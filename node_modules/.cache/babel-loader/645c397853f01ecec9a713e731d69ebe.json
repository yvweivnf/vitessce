{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { CullingVolume, Plane, AxisAlignedBoundingBox, makeOrientedBoundingBoxFromPoints } from '@math.gl/culling';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport { osmTile2lngLat } from './utils';\nvar TILE_SIZE = 512;\nvar MAX_MAPS = 3;\nvar REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];\nvar REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);\nvar REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);\n\nvar OSMNode = /*#__PURE__*/function () {\n  function OSMNode(x, y, z) {\n    _classCallCheck(this, OSMNode);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  _createClass(OSMNode, [{\n    key: \"update\",\n    value: function update(params) {\n      var viewport = params.viewport,\n          cullingVolume = params.cullingVolume,\n          elevationBounds = params.elevationBounds,\n          minZ = params.minZ,\n          maxZ = params.maxZ,\n          bounds = params.bounds,\n          offset = params.offset,\n          project = params.project;\n      var boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n      if (bounds && !this.insideBounds(bounds)) {\n        return false;\n      }\n\n      var isInside = cullingVolume.computeVisibility(boundingVolume);\n\n      if (isInside < 0) {\n        return false;\n      }\n\n      if (!this.childVisible) {\n        var z = this.z;\n\n        if (z < maxZ && z >= minZ) {\n          var distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;\n          z += Math.floor(Math.log2(distance));\n        }\n\n        if (z >= maxZ) {\n          this.selected = true;\n          return true;\n        }\n      }\n\n      this.selected = false;\n      this.childVisible = true;\n\n      var _iterator = _createForOfIteratorHelper(this.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          child.update(params);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getSelected\",\n    value: function getSelected() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (this.selected) {\n        result.push(this);\n      }\n\n      if (this._children) {\n        var _iterator2 = _createForOfIteratorHelper(this._children),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var node = _step2.value;\n            node.getSelected(result);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"insideBounds\",\n    value: function insideBounds(_ref) {\n      var _ref3 = _slicedToArray(_ref, 4),\n          minX = _ref3[0],\n          minY = _ref3[1],\n          maxX = _ref3[2],\n          maxY = _ref3[3];\n\n      var scale = Math.pow(2, this.z);\n      var extent = TILE_SIZE / scale;\n      return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;\n    }\n  }, {\n    key: \"getBoundingVolume\",\n    value: function getBoundingVolume(zRange, worldOffset, project) {\n      if (project) {\n        var refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n        var refPointPositions = [];\n\n        var _iterator3 = _createForOfIteratorHelper(refPoints),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var p = _step3.value;\n            var lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n            lngLat[2] = zRange[0];\n            refPointPositions.push(project(lngLat));\n\n            if (zRange[0] !== zRange[1]) {\n              lngLat[2] = zRange[1];\n              refPointPositions.push(project(lngLat));\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        return makeOrientedBoundingBoxFromPoints(refPointPositions);\n      }\n\n      var scale = Math.pow(2, this.z);\n      var extent = TILE_SIZE / scale;\n      var originX = this.x * extent + worldOffset * TILE_SIZE;\n      var originY = TILE_SIZE - (this.y + 1) * extent;\n      return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      if (!this._children) {\n        var x = this.x * 2;\n        var y = this.y * 2;\n        var z = this.z + 1;\n        this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];\n      }\n\n      return this._children;\n    }\n  }]);\n\n  return OSMNode;\n}();\n\nexport function getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  var project = viewport.resolution ? viewport.projectPosition : null;\n  var planes = Object.values(viewport.getFrustumPlanes()).map(function (_ref2) {\n    var normal = _ref2.normal,\n        distance = _ref2.distance;\n    return new Plane(normal.clone().negate(), distance);\n  });\n  var cullingVolume = new CullingVolume(planes);\n  var unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  var elevationMin = zRange && zRange[0] * unitsPerMeter || 0;\n  var elevationMax = zRange && zRange[1] * unitsPerMeter || 0;\n  var minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  if (bounds) {\n    var _bounds = bounds,\n        _bounds2 = _slicedToArray(_bounds, 4),\n        minLng = _bounds2[0],\n        minLat = _bounds2[1],\n        maxLng = _bounds2[2],\n        maxLat = _bounds2[3];\n\n    var topLeft = lngLatToWorld([minLng, maxLat]);\n    var bottomRight = lngLatToWorld([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n\n  var root = new OSMNode(0, 0, 0);\n  var traversalParams = {\n    viewport: viewport,\n    project: project,\n    cullingVolume: cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ: minZ,\n    maxZ: maxZ,\n    bounds: bounds,\n    offset: 0\n  };\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    traversalParams.offset = -1;\n\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n\n    traversalParams.offset = 1;\n\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}","map":{"version":3,"sources":["../../../src/tile-layer/tile-2d-traversal.js"],"names":["TILE_SIZE","MAX_MAPS","REF_POINTS_5","REF_POINTS_9","REF_POINTS_11","constructor","x","y","z","project","boundingVolume","bounds","isInside","cullingVolume","distance","viewport","Math","child","result","node","scale","extent","refPoints","refPointPositions","lngLat","osmTile2lngLat","p","zRange","makeOrientedBoundingBoxFromPoints","originX","worldOffset","originY","planes","normal","unitsPerMeter","elevationMin","elevationMax","minZ","topLeft","lngLatToWorld","bottomRight","root","traversalParams","elevationBounds","maxZ","offset"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport {\n  CullingVolume,\n  Plane,\n  AxisAlignedBoundingBox,\n  makeOrientedBoundingBoxFromPoints\n} from '@math.gl/culling';\nimport {lngLatToWorld} from '@math.gl/web-mercator';\nimport {osmTile2lngLat} from './utils';\n\nconst TILE_SIZE = 512;\n// number of world copies to check\nconst MAX_MAPS = 3;\n// for calculating bounding volume of a tile in a non-web-mercator viewport\nconst REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]]; // 4 corners and center\nconst REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]); // 4 corners, center and 4 mid points\nconst REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]); // 2 additional points on equator for top tile\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [\n        new OSMNode(x, y, z),\n        new OSMNode(x, y + 1, z),\n        new OSMNode(x + 1, y, z),\n        new OSMNode(x + 1, y + 1, z)\n      ];\n    }\n    return this._children;\n  }\n\n  update(params) {\n    const {viewport, cullingVolume, elevationBounds, minZ, maxZ, bounds, offset, project} = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n    // First, check if this tile is visible\n    if (bounds && !this.insideBounds(bounds)) {\n      return false;\n    }\n\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n    if (isInside < 0) {\n      return false;\n    }\n\n    // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester\n    if (!this.childVisible) {\n      let {z} = this;\n      if (z < maxZ && z >= minZ) {\n        // Adjust LOD\n        // If the tile is far enough from the camera, accept a lower zoom level\n        const distance =\n          (boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale) / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n      if (z >= maxZ) {\n        // LOD is acceptable\n        this.selected = true;\n        return true;\n      }\n    }\n\n    // LOD is not enough, recursively test child tiles\n    this.selected = false;\n    this.childVisible = true;\n    for (const child of this.children) {\n      child.update(params);\n    }\n    return true;\n  }\n\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n    return result;\n  }\n\n  insideBounds([minX, minY, maxX, maxY]) {\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n\n    return (\n      this.x * extent < maxX &&\n      this.y * extent < maxY &&\n      (this.x + 1) * extent > minX &&\n      (this.y + 1) * extent > minY\n    );\n  }\n\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      // Custom projection\n      // Estimate bounding box from sample points\n      // At low zoom level we need more samples to calculate the bounding volume correctly\n      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n\n      // Convert from tile-relative coordinates to common space\n      const refPointPositions = [];\n      for (const p of refPoints) {\n        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n        lngLat[2] = zRange[0];\n        refPointPositions.push(project(lngLat));\n\n        if (zRange[0] !== zRange[1]) {\n          // Account for the elevation volume\n          lngLat[2] = zRange[1];\n          refPointPositions.push(project(lngLat));\n        }\n      }\n\n      return makeOrientedBoundingBoxFromPoints(refPointPositions);\n    }\n\n    // Use WebMercator projection\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    // deck's common space is y-flipped\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n\n    return new AxisAlignedBoundingBox(\n      [originX, originY, zRange[0]],\n      [originX + extent, originY + extent, zRange[1]]\n    );\n  }\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  const project = viewport.resolution ? viewport.projectPosition : null;\n\n  // Get the culling volume of the current camera\n  const planes = Object.values(viewport.getFrustumPlanes()).map(\n    ({normal, distance}) => new Plane(normal.clone().negate(), distance)\n  );\n  const cullingVolume = new CullingVolume(planes);\n\n  // Project zRange from meters to common space\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = (zRange && zRange[0] * unitsPerMeter) || 0;\n  const elevationMax = (zRange && zRange[1] * unitsPerMeter) || 0;\n\n  // Always load at the current zoom level if pitch is small\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  // Map extent to OSM position\n  if (bounds) {\n    const [minLng, minLat, maxLng, maxLat] = bounds;\n    const topLeft = lngLatToWorld([minLng, maxLat]);\n    const bottomRight = lngLatToWorld([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    bounds,\n    // num. of worlds from the center. For repeated maps\n    offset: 0\n  };\n\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    // Check worlds in repeated maps\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}\n"]},"metadata":{},"sourceType":"module"}