{"ast":null,"code":"import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nconst array8 = n => new Uint8Array(n);\n\nconst array16 = n => new Uint16Array(n);\n\nconst array32 = n => new Uint32Array(n);\n/**\n * Maintains CrossFilter state.\n */\n\n\nfunction Bitmaps() {\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n\n      let t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n\n      for (j = i; i < n; ++i) {\n        t = data[i];\n\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) {\n      curr[k] |= one;\n    },\n\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n\n    resize(n, m) {\n      const k = curr.length;\n\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension(index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n\n      return dim;\n    }\n\n  };\n}\n/**\n * Maintains a list of values, sorted by key.\n */\n\n\nfunction SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n          n1 = data.length,\n          addi = array32(n1);\n    let addv = Array(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0,\n        key,\n        index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = output.rem = output.add,\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n\n    if (pulse.mod.length) {\n      modMap = {};\n\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(),\n        j,\n        key,\n        add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0,\n        i,\n        q; // survey how many queries have changed\n\n    output.filters = 0;\n\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n\n});\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n          // bit mask where zeros -> dims to ignore\n    bitmap = _.filter,\n          mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter\n\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n\n});\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-crossfilter/build/vega-crossfilter.module.js"],"names":["permute","bisectLeft","bisectRight","Transform","inherits","array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","Bitmaps","width","data","seen","curr","array","prev","lengthen","length","add","i","j","t","_index","push","remove","num","map","copy","Array","reindex","size","reset","k","all","set","one","clear","resize","m","Math","max","constructor","Dimension","index","query","bit","zero","range","slice","bisect","onAdd","added","dim","value","idx","lo","hi","n1","SortedIndex","insert","key","base","n0","addi","addv","oldv","oldi","sort","merge","values","call","a","b","x","y","value0","index0","value1","index1","i0","i1","CrossFilter","params","_indices","_dims","Definition","transform","_","pulse","init","modified","fields","some","f","reinit","eval","indices","dims","fname","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","source","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","ResolveFilter","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","REM","c","SOURCE","crossfilter","resolvefilter"],"mappings":"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","sourcesContent":["import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nconst array8 = n => new Uint8Array(n);\nconst array16 = n => new Uint16Array(n);\nconst array32 = n => new Uint32Array(n);\n\n/**\n * Maintains CrossFilter state.\n */\n\nfunction Bitmaps() {\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n\n      let t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n\n      for (j = i; i < n; ++i) {\n        t = data[i];\n\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) {\n      curr[k] |= one;\n    },\n\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n\n    resize(n, m) {\n      const k = curr.length;\n\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension (index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n\n      return dim;\n    }\n\n  };\n}\n\n/**\n * Maintains a list of values, sorted by key.\n */\n\nfunction SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n          n1 = data.length,\n          addi = array32(n1);\n    let addv = Array(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0,\n        key,\n        index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = output.rem = output.add,\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n\n    if (pulse.mod.length) {\n      modMap = {};\n\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(),\n        j,\n        key,\n        add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0,\n        i,\n        q; // survey how many queries have changed\n\n    output.filters = 0;\n\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n\n});\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n          // bit mask where zeros -> dims to ignore\n    bitmap = _.filter,\n          mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter\n\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n\n});\n\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };\n"]},"metadata":{},"sourceType":"module"}