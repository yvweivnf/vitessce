{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n\nvar helpers_1 = require(\"@turf/helpers\");\n\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\n\n\nfunction destination(origin, distance, bearing, options) {\n  if (options === void 0) {\n    options = {};\n  } // Handle input\n\n\n  var coordinates1 = invariant_1.getCoord(origin);\n  var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n  var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n  var bearingRad = helpers_1.degreesToRadians(bearing);\n  var radians = helpers_1.lengthToRadians(distance, options.units); // Main\n\n  var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n  var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n  var lng = helpers_1.radiansToDegrees(longitude2);\n  var lat = helpers_1.radiansToDegrees(latitude2);\n  return helpers_1.point([lng, lat], options.properties);\n}\n\nexports.default = destination;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/destination/index.js"],"names":["Object","defineProperty","exports","value","helpers_1","require","invariant_1","destination","origin","distance","bearing","options","coordinates1","getCoord","longitude1","degreesToRadians","latitude1","bearingRad","radians","lengthToRadians","units","latitude2","Math","asin","sin","cos","longitude2","atan2","lng","radiansToDegrees","lat","point","properties","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C,E,CACA;AACA;;AACA,IAAIC,SAAS,GAAGC,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,iBAAD,CAAzB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAASE,WAAT,CAAqBC,MAArB,EAA6BC,QAA7B,EAAuCC,OAAvC,EAAgDC,OAAhD,EAAyD;AACrD,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe,GADY,CAErD;;;AACA,MAAIC,YAAY,GAAGN,WAAW,CAACO,QAAZ,CAAqBL,MAArB,CAAnB;AACA,MAAIM,UAAU,GAAGV,SAAS,CAACW,gBAAV,CAA2BH,YAAY,CAAC,CAAD,CAAvC,CAAjB;AACA,MAAII,SAAS,GAAGZ,SAAS,CAACW,gBAAV,CAA2BH,YAAY,CAAC,CAAD,CAAvC,CAAhB;AACA,MAAIK,UAAU,GAAGb,SAAS,CAACW,gBAAV,CAA2BL,OAA3B,CAAjB;AACA,MAAIQ,OAAO,GAAGd,SAAS,CAACe,eAAV,CAA0BV,QAA1B,EAAoCE,OAAO,CAACS,KAA5C,CAAd,CAPqD,CAQrD;;AACA,MAAIC,SAAS,GAAGC,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACE,GAAL,CAASR,SAAT,IAAsBM,IAAI,CAACG,GAAL,CAASP,OAAT,CAAtB,GACtBI,IAAI,CAACG,GAAL,CAAST,SAAT,IAAsBM,IAAI,CAACE,GAAL,CAASN,OAAT,CAAtB,GAA0CI,IAAI,CAACG,GAAL,CAASR,UAAT,CAD9B,CAAhB;AAEA,MAAIS,UAAU,GAAGZ,UAAU,GAAGQ,IAAI,CAACK,KAAL,CAAWL,IAAI,CAACE,GAAL,CAASP,UAAT,IAAuBK,IAAI,CAACE,GAAL,CAASN,OAAT,CAAvB,GAA2CI,IAAI,CAACG,GAAL,CAAST,SAAT,CAAtD,EAA2EM,IAAI,CAACG,GAAL,CAASP,OAAT,IAAoBI,IAAI,CAACE,GAAL,CAASR,SAAT,IAAsBM,IAAI,CAACE,GAAL,CAASH,SAAT,CAArH,CAA9B;AACA,MAAIO,GAAG,GAAGxB,SAAS,CAACyB,gBAAV,CAA2BH,UAA3B,CAAV;AACA,MAAII,GAAG,GAAG1B,SAAS,CAACyB,gBAAV,CAA2BR,SAA3B,CAAV;AACA,SAAOjB,SAAS,CAAC2B,KAAV,CAAgB,CAACH,GAAD,EAAME,GAAN,CAAhB,EAA4BnB,OAAO,CAACqB,UAApC,CAAP;AACH;;AACD9B,OAAO,CAAC+B,OAAR,GAAkB1B,WAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n"]},"metadata":{},"sourceType":"script"}