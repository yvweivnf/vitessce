{"ast":null,"code":"import * as log from '../../log';\nimport * as optimizers from './optimizers';\nimport { moveFacetDown } from './subtree';\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n/**\n * Iterates over a dataflow graph and checks whether all links are consistent.\n */\n\nexport function checkLinks(nodes) {\n  for (const node of nodes) {\n    for (const child of node.children) {\n      if (child.parent !== node) {\n        // log.error('Dataflow graph is inconsistent.', node, child);\n        return false;\n      }\n    }\n\n    if (!checkLinks(node.children)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n */\n\nfunction runOptimizer(optimizer, nodes) {\n  let modified = false;\n\n  for (const node of nodes) {\n    modified = optimizer.optimize(node) || modified;\n  }\n\n  return modified;\n}\n\nfunction optimizationDataflowHelper(dataComponent, model, firstPass) {\n  let roots = dataComponent.sources;\n  let modified = false;\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots) || modified;\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots) || modified; // remove source nodes that don't have any children because they also don't have output nodes\n\n  roots = roots.filter(r => r.numChildren() > 0);\n  modified = runOptimizer(new optimizers.RemoveUnusedSubtrees(), roots) || modified;\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  if (!firstPass) {\n    // Only run these optimizations after the optimizer has moved down the facet node.\n    // With this change, we can be more aggressive in the optimizations.\n    modified = runOptimizer(new optimizers.MoveParseUp(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeBins(model), roots) || modified;\n    modified = runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeParse(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeAggregates(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeIdenticalNodes(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeOutputs(), roots) || modified;\n  }\n\n  dataComponent.sources = roots;\n  return modified;\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\n\n\nexport function optimizeDataflow(data, model) {\n  // check before optimizations\n  checkLinks(data.sources);\n  let firstPassCounter = 0;\n  let secondPassCounter = 0;\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model, true)) {\n      break;\n    }\n\n    firstPassCounter++;\n  } // move facets down and make a copy of the subtree so that we can have scales at the top level\n\n\n  data.sources.map(moveFacetDown);\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model, false)) {\n      break;\n    }\n\n    secondPassCounter++;\n  } // check after optimizations\n\n\n  checkLinks(data.sources);\n\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/data/optimize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../../log';\nimport * as optimizers from './optimizers';\nimport { moveFacetDown } from './subtree';\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n/**\n * Iterates over a dataflow graph and checks whether all links are consistent.\n */\nexport function checkLinks(nodes) {\n    for (const node of nodes) {\n        for (const child of node.children) {\n            if (child.parent !== node) {\n                // log.error('Dataflow graph is inconsistent.', node, child);\n                return false;\n            }\n        }\n        if (!checkLinks(node.children)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n */\nfunction runOptimizer(optimizer, nodes) {\n    let modified = false;\n    for (const node of nodes) {\n        modified = optimizer.optimize(node) || modified;\n    }\n    return modified;\n}\nfunction optimizationDataflowHelper(dataComponent, model, firstPass) {\n    let roots = dataComponent.sources;\n    let modified = false;\n    modified = runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots) || modified;\n    modified = runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots) || modified;\n    // remove source nodes that don't have any children because they also don't have output nodes\n    roots = roots.filter(r => r.numChildren() > 0);\n    modified = runOptimizer(new optimizers.RemoveUnusedSubtrees(), roots) || modified;\n    roots = roots.filter(r => r.numChildren() > 0);\n    if (!firstPass) {\n        // Only run these optimizations after the optimizer has moved down the facet node.\n        // With this change, we can be more aggressive in the optimizations.\n        modified = runOptimizer(new optimizers.MoveParseUp(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeBins(model), roots) || modified;\n        modified = runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeParse(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeAggregates(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeTimeUnits(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeIdenticalNodes(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeOutputs(), roots) || modified;\n    }\n    dataComponent.sources = roots;\n    return modified;\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(data, model) {\n    // check before optimizations\n    checkLinks(data.sources);\n    let firstPassCounter = 0;\n    let secondPassCounter = 0;\n    for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n        if (!optimizationDataflowHelper(data, model, true)) {\n            break;\n        }\n        firstPassCounter++;\n    }\n    // move facets down and make a copy of the subtree so that we can have scales at the top level\n    data.sources.map(moveFacetDown);\n    for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n        if (!optimizationDataflowHelper(data, model, false)) {\n            break;\n        }\n        secondPassCounter++;\n    }\n    // check after optimizations\n    checkLinks(data.sources);\n    if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n        log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n    }\n}\n//# sourceMappingURL=optimize.js.map"]},"metadata":{},"sourceType":"module"}