{"ast":null,"code":"import { selector as parseSelector } from 'vega-event-selector';\nimport { array, isObject, isString, stringValue } from 'vega-util';\nimport { selectionCompilers, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, entries, replacePathInField, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { DataSourceType } from '../../data';\nexport function parseUnitSelection(model, selDefs) {\n  var _a;\n\n  const selCmpts = {};\n  const selectionConfig = model.config.selection;\n  if (!selDefs || !selDefs.length) return selCmpts;\n\n  for (const def of selDefs) {\n    const name = varName(def.name);\n    const selDef = def.select;\n    const type = isString(selDef) ? selDef : selDef.type;\n    const defaults = isObject(selDef) ? duplicate(selDef) : {\n      type\n    }; // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n\n    const cfg = selectionConfig[type];\n\n    for (const key in cfg) {\n      // Project transform applies its defaults.\n      if (key === 'fields' || key === 'encodings') {\n        continue;\n      }\n\n      if (key === 'mark') {\n        defaults[key] = Object.assign(Object.assign({}, cfg[key]), defaults[key]);\n      }\n\n      if (defaults[key] === undefined || defaults[key] === true) {\n        defaults[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : defaults[key];\n      }\n    }\n\n    const selCmpt = selCmpts[name] = Object.assign(Object.assign({}, defaults), {\n      name,\n      type,\n      init: def.value,\n      bind: def.bind,\n      events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on))\n    });\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.parse) {\n        c.parse(model, selCmpt, def);\n      }\n    }\n  }\n\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, pred, dfnode, datum = 'datum') {\n  const name = isString(pred) ? pred : pred.param;\n  const vname = varName(name);\n  const store = stringValue(vname + STORE);\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n    return `!!${vname}`;\n  }\n\n  if (selCmpt.project.timeUnit) {\n    const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n    const tunode = selCmpt.project.timeUnit.clone();\n\n    if (child.parent) {\n      tunode.insertAsParentOf(child);\n    } else {\n      child.parent = tunode;\n    }\n  }\n\n  const test = `vlSelectionTest(${store}, ${datum}${selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`}`;\n  const length = `length(data(${store}))`;\n  return pred.empty === false ? `${length} && ${test}` : `!${length} || ${test}`;\n}\nexport function parseSelectionExtent(model, name, extent) {\n  const vname = varName(name);\n  const encoding = extent['encoding'];\n  let field = extent['field'];\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat it as a variable parameter.\n    return vname;\n  }\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n\n    if (selCmpt.project.items.length > 1) {\n      warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' + `Using \"field\": ${stringValue(field)}.`);\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn((!encodings.length ? 'No ' : 'Multiple ') + `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.param)}. ` + `Using \"field\": ${stringValue(field)}.`);\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return `${selCmpt.name}[${stringValue(replacePathInField(field))}]`;\n}\nexport function materializeSelections(model, main) {\n  var _a;\n\n  for (const [selection, selCmpt] of entries((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, {\n      param: selection\n    }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/selection/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { selector as parseSelector } from 'vega-event-selector';\nimport { array, isObject, isString, stringValue } from 'vega-util';\nimport { selectionCompilers, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, entries, replacePathInField, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { DataSourceType } from '../../data';\nexport function parseUnitSelection(model, selDefs) {\n    var _a;\n    const selCmpts = {};\n    const selectionConfig = model.config.selection;\n    if (!selDefs || !selDefs.length)\n        return selCmpts;\n    for (const def of selDefs) {\n        const name = varName(def.name);\n        const selDef = def.select;\n        const type = isString(selDef) ? selDef : selDef.type;\n        const defaults = isObject(selDef) ? duplicate(selDef) : { type };\n        // Set default values from config if a property hasn't been specified,\n        // or if it is true. E.g., \"translate\": true should use the default\n        // event handlers for translate. However, true may be a valid value for\n        // a property (e.g., \"nearest\": true).\n        const cfg = selectionConfig[type];\n        for (const key in cfg) {\n            // Project transform applies its defaults.\n            if (key === 'fields' || key === 'encodings') {\n                continue;\n            }\n            if (key === 'mark') {\n                defaults[key] = Object.assign(Object.assign({}, cfg[key]), defaults[key]);\n            }\n            if (defaults[key] === undefined || defaults[key] === true) {\n                defaults[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : defaults[key];\n            }\n        }\n        const selCmpt = (selCmpts[name] = Object.assign(Object.assign({}, defaults), { name,\n            type, init: def.value, bind: def.bind, events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on)) }));\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.parse) {\n                c.parse(model, selCmpt, def);\n            }\n        }\n    }\n    return selCmpts;\n}\nexport function parseSelectionPredicate(model, pred, dfnode, datum = 'datum') {\n    const name = isString(pred) ? pred : pred.param;\n    const vname = varName(name);\n    const store = stringValue(vname + STORE);\n    let selCmpt;\n    try {\n        selCmpt = model.getSelectionComponent(vname, name);\n    }\n    catch (e) {\n        // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n        return `!!${vname}`;\n    }\n    if (selCmpt.project.timeUnit) {\n        const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n        const tunode = selCmpt.project.timeUnit.clone();\n        if (child.parent) {\n            tunode.insertAsParentOf(child);\n        }\n        else {\n            child.parent = tunode;\n        }\n    }\n    const test = `vlSelectionTest(${store}, ${datum}${selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`}`;\n    const length = `length(data(${store}))`;\n    return pred.empty === false ? `${length} && ${test}` : `!${length} || ${test}`;\n}\nexport function parseSelectionExtent(model, name, extent) {\n    const vname = varName(name);\n    const encoding = extent['encoding'];\n    let field = extent['field'];\n    let selCmpt;\n    try {\n        selCmpt = model.getSelectionComponent(vname, name);\n    }\n    catch (e) {\n        // If a selection isn't found, treat it as a variable parameter.\n        return vname;\n    }\n    if (!encoding && !field) {\n        field = selCmpt.project.items[0].field;\n        if (selCmpt.project.items.length > 1) {\n            warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n                `Using \"field\": ${stringValue(field)}.`);\n        }\n    }\n    else if (encoding && !field) {\n        const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n        if (!encodings.length || encodings.length > 1) {\n            field = selCmpt.project.items[0].field;\n            warn((!encodings.length ? 'No ' : 'Multiple ') +\n                `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.param)}. ` +\n                `Using \"field\": ${stringValue(field)}.`);\n        }\n        else {\n            field = encodings[0].field;\n        }\n    }\n    return `${selCmpt.name}[${stringValue(replacePathInField(field))}]`;\n}\nexport function materializeSelections(model, main) {\n    var _a;\n    for (const [selection, selCmpt] of entries((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const lookupName = model.getName(`lookup_${selection}`);\n        model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, { param: selection }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n    }\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}