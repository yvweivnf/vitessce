{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\n\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  var _d, _e;\n\n  (_a = legend.encode) !== null && _a !== void 0 ? _a : legend.encode = {};\n  (_b = (_d = legend.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};\n  (_c = (_e = legend.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {}; // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  legend.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleLegends(model) {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  const legends = vals(legendByDomain).flat().map(l => assembleLegend(l, model.config)).filter(l => l !== undefined);\n  return legends;\n}\nexport function assembleLegend(legendCmpt, config) {\n  var _a, _b, _c;\n\n  const _d = legendCmpt.combine(),\n        {\n    disable,\n    labelExpr,\n    selections\n  } = _d,\n        legend = __rest(_d, [\"disable\", \"labelExpr\", \"selections\"]);\n\n  if (disable) {\n    return undefined;\n  }\n\n  if (config.aria === false && legend.aria == undefined) {\n    legend.aria = false;\n  }\n\n  if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {\n    const out = legend.encode.symbols.update;\n\n    if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n      // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n      out.stroke = {\n        value: 'transparent'\n      };\n    } // Remove properties that the legend is encoding.\n\n\n    for (const property of LEGEND_SCALE_CHANNELS) {\n      if (legend[property]) {\n        delete out[property];\n      }\n    }\n  }\n\n  if (!legend.title) {\n    // title schema doesn't include null, ''\n    delete legend.title;\n  }\n\n  if (labelExpr !== undefined) {\n    let expr = labelExpr;\n\n    if (((_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) && isSignalRef(legend.encode.labels.update.text)) {\n      expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n    }\n\n    setLegendEncode(legend, 'labels', 'text', {\n      signal: expr\n    });\n  }\n\n  return legend;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n    var _a, _b, _c;\n    var _d, _e;\n    (_a = legend.encode) !== null && _a !== void 0 ? _a : (legend.encode = {});\n    (_b = (_d = legend.encode)[part]) !== null && _b !== void 0 ? _b : (_d[part] = {});\n    (_c = (_e = legend.encode[part]).update) !== null && _c !== void 0 ? _c : (_e.update = {});\n    // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n    legend.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleLegends(model) {\n    const legendComponentIndex = model.component.legends;\n    const legendByDomain = {};\n    for (const channel of keys(legendComponentIndex)) {\n        const scaleComponent = model.getScaleComponent(channel);\n        const domainHash = stringify(scaleComponent.get('domains'));\n        if (legendByDomain[domainHash]) {\n            for (const mergedLegendComponent of legendByDomain[domainHash]) {\n                const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n                if (!merged) {\n                    // If cannot merge, need to add this legend separately\n                    legendByDomain[domainHash].push(legendComponentIndex[channel]);\n                }\n            }\n        }\n        else {\n            legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n        }\n    }\n    const legends = vals(legendByDomain)\n        .flat()\n        .map(l => assembleLegend(l, model.config))\n        .filter(l => l !== undefined);\n    return legends;\n}\nexport function assembleLegend(legendCmpt, config) {\n    var _a, _b, _c;\n    const _d = legendCmpt.combine(), { disable, labelExpr, selections } = _d, legend = __rest(_d, [\"disable\", \"labelExpr\", \"selections\"]);\n    if (disable) {\n        return undefined;\n    }\n    if (config.aria === false && legend.aria == undefined) {\n        legend.aria = false;\n    }\n    if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {\n        const out = legend.encode.symbols.update;\n        if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n            // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n            out.stroke = { value: 'transparent' };\n        }\n        // Remove properties that the legend is encoding.\n        for (const property of LEGEND_SCALE_CHANNELS) {\n            if (legend[property]) {\n                delete out[property];\n            }\n        }\n    }\n    if (!legend.title) {\n        // title schema doesn't include null, ''\n        delete legend.title;\n    }\n    if (labelExpr !== undefined) {\n        let expr = labelExpr;\n        if (((_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) && isSignalRef(legend.encode.labels.update.text)) {\n            expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n        }\n        setLegendEncode(legend, 'labels', 'text', { signal: expr });\n    }\n    return legend;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}