{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { normalizeTransitionSettings } from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\nvar TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\n\nvar UniformTransitionManager = /*#__PURE__*/function () {\n  function UniformTransitionManager(timeline) {\n    _classCallCheck(this, UniformTransitionManager);\n\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  _createClass(UniformTransitionManager, [{\n    key: \"add\",\n    value: function add(key, fromValue, toValue, settings) {\n      var transitions = this.transitions;\n\n      if (transitions.has(key)) {\n        var _transition = transitions.get(key);\n\n        var _transition$value = _transition.value,\n            value = _transition$value === void 0 ? _transition.settings.fromValue : _transition$value;\n        fromValue = value;\n        this.remove(key);\n      }\n\n      settings = normalizeTransitionSettings(settings);\n\n      if (!settings) {\n        return;\n      }\n\n      var TransitionType = TRANSITION_TYPES[settings.type];\n\n      if (!TransitionType) {\n        log.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n        return;\n      }\n\n      var transition = new TransitionType(this.timeline);\n      transition.start(_objectSpread({}, settings, {\n        fromValue: fromValue,\n        toValue: toValue\n      }));\n      transitions.set(key, transition);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var transitions = this.transitions;\n\n      if (transitions.has(key)) {\n        transitions.get(key).cancel();\n        transitions.delete(key);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var propsInTransition = {};\n\n      var _iterator = _createForOfIteratorHelper(this.transitions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              transition = _step$value[1];\n\n          transition.update();\n          propsInTransition[key] = transition.value;\n\n          if (!transition.inProgress) {\n            this.remove(key);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return propsInTransition;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _iterator2 = _createForOfIteratorHelper(this.transitions.keys()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          this.remove(key);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"active\",\n    get: function get() {\n      return this.transitions.size > 0;\n    }\n  }]);\n\n  return UniformTransitionManager;\n}();\n\nexport { UniformTransitionManager as default };","map":{"version":3,"sources":["../../../src/lib/uniform-transition-manager.js"],"names":["TRANSITION_TYPES","interpolation","spring","CPUSpringTransition","constructor","transitions","transition","value","fromValue","settings","normalizeTransitionSettings","TransitionType","log","toValue","propsInTransition"],"mappings":";;;;;AAAA,SAAA,2BAAA,QAAA,wCAAA;AACA,OAAA,0BAAA,MAAA,6CAAA;AACA,OAAA,mBAAA,MAAA,sCAAA;AACA,OAAA,GAAA,MAAA,cAAA;AAEA,IAAMA,gBAAgB,GAAG;AACvBC,EAAAA,aAAa,EADU,0BAAA;AAEvBC,EAAAA,MAAM,EAAEC;AAFe,CAAzB;;IAKe,wB;AACbC,oCAAW,QAAXA,EAAsB;AAAA;;AACpB,SAAA,WAAA,GAAmB,IAAnB,GAAmB,EAAnB;AACA,SAAA,QAAA,GAAA,QAAA;AACD;;;;wBAME,G,EAAA,S,EAAA,O,EAAA,Q,EAAoC;AAAA,UAC9BC,WAD8B,GACrC,IADqC,CAC9BA,WAD8B;;AAErC,UAAIA,WAAW,CAAXA,GAAAA,CAAJ,GAAIA,CAAJ,EAA0B;AACxB,YAAMC,WAAU,GAAGD,WAAW,CAAXA,GAAAA,CAAnB,GAAmBA,CAAnB;;AADwB,gCAGxB,WAHwB,CAGjBE,KAHiB;AAAA,YAGjBA,KAHiB,kCAGTD,WAAU,CAAVA,QAAAA,CAAoBE,SAHX;AAKxBA,QAAAA,SAAS,GAATA,KAAAA;AACA,aAAA,MAAA,CAAA,GAAA;AACD;;AAEDC,MAAAA,QAAQ,GAAGC,2BAA2B,CAAtCD,QAAsC,CAAtCA;;AACA,UAAI,CAAJ,QAAA,EAAe;AACb;AACD;;AAED,UAAME,cAAc,GAAGX,gBAAgB,CAACS,QAAQ,CAAhD,IAAuC,CAAvC;;AACA,UAAI,CAAJ,cAAA,EAAqB;AACnBG,QAAAA,GAAG,CAAHA,KAAAA,CAAAA,gCAAAA,MAAAA,CAA0CH,QAAQ,CAAlDG,IAAAA,EAAAA,GAAAA,CAAAA;AACA;AACD;;AACD,UAAMN,UAAU,GAAG,IAAA,cAAA,CAAmB,KAAtC,QAAmB,CAAnB;AACAA,MAAAA,UAAU,CAAVA,KAAAA,mBAAiB,QAAjBA;AAEEE,QAAAA,SAFe,EAEfA,SAFFF;AAGEO,QAAAA,OAAAA,EAAAA;AAHFP;AAKAD,MAAAA,WAAW,CAAXA,GAAAA,CAAAA,GAAAA,EAAAA,UAAAA;AACD;;;2BAEK,G,EAAM;AAAA,UACHA,WADG,GACV,IADU,CACHA,WADG;;AAEV,UAAIA,WAAW,CAAXA,GAAAA,CAAJ,GAAIA,CAAJ,EAA0B;AACxBA,QAAAA,WAAW,CAAXA,GAAAA,CAAAA,GAAAA,EAAAA,MAAAA;AACAA,QAAAA,WAAW,CAAXA,MAAAA,CAAAA,GAAAA;AACD;AACF;;;6BAEQ;AACP,UAAMS,iBAAiB,GAAvB,EAAA;;AADO,iDAGyB,KAAhC,WAHO;AAAA;;AAAA;AAGP,4DAAkD;AAAA;AAAA,cAAvC,GAAuC;AAAA,cAAlD,UAAkD;;AAChDR,UAAAA,UAAU,CAAVA,MAAAA;AACAQ,UAAAA,iBAAiB,CAAjBA,GAAiB,CAAjBA,GAAyBR,UAAU,CAAnCQ,KAAAA;;AACA,cAAI,CAACR,UAAU,CAAf,UAAA,EAA4B;AAE1B,iBAAA,MAAA,CAAA,GAAA;AACD;AACF;AAVM;AAAA;AAAA;AAAA;AAAA;;AAYP,aAAA,iBAAA;AACD;;;4BAEO;AAAA,kDACY,KAAA,WAAA,CAAlB,IAAkB,EADZ;AAAA;;AAAA;AACN,+DAA2C;AAAA,cAA3C,GAA2C;AACzC,eAAA,MAAA,CAAA,GAAA;AACD;AAHK;AAAA;AAAA;AAAA;AAAA;AAIP;;;wBA7DY;AACX,aAAO,KAAA,WAAA,CAAA,IAAA,GAAP,CAAA;AACD;;;;;;SARY,wB","sourcesContent":["import {normalizeTransitionSettings} from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\n\nexport default class UniformTransitionManager {\n  constructor(timeline) {\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  get active() {\n    return this.transitions.size > 0;\n  }\n\n  add(key, fromValue, toValue, settings) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      const transition = transitions.get(key);\n      // value may not be available if `update()` has not been called. Fallback to `fromValue`\n      const {value = transition.settings.fromValue} = transition;\n      // start from interrupted position\n      fromValue = value;\n      this.remove(key);\n    }\n\n    settings = normalizeTransitionSettings(settings);\n    if (!settings) {\n      return;\n    }\n\n    const TransitionType = TRANSITION_TYPES[settings.type];\n    if (!TransitionType) {\n      log.error(`unsupported transition type '${settings.type}'`)();\n      return;\n    }\n    const transition = new TransitionType(this.timeline);\n    transition.start({\n      ...settings,\n      fromValue,\n      toValue\n    });\n    transitions.set(key, transition);\n  }\n\n  remove(key) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      transitions.get(key).cancel();\n      transitions.delete(key);\n    }\n  }\n\n  update() {\n    const propsInTransition = {};\n\n    for (const [key, transition] of this.transitions) {\n      transition.update();\n      propsInTransition[key] = transition.value;\n      if (!transition.inProgress) {\n        // transition ended\n        this.remove(key);\n      }\n    }\n\n    return propsInTransition;\n  }\n\n  clear() {\n    for (const key of this.transitions.keys()) {\n      this.remove(key);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}