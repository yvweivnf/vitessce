{"ast":null,"code":"import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getAxisConfig } from './config';\nexport const axisRules = {\n  scale: ({\n    model,\n    channel\n  }) => model.scaleName(channel),\n  format: ({\n    fieldOrDatumDef,\n    config,\n    axis\n  }) => {\n    const {\n      format,\n      formatType\n    } = axis;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n  },\n  formatType: ({\n    axis,\n    fieldOrDatumDef,\n    scaleType\n  }) => {\n    const {\n      formatType\n    } = axis;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  grid: ({\n    fieldOrDatumDef,\n    axis,\n    scaleType\n  }) => {\n    var _a;\n\n    return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef);\n  },\n  gridScale: ({\n    model,\n    channel\n  }) => gridScale(model, channel),\n  labelAlign: ({\n    axis,\n    labelAngle,\n    orient,\n    channel\n  }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel),\n  labelAngle: ({\n    labelAngle\n  }) => labelAngle,\n  labelBaseline: ({\n    axis,\n    labelAngle,\n    orient,\n    channel\n  }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel),\n  labelFlush: ({\n    axis,\n    fieldOrDatumDef,\n    channel\n  }) => {\n    var _a;\n\n    return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel);\n  },\n  labelOverlap: ({\n    axis,\n    fieldOrDatumDef,\n    scaleType\n  }) => {\n    var _a;\n\n    return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n  },\n  // we already calculate orient in parse\n  orient: ({\n    orient\n  }) => orient,\n  tickCount: ({\n    channel,\n    model,\n    axis,\n    fieldOrDatumDef,\n    scaleType\n  }) => {\n    var _a;\n\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n    return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({\n      fieldOrDatumDef,\n      scaleType,\n      size,\n      values: axis.values\n    });\n  },\n  title: ({\n    axis,\n    model,\n    channel\n  }) => {\n    if (axis.title !== undefined) {\n      return axis.title;\n    }\n\n    const fieldDefTitle = getFieldDefTitle(model, channel);\n\n    if (fieldDefTitle !== undefined) {\n      return fieldDefTitle;\n    }\n\n    const fieldDef = model.typedFieldDef(channel);\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef2 = model.fieldDef(channel2); // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n\n    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n  },\n  values: ({\n    axis,\n    fieldOrDatumDef\n  }) => values(axis, fieldOrDatumDef),\n  zindex: ({\n    axis,\n    fieldOrDatumDef,\n    mark\n  }) => {\n    var _a;\n\n    return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef);\n  }\n}; // TODO: we need to refactor this method after we take care of config refactoring\n\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\n\nexport function defaultGrid(scaleType, fieldDef) {\n  return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);\n}\nexport function gridScale(model, channel) {\n  const gridChannel = channel === 'x' ? 'y' : 'x';\n\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n\n  return undefined;\n}\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n  const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle; // try axis value\n\n  if (labelAngle !== undefined) {\n    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n  } else {\n    // try axis config value\n    const {\n      configValue: angle\n    } = getAxisConfig('labelAngle', styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);\n\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n        return 270;\n      } // no default\n\n\n      return undefined;\n    }\n  }\n}\nexport function normalizeAngleExpr(angle) {\n  return `(((${angle.signal} % 360) + 360) % 360)`;\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n  if (angle !== undefined) {\n    if (channel === 'x') {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n        return {\n          signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` + `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n        };\n      }\n\n      if (45 < angle && angle < 135 || 225 < angle && angle < 315) {\n        return 'middle';\n      }\n\n      if (isSignalRef(orient)) {\n        const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n        return {\n          signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"`\n        };\n      }\n\n      return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n    } else {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n        const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n        return {\n          signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n        };\n      }\n\n      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {\n        return alwaysIncludeMiddle ? 'middle' : null;\n      }\n\n      if (isSignalRef(orient)) {\n        const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n        return {\n          signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"`\n        };\n      }\n\n      return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n    }\n  }\n\n  return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n  if (angle === undefined) {\n    return undefined;\n  }\n\n  const isX = channel === 'x';\n  const startAngle = isX ? 0 : 90;\n  const mainOrient = isX ? 'bottom' : 'left';\n\n  if (isSignalRef(angle)) {\n    const a = normalizeAngleExpr(angle);\n    const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n    return {\n      signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` + `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((angle + startAngle) % 180 === 0) {\n    // For bottom, use default label align so label flush still works\n    return isX ? null : 'center';\n  }\n\n  if (isSignalRef(orient)) {\n    const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n    const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n    return {\n      signal: `${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n    return 'left';\n  }\n\n  return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (hasTimeUnit && !isObject(sort) || type !== 'nominal' && type !== 'ordinal') {\n    if (scaleType === 'log' || scaleType === 'symlog') {\n      return 'greedy';\n    }\n\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultOrient(channel) {\n  return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount({\n  fieldOrDatumDef,\n  scaleType,\n  size,\n  values: vals\n}) {\n  var _a;\n\n  if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n    if (isFieldDef(fieldOrDatumDef)) {\n      if (isBinning(fieldOrDatumDef.bin)) {\n        // for binned data, we don't want more ticks than maxbins\n        return {\n          signal: `ceil(${size.signal}/10)`\n        };\n      }\n\n      if (fieldOrDatumDef.timeUnit && contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {\n        return undefined;\n      }\n    }\n\n    return {\n      signal: `ceil(${size.signal}/40)`\n    };\n  }\n\n  return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.fieldDef(channel);\n  const fieldDef2 = model.fieldDef(channel2);\n  const title1 = fieldDef ? fieldDef.title : undefined;\n  const title2 = fieldDef2 ? fieldDef2.title : undefined;\n\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n\n  return undefined;\n}\nexport function values(axis, fieldOrDatumDef) {\n  const vals = axis.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getAxisConfig } from './config';\nexport const axisRules = {\n    scale: ({ model, channel }) => model.scaleName(channel),\n    format: ({ fieldOrDatumDef, config, axis }) => {\n        const { format, formatType } = axis;\n        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n    },\n    formatType: ({ axis, fieldOrDatumDef, scaleType }) => {\n        const { formatType } = axis;\n        return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n    },\n    grid: ({ fieldOrDatumDef, axis, scaleType }) => { var _a; return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef); },\n    gridScale: ({ model, channel }) => gridScale(model, channel),\n    labelAlign: ({ axis, labelAngle, orient, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel),\n    labelAngle: ({ labelAngle }) => labelAngle,\n    labelBaseline: ({ axis, labelAngle, orient, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel),\n    labelFlush: ({ axis, fieldOrDatumDef, channel }) => { var _a; return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel); },\n    labelOverlap: ({ axis, fieldOrDatumDef, scaleType }) => {\n        var _a;\n        return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n    },\n    // we already calculate orient in parse\n    orient: ({ orient }) => orient,\n    tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType }) => {\n        var _a;\n        const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n        const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n        return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({ fieldOrDatumDef, scaleType, size, values: axis.values });\n    },\n    title: ({ axis, model, channel }) => {\n        if (axis.title !== undefined) {\n            return axis.title;\n        }\n        const fieldDefTitle = getFieldDefTitle(model, channel);\n        if (fieldDefTitle !== undefined) {\n            return fieldDefTitle;\n        }\n        const fieldDef = model.typedFieldDef(channel);\n        const channel2 = channel === 'x' ? 'x2' : 'y2';\n        const fieldDef2 = model.fieldDef(channel2);\n        // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n        return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n    },\n    values: ({ axis, fieldOrDatumDef }) => values(axis, fieldOrDatumDef),\n    zindex: ({ axis, fieldOrDatumDef, mark }) => { var _a; return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef); }\n};\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function defaultGrid(scaleType, fieldDef) {\n    return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);\n}\nexport function gridScale(model, channel) {\n    const gridChannel = channel === 'x' ? 'y' : 'x';\n    if (model.getScaleComponent(gridChannel)) {\n        return model.scaleName(gridChannel);\n    }\n    return undefined;\n}\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n    const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;\n    // try axis value\n    if (labelAngle !== undefined) {\n        return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n    }\n    else {\n        // try axis config value\n        const { configValue: angle } = getAxisConfig('labelAngle', styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);\n        if (angle !== undefined) {\n            return normalizeAngle(angle);\n        }\n        else {\n            // get default value\n            if (channel === X &&\n                contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) &&\n                !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n                return 270;\n            }\n            // no default\n            return undefined;\n        }\n    }\n}\nexport function normalizeAngleExpr(angle) {\n    return `(((${angle.signal} % 360) + 360) % 360)`;\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n    if (angle !== undefined) {\n        if (channel === 'x') {\n            if (isSignalRef(angle)) {\n                const a = normalizeAngleExpr(angle);\n                const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n                return {\n                    signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` +\n                        `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n                };\n            }\n            if ((45 < angle && angle < 135) || (225 < angle && angle < 315)) {\n                return 'middle';\n            }\n            if (isSignalRef(orient)) {\n                const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n                return { signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"` };\n            }\n            return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n        }\n        else {\n            if (isSignalRef(angle)) {\n                const a = normalizeAngleExpr(angle);\n                const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n                const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n                return {\n                    signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n                };\n            }\n            if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n                return alwaysIncludeMiddle ? 'middle' : null;\n            }\n            if (isSignalRef(orient)) {\n                const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n                return { signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"` };\n            }\n            return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n        }\n    }\n    return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n    if (angle === undefined) {\n        return undefined;\n    }\n    const isX = channel === 'x';\n    const startAngle = isX ? 0 : 90;\n    const mainOrient = isX ? 'bottom' : 'left';\n    if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n        return {\n            signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` +\n                `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n        };\n    }\n    if ((angle + startAngle) % 180 === 0) {\n        // For bottom, use default label align so label flush still works\n        return isX ? null : 'center';\n    }\n    if (isSignalRef(orient)) {\n        const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n        const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n        return {\n            signal: `${orientIsMain} ? \"left\" : \"right\"`\n        };\n    }\n    if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n        return 'left';\n    }\n    return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n    if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n        return true;\n    }\n    return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n    // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n    if ((hasTimeUnit && !isObject(sort)) || (type !== 'nominal' && type !== 'ordinal')) {\n        if (scaleType === 'log' || scaleType === 'symlog') {\n            return 'greedy';\n        }\n        return true;\n    }\n    return undefined;\n}\nexport function defaultOrient(channel) {\n    return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount({ fieldOrDatumDef, scaleType, size, values: vals }) {\n    var _a;\n    if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n        if (isFieldDef(fieldOrDatumDef)) {\n            if (isBinning(fieldOrDatumDef.bin)) {\n                // for binned data, we don't want more ticks than maxbins\n                return { signal: `ceil(${size.signal}/10)` };\n            }\n            if (fieldOrDatumDef.timeUnit &&\n                contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {\n                return undefined;\n            }\n        }\n        return { signal: `ceil(${size.signal}/40)` };\n    }\n    return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef = model.fieldDef(channel);\n    const fieldDef2 = model.fieldDef(channel2);\n    const title1 = fieldDef ? fieldDef.title : undefined;\n    const title2 = fieldDef2 ? fieldDef2.title : undefined;\n    if (title1 && title2) {\n        return mergeTitle(title1, title2);\n    }\n    else if (title1) {\n        return title1;\n    }\n    else if (title2) {\n        return title2;\n    }\n    else if (title1 !== undefined) {\n        // falsy value to disable config\n        return title1;\n    }\n    else if (title2 !== undefined) {\n        // falsy value to disable config\n        return title2;\n    }\n    return undefined;\n}\nexport function values(axis, fieldOrDatumDef) {\n    const vals = axis.values;\n    if (isArray(vals)) {\n        return valueArray(fieldOrDatumDef, vals);\n    }\n    else if (isSignalRef(vals)) {\n        return vals;\n    }\n    return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n    if (mark === 'rect' && isDiscrete(fieldDef)) {\n        return 1;\n    }\n    return 0;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}