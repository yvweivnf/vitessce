{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\nfunction testVariable(qualifier) {\n  return new RegExp(\"\\\\b\".concat(qualifier, \"[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)\"), 'g');\n}\n\nvar ES300_REPLACEMENTS = [[/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'], [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('], [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']];\nvar ES300_VERTEX_REPLACEMENTS = [].concat(ES300_REPLACEMENTS, [[testVariable('attribute'), 'in $1'], [testVariable('varying'), 'out $1']]);\nvar ES300_FRAGMENT_REPLACEMENTS = [].concat(ES300_REPLACEMENTS, [[testVariable('varying'), 'in $1']]);\nvar ES100_REPLACEMENTS = [[/^#version[ \\t]+300[ \\t]+es/, '#version 100'], [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('], [/\\btexture\\(/g, 'texture2D('], [/\\btextureLod\\(/g, 'texture2DLodEXT(']];\nvar ES100_VERTEX_REPLACEMENTS = [].concat(ES100_REPLACEMENTS, [[testVariable('in'), 'attribute $1'], [testVariable('out'), 'varying $1']]);\nvar ES100_FRAGMENT_REPLACEMENTS = [].concat(ES100_REPLACEMENTS, [[testVariable('in'), 'varying $1']]);\nvar ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';\nvar ES300_FRAGMENT_OUTPUT_REGEX = /\\bout[ \\t]+vec4[ \\t]+(\\w+)[ \\t]*;\\n?/;\nvar REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/;\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);\n\n    case 100:\n      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);\n\n    default:\n      throw new Error(\"unknown GLSL version \".concat(targetGLSLVersion));\n  }\n}\n\nfunction convertShader(source, replacements) {\n  var _iterator = _createForOfIteratorHelper(replacements),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          pattern = _step$value[0],\n          replacement = _step$value[1];\n\n      source = source.replace(pattern, replacement);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return source;\n}\n\nfunction convertFragmentShaderTo300(source) {\n  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n  var outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n\n  if (outputMatch) {\n    var outputName = outputMatch[1];\n    source = source.replace(new RegExp(\"\\\\b\".concat(ES100_FRAGMENT_OUTPUT_NAME, \"\\\\b\"), 'g'), outputName);\n  } else {\n    var _outputName = 'fragmentColor';\n    source = source.replace(REGEX_START_OF_MAIN, function (match) {\n      return \"out vec4 \".concat(_outputName, \";\\n\").concat(match);\n    }).replace(new RegExp(\"\\\\b\".concat(ES100_FRAGMENT_OUTPUT_NAME, \"\\\\b\"), 'g'), _outputName);\n  }\n\n  return source;\n}\n\nfunction convertFragmentShaderTo100(source) {\n  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);\n  var outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n\n  if (outputMatch) {\n    var outputName = outputMatch[1];\n    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp(\"\\\\b\".concat(outputName, \"\\\\b\"), 'g'), ES100_FRAGMENT_OUTPUT_NAME);\n  }\n\n  return source;\n}","map":{"version":3,"sources":["../../../src/lib/transpile-shader.js"],"names":["ES300_REPLACEMENTS","ES300_VERTEX_REPLACEMENTS","testVariable","ES300_FRAGMENT_REPLACEMENTS","ES100_REPLACEMENTS","ES100_VERTEX_REPLACEMENTS","ES100_FRAGMENT_REPLACEMENTS","ES100_FRAGMENT_OUTPUT_NAME","ES300_FRAGMENT_OUTPUT_REGEX","REGEX_START_OF_MAIN","isVertex","convertShader","convertFragmentShaderTo300","convertFragmentShaderTo100","source","outputMatch","outputName","match"],"mappings":"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","sourcesContent":["// TRANSPILATION TABLES\n\nfunction testVariable(qualifier) {\n  /*\n    should match:\n      in float weight;\n      out vec4 positions[2];\n    should not match:\n      void f(out float a, in float b) {}\n   */\n  return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS = [\n  // Fix poorly formatted version directive\n  [/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n  // The individual `texture...()` functions were replaced with `texture()` overloads\n  [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('],\n  [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']\n];\n\nconst ES300_VERTEX_REPLACEMENTS = [\n  ...ES300_REPLACEMENTS,\n  // `attribute` keyword replaced with `in`\n  [testVariable('attribute'), 'in $1'],\n  // `varying` keyword replaced with `out`\n  [testVariable('varying'), 'out $1']\n];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS = [\n  ...ES300_REPLACEMENTS,\n  // `varying` keyword replaced with `in`\n  [testVariable('varying'), 'in $1']\n];\n\nconst ES100_REPLACEMENTS = [\n  [/^#version[ \\t]+300[ \\t]+es/, '#version 100'],\n\n  // In GLSL 1.00 ES these functions are provided by an extension\n  [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('],\n\n  // Overloads in GLSL 3.00 map to individual functions. Note that we cannot\n  // differentiate 2D,2DProj,Cube without type analysis so we choose the most common variant.\n  [/\\btexture\\(/g, 'texture2D('],\n  [/\\btextureLod\\(/g, 'texture2DLodEXT(']\n];\n\nconst ES100_VERTEX_REPLACEMENTS = [\n  ...ES100_REPLACEMENTS,\n  [testVariable('in'), 'attribute $1'],\n  [testVariable('out'), 'varying $1']\n];\n\nconst ES100_FRAGMENT_REPLACEMENTS = [\n  ...ES100_REPLACEMENTS,\n  // Replace `in` with `varying`\n  [testVariable('in'), 'varying $1']\n];\n\nconst ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';\nconst ES300_FRAGMENT_OUTPUT_REGEX = /\\bout[ \\t]+vec4[ \\t]+(\\w+)[ \\t]*;\\n?/;\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\n\n// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex\n        ? convertShader(source, ES300_VERTEX_REPLACEMENTS)\n        : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex\n        ? convertShader(source, ES100_VERTEX_REPLACEMENTS)\n        : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertShader(source, replacements) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n\nfunction convertFragmentShaderTo300(source) {\n  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source.replace(new RegExp(`\\\\b${ES100_FRAGMENT_OUTPUT_NAME}\\\\b`, 'g'), outputName);\n  } else {\n    const outputName = 'fragmentColor';\n    source = source\n      .replace(REGEX_START_OF_MAIN, match => `out vec4 ${outputName};\\n${match}`)\n      .replace(new RegExp(`\\\\b${ES100_FRAGMENT_OUTPUT_NAME}\\\\b`, 'g'), outputName);\n  }\n\n  return source;\n}\n\nfunction convertFragmentShaderTo100(source) {\n  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);\n\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source\n      .replace(ES300_FRAGMENT_OUTPUT_REGEX, '')\n      .replace(new RegExp(`\\\\b${outputName}\\\\b`, 'g'), ES100_FRAGMENT_OUTPUT_NAME);\n  }\n\n  return source;\n}\n"]},"metadata":{},"sourceType":"module"}