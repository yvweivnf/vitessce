{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { fs } from '@loaders.gl/loader-utils';\nexport function readArrayBuffer(_x, _x2, _x3) {\n  return _readArrayBuffer.apply(this, arguments);\n}\n\nfunction _readArrayBuffer() {\n  _readArrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(file, start, length) {\n    var slice;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(typeof file === 'number')) {\n              _context.next = 4;\n              break;\n            }\n\n            _context.next = 3;\n            return fs._readToArrayBuffer(file, start, length);\n\n          case 3:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 4:\n            if (!(file instanceof Blob)) {\n              file = new Blob([file]);\n            }\n\n            slice = file.slice(start, start + length);\n            _context.next = 8;\n            return readBlob(slice);\n\n          case 8:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _readArrayBuffer.apply(this, arguments);\n}\n\nexport function readBlob(_x4) {\n  return _readBlob.apply(this, arguments);\n}\n\nfunction _readBlob() {\n  _readBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blob) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return new Promise(function (resolve, reject) {\n              var fileReader = new FileReader();\n\n              fileReader.onload = function (event) {\n                var _event$target;\n\n                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n              };\n\n              fileReader.onerror = function (error) {\n                return reject(error);\n              };\n\n              fileReader.readAsArrayBuffer(blob);\n            });\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _readBlob.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/fetch/read-array-buffer.ts"],"names":["fs","file","slice","start","readBlob","fileReader","event","resolve","error","reject"],"mappings":";;AACA,SAAA,EAAA,QAAA,0BAAA;AASA,gBAAO,eAAP;AAAA;AAAA;;;8EAAO,iBAAA,IAAA,EAAA,KAAA,EAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAKD,OAAA,IAAA,KAAJ,QALK;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAMUA,EAAE,CAAFA,kBAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAb,MAAaA,CANV;;AAAA;AAAA;;AAAA;AASL,gBAAI,EAAEC,IAAI,YAAV,IAAI,CAAJ,EAA6B;AAC3BA,cAAAA,IAAI,GAAG,IAAA,IAAA,CAAS,CAAhBA,IAAgB,CAAT,CAAPA;AACD;;AACKC,YAAAA,KAZD,GAYSD,IAAI,CAAJA,KAAAA,CAAAA,KAAAA,EAAkBE,KAAK,GAArC,MAAcF,CAZT;AAAA;AAAA,mBAaQG,QAAQ,CAArB,KAAqB,CAbhB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAuBP,gBAAO,QAAP;AAAA;AAAA;;;uEAAO,kBAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACQ,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AAC5C,kBAAMC,UAAU,GAAG,IAAnB,UAAmB,EAAnB;;AACAA,cAAAA,UAAU,CAAVA,MAAAA,GAAqBC,UAAAA,KAAD,EAAA;AAAA,oBAAA,aAAA;;AAAA,uBAClBC,OAAO,CAACD,KAAD,KAAA,IAACA,IAAAA,KAAD,KAAA,KAAA,CAACA,GAAD,KAAA,CAACA,GAAD,CAAA,aAAA,GAACA,KAAK,CAAN,MAAA,MAAA,IAAA,IAAA,aAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAACA,aAAAA,CADU,MACX,CADW;AAApBD,eAAAA;;AAGAA,cAAAA,UAAU,CAAVA,OAAAA,GAAsBG,UAAAA,KAAD;AAAA,uBAAsCC,MAAM,CAAjEJ,KAAiE,CAA5C;AAAA,eAArBA;;AACAA,cAAAA,UAAU,CAAVA,iBAAAA,CAAAA,IAAAA;AANF,aAAa,CADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["//\nimport {fs} from '@loaders.gl/loader-utils';\n\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(\n  file: Blob | ArrayBuffer | string | number,\n  start: number,\n  length: number\n): Promise<ArrayBuffer> {\n  if (typeof file === 'number') {\n    return await fs._readToArrayBuffer(file, start, length);\n  }\n  // TODO - we can do better for ArrayBuffer and string\n  if (!(file instanceof Blob)) {\n    file = new Blob([file]);\n  }\n  const slice = file.slice(start, start + length);\n  return await readBlob(slice);\n}\n\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob: Blob): Promise<ArrayBuffer> {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = (event: ProgressEvent<FileReader>) =>\n      resolve(event?.target?.result as ArrayBuffer);\n    // TODO - reject with a proper Error\n    fileReader.onerror = (error: ProgressEvent<FileReader>) => reject(error);\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}