{"ast":null,"code":"import { normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { CompositeMarkNormalizer } from './base';\nimport { makeCompositeAggregatePartFactory } from './common';\nimport { errorBarParams } from './errorbar';\nexport const ERRORBAND = 'errorband';\nexport const ERRORBAND_PARTS = ['band', 'borders'];\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\nexport function normalizeErrorBand(spec, {\n  config\n}) {\n  // Need to initEncoding first so we can infer type\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAND, config);\n  const errorBandDef = markDef;\n  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n  let bandMark = {\n    type: is2D ? 'area' : 'rect'\n  };\n  let bordersMark = {\n    type: is2D ? 'line' : 'rule'\n  };\n  const interpolate = Object.assign(Object.assign({}, errorBandDef.interpolate ? {\n    interpolate: errorBandDef.interpolate\n  } : {}), errorBandDef.tension && errorBandDef.interpolate ? {\n    tension: errorBandDef.tension\n  } : {});\n\n  if (is2D) {\n    bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate), {\n      ariaRoleDescription: 'errorband'\n    });\n    bordersMark = Object.assign(Object.assign(Object.assign({}, bordersMark), interpolate), {\n      aria: false\n    });\n  } else if (errorBandDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (errorBandDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    transform,\n    layer: [...makeErrorBandPart({\n      partName: 'band',\n      mark: bandMark,\n      positionPrefix: 'lower',\n      endPositionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'lower',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })]\n  });\n}","map":{"version":3,"sources":["../../../src/compositemark/errorband.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { CompositeMarkNormalizer } from './base';\nimport { makeCompositeAggregatePartFactory } from './common';\nimport { errorBarParams } from './errorbar';\nexport const ERRORBAND = 'errorband';\nexport const ERRORBAND_PARTS = ['band', 'borders'];\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\nexport function normalizeErrorBand(spec, { config }) {\n    // Need to initEncoding first so we can infer type\n    spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });\n    const { transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAND, config);\n    const errorBandDef = markDef;\n    const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);\n    const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n    let bandMark = { type: is2D ? 'area' : 'rect' };\n    let bordersMark = { type: is2D ? 'line' : 'rule' };\n    const interpolate = Object.assign(Object.assign({}, (errorBandDef.interpolate ? { interpolate: errorBandDef.interpolate } : {})), (errorBandDef.tension && errorBandDef.interpolate ? { tension: errorBandDef.tension } : {}));\n    if (is2D) {\n        bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate), { ariaRoleDescription: 'errorband' });\n        bordersMark = Object.assign(Object.assign(Object.assign({}, bordersMark), interpolate), { aria: false });\n    }\n    else if (errorBandDef.interpolate) {\n        log.warn(log.message.errorBand1DNotSupport('interpolate'));\n    }\n    else if (errorBandDef.tension) {\n        log.warn(log.message.errorBand1DNotSupport('tension'));\n    }\n    return Object.assign(Object.assign({}, outerSpec), { transform, layer: [\n            ...makeErrorBandPart({\n                partName: 'band',\n                mark: bandMark,\n                positionPrefix: 'lower',\n                endPositionPrefix: 'upper',\n                extraEncoding: tooltipEncoding\n            }),\n            ...makeErrorBandPart({\n                partName: 'borders',\n                mark: bordersMark,\n                positionPrefix: 'lower',\n                extraEncoding: tooltipEncoding\n            }),\n            ...makeErrorBandPart({\n                partName: 'borders',\n                mark: bordersMark,\n                positionPrefix: 'upper',\n                extraEncoding: tooltipEncoding\n            })\n        ] });\n}\n//# sourceMappingURL=errorband.js.map"]},"metadata":{},"sourceType":"module"}