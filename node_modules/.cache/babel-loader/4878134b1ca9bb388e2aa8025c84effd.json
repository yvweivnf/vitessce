{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\src\\\\components\\\\spatial\\\\Spatial.js\";\nimport React, { forwardRef } from 'react';\nimport isEqual from 'lodash/isEqual';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core'; // eslint-disable-line import/no-extraneous-dependencies\n\nimport { PolygonLayer, ScatterplotLayer } from '@deck.gl/layers'; // eslint-disable-line import/no-extraneous-dependencies\n\nimport { Matrix4 } from 'math.gl';\nimport { ScaleBarLayer, MultiscaleImageLayer, AdditiveColormapExtension, ColorPaletteExtension } from '@hms-dbmi/viv';\nimport { getSelectionLayers } from '../../layers';\nimport { cellLayerDefaultProps, PALETTE, getDefaultColor } from '../utils';\nimport { getSourceFromLoader } from '../../utils';\nimport { square, getLayerLoaderTuple, renderSubBitmaskLayers } from './utils';\nimport AbstractSpatialOrScatterplot from '../shared-spatial-scatterplot/AbstractSpatialOrScatterplot';\nimport { createCellsQuadTree } from '../shared-spatial-scatterplot/quadtree';\nimport { ScaledExpressionExtension } from '../../layer-extensions';\nconst CELLS_LAYER_ID = 'cells-layer';\nconst MOLECULES_LAYER_ID = 'molecules-layer';\nconst NEIGHBORHOODS_LAYER_ID = 'neighborhoods-layer'; // Default getter function props.\n\nconst defaultGetCellCoords = cell => cell.xy;\n\nconst makeDefaultGetCellPolygon = radius => cellEntry => {\n  var _cell$poly;\n\n  const cell = cellEntry[1];\n  return ((_cell$poly = cell.poly) === null || _cell$poly === void 0 ? void 0 : _cell$poly.length) ? cell.poly : square(cell.xy[0], cell.xy[1], radius);\n};\n\nconst makeDefaultGetCellColors = (cellColors, theme) => cellEntry => {\n  const [r, g, b, a] = cellColors && cellColors.get(cellEntry[0]) || getDefaultColor(theme);\n  return [r, g, b, 255 * (a || 1)];\n};\n\nconst makeDefaultGetCellIsSelected = cellSelection => {\n  if (cellSelection) {\n    // For performance, convert the Array to a Set instance.\n    // Set.has() is faster than Array.includes().\n    const cellSelectionSet = new Set(cellSelection);\n    return cellEntry => cellSelectionSet.has(cellEntry[0]) ? 1.0 : 0.0;\n  }\n\n  return () => 0.0;\n};\n/**\n * React component which expresses the spatial relationships between cells and molecules.\n * @param {object} props\n * @param {string} props.uuid A unique identifier for this component,\n * used to determine when to show tooltips vs. crosshairs.\n * @param {number} props.height Height of the DeckGL canvas, used when\n * rendering the scale bar layer.\n * @param {number} props.width Width of the DeckGL canvas, used when\n * rendering the scale bar layer.\n * @param {object} props.viewState The DeckGL viewState object.\n * @param {function} props.setViewState A handler for updating the DeckGL\n * viewState object.\n * @param {object} props.molecules Molecules data.\n * @param {object} props.cells Cells data.\n * @param {object} props.neighborhoods Neighborhoods data.\n * @param {number} props.lineWidthScale Width of cell border in view space (deck.gl).\n * @param {number} props.lineWidthMaxPixels Max width of the cell border in pixels (deck.gl).\n * @param {object} props.imageLayerLoaders An object mapping raster layer index to Viv loader\n * instances.\n * @param {object} props.cellColors Map from cell IDs to colors [r, g, b].\n * @param {function} props.getCellCoords Getter function for cell coordinates\n * (used by the selection layer).\n * @param {function} props.getCellColor Getter function for cell color as [r, g, b] array.\n * @param {function} props.getCellPolygon Getter function for cell polygons.\n * @param {function} props.getCellIsSelected Getter function for cell layer isSelected.\n * @param {function} props.getMoleculeColor\n * @param {function} props.getMoleculePosition\n * @param {function} props.getNeighborhoodPolygon\n * @param {function} props.updateViewInfo Handler for DeckGL viewport updates,\n * used when rendering tooltips and crosshairs.\n * @param {function} props.onCellClick Getter function for cell layer onClick.\n * @param {string} props.theme \"light\" or \"dark\" for the vitessce theme\n */\n\n\nclass Spatial extends AbstractSpatialOrScatterplot {\n  constructor(props) {\n    super(props); // To avoid storing large arrays/objects\n    // in React state, this component\n    // uses instance variables.\n    // All instance variables used in this class:\n\n    this.cellsEntries = [];\n    this.moleculesEntries = [];\n    this.cellsQuadTree = null;\n    this.cellsLayer = null;\n    this.moleculesLayer = null;\n    this.neighborhoodsLayer = null;\n    this.imageLayers = [];\n    this.layerLoaderSelections = {}; // Better for the bitmask layer when there is no color data to use this.\n    // 2048 is best for performance and for stability (4096 texture size is not always supported).\n\n    this.randomColorData = {\n      data: new Uint8Array(2048 * 2048 * 3).map((_, j) => j < 4 ? 0 : Math.round(255 * Math.random())),\n      // This buffer should be able to hold colors for 2048 x 2048 ~ 4 million cells.\n      height: 2048,\n      width: 2048\n    };\n    this.color = { ...this.randomColorData\n    };\n    this.expression = {\n      data: new Uint8Array(2048 * 2048),\n      // This buffer should be able to hold colors for 2048 x 2048 ~ 4 million cells.\n      height: 2048,\n      width: 2048\n    }; // Initialize data and layers.\n\n    this.onUpdateCellsData();\n    this.onUpdateCellsLayer();\n    this.onUpdateMoleculesData();\n    this.onUpdateMoleculesLayer();\n    this.onUpdateNeighborhoodsData();\n    this.onUpdateNeighborhoodsLayer();\n    this.onUpdateImages();\n  }\n\n  createCellsLayer(layerDef) {\n    const {\n      radius,\n      stroked,\n      visible,\n      opacity\n    } = layerDef;\n    const {\n      cellsEntries\n    } = this;\n    const {\n      theme,\n      cellFilter,\n      cellSelection,\n      setCellHighlight,\n      setComponentHover,\n      getCellIsSelected = makeDefaultGetCellIsSelected(cellsEntries.length === cellSelection.length ? null : cellSelection),\n      cellColors,\n      getCellColor = makeDefaultGetCellColors(cellColors, theme),\n      getCellPolygon = makeDefaultGetCellPolygon(radius),\n      onCellClick,\n      lineWidthScale = 10,\n      lineWidthMaxPixels = 2,\n      geneExpressionColormapRange,\n      cellColorEncoding,\n      getExpressionValue,\n      geneExpressionColormap\n    } = this.props;\n    const filteredCellsEntries = cellFilter ? cellsEntries.filter(cellEntry => cellFilter.includes(cellEntry[0])) : cellsEntries; // Graphics rendering has the y-axis positive going south,\n    // so we need to flip it for rendering tooltips.\n\n    const flipYTooltip = true;\n    return new PolygonLayer({\n      id: CELLS_LAYER_ID,\n      backgroundColor: [0, 0, 0],\n      isSelected: getCellIsSelected,\n      getPolygon: getCellPolygon,\n      updateTriggers: {\n        getLineWidth: [stroked],\n        isSelected: cellSelection,\n        getExpressionValue,\n        getFillColor: [opacity, cellColorEncoding, cellSelection, cellColors],\n        getLineColor: [cellColorEncoding, cellSelection, cellColors]\n      },\n      getFillColor: cellEntry => {\n        const color = getCellColor(cellEntry);\n        color[3] = opacity * 255;\n        return color;\n      },\n      getLineColor: cellEntry => {\n        const color = getCellColor(cellEntry);\n        color[3] = 255;\n        return color;\n      },\n      onClick: info => {\n        if (onCellClick) {\n          onCellClick(info);\n        }\n      },\n      visible,\n      getLineWidth: stroked ? 1 : 0,\n      lineWidthScale,\n      lineWidthMaxPixels,\n      getExpressionValue,\n      extensions: [new ScaledExpressionExtension()],\n      colorScaleLo: geneExpressionColormapRange[0],\n      colorScaleHi: geneExpressionColormapRange[1],\n      isExpressionMode: cellColorEncoding === 'geneSelection',\n      colormap: geneExpressionColormap,\n      ...cellLayerDefaultProps(filteredCellsEntries, undefined, setCellHighlight, setComponentHover, flipYTooltip)\n    });\n  }\n\n  createMoleculesLayer(layerDef) {\n    const {\n      setMoleculeHighlight,\n      getMoleculeColor = d => PALETTE[d[2] % PALETTE.length],\n      getMoleculePosition = d => [d[0], d[1], 0]\n    } = this.props;\n    const {\n      moleculesEntries\n    } = this;\n    return new ScatterplotLayer({\n      id: MOLECULES_LAYER_ID,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      data: moleculesEntries,\n      pickable: true,\n      autoHighlight: true,\n      radiusMaxPixels: 3,\n      opacity: layerDef.opacity,\n      visible: layerDef.visible,\n      getRadius: layerDef.radius,\n      getPosition: getMoleculePosition,\n      getLineColor: getMoleculeColor,\n      getFillColor: getMoleculeColor,\n      onHover: info => {\n        if (setMoleculeHighlight) {\n          if (info.object) {\n            setMoleculeHighlight(info.object[3]);\n          } else {\n            setMoleculeHighlight(null);\n          }\n        }\n      }\n    });\n  }\n\n  createNeighborhoodsLayer(layerDef) {\n    const {\n      getNeighborhoodPolygon = neighborhoodsEntry => {\n        const neighborhood = neighborhoodsEntry[1];\n        return neighborhood.poly;\n      }\n    } = this.props;\n    const {\n      neighborhoodsEntries\n    } = this;\n    return new PolygonLayer({\n      id: NEIGHBORHOODS_LAYER_ID,\n      getPolygon: getNeighborhoodPolygon,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      data: neighborhoodsEntries,\n      pickable: true,\n      autoHighlight: true,\n      stroked: true,\n      filled: false,\n      getElevation: 0,\n      getLineWidth: 10,\n      visible: layerDef.visible\n    });\n  }\n\n  createSelectionLayers() {\n    const {\n      viewState,\n      getCellCoords = defaultGetCellCoords,\n      setCellSelection\n    } = this.props;\n    const {\n      tool\n    } = this.state;\n    const {\n      cellsQuadTree\n    } = this;\n    return getSelectionLayers(tool, viewState.zoom, CELLS_LAYER_ID, getCellCoords, setCellSelection, cellsQuadTree);\n  }\n\n  createScaleBarLayer() {\n    const {\n      viewState,\n      width,\n      height,\n      imageLayerLoaders = {},\n      layers\n    } = this.props;\n    const use3d = (layers || []).some(i => i.use3d); // Just get the first layer/loader since they should all be spatially\n    // resolved and therefore have the same unit size scale.\n\n    const loaders = Object.values(imageLayerLoaders);\n    if (!viewState || !width || !height || loaders.length < 1) return null;\n    const loader = loaders[0];\n    if (!loader) return null;\n    const source = getSourceFromLoader(loader);\n    if (!source.meta) return null;\n    const {\n      physicalSizes\n    } = source.meta;\n\n    if (physicalSizes && !use3d) {\n      const {\n        x\n      } = physicalSizes;\n      const {\n        unit,\n        size\n      } = x;\n\n      if (unit && size) {\n        return new ScaleBarLayer({\n          id: 'scalebar-layer',\n          unit,\n          size,\n          viewState: { ...viewState,\n            width,\n            height\n          }\n        });\n      }\n\n      return null;\n    }\n\n    return null;\n  }\n\n  createImageLayer(rawLayerDef, loader, i) {\n    const layerDef = { ...rawLayerDef,\n      channels: rawLayerDef.channels.filter(channel => channel.selection && channel.color && channel.slider)\n    }; // We need to keep the same selections array reference,\n    // otherwise the Viv layer will not be re-used as we want it to,\n    // since selections is one of its `updateTriggers`.\n    // Reference: https://github.com/hms-dbmi/viv/blob/ad86d0f/src/layers/MultiscaleImageLayer/MultiscaleImageLayer.js#L127\n\n    let selections;\n    const nextLoaderSelection = layerDef.channels.map(c => c.selection);\n    const prevLoaderSelection = this.layerLoaderSelections[layerDef.index];\n\n    if (isEqual(prevLoaderSelection, nextLoaderSelection)) {\n      selections = prevLoaderSelection;\n    } else {\n      selections = nextLoaderSelection;\n      this.layerLoaderSelections[layerDef.index] = nextLoaderSelection;\n    }\n\n    const useTransparentColor = !layerDef.visible && typeof layerDef.visible === 'boolean' || Boolean(layerDef.transparentColor);\n    const transparentColor = useTransparentColor ? [0, 0, 0] : null;\n    const layerProps = {\n      colormap: layerDef.colormap,\n      opacity: layerDef.opacity,\n      useTransparentColor,\n      transparentColor,\n      colors: layerDef.channels.map(c => c.color),\n      sliders: layerDef.channels.map(c => c.slider),\n      resolution: layerDef.resolution,\n      renderingMode: layerDef.renderingMode,\n      xSlice: layerDef.xSlice,\n      ySlice: layerDef.ySlice,\n      zSlice: layerDef.zSlice,\n      callback: layerDef.callback,\n      visibilities: layerDef.channels.map(c => !layerDef.visible && typeof layerDef.visible === 'boolean' ? false : c.visible)\n    };\n    if (!loader || !layerProps) return null;\n    const {\n      metadata: {\n        transform\n      },\n      data\n    } = loader;\n    let modelMatrix;\n\n    if (transform) {\n      const {\n        scale,\n        translate\n      } = transform;\n      modelMatrix = new Matrix4().translate([translate.x, translate.y, 0]).scale(scale);\n    } else if (layerDef.modelMatrix) {\n      // eslint-disable-next-line prefer-destructuring\n      modelMatrix = new Matrix4(layerDef.modelMatrix);\n    }\n\n    if (rawLayerDef.type === 'bitmask') {\n      const {\n        geneExpressionColormap,\n        geneExpressionColormapRange = [0.0, 1.0],\n        cellColorEncoding\n      } = this.props;\n      return new MultiscaleImageLayer({\n        // `bitmask` is used by the AbstractSpatialOrScatterplot\n        // https://github.com/vitessce/vitessce/pull/927/files#diff-9cab35a2ca0c5b6d9754b177810d25079a30ca91efa062d5795181360bc3ff2cR111\n        id: `bitmask-layer-${layerDef.index}-${i}`,\n        channelsVisible: layerProps.visibilities,\n        opacity: layerProps.opacity,\n        modelMatrix,\n        hoveredCell: Number(this.props.cellHighlight),\n        renderSubLayers: renderSubBitmaskLayers,\n        loader: data,\n        selections,\n        // For some reason, deck.gl doesn't recognize the prop diffing\n        // unless these are separated out.  I don't think it's a bug, just\n        // has to do with the fact that we don't have it in the `defaultProps`,\n        // could be wrong though.\n        cellColorData: this.color.data,\n        cellTexHeight: this.color.height,\n        cellTexWidth: this.color.width,\n        excludeBackground: true,\n        onViewportLoad: layerProps.callback,\n        colorScaleLo: geneExpressionColormapRange[0],\n        colorScaleHi: geneExpressionColormapRange[1],\n        isExpressionMode: cellColorEncoding === 'geneSelection',\n        colormap: geneExpressionColormap,\n        expressionData: this.expression.data\n      });\n    }\n\n    const [Layer, layerLoader] = getLayerLoaderTuple(data, layerDef.use3d);\n    const extensions = layerDef.use3d ? [] : [...(layerProps.colormap ? [new AdditiveColormapExtension()] : [new ColorPaletteExtension()])];\n    return new Layer({\n      loader: layerLoader,\n      id: `${layerDef.use3d ? 'volume' : 'image'}-layer-${layerDef.index}-${i}`,\n      colors: layerProps.colors,\n      contrastLimits: layerProps.sliders,\n      selections,\n      channelsVisible: layerProps.visibilities,\n      opacity: layerProps.opacity,\n      colormap: layerProps.colormap,\n      modelMatrix,\n      transparentColor: layerProps.transparentColor,\n      useTransparentColor: layerProps.useTransparentColor,\n      resolution: layerProps.resolution,\n      renderingMode: layerProps.renderingMode,\n      pickable: false,\n      xSlice: layerProps.xSlice,\n      ySlice: layerProps.ySlice,\n      zSlice: layerProps.zSlice,\n      onViewportLoad: layerProps.callback,\n      extensions\n    });\n  }\n\n  createImageLayers() {\n    const {\n      layers,\n      imageLayerLoaders = {},\n      rasterLayersCallbacks = []\n    } = this.props;\n    const use3d = (layers || []).some(i => i.use3d);\n    const use3dIndex = (layers || []).findIndex(i => i.use3d);\n    return (layers || []).filter(layer => layer.type === 'raster' || layer.type === 'bitmask').filter(layer => use3d ? layer.use3d === use3d : true).map((layer, i) => this.createImageLayer({ ...layer,\n      callback: rasterLayersCallbacks[use3d ? use3dIndex : i]\n    }, imageLayerLoaders[layer.index], i));\n  }\n\n  getLayers() {\n    const {\n      imageLayers,\n      cellsLayer,\n      neighborhoodsLayer,\n      moleculesLayer\n    } = this;\n    return [...imageLayers, cellsLayer, neighborhoodsLayer, moleculesLayer, this.createScaleBarLayer(), ...this.createSelectionLayers()];\n  }\n\n  onUpdateCellsData() {\n    const {\n      cells = {},\n      getCellCoords = defaultGetCellCoords\n    } = this.props;\n    const cellsEntries = Object.entries(cells);\n    this.cellsEntries = cellsEntries;\n    this.cellsQuadTree = createCellsQuadTree(cellsEntries, getCellCoords);\n  }\n\n  onUpdateCellsLayer() {\n    const {\n      layers\n    } = this.props;\n    const layerDef = (layers || []).find(layer => layer.type === 'cells');\n\n    if (layerDef) {\n      this.cellsLayer = this.createCellsLayer(layerDef);\n    } else {\n      this.cellsLayer = null;\n    }\n  }\n\n  onUpdateCellColors() {\n    const color = this.randomColorData;\n    const {\n      size\n    } = this.props.cellColors;\n\n    if (typeof size === 'number') {\n      const cellIds = this.props.cellColors.keys();\n      color.data = new Uint8Array(color.height * color.width * 3).fill(getDefaultColor(this.props.theme)[0]); // 0th cell id is the empty space of the image i.e black color.\n\n      color.data[0] = 0;\n      color.data[1] = 0;\n      color.data[2] = 0; // eslint-disable-next-line no-restricted-syntax\n\n      for (const id of cellIds) {\n        if (id > 0) {\n          const cellColor = this.props.cellColors.get(id);\n\n          if (cellColor) {\n            color.data.set(cellColor.slice(0, 3), Number(id) * 3);\n          }\n        }\n      }\n    }\n\n    this.color = color;\n  }\n\n  onUpdateExpressionData() {\n    var _expressionData$;\n\n    const {\n      expressionData\n    } = this.props;\n\n    if ((_expressionData$ = expressionData[0]) === null || _expressionData$ === void 0 ? void 0 : _expressionData$.length) {\n      this.expression.data = new Uint8Array(this.expression.height * this.expression.width);\n      this.expression.data.set(expressionData[0]);\n    }\n  }\n\n  onUpdateMoleculesData() {\n    const {\n      molecules = {}\n    } = this.props;\n    const moleculesEntries = Object.entries(molecules).flatMap(([molecule, coords], index) => coords.map(([x, y]) => [x, y, index, molecule]));\n    this.moleculesEntries = moleculesEntries;\n  }\n\n  onUpdateMoleculesLayer() {\n    const {\n      layers\n    } = this.props;\n    const layerDef = (layers || []).find(layer => layer.type === 'molecules');\n\n    if (layerDef) {\n      this.moleculesLayer = this.createMoleculesLayer(layerDef);\n    } else {\n      this.moleculesLayer = null;\n    }\n  }\n\n  onUpdateNeighborhoodsData() {\n    const {\n      neighborhoods = {}\n    } = this.props;\n    const neighborhoodsEntries = Object.entries(neighborhoods);\n    this.neighborhoodsEntries = neighborhoodsEntries;\n  }\n\n  onUpdateNeighborhoodsLayer() {\n    const {\n      layers\n    } = this.props;\n    const layerDef = (layers || []).find(layer => layer.type === 'neighborhoods');\n\n    if (layerDef) {\n      this.neighborhoodsLayer = this.createNeighborhoodsLayer(layerDef);\n    } else {\n      this.neighborhoodsLayer = null;\n    }\n  }\n\n  onUpdateImages() {\n    this.imageLayers = this.createImageLayers();\n  }\n\n  viewInfoDidUpdate() {\n    const {\n      getCellCoords = defaultGetCellCoords\n    } = this.props;\n    super.viewInfoDidUpdate(getCellCoords);\n  }\n  /**\n   * Here, asynchronously check whether props have\n   * updated which require re-computing memoized variables,\n   * followed by a re-render.\n   * This function does not follow React conventions or paradigms,\n   * it is only implemented this way to try to squeeze out\n   * performance.\n   * @param {object} prevProps The previous props to diff against.\n   */\n\n\n  componentDidUpdate(prevProps) {\n    this.viewInfoDidUpdate();\n\n    const shallowDiff = propName => prevProps[propName] !== this.props[propName];\n\n    if (['cells'].some(shallowDiff)) {\n      // Cells data changed.\n      this.onUpdateCellsData();\n      this.forceUpdate();\n    }\n\n    if (['layers', 'cells', 'cellFilter', 'cellSelection', 'cellColors', 'geneExpressionColormapRange', 'cellColorEncoding', 'geneExpressionColormap'].some(shallowDiff)) {\n      // Cells layer props changed.\n      this.onUpdateCellsLayer();\n      this.forceUpdate();\n    }\n\n    if (['cellColors'].some(shallowDiff)) {\n      // Cells Color layer props changed.\n      this.onUpdateCellColors();\n      this.forceUpdate();\n    }\n\n    if (['expressionData'].some(shallowDiff)) {\n      // Expression data prop changed.\n      this.onUpdateExpressionData();\n      this.forceUpdate();\n    }\n\n    if (['molecules'].some(shallowDiff)) {\n      // Molecules data changed.\n      this.onUpdateMoleculesData();\n      this.forceUpdate();\n    }\n\n    if (['layers', 'molecules'].some(shallowDiff)) {\n      // Molecules layer props changed.\n      this.onUpdateMoleculesLayer();\n      this.forceUpdate();\n    }\n\n    if (['neighborhoods'].some(shallowDiff)) {\n      // Neighborhoods data changed.\n      this.onUpdateNeighborhoodsData();\n      this.forceUpdate();\n    }\n\n    if (['layers', 'neighborhoods'].some(shallowDiff)) {\n      // Neighborhoods layer props changed.\n      this.onUpdateNeighborhoodsLayer();\n      this.forceUpdate();\n    }\n\n    if (['layers', 'imageLayerLoaders', 'cellColors', 'cellHighlight', 'geneExpressionColormapRange', 'expressionData', 'rasterLayersCallbacks', 'geneExpressionColormap'].some(shallowDiff)) {\n      // Image layers changed.\n      this.onUpdateImages();\n      this.forceUpdate();\n    }\n  } // render() is implemented in the abstract parent class.\n\n\n}\n/**\n * Need this wrapper function here,\n * since we want to pass a forwardRef\n * so that outer components can\n * access the grandchild DeckGL ref,\n * but we are using a class component.\n */\n\n\nconst SpatialWrapper = forwardRef((props, deckRef) => /*#__PURE__*/React.createElement(Spatial, Object.assign({}, props, {\n  deckRef: deckRef,\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 663,\n    columnNumber: 3\n  }\n})));\nexport default SpatialWrapper;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/spatial/Spatial.js"],"names":["React","forwardRef","isEqual","COORDINATE_SYSTEM","PolygonLayer","ScatterplotLayer","Matrix4","ScaleBarLayer","MultiscaleImageLayer","AdditiveColormapExtension","ColorPaletteExtension","getSelectionLayers","cellLayerDefaultProps","PALETTE","getDefaultColor","getSourceFromLoader","square","getLayerLoaderTuple","renderSubBitmaskLayers","AbstractSpatialOrScatterplot","createCellsQuadTree","ScaledExpressionExtension","CELLS_LAYER_ID","MOLECULES_LAYER_ID","NEIGHBORHOODS_LAYER_ID","defaultGetCellCoords","cell","xy","makeDefaultGetCellPolygon","radius","cellEntry","poly","length","makeDefaultGetCellColors","cellColors","theme","r","g","b","a","get","makeDefaultGetCellIsSelected","cellSelection","cellSelectionSet","Set","has","Spatial","constructor","props","cellsEntries","moleculesEntries","cellsQuadTree","cellsLayer","moleculesLayer","neighborhoodsLayer","imageLayers","layerLoaderSelections","randomColorData","data","Uint8Array","map","_","j","Math","round","random","height","width","color","expression","onUpdateCellsData","onUpdateCellsLayer","onUpdateMoleculesData","onUpdateMoleculesLayer","onUpdateNeighborhoodsData","onUpdateNeighborhoodsLayer","onUpdateImages","createCellsLayer","layerDef","stroked","visible","opacity","cellFilter","setCellHighlight","setComponentHover","getCellIsSelected","getCellColor","getCellPolygon","onCellClick","lineWidthScale","lineWidthMaxPixels","geneExpressionColormapRange","cellColorEncoding","getExpressionValue","geneExpressionColormap","filteredCellsEntries","filter","includes","flipYTooltip","id","backgroundColor","isSelected","getPolygon","updateTriggers","getLineWidth","getFillColor","getLineColor","onClick","info","extensions","colorScaleLo","colorScaleHi","isExpressionMode","colormap","undefined","createMoleculesLayer","setMoleculeHighlight","getMoleculeColor","d","getMoleculePosition","coordinateSystem","CARTESIAN","pickable","autoHighlight","radiusMaxPixels","getRadius","getPosition","onHover","object","createNeighborhoodsLayer","getNeighborhoodPolygon","neighborhoodsEntry","neighborhood","neighborhoodsEntries","filled","getElevation","createSelectionLayers","viewState","getCellCoords","setCellSelection","tool","state","zoom","createScaleBarLayer","imageLayerLoaders","layers","use3d","some","i","loaders","Object","values","loader","source","meta","physicalSizes","x","unit","size","createImageLayer","rawLayerDef","channels","channel","selection","slider","selections","nextLoaderSelection","c","prevLoaderSelection","index","useTransparentColor","Boolean","transparentColor","layerProps","colors","sliders","resolution","renderingMode","xSlice","ySlice","zSlice","callback","visibilities","metadata","transform","modelMatrix","scale","translate","y","type","channelsVisible","hoveredCell","Number","cellHighlight","renderSubLayers","cellColorData","cellTexHeight","cellTexWidth","excludeBackground","onViewportLoad","expressionData","Layer","layerLoader","contrastLimits","createImageLayers","rasterLayersCallbacks","use3dIndex","findIndex","layer","getLayers","cells","entries","find","onUpdateCellColors","cellIds","keys","fill","cellColor","set","slice","onUpdateExpressionData","molecules","flatMap","molecule","coords","neighborhoods","viewInfoDidUpdate","componentDidUpdate","prevProps","shallowDiff","propName","forceUpdate","SpatialWrapper","deckRef"],"mappings":"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","sourcesContent":["import React, { forwardRef } from 'react';\nimport isEqual from 'lodash/isEqual';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core'; // eslint-disable-line import/no-extraneous-dependencies\nimport { PolygonLayer, ScatterplotLayer } from '@deck.gl/layers'; // eslint-disable-line import/no-extraneous-dependencies\nimport { Matrix4 } from 'math.gl';\nimport {\n  ScaleBarLayer,\n  MultiscaleImageLayer,\n  AdditiveColormapExtension,\n  ColorPaletteExtension,\n} from '@hms-dbmi/viv';\nimport { getSelectionLayers } from '../../layers';\nimport { cellLayerDefaultProps, PALETTE, getDefaultColor } from '../utils';\nimport { getSourceFromLoader } from '../../utils';\nimport { square, getLayerLoaderTuple, renderSubBitmaskLayers } from './utils';\nimport AbstractSpatialOrScatterplot from '../shared-spatial-scatterplot/AbstractSpatialOrScatterplot';\nimport { createCellsQuadTree } from '../shared-spatial-scatterplot/quadtree';\nimport { ScaledExpressionExtension } from '../../layer-extensions';\n\nconst CELLS_LAYER_ID = 'cells-layer';\nconst MOLECULES_LAYER_ID = 'molecules-layer';\nconst NEIGHBORHOODS_LAYER_ID = 'neighborhoods-layer';\n\n// Default getter function props.\nconst defaultGetCellCoords = cell => cell.xy;\nconst makeDefaultGetCellPolygon = radius => (cellEntry) => {\n  const cell = cellEntry[1];\n  return cell.poly?.length ? cell.poly : square(cell.xy[0], cell.xy[1], radius);\n};\nconst makeDefaultGetCellColors = (cellColors, theme) => (cellEntry) => {\n  const [r, g, b, a] = (cellColors && cellColors.get(cellEntry[0])) || getDefaultColor(theme);\n  return [r, g, b, 255 * (a || 1)];\n};\nconst makeDefaultGetCellIsSelected = (cellSelection) => {\n  if (cellSelection) {\n    // For performance, convert the Array to a Set instance.\n    // Set.has() is faster than Array.includes().\n    const cellSelectionSet = new Set(cellSelection);\n    return cellEntry => (cellSelectionSet.has(cellEntry[0]) ? 1.0 : 0.0);\n  }\n  return () => 0.0;\n};\n\n/**\n * React component which expresses the spatial relationships between cells and molecules.\n * @param {object} props\n * @param {string} props.uuid A unique identifier for this component,\n * used to determine when to show tooltips vs. crosshairs.\n * @param {number} props.height Height of the DeckGL canvas, used when\n * rendering the scale bar layer.\n * @param {number} props.width Width of the DeckGL canvas, used when\n * rendering the scale bar layer.\n * @param {object} props.viewState The DeckGL viewState object.\n * @param {function} props.setViewState A handler for updating the DeckGL\n * viewState object.\n * @param {object} props.molecules Molecules data.\n * @param {object} props.cells Cells data.\n * @param {object} props.neighborhoods Neighborhoods data.\n * @param {number} props.lineWidthScale Width of cell border in view space (deck.gl).\n * @param {number} props.lineWidthMaxPixels Max width of the cell border in pixels (deck.gl).\n * @param {object} props.imageLayerLoaders An object mapping raster layer index to Viv loader\n * instances.\n * @param {object} props.cellColors Map from cell IDs to colors [r, g, b].\n * @param {function} props.getCellCoords Getter function for cell coordinates\n * (used by the selection layer).\n * @param {function} props.getCellColor Getter function for cell color as [r, g, b] array.\n * @param {function} props.getCellPolygon Getter function for cell polygons.\n * @param {function} props.getCellIsSelected Getter function for cell layer isSelected.\n * @param {function} props.getMoleculeColor\n * @param {function} props.getMoleculePosition\n * @param {function} props.getNeighborhoodPolygon\n * @param {function} props.updateViewInfo Handler for DeckGL viewport updates,\n * used when rendering tooltips and crosshairs.\n * @param {function} props.onCellClick Getter function for cell layer onClick.\n * @param {string} props.theme \"light\" or \"dark\" for the vitessce theme\n */\nclass Spatial extends AbstractSpatialOrScatterplot {\n  constructor(props) {\n    super(props);\n\n    // To avoid storing large arrays/objects\n    // in React state, this component\n    // uses instance variables.\n    // All instance variables used in this class:\n    this.cellsEntries = [];\n    this.moleculesEntries = [];\n    this.cellsQuadTree = null;\n    this.cellsLayer = null;\n    this.moleculesLayer = null;\n    this.neighborhoodsLayer = null;\n    this.imageLayers = [];\n    this.layerLoaderSelections = {};\n    // Better for the bitmask layer when there is no color data to use this.\n    // 2048 is best for performance and for stability (4096 texture size is not always supported).\n    this.randomColorData = {\n      data: new Uint8Array(2048 * 2048 * 3)\n        .map((_, j) => (j < 4 ? 0 : Math.round(255 * Math.random()))),\n      // This buffer should be able to hold colors for 2048 x 2048 ~ 4 million cells.\n      height: 2048,\n      width: 2048,\n    };\n    this.color = { ...this.randomColorData };\n    this.expression = {\n      data: new Uint8Array(2048 * 2048),\n      // This buffer should be able to hold colors for 2048 x 2048 ~ 4 million cells.\n      height: 2048,\n      width: 2048,\n    };\n\n    // Initialize data and layers.\n    this.onUpdateCellsData();\n    this.onUpdateCellsLayer();\n    this.onUpdateMoleculesData();\n    this.onUpdateMoleculesLayer();\n    this.onUpdateNeighborhoodsData();\n    this.onUpdateNeighborhoodsLayer();\n    this.onUpdateImages();\n  }\n\n  createCellsLayer(layerDef) {\n    const {\n      radius, stroked, visible, opacity,\n    } = layerDef;\n    const { cellsEntries } = this;\n    const {\n      theme,\n      cellFilter,\n      cellSelection,\n      setCellHighlight,\n      setComponentHover,\n      getCellIsSelected = makeDefaultGetCellIsSelected(\n        cellsEntries.length === cellSelection.length ? null : cellSelection,\n      ),\n      cellColors,\n      getCellColor = makeDefaultGetCellColors(cellColors, theme),\n      getCellPolygon = makeDefaultGetCellPolygon(radius),\n      onCellClick,\n      lineWidthScale = 10,\n      lineWidthMaxPixels = 2,\n      geneExpressionColormapRange,\n      cellColorEncoding,\n      getExpressionValue,\n      geneExpressionColormap,\n    } = this.props;\n    const filteredCellsEntries = cellFilter\n      ? cellsEntries.filter(cellEntry => cellFilter.includes(cellEntry[0]))\n      : cellsEntries;\n\n    // Graphics rendering has the y-axis positive going south,\n    // so we need to flip it for rendering tooltips.\n    const flipYTooltip = true;\n\n    return new PolygonLayer({\n      id: CELLS_LAYER_ID,\n      backgroundColor: [0, 0, 0],\n      isSelected: getCellIsSelected,\n      getPolygon: getCellPolygon,\n      updateTriggers: {\n        getLineWidth: [stroked],\n        isSelected: cellSelection,\n        getExpressionValue,\n        getFillColor: [opacity, cellColorEncoding, cellSelection, cellColors],\n        getLineColor: [cellColorEncoding, cellSelection, cellColors],\n      },\n      getFillColor: (cellEntry) => {\n        const color = getCellColor(cellEntry);\n        color[3] = opacity * 255;\n        return color;\n      },\n      getLineColor: (cellEntry) => {\n        const color = getCellColor(cellEntry);\n        color[3] = 255;\n        return color;\n      },\n      onClick: (info) => {\n        if (onCellClick) {\n          onCellClick(info);\n        }\n      },\n      visible,\n      getLineWidth: stroked ? 1 : 0,\n      lineWidthScale,\n      lineWidthMaxPixels,\n      getExpressionValue,\n      extensions: [new ScaledExpressionExtension()],\n      colorScaleLo: geneExpressionColormapRange[0],\n      colorScaleHi: geneExpressionColormapRange[1],\n      isExpressionMode: cellColorEncoding === 'geneSelection',\n      colormap: geneExpressionColormap,\n      ...cellLayerDefaultProps(\n        filteredCellsEntries,\n        undefined,\n        setCellHighlight,\n        setComponentHover,\n        flipYTooltip,\n      ),\n    });\n  }\n\n  createMoleculesLayer(layerDef) {\n    const {\n      setMoleculeHighlight,\n      getMoleculeColor = d => PALETTE[d[2] % PALETTE.length],\n      getMoleculePosition = d => [d[0], d[1], 0],\n    } = this.props;\n    const { moleculesEntries } = this;\n\n    return new ScatterplotLayer({\n      id: MOLECULES_LAYER_ID,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      data: moleculesEntries,\n      pickable: true,\n      autoHighlight: true,\n      radiusMaxPixels: 3,\n      opacity: layerDef.opacity,\n      visible: layerDef.visible,\n      getRadius: layerDef.radius,\n      getPosition: getMoleculePosition,\n      getLineColor: getMoleculeColor,\n      getFillColor: getMoleculeColor,\n      onHover: (info) => {\n        if (setMoleculeHighlight) {\n          if (info.object) {\n            setMoleculeHighlight(info.object[3]);\n          } else {\n            setMoleculeHighlight(null);\n          }\n        }\n      },\n    });\n  }\n\n  createNeighborhoodsLayer(layerDef) {\n    const {\n      getNeighborhoodPolygon = (neighborhoodsEntry) => {\n        const neighborhood = neighborhoodsEntry[1];\n        return neighborhood.poly;\n      },\n    } = this.props;\n    const { neighborhoodsEntries } = this;\n\n    return new PolygonLayer({\n      id: NEIGHBORHOODS_LAYER_ID,\n      getPolygon: getNeighborhoodPolygon,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      data: neighborhoodsEntries,\n      pickable: true,\n      autoHighlight: true,\n      stroked: true,\n      filled: false,\n      getElevation: 0,\n      getLineWidth: 10,\n      visible: layerDef.visible,\n    });\n  }\n\n  createSelectionLayers() {\n    const {\n      viewState,\n      getCellCoords = defaultGetCellCoords,\n      setCellSelection,\n    } = this.props;\n    const { tool } = this.state;\n    const { cellsQuadTree } = this;\n    return getSelectionLayers(\n      tool,\n      viewState.zoom,\n      CELLS_LAYER_ID,\n      getCellCoords,\n      setCellSelection,\n      cellsQuadTree,\n    );\n  }\n\n  createScaleBarLayer() {\n    const {\n      viewState,\n      width,\n      height,\n      imageLayerLoaders = {},\n      layers,\n    } = this.props;\n    const use3d = (layers || []).some(i => i.use3d);\n    // Just get the first layer/loader since they should all be spatially\n    // resolved and therefore have the same unit size scale.\n    const loaders = Object.values(imageLayerLoaders);\n    if (!viewState || !width || !height || loaders.length < 1) return null;\n    const loader = loaders[0];\n    if (!loader) return null;\n    const source = getSourceFromLoader(loader);\n    if (!source.meta) return null;\n    const { physicalSizes } = source.meta;\n    if (physicalSizes && !use3d) {\n      const { x } = physicalSizes;\n      const { unit, size } = x;\n      if (unit && size) {\n        return new ScaleBarLayer({\n          id: 'scalebar-layer',\n          unit,\n          size,\n          viewState: { ...viewState, width, height },\n        });\n      }\n      return null;\n    }\n    return null;\n  }\n\n  createImageLayer(rawLayerDef, loader, i) {\n    const layerDef = {\n      ...rawLayerDef,\n      channels: rawLayerDef.channels.filter(\n        channel => channel.selection && channel.color && channel.slider,\n      ),\n    };\n\n    // We need to keep the same selections array reference,\n    // otherwise the Viv layer will not be re-used as we want it to,\n    // since selections is one of its `updateTriggers`.\n    // Reference: https://github.com/hms-dbmi/viv/blob/ad86d0f/src/layers/MultiscaleImageLayer/MultiscaleImageLayer.js#L127\n    let selections;\n    const nextLoaderSelection = layerDef.channels.map(c => c.selection);\n    const prevLoaderSelection = this.layerLoaderSelections[layerDef.index];\n    if (isEqual(prevLoaderSelection, nextLoaderSelection)) {\n      selections = prevLoaderSelection;\n    } else {\n      selections = nextLoaderSelection;\n      this.layerLoaderSelections[layerDef.index] = nextLoaderSelection;\n    }\n    const useTransparentColor = (!layerDef.visible\n      && typeof layerDef.visible === 'boolean')\n      || Boolean(layerDef.transparentColor);\n    const transparentColor = useTransparentColor ? [0, 0, 0] : null;\n    const layerProps = {\n      colormap: layerDef.colormap,\n      opacity: layerDef.opacity,\n      useTransparentColor,\n      transparentColor,\n      colors: layerDef.channels.map(c => c.color),\n      sliders: layerDef.channels.map(c => c.slider),\n      resolution: layerDef.resolution,\n      renderingMode: layerDef.renderingMode,\n      xSlice: layerDef.xSlice,\n      ySlice: layerDef.ySlice,\n      zSlice: layerDef.zSlice,\n      callback: layerDef.callback,\n      visibilities: layerDef.channels.map(c => (!layerDef.visible && typeof layerDef.visible === 'boolean'\n        ? false\n        : c.visible)),\n    };\n\n    if (!loader || !layerProps) return null;\n    const {\n      metadata: { transform },\n      data,\n    } = loader;\n    let modelMatrix;\n    if (transform) {\n      const { scale, translate } = transform;\n      modelMatrix = new Matrix4()\n        .translate([translate.x, translate.y, 0])\n        .scale(scale);\n    } else if (layerDef.modelMatrix) {\n      // eslint-disable-next-line prefer-destructuring\n      modelMatrix = new Matrix4(layerDef.modelMatrix);\n    }\n    if (rawLayerDef.type === 'bitmask') {\n      const {\n        geneExpressionColormap,\n        geneExpressionColormapRange = [0.0, 1.0],\n        cellColorEncoding,\n      } = this.props;\n      return new MultiscaleImageLayer({\n        // `bitmask` is used by the AbstractSpatialOrScatterplot\n        // https://github.com/vitessce/vitessce/pull/927/files#diff-9cab35a2ca0c5b6d9754b177810d25079a30ca91efa062d5795181360bc3ff2cR111\n        id: `bitmask-layer-${layerDef.index}-${i}`,\n        channelsVisible: layerProps.visibilities,\n        opacity: layerProps.opacity,\n        modelMatrix,\n        hoveredCell: Number(this.props.cellHighlight),\n        renderSubLayers: renderSubBitmaskLayers,\n        loader: data,\n        selections,\n        // For some reason, deck.gl doesn't recognize the prop diffing\n        // unless these are separated out.  I don't think it's a bug, just\n        // has to do with the fact that we don't have it in the `defaultProps`,\n        // could be wrong though.\n        cellColorData: this.color.data,\n        cellTexHeight: this.color.height,\n        cellTexWidth: this.color.width,\n        excludeBackground: true,\n        onViewportLoad: layerProps.callback,\n        colorScaleLo: geneExpressionColormapRange[0],\n        colorScaleHi: geneExpressionColormapRange[1],\n        isExpressionMode: cellColorEncoding === 'geneSelection',\n        colormap: geneExpressionColormap,\n        expressionData: this.expression.data,\n      });\n    }\n    const [Layer, layerLoader] = getLayerLoaderTuple(data, layerDef.use3d);\n\n    const extensions = (layerDef.use3d ? [] : [\n      ...(layerProps.colormap ? [\n        new AdditiveColormapExtension(),\n      ] : [\n        new ColorPaletteExtension(),\n      ]),\n    ]);\n\n    return new Layer({\n      loader: layerLoader,\n      id: `${layerDef.use3d ? 'volume' : 'image'}-layer-${layerDef.index}-${i}`,\n      colors: layerProps.colors,\n      contrastLimits: layerProps.sliders,\n      selections,\n      channelsVisible: layerProps.visibilities,\n      opacity: layerProps.opacity,\n      colormap: layerProps.colormap,\n      modelMatrix,\n      transparentColor: layerProps.transparentColor,\n      useTransparentColor: layerProps.useTransparentColor,\n      resolution: layerProps.resolution,\n      renderingMode: layerProps.renderingMode,\n      pickable: false,\n      xSlice: layerProps.xSlice,\n      ySlice: layerProps.ySlice,\n      zSlice: layerProps.zSlice,\n      onViewportLoad: layerProps.callback,\n      extensions,\n    });\n  }\n\n  createImageLayers() {\n    const {\n      layers,\n      imageLayerLoaders = {},\n      rasterLayersCallbacks = [],\n    } = this.props;\n    const use3d = (layers || []).some(i => i.use3d);\n    const use3dIndex = (layers || []).findIndex(i => i.use3d);\n    return (layers || [])\n      .filter(layer => layer.type === 'raster' || layer.type === 'bitmask')\n      .filter(layer => (use3d ? layer.use3d === use3d : true))\n      .map((layer, i) => this.createImageLayer(\n        { ...layer, callback: rasterLayersCallbacks[use3d ? use3dIndex : i] },\n        imageLayerLoaders[layer.index],\n        i,\n      ));\n  }\n\n  getLayers() {\n    const {\n      imageLayers, cellsLayer, neighborhoodsLayer, moleculesLayer,\n    } = this;\n    return [\n      ...imageLayers,\n      cellsLayer,\n      neighborhoodsLayer,\n      moleculesLayer,\n      this.createScaleBarLayer(),\n      ...this.createSelectionLayers(),\n    ];\n  }\n\n  onUpdateCellsData() {\n    const { cells = {}, getCellCoords = defaultGetCellCoords } = this.props;\n    const cellsEntries = Object.entries(cells);\n    this.cellsEntries = cellsEntries;\n    this.cellsQuadTree = createCellsQuadTree(cellsEntries, getCellCoords);\n  }\n\n  onUpdateCellsLayer() {\n    const { layers } = this.props;\n    const layerDef = (layers || []).find(layer => layer.type === 'cells');\n    if (layerDef) {\n      this.cellsLayer = this.createCellsLayer(layerDef);\n    } else {\n      this.cellsLayer = null;\n    }\n  }\n\n  onUpdateCellColors() {\n    const color = this.randomColorData;\n    const { size } = this.props.cellColors;\n    if (typeof size === 'number') {\n      const cellIds = this.props.cellColors.keys();\n      color.data = new Uint8Array(color.height * color.width * 3).fill(\n        getDefaultColor(this.props.theme)[0],\n      );\n      // 0th cell id is the empty space of the image i.e black color.\n      color.data[0] = 0;\n      color.data[1] = 0;\n      color.data[2] = 0;\n      // eslint-disable-next-line no-restricted-syntax\n      for (const id of cellIds) {\n        if (id > 0) {\n          const cellColor = this.props.cellColors.get(id);\n          if (cellColor) {\n            color.data.set(cellColor.slice(0, 3), Number(id) * 3);\n          }\n        }\n      }\n    }\n    this.color = color;\n  }\n\n  onUpdateExpressionData() {\n    const { expressionData } = this.props;\n    if (expressionData[0]?.length) {\n      this.expression.data = new Uint8Array(\n        this.expression.height * this.expression.width,\n      );\n      this.expression.data.set(expressionData[0]);\n    }\n  }\n\n  onUpdateMoleculesData() {\n    const { molecules = {} } = this.props;\n    const moleculesEntries = Object.entries(molecules).flatMap(\n      ([molecule, coords], index) => coords.map(([x, y]) => [x, y, index, molecule]),\n    );\n    this.moleculesEntries = moleculesEntries;\n  }\n\n  onUpdateMoleculesLayer() {\n    const { layers } = this.props;\n    const layerDef = (layers || []).find(layer => layer.type === 'molecules');\n    if (layerDef) {\n      this.moleculesLayer = this.createMoleculesLayer(layerDef);\n    } else {\n      this.moleculesLayer = null;\n    }\n  }\n\n  onUpdateNeighborhoodsData() {\n    const { neighborhoods = {} } = this.props;\n    const neighborhoodsEntries = Object.entries(neighborhoods);\n    this.neighborhoodsEntries = neighborhoodsEntries;\n  }\n\n  onUpdateNeighborhoodsLayer() {\n    const { layers } = this.props;\n    const layerDef = (layers || []).find(\n      layer => layer.type === 'neighborhoods',\n    );\n    if (layerDef) {\n      this.neighborhoodsLayer = this.createNeighborhoodsLayer(layerDef);\n    } else {\n      this.neighborhoodsLayer = null;\n    }\n  }\n\n  onUpdateImages() {\n    this.imageLayers = this.createImageLayers();\n  }\n\n  viewInfoDidUpdate() {\n    const { getCellCoords = defaultGetCellCoords } = this.props;\n    super.viewInfoDidUpdate(getCellCoords);\n  }\n\n  /**\n   * Here, asynchronously check whether props have\n   * updated which require re-computing memoized variables,\n   * followed by a re-render.\n   * This function does not follow React conventions or paradigms,\n   * it is only implemented this way to try to squeeze out\n   * performance.\n   * @param {object} prevProps The previous props to diff against.\n   */\n  componentDidUpdate(prevProps) {\n    this.viewInfoDidUpdate();\n\n    const shallowDiff = propName => prevProps[propName] !== this.props[propName];\n    if (['cells'].some(shallowDiff)) {\n      // Cells data changed.\n      this.onUpdateCellsData();\n      this.forceUpdate();\n    }\n\n    if (\n      [\n        'layers',\n        'cells',\n        'cellFilter',\n        'cellSelection',\n        'cellColors',\n        'geneExpressionColormapRange',\n        'cellColorEncoding',\n        'geneExpressionColormap',\n      ].some(shallowDiff)\n    ) {\n      // Cells layer props changed.\n      this.onUpdateCellsLayer();\n      this.forceUpdate();\n    }\n\n    if (['cellColors'].some(shallowDiff)) {\n      // Cells Color layer props changed.\n      this.onUpdateCellColors();\n      this.forceUpdate();\n    }\n\n    if (['expressionData'].some(shallowDiff)) {\n      // Expression data prop changed.\n      this.onUpdateExpressionData();\n      this.forceUpdate();\n    }\n\n    if (['molecules'].some(shallowDiff)) {\n      // Molecules data changed.\n      this.onUpdateMoleculesData();\n      this.forceUpdate();\n    }\n\n    if (['layers', 'molecules'].some(shallowDiff)) {\n      // Molecules layer props changed.\n      this.onUpdateMoleculesLayer();\n      this.forceUpdate();\n    }\n\n    if (['neighborhoods'].some(shallowDiff)) {\n      // Neighborhoods data changed.\n      this.onUpdateNeighborhoodsData();\n      this.forceUpdate();\n    }\n\n    if (['layers', 'neighborhoods'].some(shallowDiff)) {\n      // Neighborhoods layer props changed.\n      this.onUpdateNeighborhoodsLayer();\n      this.forceUpdate();\n    }\n\n    if (\n      [\n        'layers',\n        'imageLayerLoaders',\n        'cellColors',\n        'cellHighlight',\n        'geneExpressionColormapRange',\n        'expressionData',\n        'rasterLayersCallbacks',\n        'geneExpressionColormap',\n      ].some(shallowDiff)\n    ) {\n      // Image layers changed.\n      this.onUpdateImages();\n      this.forceUpdate();\n    }\n  }\n\n  // render() is implemented in the abstract parent class.\n}\n\n/**\n * Need this wrapper function here,\n * since we want to pass a forwardRef\n * so that outer components can\n * access the grandchild DeckGL ref,\n * but we are using a class component.\n */\nconst SpatialWrapper = forwardRef((props, deckRef) => (\n  <Spatial {...props} deckRef={deckRef} />\n));\nexport default SpatialWrapper;\n"]},"metadata":{},"sourceType":"module"}