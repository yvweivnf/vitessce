{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\n\nexport class FacetNode extends DataFlowNode {\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  constructor(parent, model, name, data) {\n    super(parent);\n    this.model = model;\n    this.name = name;\n    this.data = data;\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = model.facet[channel];\n\n      if (fieldDef) {\n        const {\n          bin,\n          sort\n        } = fieldDef;\n        this[channel] = Object.assign({\n          name: model.getName(`${channel}_domain`),\n          fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, {\n            binSuffix: 'end'\n          })] : [])]\n        }, isSortField(sort) ? {\n          sortField: sort\n        } : isArray(sort) ? {\n          sortIndexField: sortArrayIndexField(fieldDef, channel)\n        } : {});\n      }\n    }\n\n    this.childModel = model.child;\n  }\n\n  hash() {\n    let out = `Facet`;\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n      }\n    }\n\n    return out;\n  }\n\n  get fields() {\n    var _a;\n\n    const f = [];\n\n    for (const channel of FACET_CHANNELS) {\n      if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n        f.push(...this[channel].fields);\n      }\n    }\n\n    return f;\n  }\n\n  dependentFields() {\n    const depFields = new Set(this.fields);\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        if (this[channel].sortField) {\n          depFields.add(this[channel].sortField.field);\n        }\n\n        if (this[channel].sortIndexField) {\n          depFields.add(this[channel].sortIndexField);\n        }\n      }\n    }\n\n    return depFields;\n  }\n\n  producedFields() {\n    return new Set(); // facet does not produce any new fields\n  }\n  /**\n   * The name to reference this source is its name.\n   */\n\n\n  getSource() {\n    return this.name;\n  }\n\n  getChildIndependentFieldsWithStep() {\n    const childIndependentFieldsWithStep = {};\n\n    for (const channel of POSITION_SCALE_CHANNELS) {\n      const childScaleComponent = this.childModel.component.scales[channel];\n\n      if (childScaleComponent && !childScaleComponent.merged) {\n        // independent scale\n        const type = childScaleComponent.get('type');\n        const range = childScaleComponent.get('range');\n\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const domain = assembleDomain(this.childModel, channel);\n          const field = getFieldFromDomain(domain);\n\n          if (field) {\n            childIndependentFieldsWithStep[channel] = field;\n          } else {\n            log.warn(log.message.unknownField(channel));\n          }\n        }\n      }\n    }\n\n    return childIndependentFieldsWithStep;\n  }\n\n  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n    const childChannel = {\n      row: 'y',\n      column: 'x',\n      facet: undefined\n    }[channel];\n    const fields = [];\n    const ops = [];\n    const as = [];\n\n    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n      if (crossedDataName) {\n        // If there is a crossed data, calculate max\n        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n        ops.push('max');\n      } else {\n        // If there is no crossed data, just calculate distinct\n        fields.push(childIndependentFieldsWithStep[childChannel]);\n        ops.push('distinct');\n      } // Although it is technically a max, just name it distinct so it's easier to refer to it\n\n\n      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n    }\n\n    const {\n      sortField,\n      sortIndexField\n    } = this[channel];\n\n    if (sortField) {\n      const {\n        op = DEFAULT_SORT_OP,\n        field\n      } = sortField;\n      fields.push(field);\n      ops.push(op);\n      as.push(vgField(sortField, {\n        forAs: true\n      }));\n    } else if (sortIndexField) {\n      fields.push(sortIndexField);\n      ops.push('max');\n      as.push(sortIndexField);\n    }\n\n    return {\n      name: this[channel].name,\n      // Use data from the crossed one if it exist\n      source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n      transform: [Object.assign({\n        type: 'aggregate',\n        groupby: this[channel].fields\n      }, fields.length ? {\n        fields,\n        ops,\n        as\n      } : {})]\n    };\n  }\n\n  assembleFacetHeaderData(childIndependentFieldsWithStep) {\n    var _a, _b;\n\n    const {\n      columns\n    } = this.model.layout;\n    const {\n      layoutHeaders\n    } = this.model.component;\n    const data = [];\n    const hasSharedAxis = {};\n\n    for (const headerChannel of HEADER_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const headers = (_a = layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) !== null && _a !== void 0 ? _a : [];\n\n        for (const header of headers) {\n          if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n            hasSharedAxis[headerChannel] = true;\n            break;\n          }\n        }\n      }\n\n      if (hasSharedAxis[headerChannel]) {\n        const cardinality = `length(data(\"${this.facet.name}\"))`;\n        const stop = headerChannel === 'row' ? columns ? {\n          signal: `ceil(${cardinality} / ${columns})`\n        } : 1 : columns ? {\n          signal: `min(${cardinality}, ${columns})`\n        } : {\n          signal: cardinality\n        };\n        data.push({\n          name: `${this.facet.name}_${headerChannel}`,\n          transform: [{\n            type: 'sequence',\n            start: 0,\n            stop\n          }]\n        });\n      }\n    }\n\n    const {\n      row,\n      column\n    } = hasSharedAxis;\n\n    if (row || column) {\n      data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n    }\n\n    return data;\n  }\n\n  assemble() {\n    var _a, _b;\n\n    const data = [];\n    let crossedDataName = null;\n    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n    const {\n      column,\n      row,\n      facet\n    } = this;\n\n    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n      // Need to create a cross dataset to correctly calculate cardinality\n      crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n      const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);\n      const ops = fields.map(() => 'distinct');\n      data.push({\n        name: crossedDataName,\n        source: this.data,\n        transform: [{\n          type: 'aggregate',\n          groupby: this.fields,\n          fields,\n          ops\n        }]\n      });\n    }\n\n    for (const channel of [COLUMN, ROW]) {\n      if (this[channel]) {\n        data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n      }\n    }\n\n    if (facet) {\n      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n\n      if (facetData) {\n        data.push(...facetData);\n      }\n    }\n\n    return data;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/facet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n    /**\n     * @param model The facet model.\n     * @param name The name that this facet source will have.\n     * @param data The source data for this facet data.\n     */\n    constructor(parent, model, name, data) {\n        super(parent);\n        this.model = model;\n        this.name = name;\n        this.data = data;\n        for (const channel of FACET_CHANNELS) {\n            const fieldDef = model.facet[channel];\n            if (fieldDef) {\n                const { bin, sort } = fieldDef;\n                this[channel] = Object.assign({ name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, { binSuffix: 'end' })] : [])] }, (isSortField(sort)\n                    ? { sortField: sort }\n                    : isArray(sort)\n                        ? { sortIndexField: sortArrayIndexField(fieldDef, channel) }\n                        : {}));\n            }\n        }\n        this.childModel = model.child;\n    }\n    hash() {\n        let out = `Facet`;\n        for (const channel of FACET_CHANNELS) {\n            if (this[channel]) {\n                out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n            }\n        }\n        return out;\n    }\n    get fields() {\n        var _a;\n        const f = [];\n        for (const channel of FACET_CHANNELS) {\n            if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n                f.push(...this[channel].fields);\n            }\n        }\n        return f;\n    }\n    dependentFields() {\n        const depFields = new Set(this.fields);\n        for (const channel of FACET_CHANNELS) {\n            if (this[channel]) {\n                if (this[channel].sortField) {\n                    depFields.add(this[channel].sortField.field);\n                }\n                if (this[channel].sortIndexField) {\n                    depFields.add(this[channel].sortIndexField);\n                }\n            }\n        }\n        return depFields;\n    }\n    producedFields() {\n        return new Set(); // facet does not produce any new fields\n    }\n    /**\n     * The name to reference this source is its name.\n     */\n    getSource() {\n        return this.name;\n    }\n    getChildIndependentFieldsWithStep() {\n        const childIndependentFieldsWithStep = {};\n        for (const channel of POSITION_SCALE_CHANNELS) {\n            const childScaleComponent = this.childModel.component.scales[channel];\n            if (childScaleComponent && !childScaleComponent.merged) {\n                // independent scale\n                const type = childScaleComponent.get('type');\n                const range = childScaleComponent.get('range');\n                if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                    const domain = assembleDomain(this.childModel, channel);\n                    const field = getFieldFromDomain(domain);\n                    if (field) {\n                        childIndependentFieldsWithStep[channel] = field;\n                    }\n                    else {\n                        log.warn(log.message.unknownField(channel));\n                    }\n                }\n            }\n        }\n        return childIndependentFieldsWithStep;\n    }\n    assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n        const childChannel = { row: 'y', column: 'x', facet: undefined }[channel];\n        const fields = [];\n        const ops = [];\n        const as = [];\n        if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n            if (crossedDataName) {\n                // If there is a crossed data, calculate max\n                fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n                ops.push('max');\n            }\n            else {\n                // If there is no crossed data, just calculate distinct\n                fields.push(childIndependentFieldsWithStep[childChannel]);\n                ops.push('distinct');\n            }\n            // Although it is technically a max, just name it distinct so it's easier to refer to it\n            as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n        }\n        const { sortField, sortIndexField } = this[channel];\n        if (sortField) {\n            const { op = DEFAULT_SORT_OP, field } = sortField;\n            fields.push(field);\n            ops.push(op);\n            as.push(vgField(sortField, { forAs: true }));\n        }\n        else if (sortIndexField) {\n            fields.push(sortIndexField);\n            ops.push('max');\n            as.push(sortIndexField);\n        }\n        return {\n            name: this[channel].name,\n            // Use data from the crossed one if it exist\n            source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n            transform: [\n                Object.assign({ type: 'aggregate', groupby: this[channel].fields }, (fields.length\n                    ? {\n                        fields,\n                        ops,\n                        as\n                    }\n                    : {}))\n            ]\n        };\n    }\n    assembleFacetHeaderData(childIndependentFieldsWithStep) {\n        var _a, _b;\n        const { columns } = this.model.layout;\n        const { layoutHeaders } = this.model.component;\n        const data = [];\n        const hasSharedAxis = {};\n        for (const headerChannel of HEADER_CHANNELS) {\n            for (const headerType of HEADER_TYPES) {\n                const headers = (_a = (layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType])) !== null && _a !== void 0 ? _a : [];\n                for (const header of headers) {\n                    if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                        hasSharedAxis[headerChannel] = true;\n                        break;\n                    }\n                }\n            }\n            if (hasSharedAxis[headerChannel]) {\n                const cardinality = `length(data(\"${this.facet.name}\"))`;\n                const stop = headerChannel === 'row'\n                    ? columns\n                        ? { signal: `ceil(${cardinality} / ${columns})` }\n                        : 1\n                    : columns\n                        ? { signal: `min(${cardinality}, ${columns})` }\n                        : { signal: cardinality };\n                data.push({\n                    name: `${this.facet.name}_${headerChannel}`,\n                    transform: [\n                        {\n                            type: 'sequence',\n                            start: 0,\n                            stop\n                        }\n                    ]\n                });\n            }\n        }\n        const { row, column } = hasSharedAxis;\n        if (row || column) {\n            data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n        }\n        return data;\n    }\n    assemble() {\n        var _a, _b;\n        const data = [];\n        let crossedDataName = null;\n        const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n        const { column, row, facet } = this;\n        if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n            // Need to create a cross dataset to correctly calculate cardinality\n            crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n            const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);\n            const ops = fields.map(() => 'distinct');\n            data.push({\n                name: crossedDataName,\n                source: this.data,\n                transform: [\n                    {\n                        type: 'aggregate',\n                        groupby: this.fields,\n                        fields,\n                        ops\n                    }\n                ]\n            });\n        }\n        for (const channel of [COLUMN, ROW]) {\n            if (this[channel]) {\n                data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n            }\n        }\n        if (facet) {\n            const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n            if (facetData) {\n                data.push(...facetData);\n            }\n        }\n        return data;\n    }\n}\n//# sourceMappingURL=facet.js.map"]},"metadata":{},"sourceType":"module"}