{"ast":null,"code":"const registry = new Map();\n\nfunction addCodec(id, importFn) {\n  registry.set(id, importFn);\n}\n\nasync function getCodec(config) {\n  if (!registry.has(config.id)) {\n    throw new Error(`Compression codec ${config.id} is not supported by Zarr.js yet.`);\n  }\n\n  const codec = await registry.get(config.id)();\n  return codec.fromConfig(config);\n}\n\nfunction createProxy(mapping) {\n  return new Proxy(mapping, {\n    set(target, key, value, _receiver) {\n      return target.setItem(key, value);\n    },\n\n    get(target, key, _receiver) {\n      return target.getItem(key);\n    },\n\n    deleteProperty(target, key) {\n      return target.deleteItem(key);\n    },\n\n    has(target, key) {\n      return target.containsItem(key);\n    }\n\n  });\n}\n\nfunction isZarrError(err) {\n  return typeof err === 'object' && err !== null && '__zarr__' in err;\n}\n\nfunction isKeyError(o) {\n  return isZarrError(o) && o.__zarr__ === 'KeyError';\n} // Custom error messages, note we have to patch the prototype of the\n// errors to fix `instanceof` calls, see:\n// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n\n\nclass ContainsArrayError extends Error {\n  constructor(path) {\n    super(`path ${path} contains an array`);\n    this.__zarr__ = 'ContainsArrayError';\n    Object.setPrototypeOf(this, ContainsArrayError.prototype);\n  }\n\n}\n\nclass ContainsGroupError extends Error {\n  constructor(path) {\n    super(`path ${path} contains a group`);\n    this.__zarr__ = 'ContainsGroupError';\n    Object.setPrototypeOf(this, ContainsGroupError.prototype);\n  }\n\n}\n\nclass ArrayNotFoundError extends Error {\n  constructor(path) {\n    super(`array not found at path ${path}`);\n    this.__zarr__ = 'ArrayNotFoundError';\n    Object.setPrototypeOf(this, ArrayNotFoundError.prototype);\n  }\n\n}\n\nclass GroupNotFoundError extends Error {\n  constructor(path) {\n    super(`ground not found at path ${path}`);\n    this.__zarr__ = 'GroupNotFoundError';\n    Object.setPrototypeOf(this, GroupNotFoundError.prototype);\n  }\n\n}\n\nclass PathNotFoundError extends Error {\n  constructor(path) {\n    super(`nothing not found at path ${path}`);\n    this.__zarr__ = 'PathNotFoundError';\n    Object.setPrototypeOf(this, PathNotFoundError.prototype);\n  }\n\n}\n\nclass PermissionError extends Error {\n  constructor(message) {\n    super(message);\n    this.__zarr__ = 'PermissionError';\n    Object.setPrototypeOf(this, PermissionError.prototype);\n  }\n\n}\n\nclass KeyError extends Error {\n  constructor(key) {\n    super(`key ${key} not present`);\n    this.__zarr__ = 'KeyError';\n    Object.setPrototypeOf(this, KeyError.prototype);\n  }\n\n}\n\nclass TooManyIndicesError extends RangeError {\n  constructor(selection, shape) {\n    super(`too many indices for array; expected ${shape.length}, got ${selection.length}`);\n    this.__zarr__ = 'TooManyIndicesError';\n    Object.setPrototypeOf(this, TooManyIndicesError.prototype);\n  }\n\n}\n\nclass BoundsCheckError extends RangeError {\n  constructor(message) {\n    super(message);\n    this.__zarr__ = 'BoundsCheckError';\n    Object.setPrototypeOf(this, BoundsCheckError.prototype);\n  }\n\n}\n\nclass InvalidSliceError extends RangeError {\n  constructor(from, to, stepSize, reason) {\n    super(`slice arguments slice(${from}, ${to}, ${stepSize}) invalid: ${reason}`);\n    this.__zarr__ = 'InvalidSliceError';\n    Object.setPrototypeOf(this, InvalidSliceError.prototype);\n  }\n\n}\n\nclass NegativeStepError extends Error {\n  constructor() {\n    super(`Negative step size is not supported when indexing.`);\n    this.__zarr__ = 'NegativeStepError';\n    Object.setPrototypeOf(this, NegativeStepError.prototype);\n  }\n\n}\n\nclass ValueError extends Error {\n  constructor(message) {\n    super(message);\n    this.__zarr__ = 'ValueError';\n    Object.setPrototypeOf(this, ValueError.prototype);\n  }\n\n}\n\nclass HTTPError extends Error {\n  constructor(code) {\n    super(code);\n    this.__zarr__ = 'HTTPError';\n    Object.setPrototypeOf(this, HTTPError.prototype);\n  }\n\n}\n\nfunction slice(start, stop = undefined, step = null) {\n  // tslint:disable-next-line: strict-type-predicates\n  if (start === undefined) {\n    // Not possible in typescript\n    throw new InvalidSliceError(start, stop, step, \"The first argument must not be undefined\");\n  }\n\n  if (typeof start === \"string\" && start !== \":\" || typeof stop === \"string\" && stop !== \":\") {\n    // Note in typescript this will never happen with type checking.\n    throw new InvalidSliceError(start, stop, step, \"Arguments can only be integers, \\\":\\\" or null\");\n  } // slice(5) === slice(null, 5)\n\n\n  if (stop === undefined) {\n    stop = start;\n    start = null;\n  } // if (start !== null && stop !== null && start > stop) {\n  //     throw new InvalidSliceError(start, stop, step, \"to is higher than from\");\n  // }\n\n\n  return {\n    start: start === \":\" ? null : start,\n    stop: stop === \":\" ? null : stop,\n    step,\n    _slice: true\n  };\n}\n/**\r\n * Port of adjustIndices\r\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L243\r\n */\n\n\nfunction adjustIndices(start, stop, step, length) {\n  if (start < 0) {\n    start += length;\n\n    if (start < 0) {\n      start = step < 0 ? -1 : 0;\n    }\n  } else if (start >= length) {\n    start = step < 0 ? length - 1 : length;\n  }\n\n  if (stop < 0) {\n    stop += length;\n\n    if (stop < 0) {\n      stop = step < 0 ? -1 : 0;\n    }\n  } else if (stop >= length) {\n    stop = step < 0 ? length - 1 : length;\n  }\n\n  if (step < 0) {\n    if (stop < start) {\n      const length = Math.floor((start - stop - 1) / -step + 1);\n      return [start, stop, step, length];\n    }\n  } else {\n    if (start < stop) {\n      const length = Math.floor((stop - start - 1) / step + 1);\n      return [start, stop, step, length];\n    }\n  }\n\n  return [start, stop, step, 0];\n}\n/**\r\n * Port of slice.indices(n) and PySlice_Unpack\r\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L166\r\n *  https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L198\r\n *\r\n * Behaviour might be slightly different as it's a weird hybrid implementation.\r\n */\n\n\nfunction sliceIndices(slice, length) {\n  let start;\n  let stop;\n  let step;\n\n  if (slice.step === null) {\n    step = 1;\n  } else {\n    step = slice.step;\n  }\n\n  if (slice.start === null) {\n    start = step < 0 ? Number.MAX_SAFE_INTEGER : 0;\n  } else {\n    start = slice.start;\n\n    if (start < 0) {\n      start += length;\n    }\n  }\n\n  if (slice.stop === null) {\n    stop = step < 0 ? -Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;\n  } else {\n    stop = slice.stop;\n\n    if (stop < 0) {\n      stop += length;\n    }\n  } // This clips out of bounds slices\n\n\n  const s = adjustIndices(start, stop, step, length);\n  start = s[0];\n  stop = s[1];\n  step = s[2]; // The output length\n\n  length = s[3]; // With out of bounds slicing these two assertions are not useful.\n  // if (stop > length) throw new Error(\"Stop greater than length\");\n  // if (start >= length) throw new Error(\"Start greater than or equal to length\");\n\n  if (step === 0) throw new Error(\"Step size 0 is invalid\");\n  return [start, stop, step, length];\n}\n\nfunction ensureArray(selection) {\n  if (!Array.isArray(selection)) {\n    return [selection];\n  }\n\n  return selection;\n}\n\nfunction checkSelectionLength(selection, shape) {\n  if (selection.length > shape.length) {\n    throw new TooManyIndicesError(selection, shape);\n  }\n}\n/**\r\n * Returns both the sliceIndices per dimension and the output shape after slicing.\r\n */\n\n\nfunction selectionToSliceIndices(selection, shape) {\n  const sliceIndicesResult = [];\n  const outShape = [];\n\n  for (let i = 0; i < selection.length; i++) {\n    const s = selection[i];\n\n    if (typeof s === \"number\") {\n      sliceIndicesResult.push(s);\n    } else {\n      const x = sliceIndices(s, shape[i]);\n      const dimLength = x[3];\n      outShape.push(dimLength);\n      sliceIndicesResult.push(x);\n    }\n  }\n\n  return [sliceIndicesResult, outShape];\n}\n/**\r\n * This translates \"...\", \":\", null into a list of slices or non-negative integer selections of length shape\r\n */\n\n\nfunction normalizeArraySelection(selection, shape, convertIntegerSelectionToSlices = false) {\n  selection = replaceEllipsis(selection, shape);\n\n  for (let i = 0; i < selection.length; i++) {\n    const dimSelection = selection[i];\n\n    if (typeof dimSelection === \"number\") {\n      if (convertIntegerSelectionToSlices) {\n        selection[i] = slice(dimSelection, dimSelection + 1, 1);\n      } else {\n        selection[i] = normalizeIntegerSelection(dimSelection, shape[i]);\n      }\n    } else if (isIntegerArray(dimSelection)) {\n      throw new TypeError(\"Integer array selections are not supported (yet)\");\n    } else if (dimSelection === \":\" || dimSelection === null) {\n      selection[i] = slice(null, null, 1);\n    }\n  }\n\n  return selection;\n}\n\nfunction replaceEllipsis(selection, shape) {\n  selection = ensureArray(selection);\n  let ellipsisIndex = -1;\n  let numEllipsis = 0;\n\n  for (let i = 0; i < selection.length; i++) {\n    if (selection[i] === \"...\") {\n      ellipsisIndex = i;\n      numEllipsis += 1;\n    }\n  }\n\n  if (numEllipsis > 1) {\n    throw new RangeError(\"an index can only have a single ellipsis ('...')\");\n  }\n\n  if (numEllipsis === 1) {\n    // count how many items to left and right of ellipsis\n    const numItemsLeft = ellipsisIndex;\n    const numItemsRight = selection.length - (numItemsLeft + 1);\n    const numItems = selection.length - 1; // All non-ellipsis items\n\n    if (numItems >= shape.length) {\n      // Ellipsis does nothing, just remove it\n      selection = selection.filter(x => x !== \"...\");\n    } else {\n      // Replace ellipsis with as many slices are needed for number of dims\n      const numNewItems = shape.length - numItems;\n      let newItem = selection.slice(0, numItemsLeft).concat(new Array(numNewItems).fill(null));\n\n      if (numItemsRight > 0) {\n        newItem = newItem.concat(selection.slice(selection.length - numItemsRight));\n      }\n\n      selection = newItem;\n    }\n  } // Fill out selection if not completely specified\n\n\n  if (selection.length < shape.length) {\n    const numMissing = shape.length - selection.length;\n    selection = selection.concat(new Array(numMissing).fill(null));\n  }\n\n  checkSelectionLength(selection, shape);\n  return selection;\n}\n\nfunction normalizeIntegerSelection(dimSelection, dimLength) {\n  // Note: Maybe we should convert to integer or warn if dimSelection is not an integer\n  // handle wraparound\n  if (dimSelection < 0) {\n    dimSelection = dimLength + dimSelection;\n  } // handle out of bounds\n\n\n  if (dimSelection >= dimLength || dimSelection < 0) {\n    throw new BoundsCheckError(`index out of bounds for dimension with length ${dimLength}`);\n  }\n\n  return dimSelection;\n}\n\nfunction isInteger(s) {\n  return typeof s === \"number\";\n}\n\nfunction isIntegerArray(s) {\n  if (!Array.isArray(s)) {\n    return false;\n  }\n\n  for (const e of s) {\n    if (typeof e !== \"number\") {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isSlice(s) {\n  if (s !== null && s[\"_slice\"] === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isContiguousSlice(s) {\n  return isSlice(s) && (s.step === null || s.step === 1);\n}\n\nfunction isContiguousSelection(selection) {\n  selection = ensureArray(selection);\n\n  for (let i = 0; i < selection.length; i++) {\n    const s = selection[i];\n\n    if (!(isIntegerArray(s) || isContiguousSlice(s) || s === \"...\")) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction* product(...iterables) {\n  if (iterables.length === 0) {\n    return;\n  } // make a list of iterators from the iterables\n\n\n  const iterators = iterables.map(it => it());\n  const results = iterators.map(it => it.next()); // Disabled to allow empty inputs\n  // if (results.some(r => r.done)) {\n  //     throw new Error(\"Input contains an empty iterator.\");\n  // }\n\n  for (let i = 0;;) {\n    if (results[i].done) {\n      // reset the current iterator\n      iterators[i] = iterables[i]();\n      results[i] = iterators[i].next(); // advance, and exit if we've reached the end\n\n      if (++i >= iterators.length) {\n        return;\n      }\n    } else {\n      yield results.map(({\n        value\n      }) => value);\n      i = 0;\n    }\n\n    results[i] = iterators[i].next();\n  }\n}\n\nclass BasicIndexer {\n  constructor(selection, array) {\n    selection = normalizeArraySelection(selection, array.shape); // Setup per-dimension indexers\n\n    this.dimIndexers = [];\n    const arrayShape = array.shape;\n\n    for (let i = 0; i < arrayShape.length; i++) {\n      let dimSelection = selection[i];\n      const dimLength = arrayShape[i];\n      const dimChunkLength = array.chunks[i];\n\n      if (dimSelection === null) {\n        dimSelection = slice(null);\n      }\n\n      if (isInteger(dimSelection)) {\n        this.dimIndexers.push(new IntDimIndexer(dimSelection, dimLength, dimChunkLength));\n      } else if (isSlice(dimSelection)) {\n        this.dimIndexers.push(new SliceDimIndexer(dimSelection, dimLength, dimChunkLength));\n      } else {\n        throw new RangeError(`Unspported selection item for basic indexing; expected integer or slice, got ${dimSelection}`);\n      }\n    }\n\n    this.shape = [];\n\n    for (const d of this.dimIndexers) {\n      if (d instanceof SliceDimIndexer) {\n        this.shape.push(d.numItems);\n      }\n    }\n\n    this.dropAxes = null;\n  }\n\n  *iter() {\n    const dimIndexerIterables = this.dimIndexers.map(x => () => x.iter());\n    const dimIndexerProduct = product(...dimIndexerIterables);\n\n    for (const dimProjections of dimIndexerProduct) {\n      // TODO fix this, I think the product outputs too many combinations\n      const chunkCoords = [];\n      const chunkSelection = [];\n      const outSelection = [];\n\n      for (const p of dimProjections) {\n        chunkCoords.push(p.dimChunkIndex);\n        chunkSelection.push(p.dimChunkSelection);\n\n        if (p.dimOutSelection !== null) {\n          outSelection.push(p.dimOutSelection);\n        }\n      }\n\n      yield {\n        chunkCoords,\n        chunkSelection,\n        outSelection\n      };\n    }\n  }\n\n}\n\nclass IntDimIndexer {\n  constructor(dimSelection, dimLength, dimChunkLength) {\n    dimSelection = normalizeIntegerSelection(dimSelection, dimLength);\n    this.dimSelection = dimSelection;\n    this.dimLength = dimLength;\n    this.dimChunkLength = dimChunkLength;\n    this.numItems = 1;\n  }\n\n  *iter() {\n    const dimChunkIndex = Math.floor(this.dimSelection / this.dimChunkLength);\n    const dimOffset = dimChunkIndex * this.dimChunkLength;\n    const dimChunkSelection = this.dimSelection - dimOffset;\n    const dimOutSelection = null;\n    yield {\n      dimChunkIndex,\n      dimChunkSelection,\n      dimOutSelection\n    };\n  }\n\n}\n\nclass SliceDimIndexer {\n  constructor(dimSelection, dimLength, dimChunkLength) {\n    // Normalize\n    const [start, stop, step] = sliceIndices(dimSelection, dimLength);\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n\n    if (this.step < 1) {\n      throw new NegativeStepError();\n    }\n\n    this.dimLength = dimLength;\n    this.dimChunkLength = dimChunkLength;\n    this.numItems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n    this.numChunks = Math.ceil(this.dimLength / this.dimChunkLength);\n  }\n\n  *iter() {\n    const dimChunkIndexFrom = Math.floor(this.start / this.dimChunkLength);\n    const dimChunkIndexTo = Math.ceil(this.stop / this.dimChunkLength); // Iterate over chunks in range\n\n    for (let dimChunkIndex = dimChunkIndexFrom; dimChunkIndex < dimChunkIndexTo; dimChunkIndex++) {\n      // Compute offsets for chunk within overall array\n      const dimOffset = dimChunkIndex * this.dimChunkLength;\n      const dimLimit = Math.min(this.dimLength, (dimChunkIndex + 1) * this.dimChunkLength); // Determine chunk length, accounting for trailing chunk\n\n      const dimChunkLength = dimLimit - dimOffset;\n      let dimChunkSelStart;\n      let dimChunkSelStop;\n      let dimOutOffset;\n\n      if (this.start < dimOffset) {\n        // Selection starts before current chunk\n        dimChunkSelStart = 0;\n        const remainder = (dimOffset - this.start) % this.step;\n\n        if (remainder > 0) {\n          dimChunkSelStart += this.step - remainder;\n        } // Compute number of previous items, provides offset into output array\n\n\n        dimOutOffset = Math.ceil((dimOffset - this.start) / this.step);\n      } else {\n        // Selection starts within current chunk\n        dimChunkSelStart = this.start - dimOffset;\n        dimOutOffset = 0;\n      }\n\n      if (this.stop > dimLimit) {\n        // Selection ends after current chunk\n        dimChunkSelStop = dimChunkLength;\n      } else {\n        // Selection ends within current chunk\n        dimChunkSelStop = this.stop - dimOffset;\n      }\n\n      const dimChunkSelection = slice(dimChunkSelStart, dimChunkSelStop, this.step);\n      const dimChunkNumItems = Math.ceil((dimChunkSelStop - dimChunkSelStart) / this.step);\n      const dimOutSelection = slice(dimOutOffset, dimOutOffset + dimChunkNumItems);\n      yield {\n        dimChunkIndex,\n        dimChunkSelection,\n        dimOutSelection\n      };\n    }\n  }\n\n}\n/**\r\n * This should be true only if this javascript is getting executed in Node.\r\n */\n\n\nconst IS_NODE = typeof process !== \"undefined\" && process.versions && process.versions.node; // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction normalizeStoragePath(path) {\n  if (path === null) {\n    return \"\";\n  }\n\n  if (path instanceof String) {\n    path = path.valueOf();\n  } // convert backslash to forward slash\n\n\n  path = path.replace(/\\\\/g, \"/\"); // ensure no leading slash\n\n  while (path.length > 0 && path[0] === '/') {\n    path = path.slice(1);\n  } // ensure no trailing slash\n\n\n  while (path.length > 0 && path[path.length - 1] === '/') {\n    path = path.slice(0, path.length - 1);\n  } // collapse any repeated slashes\n\n\n  path = path.replace(/\\/\\/+/g, \"/\"); // don't allow path segments with just '.' or '..'\n\n  const segments = path.split('/');\n\n  for (const s of segments) {\n    if (s === \".\" || s === \"..\") {\n      throw Error(\"path containing '.' or '..' segment not allowed\");\n    }\n  }\n\n  return path;\n}\n\nfunction normalizeShape(shape) {\n  if (typeof shape === \"number\") {\n    shape = [shape];\n  }\n\n  return shape.map(x => Math.floor(x));\n}\n\nfunction normalizeChunks(chunks, shape) {\n  // Assume shape is already normalized\n  if (chunks === null || chunks === true) {\n    throw new Error(\"Chunk guessing is not supported yet\");\n  }\n\n  if (chunks === false) {\n    return shape;\n  }\n\n  if (typeof chunks === \"number\") {\n    chunks = [chunks];\n  } // handle underspecified chunks\n\n\n  if (chunks.length < shape.length) {\n    // assume chunks across remaining dimensions\n    chunks = chunks.concat(shape.slice(chunks.length));\n  }\n\n  return chunks.map((x, idx) => {\n    // handle null or -1 in chunks\n    if (x === -1 || x === null) {\n      return shape[idx];\n    } else {\n      return Math.floor(x);\n    }\n  });\n}\n\nfunction normalizeOrder(order) {\n  order = order.toUpperCase();\n  return order;\n}\n\nfunction normalizeDtype(dtype) {\n  return dtype;\n}\n\nfunction normalizeFillValue(fillValue) {\n  return fillValue;\n}\n/**\r\n * Determine whether `item` specifies a complete slice of array with the\r\n *  given `shape`. Used to optimize __setitem__ operations on chunks\r\n * @param item\r\n * @param shape\r\n */\n\n\nfunction isTotalSlice(item, shape) {\n  if (item === null) {\n    return true;\n  }\n\n  if (!Array.isArray(item)) {\n    item = [item];\n  }\n\n  for (let i = 0; i < Math.min(item.length, shape.length); i++) {\n    const it = item[i];\n    if (it === null) continue;\n\n    if (isSlice(it)) {\n      const s = it;\n      const isStepOne = s.step === 1 || s.step === null;\n\n      if (s.start === null && s.stop === null && isStepOne) {\n        continue;\n      }\n\n      if (s.stop - s.start === shape[i] && isStepOne) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return false; // } else {\n    //     console.error(`isTotalSlice unexpected non-slice, got ${it}`);\n    //     return false;\n    // }\n  }\n\n  return true;\n}\n/**\r\n * Checks for === equality of all elements.\r\n */\n\n\nfunction arrayEquals1D(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*\r\n * Determines \"C\" order strides for a given shape array.\r\n * Strides provide integer steps in each dimention to traverse an ndarray.\r\n *\r\n * NOTE: - These strides here are distinct from numpy.ndarray.strides, which describe actual byte steps.\r\n *       - Strides are assumed to be contiguous, so initial step is 1. Thus, output will always be [XX, XX, 1].\r\n */\n\n\nfunction getStrides(shape) {\n  // adapted from https://github.com/scijs/ndarray/blob/master/ndarray.js#L326-L330\n  const ndim = shape.length;\n  const strides = Array(ndim);\n  let step = 1; // init step\n\n  for (let i = ndim - 1; i >= 0; i--) {\n    strides[i] = step;\n    step *= shape[i];\n  }\n\n  return strides;\n}\n/**\r\n * Preserves (double) slashes earlier in the path, so this works better\r\n * for URLs. From https://stackoverflow.com/a/46427607/4178400\r\n * @param args parts of a path or URL to join.\r\n */\n\n\nfunction joinUrlParts(...args) {\n  return args.map((part, i) => {\n    if (i === 0) {\n      return part.trim().replace(/[\\/]*$/g, '');\n    } else {\n      return part.trim().replace(/(^[\\/]*|[\\/]*$)/g, '');\n    }\n  }).filter(x => x.length).join('/');\n}\n/**\r\n * Swaps byte order in-place for a given TypedArray.\r\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\r\n * @param src TypedArray\r\n */\n\n\nfunction byteSwapInplace(src) {\n  const b = src.BYTES_PER_ELEMENT;\n  if (b === 1) return; // no swapping needed\n\n  if (IS_NODE) {\n    // Use builtin methods for swapping if in Node environment\n    const bytes = Buffer.from(src.buffer, src.byteOffset, src.length * b);\n    if (b === 2) bytes.swap16();\n    if (b === 4) bytes.swap32();\n    if (b === 8) bytes.swap64();\n    return;\n  } // In browser, need to flip manually\n  // Adapted from https://github.com/zbjornson/node-bswap/blob/master/bswap.js\n\n\n  const flipper = new Uint8Array(src.buffer, src.byteOffset, src.length * b);\n  const numFlips = b / 2;\n  const endByteIndex = b - 1;\n  let t;\n\n  for (let i = 0; i < flipper.length; i += b) {\n    for (let j = 0; j < numFlips; j++) {\n      t = flipper[i + j];\n      flipper[i + j] = flipper[i + endByteIndex - j];\n      flipper[i + endByteIndex - j] = t;\n    }\n  }\n}\n/**\r\n * Creates a copy of a TypedArray and swaps bytes.\r\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\r\n * @param src TypedArray\r\n */\n\n\nfunction byteSwap(src) {\n  const copy = src.slice();\n  byteSwapInplace(copy);\n  return copy;\n}\n\nconst ARRAY_META_KEY = \".zarray\";\nconst GROUP_META_KEY = \".zgroup\";\nconst ATTRS_META_KEY = \".zattrs\";\n/**\r\n * Return true if the store contains an array at the given logical path.\r\n */\n\nasync function containsArray(store, path = null) {\n  path = normalizeStoragePath(path);\n  const prefix = pathToPrefix(path);\n  const key = prefix + ARRAY_META_KEY;\n  return store.containsItem(key);\n}\n/**\r\n * Return true if the store contains a group at the given logical path.\r\n */\n\n\nasync function containsGroup(store, path = null) {\n  path = normalizeStoragePath(path);\n  const prefix = pathToPrefix(path);\n  const key = prefix + GROUP_META_KEY;\n  return store.containsItem(key);\n}\n\nfunction pathToPrefix(path) {\n  // assume path already normalized\n  if (path.length > 0) {\n    return path + '/';\n  }\n\n  return '';\n}\n\nasync function requireParentGroup(store, path, chunkStore, overwrite) {\n  // Assume path is normalized\n  if (path.length === 0) {\n    return;\n  }\n\n  const segments = path.split(\"/\");\n  let p = \"\";\n\n  for (const s of segments.slice(0, segments.length - 1)) {\n    p += s;\n\n    if (await containsArray(store, p)) {\n      await initGroupMetadata(store, p, overwrite);\n    } else if (!(await containsGroup(store, p))) {\n      await initGroupMetadata(store, p);\n    }\n\n    p += \"/\";\n  }\n}\n\nasync function initGroupMetadata(store, path = null, overwrite = false) {\n  path = normalizeStoragePath(path); // Guard conditions\n\n  if (overwrite) {\n    throw Error(\"Group overwriting not implemented yet :(\");\n  } else if (await containsArray(store, path)) {\n    throw new ContainsArrayError(path);\n  } else if (await containsGroup(store, path)) {\n    throw new ContainsGroupError(path);\n  }\n\n  const metadata = {\n    zarr_format: 2\n  };\n  const key = pathToPrefix(path) + GROUP_META_KEY;\n  await store.setItem(key, JSON.stringify(metadata));\n}\n/**\r\n *  Initialize a group store. Note that this is a low-level function and there should be no\r\n *  need to call this directly from user code.\r\n */\n\n\nasync function initGroup(store, path = null, chunkStore = null, overwrite = false) {\n  path = normalizeStoragePath(path);\n  await requireParentGroup(store, path, chunkStore, overwrite);\n  await initGroupMetadata(store, path, overwrite);\n}\n\nasync function initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters) {\n  // Guard conditions\n  if (overwrite) {\n    throw Error(\"Array overwriting not implemented yet :(\");\n  } else if (await containsArray(store, path)) {\n    throw new ContainsArrayError(path);\n  } else if (await containsGroup(store, path)) {\n    throw new ContainsGroupError(path);\n  } // Normalize metadata,  does type checking too.\n\n\n  dtype = normalizeDtype(dtype);\n  shape = normalizeShape(shape);\n  chunks = normalizeChunks(chunks, shape);\n  order = normalizeOrder(order);\n  fillValue = normalizeFillValue(fillValue);\n\n  if (filters !== null && filters.length > 0) {\n    throw Error(\"Filters are not supported yet\");\n  }\n\n  let serializedFillValue = fillValue;\n\n  if (typeof fillValue === \"number\") {\n    if (Number.isNaN(fillValue)) serializedFillValue = \"NaN\";\n    if (Number.POSITIVE_INFINITY === fillValue) serializedFillValue = \"Infinity\";\n    if (Number.NEGATIVE_INFINITY === fillValue) serializedFillValue = \"-Infinity\";\n  }\n\n  filters = null;\n  const metadata = {\n    zarr_format: 2,\n    shape: shape,\n    chunks: chunks,\n    dtype: dtype,\n    fill_value: serializedFillValue,\n    order: order,\n    compressor: compressor,\n    filters: filters\n  };\n  const metaKey = pathToPrefix(path) + ARRAY_META_KEY;\n  await store.setItem(metaKey, JSON.stringify(metadata));\n}\n/**\r\n *\r\n * Initialize an array store with the given configuration. Note that this is a low-level\r\n * function and there should be no need to call this directly from user code\r\n */\n\n\nasync function initArray(store, shape, chunks, dtype, path = null, compressor = null, fillValue = null, order = \"C\", overwrite = false, chunkStore = null, filters = null) {\n  path = normalizeStoragePath(path);\n  await requireParentGroup(store, path, chunkStore, overwrite);\n  await initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n}\n\nfunction parseMetadata(s) {\n  // Here we allow that a store may return an already-parsed metadata object,\n  // or a string of JSON that we will parse here. We allow for an already-parsed\n  // object to accommodate a consolidated metadata store, where all the metadata for\n  // all groups and arrays will already have been parsed from JSON.\n  if (typeof s !== 'string') {\n    // tslint:disable-next-line: strict-type-predicates\n    if (IS_NODE && Buffer.isBuffer(s)) {\n      return JSON.parse(s.toString());\n    } else if (s instanceof ArrayBuffer) {\n      const utf8Decoder = new TextDecoder();\n      const bytes = new Uint8Array(s);\n      return JSON.parse(utf8Decoder.decode(bytes));\n    } else {\n      return s;\n    }\n  }\n\n  return JSON.parse(s);\n}\n/**\r\n * Class providing access to user attributes on an array or group. Should not be\r\n * instantiated directly, will be available via the `.attrs` property of an array or\r\n * group.\r\n */\n\n\nclass Attributes {\n  constructor(store, key, readOnly, cache = true) {\n    this.store = store;\n    this.key = key;\n    this.readOnly = readOnly;\n    this.cache = cache;\n    this.cachedValue = null;\n  }\n  /**\r\n   * Retrieve all attributes as a JSON object.\r\n   */\n\n\n  async asObject() {\n    if (this.cache && this.cachedValue !== null) {\n      return this.cachedValue;\n    }\n\n    const o = await this.getNoSync();\n\n    if (this.cache) {\n      this.cachedValue = o;\n    }\n\n    return o;\n  }\n\n  async getNoSync() {\n    try {\n      const data = await this.store.getItem(this.key); // TODO fix typing?\n\n      return parseMetadata(data);\n    } catch (error) {\n      return {};\n    }\n  }\n\n  async setNoSync(key, value) {\n    const d = await this.getNoSync();\n    d[key] = value;\n    await this.putNoSync(d);\n    return true;\n  }\n\n  async putNoSync(m) {\n    await this.store.setItem(this.key, JSON.stringify(m));\n\n    if (this.cache) {\n      this.cachedValue = m;\n    }\n  }\n\n  async delNoSync(key) {\n    const d = await this.getNoSync();\n    delete d[key];\n    await this.putNoSync(d);\n    return true;\n  }\n  /**\r\n   * Overwrite all attributes with the provided object in a single operation\r\n   */\n\n\n  async put(d) {\n    if (this.readOnly) {\n      throw new PermissionError(\"attributes are read-only\");\n    }\n\n    return this.putNoSync(d);\n  }\n\n  async setItem(key, value) {\n    if (this.readOnly) {\n      throw new PermissionError(\"attributes are read-only\");\n    }\n\n    return this.setNoSync(key, value);\n  }\n\n  async getItem(key) {\n    return (await this.asObject())[key];\n  }\n\n  async deleteItem(key) {\n    if (this.readOnly) {\n      throw new PermissionError(\"attributes are read-only\");\n    }\n\n    return this.delNoSync(key);\n  }\n\n  async containsItem(key) {\n    return (await this.asObject())[key] !== undefined;\n  }\n\n  proxy() {\n    return createProxy(this);\n  }\n\n}\n\nconst DTYPE_TYPEDARRAY_MAPPING = {\n  '|b': Int8Array,\n  '|B': Uint8Array,\n  '|u1': Uint8Array,\n  '|i1': Int8Array,\n  '<b': Int8Array,\n  '<B': Uint8Array,\n  '<u1': Uint8Array,\n  '<i1': Int8Array,\n  '<u2': Uint16Array,\n  '<i2': Int16Array,\n  '<u4': Uint32Array,\n  '<i4': Int32Array,\n  '<f4': Float32Array,\n  '<f8': Float64Array,\n  '>b': Int8Array,\n  '>B': Uint8Array,\n  '>u1': Uint8Array,\n  '>i1': Int8Array,\n  '>u2': Uint16Array,\n  '>i2': Int16Array,\n  '>u4': Uint32Array,\n  '>i4': Int32Array,\n  '>f4': Float32Array,\n  '>f8': Float64Array\n};\n/*\r\n * Called by NestedArray and RawArray constructors only.\r\n * We byte-swap the buffer of a store after decoding\r\n * since TypedArray views are little endian only.\r\n *\r\n * This means NestedArrays and RawArrays will always be little endian,\r\n * unless a numpy-like library comes around and can handle endianess\r\n * for buffer views.\r\n */\n\nfunction getTypedArrayDtypeString(t) {\n  // Favour the types below instead of small and big B\n  if (t instanceof Uint8Array) return '|u1';\n  if (t instanceof Int8Array) return '|i1';\n  if (t instanceof Uint16Array) return '<u2';\n  if (t instanceof Int16Array) return '<i2';\n  if (t instanceof Uint32Array) return '<u4';\n  if (t instanceof Int32Array) return '<i4';\n  if (t instanceof Float32Array) return '<f4';\n  if (t instanceof Float64Array) return '<f8';\n  throw new ValueError('Mapping for TypedArray to Dtypestring not known');\n}\n/**\r\n * Digs down into the dimensions of given array to find the TypedArray and returns its constructor.\r\n * Better to use sparingly.\r\n */\n\n\nfunction getNestedArrayConstructor(arr) {\n  // TODO fix typing\n  // tslint:disable-next-line: strict-type-predicates\n  if (arr.byteLength !== undefined) {\n    return arr.constructor;\n  }\n\n  return getNestedArrayConstructor(arr[0]);\n}\n/**\r\n * Returns both the slice result and new output shape\r\n * @param arr NestedArray to slice\r\n * @param shape The shape of the NestedArray\r\n * @param selection\r\n */\n\n\nfunction sliceNestedArray(arr, shape, selection) {\n  // This translates \"...\", \":\", null into a list of slices or integer selections\n  const normalizedSelection = normalizeArraySelection(selection, shape);\n  const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, shape);\n\n  const outArray = _sliceNestedArray(arr, shape, sliceIndices);\n\n  return [outArray, outShape];\n}\n\nfunction _sliceNestedArray(arr, shape, selection) {\n  const currentSlice = selection[0]; // Is this necessary?\n  // // This is possible when a slice list is passed shorter than the amount of dimensions\n  // // tslint:disable-next-line: strict-type-predicates\n  // if (currentSlice === undefined) {\n  //     return arr.slice();\n  // }\n  // When a number is passed that dimension is squeezed\n\n  if (typeof currentSlice === \"number\") {\n    // Assume already normalized integer selection here.\n    if (shape.length === 1) {\n      return arr[currentSlice];\n    } else {\n      return _sliceNestedArray(arr[currentSlice], shape.slice(1), selection.slice(1));\n    }\n  }\n\n  const [from, to, step, outputSize] = currentSlice;\n\n  if (outputSize === 0) {\n    return new (getNestedArrayConstructor(arr))(0);\n  }\n\n  if (shape.length === 1) {\n    if (step === 1) {\n      return arr.slice(from, to);\n    }\n\n    const newArrData = new arr.constructor(outputSize);\n\n    for (let i = 0; i < outputSize; i++) {\n      newArrData[i] = arr[from + i * step];\n    }\n\n    return newArrData;\n  }\n\n  let newArr = new Array(outputSize);\n\n  for (let i = 0; i < outputSize; i++) {\n    newArr[i] = _sliceNestedArray(arr[from + i * step], shape.slice(1), selection.slice(1));\n  } // This is necessary to ensure that the return value is a NestedArray if the last dimension is squeezed\n  // e.g. shape [2,1] with slice [:, 0] would otherwise result in a list of numbers instead of a valid NestedArray\n\n\n  if (outputSize > 0 && typeof newArr[0] === \"number\") {\n    const typedArrayConstructor = arr[0].constructor;\n    newArr = typedArrayConstructor.from(newArr);\n  }\n\n  return newArr;\n}\n\nfunction setNestedArrayToScalar(dstArr, value, destShape, selection) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  const normalizedSelection = normalizeArraySelection(selection, destShape, true); // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n\n  const [sliceIndices, _outShape] = selectionToSliceIndices(normalizedSelection, destShape);\n\n  _setNestedArrayToScalar(dstArr, value, destShape, sliceIndices);\n}\n\nfunction setNestedArray(dstArr, sourceArr, destShape, sourceShape, selection) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  const normalizedSelection = normalizeArraySelection(selection, destShape, false);\n  const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, destShape); // TODO: replace with non stringify equality check\n\n  if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n    throw new ValueError(`Shape mismatch in target and source NestedArray: ${outShape} and ${sourceShape}`);\n  }\n\n  _setNestedArray(dstArr, sourceArr, destShape, sliceIndices);\n}\n\nfunction _setNestedArray(dstArr, sourceArr, shape, selection) {\n  const currentSlice = selection[0];\n\n  if (typeof sourceArr === \"number\") {\n    _setNestedArrayToScalar(dstArr, sourceArr, shape, selection.map(x => typeof x === \"number\" ? [x, x + 1, 1, 1] : x));\n\n    return;\n  } // This dimension is squeezed.\n\n\n  if (typeof currentSlice === \"number\") {\n    _setNestedArray(dstArr[currentSlice], sourceArr, shape.slice(1), selection.slice(1));\n\n    return;\n  }\n\n  const [from, _to, step, outputSize] = currentSlice;\n\n  if (shape.length === 1) {\n    if (step === 1) {\n      dstArr.set(sourceArr, from);\n    } else {\n      for (let i = 0; i < outputSize; i++) {\n        dstArr[from + i * step] = sourceArr[i];\n      }\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < outputSize; i++) {\n    _setNestedArray(dstArr[from + i * step], sourceArr[i], shape.slice(1), selection.slice(1));\n  }\n}\n\nfunction _setNestedArrayToScalar(dstArr, value, shape, selection) {\n  const currentSlice = selection[0];\n  const [from, to, step, outputSize] = currentSlice;\n\n  if (shape.length === 1) {\n    if (step === 1) {\n      dstArr.fill(value, from, to);\n    } else {\n      for (let i = 0; i < outputSize; i++) {\n        dstArr[from + i * step] = value;\n      }\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < outputSize; i++) {\n    _setNestedArrayToScalar(dstArr[from + i * step], value, shape.slice(1), selection.slice(1));\n  }\n}\n\nfunction flattenNestedArray(arr, shape, constr) {\n  if (constr === undefined) {\n    constr = getNestedArrayConstructor(arr);\n  }\n\n  const size = shape.reduce((x, y) => x * y, 1);\n  const outArr = new constr(size);\n\n  _flattenNestedArray(arr, shape, outArr, 0);\n\n  return outArr;\n}\n\nfunction _flattenNestedArray(arr, shape, outArr, offset) {\n  if (shape.length === 1) {\n    // This is only ever reached if called with rank 1 shape, never reached through recursion.\n    // We just slice set the array directly from one level above to save some function calls.\n    outArr.set(arr, offset);\n    return;\n  }\n\n  if (shape.length === 2) {\n    for (let i = 0; i < shape[0]; i++) {\n      outArr.set(arr[i], offset + shape[1] * i);\n    }\n\n    return arr;\n  }\n\n  const nextShape = shape.slice(1); // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n\n  const mult = nextShape.reduce((x, y) => x * y, 1);\n\n  for (let i = 0; i < shape[0]; i++) {\n    _flattenNestedArray(arr[i], nextShape, outArr, offset + mult * i);\n  }\n\n  return arr;\n}\n\nclass NestedArray {\n  constructor(data, shape, dtype) {\n    const dataIsTypedArray = data !== null && !!data.BYTES_PER_ELEMENT;\n\n    if (shape === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n      }\n\n      shape = [data.length];\n    }\n\n    if (dtype === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n      }\n\n      dtype = getTypedArrayDtypeString(data);\n    }\n\n    shape = normalizeShape(shape);\n    this.shape = shape;\n    this.dtype = dtype;\n\n    if (dataIsTypedArray && shape.length !== 1) {\n      data = data.buffer;\n    } // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n\n\n    if (this.shape.length === 0) {\n      this.data = new DTYPE_TYPEDARRAY_MAPPING[dtype](1);\n    } else if ( // tslint:disable-next-line: strict-type-predicates\n    IS_NODE && Buffer.isBuffer(data) || data instanceof ArrayBuffer || data === null || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n    ) {\n      // Create from ArrayBuffer or Buffer\n      const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n      if (data === null) {\n        data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n      }\n\n      const numDataElements = data.byteLength / parseInt(dtype[dtype.length - 1], 10);\n\n      if (numShapeElements !== numDataElements) {\n        throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n      }\n\n      const typeConstructor = DTYPE_TYPEDARRAY_MAPPING[dtype];\n      this.data = createNestedArray(data, typeConstructor, shape);\n    } else {\n      this.data = data;\n    }\n  }\n\n  get(selection) {\n    const [sliceResult, outShape] = sliceNestedArray(this.data, this.shape, selection);\n\n    if (outShape.length === 0) {\n      return sliceResult;\n    } else {\n      return new NestedArray(sliceResult, outShape, this.dtype);\n    }\n  }\n\n  set(selection = null, value) {\n    if (selection === null) {\n      selection = [slice(null)];\n    }\n\n    if (typeof value === \"number\") {\n      if (this.shape.length === 0) {\n        // Zero dimension array..\n        this.data[0] = value;\n      } else {\n        setNestedArrayToScalar(this.data, value, this.shape, selection);\n      }\n    } else {\n      setNestedArray(this.data, value.data, this.shape, value.shape, selection);\n    }\n  }\n\n  flatten() {\n    if (this.shape.length === 1) {\n      return this.data;\n    }\n\n    return flattenNestedArray(this.data, this.shape, DTYPE_TYPEDARRAY_MAPPING[this.dtype]);\n  }\n  /**\r\n   * Currently only supports a single integer as the size, TODO: support start, stop, step.\r\n   */\n\n\n  static arange(size, dtype = \"<i4\") {\n    const constr = DTYPE_TYPEDARRAY_MAPPING[dtype];\n    const data = rangeTypedArray([size], constr);\n    return new NestedArray(data, [size], dtype);\n  }\n\n}\n/**\r\n * Creates a TypedArray with values 0 through N where N is the product of the shape.\r\n */\n\n\nfunction rangeTypedArray(shape, tContructor) {\n  const size = shape.reduce((x, y) => x * y, 1);\n  const data = new tContructor(size);\n  data.set([...Array(size).keys()]); // Sets range 0,1,2,3,4,5\n\n  return data;\n}\n/**\r\n * Creates multi-dimensional (rank > 1) array given input data and shape recursively.\r\n * What it does is create a Array<Array<...<Array<Uint8Array>>> or some other typed array.\r\n * This is for internal use, there should be no need to call this from user code.\r\n * @param data a buffer containing the data for this array.\r\n * @param t constructor for the datatype of choice\r\n * @param shape list of numbers describing the size in each dimension\r\n * @param offset in bytes for this dimension\r\n */\n\n\nfunction createNestedArray(data, t, shape, offset = 0) {\n  if (shape.length === 1) {\n    // This is only ever reached if called with rank 1 shape, never reached through recursion.\n    // We just slice set the array directly from one level above to save some function calls.\n    return new t(data.slice(offset, offset + shape[0] * t.BYTES_PER_ELEMENT));\n  }\n\n  const arr = new Array(shape[0]);\n\n  if (shape.length === 2) {\n    for (let i = 0; i < shape[0]; i++) {\n      arr[i] = new t(data.slice(offset + shape[1] * i * t.BYTES_PER_ELEMENT, offset + shape[1] * (i + 1) * t.BYTES_PER_ELEMENT));\n    }\n\n    return arr;\n  }\n\n  const nextShape = shape.slice(1); // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n\n  const mult = nextShape.reduce((x, y) => x * y, 1);\n\n  for (let i = 0; i < shape[0]; i++) {\n    arr[i] = createNestedArray(data, t, nextShape, offset + mult * i * t.BYTES_PER_ELEMENT);\n  }\n\n  return arr;\n}\n\nfunction setRawArrayToScalar(dstArr, dstStrides, dstShape, dstSelection, value) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  const normalizedSelection = normalizeArraySelection(dstSelection, dstShape, true);\n  const [sliceIndices] = selectionToSliceIndices(normalizedSelection, dstShape); // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n\n  _setRawArrayToScalar(value, dstArr, dstStrides, sliceIndices);\n}\n\nfunction setRawArray(dstArr, dstStrides, dstShape, dstSelection, sourceArr, sourceStrides, sourceShape) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, false);\n  const [dstSliceIndices, outShape] = selectionToSliceIndices(normalizedDstSelection, dstShape); // TODO: replace with non stringify equality check\n\n  if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n    throw new ValueError(`Shape mismatch in target and source RawArray: ${outShape} and ${sourceShape}`);\n  }\n\n  _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides);\n}\n\nfunction setRawArrayFromChunkItem(dstArr, dstStrides, dstShape, dstSelection, sourceArr, sourceStrides, sourceShape, sourceSelection) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, true); // Above we force the results to be dstSliceIndices only, without integer selections making this cast is safe.\n\n  const [dstSliceIndices] = selectionToSliceIndices(normalizedDstSelection, dstShape);\n  const normalizedSourceSelection = normalizeArraySelection(sourceSelection, sourceShape, false);\n  const [sourceSliceIndicies] = selectionToSliceIndices(normalizedSourceSelection, sourceShape); // TODO check to ensure chunk and dest selection are same shape?\n  // As is, this only gets called in ZarrArray.getRaw where this condition should be ensured, and check might hinder performance.\n\n  _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides, sourceSliceIndicies);\n}\n\nfunction _setRawArrayToScalar(value, dstArr, dstStrides, dstSliceIndices) {\n  const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n  const [currentDstStride, ...nextDstStrides] = dstStrides;\n  const [from, _to, step, outputSize] = currentDstSlice;\n\n  if (dstStrides.length === 1) {\n    if (step === 1 && currentDstStride === 1) {\n      dstArr.fill(value, from, from + outputSize);\n    } else {\n      for (let i = 0; i < outputSize; i++) {\n        dstArr[currentDstStride * (from + step * i)] = value;\n      }\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < outputSize; i++) {\n    _setRawArrayToScalar(value, dstArr.subarray(currentDstStride * (from + step * i)), nextDstStrides, nextDstSliceIndices);\n  }\n}\n\nfunction _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides) {\n  if (dstSliceIndices.length === 0) {\n    dstArr.set(sourceArr);\n    return;\n  }\n\n  const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n  const [currentDstStride, ...nextDstStrides] = dstStrides; // This dimension is squeezed.\n\n  if (typeof currentDstSlice === \"number\") {\n    _setRawArray(dstArr.subarray(currentDstSlice * currentDstStride), nextDstStrides, nextDstSliceIndices, sourceArr, sourceStrides);\n\n    return;\n  }\n\n  const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\n  const [from, _to, step, outputSize] = currentDstSlice;\n\n  if (dstStrides.length === 1) {\n    if (step === 1 && currentDstStride === 1 && currentSourceStride === 1) {\n      dstArr.set(sourceArr.subarray(0, outputSize), from);\n    } else {\n      for (let i = 0; i < outputSize; i++) {\n        dstArr[currentDstStride * (from + step * i)] = sourceArr[currentSourceStride * i];\n      }\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < outputSize; i++) {\n    // Apply strides as above, using both destination and source-specific strides.\n    _setRawArray(dstArr.subarray(currentDstStride * (from + i * step)), nextDstStrides, nextDstSliceIndices, sourceArr.subarray(currentSourceStride * i), nextSourceStrides);\n  }\n}\n\nfunction _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides, sourceSliceIndices) {\n  if (sourceSliceIndices.length === 0) {\n    // Case when last source dimension is squeezed\n    dstArr.set(sourceArr.subarray(0, dstArr.length));\n    return;\n  } // Get current indicies and strides for both destination and source arrays\n\n\n  const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n  const [currentSourceSlice, ...nextSourceSliceIndices] = sourceSliceIndices;\n  const [currentDstStride, ...nextDstStrides] = dstStrides;\n  const [currentSourceStride, ...nextSourceStrides] = sourceStrides; // This source dimension is squeezed\n\n  if (typeof currentSourceSlice === \"number\") {\n    /*\r\n    Sets dimension offset for squeezed dimension.\r\n     Ex. if 0th dimension is squeezed to 2nd index (numpy : arr[2,i])\r\n         sourceArr[stride[0]* 2 + i] --> sourceArr.subarray(stride[0] * 2)[i] (sourceArr[i] in next call)\r\n     Thus, subsequent squeezed dims are appended to the source offset.\r\n    */\n    _setRawArrayFromChunkItem( // Don't update destination offset/slices, just source\n    dstArr, dstStrides, dstSliceIndices, sourceArr.subarray(currentSourceStride * currentSourceSlice), nextSourceStrides, nextSourceSliceIndices);\n\n    return;\n  }\n\n  const [from, _to, step, outputSize] = currentDstSlice; // just need start and size\n\n  const [sfrom, _sto, sstep, _soutputSize] = currentSourceSlice; // Will always be subset of dst, so don't need output size just start\n\n  if (dstStrides.length === 1 && sourceStrides.length === 1) {\n    if (step === 1 && currentDstStride === 1 && sstep === 1 && currentSourceStride === 1) {\n      dstArr.set(sourceArr.subarray(sfrom, sfrom + outputSize), from);\n    } else {\n      for (let i = 0; i < outputSize; i++) {\n        dstArr[currentDstStride * (from + step * i)] = sourceArr[currentSourceStride * (sfrom + sstep * i)];\n      }\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < outputSize; i++) {\n    // Apply strides as above, using both destination and source-specific strides.\n    _setRawArrayFromChunkItem(dstArr.subarray(currentDstStride * (from + i * step)), nextDstStrides, nextDstSliceIndices, sourceArr.subarray(currentSourceStride * (sfrom + i * sstep)), nextSourceStrides, nextSourceSliceIndices);\n  }\n}\n\nclass RawArray {\n  constructor(data, shape, dtype, strides) {\n    const dataIsTypedArray = data !== null && !!data.BYTES_PER_ELEMENT;\n\n    if (shape === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n      }\n\n      shape = [data.length];\n    }\n\n    shape = normalizeShape(shape);\n\n    if (dtype === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n      }\n\n      dtype = getTypedArrayDtypeString(data);\n    }\n\n    if (strides === undefined) {\n      strides = getStrides(shape);\n    }\n\n    this.shape = shape;\n    this.dtype = dtype;\n    this.strides = strides;\n\n    if (dataIsTypedArray && shape.length !== 1) {\n      data = data.buffer;\n    } // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n\n\n    if (this.shape.length === 0) {\n      this.data = new DTYPE_TYPEDARRAY_MAPPING[dtype](1);\n    } else if ( // tslint:disable-next-line: strict-type-predicates\n    IS_NODE && Buffer.isBuffer(data) || data instanceof ArrayBuffer || data === null || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n    ) {\n      // Create from ArrayBuffer or Buffer\n      const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n      if (data === null) {\n        data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n      }\n\n      const numDataElements = data.byteLength / parseInt(dtype[dtype.length - 1], 10);\n\n      if (numShapeElements !== numDataElements) {\n        throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n      }\n\n      const typeConstructor = DTYPE_TYPEDARRAY_MAPPING[dtype];\n      this.data = new typeConstructor(data);\n    } else {\n      this.data = data;\n    }\n  }\n\n  set(selection = null, value, chunkSelection) {\n    if (selection === null) {\n      selection = [slice(null)];\n    }\n\n    if (typeof value === \"number\") {\n      if (this.shape.length === 0) {\n        // Zero dimension array..\n        this.data[0] = value;\n      } else {\n        setRawArrayToScalar(this.data, this.strides, this.shape, selection, value);\n      }\n    } else if (value instanceof RawArray && chunkSelection) {\n      // Copy directly from decoded chunk to destination array\n      setRawArrayFromChunkItem(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape, chunkSelection);\n    } else {\n      setRawArray(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape);\n    }\n  }\n\n}\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar eventemitter3 = createCommonjsModule(function (module) {\n  var has = Object.prototype.hasOwnProperty,\n      prefix = '~';\n  /**\n   * Constructor to create a storage for our `EE` objects.\n   * An `Events` instance is a plain object whose properties are event names.\n   *\n   * @constructor\n   * @private\n   */\n\n  function Events() {} //\n  // We try to not inherit from `Object.prototype`. In some engines creating an\n  // instance in this way is faster than calling `Object.create(null)` directly.\n  // If `Object.create(null)` is not supported we prefix the event names with a\n  // character to make sure that the built-in object properties are not\n  // overridden or used as an attack vector.\n  //\n\n\n  if (Object.create) {\n    Events.prototype = Object.create(null); //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n\n    if (!new Events().__proto__) prefix = false;\n  }\n  /**\n   * Representation of a single event listener.\n   *\n   * @param {Function} fn The listener function.\n   * @param {*} context The context to invoke the listener with.\n   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n   * @constructor\n   * @private\n   */\n\n\n  function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n  }\n  /**\n   * Add a listener for a given event.\n   *\n   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} context The context to invoke the listener with.\n   * @param {Boolean} once Specify if the listener is a one-time listener.\n   * @returns {EventEmitter}\n   * @private\n   */\n\n\n  function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The listener must be a function');\n    }\n\n    var listener = new EE(fn, context || emitter, once),\n        evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];\n    return emitter;\n  }\n  /**\n   * Clear event by name.\n   *\n   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n   * @param {(String|Symbol)} evt The Event name.\n   * @private\n   */\n\n\n  function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];\n  }\n  /**\n   * Minimal `EventEmitter` interface that is molded against the Node.js\n   * `EventEmitter` interface.\n   *\n   * @constructor\n   * @public\n   */\n\n\n  function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   *\n   * @returns {Array}\n   * @public\n   */\n\n\n  EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [],\n        events,\n        name;\n    if (this._eventsCount === 0) return names;\n\n    for (name in events = this._events) {\n      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n\n    return names;\n  };\n  /**\n   * Return the listeners registered for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Array} The registered listeners.\n   * @public\n   */\n\n\n  EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event,\n        handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [handlers.fn];\n\n    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n      ee[i] = handlers[i].fn;\n    }\n\n    return ee;\n  };\n  /**\n   * Return the number of listeners listening to a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Number} The number of listeners.\n   * @public\n   */\n\n\n  EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event,\n        listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n  };\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Boolean} `true` if the event had listeners, else `false`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt],\n        len = arguments.length,\n        args,\n        i;\n\n    if (listeners.fn) {\n      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n      switch (len) {\n        case 1:\n          return listeners.fn.call(listeners.context), true;\n\n        case 2:\n          return listeners.fn.call(listeners.context, a1), true;\n\n        case 3:\n          return listeners.fn.call(listeners.context, a1, a2), true;\n\n        case 4:\n          return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\n        case 5:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\n        case 6:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n      }\n\n      for (i = 1, args = new Array(len - 1); i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      listeners.fn.apply(listeners.context, args);\n    } else {\n      var length = listeners.length,\n          j;\n\n      for (i = 0; i < length; i++) {\n        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n        switch (len) {\n          case 1:\n            listeners[i].fn.call(listeners[i].context);\n            break;\n\n          case 2:\n            listeners[i].fn.call(listeners[i].context, a1);\n            break;\n\n          case 3:\n            listeners[i].fn.call(listeners[i].context, a1, a2);\n            break;\n\n          case 4:\n            listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n            break;\n\n          default:\n            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n              args[j - 1] = arguments[j];\n            }\n            listeners[i].fn.apply(listeners[i].context, args);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Add a listener for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n  };\n  /**\n   * Add a one-time listener for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n  };\n  /**\n   * Remove the listeners of a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn Only remove the listeners that match this function.\n   * @param {*} context Only remove the listeners that have this context.\n   * @param {Boolean} once Only remove one-time listeners.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return this;\n\n    if (!fn) {\n      clearEvent(this, evt);\n      return this;\n    }\n\n    var listeners = this._events[evt];\n\n    if (listeners.fn) {\n      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n        clearEvent(this, evt);\n      }\n    } else {\n      for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n          events.push(listeners[i]);\n        }\n      } //\n      // Reset the array, or remove it completely if we have no more listeners.\n      //\n\n\n      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);\n    }\n\n    return this;\n  };\n  /**\n   * Remove all listeners, or those of the specified event.\n   *\n   * @param {(String|Symbol)} [event] The event name.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n\n    if (event) {\n      evt = prefix ? prefix + event : event;\n      if (this._events[evt]) clearEvent(this, evt);\n    } else {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n\n    return this;\n  }; //\n  // Alias methods names because people roll like that.\n  //\n\n\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on; //\n  // Expose the prefix.\n  //\n\n  EventEmitter.prefixed = prefix; //\n  // Allow `EventEmitter` to be imported as module namespace.\n  //\n\n  EventEmitter.EventEmitter = EventEmitter; //\n  // Expose the module.\n  //\n\n  {\n    module.exports = EventEmitter;\n  }\n});\n\nvar pFinally = (promise, onFinally) => {\n  onFinally = onFinally || (() => {});\n\n  return promise.then(val => new Promise(resolve => {\n    resolve(onFinally());\n  }).then(() => val), err => new Promise(resolve => {\n    resolve(onFinally());\n  }).then(() => {\n    throw err;\n  }));\n};\n\nclass TimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n\n}\n\nconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n  if (typeof milliseconds !== 'number' || milliseconds < 0) {\n    throw new TypeError('Expected `milliseconds` to be a positive number');\n  }\n\n  if (milliseconds === Infinity) {\n    resolve(promise);\n    return;\n  }\n\n  const timer = setTimeout(() => {\n    if (typeof fallback === 'function') {\n      try {\n        resolve(fallback());\n      } catch (error) {\n        reject(error);\n      }\n\n      return;\n    }\n\n    const message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n    const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n    if (typeof promise.cancel === 'function') {\n      promise.cancel();\n    }\n\n    reject(timeoutError);\n  }, milliseconds); // TODO: Use native `finally` keyword when targeting Node.js 10\n\n  pFinally( // eslint-disable-next-line promise/prefer-await-to-then\n  promise.then(resolve, reject), () => {\n    clearTimeout(timer);\n  });\n});\n\nvar pTimeout_1 = pTimeout; // TODO: Remove this for the next major release\n\nvar default_1 = pTimeout;\nvar TimeoutError_1 = TimeoutError;\npTimeout_1.default = default_1;\npTimeout_1.TimeoutError = TimeoutError_1;\nvar lowerBound_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  }); // Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound\n  // Used to compute insertion index to keep queue sorted after insertion\n\n  function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n\n    while (count > 0) {\n      const step = count / 2 | 0;\n      let it = first + step;\n\n      if (comparator(array[it], value) <= 0) {\n        first = ++it;\n        count -= step + 1;\n      } else {\n        count = step;\n      }\n    }\n\n    return first;\n  }\n\n  exports.default = lowerBound;\n});\nunwrapExports(lowerBound_1);\nvar priorityQueue = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  class PriorityQueue {\n    constructor() {\n      this._queue = [];\n    }\n\n    enqueue(run, options) {\n      options = Object.assign({\n        priority: 0\n      }, options);\n      const element = {\n        priority: options.priority,\n        run\n      };\n\n      if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n        this._queue.push(element);\n\n        return;\n      }\n\n      const index = lowerBound_1.default(this._queue, element, (a, b) => b.priority - a.priority);\n\n      this._queue.splice(index, 0, element);\n    }\n\n    dequeue() {\n      const item = this._queue.shift();\n\n      return item && item.run;\n    }\n\n    get size() {\n      return this._queue.length;\n    }\n\n  }\n\n  exports.default = PriorityQueue;\n});\nunwrapExports(priorityQueue);\nvar dist = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  const empty = () => {};\n\n  const timeoutError = new pTimeout_1.default.TimeoutError();\n  /**\n  Promise queue with concurrency control.\n  */\n\n  class PQueue extends eventemitter3 {\n    constructor(options) {\n      super();\n      this._intervalCount = 0;\n      this._intervalEnd = 0;\n      this._pendingCount = 0;\n      this._resolveEmpty = empty;\n      this._resolveIdle = empty; // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n\n      options = Object.assign({\n        carryoverConcurrencyCount: false,\n        intervalCap: Infinity,\n        interval: 0,\n        concurrency: Infinity,\n        autoStart: true,\n        queueClass: priorityQueue.default\n      }, options // TODO: Remove this `as`.\n      );\n\n      if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n        throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap}\\` (${typeof options.intervalCap})`);\n      }\n\n      if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n        throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval}\\` (${typeof options.interval})`);\n      }\n\n      this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n      this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n      this._intervalCap = options.intervalCap;\n      this._interval = options.interval;\n      this._queue = new options.queueClass();\n      this._queueClass = options.queueClass;\n      this.concurrency = options.concurrency;\n      this._timeout = options.timeout;\n      this._throwOnTimeout = options.throwOnTimeout === true;\n      this._isPaused = options.autoStart === false;\n    }\n\n    get _doesIntervalAllowAnother() {\n      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n\n    get _doesConcurrentAllowAnother() {\n      return this._pendingCount < this._concurrency;\n    }\n\n    _next() {\n      this._pendingCount--;\n\n      this._tryToStartAnother();\n    }\n\n    _resolvePromises() {\n      this._resolveEmpty();\n\n      this._resolveEmpty = empty;\n\n      if (this._pendingCount === 0) {\n        this._resolveIdle();\n\n        this._resolveIdle = empty;\n      }\n    }\n\n    _onResumeInterval() {\n      this._onInterval();\n\n      this._initializeIntervalIfNeeded();\n\n      this._timeoutId = undefined;\n    }\n\n    _isIntervalPaused() {\n      const now = Date.now();\n\n      if (this._intervalId === undefined) {\n        const delay = this._intervalEnd - now;\n\n        if (delay < 0) {\n          // Act as the interval was done\n          // We don't need to resume it here because it will be resumed on line 160\n          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        } else {\n          // Act as the interval is pending\n          if (this._timeoutId === undefined) {\n            this._timeoutId = setTimeout(() => {\n              this._onResumeInterval();\n            }, delay);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    _tryToStartAnother() {\n      if (this._queue.size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (this._intervalId) {\n          clearInterval(this._intervalId);\n        }\n\n        this._intervalId = undefined;\n\n        this._resolvePromises();\n\n        return false;\n      }\n\n      if (!this._isPaused) {\n        const canInitializeInterval = !this._isIntervalPaused();\n\n        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n          this.emit('active');\n\n          this._queue.dequeue()();\n\n          if (canInitializeInterval) {\n            this._initializeIntervalIfNeeded();\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    _initializeIntervalIfNeeded() {\n      if (this._isIntervalIgnored || this._intervalId !== undefined) {\n        return;\n      }\n\n      this._intervalId = setInterval(() => {\n        this._onInterval();\n      }, this._interval);\n      this._intervalEnd = Date.now() + this._interval;\n    }\n\n    _onInterval() {\n      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n        clearInterval(this._intervalId);\n        this._intervalId = undefined;\n      }\n\n      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n      this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n\n\n    _processQueue() {\n      // eslint-disable-next-line no-empty\n      while (this._tryToStartAnother()) {}\n    }\n\n    get concurrency() {\n      return this._concurrency;\n    }\n\n    set concurrency(newConcurrency) {\n      if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n        throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n      }\n\n      this._concurrency = newConcurrency;\n\n      this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n\n\n    async add(fn, options = {}) {\n      return new Promise((resolve, reject) => {\n        const run = async () => {\n          this._pendingCount++;\n          this._intervalCount++;\n\n          try {\n            const operation = this._timeout === undefined && options.timeout === undefined ? fn() : pTimeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, () => {\n              if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                reject(timeoutError);\n              }\n\n              return undefined;\n            });\n            resolve((await operation));\n          } catch (error) {\n            reject(error);\n          }\n\n          this._next();\n        };\n\n        this._queue.enqueue(run, options);\n\n        this._tryToStartAnother();\n      });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n     @returns A promise that resolves when all functions are resolved.\n    */\n\n\n    async addAll(functions, options) {\n      return Promise.all(functions.map(async function_ => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n\n\n    start() {\n      if (!this._isPaused) {\n        return this;\n      }\n\n      this._isPaused = false;\n\n      this._processQueue();\n\n      return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n\n\n    pause() {\n      this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n\n\n    clear() {\n      this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n     @returns A promise that settles when the queue becomes empty.\n    */\n\n\n    async onEmpty() {\n      // Instantly resolve if the queue is empty\n      if (this._queue.size === 0) {\n        return;\n      }\n\n      return new Promise(resolve => {\n        const existingResolve = this._resolveEmpty;\n\n        this._resolveEmpty = () => {\n          existingResolve();\n          resolve();\n        };\n      });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n     @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n\n\n    async onIdle() {\n      // Instantly resolve if none pending and if nothing else is queued\n      if (this._pendingCount === 0 && this._queue.size === 0) {\n        return;\n      }\n\n      return new Promise(resolve => {\n        const existingResolve = this._resolveIdle;\n\n        this._resolveIdle = () => {\n          existingResolve();\n          resolve();\n        };\n      });\n    }\n    /**\n    Size of the queue.\n    */\n\n\n    get size() {\n      return this._queue.size;\n    }\n    /**\n    Number of pending promises.\n    */\n\n\n    get pending() {\n      return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n\n\n    get isPaused() {\n      return this._isPaused;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n\n\n    set timeout(milliseconds) {\n      this._timeout = milliseconds;\n    }\n\n    get timeout() {\n      return this._timeout;\n    }\n\n  }\n\n  exports.default = PQueue;\n});\nvar PQueue = unwrapExports(dist);\n\nclass ZarrArray {\n  /**\r\n   * Instantiate an array from an initialized store.\r\n   * @param store Array store, already initialized.\r\n   * @param path Storage path.\r\n   * @param metadata The initial value for the metadata\r\n   * @param readOnly True if array should be protected against modification.\r\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\r\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\r\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\r\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\r\n   */\n  constructor(store, path = null, metadata, readOnly = false, chunkStore = null, cacheMetadata = true, cacheAttrs = true) {\n    // N.B., expect at this point store is fully initialized with all\n    // configuration metadata fully specified and normalized\n    this.store = store;\n    this._chunkStore = chunkStore;\n    this.path = normalizeStoragePath(path);\n    this.keyPrefix = pathToPrefix(this.path);\n    this.readOnly = readOnly;\n    this.cacheMetadata = cacheMetadata;\n    this.cacheAttrs = cacheAttrs;\n    this.meta = metadata;\n\n    if (this.meta.compressor !== null) {\n      this.compressor = getCodec(this.meta.compressor);\n    } else {\n      this.compressor = null;\n    }\n\n    const attrKey = this.keyPrefix + ATTRS_META_KEY;\n    this.attrs = new Attributes(this.store, attrKey, this.readOnly, cacheAttrs);\n  }\n  /**\r\n   * A `Store` providing the underlying storage for array chunks.\r\n   */\n\n\n  get chunkStore() {\n    if (this._chunkStore) {\n      return this._chunkStore;\n    }\n\n    return this.store;\n  }\n  /**\r\n   * Array name following h5py convention.\r\n   */\n\n\n  get name() {\n    if (this.path.length > 0) {\n      if (this.path[0] !== \"/\") {\n        return \"/\" + this.path;\n      }\n\n      return this.path;\n    }\n\n    return null;\n  }\n  /**\r\n   * Final component of name.\r\n   */\n\n\n  get basename() {\n    const name = this.name;\n\n    if (name === null) {\n      return null;\n    }\n\n    const parts = name.split(\"/\");\n    return parts[parts.length - 1];\n  }\n  /**\r\n   * \"A list of integers describing the length of each dimension of the array.\r\n   */\n\n\n  get shape() {\n    // this.refreshMetadata();\n    return this.meta.shape;\n  }\n  /**\r\n   * A list of integers describing the length of each dimension of a chunk of the array.\r\n   */\n\n\n  get chunks() {\n    return this.meta.chunks;\n  }\n  /**\r\n   * Integer describing how many element a chunk contains\r\n   */\n\n\n  get chunkSize() {\n    return this.chunks.reduce((x, y) => x * y, 1);\n  }\n  /**\r\n   *  The NumPy data type.\r\n   */\n\n\n  get dtype() {\n    return this.meta.dtype;\n  }\n  /**\r\n   *  A value used for uninitialized portions of the array.\r\n   */\n\n\n  get fillValue() {\n    const fillTypeValue = this.meta.fill_value; // TODO extract into function\n\n    if (fillTypeValue === \"NaN\") {\n      return NaN;\n    } else if (fillTypeValue === \"Infinity\") {\n      return Infinity;\n    } else if (fillTypeValue === \"-Infinity\") {\n      return -Infinity;\n    }\n\n    return this.meta.fill_value;\n  }\n  /**\r\n   *  Number of dimensions.\r\n   */\n\n\n  get nDims() {\n    return this.meta.shape.length;\n  }\n  /**\r\n   *  The total number of elements in the array.\r\n   */\n\n\n  get size() {\n    // this.refreshMetadata()\n    return this.meta.shape.reduce((x, y) => x * y, 1);\n  }\n\n  get length() {\n    return this.shape[0];\n  }\n\n  get _chunkDataShape() {\n    if (this.shape === []) {\n      return [1];\n    } else {\n      const s = [];\n\n      for (let i = 0; i < this.shape.length; i++) {\n        s[i] = Math.ceil(this.shape[i] / this.chunks[i]);\n      }\n\n      return s;\n    }\n  }\n  /**\r\n   * A tuple of integers describing the number of chunks along each\r\n   * dimension of the array.\r\n   */\n\n\n  get chunkDataShape() {\n    // this.refreshMetadata();\n    return this._chunkDataShape;\n  }\n  /**\r\n   * Total number of chunks.\r\n   */\n\n\n  get numChunks() {\n    // this.refreshMetadata();\n    return this.chunkDataShape.reduce((x, y) => x * y, 1);\n  }\n  /**\r\n   * Instantiate an array from an initialized store.\r\n   * @param store Array store, already initialized.\r\n   * @param path Storage path.\r\n   * @param readOnly True if array should be protected against modification.\r\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\r\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\r\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\r\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\r\n   */\n\n\n  static async create(store, path = null, readOnly = false, chunkStore = null, cacheMetadata = true, cacheAttrs = true) {\n    const metadata = await this.loadMetadataForConstructor(store, path);\n    return new ZarrArray(store, path, metadata, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n  }\n\n  static async loadMetadataForConstructor(store, path) {\n    try {\n      path = normalizeStoragePath(path);\n      const keyPrefix = pathToPrefix(path);\n      const metaStoreValue = await store.getItem(keyPrefix + ARRAY_META_KEY);\n      return parseMetadata(metaStoreValue);\n    } catch (error) {\n      if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path !== null && path !== void 0 ? path : '');\n      }\n\n      throw new Error(\"Failed to load metadata for ZarrArray:\" + error.toString());\n    }\n  }\n  /**\r\n   * (Re)load metadata from store\r\n   */\n\n\n  async reloadMetadata() {\n    const metaKey = this.keyPrefix + ARRAY_META_KEY;\n    const metaStoreValue = this.store.getItem(metaKey);\n    this.meta = parseMetadata((await metaStoreValue));\n    return this.meta;\n  }\n\n  async refreshMetadata() {\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n  }\n\n  get(selection = null, opts = {}) {\n    return this.getBasicSelection(selection, false, opts);\n  }\n\n  getRaw(selection = null, opts = {}) {\n    return this.getBasicSelection(selection, true, opts);\n  }\n\n  async getBasicSelection(selection, asRaw = false, {\n    concurrencyLimit = 10,\n    progressCallback\n  } = {}) {\n    // Refresh metadata\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    } // Check fields (TODO?)\n\n\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      return this.getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback);\n    }\n  }\n\n  getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback) {\n    const indexer = new BasicIndexer(selection, this);\n    return this.getSelection(indexer, asRaw, concurrencyLimit, progressCallback);\n  }\n\n  async getSelection(indexer, asRaw, concurrencyLimit, progressCallback) {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be extracted. Each chunk is processed in turn, extracting the\n    // necessary data and storing into the correct location in the output array.\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n    // check fields are sensible (TODO?)\n    const outDtype = this.dtype;\n    const outShape = indexer.shape;\n    const outSize = indexer.shape.reduce((x, y) => x * y, 1);\n\n    if (asRaw && outSize === this.chunkSize) {\n      // Optimization: if output strided array _is_ chunk exactly,\n      // decode directly as new TypedArray and return\n      const itr = indexer.iter();\n      const proj = itr.next(); // ensure there is only one projection\n\n      if (proj.done === false && itr.next().done === true) {\n        const chunkProjection = proj.value;\n        const out = await this.decodeDirectToRawArray(chunkProjection, outShape, outSize);\n        return out;\n      }\n    }\n\n    const out = asRaw ? new RawArray(null, outShape, outDtype) : new NestedArray(null, outShape, outDtype);\n\n    if (outSize === 0) {\n      return out;\n    } // create promise queue with concurrency control\n\n\n    const queue = new PQueue({\n      concurrency: concurrencyLimit\n    });\n\n    if (progressCallback) {\n      let progress = 0;\n      let queueSize = 0;\n\n      for (const _ of indexer.iter()) queueSize += 1;\n\n      progressCallback({\n        progress: 0,\n        queueSize: queueSize\n      });\n\n      for (const proj of indexer.iter()) {\n        (async () => {\n          await queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n          progress += 1;\n          progressCallback({\n            progress: progress,\n            queueSize: queueSize\n          });\n        })();\n      }\n    } else {\n      for (const proj of indexer.iter()) {\n        queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n      }\n    } // guarantees that all work on queue has finished\n\n\n    await queue.onIdle(); // Return scalar instead of zero-dimensional array.\n\n    if (out.shape.length === 0) {\n      return out.data[0];\n    }\n\n    return out;\n  }\n  /**\r\n   * Obtain part or whole of a chunk.\r\n   * @param chunkCoords Indices of the chunk.\r\n   * @param chunkSelection Location of region within the chunk to extract.\r\n   * @param out Array to store result in.\r\n   * @param outSelection Location of region within output array to store results in.\r\n   * @param dropAxes Axes to squeeze out of the chunk.\r\n   */\n\n\n  async chunkGetItem(chunkCoords, chunkSelection, out, outSelection, dropAxes) {\n    if (chunkCoords.length !== this._chunkDataShape.length) {\n      throw new ValueError(`Inconsistent shapes: chunkCoordsLength: ${chunkCoords.length}, cDataShapeLength: ${this.chunkDataShape.length}`);\n    }\n\n    const cKey = this.chunkKey(chunkCoords);\n\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      const decodedChunk = await this.decodeChunk(cdata);\n\n      if (out instanceof NestedArray) {\n        if (isContiguousSelection(outSelection) && isTotalSlice(chunkSelection, this.chunks) && !this.meta.filters) {\n          // Optimization: we want the whole chunk, and the destination is\n          // contiguous, so we can decompress directly from the chunk\n          // into the destination array\n          // TODO check order\n          // TODO filters..\n          out.set(outSelection, this.toNestedArray(decodedChunk));\n          return;\n        } // Decode chunk\n\n\n        const chunk = this.toNestedArray(decodedChunk);\n        const tmp = chunk.get(chunkSelection);\n\n        if (dropAxes !== null) {\n          throw new Error(\"Drop axes is not supported yet\");\n        }\n\n        out.set(outSelection, tmp);\n      } else {\n        /* RawArray\r\n        Copies chunk by index directly into output. Doesn't matter if selection is contiguous\r\n        since store/output are different shapes/strides.\r\n        */\n        out.set(outSelection, this.chunkBufferToRawArray(decodedChunk), chunkSelection);\n      }\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if cKey doesn't exist in store\n        if (this.fillValue !== null) {\n          out.set(outSelection, this.fillValue);\n        }\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  async getRawChunk(chunkCoords, opts) {\n    if (chunkCoords.length !== this.shape.length) {\n      throw new Error(`Chunk coordinates ${chunkCoords.join(\".\")} do not correspond to shape ${this.shape}.`);\n    }\n\n    try {\n      for (let i = 0; i < chunkCoords.length; i++) {\n        const dimLength = Math.ceil(this.shape[i] / this.chunks[i]);\n        chunkCoords[i] = normalizeIntegerSelection(chunkCoords[i], dimLength);\n      }\n    } catch (error) {\n      if (error instanceof BoundsCheckError) {\n        throw new BoundsCheckError(`index ${chunkCoords.join(\".\")} is out of bounds for shape: ${this.shape} and chunks ${this.chunks}`);\n      } else {\n        throw error;\n      }\n    }\n\n    const cKey = this.chunkKey(chunkCoords);\n    const cdata = this.chunkStore.getItem(cKey, opts === null || opts === void 0 ? void 0 : opts.storeOptions);\n    const buffer = await this.decodeChunk((await cdata));\n    const outShape = this.chunks.filter(d => d !== 1); // squeeze chunk dim if 1\n\n    return new RawArray(buffer, outShape, this.dtype);\n  }\n\n  chunkKey(chunkCoords) {\n    return this.keyPrefix + chunkCoords.join(\".\");\n  }\n\n  ensureByteArray(chunkData) {\n    if (typeof chunkData === \"string\") {\n      return new Uint8Array(Buffer.from(chunkData).buffer);\n    }\n\n    return new Uint8Array(chunkData);\n  }\n\n  toTypedArray(buffer) {\n    return new DTYPE_TYPEDARRAY_MAPPING[this.dtype](buffer);\n  }\n\n  toNestedArray(data) {\n    const buffer = this.ensureByteArray(data).buffer;\n    return new NestedArray(buffer, this.chunks, this.dtype);\n  }\n\n  async decodeChunk(chunkData) {\n    let bytes = this.ensureByteArray(chunkData);\n\n    if (this.compressor !== null) {\n      bytes = await (await this.compressor).decode(bytes);\n    }\n\n    if (this.dtype.includes('>')) {\n      // Need to flip bytes for Javascript TypedArrays\n      // We flip bytes in-place to avoid creating an extra copy of the decoded buffer.\n      byteSwapInplace(this.toTypedArray(bytes.buffer));\n    } // TODO filtering etc\n\n\n    return bytes.buffer;\n  }\n\n  chunkBufferToRawArray(buffer) {\n    return new RawArray(buffer, this.chunks, this.dtype);\n  }\n\n  async decodeDirectToRawArray({\n    chunkCoords\n  }, outShape, outSize) {\n    const cKey = this.chunkKey(chunkCoords);\n\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      return new RawArray((await this.decodeChunk(cdata)), outShape, this.dtype);\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if item doesn't exist\n        const data = new DTYPE_TYPEDARRAY_MAPPING[this.dtype](outSize);\n        return new RawArray(data.fill(this.fillValue), outShape);\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  async set(selection = null, value, opts = {}) {\n    await this.setBasicSelection(selection, value, opts);\n  }\n\n  async setBasicSelection(selection, value, {\n    concurrencyLimit = 10,\n    progressCallback\n  } = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"Object is read only\");\n    }\n\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      await this.setBasicSelectionND(selection, value, concurrencyLimit, progressCallback);\n    }\n  }\n\n  async setBasicSelectionND(selection, value, concurrencyLimit, progressCallback) {\n    const indexer = new BasicIndexer(selection, this);\n    await this.setSelection(indexer, value, concurrencyLimit, progressCallback);\n  }\n\n  getChunkValue(proj, indexer, value, selectionShape) {\n    let chunkValue;\n\n    if (selectionShape === []) {\n      chunkValue = value;\n    } else if (typeof value === \"number\") {\n      chunkValue = value;\n    } else {\n      chunkValue = value.get(proj.outSelection); // tslint:disable-next-line: strict-type-predicates\n\n      if (indexer.dropAxes !== null) {\n        throw new Error(\"Handling drop axes not supported yet\");\n      }\n    }\n\n    return chunkValue;\n  }\n\n  async setSelection(indexer, value, concurrencyLimit, progressCallback) {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be replaced. Each chunk is processed in turn, extracting the\n    // necessary data from the value array and storing into the chunk array.\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n    // TODO? check fields are sensible\n    // Determine indices of chunks overlapping the selection\n    const selectionShape = indexer.shape; // Check value shape\n\n    if (selectionShape === []) ;else if (typeof value === \"number\") ;else if (value instanceof NestedArray) {\n      // TODO: non stringify equality check\n      if (!arrayEquals1D(value.shape, selectionShape)) {\n        throw new ValueError(`Shape mismatch in source NestedArray and set selection: ${value.shape} and ${selectionShape}`);\n      }\n    } else {\n      // TODO support TypedArrays, buffers, etc\n      throw new Error(\"Unknown data type for setting :(\");\n    }\n    const queue = new PQueue({\n      concurrency: concurrencyLimit\n    });\n\n    if (progressCallback) {\n      let queueSize = 0;\n\n      for (const _ of indexer.iter()) queueSize += 1;\n\n      let progress = 0;\n      progressCallback({\n        progress: 0,\n        queueSize: queueSize\n      });\n\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n\n        (async () => {\n          await queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n          progress += 1;\n          progressCallback({\n            progress: progress,\n            queueSize: queueSize\n          });\n        })();\n      }\n    } else {\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n        queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n      }\n    } // guarantees that all work on queue has finished\n\n\n    await queue.onIdle();\n  }\n\n  async chunkSetItem(chunkCoords, chunkSelection, value) {\n    // Obtain key for chunk storage\n    const chunkKey = this.chunkKey(chunkCoords);\n    let chunk = null;\n    const dtypeConstr = DTYPE_TYPEDARRAY_MAPPING[this.dtype];\n    const chunkSize = this.chunkSize;\n\n    if (isTotalSlice(chunkSelection, this.chunks)) {\n      // Totally replace chunk\n      // Optimization: we are completely replacing the chunk, so no need\n      // to access the existing chunk data\n      if (typeof value === \"number\") {\n        // TODO get the right type here\n        chunk = new dtypeConstr(chunkSize);\n        chunk.fill(value);\n      } else {\n        chunk = value.flatten();\n      }\n    } else {\n      // partially replace the contents of this chunk\n      // Existing chunk data\n      let chunkData;\n\n      try {\n        // Chunk is initialized if this does not error\n        const chunkStoreData = await this.chunkStore.getItem(chunkKey);\n        const dBytes = await this.decodeChunk(chunkStoreData);\n        chunkData = this.toTypedArray(dBytes);\n      } catch (error) {\n        if (isKeyError(error)) {\n          // Chunk is not initialized\n          chunkData = new dtypeConstr(chunkSize);\n\n          if (this.fillValue !== null) {\n            chunkData.fill(this.fillValue);\n          }\n        } else {\n          // Different type of error - rethrow\n          throw error;\n        }\n      }\n\n      const chunkNestedArray = new NestedArray(chunkData, this.chunks, this.dtype);\n      chunkNestedArray.set(chunkSelection, value);\n      chunk = chunkNestedArray.flatten();\n    }\n\n    const chunkData = await this.encodeChunk(chunk);\n    this.chunkStore.setItem(chunkKey, chunkData);\n  }\n\n  async encodeChunk(chunk) {\n    if (this.dtype.includes('>')) {\n      /*\r\n       * If big endian, flip bytes before applying compression and setting store.\r\n       *\r\n       * Here we create a copy (not in-place byteswapping) to avoid flipping the\r\n       * bytes in the buffers of user-created Raw- and NestedArrays.\r\n      */\n      chunk = byteSwap(chunk);\n    }\n\n    if (this.compressor !== null) {\n      const bytes = new Uint8Array(chunk.buffer);\n      const cbytes = await (await this.compressor).encode(bytes);\n      return cbytes.buffer;\n    } // TODO: filters, etc\n\n\n    return chunk.buffer;\n  }\n\n}\n\nclass MemoryStore {\n  constructor(root = {}) {\n    this.root = root;\n  }\n\n  proxy() {\n    return createProxy(this);\n  }\n\n  getParent(item) {\n    let parent = this.root;\n    const segments = item.split('/'); // find the parent container\n\n    for (const k of segments.slice(0, segments.length - 1)) {\n      parent = parent[k];\n\n      if (!parent) {\n        throw Error(item);\n      } // if not isinstance(parent, self.cls):\n      //     raise KeyError(item)\n\n    }\n\n    return [parent, segments[segments.length - 1]];\n  }\n\n  requireParent(item) {\n    let parent = this.root;\n    const segments = item.split('/'); // require the parent container\n\n    for (const k of segments.slice(0, segments.length - 1)) {\n      // TODO: verify correct implementation\n      if (parent[k] === undefined) {\n        parent[k] = {};\n      }\n\n      parent = parent[k];\n    }\n\n    return [parent, segments[segments.length - 1]];\n  }\n\n  getItem(item) {\n    const [parent, key] = this.getParent(item);\n    const value = parent[key];\n\n    if (value === undefined) {\n      throw new KeyError(item);\n    }\n\n    return value;\n  }\n\n  setItem(item, value) {\n    const [parent, key] = this.requireParent(item);\n    parent[key] = value;\n    return true;\n  }\n\n  deleteItem(item) {\n    const [parent, key] = this.getParent(item);\n    return delete parent[key];\n  }\n\n  containsItem(item) {\n    // TODO: more sane implementation\n    try {\n      return this.getItem(item) !== undefined;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  keys() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n}\n\nvar HTTPMethod;\n\n(function (HTTPMethod) {\n  HTTPMethod[\"HEAD\"] = \"HEAD\";\n  HTTPMethod[\"GET\"] = \"GET\";\n  HTTPMethod[\"PUT\"] = \"PUT\";\n})(HTTPMethod || (HTTPMethod = {}));\n\nconst DEFAULT_METHODS = [HTTPMethod.HEAD, HTTPMethod.GET, HTTPMethod.PUT];\n\nclass HTTPStore {\n  constructor(url, options = {}) {\n    this.url = url;\n    const {\n      fetchOptions = {},\n      supportedMethods = DEFAULT_METHODS\n    } = options;\n    this.fetchOptions = fetchOptions;\n    this.supportedMethods = new Set(supportedMethods);\n  }\n\n  keys() {\n    throw new Error('Method not implemented.');\n  }\n\n  async getItem(item, opts) {\n    const url = joinUrlParts(this.url, item);\n    const value = await fetch(url, { ...this.fetchOptions,\n      ...opts\n    });\n\n    if (value.status === 404) {\n      // Item is not found\n      throw new KeyError(item);\n    } else if (value.status !== 200) {\n      throw new HTTPError(String(value.status));\n    } // only decode if 200\n\n\n    if (IS_NODE) {\n      return Buffer.from((await value.arrayBuffer()));\n    } else {\n      return value.arrayBuffer(); // Browser\n    }\n  }\n\n  async setItem(item, value) {\n    if (!this.supportedMethods.has(HTTPMethod.PUT)) {\n      throw new Error('HTTP PUT no a supported method for store.');\n    }\n\n    const url = joinUrlParts(this.url, item);\n\n    if (typeof value === 'string') {\n      value = new TextEncoder().encode(value).buffer;\n    }\n\n    const set = await fetch(url, { ...this.fetchOptions,\n      method: HTTPMethod.PUT,\n      body: value\n    });\n    return set.status.toString()[0] === '2';\n  }\n\n  deleteItem(_item) {\n    throw new Error('Method not implemented.');\n  }\n\n  async containsItem(item) {\n    const url = joinUrlParts(this.url, item); // Just check headers if HEAD method supported\n\n    const method = this.supportedMethods.has(HTTPMethod.HEAD) ? HTTPMethod.HEAD : HTTPMethod.GET;\n    const value = await fetch(url, { ...this.fetchOptions,\n      method\n    });\n    return value.status === 200;\n  }\n\n}\n/**\r\n *\r\n * @param shape Array shape.\r\n * @param chunks  Chunk shape. If `true`, will be guessed from `shape` and `dtype`. If\r\n *      `false`, will be set to `shape`, i.e., single chunk for the whole array.\r\n *      If an int, the chunk size in each dimension will be given by the value\r\n *      of `chunks`. Default is `true`.\r\n * @param dtype NumPy dtype.\r\n * @param compressor Primary compressor.\r\n * @param fillValue Default value to use for uninitialized portions of the array.\r\n * @param order Memory layout to be used within each chunk.\r\n * @param store Store or path to directory in file system or name of zip file.\r\n * @param overwrite  If True, delete all pre-existing data in `store` at `path` before creating the array.\r\n * @param path Path under which array is stored.\r\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n * @param filters Sequence of filters to use to encode chunk data prior to compression.\r\n * @param cacheMetadata If `true` (default), array configuration metadata will be cached for the\r\n *      lifetime of the object. If `false`, array metadata will be reloaded\r\n *      prior to all data access and modification operations (may incur\r\n *      overhead depending on storage and data access pattern).\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read\r\n *      operations. If `false`, user attributes are reloaded from the store prior\r\n *      to all attribute read operations.\r\n * @param readOnly `true` if array should be protected against modification, defaults to `false`.\r\n */\n\n\nasync function create({\n  shape,\n  chunks = true,\n  dtype = \"<i4\",\n  compressor = null,\n  fillValue = null,\n  order = \"C\",\n  store,\n  overwrite = false,\n  path,\n  chunkStore,\n  filters,\n  cacheMetadata = true,\n  cacheAttrs = true,\n  readOnly = false\n}) {\n  store = normalizeStoreArgument(store);\n  await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n  const z = await ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n  return z;\n}\n/**\r\n * Create an empty array.\r\n */\n\n\nasync function empty(shape, opts = {}) {\n  opts.fillValue = null;\n  return create({\n    shape,\n    ...opts\n  });\n}\n/**\r\n * Create an array, with zero being used as the default value for\r\n * uninitialized portions of the array.\r\n */\n\n\nasync function zeros(shape, opts = {}) {\n  opts.fillValue = 0;\n  return create({\n    shape,\n    ...opts\n  });\n}\n/**\r\n * Create an array, with one being used as the default value for\r\n * uninitialized portions of the array.\r\n */\n\n\nasync function ones(shape, opts = {}) {\n  opts.fillValue = 1;\n  return create({\n    shape,\n    ...opts\n  });\n}\n/**\r\n * Create an array, with `fill_value` being used as the default value for\r\n * uninitialized portions of the array\r\n */\n\n\nasync function full(shape, fillValue, opts = {}) {\n  opts.fillValue = fillValue;\n  return create({\n    shape,\n    ...opts\n  });\n}\n\nasync function array(data, opts = {}) {\n  // TODO: infer chunks?\n  let shape = null;\n\n  if (data instanceof NestedArray) {\n    shape = data.shape;\n    opts.dtype = opts.dtype === undefined ? data.dtype : opts.dtype;\n  } else {\n    shape = data.byteLength; // TODO: infer datatype\n  } // TODO: support TypedArray\n\n\n  const wasReadOnly = opts.readOnly === undefined ? false : opts.readOnly;\n  opts.readOnly = false;\n  const z = await create({\n    shape,\n    ...opts\n  });\n  await z.set(null, data);\n  z.readOnly = wasReadOnly;\n  return z;\n}\n\nasync function openArray({\n  shape,\n  mode = \"a\",\n  chunks = true,\n  dtype = \"<i4\",\n  compressor = null,\n  fillValue = null,\n  order = \"C\",\n  store,\n  overwrite = false,\n  path = null,\n  chunkStore,\n  filters,\n  cacheMetadata = true,\n  cacheAttrs = true\n} = {}) {\n  store = normalizeStoreArgument(store);\n\n  if (chunkStore === undefined) {\n    chunkStore = normalizeStoreArgument(store);\n  }\n\n  path = normalizeStoragePath(path);\n\n  if (mode === \"r\" || mode === \"r+\") {\n    if (!(await containsArray(store, path))) {\n      if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n      }\n\n      throw new ArrayNotFoundError(path);\n    }\n  } else if (mode === \"w\") {\n    if (shape === undefined) {\n      throw new ValueError(\"Shape can not be undefined when creating a new array\");\n    }\n\n    await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n  } else if (mode === \"a\") {\n    if (!(await containsArray(store, path))) {\n      if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n      }\n\n      if (shape === undefined) {\n        throw new ValueError(\"Shape can not be undefined when creating a new array\");\n      }\n\n      await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n    }\n  } else if (mode === \"w-\" || mode === \"x\") {\n    if (await containsArray(store, path)) {\n      throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n      throw new ContainsGroupError(path);\n    } else {\n      if (shape === undefined) {\n        throw new ValueError(\"Shape can not be undefined when creating a new array\");\n      }\n\n      await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n    }\n  } else {\n    throw new ValueError(`Invalid mode argument: ${mode}`);\n  }\n\n  const readOnly = mode === \"r\";\n  return ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n}\n\nfunction normalizeStoreArgument(store) {\n  if (store === undefined) {\n    return new MemoryStore();\n  } else if (typeof store === \"string\") {\n    return new HTTPStore(store);\n  }\n\n  return store;\n}\n\nclass Group {\n  constructor(store, path = null, metadata, readOnly = false, chunkStore = null, cacheAttrs = true) {\n    this.store = store;\n    this._chunkStore = chunkStore;\n    this.path = normalizeStoragePath(path);\n    this.keyPrefix = pathToPrefix(this.path);\n    this.readOnly = readOnly;\n    this.meta = metadata; // Initialize attributes\n\n    const attrKey = this.keyPrefix + ATTRS_META_KEY;\n    this.attrs = new Attributes(this.store, attrKey, this.readOnly, cacheAttrs);\n  }\n  /**\r\n   * Group name following h5py convention.\r\n   */\n\n\n  get name() {\n    if (this.path.length > 0) {\n      if (this.path[0] !== \"/\") {\n        return \"/\" + this.path;\n      }\n\n      return this.path;\n    }\n\n    return \"/\";\n  }\n  /**\r\n   * Final component of name.\r\n   */\n\n\n  get basename() {\n    const parts = this.name.split(\"/\");\n    return parts[parts.length - 1];\n  }\n  /**\r\n   * A `Store` providing the underlying storage for array chunks.\r\n   */\n\n\n  get chunkStore() {\n    if (this._chunkStore) {\n      return this._chunkStore;\n    }\n\n    return this.store;\n  }\n\n  static async create(store, path = null, readOnly = false, chunkStore = null, cacheAttrs = true) {\n    const metadata = await this.loadMetadataForConstructor(store, path);\n    return new Group(store, path, metadata, readOnly, chunkStore, cacheAttrs);\n  }\n\n  static async loadMetadataForConstructor(store, path) {\n    path = normalizeStoragePath(path);\n    const keyPrefix = pathToPrefix(path);\n\n    try {\n      const metaStoreValue = await store.getItem(keyPrefix + GROUP_META_KEY);\n      return parseMetadata(metaStoreValue);\n    } catch (error) {\n      if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n      }\n\n      throw new GroupNotFoundError(path);\n    }\n  }\n\n  itemPath(item) {\n    const absolute = typeof item === \"string\" && item.length > 0 && item[0] === '/';\n    const path = normalizeStoragePath(item); // Absolute path\n\n    if (!absolute && this.path.length > 0) {\n      return this.keyPrefix + path;\n    }\n\n    return path;\n  }\n  /**\r\n   * Create a sub-group.\r\n   */\n\n\n  async createGroup(name, overwrite = false) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    const path = this.itemPath(name);\n    await initGroup(this.store, path, this._chunkStore, overwrite);\n    return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n  }\n  /**\r\n   * Obtain a sub-group, creating one if it doesn't exist.\r\n   */\n\n\n  async requireGroup(name, overwrite = false) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    const path = this.itemPath(name);\n\n    if (!(await containsGroup(this.store, path))) {\n      await initGroup(this.store, path, this._chunkStore, overwrite);\n    }\n\n    return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n  }\n\n  getOptsForArrayCreation(name, opts = {}) {\n    const path = this.itemPath(name);\n    opts.path = path;\n\n    if (opts.cacheAttrs === undefined) {\n      opts.cacheAttrs = this.attrs.cache;\n    }\n\n    opts.store = this.store;\n    opts.chunkStore = this.chunkStore;\n    return opts;\n  }\n  /**\r\n   * Creates an array\r\n   */\n\n\n  array(name, data, opts, overwrite) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    opts = this.getOptsForArrayCreation(name, opts);\n    opts.overwrite = overwrite === undefined ? opts.overwrite : overwrite;\n    return array(data, opts);\n  }\n\n  empty(name, shape, opts = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    opts = this.getOptsForArrayCreation(name, opts);\n    return empty(shape, opts);\n  }\n\n  zeros(name, shape, opts = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    opts = this.getOptsForArrayCreation(name, opts);\n    return zeros(shape, opts);\n  }\n\n  ones(name, shape, opts = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    opts = this.getOptsForArrayCreation(name, opts);\n    return ones(shape, opts);\n  }\n\n  full(name, shape, fillValue, opts = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    opts = this.getOptsForArrayCreation(name, opts);\n    return full(shape, fillValue, opts);\n  }\n\n  createDataset(name, shape, data, opts) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    opts = this.getOptsForArrayCreation(name, opts);\n    let z;\n\n    if (data === undefined) {\n      if (shape === undefined) {\n        throw new ValueError(\"Shape must be set if no data is passed to CreateDataset\");\n      }\n\n      z = create({\n        shape,\n        ...opts\n      });\n    } else {\n      z = array(data, opts);\n    }\n\n    return z;\n  }\n\n  async getItem(item) {\n    const path = this.itemPath(item);\n\n    if (await containsArray(this.store, path)) {\n      return ZarrArray.create(this.store, path, this.readOnly, this.chunkStore, undefined, this.attrs.cache);\n    } else if (await containsGroup(this.store, path)) {\n      return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n    }\n\n    throw new KeyError(item);\n  }\n\n  async setItem(item, value) {\n    await this.array(item, value, {}, true);\n    return true;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  async deleteItem(_item) {\n    if (this.readOnly) {\n      throw new PermissionError(\"group is read only\");\n    }\n\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async containsItem(item) {\n    const path = this.itemPath(item);\n    return (await containsArray(this.store, path)) || containsGroup(this.store, path);\n  }\n\n  proxy() {\n    return createProxy(this);\n  }\n\n}\n/**\r\n * Create a group.\r\n * @param store Store or path to directory in file system.\r\n * @param path Group path within store.\r\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n * @param overwrite If `true`, delete any pre-existing data in `store` at `path` before creating the group.\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations.\r\n *   If `false`, user attributes are reloaded from the store prior to all attribute read operations.\r\n */\n\n\nasync function group(store, path = null, chunkStore, overwrite = false, cacheAttrs = true) {\n  store = normalizeStoreArgument(store);\n  path = normalizeStoragePath(path);\n\n  if (overwrite || (await containsGroup(store))) {\n    await initGroup(store, path, chunkStore, overwrite);\n  }\n\n  return Group.create(store, path, false, chunkStore, cacheAttrs);\n}\n/**\r\n * Open a group using file-mode-like semantics.\r\n * @param store Store or path to directory in file system or name of zip file.\r\n * @param path Group path within store.\r\n * @param mode Persistence mode, see `PersistenceMode` type.\r\n * @param chunkStore Store or path to directory in file system or name of zip file.\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations\r\n *   If False, user attributes are reloaded from the store prior to all attribute read operations.\r\n *\r\n */\n\n\nasync function openGroup(store, path = null, mode = \"a\", chunkStore, cacheAttrs = true) {\n  store = normalizeStoreArgument(store);\n\n  if (chunkStore !== undefined) {\n    chunkStore = normalizeStoreArgument(store);\n  }\n\n  path = normalizeStoragePath(path);\n\n  if (mode === \"r\" || mode === \"r+\") {\n    if (!(await containsGroup(store, path))) {\n      if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n      }\n\n      throw new GroupNotFoundError(path);\n    }\n  } else if (mode === \"w\") {\n    await initGroup(store, path, chunkStore, true);\n  } else if (mode === \"a\") {\n    if (!(await containsGroup(store, path))) {\n      if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n      }\n\n      await initGroup(store, path, chunkStore);\n    }\n  } else if (mode === \"w-\" || mode === \"x\") {\n    if (await containsArray(store, path)) {\n      throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n      throw new ContainsGroupError(path);\n    } else {\n      await initGroup(store, path, chunkStore);\n    }\n  } else {\n    throw new ValueError(`Invalid mode argument: ${mode}`);\n  }\n\n  const readOnly = mode === \"r\";\n  return Group.create(store, path, readOnly, chunkStore, cacheAttrs);\n}\n\nclass ObjectStore {\n  constructor() {\n    this.object = {};\n  }\n\n  getItem(item) {\n    if (!Object.prototype.hasOwnProperty.call(this.object, item)) {\n      throw new KeyError(item);\n    }\n\n    return this.object[item];\n  }\n\n  setItem(item, value) {\n    this.object[item] = value;\n    return true;\n  }\n\n  deleteItem(item) {\n    return delete this.object[item];\n  }\n\n  containsItem(item) {\n    return Object.prototype.hasOwnProperty.call(this.object, item);\n  }\n\n  proxy() {\n    return createProxy(this);\n  }\n\n  keys() {\n    return Object.getOwnPropertyNames(this.object);\n  }\n\n}\n\nexport { ArrayNotFoundError, BoundsCheckError, ContainsArrayError, ContainsGroupError, DTYPE_TYPEDARRAY_MAPPING, Group, GroupNotFoundError, HTTPError, HTTPStore, InvalidSliceError, KeyError, MemoryStore, NegativeStepError, NestedArray, ObjectStore, PathNotFoundError, PermissionError, TooManyIndicesError, ValueError, ZarrArray, addCodec, array, create, createProxy, empty, full, getCodec, getTypedArrayDtypeString, group, isKeyError, normalizeStoreArgument, ones, openArray, openGroup, rangeTypedArray, slice, sliceIndices, zeros };","map":{"version":3,"sources":["../src/compression/registry.ts","../src/mutableMapping.ts","../src/errors.ts","../src/core/slice.ts","../src/core/indexing.ts","../src/util.ts","../src/names.ts","../src/storage/index.ts","../src/metadata.ts","../src/attributes.ts","../src/nestedArray/types.ts","../src/nestedArray/ops.ts","../src/nestedArray/index.ts","../src/rawArray/ops.ts","../src/rawArray/index.ts","../node_modules/eventemitter3/index.js","../node_modules/p-finally/index.js","../node_modules/p-timeout/index.js","../node_modules/p-queue/dist/lower-bound.js","../node_modules/p-queue/dist/priority-queue.js","../node_modules/p-queue/dist/index.js","../src/core/index.ts","../src/storage/memoryStore.ts","../src/storage/httpStore.ts","../src/creation.ts","../src/hierarchy.ts","../src/storage/objectStore.ts"],"names":["lower_bound_1","p_timeout_1","EventEmitter","priority_queue_1"],"mappings":"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","sourcesContent":["import type { Codec, CompressorConfig } from 'numcodecs';\n\n// TODO: This interface is tied to compressors in numcodecs..\n// might be better to just use 'any' or have numcodecs export complete \n// (optional) config? \ninterface Options {\n  level?: number;\n  cname?: string;\n  blocksize?: number;\n  clevel?: number;\n  shuffle?: number;\n}\n\ntype CodecConstructor = { fromConfig(config: Options & CompressorConfig): Codec };\ntype CodecImporter = () => CodecConstructor | Promise<CodecConstructor>;\n\nconst registry: Map<string, CodecImporter> = new Map();\n\nexport function addCodec(id: string, importFn: CodecImporter) {\n  registry.set(id, importFn);\n}\n\nexport async function getCodec<T extends Codec>(config: Options & CompressorConfig): Promise<T> {\n  if (!registry.has(config.id)) {\n    throw new Error(`Compression codec ${config.id} is not supported by Zarr.js yet.`);\n  }\n  const codec = await (registry.get(config.id) as CodecImporter)();\n  return codec.fromConfig(config) as T;\n}\n","/**\n * Closely resembles the functions on the MutableMapping type in Python.\n */\nexport interface MutableMapping<T, O=any> {\n    getItem(item: string, opts?: O): T;\n    setItem(item: string, value: T): boolean;\n    deleteItem(item: string): boolean;\n    containsItem(item: string): boolean;\n\n    proxy(): MutableMappingProxy<T>;\n\n    // length(): number;\n}\n\n/**\n * Closely resembles the functions on the MutableMapping type in Python.\n */\nexport interface AsyncMutableMapping<T, O=any> {\n    getItem(item: string, opts?: O): Promise<T>;\n    setItem(item: string, value: T): Promise<boolean>;\n    deleteItem(item: string): Promise<boolean>;\n    containsItem(item: string): Promise<boolean>;\n    // length(): number;\n}\n\nexport interface MutableMappingProxy<T> {\n    [key: string]: T;\n}\n\nexport interface AsyncMutableMappingProxy<T> {\n    [key: string]: T | Promise<T>;\n}\n\n\n/**\n * A proxy allows for accessing, setting and deleting the keys in the mutable mapping using\n * m[\"a\"] or even m.a notation.\n */\nexport function createProxy<S, T>(mapping: S & MutableMapping<T>): (S & MutableMappingProxy<T>);\nexport function createProxy<S, T>(mapping: S & AsyncMutableMapping<T>): (S & AsyncMutableMappingProxy<T>);\nexport function createProxy<S, T>(mapping: (S & MutableMapping<T>) | (S & AsyncMutableMapping<T>)): (S & MutableMappingProxy<T>) | (S & AsyncMutableMappingProxy<T>) {\n    return new Proxy(mapping as any, {\n        set(target, key, value, _receiver) {\n            return target.setItem(key as string, value);\n        },\n        get(target, key, _receiver) {\n            return target.getItem(key as string);\n        },\n        deleteProperty(target, key) {\n            return target.deleteItem(key as string);\n        },\n        has(target, key) {\n            return target.containsItem(key as string);\n        }\n    });\n}","export interface ZarrError {\n    __zarr__: string;\n}\n\nfunction isZarrError(err: unknown): err is ZarrError {\n    return typeof err === 'object' && err !== null && '__zarr__' in err;\n}\n\nexport function isKeyError(o: unknown) {\n    return isZarrError(o) && o.__zarr__ === 'KeyError';\n}\n\n// Custom error messages, note we have to patch the prototype of the\n// errors to fix `instanceof` calls, see:\n// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\nexport class ContainsArrayError extends Error implements ZarrError {\n    __zarr__ = 'ContainsArrayError';\n    constructor(path: string) {\n        super(`path ${path} contains an array`);\n        Object.setPrototypeOf(this, ContainsArrayError.prototype);\n    }\n}\n\nexport class ContainsGroupError extends Error implements ZarrError {\n    __zarr__ = 'ContainsGroupError';\n    constructor(path: string) {\n        super(`path ${path} contains a group`);\n        Object.setPrototypeOf(this, ContainsGroupError.prototype);\n    }\n}\n\nexport class ArrayNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'ArrayNotFoundError';\n    constructor(path: string) {\n        super(`array not found at path ${path}`);\n        Object.setPrototypeOf(this, ArrayNotFoundError.prototype);\n    }\n}\n\nexport class GroupNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'GroupNotFoundError';\n    constructor(path: string) {\n        super(`ground not found at path ${path}`);\n        Object.setPrototypeOf(this, GroupNotFoundError.prototype);\n    }\n}\n\nexport class PathNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'PathNotFoundError';\n    constructor(path: string) {\n        super(`nothing not found at path ${path}`);\n        Object.setPrototypeOf(this, PathNotFoundError.prototype);\n    }\n}\n\nexport class PermissionError extends Error implements ZarrError {\n    __zarr__ = 'PermissionError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, PermissionError.prototype);\n    }\n}\n\nexport class KeyError extends Error implements ZarrError {\n    __zarr__ = 'KeyError';\n    constructor(key: string) {\n        super(`key ${key} not present`);\n        Object.setPrototypeOf(this, KeyError.prototype);\n    }\n}\n\nexport class TooManyIndicesError extends RangeError implements ZarrError {\n    __zarr__ = 'TooManyIndicesError';\n    constructor(selection: any[], shape: number[]) {\n        super(`too many indices for array; expected ${shape.length}, got ${selection.length}`);\n        Object.setPrototypeOf(this, TooManyIndicesError.prototype);\n    }\n}\n\nexport class BoundsCheckError extends RangeError implements ZarrError {\n    __zarr__ = 'BoundsCheckError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, BoundsCheckError.prototype);\n    }\n}\n\nexport class InvalidSliceError extends RangeError implements ZarrError {\n    __zarr__ = 'InvalidSliceError';\n    constructor(from: any, to: any, stepSize: any, reason: any) {\n        super(`slice arguments slice(${from}, ${to}, ${stepSize}) invalid: ${reason}`);\n        Object.setPrototypeOf(this, InvalidSliceError.prototype);\n    }\n}\n\nexport class NegativeStepError extends Error implements ZarrError {\n    __zarr__ = 'NegativeStepError';\n    constructor() {\n        super(`Negative step size is not supported when indexing.`);\n        Object.setPrototypeOf(this, NegativeStepError.prototype);\n    }\n}\n\nexport class ValueError extends Error implements ZarrError {\n    __zarr__ = 'ValueError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, ValueError.prototype);\n    }\n}\n\nexport class HTTPError extends Error implements ZarrError {\n    __zarr__ = 'HTTPError';\n    constructor(code: string) {\n        super(code);\n        Object.setPrototypeOf(this, HTTPError.prototype);\n    }\n}\n","\nimport { InvalidSliceError } from '../errors';\nimport { Slice, SliceArgument, SliceIndices } from \"./types\";\n\nexport function slice(start: SliceArgument, stop: SliceArgument | undefined = undefined, step: number | null = null): Slice {\n    // tslint:disable-next-line: strict-type-predicates\n    if (start === undefined) { // Not possible in typescript\n        throw new InvalidSliceError(start, stop, step, \"The first argument must not be undefined\");\n    }\n\n    if ((typeof start === \"string\" && start !== \":\") || (typeof stop === \"string\" && stop !== \":\")) { // Note in typescript this will never happen with type checking.\n        throw new InvalidSliceError(start, stop, step, \"Arguments can only be integers, \\\":\\\" or null\");\n    }\n\n    // slice(5) === slice(null, 5)\n    if (stop === undefined) {\n        stop = start;\n        start = null;\n    }\n\n    // if (start !== null && stop !== null && start > stop) {\n    //     throw new InvalidSliceError(start, stop, step, \"to is higher than from\");\n    // }\n\n    return {\n        start: start === \":\" ? null : start,\n        stop: stop === \":\" ? null : stop,\n        step,\n        _slice: true,\n    };\n}\n\n\n/**\n * Port of adjustIndices\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L243\n */\nfunction adjustIndices(start: number, stop: number, step: number, length: number) {\n    if (start < 0) {\n        start += length;\n        if (start < 0) {\n            start = (step < 0) ? -1 : 0;\n        }\n    } else if (start >= length) {\n        start = (step < 0) ? length - 1 : length;\n    }\n\n    if (stop < 0) {\n        stop += length;\n        if (stop < 0) {\n            stop = (step < 0) ? -1 : 0;\n        }\n    } else if (stop >= length) {\n        stop = (step < 0) ? length - 1 : length;\n    }\n\n    if (step < 0) {\n        if (stop < start) {\n            const length = Math.floor((start - stop - 1) / (-step) + 1);\n            return [start, stop, step, length];\n        }\n    } else {\n        if (start < stop) {\n            const length = Math.floor((stop - start - 1) / step + 1);\n            return [start, stop, step, length];\n        }\n    }\n    return [start, stop, step, 0];\n}\n\n/**\n * Port of slice.indices(n) and PySlice_Unpack\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L166\n *  https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L198 \n * \n * Behaviour might be slightly different as it's a weird hybrid implementation.\n */\nexport function sliceIndices(slice: Slice, length: number): SliceIndices {\n    let start: number;\n    let stop: number;\n    let step: number;\n\n    if (slice.step === null) {\n        step = 1;\n    } else {\n        step = slice.step;\n    }\n\n    if (slice.start === null) {\n        start = step < 0 ? Number.MAX_SAFE_INTEGER : 0;\n    } else {\n        start = slice.start;\n        if (start < 0) {\n            start += length;\n        }\n    }\n\n    if (slice.stop === null) {\n        stop = step < 0 ? -Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;\n    } else {\n        stop = slice.stop;\n        if (stop < 0) {\n            stop += length;\n        }\n    }\n\n    // This clips out of bounds slices\n    const s = adjustIndices(start, stop, step, length);\n    start = s[0];\n    stop = s[1];\n    step = s[2];\n    // The output length\n    length = s[3];\n\n\n    // With out of bounds slicing these two assertions are not useful.\n    // if (stop > length) throw new Error(\"Stop greater than length\");\n    // if (start >= length) throw new Error(\"Start greater than or equal to length\");\n\n    if (step === 0) throw new Error(\"Step size 0 is invalid\");\n\n    return [start, stop, step, length];\n}","import { TooManyIndicesError, BoundsCheckError, NegativeStepError } from '../errors';\nimport { ZarrArray } from './index';\nimport { Slice, ArraySelection, ChunkDimProjection, Indexer, DimIndexer, ChunkProjection, NormalizedArraySelection, SliceIndices, DimensionArraySelection } from './types';\nimport { sliceIndices, slice } from \"./slice\";\n\nfunction ensureArray(selection: ArraySelection): DimensionArraySelection[] {\n    if (!Array.isArray(selection)) {\n        return [selection];\n    }\n    return selection;\n}\n\nfunction checkSelectionLength(selection: DimensionArraySelection[], shape: number[]) {\n    if (selection.length > shape.length) {\n        throw new TooManyIndicesError(selection, shape);\n    }\n}\n\n/**\n * Returns both the sliceIndices per dimension and the output shape after slicing.\n */\nexport function selectionToSliceIndices(selection: NormalizedArraySelection, shape: number[]): [(number | SliceIndices)[], number[]] {\n    const sliceIndicesResult = [];\n    const outShape = [];\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (typeof s === \"number\") {\n            sliceIndicesResult.push(s);\n        } else {\n            const x = sliceIndices(s, shape[i]);\n            const dimLength = x[3];\n\n            outShape.push(dimLength);\n            sliceIndicesResult.push(x);\n        }\n    }\n\n    return [sliceIndicesResult, outShape];\n}\n\n/**\n * This translates \"...\", \":\", null into a list of slices or non-negative integer selections of length shape\n */\nexport function normalizeArraySelection(selection: ArraySelection | number, shape: number[], convertIntegerSelectionToSlices = false): NormalizedArraySelection {\n    selection = replaceEllipsis(selection, shape);\n\n    for (let i = 0; i < selection.length; i++) {\n        const dimSelection = selection[i];\n\n        if (typeof dimSelection === \"number\") {\n            if (convertIntegerSelectionToSlices) {\n                selection[i] = slice(dimSelection, dimSelection + 1, 1);\n            } else {\n                selection[i] = normalizeIntegerSelection(dimSelection, shape[i]);\n            }\n        } else if (isIntegerArray(dimSelection)) {\n            throw new TypeError(\"Integer array selections are not supported (yet)\");\n        } else if (dimSelection === \":\" || dimSelection === null) {\n            selection[i] = slice(null, null, 1);\n        }\n    }\n\n    return selection as NormalizedArraySelection;\n}\n\nexport function replaceEllipsis(selection: ArraySelection | number, shape: number[]) {\n    selection = ensureArray(selection);\n\n    let ellipsisIndex = -1;\n    let numEllipsis = 0;\n    for (let i = 0; i < selection.length; i++) {\n        if (selection[i] === \"...\") {\n            ellipsisIndex = i;\n            numEllipsis += 1;\n        }\n    }\n\n    if (numEllipsis > 1) {\n        throw new RangeError(\"an index can only have a single ellipsis ('...')\");\n    }\n    if (numEllipsis === 1) {\n        // count how many items to left and right of ellipsis\n        const numItemsLeft = ellipsisIndex;\n        const numItemsRight = selection.length - (numItemsLeft + 1);\n        const numItems = selection.length - 1; // All non-ellipsis items\n        if (numItems >= shape.length) {\n            // Ellipsis does nothing, just remove it\n            selection = selection.filter((x) => x !== \"...\");\n        } else {\n            // Replace ellipsis with as many slices are needed for number of dims\n            const numNewItems = shape.length - numItems;\n            let newItem = selection.slice(0, numItemsLeft).concat(new Array(numNewItems).fill(null));\n            if (numItemsRight > 0) {\n                newItem = newItem.concat(selection.slice(selection.length - numItemsRight));\n            }\n            selection = newItem;\n        }\n    }\n    // Fill out selection if not completely specified\n    if (selection.length < shape.length) {\n        const numMissing = shape.length - selection.length;\n        selection = selection.concat(new Array(numMissing).fill(null));\n    }\n\n    checkSelectionLength(selection, shape);\n    return selection;\n}\n\nexport function normalizeIntegerSelection(dimSelection: number, dimLength: number): number {\n    // Note: Maybe we should convert to integer or warn if dimSelection is not an integer\n\n    // handle wraparound\n    if (dimSelection < 0) {\n        dimSelection = dimLength + dimSelection;\n    }\n\n    // handle out of bounds\n    if (dimSelection >= dimLength || dimSelection < 0) {\n        throw new BoundsCheckError(`index out of bounds for dimension with length ${dimLength}`);\n    }\n\n    return dimSelection;\n}\n\nfunction isInteger(s: any) {\n    return typeof s === \"number\";\n}\n\nexport function isIntegerArray(s: any) {\n    if (!Array.isArray(s)) {\n        return false;\n    }\n    for (const e of s) {\n        if (typeof e !== \"number\") {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function isSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    if (s !== null && (s as any)[\"_slice\"] === true) {\n        return true;\n    }\n    return false;\n}\n\nfunction isContiguousSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    return isSlice(s) && ((s as Slice).step === null || (s as Slice).step === 1);\n}\n\nfunction isPositiveSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    return isSlice(s) && ((s as Slice).step === null || ((s as Slice).step as number) >= 1);\n}\n\nexport function isContiguousSelection(selection: ArraySelection) {\n    selection = ensureArray(selection);\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (!(isIntegerArray(s) || isContiguousSlice(s) || s === \"...\")) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction isBasicSelection(selection: ArraySelection): boolean {\n    selection = ensureArray(selection);\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (!(isInteger(s) || isPositiveSlice(s))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction* product<T>(...iterables: (() => IterableIterator<T>)[]): IterableIterator<T[]> {\n    if (iterables.length === 0) { return; }\n    // make a list of iterators from the iterables\n    const iterators = iterables.map(it => it());\n    const results = iterators.map(it => it.next());\n\n    // Disabled to allow empty inputs\n    // if (results.some(r => r.done)) {\n    //     throw new Error(\"Input contains an empty iterator.\");\n    // }\n\n    for (let i = 0; ;) {\n        if (results[i].done) {\n            // reset the current iterator\n            iterators[i] = iterables[i]();\n            results[i] = iterators[i].next();\n            // advance, and exit if we've reached the end\n            if (++i >= iterators.length) { return; }\n        } else {\n            yield results.map(({ value }) => value);\n            i = 0;\n        }\n        results[i] = iterators[i].next();\n    }\n}\n\nexport class BasicIndexer implements Indexer {\n    dimIndexers: DimIndexer[];\n    shape: number[];\n    dropAxes: null;\n\n    constructor(selection: ArraySelection, array: ZarrArray) {\n        selection = normalizeArraySelection(selection, array.shape);\n\n        // Setup per-dimension indexers\n        this.dimIndexers = [];\n        const arrayShape = array.shape;\n        for (let i = 0; i < arrayShape.length; i++) {\n            let dimSelection = selection[i];\n            const dimLength = arrayShape[i];\n            const dimChunkLength = array.chunks[i];\n\n            if (dimSelection === null) {\n                dimSelection = slice(null);\n            }\n\n\n            if (isInteger(dimSelection)) {\n                this.dimIndexers.push(new IntDimIndexer(dimSelection as number, dimLength, dimChunkLength));\n            } else if (isSlice(dimSelection)) {\n                this.dimIndexers.push(new SliceDimIndexer(dimSelection as Slice, dimLength, dimChunkLength));\n            } else {\n                throw new RangeError(`Unspported selection item for basic indexing; expected integer or slice, got ${dimSelection}`);\n            }\n        }\n\n        this.shape = [];\n        for (const d of this.dimIndexers) {\n            if (d instanceof SliceDimIndexer) {\n                this.shape.push(d.numItems);\n            }\n        }\n        this.dropAxes = null;\n    }\n\n    * iter() {\n        const dimIndexerIterables = this.dimIndexers.map(x => (() => x.iter()));\n        const dimIndexerProduct = product(...dimIndexerIterables);\n\n        for (const dimProjections of dimIndexerProduct) {\n            // TODO fix this, I think the product outputs too many combinations\n            const chunkCoords = [];\n            const chunkSelection = [];\n            const outSelection = [];\n\n            for (const p of dimProjections) {\n                chunkCoords.push((p).dimChunkIndex);\n                chunkSelection.push((p).dimChunkSelection);\n                if ((p).dimOutSelection !== null) {\n                    outSelection.push((p).dimOutSelection);\n                }\n            }\n\n            yield ({\n                chunkCoords,\n                chunkSelection,\n                outSelection,\n            } as ChunkProjection);\n        }\n\n    }\n}\n\nclass IntDimIndexer implements DimIndexer {\n    dimSelection: number;\n    dimLength: number;\n    dimChunkLength: number;\n    numItems: number;\n\n    constructor(dimSelection: number, dimLength: number, dimChunkLength: number) {\n        dimSelection = normalizeIntegerSelection(dimSelection, dimLength);\n        this.dimSelection = dimSelection;\n        this.dimLength = dimLength;\n        this.dimChunkLength = dimChunkLength;\n        this.numItems = 1;\n    }\n\n    * iter() {\n        const dimChunkIndex = Math.floor(this.dimSelection / this.dimChunkLength);\n        const dimOffset = dimChunkIndex * this.dimChunkLength;\n        const dimChunkSelection = this.dimSelection - dimOffset;\n        const dimOutSelection = null;\n        yield {\n            dimChunkIndex,\n            dimChunkSelection,\n            dimOutSelection,\n        } as ChunkDimProjection;\n    }\n}\n\nclass SliceDimIndexer implements DimIndexer {\n    dimLength: number;\n    dimChunkLength: number;\n    numItems: number;\n    numChunks: number;\n\n    start: number;\n    stop: number;\n    step: number;\n\n    constructor(dimSelection: Slice, dimLength: number, dimChunkLength: number) {\n        // Normalize\n        const [start, stop, step] = sliceIndices(dimSelection, dimLength);\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n        if (this.step < 1) {\n            throw new NegativeStepError();\n        }\n\n        this.dimLength = dimLength;\n        this.dimChunkLength = dimChunkLength;\n        this.numItems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n        this.numChunks = Math.ceil(this.dimLength / this.dimChunkLength);\n    }\n\n    *iter() {\n        const dimChunkIndexFrom = Math.floor(this.start / this.dimChunkLength);\n        const dimChunkIndexTo = Math.ceil(this.stop / this.dimChunkLength);\n\n        // Iterate over chunks in range\n        for (let dimChunkIndex = dimChunkIndexFrom; dimChunkIndex < dimChunkIndexTo; dimChunkIndex++) {\n\n            // Compute offsets for chunk within overall array\n            const dimOffset = dimChunkIndex * this.dimChunkLength;\n            const dimLimit = Math.min(this.dimLength, (dimChunkIndex + 1) * this.dimChunkLength);\n\n            // Determine chunk length, accounting for trailing chunk\n            const dimChunkLength = dimLimit - dimOffset;\n\n            let dimChunkSelStart: number;\n            let dimChunkSelStop: number;\n            let dimOutOffset: number;\n\n            if (this.start < dimOffset) {\n                // Selection starts before current chunk\n\n                dimChunkSelStart = 0;\n                const remainder = (dimOffset - this.start) % this.step;\n                if (remainder > 0) {\n                    dimChunkSelStart += this.step - remainder;\n                }\n                // Compute number of previous items, provides offset into output array\n                dimOutOffset = Math.ceil((dimOffset - this.start) / this.step);\n            } else {\n                // Selection starts within current chunk\n                dimChunkSelStart = this.start - dimOffset;\n                dimOutOffset = 0;\n            }\n\n            if (this.stop > dimLimit) {\n                // Selection ends after current chunk\n                dimChunkSelStop = dimChunkLength;\n            } else {\n                // Selection ends within current chunk\n                dimChunkSelStop = this.stop - dimOffset;\n            }\n\n            const dimChunkSelection = slice(dimChunkSelStart, dimChunkSelStop, this.step);\n            const dimChunkNumItems = Math.ceil((dimChunkSelStop - dimChunkSelStart) / this.step);\n            const dimOutSelection = slice(dimOutOffset, dimOutOffset + dimChunkNumItems);\n            yield {\n                dimChunkIndex,\n                dimChunkSelection,\n                dimOutSelection,\n            } as ChunkDimProjection;\n        }\n\n    }\n\n}\n","import { Order, FillType, ChunksArgument, DtypeString } from \"./types\";\n\nimport { DimensionSelection, Slice } from \"./core/types\";\nimport { isSlice } from \"./core/indexing\";\nimport { TypedArray } from \"./nestedArray/types\";\n\n/**\n * This should be true only if this javascript is getting executed in Node.\n */\nexport const IS_NODE = typeof process !== \"undefined\" && process.versions && process.versions.node;\n\nexport function humanReadableSize(size: number) {\n    if (size < 2 ** 10) {\n        return `${size}`;\n    }\n    else if (size < 2 ** 20) {\n        return `${(size / (2 ** 10)).toFixed(1)}K`;\n    }\n    else if (size < 2 ** 30) {\n        return `${(size / (2 ** 20)).toFixed(1)}M`;\n    }\n    else if (size < 2 ** 40) {\n        return `${(size / (2 ** 30)).toFixed(1)}G`;\n    }\n    else if (size < 2 ** 50) {\n        return `${(size / (2 ** 40)).toFixed(1)}T`;\n    }\n    return `${(size / (2 ** 50)).toFixed(1)}P`;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function normalizeStoragePath(path: string | String | null): string {\n    if (path === null) {\n        return \"\";\n    }\n\n    if (path instanceof String) {\n        path = path.valueOf();\n    }\n\n    // convert backslash to forward slash\n    path = path.replace(/\\\\/g, \"/\");\n    // ensure no leading slash\n    while (path.length > 0 && path[0] === '/') {\n        path = path.slice(1);\n    }\n\n    // ensure no trailing slash\n    while (path.length > 0 && path[path.length - 1] === '/') {\n        path = path.slice(0, path.length - 1);\n    }\n\n\n    // collapse any repeated slashes\n    path = path.replace(/\\/\\/+/g, \"/\");\n\n    // don't allow path segments with just '.' or '..'\n    const segments = path.split('/');\n\n    for (const s of segments) {\n        if (s === \".\" || s === \"..\") {\n            throw Error(\"path containing '.' or '..' segment not allowed\");\n        }\n    }\n    return path as string;\n}\n\nexport function normalizeShape(shape: number | number[]): number[] {\n    if (typeof shape === \"number\") {\n        shape = [shape];\n    }\n    return shape.map(x => Math.floor(x));\n}\n\nexport function normalizeChunks(chunks: ChunksArgument, shape: number[]): number[] {\n    // Assume shape is already normalized\n\n    if (chunks === null || chunks === true) {\n        throw new Error(\"Chunk guessing is not supported yet\");\n    }\n\n    if (chunks === false) {\n        return shape;\n    }\n\n    if (typeof chunks === \"number\") {\n        chunks = [chunks];\n    }\n\n    // handle underspecified chunks\n    if (chunks.length < shape.length) {\n        // assume chunks across remaining dimensions\n        chunks = chunks.concat(shape.slice(chunks.length));\n    }\n\n    return chunks.map((x, idx) => {\n        // handle null or -1 in chunks\n        if (x === -1 || x === null) {\n            return shape[idx];\n        } else {\n            return Math.floor(x);\n        }\n    });\n}\n\nexport function normalizeOrder(order: string): Order {\n    order = order.toUpperCase();\n    return order as Order;\n}\n\nexport function normalizeDtype(dtype: DtypeString): DtypeString {\n    return dtype;\n}\n\nexport function normalizeFillValue(fillValue: FillType): FillType {\n    return fillValue;\n}\n\n/**\n * Determine whether `item` specifies a complete slice of array with the\n *  given `shape`. Used to optimize __setitem__ operations on chunks\n * @param item\n * @param shape\n */\nexport function isTotalSlice(item: DimensionSelection | DimensionSelection[], shape: number[]): boolean {\n    if (item === null) {\n        return true;\n    }\n    if (!Array.isArray(item)) {\n        item = [item];\n    }\n\n    for (let i = 0; i < Math.min(item.length, shape.length); i++) {\n        const it = item[i];\n        if (it === null) continue;\n\n        if (isSlice(it)) {\n            const s = it as Slice;\n            const isStepOne = s.step === 1 || s.step === null;\n\n            if (s.start === null && s.stop === null && isStepOne) {\n                continue;\n            }\n            if (((s.stop as number) - (s.start as number)) === shape[i] && isStepOne) {\n                continue;\n            }\n            return false;\n        }\n        return false;\n\n\n        // } else {\n        //     console.error(`isTotalSlice unexpected non-slice, got ${it}`);\n        //     return false;\n        // }\n    }\n    return true;\n}\n\n/**\n * Checks for === equality of all elements.\n */\nexport function arrayEquals1D(a: ArrayLike<any>, b: ArrayLike<any>) {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/*\n * Determines \"C\" order strides for a given shape array.\n * Strides provide integer steps in each dimention to traverse an ndarray.\n *\n * NOTE: - These strides here are distinct from numpy.ndarray.strides, which describe actual byte steps.\n *       - Strides are assumed to be contiguous, so initial step is 1. Thus, output will always be [XX, XX, 1].\n */\nexport function getStrides(shape: number[]): number[] {\n    // adapted from https://github.com/scijs/ndarray/blob/master/ndarray.js#L326-L330\n    const ndim = shape.length;\n    const strides = Array(ndim);\n    let step = 1; // init step\n    for (let i = ndim - 1; i >= 0; i--) {\n        strides[i] = step;\n        step *= shape[i];\n    }\n    return strides;\n}\n\n/**\n * Preserves (double) slashes earlier in the path, so this works better\n * for URLs. From https://stackoverflow.com/a/46427607/4178400\n * @param args parts of a path or URL to join.\n */\nexport function joinUrlParts(...args: string[]) {\n    return args.map((part, i) => {\n        if (i === 0) {\n          return part.trim().replace(/[\\/]*$/g, '');\n        } else {\n          return part.trim().replace(/(^[\\/]*|[\\/]*$)/g, '');\n        }\n      }).filter(x=>x.length).join('/');\n}\n\n\n/**\n * Swaps byte order in-place for a given TypedArray.\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\n * @param src TypedArray\n */\nexport function byteSwapInplace(src: TypedArray): void {\n  const b = src.BYTES_PER_ELEMENT;\n  if (b === 1) return; // no swapping needed\n  if (IS_NODE) {\n    // Use builtin methods for swapping if in Node environment\n    const bytes = Buffer.from(src.buffer, src.byteOffset, src.length * b);\n    if (b === 2) bytes.swap16();\n    if (b === 4) bytes.swap32();\n    if (b === 8) bytes.swap64();\n    return;\n  }\n  // In browser, need to flip manually\n  // Adapted from https://github.com/zbjornson/node-bswap/blob/master/bswap.js\n  const flipper = new Uint8Array(src.buffer, src.byteOffset, src.length * b);\n  const numFlips = b / 2;\n  const endByteIndex = b - 1;\n  let t: number;\n  for (let i = 0; i < flipper.length; i += b) {\n    for (let j = 0; j < numFlips; j++) {\n      t = flipper[i + j];\n      flipper[i + j] = flipper[i + endByteIndex - j];\n      flipper[i + endByteIndex - j] = t;\n    }\n  }\n}\n\n/**\n * Creates a copy of a TypedArray and swaps bytes.\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\n * @param src TypedArray\n */\nexport function byteSwap(src: TypedArray): TypedArray {\n    const copy = src.slice();\n    byteSwapInplace(copy);\n    return copy;\n}\n","export const ARRAY_META_KEY = \".zarray\";\nexport const GROUP_META_KEY = \".zgroup\";\nexport const ATTRS_META_KEY = \".zattrs\";\n","import { normalizeStoragePath, normalizeChunks, normalizeDtype, normalizeShape, normalizeOrder, normalizeFillValue } from '../util';\nimport { Store } from './types';\nimport { ARRAY_META_KEY, GROUP_META_KEY } from '../names';\nimport { FillType, Order, Filter, CompressorConfig, ZarrGroupMetadata, ChunksArgument, DtypeString, ZarrArrayMetadata, FillTypeSerialized } from '../types';\nimport { ContainsArrayError, ContainsGroupError } from '../errors';\n\n\n/**\n * Return true if the store contains an array at the given logical path.\n */\nexport async function containsArray(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    const prefix = pathToPrefix(path);\n    const key = prefix + ARRAY_META_KEY;\n    return store.containsItem(key);\n}\n\n/**\n * Return true if the store contains a group at the given logical path.\n */\nexport async function containsGroup<T>(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    const prefix = pathToPrefix(path);\n    const key = prefix + GROUP_META_KEY;\n    return store.containsItem(key);\n}\n\n\nexport function pathToPrefix(path: string): string {\n    // assume path already normalized\n    if (path.length > 0) {\n        return path + '/';\n    }\n    return '';\n}\n\nasync function listDirFromKeys(store: Store, path: string) {\n    // assume path already normalized\n    const prefix = pathToPrefix(path);\n    const children = new Set<string>();\n\n    for (const key in await store.keys()) {\n        if (key.startsWith(prefix) && key.length > prefix.length) {\n            const suffix = key.slice(prefix.length);\n            const child = suffix.split('/')[0];\n            children.add(child);\n        }\n    }\n    return Array.from(children).sort();\n}\n\nasync function requireParentGroup(store: Store, path: string, chunkStore: Store | null, overwrite: boolean) {\n    // Assume path is normalized\n    if (path.length === 0) {\n        return;\n    }\n\n    const segments = path.split(\"/\");\n    let p = \"\";\n    for (const s of segments.slice(0, segments.length - 1)) {\n        p += s;\n        if (await containsArray(store, p)) {\n            await initGroupMetadata(store, p, overwrite);\n        } else if (!await containsGroup(store, p)) {\n            await initGroupMetadata(store, p);\n        }\n        p += \"/\";\n    }\n}\n\n/**\n * Obtain a directory listing for the given path. If `store` provides a `listDir`\n *  method, this will be called, otherwise will fall back to implementation via the\n *  `MutableMapping` interface.\n * @param store \n */\nexport async function listDir(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    if (store.listDir) {\n        return store.listDir(path);\n    } else {\n        return listDirFromKeys(store, path);\n    }\n}\n\nasync function initGroupMetadata(store: Store, path: string | null = null,overwrite = false) {\n    path = normalizeStoragePath(path);\n\n    // Guard conditions\n    if (overwrite) {\n        throw Error(\"Group overwriting not implemented yet :(\");\n    } else if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n    }\n\n    const metadata: ZarrGroupMetadata = { zarr_format: 2 };\n    const key = pathToPrefix(path) + GROUP_META_KEY;\n    await store.setItem(key, JSON.stringify(metadata));\n}\n/**\n *  Initialize a group store. Note that this is a low-level function and there should be no\n *  need to call this directly from user code.\n */\nexport async function initGroup(store: Store, path: string | null = null, chunkStore: null | Store = null, overwrite = false) {\n    path = normalizeStoragePath(path);\n    await requireParentGroup(store, path, chunkStore, overwrite);\n    await initGroupMetadata(store, path, overwrite);\n}\n\nasync function initArrayMetadata(\n    store: Store,\n    shape: number | number[],\n    chunks: ChunksArgument,\n    dtype: DtypeString,\n    path: string,\n    compressor: null | CompressorConfig,\n    fillValue: FillType,\n    order: Order,\n    overwrite: boolean,\n    chunkStore: null | Store,\n    filters: null | Filter[]\n) {\n    // Guard conditions\n    if (overwrite) {\n        throw Error(\"Array overwriting not implemented yet :(\");\n    } else if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n    }\n\n    // Normalize metadata,  does type checking too.\n    dtype = normalizeDtype(dtype);\n    shape = normalizeShape(shape);\n    chunks = normalizeChunks(chunks, shape);\n    order = normalizeOrder(order);\n    fillValue = normalizeFillValue(fillValue);\n\n    if (filters !== null && filters.length > 0) {\n        throw Error(\"Filters are not supported yet\");\n    }\n\n    let serializedFillValue: FillTypeSerialized = fillValue;\n\n    if (typeof fillValue === \"number\") {\n        if (Number.isNaN(fillValue)) serializedFillValue = \"NaN\";\n        if (Number.POSITIVE_INFINITY === fillValue) serializedFillValue = \"Infinity\";\n        if (Number.NEGATIVE_INFINITY === fillValue) serializedFillValue = \"-Infinity\";\n    }\n\n    filters = null;\n\n    const metadata: ZarrArrayMetadata = {\n        zarr_format: 2,\n\n        shape: shape,\n        chunks: chunks as number[],\n\n        dtype: dtype,\n        fill_value: serializedFillValue,\n        order: order,\n        compressor: compressor,\n        filters: filters,\n    };\n    const metaKey = pathToPrefix(path) + ARRAY_META_KEY;\n    await store.setItem(metaKey, JSON.stringify(metadata));\n}\n\n/**\n * \n * Initialize an array store with the given configuration. Note that this is a low-level\n * function and there should be no need to call this directly from user code\n */\nexport async function initArray(\n    store: Store,\n    shape: number | number[],\n    chunks: ChunksArgument,\n    dtype: DtypeString,\n    path: string | null = null,\n    compressor: null | CompressorConfig = null,\n    fillValue: FillType = null,\n    order: Order = \"C\",\n    overwrite = false,\n    chunkStore: null | Store = null,\n    filters: null | Filter[] = null\n) {\n\n    path = normalizeStoragePath(path);\n    await requireParentGroup(store, path, chunkStore, overwrite);\n    await initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n}\n","import { ZarrMetadataType, UserAttributes } from './types';\nimport { ValidStoreType } from './storage/types';\nimport { IS_NODE } from './util';\n\nexport function parseMetadata(\n    s: ValidStoreType | ZarrMetadataType\n): ZarrMetadataType | UserAttributes {\n    // Here we allow that a store may return an already-parsed metadata object,\n    // or a string of JSON that we will parse here. We allow for an already-parsed\n    // object to accommodate a consolidated metadata store, where all the metadata for\n    // all groups and arrays will already have been parsed from JSON.\n    if (typeof s !== 'string') {\n        // tslint:disable-next-line: strict-type-predicates\n        if (IS_NODE && Buffer.isBuffer(s)) {\n            return JSON.parse(s.toString());\n        } else if (s instanceof ArrayBuffer) {\n            const utf8Decoder = new TextDecoder();\n            const bytes = new Uint8Array(s);\n            return JSON.parse(utf8Decoder.decode(bytes));\n        } else {\n            return s;\n        }\n    }\n    return JSON.parse(s);\n}\n","import { createProxy, AsyncMutableMapping, AsyncMutableMappingProxy } from './mutableMapping';\nimport { Store } from './storage/types';\nimport { parseMetadata } from './metadata';\nimport { UserAttributes } from './types';\nimport { PermissionError } from './errors';\n\n/**\n * Class providing access to user attributes on an array or group. Should not be\n * instantiated directly, will be available via the `.attrs` property of an array or\n * group.\n */\nexport class Attributes<M extends UserAttributes> implements AsyncMutableMapping<any> {\n    store: Store;\n    key: string;\n    readOnly: boolean;\n    cache: boolean;\n    private cachedValue: M | null;\n\n    constructor(store: Store, key: string, readOnly: boolean, cache = true) {\n        this.store = store;\n        this.key = key;\n        this.readOnly = readOnly;\n        this.cache = cache;\n        this.cachedValue = null;\n    }\n\n    /**\n     * Retrieve all attributes as a JSON object.\n     */\n    public async asObject() {\n        if (this.cache && this.cachedValue !== null) {\n            return this.cachedValue;\n        }\n        const o = await this.getNoSync();\n        if (this.cache) {\n            this.cachedValue = o;\n        }\n        return o;\n    }\n\n    private async getNoSync(): Promise<M> {\n        try {\n            const data = await this.store.getItem(this.key);\n            // TODO fix typing?\n            return parseMetadata(data) as M;\n        } catch (error) {\n            return {} as M;\n        }\n    }\n\n    private async setNoSync(key: string, value: any) {\n        const d = await this.getNoSync();\n        (d as any)[key] = value;\n        await this.putNoSync(d);\n        return true;\n    }\n\n    private async putNoSync(m: M) {\n        await this.store.setItem(this.key, JSON.stringify(m));\n        if (this.cache) {\n            this.cachedValue = m;\n        }\n    }\n\n    private async delNoSync(key: string): Promise<boolean> {\n        const d = await this.getNoSync();\n        delete (d as any)[key];\n        await this.putNoSync(d);\n        return true;\n    }\n\n    /**\n     * Overwrite all attributes with the provided object in a single operation\n     */\n    async put(d: M) {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.putNoSync(d);\n    }\n\n    async setItem(key: string, value: any): Promise<boolean> {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.setNoSync(key, value);\n    }\n\n    async getItem(key: string) {\n        return ((await this.asObject()) as any)[key];\n    }\n\n    async deleteItem(key: string) {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.delNoSync(key);\n    }\n\n    async containsItem(key: string) {\n        return ((await this.asObject()) as any)[key] !== undefined;\n    }\n\n    proxy(): AsyncMutableMappingProxy<any> {\n        return createProxy(this);\n    }\n}","import { DtypeString } from '../types';\nimport { ValueError } from '../errors';\n\nexport type NestedArrayData = TypedArray | NDNestedArrayData;\nexport type NDNestedArrayData =\n  | TypedArray[]\n  | TypedArray[][]\n  | TypedArray[][][]\n  | TypedArray[][][][]\n  | TypedArray[][][][][]\n  | TypedArray[][][][][][];\n\nexport type TypedArray =\n  | Uint8Array\n  | Int8Array\n  | Uint16Array\n  | Int16Array\n  | Uint32Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\n// ArrayLike<any> & {\n//     BYTES_PER_ELEMENT: number;\n//     set(array: ArrayLike<number>, offset?: number): void;\n//     slice(start?: number, end?: number): TypedArray;\n//     subarray(start?: number, end?: number): TypedArray;\n//     buffer: Buffer | ArrayBuffer;\n//     constructor: TypedArrayConstructor<TypedArray>;\n// };\nexport type TypedArrayConstructor<TypedArray> = {\n  new(): TypedArray;\n  // tslint:disable-next-line: unified-signatures\n  new(size: number): TypedArray;\n  // tslint:disable-next-line: unified-signatures\n  new(buffer: ArrayBuffer): TypedArray;\n  BYTES_PER_ELEMENT: number;\n};\n\nexport const DTYPE_TYPEDARRAY_MAPPING: { [A in DtypeString]: TypedArrayConstructor<TypedArray> } = {\n  '|b': Int8Array,\n  '|B': Uint8Array,\n  '|u1': Uint8Array,\n  '|i1': Int8Array,\n  '<b': Int8Array,\n  '<B': Uint8Array,\n  '<u1': Uint8Array,\n  '<i1': Int8Array,\n  '<u2': Uint16Array,\n  '<i2': Int16Array,\n  '<u4': Uint32Array,\n  '<i4': Int32Array,\n  '<f4': Float32Array,\n  '<f8': Float64Array,\n  '>b': Int8Array,\n  '>B': Uint8Array,\n  '>u1': Uint8Array,\n  '>i1': Int8Array,\n  '>u2': Uint16Array,\n  '>i2': Int16Array,\n  '>u4': Uint32Array,\n  '>i4': Int32Array,\n  '>f4': Float32Array,\n  '>f8': Float64Array\n};\n\n/*\n * Called by NestedArray and RawArray constructors only.\n * We byte-swap the buffer of a store after decoding\n * since TypedArray views are little endian only.\n *\n * This means NestedArrays and RawArrays will always be little endian,\n * unless a numpy-like library comes around and can handle endianess\n * for buffer views.\n */\nexport function getTypedArrayDtypeString(t: TypedArray): DtypeString {\n  // Favour the types below instead of small and big B\n  if (t instanceof Uint8Array) return '|u1';\n  if (t instanceof Int8Array) return '|i1';\n  if (t instanceof Uint16Array) return '<u2';\n  if (t instanceof Int16Array) return '<i2';\n  if (t instanceof Uint32Array) return '<u4';\n  if (t instanceof Int32Array) return '<i4';\n  if (t instanceof Float32Array) return '<f4';\n  if (t instanceof Float64Array) return '<f8';\n  throw new ValueError('Mapping for TypedArray to Dtypestring not known');\n}\n","import { ArraySelection, SliceIndices } from '../core/types';\nimport { ValueError } from '../errors';\nimport { TypedArray, TypedArrayConstructor, NestedArrayData, NDNestedArrayData } from './types';\nimport { normalizeArraySelection, selectionToSliceIndices } from '../core/indexing';\n\n/**\n * Digs down into the dimensions of given array to find the TypedArray and returns its constructor.\n * Better to use sparingly.\n */\nexport function getNestedArrayConstructor<T extends TypedArray>(arr: any): TypedArrayConstructor<T> {\n    // TODO fix typing\n    // tslint:disable-next-line: strict-type-predicates\n    if ((arr as TypedArray).byteLength !== undefined) {\n        return (arr).constructor;\n    }\n    return getNestedArrayConstructor(arr[0]);\n}\n\n/**\n * Returns both the slice result and new output shape\n * @param arr NestedArray to slice\n * @param shape The shape of the NestedArray\n * @param selection\n */\nexport function sliceNestedArray<T extends TypedArray>(arr: NestedArrayData, shape: number[], selection: number | ArraySelection): [NestedArrayData | number, number[]] {\n    // This translates \"...\", \":\", null into a list of slices or integer selections\n    const normalizedSelection = normalizeArraySelection(selection, shape);\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, shape);\n    const outArray = _sliceNestedArray(arr, shape, sliceIndices);\n    return [outArray, outShape];\n}\n\nfunction _sliceNestedArray<T extends TypedArray>(arr: NestedArrayData, shape: number[], selection: (SliceIndices | number)[]): NestedArrayData | number {\n    const currentSlice = selection[0];\n\n    // Is this necessary?\n    // // This is possible when a slice list is passed shorter than the amount of dimensions\n    // // tslint:disable-next-line: strict-type-predicates\n    // if (currentSlice === undefined) {\n    //     return arr.slice();\n    // }\n\n    // When a number is passed that dimension is squeezed\n    if (typeof currentSlice === \"number\") {\n        // Assume already normalized integer selection here.\n        if (shape.length === 1) {\n            return arr[currentSlice];\n        } else {\n            return _sliceNestedArray(arr[currentSlice] as NestedArrayData, shape.slice(1), selection.slice(1));\n        }\n    }\n    const [from, to, step, outputSize] = currentSlice;\n\n    if (outputSize === 0) {\n        return new (getNestedArrayConstructor(arr))(0);\n    }\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            return (arr as TypedArray).slice(from, to);\n        }\n\n        const newArrData = new (arr.constructor as TypedArrayConstructor<T>)(outputSize);\n        for (let i = 0; i < outputSize; i++) {\n            newArrData[i] = (arr as TypedArray)[from + i * step];\n        }\n        return newArrData;\n    }\n\n    let newArr = new Array(outputSize);\n\n    for (let i = 0; i < outputSize; i++) {\n        newArr[i] = _sliceNestedArray(arr[from + i * step] as NestedArrayData, shape.slice(1), selection.slice(1));\n    }\n\n    // This is necessary to ensure that the return value is a NestedArray if the last dimension is squeezed\n    // e.g. shape [2,1] with slice [:, 0] would otherwise result in a list of numbers instead of a valid NestedArray\n    if (outputSize > 0 && typeof newArr[0] === \"number\") {\n        const typedArrayConstructor = (arr[0] as TypedArray).constructor;\n        newArr = (typedArrayConstructor as any).from(newArr);\n    }\n\n    return newArr;\n}\n\n\n\n\nexport function setNestedArrayToScalar<T extends TypedArray>(dstArr: NestedArrayData, value: number, destShape: number[], selection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(selection, destShape, true);\n\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n    const [sliceIndices, _outShape] = selectionToSliceIndices(normalizedSelection, destShape) as [SliceIndices[], number[]];\n    _setNestedArrayToScalar(dstArr, value, destShape, sliceIndices);\n}\n\nexport function setNestedArray<T extends TypedArray>(dstArr: NestedArrayData, sourceArr: NestedArrayData, destShape: number[], sourceShape: number[], selection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(selection, destShape, false);\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, destShape);\n\n    // TODO: replace with non stringify equality check\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n        throw new ValueError(`Shape mismatch in target and source NestedArray: ${outShape} and ${sourceShape}`);\n    }\n\n    _setNestedArray(dstArr, sourceArr, destShape, sliceIndices);\n}\n\n\nfunction _setNestedArray<T extends TypedArray>(dstArr: NestedArrayData, sourceArr: NestedArrayData | number, shape: number[], selection: (SliceIndices | number)[]) {\n\n    const currentSlice = selection[0];\n\n    if (typeof sourceArr === \"number\") {\n        _setNestedArrayToScalar(dstArr, sourceArr, shape, selection.map(x => typeof x === \"number\" ? [x, x + 1, 1, 1] : x));\n        return;\n    }\n\n    // This dimension is squeezed.\n    if (typeof currentSlice === \"number\") {\n        _setNestedArray((dstArr as NDNestedArrayData)[currentSlice], sourceArr, shape.slice(1), selection.slice(1));\n        return;\n    }\n\n    const [from, _to, step, outputSize] = currentSlice;\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            (dstArr as TypedArray).set(sourceArr as TypedArray, from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[from + i * step] = (sourceArr)[i];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setNestedArray((dstArr as NDNestedArrayData)[from + i * step], (sourceArr as NDNestedArrayData)[i], shape.slice(1), selection.slice(1));\n    }\n}\n\nfunction _setNestedArrayToScalar<T extends TypedArray>(dstArr: NestedArrayData, value: number, shape: number[], selection: SliceIndices[]) {\n    const currentSlice = selection[0];\n\n    const [from, to, step, outputSize] = currentSlice;\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            (dstArr as TypedArray).fill(value, from, to);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[from + i * step] = value;\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setNestedArrayToScalar((dstArr as NDNestedArrayData)[from + i * step], value, shape.slice(1), selection.slice(1));\n    }\n}\n\nexport function flattenNestedArray(arr: NestedArrayData, shape: number[], constr?: TypedArrayConstructor<TypedArray>): TypedArray {\n    if (constr === undefined) {\n        constr = getNestedArrayConstructor(arr);\n    }\n    const size = shape.reduce((x, y) => x * y, 1);\n    const outArr = new constr(size);\n\n    _flattenNestedArray(arr, shape, outArr, 0);\n\n    return outArr;\n}\n\nfunction _flattenNestedArray(arr: NestedArrayData, shape: number[], outArr: TypedArray, offset: number) {\n    if (shape.length === 1) {\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\n        // We just slice set the array directly from one level above to save some function calls.\n        outArr.set((arr as TypedArray), offset);\n        return;\n    }\n\n    if (shape.length === 2) {\n        for (let i = 0; i < shape[0]; i++) {\n            outArr.set((arr as TypedArray[])[i], offset + shape[1] * i);\n        }\n        return arr;\n    }\n\n    const nextShape = shape.slice(1);\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n    const mult = nextShape.reduce((x, y) => x * y, 1);\n\n    for (let i = 0; i < shape[0]; i++) {\n        _flattenNestedArray((arr as NDNestedArrayData)[i], nextShape, outArr, offset + mult * i);\n    }\n    return arr;\n}\n","import { DtypeString } from '../types';\nimport { NestedArrayData, TypedArray, TypedArrayConstructor, DTYPE_TYPEDARRAY_MAPPING, getTypedArrayDtypeString } from './types';\nimport { ArraySelection, Slice } from '../core/types';\nimport { slice } from '../core/slice';\nimport { ValueError } from '../errors';\nimport { normalizeShape, IS_NODE } from '../util';\nimport { setNestedArray, setNestedArrayToScalar, flattenNestedArray, sliceNestedArray } from './ops';\n\nexport class NestedArray<T extends TypedArray> {\n    dtype: DtypeString;\n    shape: number[];\n    data: NestedArrayData;\n\n    constructor(data: TypedArray, shape?: number | number[], dtype?: DtypeString)\n    constructor(data: Buffer | ArrayBuffer | NestedArrayData | null, shape: number | number[], dtype: DtypeString)\n    constructor(data: Buffer | ArrayBuffer | NestedArrayData | TypedArray | null, shape?: number | number[], dtype?: DtypeString) {\n        const dataIsTypedArray = data !== null && !!(data as TypedArray).BYTES_PER_ELEMENT;\n\n        if (shape === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n            }\n            shape = [(data as TypedArray).length];\n        }\n\n        if (dtype === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n            }\n            dtype = getTypedArrayDtypeString(data as TypedArray);\n        }\n\n        shape = normalizeShape(shape);\n        this.shape = shape;\n        this.dtype = dtype;\n\n        if (dataIsTypedArray && shape.length !== 1) {\n            data = (data as TypedArray).buffer;\n        }\n\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n        if (this.shape.length === 0) {\n            this.data = new DTYPE_TYPEDARRAY_MAPPING[dtype](1);\n        }\n        else if (\n            // tslint:disable-next-line: strict-type-predicates\n            (IS_NODE && Buffer.isBuffer(data))\n            || data instanceof ArrayBuffer\n            || data === null\n            || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n        ) {\n            // Create from ArrayBuffer or Buffer\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n            if (data === null) {\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n            }\n\n            const numDataElements = (data as ArrayBuffer).byteLength / parseInt(dtype[dtype.length - 1], 10);\n            if (numShapeElements !== numDataElements) {\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n            }\n            const typeConstructor: TypedArrayConstructor<TypedArray> = DTYPE_TYPEDARRAY_MAPPING[dtype];\n            this.data = createNestedArray((data as ArrayBuffer), typeConstructor, shape);\n        } else {\n            this.data = data;\n        }\n    }\n\n    public get(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[]): NestedArray<T>;\n    public get(selection: ArraySelection): NestedArray<T> | number;\n    public get(selection: ArraySelection): NestedArray<T> | number {\n        const [sliceResult, outShape] = sliceNestedArray(this.data, this.shape, selection);\n        if (outShape.length === 0) {\n            return sliceResult as number;\n        } else {\n            return new NestedArray(sliceResult as NestedArrayData, outShape, this.dtype);\n        }\n    }\n\n    public set(selection: ArraySelection = null, value: NestedArray<T> | number) {\n        if (selection === null) {\n            selection = [slice(null)];\n        }\n        if (typeof value === \"number\") {\n            if (this.shape.length === 0) {\n                // Zero dimension array..\n                this.data[0] = value;\n            } else {\n                setNestedArrayToScalar(this.data, value, this.shape, selection);\n            }\n        } else {\n            setNestedArray(this.data, value.data, this.shape, value.shape, selection);\n        }\n    }\n\n    public flatten(): T {\n        if (this.shape.length === 1) {\n            return this.data as T;\n        }\n        return flattenNestedArray(this.data, this.shape, DTYPE_TYPEDARRAY_MAPPING[this.dtype]) as T;\n    }\n\n    /**\n     * Currently only supports a single integer as the size, TODO: support start, stop, step.\n     */\n    public static arange(size: number, dtype: DtypeString = \"<i4\"): NestedArray<TypedArray> {\n        const constr = DTYPE_TYPEDARRAY_MAPPING[dtype];\n        const data = rangeTypedArray([size], constr);\n        return new NestedArray(data, [size], dtype);\n    }\n}\n\n\n\n/**\n * Creates a TypedArray with values 0 through N where N is the product of the shape.\n */\nexport function rangeTypedArray<T extends TypedArray>(shape: number[], tContructor: TypedArrayConstructor<T>) {\n    const size = shape.reduce((x, y) => x * y, 1);\n    const data = new tContructor(size);\n    data.set([...Array(size).keys()]); // Sets range 0,1,2,3,4,5\n    return data;\n}\n\n/**\n * Creates multi-dimensional (rank > 1) array given input data and shape recursively.\n * What it does is create a Array<Array<...<Array<Uint8Array>>> or some other typed array.\n * This is for internal use, there should be no need to call this from user code.\n * @param data a buffer containing the data for this array.\n * @param t constructor for the datatype of choice\n * @param shape list of numbers describing the size in each dimension\n * @param offset in bytes for this dimension\n */\nexport function createNestedArray<T extends TypedArray>(data: Buffer | ArrayBuffer, t: TypedArrayConstructor<T>, shape: number[], offset = 0): NestedArrayData {\n    if (shape.length === 1) {\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\n        // We just slice set the array directly from one level above to save some function calls.\n        return new t(data.slice(offset, offset + shape[0] * t.BYTES_PER_ELEMENT));\n    }\n\n    const arr = new Array<any>(shape[0]);\n    if (shape.length === 2) {\n        for (let i = 0; i < shape[0]; i++) {\n            arr[i] = new t(data.slice(offset + shape[1] * i * t.BYTES_PER_ELEMENT, offset + shape[1] * (i + 1) * t.BYTES_PER_ELEMENT));\n        }\n        return arr;\n    }\n\n    const nextShape = shape.slice(1);\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n    const mult = nextShape.reduce((x, y) => x * y, 1);\n\n    for (let i = 0; i < shape[0]; i++) {\n        arr[i] = createNestedArray(data, t, nextShape, offset + mult * i * t.BYTES_PER_ELEMENT);\n    }\n    return arr;\n}\n","import { ArraySelection, SliceIndices } from '../core/types';\nimport { normalizeArraySelection, selectionToSliceIndices } from '../core/indexing';\nimport { ValueError } from '../errors';\nimport { TypedArray } from '../nestedArray/types';\n\nexport function setRawArrayToScalar(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, value: number) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(dstSelection, dstShape, true);\n    const [sliceIndices] = selectionToSliceIndices(normalizedSelection, dstShape);\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n    _setRawArrayToScalar(value, dstArr, dstStrides, sliceIndices as SliceIndices[]);\n}\n\nexport function setRawArray(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, sourceArr: TypedArray, sourceStrides: number[], sourceShape: number[]): void {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, false);\n    const [dstSliceIndices, outShape] = selectionToSliceIndices(normalizedDstSelection, dstShape);\n\n    // TODO: replace with non stringify equality check\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n        throw new ValueError(`Shape mismatch in target and source RawArray: ${outShape} and ${sourceShape}`);\n    }\n\n    _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides);\n}\n\nexport function setRawArrayFromChunkItem(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, sourceArr: TypedArray, sourceStrides: number[], sourceShape: number[], sourceSelection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, true);\n    // Above we force the results to be dstSliceIndices only, without integer selections making this cast is safe.\n    const [dstSliceIndices] = selectionToSliceIndices(normalizedDstSelection, dstShape);\n\n    const normalizedSourceSelection = normalizeArraySelection(sourceSelection, sourceShape, false);\n    const [sourceSliceIndicies] = selectionToSliceIndices(normalizedSourceSelection, sourceShape);\n\n    // TODO check to ensure chunk and dest selection are same shape?\n    // As is, this only gets called in ZarrArray.getRaw where this condition should be ensured, and check might hinder performance.\n\n    _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices as SliceIndices[], sourceArr, sourceStrides, sourceSliceIndicies);\n}\n\nfunction _setRawArrayToScalar(value: number, dstArr: TypedArray, dstStrides: number[], dstSliceIndices: SliceIndices[]) {\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n\n    const [from, _to, step, outputSize] = currentDstSlice;\n\n    if (dstStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1) {\n            dstArr.fill(value, from, from + outputSize);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = value;\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setRawArrayToScalar(\n            value,\n            dstArr.subarray(currentDstStride * (from + (step * i))),\n            nextDstStrides,\n            nextDstSliceIndices,\n        );\n    }\n}\n\nfunction _setRawArray(dstArr: TypedArray, dstStrides: number[], dstSliceIndices: (number | SliceIndices)[], sourceArr: TypedArray, sourceStrides: number[]) {\n    if (dstSliceIndices.length === 0) {\n        dstArr.set(sourceArr);\n        return;\n    }\n\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n\n    // This dimension is squeezed.\n    if (typeof currentDstSlice === \"number\") {\n        _setRawArray(\n            dstArr.subarray(currentDstSlice * currentDstStride),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr,\n            sourceStrides\n        );\n        return;\n    }\n\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\n    const [from, _to, step, outputSize] = currentDstSlice;\n\n    if (dstStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1 && currentSourceStride === 1) {\n            dstArr.set(sourceArr.subarray(0, outputSize), from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * i];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        // Apply strides as above, using both destination and source-specific strides.\n        _setRawArray(\n            dstArr.subarray(currentDstStride * (from + (i * step))),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr.subarray(currentSourceStride * i),\n            nextSourceStrides\n        );\n    }\n}\n\nfunction _setRawArrayFromChunkItem(dstArr: TypedArray, dstStrides: number[], dstSliceIndices: SliceIndices[], sourceArr: TypedArray, sourceStrides: number[], sourceSliceIndices: (SliceIndices | number)[]) {\n    if (sourceSliceIndices.length === 0) {\n        // Case when last source dimension is squeezed\n        dstArr.set(sourceArr.subarray(0, dstArr.length));\n        return;\n    }\n\n    // Get current indicies and strides for both destination and source arrays\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentSourceSlice, ...nextSourceSliceIndices] = sourceSliceIndices;\n\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\n\n    // This source dimension is squeezed\n    if (typeof currentSourceSlice === \"number\") {\n        /*\n        Sets dimension offset for squeezed dimension.\n\n        Ex. if 0th dimension is squeezed to 2nd index (numpy : arr[2,i])\n\n            sourceArr[stride[0]* 2 + i] --> sourceArr.subarray(stride[0] * 2)[i] (sourceArr[i] in next call)\n\n        Thus, subsequent squeezed dims are appended to the source offset.\n        */\n        _setRawArrayFromChunkItem(\n            // Don't update destination offset/slices, just source\n            dstArr, dstStrides, dstSliceIndices,\n            sourceArr.subarray(currentSourceStride * currentSourceSlice),\n            nextSourceStrides,\n            nextSourceSliceIndices,\n        );\n        return;\n    }\n\n    const [from, _to, step, outputSize] = currentDstSlice; // just need start and size\n    const [sfrom, _sto, sstep, _soutputSize] = currentSourceSlice; // Will always be subset of dst, so don't need output size just start\n\n    if (dstStrides.length === 1 && sourceStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1 && sstep === 1 && currentSourceStride === 1) {\n            dstArr.set(sourceArr.subarray(sfrom, sfrom + outputSize), from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * (sfrom + (sstep * i))];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        // Apply strides as above, using both destination and source-specific strides.\n        _setRawArrayFromChunkItem(\n            dstArr.subarray(currentDstStride * (from + (i * step))),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr.subarray(currentSourceStride * (sfrom + (i * sstep))),\n            nextSourceStrides,\n            nextSourceSliceIndices,\n        );\n    }\n}\n","import { DtypeString } from '../types';\nimport { ArraySelection } from '../core/types';\nimport { slice } from '../core/slice';\nimport { ValueError } from '../errors';\nimport { normalizeShape, IS_NODE, getStrides } from '../util';\nimport { TypedArray, DTYPE_TYPEDARRAY_MAPPING, getTypedArrayDtypeString, TypedArrayConstructor } from '../nestedArray/types';\nimport { setRawArrayFromChunkItem, setRawArrayToScalar, setRawArray } from './ops';\n\nexport class RawArray {\n    dtype: DtypeString;\n    shape: number[];\n    strides: number[];\n    data: TypedArray;\n\n    constructor(data: TypedArray, shape?: number | number[], dtype?: DtypeString, strides?: number[])\n    constructor(data: Buffer | ArrayBuffer | null, shape?: number | number[], dtype?: DtypeString, strides?: number[])\n    constructor(data: Buffer | ArrayBuffer | TypedArray | null, shape?: number | number[], dtype?: DtypeString, strides?: number[]) {\n        const dataIsTypedArray = data !== null && !!(data as TypedArray).BYTES_PER_ELEMENT;\n\n        if (shape === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n            }\n            shape = [(data as TypedArray).length];\n        }\n        shape = normalizeShape(shape);\n\n        if (dtype === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n            }\n            dtype = getTypedArrayDtypeString(data as TypedArray);\n        }\n\n        if (strides === undefined) {\n            strides = getStrides(shape);\n        }\n\n        this.shape = shape;\n        this.dtype = dtype;\n        this.strides = strides;\n\n        if (dataIsTypedArray && shape.length !== 1) {\n            data = (data as TypedArray).buffer;\n        }\n\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n        if (this.shape.length === 0) {\n            this.data = new DTYPE_TYPEDARRAY_MAPPING[dtype](1);\n        } else if (\n            // tslint:disable-next-line: strict-type-predicates\n            (IS_NODE && Buffer.isBuffer(data))\n            || data instanceof ArrayBuffer\n            || data === null\n            || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n        ) {\n            // Create from ArrayBuffer or Buffer\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n            if (data === null) {\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n            }\n\n            const numDataElements = (data as ArrayBuffer).byteLength / parseInt(dtype[dtype.length - 1], 10);\n            if (numShapeElements !== numDataElements) {\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n            }\n            const typeConstructor: TypedArrayConstructor<TypedArray> = DTYPE_TYPEDARRAY_MAPPING[dtype];\n            this.data = new typeConstructor(data as ArrayBuffer);\n        } else {\n            this.data = data;\n        }\n    }\n\n    public set(selection: ArraySelection, value: RawArray | number): void;\n    public set(selection: ArraySelection, chunk: RawArray, chunkSelection: ArraySelection): void;\n    public set(selection: ArraySelection = null, value: RawArray | number, chunkSelection?: ArraySelection) {\n        if (selection === null) {\n            selection = [slice(null)];\n        }\n        if (typeof value === \"number\") {\n            if (this.shape.length === 0) {\n                // Zero dimension array..\n                this.data[0] = value;\n            } else {\n                setRawArrayToScalar(this.data, this.strides, this.shape, selection, value);\n            }\n        } else if (value instanceof RawArray && chunkSelection) {\n            // Copy directly from decoded chunk to destination array\n            setRawArrayFromChunkItem(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape, chunkSelection);\n        } else {\n            setRawArray(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape);\n        }\n    }\n}\n\n\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","'use strict';\nmodule.exports = (promise, onFinally) => {\n\tonFinally = onFinally || (() => {});\n\n\treturn promise.then(\n\t\tval => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => val),\n\t\terr => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => {\n\t\t\tthrow err;\n\t\t})\n\t);\n};\n","'use strict';\n\nconst pFinally = require('p-finally');\n\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t}\n\n\tif (milliseconds === Infinity) {\n\t\tresolve(promise);\n\t\treturn;\n\t}\n\n\tconst timer = setTimeout(() => {\n\t\tif (typeof fallback === 'function') {\n\t\t\ttry {\n\t\t\t\tresolve(fallback());\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\tif (typeof promise.cancel === 'function') {\n\t\t\tpromise.cancel();\n\t\t}\n\n\t\treject(timeoutError);\n\t}, milliseconds);\n\n\t// TODO: Use native `finally` keyword when targeting Node.js 10\n\tpFinally(\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tpromise.then(resolve, reject),\n\t\t() => {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t);\n});\n\nmodule.exports = pTimeout;\n// TODO: Remove this for the next major release\nmodule.exports.default = pTimeout;\n\nmodule.exports.TimeoutError = TimeoutError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = (count / 2) | 0;\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\nexports.default = lowerBound;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lower_bound_1 = require(\"./lower-bound\");\nclass PriorityQueue {\n    constructor() {\n        this._queue = [];\n    }\n    enqueue(run, options) {\n        options = Object.assign({ priority: 0 }, options);\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item && item.run;\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\nexports.default = PriorityQueue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.default.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options\n        // TODO: Remove this `as`.\n        );\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                this.emit('active');\n                this._queue.dequeue()();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n}\nexports.default = PQueue;\n","import { Store, ValidStoreType } from \"../storage/types\";\n\nimport { containsGroup, pathToPrefix } from '../storage/index';\nimport { normalizeStoragePath, isTotalSlice, arrayEquals1D, byteSwap, byteSwapInplace } from '../util';\nimport { ZarrArrayMetadata, UserAttributes, FillType } from '../types';\nimport { ARRAY_META_KEY, ATTRS_META_KEY } from '../names';\nimport { Attributes } from \"../attributes\";\nimport { parseMetadata } from \"../metadata\";\nimport { ArraySelection, DimensionSelection, Indexer, Slice, ChunkProjection } from \"./types\";\nimport { BasicIndexer, isContiguousSelection, normalizeIntegerSelection } from './indexing';\nimport { NestedArray } from \"../nestedArray\";\nimport { RawArray } from \"../rawArray\";\nimport { TypedArray, DTYPE_TYPEDARRAY_MAPPING } from '../nestedArray/types';\nimport { ValueError, PermissionError, BoundsCheckError, ContainsGroupError, isKeyError } from '../errors';\nimport { getCodec } from \"../compression/registry\";\n\n\nimport type { Codec } from 'numcodecs';\nimport PQueue from 'p-queue';\n\nexport interface GetOptions {\n  concurrencyLimit?: number;\n  progressCallback?: (progressUpdate: {\n    progress: number;\n    queueSize: number;\n  }) => void;\n}\n\nexport interface SetOptions {\n  concurrencyLimit?: number;\n  progressCallback?: (progressUpdate: {\n    progress: number;\n    queueSize: number;\n  }) => void;\n}\n\nexport interface GetRawChunkOptions<O> {\n  storeOptions: O;\n}\n\nexport class ZarrArray {\n\n  public store: Store;\n  private compressor: Promise<Codec> | null;\n\n  private _chunkStore: Store | null;\n  /**\n   * A `Store` providing the underlying storage for array chunks.\n   */\n  public get chunkStore(): Store {\n    if (this._chunkStore) {\n      return this._chunkStore;\n    }\n    return this.store;\n  }\n  public path: string;\n  public keyPrefix: string;\n  public readOnly: boolean;\n  public cacheMetadata: boolean;\n  public cacheAttrs: boolean;\n  public meta: ZarrArrayMetadata;\n  public attrs: Attributes<UserAttributes>;\n\n  /**\n   * Array name following h5py convention.\n   */\n  public get name(): string | null {\n    if (this.path.length > 0) {\n      if (this.path[0] !== \"/\") {\n        return \"/\" + this.path;\n      }\n      return this.path;\n    }\n    return null;\n  }\n\n  /**\n   * Final component of name.\n   */\n  public get basename(): string | null {\n    const name = this.name;\n    if (name === null) {\n      return null;\n    }\n    const parts = name.split(\"/\");\n    return parts[parts.length - 1];\n  }\n\n  /**\n   * \"A list of integers describing the length of each dimension of the array.\n   */\n  public get shape(): number[] {\n    // this.refreshMetadata();\n    return this.meta.shape;\n  }\n\n  /**\n   * A list of integers describing the length of each dimension of a chunk of the array.\n   */\n  public get chunks(): number[] {\n    return this.meta.chunks;\n  }\n\n  /**\n   * Integer describing how many element a chunk contains\n   */\n  private get chunkSize(): number {\n    return this.chunks.reduce((x, y) => x * y, 1);\n  }\n\n  /**\n   *  The NumPy data type.\n   */\n  public get dtype() {\n    return this.meta.dtype;\n  }\n\n  /**\n   *  A value used for uninitialized portions of the array.\n   */\n  public get fillValue(): FillType {\n\n    const fillTypeValue = this.meta.fill_value;\n\n    // TODO extract into function\n    if (fillTypeValue === \"NaN\") {\n      return NaN;\n    } else if (fillTypeValue === \"Infinity\") {\n      return Infinity;\n    } else if (fillTypeValue === \"-Infinity\") {\n      return -Infinity;\n    }\n\n    return this.meta.fill_value as FillType;\n  }\n\n  /**\n   *  Number of dimensions.\n   */\n  public get nDims() {\n    return this.meta.shape.length;\n  }\n\n  /**\n   *  The total number of elements in the array.\n   */\n  public get size() {\n    // this.refreshMetadata()\n    return this.meta.shape.reduce((x, y) => x * y, 1);\n  }\n\n  public get length() {\n    return this.shape[0];\n  }\n\n\n  private get _chunkDataShape() {\n    if (this.shape === []) {\n      return [1];\n    } else {\n      const s = [];\n      for (let i = 0; i < this.shape.length; i++) {\n        s[i] = Math.ceil(this.shape[i] / this.chunks[i]);\n      }\n      return s;\n    }\n  }\n  /**\n   * A tuple of integers describing the number of chunks along each\n   * dimension of the array.\n   */\n  public get chunkDataShape() {\n    // this.refreshMetadata();\n    return this._chunkDataShape;\n  }\n\n  /**\n   * Total number of chunks.\n   */\n  public get numChunks() {\n    // this.refreshMetadata();\n    return this.chunkDataShape.reduce((x, y) => x * y, 1);\n  }\n\n  /**\n   * Instantiate an array from an initialized store.\n   * @param store Array store, already initialized.\n   * @param path Storage path.\n   * @param readOnly True if array should be protected against modification.\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\n   */\n  public static async create(store: Store, path: null | string = null, readOnly = false, chunkStore: Store | null = null, cacheMetadata = true, cacheAttrs = true) {\n    const metadata = await this.loadMetadataForConstructor(store, path);\n    return new ZarrArray(store, path, metadata as ZarrArrayMetadata, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n  }\n\n  private static async loadMetadataForConstructor(store: Store, path: null | string) {\n    try {\n      path = normalizeStoragePath(path);\n      const keyPrefix = pathToPrefix(path);\n      const metaStoreValue = await store.getItem(keyPrefix + ARRAY_META_KEY);\n      return parseMetadata(metaStoreValue);\n    } catch (error) {\n      if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path ?? '');\n      }\n      throw new Error(\"Failed to load metadata for ZarrArray:\" + error.toString());\n    }\n  }\n\n  /**\n   * Instantiate an array from an initialized store.\n   * @param store Array store, already initialized.\n   * @param path Storage path.\n   * @param metadata The initial value for the metadata\n   * @param readOnly True if array should be protected against modification.\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\n   */\n  private constructor(store: Store, path: null | string = null, metadata: ZarrArrayMetadata, readOnly = false, chunkStore: Store | null = null, cacheMetadata = true, cacheAttrs = true) {\n    // N.B., expect at this point store is fully initialized with all\n    // configuration metadata fully specified and normalized\n\n    this.store = store;\n    this._chunkStore = chunkStore;\n    this.path = normalizeStoragePath(path);\n    this.keyPrefix = pathToPrefix(this.path);\n    this.readOnly = readOnly;\n    this.cacheMetadata = cacheMetadata;\n    this.cacheAttrs = cacheAttrs;\n    this.meta = metadata;\n    if (this.meta.compressor !== null) {\n      this.compressor = getCodec(this.meta.compressor);\n    } else {\n      this.compressor = null;\n    }\n\n\n    const attrKey = this.keyPrefix + ATTRS_META_KEY;\n    this.attrs = new Attributes<UserAttributes>(this.store, attrKey, this.readOnly, cacheAttrs);\n  }\n\n  /**\n   * (Re)load metadata from store\n   */\n  public async reloadMetadata() {\n    const metaKey = this.keyPrefix + ARRAY_META_KEY;\n    const metaStoreValue = this.store.getItem(metaKey);\n    this.meta = parseMetadata(await metaStoreValue) as ZarrArrayMetadata;\n    return this.meta;\n  }\n\n  private async refreshMetadata() {\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n  }\n\n  public get(selection?: undefined | Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public get(selection?: ArraySelection, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public get(selection: ArraySelection = null, opts: GetOptions = {}): Promise<NestedArray<TypedArray> | number> {\n    return this.getBasicSelection(selection, false, opts);\n  }\n\n  public getRaw(selection?: undefined | Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], opts?: GetOptions): Promise<RawArray | number>;\n  public getRaw(selection?: ArraySelection, opts?: GetOptions): Promise<RawArray | number>;\n  public getRaw(selection: ArraySelection = null, opts: GetOptions = {}): Promise<RawArray | number> {\n    return this.getBasicSelection(selection, true, opts);\n  }\n\n  // asRaw = false\n  public async getBasicSelection(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], asRaw?: false, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public async getBasicSelection(selection: ArraySelection, asRaw?: false, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  // asRaw = true\n  public async getBasicSelection(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], asRaw?: true, opts?: GetOptions): Promise<RawArray | number>;\n  public async getBasicSelection(selection: ArraySelection, asRaw?: true, opts?: GetOptions): Promise<RawArray | number>;\n\n  public async getBasicSelection(selection: ArraySelection, asRaw = false, { concurrencyLimit = 10, progressCallback }: GetOptions = {}): Promise<NestedArray<TypedArray> | RawArray | number> {\n    // Refresh metadata\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n\n    // Check fields (TODO?)\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      return this.getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback);\n    }\n  }\n\n  private getBasicSelectionND(selection: ArraySelection, asRaw: boolean, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void): Promise<number | NestedArray<TypedArray> | RawArray> {\n    const indexer = new BasicIndexer(selection, this);\n    return this.getSelection(indexer, asRaw, concurrencyLimit, progressCallback);\n  }\n\n  private async getSelection(indexer: BasicIndexer, asRaw: boolean, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void): Promise<number | NestedArray<TypedArray> | RawArray> {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be extracted. Each chunk is processed in turn, extracting the\n    // necessary data and storing into the correct location in the output array.\n\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n\n    // check fields are sensible (TODO?)\n\n    const outDtype = this.dtype;\n    const outShape = indexer.shape;\n    const outSize = indexer.shape.reduce((x, y) => x * y, 1);\n\n    if (asRaw && (outSize === this.chunkSize)) {\n      // Optimization: if output strided array _is_ chunk exactly,\n      // decode directly as new TypedArray and return\n      const itr = indexer.iter();\n      const proj = itr.next(); // ensure there is only one projection\n      if (proj.done === false && itr.next().done === true) {\n        const chunkProjection = proj.value as ChunkProjection;\n        const out = await this.decodeDirectToRawArray(chunkProjection, outShape, outSize);\n        return out;\n      }\n    }\n\n    const out = asRaw\n      ? new RawArray(null, outShape, outDtype)\n      : new NestedArray(null, outShape, outDtype);\n\n    if (outSize === 0) {\n      return out;\n    }\n\n    // create promise queue with concurrency control\n    const queue = new PQueue({ concurrency: concurrencyLimit });\n\n    if (progressCallback) {\n\n      let progress = 0;\n      let queueSize = 0;\n      for (const _ of indexer.iter()) queueSize += 1;\n      progressCallback({ progress: 0, queueSize: queueSize });\n      for (const proj of indexer.iter()) {\n        (async () => {\n          await queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n          progress += 1;\n          progressCallback({ progress: progress, queueSize: queueSize });\n        })();\n      }\n\n    } else {\n      for (const proj of indexer.iter()) {\n        queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n      }\n    }\n\n    // guarantees that all work on queue has finished\n    await queue.onIdle();\n\n    // Return scalar instead of zero-dimensional array.\n    if (out.shape.length === 0) {\n      return out.data[0] as number;\n    }\n\n    return out;\n  }\n\n  /**\n   * Obtain part or whole of a chunk.\n   * @param chunkCoords Indices of the chunk.\n   * @param chunkSelection Location of region within the chunk to extract.\n   * @param out Array to store result in.\n   * @param outSelection Location of region within output array to store results in.\n   * @param dropAxes Axes to squeeze out of the chunk.\n   */\n  private async chunkGetItem<T extends TypedArray>(chunkCoords: number[], chunkSelection: DimensionSelection[], out: NestedArray<T> | RawArray, outSelection: DimensionSelection[], dropAxes: null | number[]) {\n    if (chunkCoords.length !== this._chunkDataShape.length) {\n      throw new ValueError(`Inconsistent shapes: chunkCoordsLength: ${chunkCoords.length}, cDataShapeLength: ${this.chunkDataShape.length}`);\n    }\n\n    const cKey = this.chunkKey(chunkCoords);\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      const decodedChunk = await this.decodeChunk(cdata);\n\n      if (out instanceof NestedArray) {\n\n        if (isContiguousSelection(outSelection) && isTotalSlice(chunkSelection, this.chunks) && !this.meta.filters) {\n          // Optimization: we want the whole chunk, and the destination is\n          // contiguous, so we can decompress directly from the chunk\n          // into the destination array\n\n          // TODO check order\n          // TODO filters..\n          out.set(outSelection, this.toNestedArray<T>(decodedChunk));\n          return;\n        }\n\n        // Decode chunk\n        const chunk = this.toNestedArray(decodedChunk);\n        const tmp = chunk.get(chunkSelection);\n\n        if (dropAxes !== null) {\n          throw new Error(\"Drop axes is not supported yet\");\n        }\n\n        out.set(outSelection, tmp as NestedArray<T>);\n\n      } else {\n        /* RawArray\n        Copies chunk by index directly into output. Doesn't matter if selection is contiguous\n        since store/output are different shapes/strides.\n        */\n        out.set(outSelection, this.chunkBufferToRawArray(decodedChunk), chunkSelection);\n      }\n\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if cKey doesn't exist in store\n        if (this.fillValue !== null) {\n          out.set(outSelection, this.fillValue);\n        }\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  public async getRawChunk<O>(chunkCoords: number[], opts?: GetRawChunkOptions<O>): Promise<RawArray> {\n    if (chunkCoords.length !== this.shape.length) {\n      throw new Error(`Chunk coordinates ${chunkCoords.join(\".\")} do not correspond to shape ${this.shape}.`);\n    }\n    try {\n      for (let i = 0; i < chunkCoords.length; i++) {\n        const dimLength = Math.ceil(this.shape[i] / this.chunks[i]);\n        chunkCoords[i] = normalizeIntegerSelection(chunkCoords[i], dimLength);\n      }\n    } catch (error) {\n      if (error instanceof BoundsCheckError) {\n        throw new BoundsCheckError(`index ${chunkCoords.join(\".\")} is out of bounds for shape: ${this.shape} and chunks ${this.chunks}`);\n      } else {\n        throw error;\n      }\n    }\n    const cKey = this.chunkKey(chunkCoords);\n    const cdata = this.chunkStore.getItem(cKey, opts?.storeOptions);\n    const buffer = await this.decodeChunk(await cdata);\n    const outShape = this.chunks.filter(d => d !== 1); // squeeze chunk dim if 1\n    return new RawArray(buffer, outShape, this.dtype);\n  }\n\n  private chunkKey(chunkCoords: number[]) {\n    return this.keyPrefix + chunkCoords.join(\".\");\n  }\n\n  private ensureByteArray(chunkData: ValidStoreType): Uint8Array {\n    if (typeof chunkData === \"string\") {\n      return new Uint8Array(Buffer.from(chunkData).buffer);\n    }\n    return new Uint8Array(chunkData);\n  }\n\n  private toTypedArray(buffer: Buffer | ArrayBuffer) {\n    return new DTYPE_TYPEDARRAY_MAPPING[this.dtype](buffer);\n  }\n\n  private toNestedArray<T extends TypedArray>(data: ValidStoreType) {\n    const buffer = this.ensureByteArray(data).buffer;\n\n    return new NestedArray<T>(buffer, this.chunks, this.dtype);\n  }\n\n  private async decodeChunk(chunkData: ValidStoreType) {\n    let bytes = this.ensureByteArray(chunkData);\n\n    if (this.compressor !== null) {\n      bytes = await (await this.compressor).decode(bytes);\n    }\n\n    if (this.dtype.includes('>')) {\n      // Need to flip bytes for Javascript TypedArrays\n      // We flip bytes in-place to avoid creating an extra copy of the decoded buffer.\n      byteSwapInplace(this.toTypedArray(bytes.buffer));\n    }\n\n    // TODO filtering etc\n    return bytes.buffer;\n  }\n\n  private chunkBufferToRawArray(buffer: Buffer | ArrayBuffer) {\n    return new RawArray(buffer, this.chunks, this.dtype);\n  }\n\n  private async decodeDirectToRawArray({ chunkCoords }: ChunkProjection, outShape: number[], outSize: number): Promise<RawArray> {\n    const cKey = this.chunkKey(chunkCoords);\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      return new RawArray(await this.decodeChunk(cdata), outShape, this.dtype);\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if item doesn't exist\n        const data = new DTYPE_TYPEDARRAY_MAPPING[this.dtype](outSize);\n        return new RawArray(data.fill(this.fillValue as number), outShape);\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  public async set(selection: ArraySelection = null, value: any, opts: SetOptions = {}) {\n    await this.setBasicSelection(selection, value, opts);\n  }\n\n  public async setBasicSelection(selection: ArraySelection, value: any, { concurrencyLimit = 10, progressCallback }: SetOptions = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"Object is read only\");\n    }\n\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      await this.setBasicSelectionND(selection, value, concurrencyLimit, progressCallback);\n    }\n  }\n\n  private async setBasicSelectionND(selection: ArraySelection, value: any, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void) {\n    const indexer = new BasicIndexer(selection, this);\n    await this.setSelection(indexer, value, concurrencyLimit, progressCallback);\n  }\n\n  private getChunkValue(proj: ChunkProjection, indexer: Indexer, value: number | NestedArray<TypedArray>, selectionShape: number[]): number | NestedArray<TypedArray> {\n    let chunkValue: number | NestedArray<TypedArray>;\n    if (selectionShape === []) {\n      chunkValue = value;\n    } else if (typeof value === \"number\") {\n      chunkValue = value;\n    } else {\n      chunkValue = value.get(proj.outSelection);\n      // tslint:disable-next-line: strict-type-predicates\n      if (indexer.dropAxes !== null) {\n        throw new Error(\"Handling drop axes not supported yet\");\n      }\n    }\n    return chunkValue;\n  }\n\n  private async setSelection(indexer: Indexer, value: number | NestedArray<TypedArray>, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void) {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be replaced. Each chunk is processed in turn, extracting the\n    // necessary data from the value array and storing into the chunk array.\n\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n\n    // TODO? check fields are sensible\n\n    // Determine indices of chunks overlapping the selection\n    const selectionShape = indexer.shape;\n\n    // Check value shape\n    if (selectionShape === []) {\n      // Setting a single value\n    } else if (typeof value === \"number\") {\n      // Setting a scalar value\n    } else if (value instanceof NestedArray) {\n      // TODO: non stringify equality check\n      if (!arrayEquals1D(value.shape, selectionShape)) {\n        throw new ValueError(`Shape mismatch in source NestedArray and set selection: ${value.shape} and ${selectionShape}`);\n      }\n    } else {\n      // TODO support TypedArrays, buffers, etc\n      throw new Error(\"Unknown data type for setting :(\");\n    }\n\n    const queue = new PQueue({ concurrency: concurrencyLimit });\n\n    if (progressCallback) {\n\n      let queueSize = 0;\n      for (const _ of indexer.iter()) queueSize += 1;\n\n      let progress = 0;\n      progressCallback({ progress: 0, queueSize: queueSize });\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n        (async () => {\n          await queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n          progress += 1;\n          progressCallback({ progress: progress, queueSize: queueSize });\n        })();\n      }\n\n    } else {\n\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n        queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n      }\n\n    }\n\n    // guarantees that all work on queue has finished\n    await queue.onIdle();\n  }\n\n  private async chunkSetItem<T extends TypedArray>(chunkCoords: number[], chunkSelection: DimensionSelection[], value: number | NestedArray<TypedArray>) {\n    // Obtain key for chunk storage\n    const chunkKey = this.chunkKey(chunkCoords);\n\n    let chunk: null | TypedArray = null;\n\n    const dtypeConstr = DTYPE_TYPEDARRAY_MAPPING[this.dtype];\n    const chunkSize = this.chunkSize;\n\n    if (isTotalSlice(chunkSelection, this.chunks)) {\n      // Totally replace chunk\n\n      // Optimization: we are completely replacing the chunk, so no need\n      // to access the existing chunk data\n\n      if (typeof value === \"number\") {\n        // TODO get the right type here\n        chunk = new dtypeConstr(chunkSize);\n        chunk.fill(value);\n      } else {\n        chunk = value.flatten();\n      }\n    } else {\n\n      // partially replace the contents of this chunk\n\n      // Existing chunk data\n      let chunkData: TypedArray;\n\n      try {\n        // Chunk is initialized if this does not error\n        const chunkStoreData = await this.chunkStore.getItem(chunkKey);\n        const dBytes = await this.decodeChunk(chunkStoreData);\n        chunkData = this.toTypedArray(dBytes);\n      } catch (error) {\n        if (isKeyError(error)) {\n          // Chunk is not initialized\n          chunkData = new dtypeConstr(chunkSize);\n          if (this.fillValue !== null) {\n            chunkData.fill(this.fillValue);\n          }\n        } else {\n          // Different type of error - rethrow\n          throw error;\n        }\n      }\n\n      const chunkNestedArray = new NestedArray(\n        chunkData,\n        this.chunks,\n        this.dtype,\n      );\n      chunkNestedArray.set(chunkSelection, value);\n      chunk = chunkNestedArray.flatten();\n    }\n    const chunkData = await this.encodeChunk(chunk);\n    this.chunkStore.setItem(chunkKey, chunkData);\n  }\n\n  private async encodeChunk(chunk: TypedArray) {\n    if (this.dtype.includes('>')) {\n      /*\n       * If big endian, flip bytes before applying compression and setting store.\n       *\n       * Here we create a copy (not in-place byteswapping) to avoid flipping the\n       * bytes in the buffers of user-created Raw- and NestedArrays.\n      */\n      chunk = byteSwap(chunk);\n    }\n\n    if (this.compressor !== null) {\n      const bytes = new Uint8Array(chunk.buffer);\n      const cbytes = await (await this.compressor).encode(bytes);\n      return cbytes.buffer;\n    }\n\n    // TODO: filters, etc\n    return chunk.buffer;\n  }\n}","import { SyncStore, ValidStoreType } from \"./types\";\nimport { createProxy, MutableMappingProxy } from \"../mutableMapping\";\nimport { KeyError } from \"../errors\";\n\nexport class MemoryStore<T extends ValidStoreType> implements SyncStore<T> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    root: { [key: string]: any };\n\n    constructor(root = {}) {\n        this.root = root;\n    }\n\n    public proxy(): MutableMappingProxy<T> {\n        return createProxy(this);\n    }\n\n    private getParent(item: string): [any, string] {\n        let parent = this.root;\n        const segments = item.split('/');\n        // find the parent container\n        for (const k of segments.slice(0, segments.length - 1)) {\n            parent = parent[k];\n            if (!parent) {\n                throw Error(item);\n            }\n            // if not isinstance(parent, self.cls):\n            //     raise KeyError(item)\n        }\n        return [parent, segments[segments.length - 1]];\n    }\n\n    private requireParent(item: string): [any, string] {\n        let parent = this.root;\n        const segments = item.split('/');\n\n        // require the parent container\n        for (const k of segments.slice(0, segments.length - 1)) {\n            // TODO: verify correct implementation\n            if (parent[k] === undefined) {\n                parent[k] = {};\n            }\n            parent = parent[k];\n        }\n\n        return [parent, segments[segments.length - 1]];\n    }\n\n    getItem(item: string) {\n        const [parent, key] = this.getParent(item);\n        const value = parent[key];\n        if (value === undefined) {\n            throw new KeyError(item);\n        }\n        return value;\n    }\n\n    setItem(item: string, value: any): boolean {\n        const [parent, key] = this.requireParent(item);\n        parent[key] = value;\n        return true;\n    }\n\n    deleteItem(item: string): boolean {\n        const [parent, key] = this.getParent(item);\n        return delete parent[key];\n    }\n\n    containsItem(item: string): boolean {\n        // TODO: more sane implementation\n        try {\n            return this.getItem(item) !== undefined;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    keys(): string[] {\n        throw new Error(\"Method not implemented.\");\n    }\n\n\n}","import { ValidStoreType, AsyncStore } from './types';\nimport { IS_NODE, joinUrlParts } from '../util';\nimport { KeyError, HTTPError } from '../errors';\n\nenum HTTPMethod {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  PUT = 'PUT',\n}\n\nconst DEFAULT_METHODS = [HTTPMethod.HEAD, HTTPMethod.GET, HTTPMethod.PUT];\n\ninterface HTTPStoreOptions {\n    fetchOptions?: RequestInit;\n    supportedMethods?: HTTPMethod[];\n}\n\nexport class HTTPStore implements AsyncStore<ArrayBuffer> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    public url: string;\n    public fetchOptions: RequestInit;\n    private supportedMethods: Set<HTTPMethod>;\n\n    constructor(url: string, options: HTTPStoreOptions = {}) {\n        this.url = url;\n        const { fetchOptions = {}, supportedMethods = DEFAULT_METHODS } = options;\n        this.fetchOptions = fetchOptions;\n        this.supportedMethods = new Set(supportedMethods);\n    }\n\n    keys(): Promise<string[]> {\n        throw new Error('Method not implemented.');\n    }\n\n    async getItem(item: string, opts?: RequestInit) {\n        const url = joinUrlParts(this.url, item);\n        const value = await fetch(url, { ...this.fetchOptions, ...opts });\n\n        if (value.status === 404) {\n            // Item is not found\n            throw new KeyError(item);\n        } else if (value.status !== 200) {\n            throw new HTTPError(String(value.status));\n        }\n\n        // only decode if 200\n        if (IS_NODE) {\n            return Buffer.from(await value.arrayBuffer());\n        } else {\n            return value.arrayBuffer(); // Browser\n        }\n    }\n\n    async setItem(item: string, value: ValidStoreType): Promise<boolean> {\n        if (!this.supportedMethods.has(HTTPMethod.PUT)) {\n          throw new Error('HTTP PUT no a supported method for store.');\n        }\n        const url = joinUrlParts(this.url, item);\n        if (typeof value === 'string') {\n            value = new TextEncoder().encode(value).buffer;\n        }\n        const set = await fetch(url, { ...this.fetchOptions, method: HTTPMethod.PUT, body: value });\n        return set.status.toString()[0] === '2';\n    }\n\n    deleteItem(_item: string): Promise<boolean> {\n        throw new Error('Method not implemented.');\n    }\n\n    async containsItem(item: string): Promise<boolean> {\n        const url = joinUrlParts(this.url, item);\n        // Just check headers if HEAD method supported\n        const method = this.supportedMethods.has(HTTPMethod.HEAD) ? HTTPMethod.HEAD : HTTPMethod.GET;\n        const value = await fetch(url, { ...this.fetchOptions, method });\n        return value.status === 200;\n    }\n}\n","import { ChunksArgument, DtypeString, CompressorConfig, Order, Filter, FillType, PersistenceMode } from './types';\nimport { Store } from './storage/types';\nimport { ZarrArray } from './core/index';\nimport { MemoryStore } from './storage/memoryStore';\nimport { initArray, containsArray, containsGroup } from './storage/index';\nimport { TypedArray } from './nestedArray/types';\nimport { NestedArray } from './nestedArray/index';\nimport { normalizeStoragePath } from './util';\nimport { ContainsArrayError, ValueError, ArrayNotFoundError, ContainsGroupError } from './errors';\nimport { HTTPStore } from './storage/httpStore';\n\n/**\n * See `create` function for type signature of these values\n */\nexport interface CreateArrayOptionsWithoutShape {\n    chunks?: ChunksArgument;\n    dtype?: DtypeString;\n    compressor?: CompressorConfig | null;\n    fillValue?: FillType;\n    order?: Order;\n    store?: Store;\n    overwrite?: boolean;\n    path?: string;\n    chunkStore?: Store;\n    filters?: Filter[];\n    cacheMetadata?: boolean;\n    cacheAttrs?: boolean;\n    readOnly?: boolean;\n}\n\nexport type CreateArrayOptions = {\n    shape: number | number[];\n    chunks?: ChunksArgument;\n    dtype?: DtypeString;\n    compressor?: CompressorConfig | null;\n    fillValue?: FillType;\n    order?: Order;\n    store?: Store;\n    overwrite?: boolean;\n    path?: string;\n    chunkStore?: Store;\n    filters?: Filter[];\n    cacheMetadata?: boolean;\n    cacheAttrs?: boolean;\n    readOnly?: boolean;\n};\n\n/**\n * \n * @param shape Array shape.\n * @param chunks  Chunk shape. If `true`, will be guessed from `shape` and `dtype`. If\n *      `false`, will be set to `shape`, i.e., single chunk for the whole array.\n *      If an int, the chunk size in each dimension will be given by the value\n *      of `chunks`. Default is `true`.\n * @param dtype NumPy dtype.\n * @param compressor Primary compressor.\n * @param fillValue Default value to use for uninitialized portions of the array.\n * @param order Memory layout to be used within each chunk.\n * @param store Store or path to directory in file system or name of zip file.\n * @param overwrite  If True, delete all pre-existing data in `store` at `path` before creating the array.\n * @param path Path under which array is stored.\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n * @param filters Sequence of filters to use to encode chunk data prior to compression.\n * @param cacheMetadata If `true` (default), array configuration metadata will be cached for the\n *      lifetime of the object. If `false`, array metadata will be reloaded\n *      prior to all data access and modification operations (may incur\n *      overhead depending on storage and data access pattern).\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read\n *      operations. If `false`, user attributes are reloaded from the store prior\n *      to all attribute read operations.\n * @param readOnly `true` if array should be protected against modification, defaults to `false`.\n */\nexport async function create(\n    { shape, chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path, chunkStore, filters, cacheMetadata = true, cacheAttrs = true, readOnly = false }: CreateArrayOptions,\n): Promise<ZarrArray> {\n\n    store = normalizeStoreArgument(store);\n\n    await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n    const z = await ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n\n    return z;\n}\n\n\n/**\n * Create an empty array.\n */\nexport async function empty(shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = null;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with zero being used as the default value for\n * uninitialized portions of the array.\n */\nexport async function zeros(shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = 0;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with one being used as the default value for\n * uninitialized portions of the array.\n */\nexport async function ones(shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = 1;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with `fill_value` being used as the default value for\n * uninitialized portions of the array\n */\nexport async function full(shape: number | number[], fillValue: FillType, opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = fillValue;\n    return create({ shape, ...opts });\n}\n\nexport async function array(data: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts: CreateArrayOptionsWithoutShape = {}) {\n    // TODO: infer chunks?\n\n    let shape = null;\n    if (data instanceof NestedArray) {\n        shape = data.shape;\n        opts.dtype = opts.dtype === undefined ? data.dtype : opts.dtype;\n    } else {\n        shape = data.byteLength;\n        // TODO: infer datatype\n    }\n    // TODO: support TypedArray\n\n    const wasReadOnly = opts.readOnly === undefined ? false : opts.readOnly;\n    opts.readOnly = false;\n\n    const z = await create({ shape, ...opts });\n    await z.set(null, data);\n    z.readOnly = wasReadOnly;\n\n    return z;\n}\n\nexport async function openArray(\n    { shape, mode = \"a\", chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path = null, chunkStore, filters, cacheMetadata = true, cacheAttrs = true }: { shape?: number | number[]; mode?: PersistenceMode; chunks?: ChunksArgument; dtype?: DtypeString; compressor?: CompressorConfig | null; fillValue?: FillType; order?: Order; store?: Store; overwrite?: boolean; path?: string | null; chunkStore?: Store; filters?: Filter[]; cacheMetadata?: boolean; cacheAttrs?: boolean } = {},\n) {\n    store = normalizeStoreArgument(store);\n    if (chunkStore === undefined) {\n        chunkStore = normalizeStoreArgument(store);\n    }\n    path = normalizeStoragePath(path);\n\n    if (mode === \"r\" || mode === \"r+\") {\n        if (!await containsArray(store, path)) {\n            if (await containsGroup(store, path)) {\n                throw new ContainsGroupError(path);\n            }\n            throw new ArrayNotFoundError(path);\n        }\n    } else if (mode === \"w\") {\n\n        if (shape === undefined) {\n            throw new ValueError(\"Shape can not be undefined when creating a new array\");\n        }\n        await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n\n    } else if (mode === \"a\") {\n        if (!await containsArray(store, path)) {\n            if (await containsGroup(store, path)) {\n                throw new ContainsGroupError(path);\n            }\n            if (shape === undefined) {\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\n            }\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n        }\n    } else if (mode === \"w-\" || (mode as any) === \"x\") {\n        if (await containsArray(store, path)) {\n            throw new ContainsArrayError(path);\n        } else if (await containsGroup(store, path)) {\n            throw new ContainsGroupError(path);\n        } else {\n            if (shape === undefined) {\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\n            }\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n        }\n    } else {\n        throw new ValueError(`Invalid mode argument: ${mode}`);\n    }\n\n    const readOnly = mode === \"r\";\n    return ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n}\n\n\nexport function normalizeStoreArgument(store?: Store | string): Store {\n    if (store === undefined) {\n        return new MemoryStore();\n    } else if (typeof store === \"string\") {\n        return new HTTPStore(store);\n    }\n    return store;\n}","import { createProxy, AsyncMutableMapping, AsyncMutableMappingProxy } from './mutableMapping';\nimport { Store, } from './storage/types';\nimport { normalizeStoragePath } from './util';\nimport { containsArray, pathToPrefix, containsGroup, initGroup } from './storage/index';\nimport { ContainsArrayError, GroupNotFoundError, PermissionError, KeyError, ValueError, ContainsGroupError } from './errors';\nimport { ZarrGroupMetadata, UserAttributes, PersistenceMode } from './types';\nimport { GROUP_META_KEY, ATTRS_META_KEY } from './names';\nimport { parseMetadata } from './metadata';\nimport { Attributes } from './attributes';\nimport { array, empty, zeros, ones, full, create, normalizeStoreArgument, CreateArrayOptionsWithoutShape } from './creation';\nimport { NestedArray } from './nestedArray';\nimport { TypedArray } from './nestedArray/types';\nimport { ZarrArray } from './core';\n\n\nexport class Group implements AsyncMutableMapping<Group | ZarrArray> {\n    /**\n     * A `Store` providing the underlying storage for the group.\n     */\n    public store: Store;\n\n    /**\n     * Storage path.\n     */\n    public path: string;\n\n    /**\n     * Group name following h5py convention.\n     */\n    public get name(): string {\n        if (this.path.length > 0) {\n            if (this.path[0] !== \"/\") {\n                return \"/\" + this.path;\n            }\n            return this.path;\n        }\n        return \"/\";\n    }\n\n    /**\n     * Final component of name.\n     */\n    public get basename(): string {\n        const parts = this.name.split(\"/\");\n        return parts[parts.length - 1];\n    }\n\n    /**\n     * An object containing user-defined attributes. Note that\n     * attribute values are stored as a JSON string in a store.\n     */\n    public attrs: Attributes<UserAttributes>;\n\n\n    private _chunkStore: Store | null;\n    /**\n     * A `Store` providing the underlying storage for array chunks.\n     */\n    public get chunkStore(): Store {\n        if (this._chunkStore) {\n            return this._chunkStore;\n        }\n        return this.store;\n    }\n\n    private keyPrefix: string;\n    public readOnly: boolean;\n    private meta: ZarrGroupMetadata;\n\n    public static async create(store: Store, path: string | null = null, readOnly = false, chunkStore: Store | null = null, cacheAttrs = true) {\n        const metadata = await this.loadMetadataForConstructor(store, path);\n        return new Group(store, path, metadata as ZarrGroupMetadata, readOnly, chunkStore, cacheAttrs);\n    }\n\n    private static async loadMetadataForConstructor(store: Store, path: null | string) {\n        path = normalizeStoragePath(path);\n        const keyPrefix = pathToPrefix(path);\n        try {\n            const metaStoreValue = await store.getItem(keyPrefix + GROUP_META_KEY);\n            return parseMetadata(metaStoreValue);\n        } catch (error) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            throw new GroupNotFoundError(path);\n        }\n    }\n\n    private constructor(store: Store, path: string | null = null, metadata: ZarrGroupMetadata, readOnly = false, chunkStore: Store | null = null, cacheAttrs = true) {\n        this.store = store;\n        this._chunkStore = chunkStore;\n        this.path = normalizeStoragePath(path);\n        this.keyPrefix = pathToPrefix(this.path);\n        this.readOnly = readOnly;\n        this.meta = metadata;\n\n        // Initialize attributes\n        const attrKey = this.keyPrefix + ATTRS_META_KEY;\n        this.attrs = new Attributes<UserAttributes>(this.store, attrKey, this.readOnly, cacheAttrs);\n    }\n\n    private itemPath(item: string | null) {\n        const absolute = typeof item === \"string\" && item.length > 0 && item[0] === '/';\n        const path = normalizeStoragePath(item);\n        // Absolute path\n        if (!absolute && this.path.length > 0) {\n            return this.keyPrefix + path;\n        }\n        return path;\n    }\n\n    /**\n     * Create a sub-group.\n     */\n    public async createGroup(name: string, overwrite = false) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        const path = this.itemPath(name);\n        await initGroup(this.store, path, this._chunkStore, overwrite);\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n    }\n\n    /**\n     * Obtain a sub-group, creating one if it doesn't exist.\n     */\n    public async requireGroup(name: string, overwrite = false) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        const path = this.itemPath(name);\n        if (!await containsGroup(this.store, path)) {\n            await initGroup(this.store, path, this._chunkStore, overwrite);\n        }\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n    }\n\n    private getOptsForArrayCreation(name: string, opts: CreateArrayOptionsWithoutShape = {}) {\n        const path = this.itemPath(name);\n        opts.path = path;\n\n        if (opts.cacheAttrs === undefined) {\n            opts.cacheAttrs = this.attrs.cache;\n        }\n        opts.store = this.store;\n        opts.chunkStore = this.chunkStore;\n        return opts;\n    }\n\n    /**\n     * Creates an array\n     */\n    public array(name: string, data: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts?: CreateArrayOptionsWithoutShape, overwrite?: boolean) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n        opts.overwrite = overwrite === undefined ? opts.overwrite : overwrite;\n\n        return array(data, opts);\n    }\n\n    public empty(name: string, shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return empty(shape, opts);\n    }\n\n    public zeros(name: string, shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return zeros(shape, opts);\n    }\n\n    public ones(name: string, shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return ones(shape, opts);\n    }\n\n    public full(name: string, shape: number | number[], fillValue: number | null, opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return full(shape, fillValue, opts);\n    }\n\n    public createDataset(name: string, shape?: number | number[], data?: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts?: CreateArrayOptionsWithoutShape) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        let z: Promise<ZarrArray>;\n        if (data === undefined) {\n            if (shape === undefined) {\n                throw new ValueError(\"Shape must be set if no data is passed to CreateDataset\");\n            }\n            z = create({ shape, ...opts });\n        } else {\n            z = array(data, opts);\n        }\n        return z;\n    }\n\n    async getItem(item: string) {\n        const path = this.itemPath(item);\n        if (await containsArray(this.store, path)) {\n            return ZarrArray.create(this.store, path, this.readOnly, this.chunkStore, undefined, this.attrs.cache);\n        } else if (await containsGroup(this.store, path)) {\n            return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n        }\n        throw new KeyError(item);\n    }\n\n    async setItem(item: string, value: any) {\n        await this.array(item, value, {}, true);\n        return true;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async deleteItem(_item: string): Promise<boolean> {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        throw new Error(\"Method not implemented.\");\n    }\n\n    async containsItem(item: string) {\n        const path = this.itemPath(item);\n        return await containsArray(this.store, path) || containsGroup(this.store, path);\n    }\n\n    proxy(): AsyncMutableMappingProxy<Group> {\n        return createProxy(this);\n    }\n}\n\n/**\n * Create a group.\n * @param store Store or path to directory in file system.\n * @param path Group path within store.\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n * @param overwrite If `true`, delete any pre-existing data in `store` at `path` before creating the group.\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations.\n *   If `false`, user attributes are reloaded from the store prior to all attribute read operations.\n */\nexport async function group(store?: Store | string, path: string | null = null, chunkStore?: Store, overwrite = false, cacheAttrs = true) {\n    store = normalizeStoreArgument(store);\n    path = normalizeStoragePath(path);\n\n    if (overwrite || await containsGroup(store)) {\n        await initGroup(store, path, chunkStore, overwrite);\n    }\n\n    return Group.create(store, path, false, chunkStore, cacheAttrs);\n}\n\n/**\n * Open a group using file-mode-like semantics.\n * @param store Store or path to directory in file system or name of zip file.\n * @param path Group path within store.\n * @param mode Persistence mode, see `PersistenceMode` type.\n * @param chunkStore Store or path to directory in file system or name of zip file.\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations\n *   If False, user attributes are reloaded from the store prior to all attribute read operations.\n *\n */\nexport async function openGroup(store?: Store | string, path: string | null = null, mode: PersistenceMode = \"a\", chunkStore?: Store, cacheAttrs = true) {\n    store = normalizeStoreArgument(store);\n    if (chunkStore !== undefined) {\n        chunkStore = normalizeStoreArgument(store);\n    }\n    path = normalizeStoragePath(path);\n\n    if (mode === \"r\" || mode === \"r+\") {\n        if (!await containsGroup(store, path)) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            throw new GroupNotFoundError(path);\n        }\n    } else if (mode === \"w\") {\n        await initGroup(store, path, chunkStore, true);\n    } else if (mode === \"a\") {\n        if (!await containsGroup(store, path)) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            await initGroup(store, path, chunkStore);\n        }\n    } else if (mode === \"w-\" || (mode as any) === \"x\") {\n        if (await containsArray(store, path)) {\n            throw new ContainsArrayError(path);\n        } else if (await containsGroup(store, path)) {\n            throw new ContainsGroupError(path);\n        } else {\n            await initGroup(store, path, chunkStore);\n        }\n    } else {\n        throw new ValueError(`Invalid mode argument: ${mode}`);\n    }\n\n    const readOnly = mode === \"r\";\n    return Group.create(store, path, readOnly, chunkStore, cacheAttrs);\n}\n","import { SyncStore, ValidStoreType } from \"./types\";\nimport { createProxy, MutableMappingProxy } from \"../mutableMapping\";\nimport { KeyError } from \"../errors\";\n\nexport class ObjectStore<T extends ValidStoreType> implements SyncStore<T> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    public object: {\n        [key: string]: T;\n    };\n\n    constructor() {\n        this.object = {};\n    }\n\n    getItem(item: string): T {\n        if (!Object.prototype.hasOwnProperty.call(this.object, item)) {\n            throw new KeyError(item);\n        }\n        return this.object[item];\n    }\n    setItem(item: string, value: T): boolean {\n        this.object[item] = value;\n        return true;\n    }\n    deleteItem(item: string): boolean {\n        return delete this.object[item];\n    }\n    containsItem(item: string): boolean {\n        return Object.prototype.hasOwnProperty.call(this.object, item);\n    }\n    proxy(): MutableMappingProxy<T> {\n        return createProxy(this);\n    }\n    keys(): string[] {\n        return Object.getOwnPropertyNames(this.object);\n    }\n}"]},"metadata":{},"sourceType":"module"}