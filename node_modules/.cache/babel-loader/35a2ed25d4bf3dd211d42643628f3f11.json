{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { hasOwnProperty, isFunction, inherits, truthy, lruCache, isArray, error, toSet, array, peek, extend, isNumber, isObject } from 'vega-util';\nimport { curveBasis, curveBasisClosed, curveBasisOpen, curveBundle, curveCardinal, curveCardinalOpen, curveCardinalClosed, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, curveLinear, curveLinearClosed, curveMonotoneY, curveMonotoneX, curveNatural, curveStep, curveStepAfter, curveStepBefore, arc as arc$2, area as area$2, line as line$2, symbol as symbol$2 } from 'd3-shape';\nimport { path as path$3 } from 'd3-path';\nimport { image as image$1, canvas } from 'vega-canvas';\nimport { loader } from 'vega-loader';\nimport { isDiscrete, domainCaption } from 'vega-scale';\nvar gradient_id = 0;\n\nfunction resetSVGGradientId() {\n  gradient_id = 0;\n}\n\nvar patternPrefix = 'p_';\n\nfunction isGradient(value) {\n  return value && value.gradient;\n}\n\nfunction gradientRef(g, defs, base) {\n  var type = g.gradient;\n  var id = g.id,\n      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed\n\n  if (!id) {\n    id = g.id = 'gradient_' + gradient_id++;\n\n    if (type === 'radial') {\n      g.x1 = get(g.x1, 0.5);\n      g.y1 = get(g.y1, 0.5);\n      g.r1 = get(g.r1, 0);\n      g.x2 = get(g.x2, 0.5);\n      g.y2 = get(g.y2, 0.5);\n      g.r2 = get(g.r2, 0.5);\n      prefix = patternPrefix;\n    } else {\n      g.x1 = get(g.x1, 0);\n      g.y1 = get(g.y1, 0);\n      g.x2 = get(g.x2, 1);\n      g.y2 = get(g.y2, 0);\n    }\n  } // register definition\n\n\n  defs[id] = g; // return url reference\n\n  return 'url(' + (base || '') + '#' + prefix + id + ')';\n}\n\nfunction get(val, def) {\n  return val != null ? val : def;\n}\n\nfunction Gradient(p0, p1) {\n  var stops = [],\n      gradient;\n  return gradient = {\n    gradient: 'linear',\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function stop(offset, color) {\n      stops.push({\n        offset: offset,\n        color: color\n      });\n      return gradient;\n    }\n  };\n}\n\nvar lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical: curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\n\nfunction curves(type, orientation, tension) {\n  var entry = hasOwnProperty(lookup, type) && lookup[type],\n      curve = null;\n\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n\n  return curve;\n} // Path parsing and rendering code adapted from fabric.js -- Thanks!\n\n\nvar cmdlen = {\n  m: 2,\n  l: 2,\n  h: 1,\n  v: 1,\n  c: 6,\n  s: 4,\n  q: 4,\n  t: 2,\n  a: 7\n},\n    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\.\\d+)(\\.\\d)/g, /(\\d)([-+])/g, /\\s|,|###/];\n\nfunction pathParse(pathstr) {\n  var result = [];\n  var curr, chunks, parsed, param, cmd, len, i, j, n, m; // First, break path into command sequence\n\n  var path = pathstr.slice().replace(regexp[0], '###$1').split(regexp[1]).slice(1); // Next, parse each command in turn\n\n  for (i = 0, n = path.length; i < n; ++i) {\n    curr = path[i];\n    chunks = curr.slice(1).trim().replace(regexp[2], '$1###$2').replace(regexp[3], '$1###$2').split(regexp[4]);\n    cmd = curr.charAt(0);\n    parsed = [cmd];\n\n    for (j = 0, m = chunks.length; j < m; ++j) {\n      if ((param = +chunks[j]) === param) {\n        // not NaN\n        parsed.push(param);\n      }\n    }\n\n    len = cmdlen[cmd.toLowerCase()];\n\n    if (parsed.length - 1 > len) {\n      var _m = parsed.length;\n      j = 1;\n      result.push([cmd].concat(parsed.slice(j, j += len))); // handle implicit lineTo (#2803)\n\n      cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;\n\n      for (; j < _m; j += len) {\n        result.push([cmd].concat(parsed.slice(j, j + len)));\n      }\n    } else {\n      result.push(parsed);\n    }\n  }\n\n  return result;\n}\n\nvar DegToRad = Math.PI / 180;\nvar Epsilon = 1e-14;\nvar HalfPi = Math.PI / 2;\nvar Tau = Math.PI * 2;\nvar HalfSqrt3 = Math.sqrt(3) / 2;\nvar segmentCache = {};\nvar bezierCache = {};\nvar join = [].join; // Copied from Inkscape svgtopdf, thanks!\n\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  var key = join.call(arguments);\n\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  var th = rotateX * DegToRad;\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = px * px / (rx * rx) + py * py / (ry * ry);\n\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = -sin_th / ry;\n  var a11 = cos_th / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n  var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  var th0 = Math.atan2(y0 - yc, x0 - xc);\n  var th1 = Math.atan2(y1 - yc, x1 - xc);\n  var th_arc = th1 - th0;\n\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += Tau;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= Tau;\n  }\n\n  var segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n  var result = [];\n\n  for (var i = 0; i < segs; ++i) {\n    var th2 = th0 + i * th_arc / segs;\n    var th3 = th0 + (i + 1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return segmentCache[key] = result;\n}\n\nfunction bezier(params) {\n  var key = join.call(params);\n\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n\n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n}\n\nvar temp = ['l', 0, 0, 0, 0, 0, 0, 0];\n\nfunction scale$1(current, sX, sY) {\n  var c = temp[0] = current[0];\n\n  if (c === 'a' || c === 'A') {\n    temp[1] = sX * current[1];\n    temp[2] = sY * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = sX * current[6];\n    temp[7] = sY * current[7];\n  } else if (c === 'h' || c === 'H') {\n    temp[1] = sX * current[1];\n  } else if (c === 'v' || c === 'V') {\n    temp[1] = sY * current[1];\n  } else {\n    for (var i = 1, n = current.length; i < n; ++i) {\n      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    }\n  }\n\n  return temp;\n}\n\nfunction pathRender(context, path, l, t, sX, sY) {\n  var current,\n      // current instruction\n  previous = null,\n      x = 0,\n      // current x\n  y = 0,\n      // current y\n  controlX = 0,\n      // current control point x\n  controlY = 0,\n      // current control point y\n  tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (sX == null) sX = 1;\n  if (sY == null) sY = sX;\n  if (context.beginPath) context.beginPath();\n\n  for (var i = 0, len = path.length; i < len; ++i) {\n    current = path[i];\n\n    if (sX !== 1 || sY !== 1) {\n      current = scale$1(current, sX, sY);\n    }\n\n    switch (current[0]) {\n      // first letter\n      case 'l':\n        // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'L':\n        // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'h':\n        // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'H':\n        // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'v':\n        // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'V':\n        // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'm':\n        // moveTo, relative\n        x += current[1];\n        y += current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'M':\n        // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'c':\n        // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(x + current[1] + l, // x1\n        y + current[2] + t, // y1\n        controlX + l, // x2\n        controlY + t, // y2\n        tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C':\n        // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n        break;\n\n      case 's':\n        // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S':\n        // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY; // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 'q':\n        // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        controlX = x + current[1];\n        controlY = y + current[2];\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q':\n        // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't':\n        // shorthand quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        } else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        } else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        context.closePath();\n        break;\n    }\n\n    previous = current;\n  }\n}\n\nfunction drawArc(context, x, y, coords) {\n  var seg = segments(coords[5], // end x\n  coords[6], // end y\n  coords[0], // radius x\n  coords[1], // radius y\n  coords[3], // large flag\n  coords[4], // sweep flag\n  coords[2], // rotation\n  x, y);\n\n  for (var i = 0; i < seg.length; ++i) {\n    var bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\n\nvar Tan30 = 0.5773502691896257;\nvar builtins = {\n  'circle': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, Tau);\n    }\n  },\n  'cross': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function draw(context, size) {\n      var w = Math.sqrt(size),\n          x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'arrow': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 7,\n          t = r / 2.5,\n          v = r / 8;\n      context.moveTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, -v);\n      context.lineTo(t, -v);\n      context.lineTo(0, -r);\n      context.lineTo(-t, -v);\n      context.lineTo(-s, -v);\n      context.closePath();\n    }\n  },\n  'wedge': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30,\n          b = r / 4;\n      context.moveTo(0, -h - o);\n      context.lineTo(-b, h - o);\n      context.lineTo(b, h - o);\n      context.closePath();\n    }\n  },\n  'triangle': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30;\n      context.moveTo(0, -h - o);\n      context.lineTo(-r, h - o);\n      context.lineTo(r, h - o);\n      context.closePath();\n    }\n  },\n  'triangle-up': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  },\n  'stroke': {\n    draw: function draw(context, size) {\n      var r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(r, 0);\n    }\n  }\n};\n\nfunction symbols(_) {\n  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n}\n\nvar custom = {};\n\nfunction customSymbol(path) {\n  if (!hasOwnProperty(custom, path)) {\n    var parsed = pathParse(path);\n    custom[path] = {\n      draw: function draw(context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n\n  return custom[path];\n}\n\nvar C = 0.448084975506; // C = 1 - c\n\nfunction rectangleX(d) {\n  return d.x;\n}\n\nfunction rectangleY(d) {\n  return d.y;\n}\n\nfunction rectangleWidth(d) {\n  return d.width;\n}\n\nfunction rectangleHeight(d) {\n  return d.height;\n}\n\nfunction number(_) {\n  return typeof _ === 'function' ? _ : function () {\n    return +_;\n  };\n}\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction vg_rect() {\n  var x = rectangleX,\n      y = rectangleY,\n      width = rectangleWidth,\n      height = rectangleHeight,\n      crTL = number(0),\n      crTR = crTL,\n      crBL = crTL,\n      crBR = crTL,\n      context = null;\n\n  function rectangle(_, x0, y0) {\n    var buffer,\n        x1 = x0 != null ? x0 : +x.call(this, _),\n        y1 = y0 != null ? y0 : +y.call(this, _),\n        w = +width.call(this, _),\n        h = +height.call(this, _),\n        s = Math.min(w, h) / 2,\n        tl = clamp(+crTL.call(this, _), 0, s),\n        tr = clamp(+crTR.call(this, _), 0, s),\n        bl = clamp(+crBL.call(this, _), 0, s),\n        br = clamp(+crBR.call(this, _), 0, s);\n    if (!context) context = buffer = path$3();\n\n    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n          y2 = y1 + h;\n      context.moveTo(x1 + tl, y1);\n      context.lineTo(x2 - tr, y1);\n      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n      context.lineTo(x2, y2 - br);\n      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n      context.lineTo(x1 + bl, y2);\n      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n      context.lineTo(x1, y1 + tl);\n      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n      context.closePath();\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  rectangle.x = function (_) {\n    if (arguments.length) {\n      x = number(_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n\n  rectangle.y = function (_) {\n    if (arguments.length) {\n      y = number(_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n\n  rectangle.width = function (_) {\n    if (arguments.length) {\n      width = number(_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n\n  rectangle.height = function (_) {\n    if (arguments.length) {\n      height = number(_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n\n  rectangle.cornerRadius = function (tl, tr, br, bl) {\n    if (arguments.length) {\n      crTL = number(tl);\n      crTR = tr != null ? number(tr) : crTL;\n      crBR = br != null ? number(br) : crTL;\n      crBL = bl != null ? number(bl) : crTR;\n      return rectangle;\n    } else {\n      return crTL;\n    }\n  };\n\n  rectangle.context = function (_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n\n  return rectangle;\n}\n\nfunction vg_trail() {\n  var x,\n      y,\n      size,\n      defined,\n      context = null,\n      ready,\n      x1,\n      y1,\n      r1;\n\n  function point(x2, y2, w2) {\n    var r2 = w2 / 2;\n\n    if (ready) {\n      var ux = y1 - y2,\n          uy = x2 - x1;\n\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.sqrt(ux * ux + uy * uy),\n            rx = (ux /= ud) * r1,\n            ry = (uy /= ud) * r1,\n            t = Math.atan2(uy, ux); // draw segment\n\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - Math.PI, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + Math.PI);\n      } else {\n        context.arc(x2, y2, r2, 0, Tau);\n      }\n\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n\n  function trail(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n    if (context == null) context = buffer = path$3();\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  trail.x = function (_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n\n  trail.y = function (_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n\n  trail.size = function (_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n\n  trail.defined = function (_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n\n  trail.context = function (_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n\n      return trail;\n    } else {\n      return context;\n    }\n  };\n\n  return trail;\n}\n\nfunction value$1(a, b) {\n  return a != null ? a : b;\n}\n\nvar x = function x(item) {\n  return item.x || 0;\n},\n    y = function y(item) {\n  return item.y || 0;\n},\n    w = function w(item) {\n  return item.width || 0;\n},\n    h = function h(item) {\n  return item.height || 0;\n},\n    xw = function xw(item) {\n  return (item.x || 0) + (item.width || 0);\n},\n    yh = function yh(item) {\n  return (item.y || 0) + (item.height || 0);\n},\n    sa = function sa(item) {\n  return item.startAngle || 0;\n},\n    ea = function ea(item) {\n  return item.endAngle || 0;\n},\n    pa = function pa(item) {\n  return item.padAngle || 0;\n},\n    ir = function ir(item) {\n  return item.innerRadius || 0;\n},\n    or = function or(item) {\n  return item.outerRadius || 0;\n},\n    cr = function cr(item) {\n  return item.cornerRadius || 0;\n},\n    tl = function tl(item) {\n  return value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0;\n},\n    tr = function tr(item) {\n  return value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0;\n},\n    br = function br(item) {\n  return value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0;\n},\n    bl = function bl(item) {\n  return value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;\n},\n    sz = function sz(item) {\n  return value$1(item.size, 64);\n},\n    ts = function ts(item) {\n  return item.size || 1;\n},\n    def = function def(item) {\n  return !(item.defined === false);\n},\n    type = function type(item) {\n  return symbols(item.shape || 'circle');\n};\n\nvar arcShape = arc$2().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),\n    areavShape = area$2().x(x).y1(y).y0(yh).defined(def),\n    areahShape = area$2().y(y).x1(x).x0(xw).defined(def),\n    lineShape = line$2().x(x).y(y).defined(def),\n    rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),\n    symbolShape = symbol$2().type(type).size(sz),\n    trailShape = vg_trail().x(x).y(y).defined(def).size(ts);\n\nfunction hasCornerRadius(item) {\n  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;\n}\n\nfunction arc$1(context, item) {\n  return arcShape.context(context)(item);\n}\n\nfunction area$1(context, items) {\n  var item = items[0],\n      interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\n\nfunction line$1(context, items) {\n  var item = items[0],\n      interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\n\nfunction rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\n\nfunction shape$1(context, item) {\n  return (item.mark.shape || item.shape).context(context)(item);\n}\n\nfunction symbol$1(context, item) {\n  return symbolShape.context(context)(item);\n}\n\nfunction trail$1(context, items) {\n  return trailShape.context(context)(items);\n}\n\nvar clip_id = 1;\n\nfunction resetSVGClipId() {\n  clip_id = 1;\n}\n\nfunction clip$1(renderer, item, size) {\n  var clip = item.clip,\n      defs = renderer._defs,\n      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n      c = defs.clipping[id] || (defs.clipping[id] = {\n    id: id\n  });\n\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else if (hasCornerRadius(size)) {\n    c.path = rectangle(null, size, 0, 0);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n\n  return 'url(#' + id + ')';\n}\n\nfunction Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\n\nBounds.prototype = {\n  clone: function clone() {\n    return new Bounds(this);\n  },\n  clear: function clear() {\n    this.x1 = +Number.MAX_VALUE;\n    this.y1 = +Number.MAX_VALUE;\n    this.x2 = -Number.MAX_VALUE;\n    this.y2 = -Number.MAX_VALUE;\n    return this;\n  },\n  empty: function empty() {\n    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;\n  },\n  equals: function equals(b) {\n    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;\n  },\n  set: function set(x1, y1, x2, y2) {\n    if (x2 < x1) {\n      this.x2 = x1;\n      this.x1 = x2;\n    } else {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    if (y2 < y1) {\n      this.y2 = y1;\n      this.y1 = y2;\n    } else {\n      this.y1 = y1;\n      this.y2 = y2;\n    }\n\n    return this;\n  },\n  add: function add(x, y) {\n    if (x < this.x1) this.x1 = x;\n    if (y < this.y1) this.y1 = y;\n    if (x > this.x2) this.x2 = x;\n    if (y > this.y2) this.y2 = y;\n    return this;\n  },\n  expand: function expand(d) {\n    this.x1 -= d;\n    this.y1 -= d;\n    this.x2 += d;\n    this.y2 += d;\n    return this;\n  },\n  round: function round() {\n    this.x1 = Math.floor(this.x1);\n    this.y1 = Math.floor(this.y1);\n    this.x2 = Math.ceil(this.x2);\n    this.y2 = Math.ceil(this.y2);\n    return this;\n  },\n  scale: function scale(s) {\n    this.x1 *= s;\n    this.y1 *= s;\n    this.x2 *= s;\n    this.y2 *= s;\n    return this;\n  },\n  translate: function translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  },\n  rotate: function rotate(angle, x, y) {\n    var p = this.rotatedPoints(angle, x, y);\n    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);\n  },\n  rotatedPoints: function rotatedPoints(angle, x, y) {\n    var x1 = this.x1,\n        y1 = this.y1,\n        x2 = this.x2,\n        y2 = this.y2,\n        cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        cx = x - x * cos + y * sin,\n        cy = y - x * sin - y * cos;\n    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];\n  },\n  union: function union(b) {\n    if (b.x1 < this.x1) this.x1 = b.x1;\n    if (b.y1 < this.y1) this.y1 = b.y1;\n    if (b.x2 > this.x2) this.x2 = b.x2;\n    if (b.y2 > this.y2) this.y2 = b.y2;\n    return this;\n  },\n  intersect: function intersect(b) {\n    if (b.x1 > this.x1) this.x1 = b.x1;\n    if (b.y1 > this.y1) this.y1 = b.y1;\n    if (b.x2 < this.x2) this.x2 = b.x2;\n    if (b.y2 < this.y2) this.y2 = b.y2;\n    return this;\n  },\n  encloses: function encloses(b) {\n    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;\n  },\n  alignsWith: function alignsWith(b) {\n    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);\n  },\n  intersects: function intersects(b) {\n    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);\n  },\n  contains: function contains(x, y) {\n    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);\n  },\n  width: function width() {\n    return this.x2 - this.x1;\n  },\n  height: function height() {\n    return this.y2 - this.y1;\n  }\n};\n\nfunction Item(mark) {\n  this.mark = mark;\n  this.bounds = this.bounds || new Bounds();\n}\n\nfunction GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = this.items || [];\n}\n\ninherits(GroupItem, Item);\n\nfunction ResourceLoader(customLoader) {\n  this._pending = 0;\n  this._loader = customLoader || loader();\n}\n\nfunction increment(loader) {\n  loader._pending += 1;\n}\n\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\n\nResourceLoader.prototype = {\n  pending: function pending() {\n    return this._pending;\n  },\n  sanitizeURL: function sanitizeURL(uri) {\n    var loader = this;\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'href'\n    }).then(function (opt) {\n      decrement(loader);\n      return opt;\n    }).catch(function () {\n      decrement(loader);\n      return null;\n    });\n  },\n  loadImage: function loadImage(uri) {\n    var loader = this,\n        Image = image$1();\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'image'\n    }).then(function (opt) {\n      var url = opt.href;\n      if (!url || !Image) throw {\n        url: url\n      };\n      var img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n\n      var cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n      if (cors != null) img.crossOrigin = cors; // attempt to load image resource\n\n      img.onload = function () {\n        return decrement(loader);\n      };\n\n      img.onerror = function () {\n        return decrement(loader);\n      };\n\n      img.src = url;\n      return img;\n    }).catch(function (e) {\n      decrement(loader);\n      return {\n        complete: false,\n        width: 0,\n        height: 0,\n        src: e && e.url || ''\n      };\n    });\n  },\n  ready: function ready() {\n    var loader = this;\n    return new Promise(function (accept) {\n      function poll(value) {\n        if (!loader.pending()) accept(value);else setTimeout(function () {\n          poll(true);\n        }, 10);\n      }\n\n      poll(false);\n    });\n  }\n};\n\nfunction boundStroke(bounds, item, miter) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    var sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n  }\n\n  return bounds;\n}\n\nfunction miterAdjustment(item, strokeWidth) {\n  // TODO: more sophisticated adjustment? Or miter support in boundContext?\n  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n}\n\nvar circleThreshold = Tau - 1e-8;\nvar bounds, lx, ly, rot, ma, mb, mc, md;\n\nvar add = function add(x, y) {\n  return bounds.add(x, y);\n};\n\nvar addL = function addL(x, y) {\n  return add(lx = x, ly = y);\n};\n\nvar addX = function addX(x) {\n  return add(x, bounds.y1);\n};\n\nvar addY = function addY(y) {\n  return add(bounds.x1, y);\n};\n\nvar px = function px(x, y) {\n  return ma * x + mc * y;\n};\n\nvar py = function py(x, y) {\n  return mb * x + md * y;\n};\n\nvar addp = function addp(x, y) {\n  return add(px(x, y), py(x, y));\n};\n\nvar addpL = function addpL(x, y) {\n  return addL(px(x, y), py(x, y));\n};\n\nfunction boundContext(_, deg) {\n  bounds = _;\n\n  if (deg) {\n    rot = deg * DegToRad;\n    ma = md = Math.cos(rot);\n    mb = Math.sin(rot);\n    mc = -mb;\n  } else {\n    ma = md = 1;\n    rot = mb = mc = 0;\n  }\n\n  return context$1;\n}\n\nvar context$1 = {\n  beginPath: function beginPath() {},\n  closePath: function closePath() {},\n  moveTo: addpL,\n  lineTo: addpL,\n  rect: function rect(x, y, w, h) {\n    if (rot) {\n      addp(x + w, y);\n      addp(x + w, y + h);\n      addp(x, y + h);\n      addpL(x, y);\n    } else {\n      add(x + w, y + h);\n      addL(x, y);\n    }\n  },\n  quadraticCurveTo: function quadraticCurveTo(x1, y1, x2, y2) {\n    var px1 = px(x1, y1),\n        py1 = py(x1, y1),\n        px2 = px(x2, y2),\n        py2 = py(x2, y2);\n    quadExtrema(lx, px1, px2, addX);\n    quadExtrema(ly, py1, py2, addY);\n    addL(px2, py2);\n  },\n  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    var px1 = px(x1, y1),\n        py1 = py(x1, y1),\n        px2 = px(x2, y2),\n        py2 = py(x2, y2),\n        px3 = px(x3, y3),\n        py3 = py(x3, y3);\n    cubicExtrema(lx, px1, px2, px3, addX);\n    cubicExtrema(ly, py1, py2, py3, addY);\n    addL(px3, py3);\n  },\n  arc: function arc(cx, cy, r, sa, ea, ccw) {\n    sa += rot;\n    ea += rot; // store last point on path\n\n    lx = r * Math.cos(ea) + cx;\n    ly = r * Math.sin(ea) + cy;\n\n    if (Math.abs(ea - sa) > circleThreshold) {\n      // treat as full circle\n      add(cx - r, cy - r);\n      add(cx + r, cy + r);\n    } else {\n      var update = function update(a) {\n        return add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n      };\n\n      var s, i; // sample end points\n\n      update(sa);\n      update(ea); // sample interior points aligned with 90 degrees\n\n      if (ea !== sa) {\n        sa = sa % Tau;\n        if (sa < 0) sa += Tau;\n        ea = ea % Tau;\n        if (ea < 0) ea += Tau;\n\n        if (ea < sa) {\n          ccw = !ccw; // flip direction\n\n          s = sa;\n          sa = ea;\n          ea = s; // swap end-points\n        }\n\n        if (ccw) {\n          ea -= Tau;\n          s = sa - sa % HalfPi;\n\n          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) {\n            update(s);\n          }\n        } else {\n          s = sa - sa % HalfPi + HalfPi;\n\n          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) {\n            update(s);\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction quadExtrema(x0, x1, x2, cb) {\n  var t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\n\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  var a = x3 - x0 + 3 * x1 - 3 * x2,\n      b = x0 + x2 - 2 * x1,\n      c = x0 - x1;\n  var t0 = 0,\n      t1 = 0,\n      r; // solve for parameter t\n\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  } // calculate position\n\n\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\n\nfunction cubic(t, x0, x1, x2, x3) {\n  var s = 1 - t,\n      s2 = s * s,\n      t2 = t * t;\n  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;\n}\n\nvar context = (context = canvas(1, 1)) ? context.getContext('2d') : null;\nvar b = new Bounds();\n\nfunction intersectPath(draw) {\n  return function (item, brush) {\n    // rely on (inaccurate) bounds intersection if no context\n    if (!context) return true; // add path to offscreen graphics context\n\n    draw(context, item); // get bounds intersection region\n\n    b.clear().union(item.bounds).intersect(brush).round();\n    var x1 = b.x1,\n        y1 = b.y1,\n        x2 = b.x2,\n        y2 = b.y2; // iterate over intersection region\n    // perform fine grained inclusion test\n\n    for (var _y = y1; _y <= y2; ++_y) {\n      for (var _x = x1; _x <= x2; ++_x) {\n        if (context.isPointInPath(_x, _y)) {\n          return true;\n        }\n      }\n    } // false if no hits in intersection region\n\n\n    return false;\n  };\n}\n\nfunction intersectPoint(item, box) {\n  return box.contains(item.x || 0, item.y || 0);\n}\n\nfunction intersectRect(item, box) {\n  var x = item.x || 0,\n      y = item.y || 0,\n      w = item.width || 0,\n      h = item.height || 0;\n  return box.intersects(b.set(x, y, x + w, y + h));\n}\n\nfunction intersectRule(item, box) {\n  var x = item.x || 0,\n      y = item.y || 0,\n      x2 = item.x2 != null ? item.x2 : x,\n      y2 = item.y2 != null ? item.y2 : y;\n  return intersectBoxLine(box, x, y, x2, y2);\n}\n\nfunction intersectBoxLine(box, x, y, u, v) {\n  var x1 = box.x1,\n      y1 = box.y1,\n      x2 = box.x2,\n      y2 = box.y2,\n      dx = u - x,\n      dy = v - y;\n  var t0 = 0,\n      t1 = 1,\n      p,\n      q,\n      r,\n      e;\n\n  for (e = 0; e < 4; ++e) {\n    if (e === 0) {\n      p = -dx;\n      q = -(x1 - x);\n    }\n\n    if (e === 1) {\n      p = dx;\n      q = x2 - x;\n    }\n\n    if (e === 2) {\n      p = -dy;\n      q = -(y1 - y);\n    }\n\n    if (e === 3) {\n      p = dy;\n      q = y2 - y;\n    }\n\n    if (Math.abs(p) < 1e-10 && q < 0) return false;\n    r = q / p;\n\n    if (p < 0) {\n      if (r > t1) return false;else if (r > t0) t0 = r;\n    } else if (p > 0) {\n      if (r < t0) return false;else if (r < t1) t1 = r;\n    }\n  }\n\n  return true;\n}\n\nfunction blend(context, item) {\n  context.globalCompositeOperation = item.blend || 'source-over';\n}\n\nfunction value(value, dflt) {\n  return value == null ? dflt : value;\n}\n\nfunction addStops(gradient, stops) {\n  var n = stops.length;\n\n  for (var i = 0; i < n; ++i) {\n    gradient.addColorStop(stops[i].offset, stops[i].color);\n  }\n\n  return gradient;\n}\n\nfunction gradient(context, spec, bounds) {\n  var w = bounds.width(),\n      h = bounds.height();\n  var gradient;\n\n  if (spec.gradient === 'radial') {\n    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));\n  } else {\n    // linear gradient\n    var x1 = value(spec.x1, 0),\n        y1 = value(spec.y1, 0),\n        x2 = value(spec.x2, 1),\n        y2 = value(spec.y2, 0);\n\n    if (x1 === x2 || y1 === y2 || w === h) {\n      // axis aligned: use normal gradient\n      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);\n    } else {\n      // not axis aligned: render gradient into a pattern (#2365)\n      // this allows us to use normalized bounding box coordinates\n      var _image = canvas(Math.ceil(w), Math.ceil(h)),\n          ictx = _image.getContext('2d');\n\n      ictx.scale(w, h);\n      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);\n      ictx.fillRect(0, 0, w, h);\n      return context.createPattern(_image, 'no-repeat');\n    }\n  }\n\n  return addStops(gradient, spec.stops);\n}\n\nfunction color(context, item, value) {\n  return isGradient(value) ? gradient(context, value, item.bounds) : value;\n}\n\nfunction fill(context, item, opacity) {\n  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar Empty = [];\n\nfunction stroke(context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n  if (lw <= 0) return false;\n  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\n\nfunction zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n  var items = scene.items,\n      output = [],\n      item,\n      i,\n      n;\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\n\nfunction visit(scene, visitor) {\n  var items = scene.items,\n      i,\n      n;\n  if (!items || !items.length) return;\n  var zitems = zorder(scene);\n\n  if (zitems && zitems.length) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n\n    items = zitems;\n  }\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    visitor(items[i]);\n  }\n}\n\nfunction pickVisit(scene, visitor) {\n  var items = scene.items,\n      hit,\n      i;\n  if (!items || !items.length) return null;\n  var zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n\n  for (i = items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n\n  if (items === zitems) {\n    for (items = scene.items, i = items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction drawAll(path) {\n  return function (context, scene, bounds) {\n    visit(scene, function (item) {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\n\nfunction drawOne(path) {\n  return function (context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\n\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n  if (path(context, items)) return;\n  blend(context, item);\n\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\n\nfunction pick$1(test) {\n  test = test || truthy;\n  return function (context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return pickVisit(scene, function (item) {\n      var b = item.bounds; // first hit test against bounding box\n\n      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test\n\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\n\nfunction hitPath(path, filled) {\n  return function (context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = filled == null ? item.fill : filled,\n        stroke = item.stroke && context.isPointInStroke,\n        lw,\n        lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap = lc != null ? lc : 'butt';\n    }\n\n    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);\n  };\n}\n\nfunction pickPath(path) {\n  return pick$1(hitPath(path));\n}\n\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\n\nfunction rotate(a) {\n  return 'rotate(' + a + ')';\n}\n\nfunction scale(scaleX, scaleY) {\n  return 'scale(' + scaleX + ',' + scaleY + ')';\n}\n\nfunction translateItem(item) {\n  return translate(item.x || 0, item.y || 0);\n}\n\nfunction rotateItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');\n}\n\nfunction transformItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');\n}\n\nfunction markItemPath(type, shape, isect) {\n  function attr(emit, item) {\n    emit('transform', rotateItem(item));\n    emit('d', shape(null, item));\n  }\n\n  function bound(bounds, item) {\n    shape(boundContext(bounds, item.angle), item);\n    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n  }\n\n  function draw(context, item) {\n    var x = item.x || 0,\n        y = item.y || 0,\n        a = item.angle || 0;\n    context.translate(x, y);\n    if (a) context.rotate(a *= DegToRad);\n    context.beginPath();\n    shape(context, item);\n    if (a) context.rotate(-a);\n    context.translate(-x, -y);\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: false,\n    attr: attr,\n    bound: bound,\n    draw: drawAll(draw),\n    pick: pickPath(draw),\n    isect: isect || intersectPath(draw)\n  };\n}\n\nvar arc = markItemPath('arc', arc$1);\n\nfunction pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n      z = a[0].orient === 'horizontal' ? 'y' : 'x',\n      i = a.length,\n      min = +Infinity,\n      hit,\n      d;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n\n  return hit;\n}\n\nfunction pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n      i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n\n  return null;\n}\n\nfunction pickTrail(a, p) {\n  var i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx * dx) return a[i];\n  }\n\n  return null;\n}\n\nfunction markMultiItemPath(type, shape, tip) {\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n\n  function bound(bounds, mark) {\n    var items = mark.items;\n\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(boundContext(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n\n  var hit = hitPath(draw);\n\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n        b = scene.bounds;\n\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: true,\n    attr: attr,\n    bound: bound,\n    draw: drawOne(draw),\n    pick: pick,\n    isect: intersectPoint,\n    tip: tip\n  };\n}\n\nvar area = markMultiItemPath('area', area$1, pickArea);\n\nfunction clip(context, scene) {\n  var clip = scene.clip;\n  context.save();\n\n  if (isFunction(clip)) {\n    context.beginPath();\n    clip(context);\n    context.clip();\n  } else {\n    clipGroup(context, scene.group);\n  }\n}\n\nfunction clipGroup(context, group) {\n  context.beginPath();\n  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);\n  context.clip();\n}\n\nfunction offset$1(item) {\n  var sw = value(item.strokeWidth, 1);\n  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;\n}\n\nfunction attr$5(emit, item) {\n  emit('transform', translateItem(item));\n}\n\nfunction emitRectangle(emit, item) {\n  var off = offset$1(item);\n  emit('d', rectangle(null, item, off, off));\n}\n\nfunction background(emit, item) {\n  emit('class', 'background');\n  emit('aria-hidden', true);\n  emitRectangle(emit, item);\n}\n\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n  emit('aria-hidden', true);\n\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\n\nfunction content(emit, item, renderer) {\n  var url = item.clip ? clip$1(renderer, item, item) : null;\n  emit('clip-path', url);\n}\n\nfunction bound$5(bounds, group) {\n  if (!group.clip && group.items) {\n    var items = group.items,\n        m = items.length;\n\n    for (var j = 0; j < m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n\n  boundStroke(bounds, group);\n  return bounds.translate(group.x || 0, group.y || 0);\n}\n\nfunction rectanglePath(context, group, x, y) {\n  var off = offset$1(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\n\nvar hitBackground = hitPath(rectanglePath);\nvar hitForeground = hitPath(rectanglePath, false);\nvar hitCorner = hitPath(rectanglePath, true);\n\nfunction draw$4(context, scene, bounds) {\n  var _this = this;\n\n  visit(scene, function (group) {\n    var gx = group.x || 0,\n        gy = group.y || 0,\n        fore = group.strokeForeground,\n        opacity = group.opacity == null ? 1 : group.opacity; // draw group background\n\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    } // setup graphics context, set clip and bounds\n\n\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy); // draw group contents\n\n    visit(group, function (item) {\n      _this.draw(context, item, bounds);\n    }); // restore graphics context\n\n    if (bounds) bounds.translate(gx, gy);\n    context.restore(); // draw group foreground\n\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\n\nfunction pick(context, scene, x, y, gx, gy) {\n  var _this2 = this;\n\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n\n  var cx = x * context.pixelRatio,\n      cy = y * context.pixelRatio;\n  return pickVisit(scene, function (group) {\n    var hit, dx, dy; // first hit test bounding box\n\n    var b = group.bounds;\n    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip\n\n    dx = group.x || 0;\n    dy = group.y || 0;\n    var dw = dx + (group.width || 0),\n        dh = dy + (group.height || 0),\n        c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system\n\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy; // test background for rounded corner clip\n\n    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n\n    var fore = group.strokeForeground,\n        ix = scene.interactive !== false; // hit test against group foreground\n\n    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    } // hit test against contained marks\n\n\n    hit = pickVisit(group, function (mark) {\n      return pickMark(mark, dx, dy) ? _this2.pick(mark, x, y, dx, dy) : null;\n    }); // hit test against group background\n\n    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    } // restore state and return\n\n\n    context.restore();\n    return hit || null;\n  });\n}\n\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);\n}\n\nvar group = {\n  type: 'group',\n  tag: 'g',\n  nested: false,\n  attr: attr$5,\n  bound: bound$5,\n  draw: draw$4,\n  pick: pick,\n  isect: intersectRect,\n  content: content,\n  background: background,\n  foreground: foreground\n};\nvar metadata = {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n  'version': '1.1'\n};\n\nfunction getImage(item, renderer) {\n  var image = item.image;\n\n  if (!image || item.url && item.url !== image.url) {\n    image = {\n      complete: false,\n      width: 0,\n      height: 0\n    };\n    renderer.loadImage(item.url).then(function (image) {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n\n  return image;\n}\n\nfunction imageWidth(item, image) {\n  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;\n}\n\nfunction imageHeight(item, image) {\n  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;\n}\n\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\n\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\n\nfunction attr$4(emit, item, renderer) {\n  var img = getImage(item, renderer),\n      w = imageWidth(item, img),\n      h = imageHeight(item, img),\n      x = (item.x || 0) - imageXOffset(item.align, w),\n      y = (item.y || 0) - imageYOffset(item.baseline, h),\n      i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n}\n\nfunction bound$4(bounds, item) {\n  var img = item.image,\n      w = imageWidth(item, img),\n      h = imageHeight(item, img),\n      x = (item.x || 0) - imageXOffset(item.align, w),\n      y = (item.y || 0) - imageYOffset(item.baseline, h);\n  return bounds.set(x, y, x + w, y + h);\n}\n\nfunction draw$3(context, scene, bounds) {\n  var _this3 = this;\n\n  visit(scene, function (item) {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    var img = getImage(item, _this3);\n    var w = imageWidth(item, img);\n    var h = imageHeight(item, img);\n    if (w === 0 || h === 0) return; // early exit\n\n    var x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        opacity,\n        ar0,\n        ar1,\n        t;\n\n    if (item.aspect !== false) {\n      ar0 = img.width / img.height;\n      ar1 = item.width / item.height;\n\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n\n    if (img.complete || img.toDataURL) {\n      blend(context, item);\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.imageSmoothingEnabled = item.smooth !== false;\n      context.drawImage(img, x, y, w, h);\n    }\n  });\n}\n\nvar image = {\n  type: 'image',\n  tag: 'image',\n  nested: false,\n  attr: attr$4,\n  bound: bound$4,\n  draw: draw$3,\n  pick: pick$1(),\n  isect: truthy,\n  // bounds check is sufficient\n  get: getImage,\n  xOffset: imageXOffset,\n  yOffset: imageYOffset\n};\nvar line = markMultiItemPath('line', line$1, pickLine);\n\nfunction attr$3(emit, item) {\n  var sx = item.scaleX || 1,\n      sy = item.scaleY || 1;\n\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\n\nfunction path$1(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n  var x = item.x || 0,\n      y = item.y || 0,\n      sx = item.scaleX || 1,\n      sy = item.scaleY || 1,\n      a = (item.angle || 0) * DegToRad,\n      cache = item.pathCache;\n\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = pathParse(path)).path = path;\n  }\n\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\n\nfunction bound$3(bounds, item) {\n  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);\n}\n\nvar path$2 = {\n  type: 'path',\n  tag: 'path',\n  nested: false,\n  attr: attr$3,\n  bound: bound$3,\n  draw: drawAll(path$1),\n  pick: pickPath(path$1),\n  isect: intersectPath(path$1)\n};\n\nfunction attr$2(emit, item) {\n  emit('d', rectangle(null, item));\n}\n\nfunction bound$2(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);\n}\n\nfunction draw$2(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\n\nvar rect = {\n  type: 'rect',\n  tag: 'path',\n  nested: false,\n  attr: attr$2,\n  bound: bound$2,\n  draw: drawAll(draw$2),\n  pick: pickPath(draw$2),\n  isect: intersectRect\n};\n\nfunction attr$1(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\n\nfunction bound$1(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);\n}\n\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n\n  return false;\n}\n\nfunction draw$1(context, scene, bounds) {\n  visit(scene, function (item) {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    var opacity = item.opacity == null ? 1 : item.opacity;\n\n    if (opacity && path(context, item, opacity)) {\n      blend(context, item);\n      context.stroke();\n    }\n  });\n}\n\nfunction hit$1(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\n\nvar rule = {\n  type: 'rule',\n  tag: 'line',\n  nested: false,\n  attr: attr$1,\n  bound: bound$1,\n  draw: draw$1,\n  pick: pick$1(hit$1),\n  isect: intersectRule\n};\nvar shape = markItemPath('shape', shape$1);\nvar symbol = markItemPath('symbol', symbol$1, intersectPoint);\nvar widthCache = lruCache();\nvar textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\nuseCanvas(true);\n\nfunction useCanvas(use) {\n  textMetrics.width = use && context ? measureWidth : estimateWidth;\n} // make simple estimate if no canvas is available\n\n\nfunction estimateWidth(item, text) {\n  return _estimateWidth(textValue(item, text), fontSize(item));\n}\n\nfunction _estimateWidth(text, currentFontHeight) {\n  return ~~(0.8 * text.length * currentFontHeight);\n} // measure text width if canvas is available\n\n\nfunction measureWidth(item, text) {\n  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));\n}\n\nfunction _measureWidth(text, currentFont) {\n  var key = \"(\".concat(currentFont, \") \").concat(text);\n  var width = widthCache.get(key);\n\n  if (width === undefined) {\n    context.font = currentFont;\n    width = context.measureText(text).width;\n    widthCache.set(key, width);\n  }\n\n  return width;\n}\n\nfunction fontSize(item) {\n  return item.fontSize != null ? +item.fontSize || 0 : 11;\n}\n\nfunction lineHeight(item) {\n  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;\n}\n\nfunction lineArray(_) {\n  return isArray(_) ? _.length > 1 ? _ : _[0] : _;\n}\n\nfunction textLines(item) {\n  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);\n}\n\nfunction multiLineOffset(item) {\n  var tl = textLines(item);\n  return (isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);\n}\n\nfunction textValue(item, line) {\n  var text = line == null ? '' : (line + '').trim();\n  return item.limit > 0 && text.length ? truncate(item, text) : text;\n}\n\nfunction widthGetter(item) {\n  if (textMetrics.width === measureWidth) {\n    // we are using canvas\n    var currentFont = font(item);\n    return function (text) {\n      return _measureWidth(text, currentFont);\n    };\n  } else {\n    // we are relying on estimates\n    var currentFontHeight = fontSize(item);\n    return function (text) {\n      return _estimateWidth(text, currentFontHeight);\n    };\n  }\n}\n\nfunction truncate(item, text) {\n  var limit = +item.limit,\n      width = widthGetter(item);\n  if (width(text) < limit) return text;\n  var ellipsis = item.ellipsis || \"\\u2026\",\n      rtl = item.dir === 'rtl',\n      lo = 0,\n      hi = text.length,\n      mid;\n  limit -= width(ellipsis);\n\n  if (rtl) {\n    while (lo < hi) {\n      mid = lo + hi >>> 1;\n      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;\n    }\n\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;\n    }\n\n    return text.slice(0, lo) + ellipsis;\n  }\n}\n\nfunction fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font ? String(font).replace(/\"/g, '\\'') : font) || 'sans-serif';\n}\n\nfunction font(item, quote) {\n  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);\n}\n\nfunction offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  // this also ensures consistent layout across renderers\n  var baseline = item.baseline,\n      h = fontSize(item);\n  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);\n}\n\nvar textAlign = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\nvar tempBounds = new Bounds();\n\nfunction anchorPoint(item) {\n  var x = item.x || 0,\n      y = item.y || 0,\n      r = item.radius || 0,\n      t;\n\n  if (r) {\n    t = (item.theta || 0) - HalfPi;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  tempBounds.x1 = x;\n  tempBounds.y1 = y;\n  return tempBounds;\n}\n\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item),\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      a = item.angle || 0,\n      t;\n  emit('text-anchor', textAlign[item.align] || 'start');\n\n  if (a) {\n    t = translate(x, y) + ' ' + rotate(a);\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n\n  emit('transform', t);\n}\n\nfunction bound(bounds, item, mode) {\n  var h = textMetrics.height(item),\n      a = item.align,\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),\n      // use 4/5 offset\n  tl = textLines(item),\n      w; // get dimensions\n\n  if (isArray(tl)) {\n    // multi-line text\n    h += lineHeight(item) * (tl.length - 1);\n    w = tl.reduce(function (w, t) {\n      return Math.max(w, textMetrics.width(item, t));\n    }, 0);\n  } else {\n    // single-line text\n    w = textMetrics.width(item, tl);\n  } // horizontal alignment\n\n\n  if (a === 'center') {\n    dx -= w / 2;\n  } else if (a === 'right') {\n    dx -= w;\n  } else ;\n\n  bounds.set(dx += x, dy += y, dx + w, dy + h);\n\n  if (item.angle && !mode) {\n    bounds.rotate(item.angle * DegToRad, x, y);\n  } else if (mode === 2) {\n    return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n  }\n\n  return bounds;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, function (item) {\n    var opacity = item.opacity == null ? 1 : item.opacity,\n        p,\n        x,\n        y,\n        i,\n        lh,\n        tl,\n        str;\n    if (bounds && !bounds.intersects(item.bounds) || // bounds check\n    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n    p = anchorPoint(item);\n    x = p.x1, y = p.y1;\n\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * DegToRad);\n      x = y = 0; // reset x, y\n    }\n\n    x += item.dx || 0;\n    y += (item.dy || 0) + offset(item);\n    tl = textLines(item);\n    blend(context, item);\n\n    if (isArray(tl)) {\n      lh = lineHeight(item);\n\n      for (i = 0; i < tl.length; ++i) {\n        str = textValue(item, tl[i]);\n\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n\n        y += lh;\n      }\n    } else {\n      str = textValue(item, tl);\n\n      if (item.fill && fill(context, item, opacity)) {\n        context.fillText(str, x, y);\n      }\n\n      if (item.stroke && stroke(context, item, opacity)) {\n        context.strokeText(str, x, y);\n      }\n    }\n\n    if (item.angle) context.restore();\n  });\n}\n\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n  // project point into space of unrotated bounds\n\n  var p = anchorPoint(item),\n      ax = p.x1,\n      ay = p.y1,\n      b = bound(tempBounds, item, 1),\n      a = -item.angle * DegToRad,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n  return b.contains(px, py);\n}\n\nfunction intersectText(item, box) {\n  var p = bound(tempBounds, item, 2);\n  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n}\n\nvar text = {\n  type: 'text',\n  tag: 'text',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick$1(hit),\n  isect: intersectText\n};\nvar trail = markMultiItemPath('trail', trail$1, pickTrail);\nvar Marks = {\n  arc: arc,\n  area: area,\n  group: group,\n  image: image,\n  line: line,\n  path: path$2,\n  rect: rect,\n  rule: rule,\n  shape: shape,\n  symbol: symbol,\n  text: text,\n  trail: trail\n};\n\nfunction boundItem(item, func, opt) {\n  var type = Marks[item.mark.marktype],\n      bound = func || type.bound;\n  if (type.nested) item = item.mark;\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\n\nvar DUMMY = {\n  mark: null\n};\n\nfunction boundMark(mark, bounds, opt) {\n  var type = Marks[mark.marktype],\n      bound = type.bound,\n      items = mark.items,\n      hasItems = items && items.length,\n      i,\n      n,\n      item,\n      b;\n\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n\n  if (hasItems) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n\n  return mark.bounds = bounds;\n}\n\nvar keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout\n'fill', 'fillOpacity', 'opacity', 'blend', // fill\n'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke\n'strokeDash', 'strokeDashOffset', // stroke dash\n'strokeForeground', 'strokeOffset', // group\n'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc\n'cornerRadius', 'padAngle', // arc, rect\n'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group\n'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line\n'url', 'aspect', 'smooth', // image\n'path', 'scaleX', 'scaleY', // path\n'x2', 'y2', // rule\n'size', 'shape', // symbol\n'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text\n'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font\n'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria\n];\n\nfunction sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\n\nfunction sceneFromJSON(json) {\n  var scene = typeof json === 'string' ? JSON.parse(json) : json;\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      items = scene.items,\n      parent,\n      i,\n      n;\n\n  if (items) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n\n  if (type) boundMark(scene);\n  return scene;\n}\n\nfunction Scenegraph(scene) {\n  if (arguments.length) {\n    this.root = sceneFromJSON(scene);\n  } else {\n    this.root = createMark({\n      marktype: 'group',\n      name: 'root',\n      role: 'frame'\n    });\n    this.root.items = [new GroupItem(this.root)];\n  }\n}\n\nScenegraph.prototype = {\n  toJSON: function toJSON(indent) {\n    return sceneToJSON(this.root, indent || 0);\n  },\n  mark: function mark(markdef, group, index) {\n    group = group || this.root.items[0];\n    var mark = createMark(markdef, group);\n    group.items[index] = mark;\n    if (mark.zindex) mark.group.zdirty = true;\n    return mark;\n  }\n};\n\nfunction createMark(def, group) {\n  var mark = {\n    bounds: new Bounds(),\n    clip: !!def.clip,\n    group: group,\n    interactive: def.interactive === false ? false : true,\n    items: [],\n    marktype: def.marktype,\n    name: def.name || undefined,\n    role: def.role || undefined,\n    zindex: def.zindex || 0\n  }; // add accessibility properties if defined\n\n  if (def.aria != null) {\n    mark.aria = def.aria;\n  }\n\n  if (def.description) {\n    mark.description = def.description;\n  }\n\n  return mark;\n} // create a new DOM element\n\n\nfunction domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n\n  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;\n} // find first child element with matching tag\n\n\nfunction domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes,\n      i = 0,\n      n = nodes.length;\n\n  for (; i < n; ++i) {\n    if (nodes[i].tagName.toLowerCase() === tag) {\n      return nodes[i];\n    }\n  }\n} // retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\n\n\nfunction domChild(el, index, tag, ns) {\n  var a = el.childNodes[index],\n      b;\n\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n\n  return a;\n} // remove all child elements at or above the given index\n\n\nfunction domClear(el, index) {\n  var nodes = el.childNodes,\n      curr = nodes.length;\n\n  while (curr > index) {\n    el.removeChild(nodes[--curr]);\n  }\n\n  return el;\n} // generate css class name for mark\n\n\nfunction cssClass(mark) {\n  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');\n}\n\nfunction point(event, el) {\n  var rect = el.getBoundingClientRect();\n  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];\n}\n\nfunction resolveItem(item, event, el, origin) {\n  var mark = item && item.mark,\n      mdef,\n      p;\n\n  if (mark && (mdef = Marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n\n    item = mdef.tip(mark.items, p);\n  }\n\n  return item;\n}\n/**\n * Create a new Handler instance.\n * @param {object} [customLoader] - Optional loader instance for\n *   href URL sanitization. If not specified, a standard loader\n *   instance will be generated.\n * @param {function} [customTooltip] - Optional tooltip handler\n *   function for custom tooltip display.\n * @constructor\n */\n\n\nfunction Handler(customLoader, customTooltip) {\n  this._active = null;\n  this._handlers = {};\n  this._loader = customLoader || loader();\n  this._tooltip = customTooltip || defaultTooltip;\n} // The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\n\n\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\n\nHandler.prototype = {\n  /**\n   * Initialize a new Handler instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {object} [obj] - Optional context object that should serve as\n   *   the \"this\" context for event callbacks.\n   * @return {Handler} - This handler instance.\n   */\n  initialize: function initialize(el, origin, obj) {\n    this._el = el;\n    this._obj = obj || null;\n    return this.origin(origin);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element: function element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas: function canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the origin coordinates of the visualization.\n   */\n  origin: function origin(_origin) {\n    if (arguments.length) {\n      this._origin = _origin || [0, 0];\n      return this;\n    } else {\n      return this._origin.slice();\n    }\n  },\n\n  /**\n   * Get / set the scenegraph root.\n   */\n  scene: function scene(_scene) {\n    if (!arguments.length) return this._scene;\n    this._scene = _scene;\n    return this;\n  },\n\n  /**\n   * Add an event handler. Subclasses should override this method.\n   */\n  on: function on()\n  /*type, handler*/\n  {},\n\n  /**\n   * Remove an event handler. Subclasses should override this method.\n   */\n  off: function off()\n  /*type, handler*/\n  {},\n\n  /**\n   * Utility method for finding the array index of an event handler.\n   * @param {Array} h - An array of registered event handlers.\n   * @param {string} type - The event type.\n   * @param {function} handler - The event handler instance to find.\n   * @return {number} - The handler's array index or -1 if not registered.\n   */\n  _handlerIndex: function _handlerIndex(h, type, handler) {\n    for (var i = h ? h.length : 0; --i >= 0;) {\n      if (h[i].type === type && (!handler || h[i].handler === handler)) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\n   * Returns an array with registered event handlers.\n   * @param {string} [type] - The event type to query. Any annotations\n   *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n   *   be ignored and the method returns all \"click\" handlers. If type is\n   *   null or unspecified, this method returns handlers for all types.\n   * @return {Array} - A new array containing all registered event handlers.\n   */\n  handlers: function handlers(type) {\n    var h = this._handlers,\n        a = [];\n\n    if (type) {\n      a.push.apply(a, _toConsumableArray(h[this.eventName(type)]));\n    } else {\n      for (var k in h) {\n        a.push.apply(a, _toConsumableArray(h[k]));\n      }\n    }\n\n    return a;\n  },\n\n  /**\n   * Parses an event name string to return the specific event type.\n   * For example, given \"click.foo\" returns \"click\"\n   * @param {string} name - The input event type string.\n   * @return {string} - A string with the event type only.\n   */\n  eventName: function eventName(name) {\n    var i = name.indexOf('.');\n    return i < 0 ? name : name.slice(0, i);\n  },\n\n  /**\n   * Handle hyperlink navigation in response to an item.href value.\n   * @param {Event} event - The event triggering hyperlink navigation.\n   * @param {Item} item - The scenegraph item.\n   * @param {string} href - The URL to navigate to.\n   */\n  handleHref: function handleHref(event, item, href) {\n    this._loader.sanitize(href, {\n      context: 'href'\n    }).then(function (opt) {\n      var e = new MouseEvent(event.type, event),\n          a = domCreate(null, 'a');\n\n      for (var name in opt) {\n        a.setAttribute(name, opt[name]);\n      }\n\n      a.dispatchEvent(e);\n    }).catch(function () {\n      /* do nothing */\n    });\n  },\n\n  /**\n   * Handle tooltip display in response to an item.tooltip value.\n   * @param {Event} event - The event triggering tooltip display.\n   * @param {Item} item - The scenegraph item.\n   * @param {boolean} show - A boolean flag indicating whether\n   *   to show or hide a tooltip for the given item.\n   */\n  handleTooltip: function handleTooltip(event, item, show) {\n    if (item && item.tooltip != null) {\n      item = resolveItem(item, event, this.canvas(), this._origin);\n\n      var _value = show && item && item.tooltip || null;\n\n      this._tooltip.call(this._obj, this, event, item, _value);\n    }\n  },\n\n  /**\n   * Returns the size of a scenegraph item and its position relative\n   * to the viewport.\n   * @param {Item} item - The scenegraph item.\n   * @return {object} - A bounding box object (compatible with the\n   *   DOMRect type) consisting of x, y, width, heigh, top, left,\n   *   right, and bottom properties.\n   */\n  getItemBoundingClientRect: function getItemBoundingClientRect(item) {\n    var el = this.canvas();\n    if (!el) return;\n    var rect = el.getBoundingClientRect(),\n        origin = this._origin,\n        bounds = item.bounds,\n        width = bounds.width(),\n        height = bounds.height();\n    var x = bounds.x1 + origin[0] + rect.left,\n        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group\n\n    while (item.mark && (item = item.mark.group)) {\n      x += item.x || 0;\n      y += item.y || 0;\n    } // return DOMRect-compatible bounding box\n\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      left: x,\n      top: y,\n      right: x + width,\n      bottom: y + height\n    };\n  }\n};\n/**\n * Create a new Renderer instance.\n * @param {object} [loader] - Optional loader instance for\n *   image and href URL sanitization. If not specified, a\n *   standard loader instance will be generated.\n * @constructor\n */\n\nfunction Renderer(loader) {\n  this._el = null;\n  this._bgcolor = null;\n  this._loader = new ResourceLoader(loader);\n}\n\nRenderer.prototype = {\n  /**\n   * Initialize a new Renderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance.\n   */\n  initialize: function initialize(el, width, height, origin, scaleFactor) {\n    this._el = el;\n    return this.resize(width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element: function element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas: function canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background: function background(bgcolor) {\n    if (arguments.length === 0) return this._bgcolor;\n    this._bgcolor = bgcolor;\n    return this;\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance;\n   */\n  resize: function resize(width, height, origin, scaleFactor) {\n    this._width = width;\n    this._height = height;\n    this._origin = origin || [0, 0];\n    this._scale = scaleFactor || 1;\n    return this;\n  },\n\n  /**\n   * Report a dirty item whose bounds should be redrawn.\n   * This base class method does nothing. Subclasses that perform\n   * incremental should implement this method.\n   * @param {Item} item - The dirty item whose bounds should be redrawn.\n   */\n  dirty: function dirty()\n  /*item*/\n  {},\n\n  /**\n   * Render an input scenegraph, potentially with a set of dirty items.\n   * This method will perform an immediate rendering with available resources.\n   * The renderer may also need to perform image loading to perform a complete\n   * render. This process can lead to asynchronous re-rendering of the scene\n   * after this method returns. To receive notification when rendering is\n   * complete, use the renderAsync method instead.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Renderer} - This renderer instance.\n   */\n  render: function render(scene) {\n    var r = this; // bind arguments into a render call, and cache it\n    // this function may be subsequently called for async redraw\n\n    r._call = function () {\n      r._render(scene);\n    }; // invoke the renderer\n\n\n    r._call(); // clear the cached call for garbage collection\n    // async redraws will stash their own copy\n\n\n    r._call = null;\n    return r;\n  },\n\n  /**\n   * Internal rendering method. Renderer subclasses should override this\n   * method to actually perform rendering.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render: function _render()\n  /*scene*/\n  {// subclasses to override\n  },\n\n  /**\n   * Asynchronous rendering method. Similar to render, but returns a Promise\n   * that resolves when all rendering is completed. Sometimes a renderer must\n   * perform image loading to get a complete rendering. The returned\n   * Promise will not resolve until this process completes.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Promise} - A Promise that resolves when rendering is complete.\n   */\n  renderAsync: function renderAsync(scene) {\n    var r = this.render(scene);\n    return this._ready ? this._ready.then(function () {\n      return r;\n    }) : Promise.resolve(r);\n  },\n\n  /**\n   * Internal method for asynchronous resource loading.\n   * Proxies method calls to the ImageLoader, and tracks loading\n   * progress to invoke a re-render once complete.\n   * @param {string} method - The method name to invoke on the ImageLoader.\n   * @param {string} uri - The URI for the requested resource.\n   * @return {Promise} - A Promise that resolves to the requested resource.\n   */\n  _load: function _load(method, uri) {\n    var r = this,\n        p = r._loader[method](uri);\n\n    if (!r._ready) {\n      // re-render the scene when loading completes\n      var call = r._call;\n      r._ready = r._loader.ready().then(function (redraw) {\n        if (redraw) call();\n        r._ready = null;\n      });\n    }\n\n    return p;\n  },\n\n  /**\n   * Sanitize a URL to include as a hyperlink in the rendered scene.\n   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string to sanitize.\n   * @return {Promise} - A Promise that resolves to the sanitized URL.\n   */\n  sanitizeURL: function sanitizeURL(uri) {\n    return this._load('sanitizeURL', uri);\n  },\n\n  /**\n   * Requests an image to include in the rendered scene.\n   * This method proxies a call to ImageLoader.loadImage, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string of the image.\n   * @return {Promise} - A Promise that resolves to the loaded Image.\n   */\n  loadImage: function loadImage(uri) {\n    return this._load('loadImage', uri);\n  }\n};\nvar KeyDownEvent = 'keydown';\nvar KeyPressEvent = 'keypress';\nvar KeyUpEvent = 'keyup';\nvar DragEnterEvent = 'dragenter';\nvar DragLeaveEvent = 'dragleave';\nvar DragOverEvent = 'dragover';\nvar MouseDownEvent = 'mousedown';\nvar MouseUpEvent = 'mouseup';\nvar MouseMoveEvent = 'mousemove';\nvar MouseOutEvent = 'mouseout';\nvar MouseOverEvent = 'mouseover';\nvar ClickEvent = 'click';\nvar DoubleClickEvent = 'dblclick';\nvar WheelEvent = 'wheel';\nvar MouseWheelEvent = 'mousewheel';\nvar TouchStartEvent = 'touchstart';\nvar TouchMoveEvent = 'touchmove';\nvar TouchEndEvent = 'touchend';\nvar Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];\nvar TooltipShowEvent = MouseMoveEvent;\nvar TooltipHideEvent = MouseOutEvent;\nvar HrefEvent = ClickEvent;\n\nfunction CanvasHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n  this._events = {};\n}\n\nvar eventBundle = function eventBundle(type) {\n  return type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type];\n}; // lazily add listeners to the canvas as needed\n\n\nfunction eventListenerCheck(handler, type) {\n  eventBundle(type).forEach(function (_) {\n    return addEventListener(handler, _);\n  });\n}\n\nfunction addEventListener(handler, type) {\n  var canvas = handler.canvas();\n\n  if (canvas && !handler._events[type]) {\n    handler._events[type] = 1;\n    canvas.addEventListener(type, handler[type] ? function (evt) {\n      return handler[type](evt);\n    } : function (evt) {\n      return handler.fire(type, evt);\n    });\n  }\n}\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function (evt) {\n    var a = this._active,\n        p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        this.fire(outEvent, evt);\n      }\n\n      this._active = p; // set new active item\n\n      this.fire(overEvent, evt); // fire over for new active item\n\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function (evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\ninherits(CanvasHandler, Handler, {\n  initialize: function initialize(el, origin, obj) {\n    var _this4 = this;\n\n    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management\n\n    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(function (type) {\n      return eventListenerCheck(_this4, type);\n    });\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n  // return the backing canvas instance\n  canvas: function canvas() {\n    return this._canvas;\n  },\n  // retrieve the current canvas context\n  context: function context() {\n    return this._canvas.getContext('2d');\n  },\n  // supported events\n  events: Events,\n  // to keep old versions of firefox happy\n  DOMMouseScroll: function DOMMouseScroll(evt) {\n    this.fire(MouseWheelEvent, evt);\n  },\n  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),\n  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),\n  mouseout: inactive(MouseOutEvent),\n  dragleave: inactive(DragLeaveEvent),\n  mousedown: function mousedown(evt) {\n    this._down = this._active;\n    this.fire(MouseDownEvent, evt);\n  },\n  click: function click(evt) {\n    if (this._down === this._active) {\n      this.fire(ClickEvent, evt);\n      this._down = null;\n    }\n  },\n  touchstart: function touchstart(evt) {\n    this._touch = this.pickEvent(evt.changedTouches[0]);\n\n    if (this._first) {\n      this._active = this._touch;\n      this._first = false;\n    }\n\n    this.fire(TouchStartEvent, evt, true);\n  },\n  touchmove: function touchmove(evt) {\n    this.fire(TouchMoveEvent, evt, true);\n  },\n  touchend: function touchend(evt) {\n    this.fire(TouchEndEvent, evt, true);\n    this._touch = null;\n  },\n  // fire an event\n  fire: function fire(type, evt, touch) {\n    var a = touch ? this._touch : this._active,\n        h = this._handlers[type]; // set event type relative to scenegraph items\n\n    evt.vegaType = type; // handle hyperlinks and tooltips first\n\n    if (type === HrefEvent && a && a.href) {\n      this.handleHref(evt, a, a.href);\n    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n      this.handleTooltip(evt, a, type !== TooltipHideEvent);\n    } // invoke all registered handlers\n\n\n    if (h) {\n      for (var i = 0, len = h.length; i < len; ++i) {\n        h[i].handler.call(this._obj, evt, a);\n      }\n    }\n  },\n  // add an event handler\n  on: function on(type, handler) {\n    var name = this.eventName(type),\n        h = this._handlers,\n        i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      eventListenerCheck(this, type);\n      (h[name] || (h[name] = [])).push({\n        type: type,\n        handler: handler\n      });\n    }\n\n    return this;\n  },\n  // remove an event handler\n  off: function off(type, handler) {\n    var name = this.eventName(type),\n        h = this._handlers[name],\n        i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      h.splice(i, 1);\n    }\n\n    return this;\n  },\n  pickEvent: function pickEvent(evt) {\n    var p = point(evt, this._canvas),\n        o = this._origin;\n    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n  },\n  // find the scenegraph item at the current mouse position\n  // x, y -- the absolute x, y mouse coordinates on the canvas element\n  // gx, gy -- the relative coordinates within the current group\n  pick: function pick(scene, x, y, gx, gy) {\n    var g = this.context(),\n        mark = Marks[scene.marktype];\n    return mark.pick.call(this, g, scene, x, y, gx, gy);\n  }\n});\n\nfunction devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\n\nvar pixelRatio = devicePixelRatio();\n\nfunction _resize(canvas, width, height, origin, scaleFactor, opt) {\n  var inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,\n      context = canvas.getContext('2d'),\n      ratio = inDOM ? pixelRatio : scaleFactor;\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n\n  for (var key in opt) {\n    context[key] = opt[key];\n  }\n\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  context.pixelRatio = ratio;\n  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);\n  return canvas;\n}\n\nfunction CanvasRenderer(loader) {\n  Renderer.call(this, loader);\n  this._options = {};\n  this._redraw = false;\n  this._dirty = new Bounds();\n  this._tempb = new Bounds();\n}\n\nvar base$1 = Renderer.prototype;\n\nvar viewBounds = function viewBounds(origin, width, height) {\n  return new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);\n};\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)\n\n  if (g.pixelRatio % 1) {\n    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n  } // to avoid artifacts translate if origin has fractional pixels\n\n\n  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path\n\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n  return b;\n}\n\ninherits(CanvasRenderer, Renderer, {\n  initialize: function initialize(el, width, height, origin, scaleFactor, options) {\n    this._options = options || {};\n    this._canvas = this._options.externalContext ? null : canvas(1, 1, this._options.type); // instantiate a small canvas\n\n    if (el && this._canvas) {\n      domClear(el, 0).appendChild(this._canvas);\n\n      this._canvas.setAttribute('class', 'marks');\n    } // this method will invoke resize to size the canvas appropriately\n\n\n    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n  resize: function resize(width, height, origin, scaleFactor) {\n    base$1.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._canvas) {\n      // configure canvas size and transform\n      _resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);\n    } else {\n      // external context needs to be scaled and positioned to origin\n      var ctx = this._options.externalContext;\n      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');\n      ctx.scale(this._scale, this._scale);\n      ctx.translate(this._origin[0], this._origin[1]);\n    }\n\n    this._redraw = true;\n    return this;\n  },\n  canvas: function canvas() {\n    return this._canvas;\n  },\n  context: function context() {\n    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);\n  },\n  dirty: function dirty(item) {\n    var b = this._tempb.clear().union(item.bounds);\n\n    var g = item.mark.group;\n\n    while (g) {\n      b.translate(g.x || 0, g.y || 0);\n      g = g.mark.group;\n    }\n\n    this._dirty.union(b);\n  },\n  _render: function _render(scene) {\n    var g = this.context(),\n        o = this._origin,\n        w = this._width,\n        h = this._height,\n        db = this._dirty,\n        vb = viewBounds(o, w, h); // setup\n\n    g.save();\n    var b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);\n    this.clear(-o[0], -o[1], w, h); // render\n\n    this.draw(g, scene, b); // takedown\n\n    g.restore();\n    db.clear();\n    return this;\n  },\n  draw: function draw(ctx, scene, bounds) {\n    var mark = Marks[scene.marktype];\n    if (scene.clip) clip(ctx, scene);\n    mark.draw.call(this, ctx, scene, bounds);\n    if (scene.clip) ctx.restore();\n  },\n  clear: function clear(x, y, w, h) {\n    var opt = this._options,\n        g = this.context();\n\n    if (opt.type !== 'pdf' && !opt.externalContext) {\n      // calling clear rect voids vector output in pdf mode\n      // and could remove external context content (#2615)\n      g.clearRect(x, y, w, h);\n    }\n\n    if (this._bgcolor != null) {\n      g.fillStyle = this._bgcolor;\n      g.fillRect(x, y, w, h);\n    }\n  }\n});\n\nfunction SVGHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  var h = this;\n  h._hrefHandler = listener(h, function (evt, item) {\n    if (item && item.href) h.handleHref(evt, item, item.href);\n  });\n  h._tooltipHandler = listener(h, function (evt, item) {\n    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n  });\n} // wrap an event listener for the SVG DOM\n\n\nvar listener = function listener(context, handler) {\n  return function (evt) {\n    var item = evt.target.__data__;\n    item = Array.isArray(item) ? item[0] : item;\n    evt.vegaType = evt.type;\n    handler.call(context._obj, evt, item);\n  };\n};\n\ninherits(SVGHandler, Handler, {\n  initialize: function initialize(el, origin, obj) {\n    var svg = this._svg;\n\n    if (svg) {\n      svg.removeEventListener(HrefEvent, this._hrefHandler);\n      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    this._svg = svg = el && domFind(el, 'svg');\n\n    if (svg) {\n      svg.addEventListener(HrefEvent, this._hrefHandler);\n      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n  canvas: function canvas() {\n    return this._svg;\n  },\n  // add an event handler\n  on: function on(type, handler) {\n    var name = this.eventName(type),\n        h = this._handlers,\n        i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      var _x2 = {\n        type: type,\n        handler: handler,\n        listener: listener(this, handler)\n      };\n      (h[name] || (h[name] = [])).push(_x2);\n\n      if (this._svg) {\n        this._svg.addEventListener(name, _x2.listener);\n      }\n    }\n\n    return this;\n  },\n  // remove an event handler\n  off: function off(type, handler) {\n    var name = this.eventName(type),\n        h = this._handlers[name],\n        i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      if (this._svg) {\n        this._svg.removeEventListener(name, h[i].listener);\n      }\n\n      h.splice(i, 1);\n    }\n\n    return this;\n  }\n});\nvar ARIA_HIDDEN = 'aria-hidden';\nvar ARIA_LABEL = 'aria-label';\nvar ARIA_ROLE = 'role';\nvar ARIA_ROLEDESCRIPTION = 'aria-roledescription';\nvar GRAPHICS_OBJECT = 'graphics-object';\nvar GRAPHICS_SYMBOL = 'graphics-symbol';\n\nvar bundle = function bundle(role, roledesc, label) {\n  var _ref;\n\n  return _ref = {}, _defineProperty(_ref, ARIA_ROLE, role), _defineProperty(_ref, ARIA_ROLEDESCRIPTION, roledesc), _defineProperty(_ref, ARIA_LABEL, label || undefined), _ref;\n}; // these roles are covered by related roles\n// we can ignore them, no need to generate attributes\n\n\nvar AriaIgnore = toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles\n\nvar AriaGuides = {\n  'axis': {\n    desc: 'axis',\n    caption: axisCaption\n  },\n  'legend': {\n    desc: 'legend',\n    caption: legendCaption\n  },\n  'title-text': {\n    desc: 'title',\n    caption: function caption(item) {\n      return \"Title text '\".concat(titleCaption(item), \"'\");\n    }\n  },\n  'title-subtitle': {\n    desc: 'subtitle',\n    caption: function caption(item) {\n      return \"Subtitle text '\".concat(titleCaption(item), \"'\");\n    }\n  }\n}; // aria properties generated for mark item encoding channels\n\nvar AriaEncode = {\n  ariaRole: ARIA_ROLE,\n  ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n  description: ARIA_LABEL\n};\n\nfunction ariaItemAttributes(emit, item) {\n  var hide = item.aria === false;\n  emit(ARIA_HIDDEN, hide || undefined);\n\n  if (hide || item.description == null) {\n    for (var prop in AriaEncode) {\n      emit(AriaEncode[prop], undefined);\n    }\n  } else {\n    var _type = item.mark.marktype;\n    emit(ARIA_LABEL, item.description);\n    emit(ARIA_ROLE, item.ariaRole || (_type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));\n    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || \"\".concat(_type, \" mark\"));\n  }\n}\n\nfunction ariaMarkAttributes(mark) {\n  return mark.aria === false ? _defineProperty({}, ARIA_HIDDEN, true) : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);\n}\n\nfunction ariaMark(mark) {\n  var type = mark.marktype;\n  var recurse = type === 'group' || type === 'text' || mark.items.some(function (_) {\n    return _.description != null && _.aria !== false;\n  });\n  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, \"\".concat(type, \" mark container\"), mark.description);\n}\n\nfunction ariaGuide(mark, opt) {\n  try {\n    var item = mark.items[0],\n        caption = opt.caption || function () {\n      return '';\n    };\n\n    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction titleCaption(item) {\n  return array(item.text).join(' ');\n}\n\nfunction axisCaption(item) {\n  var datum = item.datum,\n      orient = item.orient,\n      title = datum.title ? extractTitle(item) : null,\n      ctx = item.context,\n      scale = ctx.scales[datum.scale].value,\n      locale = ctx.dataflow.locale(),\n      type = scale.type,\n      xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';\n  return \"\".concat(xy, \"-axis\") + (title ? \" titled '\".concat(title, \"'\") : '') + \" for a \".concat(isDiscrete(type) ? 'discrete' : type, \" scale\") + \" with \".concat(domainCaption(locale, scale, item));\n}\n\nfunction legendCaption(item) {\n  var datum = item.datum,\n      title = datum.title ? extractTitle(item) : null,\n      type = \"\".concat(datum.type || '', \" legend\").trim(),\n      scales = datum.scales,\n      props = Object.keys(scales),\n      ctx = item.context,\n      scale = ctx.scales[scales[props[0]]].value,\n      locale = ctx.dataflow.locale();\n  return capitalize(type) + (title ? \" titled '\".concat(title, \"'\") : '') + \" for \".concat(channelCaption(props)) + \" with \".concat(domainCaption(locale, scale, item));\n}\n\nfunction extractTitle(item) {\n  try {\n    return array(peek(item.items).items[0].text).join(' ');\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction channelCaption(props) {\n  props = props.map(function (p) {\n    return p + (p === 'fill' || p === 'stroke' ? ' color' : '');\n  });\n  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + peek(props);\n}\n\nfunction capitalize(s) {\n  return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n}\n\nvar innerText = function innerText(val) {\n  return (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n};\n\nvar attrText = function attrText(val) {\n  return innerText(val).replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n};\n\nfunction markup() {\n  var buf = '',\n      outer = '',\n      inner = '';\n\n  var stack = [],\n      clear = function clear() {\n    return outer = inner = '';\n  },\n      push = function push(tag) {\n    if (outer) {\n      buf += \"\".concat(outer, \">\").concat(inner);\n      clear();\n    }\n\n    stack.push(tag);\n  },\n      attr = function attr(name, value) {\n    if (value != null) outer += \" \".concat(name, \"=\\\"\").concat(attrText(value), \"\\\"\");\n    return m;\n  },\n      m = {\n    open: function open(tag) {\n      push(tag);\n      outer = '<' + tag;\n\n      for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        attrs[_key - 1] = arguments[_key];\n      }\n\n      for (var _i = 0, _attrs = attrs; _i < _attrs.length; _i++) {\n        var set = _attrs[_i];\n\n        for (var key in set) {\n          attr(key, set[key]);\n        }\n      }\n\n      return m;\n    },\n    close: function close() {\n      var tag = stack.pop();\n\n      if (outer) {\n        buf += outer + (inner ? \">\".concat(inner, \"</\").concat(tag, \">\") : '/>');\n      } else {\n        buf += \"</\".concat(tag, \">\");\n      }\n\n      clear();\n      return m;\n    },\n    attr: attr,\n    text: function text(t) {\n      return inner += innerText(t), m;\n    },\n    toString: function toString() {\n      return buf;\n    }\n  };\n\n  return m;\n}\n\nvar serializeXML = function serializeXML(node) {\n  return _serialize(markup(), node) + '';\n};\n\nfunction _serialize(m, node) {\n  m.open(node.tagName);\n\n  if (node.hasAttributes()) {\n    var attrs = node.attributes,\n        n = attrs.length;\n\n    for (var i = 0; i < n; ++i) {\n      m.attr(attrs[i].name, attrs[i].value);\n    }\n  }\n\n  if (node.hasChildNodes()) {\n    var children = node.childNodes,\n        _n = children.length;\n\n    for (var _i2 = 0; _i2 < _n; _i2++) {\n      var child = children[_i2];\n      child.nodeType === 3 // text node\n      ? m.text(child.nodeValue) : _serialize(m, child);\n    }\n  }\n\n  return m.close();\n}\n\nvar styles = {\n  fill: 'fill',\n  fillOpacity: 'fill-opacity',\n  stroke: 'stroke',\n  strokeOpacity: 'stroke-opacity',\n  strokeWidth: 'stroke-width',\n  strokeCap: 'stroke-linecap',\n  strokeJoin: 'stroke-linejoin',\n  strokeDash: 'stroke-dasharray',\n  strokeDashOffset: 'stroke-dashoffset',\n  strokeMiterLimit: 'stroke-miterlimit',\n  opacity: 'opacity',\n  blend: 'mix-blend-mode'\n}; // ensure miter limit default is consistent with canvas (#2498)\n\nvar rootAttributes = {\n  'fill': 'none',\n  'stroke-miterlimit': 10\n};\nvar RootIndex = 0,\n    xmlns = 'http://www.w3.org/2000/xmlns/',\n    svgns = metadata.xmlns;\n\nfunction SVGRenderer(loader) {\n  Renderer.call(this, loader);\n  this._dirtyID = 0;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\n\nvar base = Renderer.prototype;\ninherits(SVGRenderer, Renderer, {\n  /**\n   * Initialize a new SVGRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance.\n   */\n  initialize: function initialize(el, width, height, origin, scaleFactor) {\n    // create the svg definitions cache\n    this._defs = {};\n\n    this._clearDefs();\n\n    if (el) {\n      this._svg = domChild(el, 0, 'svg', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);\n\n      this._svg.setAttribute('version', metadata['version']);\n\n      this._svg.setAttribute('class', 'marks');\n\n      domClear(el, 1); // set the svg root group\n\n      this._root = domChild(this._svg, RootIndex, 'g', svgns);\n      setAttributes(this._root, rootAttributes); // ensure no additional child elements\n\n      domClear(this._svg, RootIndex + 1);\n    } // set background color if defined\n\n\n    this.background(this._bgcolor);\n    return base.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background: function background(bgcolor) {\n    if (arguments.length && this._svg) {\n      this._svg.style.setProperty('background-color', bgcolor);\n    }\n\n    return base.background.apply(this, arguments);\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize: function resize(width, height, origin, scaleFactor) {\n    base.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._svg) {\n      setAttributes(this._svg, {\n        width: this._width * this._scale,\n        height: this._height * this._scale,\n        viewBox: \"0 0 \".concat(this._width, \" \").concat(this._height)\n      });\n\n      this._root.setAttribute('transform', \"translate(\".concat(this._origin, \")\"));\n    }\n\n    this._dirty = [];\n    return this;\n  },\n\n  /**\n   * Returns the SVG element of the visualization.\n   * @return {DOMElement} - The SVG element.\n   */\n  canvas: function canvas() {\n    return this._svg;\n  },\n\n  /**\n   * Returns an SVG text string for the rendered content,\n   * or null if this renderer is currently headless.\n   */\n  svg: function svg() {\n    var svg = this._svg,\n        bg = this._bgcolor;\n    if (!svg) return null;\n    var node;\n\n    if (bg) {\n      svg.removeAttribute('style');\n      node = domChild(svg, RootIndex, 'rect', svgns);\n      setAttributes(node, {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      });\n    }\n\n    var text = serializeXML(svg);\n\n    if (bg) {\n      svg.removeChild(node);\n\n      this._svg.style.setProperty('background-color', bg);\n    }\n\n    return text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render: function _render(scene) {\n    // perform spot updates and re-render markup\n    if (this._dirtyCheck()) {\n      if (this._dirtyAll) this._clearDefs();\n      this.mark(this._root, scene);\n      domClear(this._root, 1);\n    }\n\n    this.defs();\n    this._dirty = [];\n    ++this._dirtyID;\n    return this;\n  },\n  // -- Manage rendering of items marked as dirty --\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty: function dirty(item) {\n    if (item.dirty !== this._dirtyID) {\n      item.dirty = this._dirtyID;\n\n      this._dirty.push(item);\n    }\n  },\n\n  /**\n   * Check if a mark item is considered dirty.\n   * @param {Item} item - The mark item.\n   */\n  isDirty: function isDirty(item) {\n    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;\n  },\n\n  /**\n   * Internal method to check dirty status and, if possible,\n   * make targetted updates without a full rendering pass.\n   */\n  _dirtyCheck: function _dirtyCheck() {\n    this._dirtyAll = true;\n    var items = this._dirty;\n    if (!items.length || !this._dirtyID) return true;\n    var id = ++this._dirtyID;\n    var item, mark, type, mdef, i, n, o;\n\n    for (i = 0, n = items.length; i < n; ++i) {\n      item = items[i];\n      mark = item.mark;\n\n      if (mark.marktype !== type) {\n        // memoize mark instance lookup\n        type = mark.marktype;\n        mdef = Marks[type];\n      }\n\n      if (mark.zdirty && mark.dirty !== id) {\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n        mark.items.forEach(function (i) {\n          i.dirty = id;\n        });\n      }\n\n      if (mark.zdirty) continue; // handle in standard drawing pass\n\n      if (item.exit) {\n        // EXIT\n        if (mdef.nested && mark.items.length) {\n          // if nested mark with remaining points, update instead\n          o = mark.items[0];\n          if (o._svg) this._update(mdef, o._svg, o);\n        } else if (item._svg) {\n          // otherwise remove from DOM\n          o = item._svg.parentNode;\n          if (o) o.removeChild(item._svg);\n        }\n\n        item._svg = null;\n        continue;\n      }\n\n      item = mdef.nested ? mark.items[0] : item;\n      if (item._update === id) continue; // already visited\n\n      if (!item._svg || !item._svg.ownerSVGElement) {\n        // ENTER\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n      } else {\n        // IN-PLACE UPDATE\n        this._update(mdef, item._svg, item);\n      }\n\n      item._update = id;\n    }\n\n    return !this._dirtyAll;\n  },\n  // -- Construct & maintain scenegraph to SVG mapping ---\n\n  /**\n   * Render a set of mark items.\n   * @param {SVGElement} el - The parent element in the SVG tree.\n   * @param {object} scene - The mark parent to render.\n   * @param {SVGElement} prev - The previous sibling in the SVG tree.\n   */\n  mark: function mark(el, scene, prev) {\n    var _this5 = this;\n\n    if (!this.isDirty(scene)) return scene._svg;\n    var svg = this._svg,\n        mdef = Marks[scene.marktype],\n        events = scene.interactive === false ? 'none' : null,\n        isGroup = mdef.tag === 'g';\n    var sibling = null,\n        i = 0;\n    var parent = bind(scene, el, prev, 'g', svg);\n    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element\n\n    var aria = ariaMarkAttributes(scene);\n\n    for (var key in aria) {\n      setAttribute(parent, key, aria[key]);\n    }\n\n    if (!isGroup) {\n      setAttribute(parent, 'pointer-events', events);\n    }\n\n    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);\n\n    var process = function process(item) {\n      var dirty = _this5.isDirty(item),\n          node = bind(item, parent, sibling, mdef.tag, svg);\n\n      if (dirty) {\n        _this5._update(mdef, node, item);\n\n        if (isGroup) recurse(_this5, node, item);\n      }\n\n      sibling = node;\n      ++i;\n    };\n\n    if (mdef.nested) {\n      if (scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    domClear(parent, i);\n    return parent;\n  },\n\n  /**\n   * Update the attributes of an SVG element for a mark item.\n   * @param {object} mdef - The mark definition object\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  _update: function _update(mdef, el, item) {\n    // set dom element and values cache\n    // provides access to emit method\n    element = el;\n    values = el.__values__; // apply aria-specific properties\n\n    ariaItemAttributes(emit, item); // apply svg attributes\n\n    mdef.attr(emit, item, this); // some marks need special treatment\n\n    var extra = mark_extras[mdef.type];\n    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes\n    // note: element state may have been modified by 'extra' method\n\n    if (element) this.style(element, item);\n  },\n\n  /**\n   * Update the presentation attributes of an SVG element for a mark item.\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  style: function style(el, item) {\n    if (item == null) return;\n\n    for (var prop in styles) {\n      var _value2 = prop === 'font' ? fontFamily(item) : item[prop];\n\n      if (_value2 === values[prop]) continue;\n      var name = styles[prop];\n\n      if (_value2 == null) {\n        el.removeAttribute(name);\n      } else {\n        if (isGradient(_value2)) {\n          _value2 = gradientRef(_value2, this._defs.gradient, href());\n        }\n\n        el.setAttribute(name, _value2 + '');\n      }\n\n      values[prop] = _value2;\n    }\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   */\n  defs: function defs() {\n    var svg = this._svg,\n        defs = this._defs;\n    var el = defs.el,\n        index = 0;\n\n    for (var id in defs.gradient) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateGradient(el, defs.gradient[id], index);\n    }\n\n    for (var _id in defs.clipping) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateClipping(el, defs.clipping[_id], index);\n    } // clean-up\n\n\n    if (el) {\n      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);\n    }\n  },\n\n  /**\n   * Clear defs caches.\n   */\n  _clearDefs: function _clearDefs() {\n    var def = this._defs;\n    def.gradient = {};\n    def.clipping = {};\n  }\n}); // mark ancestor chain with a dirty id\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n} // update gradient definitions\n\n\nfunction updateGradient(el, grad, index) {\n  var i, n, stop;\n\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // We wrap the radial gradient in a pattern element, allowing us to\n    // maintain a circular gradient that matches what canvas provides.\n    var pt = domChild(el, index++, 'pattern', svgns);\n    setAttributes(pt, {\n      id: patternPrefix + grad.id,\n      viewBox: '0,0,1,1',\n      width: '100%',\n      height: '100%',\n      preserveAspectRatio: 'xMidYMid slice'\n    });\n    pt = domChild(pt, 0, 'rect', svgns);\n    setAttributes(pt, {\n      width: 1,\n      height: 1,\n      fill: \"url(\".concat(href(), \"#\").concat(grad.id, \")\")\n    });\n    el = domChild(el, index++, 'radialGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      fx: grad.x1,\n      fy: grad.y1,\n      fr: grad.r1,\n      cx: grad.x2,\n      cy: grad.y2,\n      r: grad.r2\n    });\n  } else {\n    el = domChild(el, index++, 'linearGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      x1: grad.x1,\n      x2: grad.x2,\n      y1: grad.y1,\n      y2: grad.y2\n    });\n  }\n\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = domChild(el, i, 'stop', svgns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n\n  domClear(el, i);\n  return index;\n} // update clipping path definitions\n\n\nfunction updateClipping(el, clip, index) {\n  var mask;\n  el = domChild(el, index, 'clipPath', svgns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', svgns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', svgns);\n    setAttributes(mask, {\n      x: 0,\n      y: 0,\n      width: clip.width,\n      height: clip.height\n    });\n  }\n\n  domClear(el, 1);\n  return index + 1;\n} // Recursively process group contents.\n\n\nfunction recurse(renderer, el, group) {\n  el = el.lastChild.previousSibling;\n  var prev,\n      idx = 0;\n  visit(group, function (item) {\n    prev = renderer.mark(el, item, prev);\n    ++idx;\n  }); // remove any extraneous DOM elements\n\n  domClear(el, 1 + idx);\n} // Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\n\n\nfunction bind(item, el, sibling, tag, svg) {\n  var node = item._svg,\n      doc; // create a new dom node if needed\n\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, svgns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {\n        fill: 'default'\n      }; // if group, create background, content, and foreground elements\n\n      if (tag === 'g') {\n        var bg = domCreate(doc, 'path', svgns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n        var cg = domCreate(doc, 'g', svgns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n        var fg = domCreate(doc, 'path', svgns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {\n          fill: 'default'\n        };\n      }\n    }\n  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n\n\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n} // check if two nodes are ordered siblings\n\n\nfunction siblingCheck(node, sibling) {\n  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same\n} // -- Set attributes & styles on SVG elements ---\n\n\nvar element = null,\n    // temp var for current SVG element\nvalues = null; // temp var for current values hash\n// Extra configuration for certain mark types\n\nvar mark_extras = {\n  group: function group(mdef, el, item) {\n    var fg = element = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n    values = el.__values__; // use parent's values hash\n\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n    var bg = element = el.childNodes[0];\n    mdef.background(emit, item, this);\n    var value = item.mark.interactive === false ? 'none' : null;\n\n    if (value !== values.events) {\n      setAttribute(fg, 'pointer-events', value);\n      setAttribute(bg, 'pointer-events', value);\n      values.events = value;\n    }\n\n    if (item.strokeForeground && item.stroke) {\n      var _fill = item.fill;\n      setAttribute(fg, 'display', null); // set style of background\n\n      this.style(bg, item);\n      setAttribute(bg, 'stroke', null); // set style of foreground\n\n      if (_fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (_fill) item.fill = _fill; // leave element null to prevent downstream styling\n\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      setAttribute(fg, 'display', 'none');\n    }\n  },\n  image: function image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n  text: function text(mdef, el, item) {\n    var tl = textLines(item);\n    var key, value, doc, lh;\n\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(function (_) {\n        return textValue(item, _);\n      });\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach(function (t, i) {\n          var ts = domCreate(doc, 'tspan', svgns);\n          ts.__data__ = item; // data binding\n\n          ts.textContent = t;\n\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n\n    setAttribute(el, 'font-family', fontFamily(item));\n    setAttribute(el, 'font-size', fontSize(item) + 'px');\n    setAttribute(el, 'font-style', item.fontStyle);\n    setAttribute(el, 'font-variant', item.fontVariant);\n    setAttribute(el, 'font-weight', item.fontWeight);\n  }\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return; // use appropriate method given namespace (ns)\n\n  if (ns) {\n    setAttributeNS(element, name, value, ns);\n  } else {\n    setAttribute(element, name, value);\n  } // note current value for future comparison\n\n\n  values[name] = value;\n}\n\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n\n    values[name] = value;\n  }\n}\n\nfunction setAttributes(el, attrs) {\n  for (var key in attrs) {\n    setAttribute(el, key, attrs[key]);\n  }\n}\n\nfunction setAttribute(el, name, value) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttribute(name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttribute(name);\n  }\n}\n\nfunction setAttributeNS(el, name, value, ns) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttributeNS(ns, name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttributeNS(ns, name);\n  }\n}\n\nfunction href() {\n  var loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}\n\nfunction SVGStringRenderer(loader) {\n  Renderer.call(this, loader);\n  this._text = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n}\n\ninherits(SVGStringRenderer, Renderer, {\n  /**\n   * Returns the rendered SVG text string,\n   * or null if rendering has not yet occurred.\n   */\n  svg: function svg() {\n    return this._text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render: function _render(scene) {\n    var m = markup(); // svg tag\n\n    m.open('svg', extend({}, metadata, {\n      class: 'marks',\n      width: this._width * this._scale,\n      height: this._height * this._scale,\n      viewBox: \"0 0 \".concat(this._width, \" \").concat(this._height)\n    })); // background, if defined\n\n    var bg = this._bgcolor;\n\n    if (bg && bg !== 'transparent' && bg !== 'none') {\n      m.open('rect', {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      }).close();\n    } // root content group\n\n\n    m.open('g', rootAttributes, {\n      transform: 'translate(' + this._origin + ')'\n    });\n    this.mark(m, scene);\n    m.close(); // </g>\n    // defs\n\n    this.defs(m); // get SVG text string\n\n    this._text = m.close() + '';\n    return this;\n  },\n\n  /**\n   * Render a set of mark items.\n   * @param {object} m - The markup context.\n   * @param {object} scene - The mark parent to render.\n   */\n  mark: function mark(m, scene) {\n    var _this6 = this;\n\n    var mdef = Marks[scene.marktype],\n        tag = mdef.tag,\n        attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag\n\n    m.open('g', {\n      'class': cssClass(scene),\n      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null\n    }, ariaMarkAttributes(scene), {\n      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n    }); // render contained elements\n\n    var process = function process(item) {\n      var href = _this6.href(item);\n\n      if (href) m.open('a', href);\n      m.open(tag, _this6.attr(scene, item, attrList, tag !== 'g' ? tag : null));\n\n      if (tag === 'text') {\n        var _tl = textLines(item);\n\n        if (isArray(_tl)) {\n          // multi-line text\n          var attrs = {\n            x: 0,\n            dy: lineHeight(item)\n          };\n\n          for (var i = 0; i < _tl.length; ++i) {\n            m.open('tspan', i ? attrs : null).text(textValue(item, _tl[i])).close();\n          }\n        } else {\n          // single-line text\n          m.text(textValue(item, _tl));\n        }\n      } else if (tag === 'g') {\n        var fore = item.strokeForeground,\n            _fill2 = item.fill,\n            _stroke = item.stroke;\n\n        if (fore && _stroke) {\n          item.stroke = null;\n        }\n\n        m.open('path', _this6.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content\n\n        m.open('g', _this6.attr(scene, item, mdef.content));\n        visit(item, function (scene) {\n          return _this6.mark(m, scene);\n        });\n        m.close();\n\n        if (fore && _stroke) {\n          if (_fill2) item.fill = null;\n          item.stroke = _stroke;\n          m.open('path', _this6.attr(scene, item, mdef.foreground, 'bgrect')).close();\n          if (_fill2) item.fill = _fill2;\n        } else {\n          m.open('path', _this6.attr(scene, item, mdef.foreground, 'bgfore')).close();\n        }\n      }\n\n      m.close(); // </tag>\n\n      if (href) m.close(); // </a>\n    };\n\n    if (mdef.nested) {\n      if (scene.items && scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    } // render closing group tag\n\n\n    return m.close(); // </g>\n  },\n\n  /**\n   * Get href attributes for a hyperlinked mark item.\n   * @param {Item} item - The mark item.\n   */\n  href: function href(item) {\n    var _this7 = this;\n\n    var href = item.href;\n    var attr;\n\n    if (href) {\n      if (attr = this._hrefs && this._hrefs[href]) {\n        return attr;\n      } else {\n        this.sanitizeURL(href).then(function (attr) {\n          // rewrite to use xlink namespace\n          attr['xlink:href'] = attr.href;\n          attr.href = null;\n          (_this7._hrefs || (_this7._hrefs = {}))[href] = attr;\n        });\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Get an object of SVG attributes for a mark item.\n   * @param {object} scene - The mark parent.\n   * @param {Item} item - The mark item.\n   * @param {array|function} attrs - One or more attribute emitters.\n   * @param {string} tag - The tag being rendered.\n   */\n  attr: function attr(scene, item, attrs, tag) {\n    var _this8 = this;\n\n    var object = {},\n        emit = function emit(name, value, ns, prefixed) {\n      object[prefixed || name] = value;\n    }; // apply mark specific attributes\n\n\n    if (Array.isArray(attrs)) {\n      attrs.forEach(function (fn) {\n        return fn(emit, item, _this8);\n      });\n    } else {\n      attrs(emit, item, this);\n    } // apply style attributes\n\n\n    if (tag) {\n      style(object, item, scene, tag, this._defs);\n    }\n\n    return object;\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   * @param {object} m - The markup context.\n   */\n  defs: function defs(m) {\n    var gradient = this._defs.gradient,\n        clipping = this._defs.clipping,\n        count = Object.keys(gradient).length + Object.keys(clipping).length;\n    if (count === 0) return; // nothing to do\n\n    m.open('defs');\n\n    for (var id in gradient) {\n      var _def = gradient[id],\n          stops = _def.stops;\n\n      if (_def.gradient === 'radial') {\n        // SVG radial gradients automatically transform to normalized bbox\n        // coordinates, in a way that is cumbersome to replicate in canvas.\n        // We wrap the radial gradient in a pattern element, allowing us to\n        // maintain a circular gradient that matches what canvas provides.\n        m.open('pattern', {\n          id: patternPrefix + id,\n          viewBox: '0,0,1,1',\n          width: '100%',\n          height: '100%',\n          preserveAspectRatio: 'xMidYMid slice'\n        });\n        m.open('rect', {\n          width: '1',\n          height: '1',\n          fill: 'url(#' + id + ')'\n        }).close();\n        m.close(); // </pattern>\n\n        m.open('radialGradient', {\n          id: id,\n          fx: _def.x1,\n          fy: _def.y1,\n          fr: _def.r1,\n          cx: _def.x2,\n          cy: _def.y2,\n          r: _def.r2\n        });\n      } else {\n        m.open('linearGradient', {\n          id: id,\n          x1: _def.x1,\n          x2: _def.x2,\n          y1: _def.y1,\n          y2: _def.y2\n        });\n      }\n\n      for (var i = 0; i < stops.length; ++i) {\n        m.open('stop', {\n          offset: stops[i].offset,\n          'stop-color': stops[i].color\n        }).close();\n      }\n\n      m.close();\n    }\n\n    for (var _id2 in clipping) {\n      var _def2 = clipping[_id2];\n      m.open('clipPath', {\n        id: _id2\n      });\n\n      if (_def2.path) {\n        m.open('path', {\n          d: _def2.path\n        }).close();\n      } else {\n        m.open('rect', {\n          x: 0,\n          y: 0,\n          width: _def2.width,\n          height: _def2.height\n        }).close();\n      }\n\n      m.close();\n    }\n\n    m.close();\n  }\n}); // Helper function for attr for style presentation attributes\n\nfunction style(s, item, scene, tag, defs) {\n  if (item == null) return s;\n\n  if (tag === 'bgrect' && scene.interactive === false) {\n    s['pointer-events'] = 'none';\n  }\n\n  if (tag === 'bgfore') {\n    if (scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n\n    s.display = 'none';\n    if (item.fill !== null) return s;\n  }\n\n  if (tag === 'image' && item.smooth === false) {\n    s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';\n  }\n\n  if (tag === 'text') {\n    s['font-family'] = fontFamily(item);\n    s['font-size'] = fontSize(item) + 'px';\n    s['font-style'] = item.fontStyle;\n    s['font-variant'] = item.fontVariant;\n    s['font-weight'] = item.fontWeight;\n  }\n\n  for (var prop in styles) {\n    var _value3 = item[prop];\n    var name = styles[prop];\n    if (_value3 === 'transparent' && (name === 'fill' || name === 'stroke')) ;else if (_value3 != null) {\n      if (isGradient(_value3)) {\n        _value3 = gradientRef(_value3, defs.gradient, '');\n      }\n\n      s[name] = _value3;\n    }\n  }\n\n  return s;\n}\n\nvar Canvas = 'canvas';\nvar PNG = 'png';\nvar SVG = 'svg';\nvar None = 'none';\nvar RenderType = {\n  Canvas: Canvas,\n  PNG: PNG,\n  SVG: SVG,\n  None: None\n};\nvar modules = {};\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler: CanvasHandler\n};\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler: SVGHandler\n};\nmodules[None] = {};\n\nfunction renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\n\nfunction intersect(scene, bounds, filter) {\n  var hits = [],\n      // intersection results\n  box = new Bounds().union(bounds),\n      // defensive copy\n  type = scene.marktype;\n  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');\n}\n\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    var items = mark.items,\n        _type2 = mark.marktype,\n        n = items.length;\n    var i = 0;\n\n    if (_type2 === 'group') {\n      for (; i < n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (var test = Marks[_type2].isect; i < n; ++i) {\n        var item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n\n  return hits;\n}\n\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));\n}\n\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  } // recursively test children marks\n  // translate box to group coordinate space\n\n\n  var marks = group.items,\n      n = marks && marks.length;\n\n  if (n) {\n    var _x3 = group.x || 0,\n        _y2 = group.y || 0;\n\n    box.translate(-_x3, -_y2);\n\n    for (var i = 0; i < n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n\n    box.translate(_x3, _y2);\n  }\n\n  return hits;\n}\n\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  var bounds = item.bounds;\n  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);\n}\n\nvar clipBounds = new Bounds();\n\nfunction boundClip(mark) {\n  var clip = mark.clip;\n\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n\n  mark.bounds.intersect(clipBounds);\n}\n\nvar TOLERANCE = 1e-9;\n\nfunction sceneEqual(a, b, key) {\n  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : isNumber(a) && isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !isObject(a) && !isObject(b) ? a == b : objectEqual(a, b);\n}\n\nfunction pathEqual(a, b) {\n  return sceneEqual(pathParse(a), pathParse(b));\n}\n\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n      kb = Object.keys(b),\n      key,\n      i;\n  if (ka.length !== kb.length) return false;\n  ka.sort();\n  kb.sort();\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n\n  return typeof a === typeof b;\n}\n\nfunction resetSVGDefIds() {\n  resetSVGClipId();\n  resetSVGGradientId();\n}\n\nexport { Bounds, CanvasHandler, CanvasRenderer, Gradient, GroupItem, Handler, Item, Marks, RenderType, Renderer, ResourceLoader, SVGHandler, SVGRenderer, SVGStringRenderer, Scenegraph, boundClip, boundContext, boundItem, boundMark, boundStroke, domChild, domClear, domCreate, domFind, font, fontFamily, fontSize, intersect, intersectBoxLine, intersectPath, intersectPoint, intersectRule, lineHeight, markup, multiLineOffset, curves as pathCurves, pathEqual, pathParse, vg_rect as pathRectangle, pathRender, symbols as pathSymbols, vg_trail as pathTrail, point, renderModule, resetSVGClipId, resetSVGDefIds, sceneEqual, sceneFromJSON, pickVisit as scenePickVisit, sceneToJSON, visit as sceneVisit, zorder as sceneZOrder, serializeXML, textMetrics };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-scenegraph/build/vega-scenegraph.module.js"],"names":["hasOwnProperty","isFunction","inherits","truthy","lruCache","isArray","error","toSet","array","peek","extend","isNumber","isObject","curveBasis","curveBasisClosed","curveBasisOpen","curveBundle","curveCardinal","curveCardinalOpen","curveCardinalClosed","curveCatmullRom","curveCatmullRomClosed","curveCatmullRomOpen","curveLinear","curveLinearClosed","curveMonotoneY","curveMonotoneX","curveNatural","curveStep","curveStepAfter","curveStepBefore","arc","arc$2","area","area$2","line","line$2","symbol","symbol$2","path","path$3","image","image$1","canvas","loader","isDiscrete","domainCaption","gradient_id","resetSVGGradientId","patternPrefix","isGradient","value","gradient","gradientRef","g","defs","base","type","id","prefix","x1","get","y1","r1","x2","y2","r2","val","def","Gradient","p0","p1","stops","stop","offset","color","push","lookup","curve","tension","horizontal","vertical","curves","orientation","entry","cmdlen","m","l","h","v","c","s","q","t","a","regexp","pathParse","pathstr","result","curr","chunks","parsed","param","cmd","len","i","j","n","slice","replace","split","length","trim","charAt","toLowerCase","concat","DegToRad","Math","PI","Epsilon","HalfPi","Tau","HalfSqrt3","sqrt","segmentCache","bezierCache","join","segments","x","y","rx","ry","large","sweep","rotateX","ox","oy","key","call","arguments","th","sin_th","sin","cos_th","cos","abs","px","py","pl","a00","a01","a10","a11","x0","y0","d","sfactor_sq","sfactor","xc","yc","th0","atan2","th1","th_arc","segs","ceil","th2","th3","bezier","params","cx","cy","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","temp","scale$1","current","sX","sY","pathRender","context","previous","controlX","controlY","tempX","tempY","tempControlX","tempControlY","beginPath","lineTo","moveTo","bezierCurveTo","quadraticCurveTo","match","drawArc","closePath","coords","seg","bez","Tan30","builtins","draw","size","r","w","rect","o","b","symbols","_","customSymbol","custom","C","rectangleX","rectangleY","rectangleWidth","width","rectangleHeight","height","number","clamp","min","max","vg_rect","crTL","crTR","crBL","crBR","rectangle","buffer","tl","tr","bl","br","cornerRadius","vg_trail","defined","ready","point","w2","ux","uy","ud","trail","data","defined0","value$1","item","xw","yh","sa","startAngle","ea","endAngle","pa","padAngle","ir","innerRadius","or","outerRadius","cr","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomRight","cornerRadiusBottomLeft","sz","ts","shape","arcShape","areavShape","areahShape","lineShape","rectShape","symbolShape","trailShape","hasCornerRadius","arc$1","area$1","items","interp","interpolate","orient","line$1","shape$1","mark","symbol$1","trail$1","clip_id","resetSVGClipId","clip$1","renderer","clip","_defs","clipping","Bounds","clear","union","prototype","clone","Number","MAX_VALUE","empty","equals","set","add","expand","round","floor","scale","translate","dx","dy","rotate","angle","p","rotatedPoints","intersect","encloses","alignsWith","intersects","contains","Item","bounds","GroupItem","ResourceLoader","customLoader","_pending","_loader","increment","decrement","pending","sanitizeURL","uri","sanitize","then","opt","catch","loadImage","Image","url","href","img","cors","crossOrigin","onload","onerror","src","e","complete","Promise","accept","poll","setTimeout","boundStroke","miter","stroke","opacity","strokeOpacity","sw","strokeWidth","miterAdjustment","strokeJoin","circleThreshold","lx","ly","rot","ma","mb","mc","md","addL","addX","addY","addp","addpL","boundContext","deg","context$1","px1","py1","px2","py2","quadExtrema","px3","py3","cubicExtrema","ccw","update","cb","t0","t1","cubic","s2","t2","getContext","intersectPath","brush","isPointInPath","intersectPoint","box","intersectRect","intersectRule","intersectBoxLine","u","blend","globalCompositeOperation","dflt","addStops","addColorStop","spec","createRadialGradient","createLinearGradient","ictx","fillStyle","fillRect","createPattern","fill","fillOpacity","globalAlpha","Empty","lw","strokeStyle","lineWidth","lineCap","strokeCap","lineJoin","miterLimit","strokeMiterLimit","setLineDash","strokeDash","lineDashOffset","strokeDashOffset","compare","zindex","index","zorder","scene","zdirty","zitems","output","sort","visit","visitor","pickVisit","hit","drawAll","drawPath","drawOne","pick$1","test","gx","gy","pixelRatio","hitPath","filled","Array","isPointInStroke","lc","pickPath","scaleX","scaleY","translateItem","rotateItem","transformItem","markItemPath","isect","attr","emit","bound","tag","nested","pick","pickArea","z","Infinity","pickLine","pow","dd","pickTrail","markMultiItemPath","tip","save","clipGroup","group","offset$1","strokeOffset","attr$5","emitRectangle","off","background","foreground","strokeForeground","content","bound$5","noBound","rectanglePath","hitBackground","hitForeground","hitCorner","draw$4","fore","restore","dw","dh","ix","interactive","pickMark","marktype","metadata","getImage","imageWidth","aspect","imageHeight","imageXOffset","align","imageYOffset","baseline","attr$4","toDataURL","bound$4","draw$3","ar0","ar1","imageSmoothingEnabled","smooth","drawImage","xOffset","yOffset","attr$3","sx","sy","path$1","cache","pathCache","bound$3","path$2","attr$2","bound$2","draw$2","attr$1","bound$1","draw$1","hit$1","rule","widthCache","textMetrics","fontSize","measureWidth","estimateWidth","useCanvas","use","text","_estimateWidth","textValue","currentFontHeight","_measureWidth","font","currentFont","undefined","measureText","lineHeight","lineArray","textLines","lineBreak","multiLineOffset","limit","truncate","widthGetter","ellipsis","rtl","dir","lo","hi","mid","fontFamily","quote","String","fontStyle","fontVariant","fontWeight","textAlign","tempBounds","anchorPoint","radius","theta","mode","reduce","lh","str","fillText","strokeText","ax","ay","intersectText","Marks","boundItem","func","DUMMY","boundMark","hasItems","keys","sceneToJSON","indent","JSON","stringify","sceneFromJSON","json","parse","initialize","parent","Scenegraph","root","createMark","name","role","toJSON","markdef","aria","description","domCreate","doc","ns","document","createElement","createElementNS","domFind","el","nodes","childNodes","tagName","domChild","ownerDocument","insertBefore","domClear","removeChild","cssClass","event","getBoundingClientRect","clientX","left","clientLeft","clientY","top","clientTop","resolveItem","origin","mdef","Handler","customTooltip","_active","_handlers","_tooltip","defaultTooltip","handler","element","setAttribute","obj","_el","_obj","firstChild","_origin","_scene","on","_handlerIndex","handlers","eventName","k","indexOf","handleHref","MouseEvent","dispatchEvent","handleTooltip","show","tooltip","getItemBoundingClientRect","right","bottom","Renderer","_bgcolor","scaleFactor","resize","bgcolor","_width","_height","_scale","dirty","render","_call","_render","renderAsync","_ready","resolve","_load","method","redraw","KeyDownEvent","KeyPressEvent","KeyUpEvent","DragEnterEvent","DragLeaveEvent","DragOverEvent","MouseDownEvent","MouseUpEvent","MouseMoveEvent","MouseOutEvent","MouseOverEvent","ClickEvent","DoubleClickEvent","WheelEvent","MouseWheelEvent","TouchStartEvent","TouchMoveEvent","TouchEndEvent","Events","TooltipShowEvent","TooltipHideEvent","HrefEvent","CanvasHandler","_down","_touch","_first","_events","eventBundle","eventListenerCheck","forEach","addEventListener","evt","fire","move","moveEvent","overEvent","outEvent","pickEvent","exit","inactive","_canvas","events","DOMMouseScroll","mousemove","dragover","mouseout","dragleave","mousedown","click","touchstart","changedTouches","touchmove","touchend","touch","vegaType","splice","devicePixelRatio","window","inDOM","HTMLElement","parentNode","ratio","style","setTransform","CanvasRenderer","_options","_redraw","_dirty","_tempb","base$1","viewBounds","clipToBounds","options","externalContext","appendChild","ctx","db","vb","clearRect","SVGHandler","_hrefHandler","listener","_tooltipHandler","target","__data__","svg","_svg","removeEventListener","ARIA_HIDDEN","ARIA_LABEL","ARIA_ROLE","ARIA_ROLEDESCRIPTION","GRAPHICS_OBJECT","GRAPHICS_SYMBOL","bundle","roledesc","label","AriaIgnore","AriaGuides","desc","caption","axisCaption","legendCaption","titleCaption","AriaEncode","ariaRole","ariaRoleDescription","ariaItemAttributes","hide","prop","ariaMarkAttributes","ariaGuide","ariaMark","recurse","some","err","datum","title","extractTitle","scales","locale","dataflow","xy","props","Object","capitalize","channelCaption","map","toUpperCase","innerText","attrText","markup","buf","outer","inner","stack","open","attrs","close","pop","toString","serializeXML","node","_serialize","hasAttributes","attributes","hasChildNodes","children","child","nodeType","nodeValue","styles","rootAttributes","RootIndex","xmlns","svgns","SVGRenderer","_dirtyID","_root","_clearDefs","setAttributeNS","setAttributes","setProperty","apply","viewBox","bg","removeAttribute","_dirtyCheck","_dirtyAll","isDirty","dirtyParents","_update","ownerSVGElement","prev","isGroup","sibling","bind","process","values","__values__","extra","mark_extras","updateGradient","updateClipping","grad","pt","preserveAspectRatio","fx","fy","fr","mask","lastChild","previousSibling","idx","cg","fg","siblingCheck","nextSibling","setStyle","textContent","removeProperty","removeAttributeNS","loc","location","hash","SVGStringRenderer","_text","class","transform","attrList","_hrefs","object","prefixed","fn","count","display","Canvas","PNG","SVG","None","RenderType","modules","headless","renderModule","filter","hits","intersectMark","intersectGroup","visitMark","intersectItem","marks","clipBounds","boundClip","TOLERANCE","sceneEqual","pathEqual","Date","objectEqual","ka","kb","resetSVGDefIds","pathCurves","pathRectangle","pathSymbols","pathTrail","scenePickVisit","sceneVisit","sceneZOrder"],"mappings":"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","sourcesContent":["import { hasOwnProperty, isFunction, inherits, truthy, lruCache, isArray, error, toSet, array, peek, extend, isNumber, isObject } from 'vega-util';\nimport { curveBasis, curveBasisClosed, curveBasisOpen, curveBundle, curveCardinal, curveCardinalOpen, curveCardinalClosed, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, curveLinear, curveLinearClosed, curveMonotoneY, curveMonotoneX, curveNatural, curveStep, curveStepAfter, curveStepBefore, arc as arc$2, area as area$2, line as line$2, symbol as symbol$2 } from 'd3-shape';\nimport { path as path$3 } from 'd3-path';\nimport { image as image$1, canvas } from 'vega-canvas';\nimport { loader } from 'vega-loader';\nimport { isDiscrete, domainCaption } from 'vega-scale';\n\nlet gradient_id = 0;\nfunction resetSVGGradientId() {\n  gradient_id = 0;\n}\nconst patternPrefix = 'p_';\nfunction isGradient(value) {\n  return value && value.gradient;\n}\nfunction gradientRef(g, defs, base) {\n  const type = g.gradient;\n  let id = g.id,\n      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed\n\n  if (!id) {\n    id = g.id = 'gradient_' + gradient_id++;\n\n    if (type === 'radial') {\n      g.x1 = get(g.x1, 0.5);\n      g.y1 = get(g.y1, 0.5);\n      g.r1 = get(g.r1, 0);\n      g.x2 = get(g.x2, 0.5);\n      g.y2 = get(g.y2, 0.5);\n      g.r2 = get(g.r2, 0.5);\n      prefix = patternPrefix;\n    } else {\n      g.x1 = get(g.x1, 0);\n      g.y1 = get(g.y1, 0);\n      g.x2 = get(g.x2, 1);\n      g.y2 = get(g.y2, 0);\n    }\n  } // register definition\n\n\n  defs[id] = g; // return url reference\n\n  return 'url(' + (base || '') + '#' + prefix + id + ')';\n}\n\nfunction get(val, def) {\n  return val != null ? val : def;\n}\n\nfunction Gradient (p0, p1) {\n  var stops = [],\n      gradient;\n  return gradient = {\n    gradient: 'linear',\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function (offset, color) {\n      stops.push({\n        offset: offset,\n        color: color\n      });\n      return gradient;\n    }\n  };\n}\n\nconst lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical: curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\nfunction curves(type, orientation, tension) {\n  var entry = hasOwnProperty(lookup, type) && lookup[type],\n      curve = null;\n\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n\n  return curve;\n}\n\n// Path parsing and rendering code adapted from fabric.js -- Thanks!\nconst cmdlen = {\n  m: 2,\n  l: 2,\n  h: 1,\n  v: 1,\n  c: 6,\n  s: 4,\n  q: 4,\n  t: 2,\n  a: 7\n},\n      regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\.\\d+)(\\.\\d)/g, /(\\d)([-+])/g, /\\s|,|###/];\nfunction pathParse (pathstr) {\n  const result = [];\n  let curr, chunks, parsed, param, cmd, len, i, j, n, m; // First, break path into command sequence\n\n  const path = pathstr.slice().replace(regexp[0], '###$1').split(regexp[1]).slice(1); // Next, parse each command in turn\n\n  for (i = 0, n = path.length; i < n; ++i) {\n    curr = path[i];\n    chunks = curr.slice(1).trim().replace(regexp[2], '$1###$2').replace(regexp[3], '$1###$2').split(regexp[4]);\n    cmd = curr.charAt(0);\n    parsed = [cmd];\n\n    for (j = 0, m = chunks.length; j < m; ++j) {\n      if ((param = +chunks[j]) === param) {\n        // not NaN\n        parsed.push(param);\n      }\n    }\n\n    len = cmdlen[cmd.toLowerCase()];\n\n    if (parsed.length - 1 > len) {\n      const m = parsed.length;\n      j = 1;\n      result.push([cmd].concat(parsed.slice(j, j += len))); // handle implicit lineTo (#2803)\n\n      cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;\n\n      for (; j < m; j += len) {\n        result.push([cmd].concat(parsed.slice(j, j + len)));\n      }\n    } else {\n      result.push(parsed);\n    }\n  }\n\n  return result;\n}\n\nconst DegToRad = Math.PI / 180;\nconst Epsilon = 1e-14;\nconst HalfPi = Math.PI / 2;\nconst Tau = Math.PI * 2;\nconst HalfSqrt3 = Math.sqrt(3) / 2;\n\nvar segmentCache = {};\nvar bezierCache = {};\nvar join = [].join; // Copied from Inkscape svgtopdf, thanks!\n\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const key = join.call(arguments);\n\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  const th = rotateX * DegToRad;\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += Tau;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= Tau;\n  }\n\n  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n  const result = [];\n\n  for (let i = 0; i < segs; ++i) {\n    const th2 = th0 + i * th_arc / segs;\n    const th3 = th0 + (i + 1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return segmentCache[key] = result;\n}\nfunction bezier(params) {\n  const key = join.call(params);\n\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n\n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const cos_th0 = Math.cos(th0);\n  const sin_th0 = Math.sin(th0);\n  const cos_th1 = Math.cos(th1);\n  const sin_th1 = Math.sin(th1);\n  const th_half = 0.5 * (th1 - th0);\n  const sin_th_h2 = Math.sin(th_half * 0.5);\n  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  const x1 = cx + cos_th0 - t * sin_th0;\n  const y1 = cy + sin_th0 + t * cos_th0;\n  const x3 = cx + cos_th1;\n  const y3 = cy + sin_th1;\n  const x2 = x3 + t * sin_th1;\n  const y2 = y3 - t * cos_th1;\n  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n}\n\nconst temp = ['l', 0, 0, 0, 0, 0, 0, 0];\n\nfunction scale$1(current, sX, sY) {\n  const c = temp[0] = current[0];\n\n  if (c === 'a' || c === 'A') {\n    temp[1] = sX * current[1];\n    temp[2] = sY * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = sX * current[6];\n    temp[7] = sY * current[7];\n  } else if (c === 'h' || c === 'H') {\n    temp[1] = sX * current[1];\n  } else if (c === 'v' || c === 'V') {\n    temp[1] = sY * current[1];\n  } else {\n    for (var i = 1, n = current.length; i < n; ++i) {\n      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    }\n  }\n\n  return temp;\n}\n\nfunction pathRender (context, path, l, t, sX, sY) {\n  var current,\n      // current instruction\n  previous = null,\n      x = 0,\n      // current x\n  y = 0,\n      // current y\n  controlX = 0,\n      // current control point x\n  controlY = 0,\n      // current control point y\n  tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (sX == null) sX = 1;\n  if (sY == null) sY = sX;\n  if (context.beginPath) context.beginPath();\n\n  for (var i = 0, len = path.length; i < len; ++i) {\n    current = path[i];\n\n    if (sX !== 1 || sY !== 1) {\n      current = scale$1(current, sX, sY);\n    }\n\n    switch (current[0]) {\n      // first letter\n      case 'l':\n        // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'L':\n        // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'h':\n        // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'H':\n        // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'v':\n        // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'V':\n        // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'm':\n        // moveTo, relative\n        x += current[1];\n        y += current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'M':\n        // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'c':\n        // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(x + current[1] + l, // x1\n        y + current[2] + t, // y1\n        controlX + l, // x2\n        controlY + t, // y2\n        tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C':\n        // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n        break;\n\n      case 's':\n        // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S':\n        // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY; // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 'q':\n        // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        controlX = x + current[1];\n        controlY = y + current[2];\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q':\n        // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't':\n        // shorthand quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        } else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        } else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        context.closePath();\n        break;\n    }\n\n    previous = current;\n  }\n}\n\nfunction drawArc(context, x, y, coords) {\n  const seg = segments(coords[5], // end x\n  coords[6], // end y\n  coords[0], // radius x\n  coords[1], // radius y\n  coords[3], // large flag\n  coords[4], // sweep flag\n  coords[2], // rotation\n  x, y);\n\n  for (let i = 0; i < seg.length; ++i) {\n    const bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\n\nconst Tan30 = 0.5773502691896257;\nconst builtins = {\n  'circle': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, Tau);\n    }\n  },\n  'cross': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function (context, size) {\n      var w = Math.sqrt(size),\n          x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'arrow': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 7,\n          t = r / 2.5,\n          v = r / 8;\n      context.moveTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, -v);\n      context.lineTo(t, -v);\n      context.lineTo(0, -r);\n      context.lineTo(-t, -v);\n      context.lineTo(-s, -v);\n      context.closePath();\n    }\n  },\n  'wedge': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30,\n          b = r / 4;\n      context.moveTo(0, -h - o);\n      context.lineTo(-b, h - o);\n      context.lineTo(b, h - o);\n      context.closePath();\n    }\n  },\n  'triangle': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30;\n      context.moveTo(0, -h - o);\n      context.lineTo(-r, h - o);\n      context.lineTo(r, h - o);\n      context.closePath();\n    }\n  },\n  'triangle-up': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  },\n  'stroke': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(r, 0);\n    }\n  }\n};\nfunction symbols(_) {\n  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n}\nvar custom = {};\n\nfunction customSymbol(path) {\n  if (!hasOwnProperty(custom, path)) {\n    const parsed = pathParse(path);\n    custom[path] = {\n      draw: function (context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n\n  return custom[path];\n}\n\nconst C = 0.448084975506; // C = 1 - c\n\nfunction rectangleX(d) {\n  return d.x;\n}\n\nfunction rectangleY(d) {\n  return d.y;\n}\n\nfunction rectangleWidth(d) {\n  return d.width;\n}\n\nfunction rectangleHeight(d) {\n  return d.height;\n}\n\nfunction number(_) {\n  return typeof _ === 'function' ? _ : () => +_;\n}\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction vg_rect () {\n  var x = rectangleX,\n      y = rectangleY,\n      width = rectangleWidth,\n      height = rectangleHeight,\n      crTL = number(0),\n      crTR = crTL,\n      crBL = crTL,\n      crBR = crTL,\n      context = null;\n\n  function rectangle(_, x0, y0) {\n    var buffer,\n        x1 = x0 != null ? x0 : +x.call(this, _),\n        y1 = y0 != null ? y0 : +y.call(this, _),\n        w = +width.call(this, _),\n        h = +height.call(this, _),\n        s = Math.min(w, h) / 2,\n        tl = clamp(+crTL.call(this, _), 0, s),\n        tr = clamp(+crTR.call(this, _), 0, s),\n        bl = clamp(+crBL.call(this, _), 0, s),\n        br = clamp(+crBR.call(this, _), 0, s);\n    if (!context) context = buffer = path$3();\n\n    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n          y2 = y1 + h;\n      context.moveTo(x1 + tl, y1);\n      context.lineTo(x2 - tr, y1);\n      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n      context.lineTo(x2, y2 - br);\n      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n      context.lineTo(x1 + bl, y2);\n      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n      context.lineTo(x1, y1 + tl);\n      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n      context.closePath();\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  rectangle.x = function (_) {\n    if (arguments.length) {\n      x = number(_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n\n  rectangle.y = function (_) {\n    if (arguments.length) {\n      y = number(_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n\n  rectangle.width = function (_) {\n    if (arguments.length) {\n      width = number(_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n\n  rectangle.height = function (_) {\n    if (arguments.length) {\n      height = number(_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n\n  rectangle.cornerRadius = function (tl, tr, br, bl) {\n    if (arguments.length) {\n      crTL = number(tl);\n      crTR = tr != null ? number(tr) : crTL;\n      crBR = br != null ? number(br) : crTL;\n      crBL = bl != null ? number(bl) : crTR;\n      return rectangle;\n    } else {\n      return crTL;\n    }\n  };\n\n  rectangle.context = function (_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n\n  return rectangle;\n}\n\nfunction vg_trail () {\n  var x,\n      y,\n      size,\n      defined,\n      context = null,\n      ready,\n      x1,\n      y1,\n      r1;\n\n  function point(x2, y2, w2) {\n    const r2 = w2 / 2;\n\n    if (ready) {\n      var ux = y1 - y2,\n          uy = x2 - x1;\n\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.sqrt(ux * ux + uy * uy),\n            rx = (ux /= ud) * r1,\n            ry = (uy /= ud) * r1,\n            t = Math.atan2(uy, ux); // draw segment\n\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - Math.PI, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + Math.PI);\n      } else {\n        context.arc(x2, y2, r2, 0, Tau);\n      }\n\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n\n  function trail(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n    if (context == null) context = buffer = path$3();\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  trail.x = function (_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n\n  trail.y = function (_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n\n  trail.size = function (_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n\n  trail.defined = function (_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n\n  trail.context = function (_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n\n      return trail;\n    } else {\n      return context;\n    }\n  };\n\n  return trail;\n}\n\nfunction value$1(a, b) {\n  return a != null ? a : b;\n}\n\nconst x = item => item.x || 0,\n      y = item => item.y || 0,\n      w = item => item.width || 0,\n      h = item => item.height || 0,\n      xw = item => (item.x || 0) + (item.width || 0),\n      yh = item => (item.y || 0) + (item.height || 0),\n      sa = item => item.startAngle || 0,\n      ea = item => item.endAngle || 0,\n      pa = item => item.padAngle || 0,\n      ir = item => item.innerRadius || 0,\n      or = item => item.outerRadius || 0,\n      cr = item => item.cornerRadius || 0,\n      tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\n      tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,\n      br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\n      bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\n      sz = item => value$1(item.size, 64),\n      ts = item => item.size || 1,\n      def = item => !(item.defined === false),\n      type = item => symbols(item.shape || 'circle');\n\nconst arcShape = arc$2().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),\n      areavShape = area$2().x(x).y1(y).y0(yh).defined(def),\n      areahShape = area$2().y(y).x1(x).x0(xw).defined(def),\n      lineShape = line$2().x(x).y(y).defined(def),\n      rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),\n      symbolShape = symbol$2().type(type).size(sz),\n      trailShape = vg_trail().x(x).y(y).defined(def).size(ts);\nfunction hasCornerRadius(item) {\n  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;\n}\nfunction arc$1(context, item) {\n  return arcShape.context(context)(item);\n}\nfunction area$1(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction line$1(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\nfunction shape$1(context, item) {\n  return (item.mark.shape || item.shape).context(context)(item);\n}\nfunction symbol$1(context, item) {\n  return symbolShape.context(context)(item);\n}\nfunction trail$1(context, items) {\n  return trailShape.context(context)(items);\n}\n\nvar clip_id = 1;\nfunction resetSVGClipId() {\n  clip_id = 1;\n}\nfunction clip$1 (renderer, item, size) {\n  var clip = item.clip,\n      defs = renderer._defs,\n      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n      c = defs.clipping[id] || (defs.clipping[id] = {\n    id: id\n  });\n\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else if (hasCornerRadius(size)) {\n    c.path = rectangle(null, size, 0, 0);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n\n  return 'url(#' + id + ')';\n}\n\nfunction Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\nBounds.prototype = {\n  clone() {\n    return new Bounds(this);\n  },\n\n  clear() {\n    this.x1 = +Number.MAX_VALUE;\n    this.y1 = +Number.MAX_VALUE;\n    this.x2 = -Number.MAX_VALUE;\n    this.y2 = -Number.MAX_VALUE;\n    return this;\n  },\n\n  empty() {\n    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;\n  },\n\n  equals(b) {\n    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;\n  },\n\n  set(x1, y1, x2, y2) {\n    if (x2 < x1) {\n      this.x2 = x1;\n      this.x1 = x2;\n    } else {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    if (y2 < y1) {\n      this.y2 = y1;\n      this.y1 = y2;\n    } else {\n      this.y1 = y1;\n      this.y2 = y2;\n    }\n\n    return this;\n  },\n\n  add(x, y) {\n    if (x < this.x1) this.x1 = x;\n    if (y < this.y1) this.y1 = y;\n    if (x > this.x2) this.x2 = x;\n    if (y > this.y2) this.y2 = y;\n    return this;\n  },\n\n  expand(d) {\n    this.x1 -= d;\n    this.y1 -= d;\n    this.x2 += d;\n    this.y2 += d;\n    return this;\n  },\n\n  round() {\n    this.x1 = Math.floor(this.x1);\n    this.y1 = Math.floor(this.y1);\n    this.x2 = Math.ceil(this.x2);\n    this.y2 = Math.ceil(this.y2);\n    return this;\n  },\n\n  scale(s) {\n    this.x1 *= s;\n    this.y1 *= s;\n    this.x2 *= s;\n    this.y2 *= s;\n    return this;\n  },\n\n  translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  },\n\n  rotate(angle, x, y) {\n    const p = this.rotatedPoints(angle, x, y);\n    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);\n  },\n\n  rotatedPoints(angle, x, y) {\n    var {\n      x1,\n      y1,\n      x2,\n      y2\n    } = this,\n        cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        cx = x - x * cos + y * sin,\n        cy = y - x * sin - y * cos;\n    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];\n  },\n\n  union(b) {\n    if (b.x1 < this.x1) this.x1 = b.x1;\n    if (b.y1 < this.y1) this.y1 = b.y1;\n    if (b.x2 > this.x2) this.x2 = b.x2;\n    if (b.y2 > this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  intersect(b) {\n    if (b.x1 > this.x1) this.x1 = b.x1;\n    if (b.y1 > this.y1) this.y1 = b.y1;\n    if (b.x2 < this.x2) this.x2 = b.x2;\n    if (b.y2 < this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  encloses(b) {\n    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;\n  },\n\n  alignsWith(b) {\n    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);\n  },\n\n  intersects(b) {\n    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);\n  },\n\n  contains(x, y) {\n    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);\n  },\n\n  width() {\n    return this.x2 - this.x1;\n  },\n\n  height() {\n    return this.y2 - this.y1;\n  }\n\n};\n\nfunction Item(mark) {\n  this.mark = mark;\n  this.bounds = this.bounds || new Bounds();\n}\n\nfunction GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = this.items || [];\n}\ninherits(GroupItem, Item);\n\nfunction ResourceLoader(customLoader) {\n  this._pending = 0;\n  this._loader = customLoader || loader();\n}\n\nfunction increment(loader) {\n  loader._pending += 1;\n}\n\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\n\nResourceLoader.prototype = {\n  pending() {\n    return this._pending;\n  },\n\n  sanitizeURL(uri) {\n    const loader = this;\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'href'\n    }).then(opt => {\n      decrement(loader);\n      return opt;\n    }).catch(() => {\n      decrement(loader);\n      return null;\n    });\n  },\n\n  loadImage(uri) {\n    const loader = this,\n          Image = image$1();\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'image'\n    }).then(opt => {\n      const url = opt.href;\n      if (!url || !Image) throw {\n        url: url\n      };\n      const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n\n      const cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n      if (cors != null) img.crossOrigin = cors; // attempt to load image resource\n\n      img.onload = () => decrement(loader);\n\n      img.onerror = () => decrement(loader);\n\n      img.src = url;\n      return img;\n    }).catch(e => {\n      decrement(loader);\n      return {\n        complete: false,\n        width: 0,\n        height: 0,\n        src: e && e.url || ''\n      };\n    });\n  },\n\n  ready() {\n    const loader = this;\n    return new Promise(accept => {\n      function poll(value) {\n        if (!loader.pending()) accept(value);else setTimeout(() => {\n          poll(true);\n        }, 10);\n      }\n\n      poll(false);\n    });\n  }\n\n};\n\nfunction boundStroke (bounds, item, miter) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n  }\n\n  return bounds;\n}\n\nfunction miterAdjustment(item, strokeWidth) {\n  // TODO: more sophisticated adjustment? Or miter support in boundContext?\n  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n}\n\nconst circleThreshold = Tau - 1e-8;\nlet bounds, lx, ly, rot, ma, mb, mc, md;\n\nconst add = (x, y) => bounds.add(x, y);\n\nconst addL = (x, y) => add(lx = x, ly = y);\n\nconst addX = x => add(x, bounds.y1);\n\nconst addY = y => add(bounds.x1, y);\n\nconst px = (x, y) => ma * x + mc * y;\n\nconst py = (x, y) => mb * x + md * y;\n\nconst addp = (x, y) => add(px(x, y), py(x, y));\n\nconst addpL = (x, y) => addL(px(x, y), py(x, y));\n\nfunction boundContext (_, deg) {\n  bounds = _;\n\n  if (deg) {\n    rot = deg * DegToRad;\n    ma = md = Math.cos(rot);\n    mb = Math.sin(rot);\n    mc = -mb;\n  } else {\n    ma = md = 1;\n    rot = mb = mc = 0;\n  }\n\n  return context$1;\n}\nconst context$1 = {\n  beginPath() {},\n\n  closePath() {},\n\n  moveTo: addpL,\n  lineTo: addpL,\n\n  rect(x, y, w, h) {\n    if (rot) {\n      addp(x + w, y);\n      addp(x + w, y + h);\n      addp(x, y + h);\n      addpL(x, y);\n    } else {\n      add(x + w, y + h);\n      addL(x, y);\n    }\n  },\n\n  quadraticCurveTo(x1, y1, x2, y2) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2);\n    quadExtrema(lx, px1, px2, addX);\n    quadExtrema(ly, py1, py2, addY);\n    addL(px2, py2);\n  },\n\n  bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2),\n          px3 = px(x3, y3),\n          py3 = py(x3, y3);\n    cubicExtrema(lx, px1, px2, px3, addX);\n    cubicExtrema(ly, py1, py2, py3, addY);\n    addL(px3, py3);\n  },\n\n  arc(cx, cy, r, sa, ea, ccw) {\n    sa += rot;\n    ea += rot; // store last point on path\n\n    lx = r * Math.cos(ea) + cx;\n    ly = r * Math.sin(ea) + cy;\n\n    if (Math.abs(ea - sa) > circleThreshold) {\n      // treat as full circle\n      add(cx - r, cy - r);\n      add(cx + r, cy + r);\n    } else {\n      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n\n      let s, i; // sample end points\n\n      update(sa);\n      update(ea); // sample interior points aligned with 90 degrees\n\n      if (ea !== sa) {\n        sa = sa % Tau;\n        if (sa < 0) sa += Tau;\n        ea = ea % Tau;\n        if (ea < 0) ea += Tau;\n\n        if (ea < sa) {\n          ccw = !ccw; // flip direction\n\n          s = sa;\n          sa = ea;\n          ea = s; // swap end-points\n        }\n\n        if (ccw) {\n          ea -= Tau;\n          s = sa - sa % HalfPi;\n\n          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);\n        } else {\n          s = sa - sa % HalfPi + HalfPi;\n\n          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);\n        }\n      }\n    }\n  }\n\n};\n\nfunction quadExtrema(x0, x1, x2, cb) {\n  const t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\n\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  const a = x3 - x0 + 3 * x1 - 3 * x2,\n        b = x0 + x2 - 2 * x1,\n        c = x0 - x1;\n  let t0 = 0,\n      t1 = 0,\n      r; // solve for parameter t\n\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  } // calculate position\n\n\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\n\nfunction cubic(t, x0, x1, x2, x3) {\n  const s = 1 - t,\n        s2 = s * s,\n        t2 = t * t;\n  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;\n}\n\nvar context = (context = canvas(1, 1)) ? context.getContext('2d') : null;\n\nconst b = new Bounds();\nfunction intersectPath(draw) {\n  return function (item, brush) {\n    // rely on (inaccurate) bounds intersection if no context\n    if (!context) return true; // add path to offscreen graphics context\n\n    draw(context, item); // get bounds intersection region\n\n    b.clear().union(item.bounds).intersect(brush).round();\n    const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = b; // iterate over intersection region\n    // perform fine grained inclusion test\n\n    for (let y = y1; y <= y2; ++y) {\n      for (let x = x1; x <= x2; ++x) {\n        if (context.isPointInPath(x, y)) {\n          return true;\n        }\n      }\n    } // false if no hits in intersection region\n\n\n    return false;\n  };\n}\nfunction intersectPoint(item, box) {\n  return box.contains(item.x || 0, item.y || 0);\n}\nfunction intersectRect(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        w = item.width || 0,\n        h = item.height || 0;\n  return box.intersects(b.set(x, y, x + w, y + h));\n}\nfunction intersectRule(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        x2 = item.x2 != null ? item.x2 : x,\n        y2 = item.y2 != null ? item.y2 : y;\n  return intersectBoxLine(box, x, y, x2, y2);\n}\nfunction intersectBoxLine(box, x, y, u, v) {\n  const {\n    x1,\n    y1,\n    x2,\n    y2\n  } = box,\n        dx = u - x,\n        dy = v - y;\n  let t0 = 0,\n      t1 = 1,\n      p,\n      q,\n      r,\n      e;\n\n  for (e = 0; e < 4; ++e) {\n    if (e === 0) {\n      p = -dx;\n      q = -(x1 - x);\n    }\n\n    if (e === 1) {\n      p = dx;\n      q = x2 - x;\n    }\n\n    if (e === 2) {\n      p = -dy;\n      q = -(y1 - y);\n    }\n\n    if (e === 3) {\n      p = dy;\n      q = y2 - y;\n    }\n\n    if (Math.abs(p) < 1e-10 && q < 0) return false;\n    r = q / p;\n\n    if (p < 0) {\n      if (r > t1) return false;else if (r > t0) t0 = r;\n    } else if (p > 0) {\n      if (r < t0) return false;else if (r < t1) t1 = r;\n    }\n  }\n\n  return true;\n}\n\nfunction blend (context, item) {\n  context.globalCompositeOperation = item.blend || 'source-over';\n}\n\nfunction value (value, dflt) {\n  return value == null ? dflt : value;\n}\n\nfunction addStops(gradient, stops) {\n  const n = stops.length;\n\n  for (let i = 0; i < n; ++i) {\n    gradient.addColorStop(stops[i].offset, stops[i].color);\n  }\n\n  return gradient;\n}\n\nfunction gradient (context, spec, bounds) {\n  const w = bounds.width(),\n        h = bounds.height();\n  let gradient;\n\n  if (spec.gradient === 'radial') {\n    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));\n  } else {\n    // linear gradient\n    const x1 = value(spec.x1, 0),\n          y1 = value(spec.y1, 0),\n          x2 = value(spec.x2, 1),\n          y2 = value(spec.y2, 0);\n\n    if (x1 === x2 || y1 === y2 || w === h) {\n      // axis aligned: use normal gradient\n      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);\n    } else {\n      // not axis aligned: render gradient into a pattern (#2365)\n      // this allows us to use normalized bounding box coordinates\n      const image = canvas(Math.ceil(w), Math.ceil(h)),\n            ictx = image.getContext('2d');\n      ictx.scale(w, h);\n      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);\n      ictx.fillRect(0, 0, w, h);\n      return context.createPattern(image, 'no-repeat');\n    }\n  }\n\n  return addStops(gradient, spec.stops);\n}\n\nfunction color (context, item, value) {\n  return isGradient(value) ? gradient(context, value, item.bounds) : value;\n}\n\nfunction fill (context, item, opacity) {\n  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar Empty = [];\nfunction stroke (context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n  if (lw <= 0) return false;\n  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\n\nfunction zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n  var items = scene.items,\n      output = [],\n      item,\n      i,\n      n;\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\nfunction visit(scene, visitor) {\n  var items = scene.items,\n      i,\n      n;\n  if (!items || !items.length) return;\n  const zitems = zorder(scene);\n\n  if (zitems && zitems.length) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n\n    items = zitems;\n  }\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    visitor(items[i]);\n  }\n}\nfunction pickVisit(scene, visitor) {\n  var items = scene.items,\n      hit,\n      i;\n  if (!items || !items.length) return null;\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n\n  for (i = items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n\n  if (items === zitems) {\n    for (items = scene.items, i = items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction drawAll(path) {\n  return function (context, scene, bounds) {\n    visit(scene, item => {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\nfunction drawOne(path) {\n  return function (context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\n\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n  if (path(context, items)) return;\n  blend(context, item);\n\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\n\nfunction pick$1(test) {\n  test = test || truthy;\n  return function (context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return pickVisit(scene, item => {\n      const b = item.bounds; // first hit test against bounding box\n\n      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test\n\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\nfunction hitPath(path, filled) {\n  return function (context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = filled == null ? item.fill : filled,\n        stroke = item.stroke && context.isPointInStroke,\n        lw,\n        lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap = lc != null ? lc : 'butt';\n    }\n\n    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);\n  };\n}\nfunction pickPath(path) {\n  return pick$1(hitPath(path));\n}\n\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\nfunction rotate(a) {\n  return 'rotate(' + a + ')';\n}\nfunction scale(scaleX, scaleY) {\n  return 'scale(' + scaleX + ',' + scaleY + ')';\n}\nfunction translateItem(item) {\n  return translate(item.x || 0, item.y || 0);\n}\nfunction rotateItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');\n}\nfunction transformItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');\n}\n\nfunction markItemPath (type, shape, isect) {\n  function attr(emit, item) {\n    emit('transform', rotateItem(item));\n    emit('d', shape(null, item));\n  }\n\n  function bound(bounds, item) {\n    shape(boundContext(bounds, item.angle), item);\n    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n  }\n\n  function draw(context, item) {\n    var x = item.x || 0,\n        y = item.y || 0,\n        a = item.angle || 0;\n    context.translate(x, y);\n    if (a) context.rotate(a *= DegToRad);\n    context.beginPath();\n    shape(context, item);\n    if (a) context.rotate(-a);\n    context.translate(-x, -y);\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: false,\n    attr: attr,\n    bound: bound,\n    draw: drawAll(draw),\n    pick: pickPath(draw),\n    isect: isect || intersectPath(draw)\n  };\n}\n\nvar arc = markItemPath('arc', arc$1);\n\nfunction pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n      z = a[0].orient === 'horizontal' ? 'y' : 'x',\n      i = a.length,\n      min = +Infinity,\n      hit,\n      d;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n\n  return hit;\n}\nfunction pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n      i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n\n  return null;\n}\nfunction pickTrail(a, p) {\n  var i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx * dx) return a[i];\n  }\n\n  return null;\n}\n\nfunction markMultiItemPath (type, shape, tip) {\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n\n  function bound(bounds, mark) {\n    var items = mark.items;\n\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(boundContext(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n\n  const hit = hitPath(draw);\n\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n        b = scene.bounds;\n\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: true,\n    attr: attr,\n    bound: bound,\n    draw: drawOne(draw),\n    pick: pick,\n    isect: intersectPoint,\n    tip: tip\n  };\n}\n\nvar area = markMultiItemPath('area', area$1, pickArea);\n\nfunction clip (context, scene) {\n  var clip = scene.clip;\n  context.save();\n\n  if (isFunction(clip)) {\n    context.beginPath();\n    clip(context);\n    context.clip();\n  } else {\n    clipGroup(context, scene.group);\n  }\n}\nfunction clipGroup(context, group) {\n  context.beginPath();\n  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);\n  context.clip();\n}\n\nfunction offset$1(item) {\n  const sw = value(item.strokeWidth, 1);\n  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;\n}\n\nfunction attr$5(emit, item) {\n  emit('transform', translateItem(item));\n}\n\nfunction emitRectangle(emit, item) {\n  const off = offset$1(item);\n  emit('d', rectangle(null, item, off, off));\n}\n\nfunction background(emit, item) {\n  emit('class', 'background');\n  emit('aria-hidden', true);\n  emitRectangle(emit, item);\n}\n\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n  emit('aria-hidden', true);\n\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\n\nfunction content(emit, item, renderer) {\n  const url = item.clip ? clip$1(renderer, item, item) : null;\n  emit('clip-path', url);\n}\n\nfunction bound$5(bounds, group) {\n  if (!group.clip && group.items) {\n    const items = group.items,\n          m = items.length;\n\n    for (let j = 0; j < m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n\n  boundStroke(bounds, group);\n  return bounds.translate(group.x || 0, group.y || 0);\n}\n\nfunction rectanglePath(context, group, x, y) {\n  const off = offset$1(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\n\nconst hitBackground = hitPath(rectanglePath);\nconst hitForeground = hitPath(rectanglePath, false);\nconst hitCorner = hitPath(rectanglePath, true);\n\nfunction draw$4(context, scene, bounds) {\n  visit(scene, group => {\n    const gx = group.x || 0,\n          gy = group.y || 0,\n          fore = group.strokeForeground,\n          opacity = group.opacity == null ? 1 : group.opacity; // draw group background\n\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    } // setup graphics context, set clip and bounds\n\n\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy); // draw group contents\n\n    visit(group, item => {\n      this.draw(context, item, bounds);\n    }); // restore graphics context\n\n    if (bounds) bounds.translate(gx, gy);\n    context.restore(); // draw group foreground\n\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\n\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n\n  const cx = x * context.pixelRatio,\n        cy = y * context.pixelRatio;\n  return pickVisit(scene, group => {\n    let hit, dx, dy; // first hit test bounding box\n\n    const b = group.bounds;\n    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip\n\n    dx = group.x || 0;\n    dy = group.y || 0;\n    const dw = dx + (group.width || 0),\n          dh = dy + (group.height || 0),\n          c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system\n\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy; // test background for rounded corner clip\n\n    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n\n    const fore = group.strokeForeground,\n          ix = scene.interactive !== false; // hit test against group foreground\n\n    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    } // hit test against contained marks\n\n\n    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background\n\n    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    } // restore state and return\n\n\n    context.restore();\n    return hit || null;\n  });\n}\n\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);\n}\n\nvar group = {\n  type: 'group',\n  tag: 'g',\n  nested: false,\n  attr: attr$5,\n  bound: bound$5,\n  draw: draw$4,\n  pick: pick,\n  isect: intersectRect,\n  content: content,\n  background: background,\n  foreground: foreground\n};\n\nvar metadata = {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n  'version': '1.1'\n};\n\nfunction getImage(item, renderer) {\n  var image = item.image;\n\n  if (!image || item.url && item.url !== image.url) {\n    image = {\n      complete: false,\n      width: 0,\n      height: 0\n    };\n    renderer.loadImage(item.url).then(image => {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n\n  return image;\n}\n\nfunction imageWidth(item, image) {\n  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;\n}\n\nfunction imageHeight(item, image) {\n  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;\n}\n\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\n\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\n\nfunction attr$4(emit, item, renderer) {\n  const img = getImage(item, renderer),\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n}\n\nfunction bound$4(bounds, item) {\n  const img = item.image,\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h);\n  return bounds.set(x, y, x + w, y + h);\n}\n\nfunction draw$3(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    const img = getImage(item, this);\n    let w = imageWidth(item, img);\n    let h = imageHeight(item, img);\n    if (w === 0 || h === 0) return; // early exit\n\n    let x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        opacity,\n        ar0,\n        ar1,\n        t;\n\n    if (item.aspect !== false) {\n      ar0 = img.width / img.height;\n      ar1 = item.width / item.height;\n\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n\n    if (img.complete || img.toDataURL) {\n      blend(context, item);\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.imageSmoothingEnabled = item.smooth !== false;\n      context.drawImage(img, x, y, w, h);\n    }\n  });\n}\n\nvar image = {\n  type: 'image',\n  tag: 'image',\n  nested: false,\n  attr: attr$4,\n  bound: bound$4,\n  draw: draw$3,\n  pick: pick$1(),\n  isect: truthy,\n  // bounds check is sufficient\n  get: getImage,\n  xOffset: imageXOffset,\n  yOffset: imageYOffset\n};\n\nvar line = markMultiItemPath('line', line$1, pickLine);\n\nfunction attr$3(emit, item) {\n  var sx = item.scaleX || 1,\n      sy = item.scaleY || 1;\n\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\n\nfunction path$1(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n  var x = item.x || 0,\n      y = item.y || 0,\n      sx = item.scaleX || 1,\n      sy = item.scaleY || 1,\n      a = (item.angle || 0) * DegToRad,\n      cache = item.pathCache;\n\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = pathParse(path)).path = path;\n  }\n\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\n\nfunction bound$3(bounds, item) {\n  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);\n}\n\nvar path$2 = {\n  type: 'path',\n  tag: 'path',\n  nested: false,\n  attr: attr$3,\n  bound: bound$3,\n  draw: drawAll(path$1),\n  pick: pickPath(path$1),\n  isect: intersectPath(path$1)\n};\n\nfunction attr$2(emit, item) {\n  emit('d', rectangle(null, item));\n}\n\nfunction bound$2(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);\n}\n\nfunction draw$2(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\n\nvar rect = {\n  type: 'rect',\n  tag: 'path',\n  nested: false,\n  attr: attr$2,\n  bound: bound$2,\n  draw: drawAll(draw$2),\n  pick: pickPath(draw$2),\n  isect: intersectRect\n};\n\nfunction attr$1(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\n\nfunction bound$1(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);\n}\n\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n\n  return false;\n}\n\nfunction draw$1(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    var opacity = item.opacity == null ? 1 : item.opacity;\n\n    if (opacity && path(context, item, opacity)) {\n      blend(context, item);\n      context.stroke();\n    }\n  });\n}\n\nfunction hit$1(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\n\nvar rule = {\n  type: 'rule',\n  tag: 'line',\n  nested: false,\n  attr: attr$1,\n  bound: bound$1,\n  draw: draw$1,\n  pick: pick$1(hit$1),\n  isect: intersectRule\n};\n\nvar shape = markItemPath('shape', shape$1);\n\nvar symbol = markItemPath('symbol', symbol$1, intersectPoint);\n\nconst widthCache = lruCache();\nvar textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\nuseCanvas(true);\n\nfunction useCanvas(use) {\n  textMetrics.width = use && context ? measureWidth : estimateWidth;\n} // make simple estimate if no canvas is available\n\n\nfunction estimateWidth(item, text) {\n  return _estimateWidth(textValue(item, text), fontSize(item));\n}\n\nfunction _estimateWidth(text, currentFontHeight) {\n  return ~~(0.8 * text.length * currentFontHeight);\n} // measure text width if canvas is available\n\n\nfunction measureWidth(item, text) {\n  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));\n}\n\nfunction _measureWidth(text, currentFont) {\n  const key = `(${currentFont}) ${text}`;\n  let width = widthCache.get(key);\n\n  if (width === undefined) {\n    context.font = currentFont;\n    width = context.measureText(text).width;\n    widthCache.set(key, width);\n  }\n\n  return width;\n}\n\nfunction fontSize(item) {\n  return item.fontSize != null ? +item.fontSize || 0 : 11;\n}\nfunction lineHeight(item) {\n  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;\n}\n\nfunction lineArray(_) {\n  return isArray(_) ? _.length > 1 ? _ : _[0] : _;\n}\n\nfunction textLines(item) {\n  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);\n}\nfunction multiLineOffset(item) {\n  const tl = textLines(item);\n  return (isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);\n}\nfunction textValue(item, line) {\n  const text = line == null ? '' : (line + '').trim();\n  return item.limit > 0 && text.length ? truncate(item, text) : text;\n}\n\nfunction widthGetter(item) {\n  if (textMetrics.width === measureWidth) {\n    // we are using canvas\n    const currentFont = font(item);\n    return text => _measureWidth(text, currentFont);\n  } else {\n    // we are relying on estimates\n    const currentFontHeight = fontSize(item);\n    return text => _estimateWidth(text, currentFontHeight);\n  }\n}\n\nfunction truncate(item, text) {\n  var limit = +item.limit,\n      width = widthGetter(item);\n  if (width(text) < limit) return text;\n  var ellipsis = item.ellipsis || '\\u2026',\n      rtl = item.dir === 'rtl',\n      lo = 0,\n      hi = text.length,\n      mid;\n  limit -= width(ellipsis);\n\n  if (rtl) {\n    while (lo < hi) {\n      mid = lo + hi >>> 1;\n      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;\n    }\n\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;\n    }\n\n    return text.slice(0, lo) + ellipsis;\n  }\n}\n\nfunction fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font ? String(font).replace(/\"/g, '\\'') : font) || 'sans-serif';\n}\nfunction font(item, quote) {\n  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);\n}\nfunction offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  // this also ensures consistent layout across renderers\n  var baseline = item.baseline,\n      h = fontSize(item);\n  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);\n}\n\nconst textAlign = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\nconst tempBounds = new Bounds();\n\nfunction anchorPoint(item) {\n  var x = item.x || 0,\n      y = item.y || 0,\n      r = item.radius || 0,\n      t;\n\n  if (r) {\n    t = (item.theta || 0) - HalfPi;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  tempBounds.x1 = x;\n  tempBounds.y1 = y;\n  return tempBounds;\n}\n\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item),\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      a = item.angle || 0,\n      t;\n  emit('text-anchor', textAlign[item.align] || 'start');\n\n  if (a) {\n    t = translate(x, y) + ' ' + rotate(a);\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n\n  emit('transform', t);\n}\n\nfunction bound(bounds, item, mode) {\n  var h = textMetrics.height(item),\n      a = item.align,\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),\n      // use 4/5 offset\n  tl = textLines(item),\n      w; // get dimensions\n\n  if (isArray(tl)) {\n    // multi-line text\n    h += lineHeight(item) * (tl.length - 1);\n    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\n  } else {\n    // single-line text\n    w = textMetrics.width(item, tl);\n  } // horizontal alignment\n\n\n  if (a === 'center') {\n    dx -= w / 2;\n  } else if (a === 'right') {\n    dx -= w;\n  } else ;\n\n  bounds.set(dx += x, dy += y, dx + w, dy + h);\n\n  if (item.angle && !mode) {\n    bounds.rotate(item.angle * DegToRad, x, y);\n  } else if (mode === 2) {\n    return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n  }\n\n  return bounds;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    var opacity = item.opacity == null ? 1 : item.opacity,\n        p,\n        x,\n        y,\n        i,\n        lh,\n        tl,\n        str;\n    if (bounds && !bounds.intersects(item.bounds) || // bounds check\n    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n    p = anchorPoint(item);\n    x = p.x1, y = p.y1;\n\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * DegToRad);\n      x = y = 0; // reset x, y\n    }\n\n    x += item.dx || 0;\n    y += (item.dy || 0) + offset(item);\n    tl = textLines(item);\n    blend(context, item);\n\n    if (isArray(tl)) {\n      lh = lineHeight(item);\n\n      for (i = 0; i < tl.length; ++i) {\n        str = textValue(item, tl[i]);\n\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n\n        y += lh;\n      }\n    } else {\n      str = textValue(item, tl);\n\n      if (item.fill && fill(context, item, opacity)) {\n        context.fillText(str, x, y);\n      }\n\n      if (item.stroke && stroke(context, item, opacity)) {\n        context.strokeText(str, x, y);\n      }\n    }\n\n    if (item.angle) context.restore();\n  });\n}\n\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n  // project point into space of unrotated bounds\n\n  var p = anchorPoint(item),\n      ax = p.x1,\n      ay = p.y1,\n      b = bound(tempBounds, item, 1),\n      a = -item.angle * DegToRad,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n  return b.contains(px, py);\n}\n\nfunction intersectText(item, box) {\n  const p = bound(tempBounds, item, 2);\n  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n}\n\nvar text = {\n  type: 'text',\n  tag: 'text',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick$1(hit),\n  isect: intersectText\n};\n\nvar trail = markMultiItemPath('trail', trail$1, pickTrail);\n\nvar Marks = {\n  arc: arc,\n  area: area,\n  group: group,\n  image: image,\n  line: line,\n  path: path$2,\n  rect: rect,\n  rule: rule,\n  shape: shape,\n  symbol: symbol,\n  text: text,\n  trail: trail\n};\n\nfunction boundItem (item, func, opt) {\n  var type = Marks[item.mark.marktype],\n      bound = func || type.bound;\n  if (type.nested) item = item.mark;\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\n\nvar DUMMY = {\n  mark: null\n};\nfunction boundMark (mark, bounds, opt) {\n  var type = Marks[mark.marktype],\n      bound = type.bound,\n      items = mark.items,\n      hasItems = items && items.length,\n      i,\n      n,\n      item,\n      b;\n\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n\n  if (hasItems) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n\n  return mark.bounds = bounds;\n}\n\nconst keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout\n'fill', 'fillOpacity', 'opacity', 'blend', // fill\n'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke\n'strokeDash', 'strokeDashOffset', // stroke dash\n'strokeForeground', 'strokeOffset', // group\n'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc\n'cornerRadius', 'padAngle', // arc, rect\n'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group\n'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line\n'url', 'aspect', 'smooth', // image\n'path', 'scaleX', 'scaleY', // path\n'x2', 'y2', // rule\n'size', 'shape', // symbol\n'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text\n'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font\n'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria\n];\nfunction sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\nfunction sceneFromJSON(json) {\n  const scene = typeof json === 'string' ? JSON.parse(json) : json;\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      items = scene.items,\n      parent,\n      i,\n      n;\n\n  if (items) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n\n  if (type) boundMark(scene);\n  return scene;\n}\n\nfunction Scenegraph(scene) {\n  if (arguments.length) {\n    this.root = sceneFromJSON(scene);\n  } else {\n    this.root = createMark({\n      marktype: 'group',\n      name: 'root',\n      role: 'frame'\n    });\n    this.root.items = [new GroupItem(this.root)];\n  }\n}\nScenegraph.prototype = {\n  toJSON(indent) {\n    return sceneToJSON(this.root, indent || 0);\n  },\n\n  mark(markdef, group, index) {\n    group = group || this.root.items[0];\n    const mark = createMark(markdef, group);\n    group.items[index] = mark;\n    if (mark.zindex) mark.group.zdirty = true;\n    return mark;\n  }\n\n};\n\nfunction createMark(def, group) {\n  const mark = {\n    bounds: new Bounds(),\n    clip: !!def.clip,\n    group: group,\n    interactive: def.interactive === false ? false : true,\n    items: [],\n    marktype: def.marktype,\n    name: def.name || undefined,\n    role: def.role || undefined,\n    zindex: def.zindex || 0\n  }; // add accessibility properties if defined\n\n  if (def.aria != null) {\n    mark.aria = def.aria;\n  }\n\n  if (def.description) {\n    mark.description = def.description;\n  }\n\n  return mark;\n}\n\n// create a new DOM element\nfunction domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n\n  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;\n} // find first child element with matching tag\n\nfunction domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes,\n      i = 0,\n      n = nodes.length;\n\n  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n    return nodes[i];\n  }\n} // retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\n\nfunction domChild(el, index, tag, ns) {\n  var a = el.childNodes[index],\n      b;\n\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n\n  return a;\n} // remove all child elements at or above the given index\n\nfunction domClear(el, index) {\n  var nodes = el.childNodes,\n      curr = nodes.length;\n\n  while (curr > index) el.removeChild(nodes[--curr]);\n\n  return el;\n} // generate css class name for mark\n\nfunction cssClass(mark) {\n  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');\n}\n\nfunction point (event, el) {\n  const rect = el.getBoundingClientRect();\n  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];\n}\n\nfunction resolveItem (item, event, el, origin) {\n  var mark = item && item.mark,\n      mdef,\n      p;\n\n  if (mark && (mdef = Marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n\n    item = mdef.tip(mark.items, p);\n  }\n\n  return item;\n}\n\n/**\n * Create a new Handler instance.\n * @param {object} [customLoader] - Optional loader instance for\n *   href URL sanitization. If not specified, a standard loader\n *   instance will be generated.\n * @param {function} [customTooltip] - Optional tooltip handler\n *   function for custom tooltip display.\n * @constructor\n */\n\nfunction Handler(customLoader, customTooltip) {\n  this._active = null;\n  this._handlers = {};\n  this._loader = customLoader || loader();\n  this._tooltip = customTooltip || defaultTooltip;\n} // The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\n\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\n\nHandler.prototype = {\n  /**\n   * Initialize a new Handler instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {object} [obj] - Optional context object that should serve as\n   *   the \"this\" context for event callbacks.\n   * @return {Handler} - This handler instance.\n   */\n  initialize(el, origin, obj) {\n    this._el = el;\n    this._obj = obj || null;\n    return this.origin(origin);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the origin coordinates of the visualization.\n   */\n  origin(origin) {\n    if (arguments.length) {\n      this._origin = origin || [0, 0];\n      return this;\n    } else {\n      return this._origin.slice();\n    }\n  },\n\n  /**\n   * Get / set the scenegraph root.\n   */\n  scene(scene) {\n    if (!arguments.length) return this._scene;\n    this._scene = scene;\n    return this;\n  },\n\n  /**\n   * Add an event handler. Subclasses should override this method.\n   */\n  on()\n  /*type, handler*/\n  {},\n\n  /**\n   * Remove an event handler. Subclasses should override this method.\n   */\n  off()\n  /*type, handler*/\n  {},\n\n  /**\n   * Utility method for finding the array index of an event handler.\n   * @param {Array} h - An array of registered event handlers.\n   * @param {string} type - The event type.\n   * @param {function} handler - The event handler instance to find.\n   * @return {number} - The handler's array index or -1 if not registered.\n   */\n  _handlerIndex(h, type, handler) {\n    for (let i = h ? h.length : 0; --i >= 0;) {\n      if (h[i].type === type && (!handler || h[i].handler === handler)) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\n   * Returns an array with registered event handlers.\n   * @param {string} [type] - The event type to query. Any annotations\n   *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n   *   be ignored and the method returns all \"click\" handlers. If type is\n   *   null or unspecified, this method returns handlers for all types.\n   * @return {Array} - A new array containing all registered event handlers.\n   */\n  handlers(type) {\n    const h = this._handlers,\n          a = [];\n\n    if (type) {\n      a.push(...h[this.eventName(type)]);\n    } else {\n      for (const k in h) {\n        a.push(...h[k]);\n      }\n    }\n\n    return a;\n  },\n\n  /**\n   * Parses an event name string to return the specific event type.\n   * For example, given \"click.foo\" returns \"click\"\n   * @param {string} name - The input event type string.\n   * @return {string} - A string with the event type only.\n   */\n  eventName(name) {\n    const i = name.indexOf('.');\n    return i < 0 ? name : name.slice(0, i);\n  },\n\n  /**\n   * Handle hyperlink navigation in response to an item.href value.\n   * @param {Event} event - The event triggering hyperlink navigation.\n   * @param {Item} item - The scenegraph item.\n   * @param {string} href - The URL to navigate to.\n   */\n  handleHref(event, item, href) {\n    this._loader.sanitize(href, {\n      context: 'href'\n    }).then(opt => {\n      const e = new MouseEvent(event.type, event),\n            a = domCreate(null, 'a');\n\n      for (const name in opt) a.setAttribute(name, opt[name]);\n\n      a.dispatchEvent(e);\n    }).catch(() => {\n      /* do nothing */\n    });\n  },\n\n  /**\n   * Handle tooltip display in response to an item.tooltip value.\n   * @param {Event} event - The event triggering tooltip display.\n   * @param {Item} item - The scenegraph item.\n   * @param {boolean} show - A boolean flag indicating whether\n   *   to show or hide a tooltip for the given item.\n   */\n  handleTooltip(event, item, show) {\n    if (item && item.tooltip != null) {\n      item = resolveItem(item, event, this.canvas(), this._origin);\n      const value = show && item && item.tooltip || null;\n\n      this._tooltip.call(this._obj, this, event, item, value);\n    }\n  },\n\n  /**\n   * Returns the size of a scenegraph item and its position relative\n   * to the viewport.\n   * @param {Item} item - The scenegraph item.\n   * @return {object} - A bounding box object (compatible with the\n   *   DOMRect type) consisting of x, y, width, heigh, top, left,\n   *   right, and bottom properties.\n   */\n  getItemBoundingClientRect(item) {\n    const el = this.canvas();\n    if (!el) return;\n    const rect = el.getBoundingClientRect(),\n          origin = this._origin,\n          bounds = item.bounds,\n          width = bounds.width(),\n          height = bounds.height();\n    let x = bounds.x1 + origin[0] + rect.left,\n        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group\n\n    while (item.mark && (item = item.mark.group)) {\n      x += item.x || 0;\n      y += item.y || 0;\n    } // return DOMRect-compatible bounding box\n\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      left: x,\n      top: y,\n      right: x + width,\n      bottom: y + height\n    };\n  }\n\n};\n\n/**\n * Create a new Renderer instance.\n * @param {object} [loader] - Optional loader instance for\n *   image and href URL sanitization. If not specified, a\n *   standard loader instance will be generated.\n * @constructor\n */\n\nfunction Renderer(loader) {\n  this._el = null;\n  this._bgcolor = null;\n  this._loader = new ResourceLoader(loader);\n}\nRenderer.prototype = {\n  /**\n   * Initialize a new Renderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._el = el;\n    return this.resize(width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length === 0) return this._bgcolor;\n    this._bgcolor = bgcolor;\n    return this;\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    this._width = width;\n    this._height = height;\n    this._origin = origin || [0, 0];\n    this._scale = scaleFactor || 1;\n    return this;\n  },\n\n  /**\n   * Report a dirty item whose bounds should be redrawn.\n   * This base class method does nothing. Subclasses that perform\n   * incremental should implement this method.\n   * @param {Item} item - The dirty item whose bounds should be redrawn.\n   */\n  dirty()\n  /*item*/\n  {},\n\n  /**\n   * Render an input scenegraph, potentially with a set of dirty items.\n   * This method will perform an immediate rendering with available resources.\n   * The renderer may also need to perform image loading to perform a complete\n   * render. This process can lead to asynchronous re-rendering of the scene\n   * after this method returns. To receive notification when rendering is\n   * complete, use the renderAsync method instead.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Renderer} - This renderer instance.\n   */\n  render(scene) {\n    const r = this; // bind arguments into a render call, and cache it\n    // this function may be subsequently called for async redraw\n\n    r._call = function () {\n      r._render(scene);\n    }; // invoke the renderer\n\n\n    r._call(); // clear the cached call for garbage collection\n    // async redraws will stash their own copy\n\n\n    r._call = null;\n    return r;\n  },\n\n  /**\n   * Internal rendering method. Renderer subclasses should override this\n   * method to actually perform rendering.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render()\n  /*scene*/\n  {// subclasses to override\n  },\n\n  /**\n   * Asynchronous rendering method. Similar to render, but returns a Promise\n   * that resolves when all rendering is completed. Sometimes a renderer must\n   * perform image loading to get a complete rendering. The returned\n   * Promise will not resolve until this process completes.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Promise} - A Promise that resolves when rendering is complete.\n   */\n  renderAsync(scene) {\n    const r = this.render(scene);\n    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);\n  },\n\n  /**\n   * Internal method for asynchronous resource loading.\n   * Proxies method calls to the ImageLoader, and tracks loading\n   * progress to invoke a re-render once complete.\n   * @param {string} method - The method name to invoke on the ImageLoader.\n   * @param {string} uri - The URI for the requested resource.\n   * @return {Promise} - A Promise that resolves to the requested resource.\n   */\n  _load(method, uri) {\n    var r = this,\n        p = r._loader[method](uri);\n\n    if (!r._ready) {\n      // re-render the scene when loading completes\n      const call = r._call;\n      r._ready = r._loader.ready().then(redraw => {\n        if (redraw) call();\n        r._ready = null;\n      });\n    }\n\n    return p;\n  },\n\n  /**\n   * Sanitize a URL to include as a hyperlink in the rendered scene.\n   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string to sanitize.\n   * @return {Promise} - A Promise that resolves to the sanitized URL.\n   */\n  sanitizeURL(uri) {\n    return this._load('sanitizeURL', uri);\n  },\n\n  /**\n   * Requests an image to include in the rendered scene.\n   * This method proxies a call to ImageLoader.loadImage, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string of the image.\n   * @return {Promise} - A Promise that resolves to the loaded Image.\n   */\n  loadImage(uri) {\n    return this._load('loadImage', uri);\n  }\n\n};\n\nconst KeyDownEvent = 'keydown';\nconst KeyPressEvent = 'keypress';\nconst KeyUpEvent = 'keyup';\nconst DragEnterEvent = 'dragenter';\nconst DragLeaveEvent = 'dragleave';\nconst DragOverEvent = 'dragover';\nconst MouseDownEvent = 'mousedown';\nconst MouseUpEvent = 'mouseup';\nconst MouseMoveEvent = 'mousemove';\nconst MouseOutEvent = 'mouseout';\nconst MouseOverEvent = 'mouseover';\nconst ClickEvent = 'click';\nconst DoubleClickEvent = 'dblclick';\nconst WheelEvent = 'wheel';\nconst MouseWheelEvent = 'mousewheel';\nconst TouchStartEvent = 'touchstart';\nconst TouchMoveEvent = 'touchmove';\nconst TouchEndEvent = 'touchend';\nconst Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];\nconst TooltipShowEvent = MouseMoveEvent;\nconst TooltipHideEvent = MouseOutEvent;\nconst HrefEvent = ClickEvent;\n\nfunction CanvasHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n  this._events = {};\n}\n\nconst eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed\n\n\nfunction eventListenerCheck(handler, type) {\n  eventBundle(type).forEach(_ => addEventListener(handler, _));\n}\n\nfunction addEventListener(handler, type) {\n  const canvas = handler.canvas();\n\n  if (canvas && !handler._events[type]) {\n    handler._events[type] = 1;\n    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));\n  }\n}\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function (evt) {\n    const a = this._active,\n          p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        this.fire(outEvent, evt);\n      }\n\n      this._active = p; // set new active item\n\n      this.fire(overEvent, evt); // fire over for new active item\n\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function (evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\ninherits(CanvasHandler, Handler, {\n  initialize(el, origin, obj) {\n    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management\n\n    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  // return the backing canvas instance\n  canvas() {\n    return this._canvas;\n  },\n\n  // retrieve the current canvas context\n  context() {\n    return this._canvas.getContext('2d');\n  },\n\n  // supported events\n  events: Events,\n\n  // to keep old versions of firefox happy\n  DOMMouseScroll(evt) {\n    this.fire(MouseWheelEvent, evt);\n  },\n\n  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),\n  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),\n  mouseout: inactive(MouseOutEvent),\n  dragleave: inactive(DragLeaveEvent),\n\n  mousedown(evt) {\n    this._down = this._active;\n    this.fire(MouseDownEvent, evt);\n  },\n\n  click(evt) {\n    if (this._down === this._active) {\n      this.fire(ClickEvent, evt);\n      this._down = null;\n    }\n  },\n\n  touchstart(evt) {\n    this._touch = this.pickEvent(evt.changedTouches[0]);\n\n    if (this._first) {\n      this._active = this._touch;\n      this._first = false;\n    }\n\n    this.fire(TouchStartEvent, evt, true);\n  },\n\n  touchmove(evt) {\n    this.fire(TouchMoveEvent, evt, true);\n  },\n\n  touchend(evt) {\n    this.fire(TouchEndEvent, evt, true);\n    this._touch = null;\n  },\n\n  // fire an event\n  fire(type, evt, touch) {\n    const a = touch ? this._touch : this._active,\n          h = this._handlers[type]; // set event type relative to scenegraph items\n\n    evt.vegaType = type; // handle hyperlinks and tooltips first\n\n    if (type === HrefEvent && a && a.href) {\n      this.handleHref(evt, a, a.href);\n    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n      this.handleTooltip(evt, a, type !== TooltipHideEvent);\n    } // invoke all registered handlers\n\n\n    if (h) {\n      for (let i = 0, len = h.length; i < len; ++i) {\n        h[i].handler.call(this._obj, evt, a);\n      }\n    }\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      eventListenerCheck(this, type);\n      (h[name] || (h[name] = [])).push({\n        type: type,\n        handler: handler\n      });\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      h.splice(i, 1);\n    }\n\n    return this;\n  },\n\n  pickEvent(evt) {\n    const p = point(evt, this._canvas),\n          o = this._origin;\n    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n  },\n\n  // find the scenegraph item at the current mouse position\n  // x, y -- the absolute x, y mouse coordinates on the canvas element\n  // gx, gy -- the relative coordinates within the current group\n  pick(scene, x, y, gx, gy) {\n    const g = this.context(),\n          mark = Marks[scene.marktype];\n    return mark.pick.call(this, g, scene, x, y, gx, gy);\n  }\n\n});\n\nfunction devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\n\nvar pixelRatio = devicePixelRatio();\nfunction resize (canvas, width, height, origin, scaleFactor, opt) {\n  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,\n        context = canvas.getContext('2d'),\n        ratio = inDOM ? pixelRatio : scaleFactor;\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n\n  for (const key in opt) {\n    context[key] = opt[key];\n  }\n\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  context.pixelRatio = ratio;\n  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);\n  return canvas;\n}\n\nfunction CanvasRenderer(loader) {\n  Renderer.call(this, loader);\n  this._options = {};\n  this._redraw = false;\n  this._dirty = new Bounds();\n  this._tempb = new Bounds();\n}\nconst base$1 = Renderer.prototype;\n\nconst viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)\n\n  if (g.pixelRatio % 1) {\n    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n  } // to avoid artifacts translate if origin has fractional pixels\n\n\n  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path\n\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n  return b;\n}\n\ninherits(CanvasRenderer, Renderer, {\n  initialize(el, width, height, origin, scaleFactor, options) {\n    this._options = options || {};\n    this._canvas = this._options.externalContext ? null : canvas(1, 1, this._options.type); // instantiate a small canvas\n\n    if (el && this._canvas) {\n      domClear(el, 0).appendChild(this._canvas);\n\n      this._canvas.setAttribute('class', 'marks');\n    } // this method will invoke resize to size the canvas appropriately\n\n\n    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  resize(width, height, origin, scaleFactor) {\n    base$1.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._canvas) {\n      // configure canvas size and transform\n      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);\n    } else {\n      // external context needs to be scaled and positioned to origin\n      const ctx = this._options.externalContext;\n      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');\n      ctx.scale(this._scale, this._scale);\n      ctx.translate(this._origin[0], this._origin[1]);\n    }\n\n    this._redraw = true;\n    return this;\n  },\n\n  canvas() {\n    return this._canvas;\n  },\n\n  context() {\n    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);\n  },\n\n  dirty(item) {\n    const b = this._tempb.clear().union(item.bounds);\n\n    let g = item.mark.group;\n\n    while (g) {\n      b.translate(g.x || 0, g.y || 0);\n      g = g.mark.group;\n    }\n\n    this._dirty.union(b);\n  },\n\n  _render(scene) {\n    const g = this.context(),\n          o = this._origin,\n          w = this._width,\n          h = this._height,\n          db = this._dirty,\n          vb = viewBounds(o, w, h); // setup\n\n    g.save();\n    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);\n    this.clear(-o[0], -o[1], w, h); // render\n\n    this.draw(g, scene, b); // takedown\n\n    g.restore();\n    db.clear();\n    return this;\n  },\n\n  draw(ctx, scene, bounds) {\n    const mark = Marks[scene.marktype];\n    if (scene.clip) clip(ctx, scene);\n    mark.draw.call(this, ctx, scene, bounds);\n    if (scene.clip) ctx.restore();\n  },\n\n  clear(x, y, w, h) {\n    const opt = this._options,\n          g = this.context();\n\n    if (opt.type !== 'pdf' && !opt.externalContext) {\n      // calling clear rect voids vector output in pdf mode\n      // and could remove external context content (#2615)\n      g.clearRect(x, y, w, h);\n    }\n\n    if (this._bgcolor != null) {\n      g.fillStyle = this._bgcolor;\n      g.fillRect(x, y, w, h);\n    }\n  }\n\n});\n\nfunction SVGHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  const h = this;\n  h._hrefHandler = listener(h, (evt, item) => {\n    if (item && item.href) h.handleHref(evt, item, item.href);\n  });\n  h._tooltipHandler = listener(h, (evt, item) => {\n    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n  });\n} // wrap an event listener for the SVG DOM\n\nconst listener = (context, handler) => evt => {\n  let item = evt.target.__data__;\n  item = Array.isArray(item) ? item[0] : item;\n  evt.vegaType = evt.type;\n  handler.call(context._obj, evt, item);\n};\n\ninherits(SVGHandler, Handler, {\n  initialize(el, origin, obj) {\n    let svg = this._svg;\n\n    if (svg) {\n      svg.removeEventListener(HrefEvent, this._hrefHandler);\n      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    this._svg = svg = el && domFind(el, 'svg');\n\n    if (svg) {\n      svg.addEventListener(HrefEvent, this._hrefHandler);\n      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  canvas() {\n    return this._svg;\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      const x = {\n        type,\n        handler,\n        listener: listener(this, handler)\n      };\n      (h[name] || (h[name] = [])).push(x);\n\n      if (this._svg) {\n        this._svg.addEventListener(name, x.listener);\n      }\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      if (this._svg) {\n        this._svg.removeEventListener(name, h[i].listener);\n      }\n\n      h.splice(i, 1);\n    }\n\n    return this;\n  }\n\n});\n\nconst ARIA_HIDDEN = 'aria-hidden';\nconst ARIA_LABEL = 'aria-label';\nconst ARIA_ROLE = 'role';\nconst ARIA_ROLEDESCRIPTION = 'aria-roledescription';\nconst GRAPHICS_OBJECT = 'graphics-object';\nconst GRAPHICS_SYMBOL = 'graphics-symbol';\n\nconst bundle = (role, roledesc, label) => ({\n  [ARIA_ROLE]: role,\n  [ARIA_ROLEDESCRIPTION]: roledesc,\n  [ARIA_LABEL]: label || undefined\n}); // these roles are covered by related roles\n// we can ignore them, no need to generate attributes\n\n\nconst AriaIgnore = toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles\n\nconst AriaGuides = {\n  'axis': {\n    desc: 'axis',\n    caption: axisCaption\n  },\n  'legend': {\n    desc: 'legend',\n    caption: legendCaption\n  },\n  'title-text': {\n    desc: 'title',\n    caption: item => `Title text '${titleCaption(item)}'`\n  },\n  'title-subtitle': {\n    desc: 'subtitle',\n    caption: item => `Subtitle text '${titleCaption(item)}'`\n  }\n}; // aria properties generated for mark item encoding channels\n\nconst AriaEncode = {\n  ariaRole: ARIA_ROLE,\n  ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n  description: ARIA_LABEL\n};\nfunction ariaItemAttributes(emit, item) {\n  const hide = item.aria === false;\n  emit(ARIA_HIDDEN, hide || undefined);\n\n  if (hide || item.description == null) {\n    for (const prop in AriaEncode) {\n      emit(AriaEncode[prop], undefined);\n    }\n  } else {\n    const type = item.mark.marktype;\n    emit(ARIA_LABEL, item.description);\n    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));\n    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);\n  }\n}\nfunction ariaMarkAttributes(mark) {\n  return mark.aria === false ? {\n    [ARIA_HIDDEN]: true\n  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);\n}\n\nfunction ariaMark(mark) {\n  const type = mark.marktype;\n  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);\n  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);\n}\n\nfunction ariaGuide(mark, opt) {\n  try {\n    const item = mark.items[0],\n          caption = opt.caption || (() => '');\n\n    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction titleCaption(item) {\n  return array(item.text).join(' ');\n}\n\nfunction axisCaption(item) {\n  const datum = item.datum,\n        orient = item.orient,\n        title = datum.title ? extractTitle(item) : null,\n        ctx = item.context,\n        scale = ctx.scales[datum.scale].value,\n        locale = ctx.dataflow.locale(),\n        type = scale.type,\n        xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';\n  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${isDiscrete(type) ? 'discrete' : type} scale` + ` with ${domainCaption(locale, scale, item)}`;\n}\n\nfunction legendCaption(item) {\n  const datum = item.datum,\n        title = datum.title ? extractTitle(item) : null,\n        type = `${datum.type || ''} legend`.trim(),\n        scales = datum.scales,\n        props = Object.keys(scales),\n        ctx = item.context,\n        scale = ctx.scales[scales[props[0]]].value,\n        locale = ctx.dataflow.locale();\n  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${domainCaption(locale, scale, item)}`;\n}\n\nfunction extractTitle(item) {\n  try {\n    return array(peek(item.items).items[0].text).join(' ');\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction channelCaption(props) {\n  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\n  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + peek(props);\n}\n\nfunction capitalize(s) {\n  return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n}\n\nconst innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\nconst attrText = val => innerText(val).replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n\nfunction markup() {\n  let buf = '',\n      outer = '',\n      inner = '';\n\n  const stack = [],\n        clear = () => outer = inner = '',\n        push = tag => {\n    if (outer) {\n      buf += `${outer}>${inner}`;\n      clear();\n    }\n\n    stack.push(tag);\n  },\n        attr = (name, value) => {\n    if (value != null) outer += ` ${name}=\"${attrText(value)}\"`;\n    return m;\n  },\n        m = {\n    open(tag, ...attrs) {\n      push(tag);\n      outer = '<' + tag;\n\n      for (const set of attrs) {\n        for (const key in set) attr(key, set[key]);\n      }\n\n      return m;\n    },\n\n    close() {\n      const tag = stack.pop();\n\n      if (outer) {\n        buf += outer + (inner ? `>${inner}</${tag}>` : '/>');\n      } else {\n        buf += `</${tag}>`;\n      }\n\n      clear();\n      return m;\n    },\n\n    attr,\n    text: t => (inner += innerText(t), m),\n    toString: () => buf\n  };\n\n  return m;\n}\nconst serializeXML = node => _serialize(markup(), node) + '';\n\nfunction _serialize(m, node) {\n  m.open(node.tagName);\n\n  if (node.hasAttributes()) {\n    const attrs = node.attributes,\n          n = attrs.length;\n\n    for (let i = 0; i < n; ++i) {\n      m.attr(attrs[i].name, attrs[i].value);\n    }\n  }\n\n  if (node.hasChildNodes()) {\n    const children = node.childNodes,\n          n = children.length;\n\n    for (let i = 0; i < n; i++) {\n      const child = children[i];\n      child.nodeType === 3 // text node\n      ? m.text(child.nodeValue) : _serialize(m, child);\n    }\n  }\n\n  return m.close();\n}\n\nconst styles = {\n  fill: 'fill',\n  fillOpacity: 'fill-opacity',\n  stroke: 'stroke',\n  strokeOpacity: 'stroke-opacity',\n  strokeWidth: 'stroke-width',\n  strokeCap: 'stroke-linecap',\n  strokeJoin: 'stroke-linejoin',\n  strokeDash: 'stroke-dasharray',\n  strokeDashOffset: 'stroke-dashoffset',\n  strokeMiterLimit: 'stroke-miterlimit',\n  opacity: 'opacity',\n  blend: 'mix-blend-mode'\n}; // ensure miter limit default is consistent with canvas (#2498)\n\nconst rootAttributes = {\n  'fill': 'none',\n  'stroke-miterlimit': 10\n};\n\nconst RootIndex = 0,\n      xmlns = 'http://www.w3.org/2000/xmlns/',\n      svgns = metadata.xmlns;\nfunction SVGRenderer(loader) {\n  Renderer.call(this, loader);\n  this._dirtyID = 0;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\nconst base = Renderer.prototype;\ninherits(SVGRenderer, Renderer, {\n  /**\n   * Initialize a new SVGRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    // create the svg definitions cache\n    this._defs = {};\n\n    this._clearDefs();\n\n    if (el) {\n      this._svg = domChild(el, 0, 'svg', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);\n\n      this._svg.setAttribute('version', metadata['version']);\n\n      this._svg.setAttribute('class', 'marks');\n\n      domClear(el, 1); // set the svg root group\n\n      this._root = domChild(this._svg, RootIndex, 'g', svgns);\n      setAttributes(this._root, rootAttributes); // ensure no additional child elements\n\n      domClear(this._svg, RootIndex + 1);\n    } // set background color if defined\n\n\n    this.background(this._bgcolor);\n    return base.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length && this._svg) {\n      this._svg.style.setProperty('background-color', bgcolor);\n    }\n\n    return base.background.apply(this, arguments);\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    base.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._svg) {\n      setAttributes(this._svg, {\n        width: this._width * this._scale,\n        height: this._height * this._scale,\n        viewBox: `0 0 ${this._width} ${this._height}`\n      });\n\n      this._root.setAttribute('transform', `translate(${this._origin})`);\n    }\n\n    this._dirty = [];\n    return this;\n  },\n\n  /**\n   * Returns the SVG element of the visualization.\n   * @return {DOMElement} - The SVG element.\n   */\n  canvas() {\n    return this._svg;\n  },\n\n  /**\n   * Returns an SVG text string for the rendered content,\n   * or null if this renderer is currently headless.\n   */\n  svg() {\n    const svg = this._svg,\n          bg = this._bgcolor;\n    if (!svg) return null;\n    let node;\n\n    if (bg) {\n      svg.removeAttribute('style');\n      node = domChild(svg, RootIndex, 'rect', svgns);\n      setAttributes(node, {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      });\n    }\n\n    const text = serializeXML(svg);\n\n    if (bg) {\n      svg.removeChild(node);\n\n      this._svg.style.setProperty('background-color', bg);\n    }\n\n    return text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    // perform spot updates and re-render markup\n    if (this._dirtyCheck()) {\n      if (this._dirtyAll) this._clearDefs();\n      this.mark(this._root, scene);\n      domClear(this._root, 1);\n    }\n\n    this.defs();\n    this._dirty = [];\n    ++this._dirtyID;\n    return this;\n  },\n\n  // -- Manage rendering of items marked as dirty --\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (item.dirty !== this._dirtyID) {\n      item.dirty = this._dirtyID;\n\n      this._dirty.push(item);\n    }\n  },\n\n  /**\n   * Check if a mark item is considered dirty.\n   * @param {Item} item - The mark item.\n   */\n  isDirty(item) {\n    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;\n  },\n\n  /**\n   * Internal method to check dirty status and, if possible,\n   * make targetted updates without a full rendering pass.\n   */\n  _dirtyCheck() {\n    this._dirtyAll = true;\n    const items = this._dirty;\n    if (!items.length || !this._dirtyID) return true;\n    const id = ++this._dirtyID;\n    let item, mark, type, mdef, i, n, o;\n\n    for (i = 0, n = items.length; i < n; ++i) {\n      item = items[i];\n      mark = item.mark;\n\n      if (mark.marktype !== type) {\n        // memoize mark instance lookup\n        type = mark.marktype;\n        mdef = Marks[type];\n      }\n\n      if (mark.zdirty && mark.dirty !== id) {\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n        mark.items.forEach(i => {\n          i.dirty = id;\n        });\n      }\n\n      if (mark.zdirty) continue; // handle in standard drawing pass\n\n      if (item.exit) {\n        // EXIT\n        if (mdef.nested && mark.items.length) {\n          // if nested mark with remaining points, update instead\n          o = mark.items[0];\n          if (o._svg) this._update(mdef, o._svg, o);\n        } else if (item._svg) {\n          // otherwise remove from DOM\n          o = item._svg.parentNode;\n          if (o) o.removeChild(item._svg);\n        }\n\n        item._svg = null;\n        continue;\n      }\n\n      item = mdef.nested ? mark.items[0] : item;\n      if (item._update === id) continue; // already visited\n\n      if (!item._svg || !item._svg.ownerSVGElement) {\n        // ENTER\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n      } else {\n        // IN-PLACE UPDATE\n        this._update(mdef, item._svg, item);\n      }\n\n      item._update = id;\n    }\n\n    return !this._dirtyAll;\n  },\n\n  // -- Construct & maintain scenegraph to SVG mapping ---\n\n  /**\n   * Render a set of mark items.\n   * @param {SVGElement} el - The parent element in the SVG tree.\n   * @param {object} scene - The mark parent to render.\n   * @param {SVGElement} prev - The previous sibling in the SVG tree.\n   */\n  mark(el, scene, prev) {\n    if (!this.isDirty(scene)) return scene._svg;\n    const svg = this._svg,\n          mdef = Marks[scene.marktype],\n          events = scene.interactive === false ? 'none' : null,\n          isGroup = mdef.tag === 'g';\n    let sibling = null,\n        i = 0;\n    const parent = bind(scene, el, prev, 'g', svg);\n    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element\n\n    const aria = ariaMarkAttributes(scene);\n\n    for (const key in aria) setAttribute(parent, key, aria[key]);\n\n    if (!isGroup) {\n      setAttribute(parent, 'pointer-events', events);\n    }\n\n    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);\n\n    const process = item => {\n      const dirty = this.isDirty(item),\n            node = bind(item, parent, sibling, mdef.tag, svg);\n\n      if (dirty) {\n        this._update(mdef, node, item);\n\n        if (isGroup) recurse(this, node, item);\n      }\n\n      sibling = node;\n      ++i;\n    };\n\n    if (mdef.nested) {\n      if (scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    domClear(parent, i);\n    return parent;\n  },\n\n  /**\n   * Update the attributes of an SVG element for a mark item.\n   * @param {object} mdef - The mark definition object\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  _update(mdef, el, item) {\n    // set dom element and values cache\n    // provides access to emit method\n    element = el;\n    values = el.__values__; // apply aria-specific properties\n\n    ariaItemAttributes(emit, item); // apply svg attributes\n\n    mdef.attr(emit, item, this); // some marks need special treatment\n\n    const extra = mark_extras[mdef.type];\n    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes\n    // note: element state may have been modified by 'extra' method\n\n    if (element) this.style(element, item);\n  },\n\n  /**\n   * Update the presentation attributes of an SVG element for a mark item.\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  style(el, item) {\n    if (item == null) return;\n\n    for (const prop in styles) {\n      let value = prop === 'font' ? fontFamily(item) : item[prop];\n      if (value === values[prop]) continue;\n      const name = styles[prop];\n\n      if (value == null) {\n        el.removeAttribute(name);\n      } else {\n        if (isGradient(value)) {\n          value = gradientRef(value, this._defs.gradient, href());\n        }\n\n        el.setAttribute(name, value + '');\n      }\n\n      values[prop] = value;\n    }\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   */\n  defs() {\n    const svg = this._svg,\n          defs = this._defs;\n    let el = defs.el,\n        index = 0;\n\n    for (const id in defs.gradient) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateGradient(el, defs.gradient[id], index);\n    }\n\n    for (const id in defs.clipping) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateClipping(el, defs.clipping[id], index);\n    } // clean-up\n\n\n    if (el) {\n      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);\n    }\n  },\n\n  /**\n   * Clear defs caches.\n   */\n  _clearDefs() {\n    const def = this._defs;\n    def.gradient = {};\n    def.clipping = {};\n  }\n\n}); // mark ancestor chain with a dirty id\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n} // update gradient definitions\n\n\nfunction updateGradient(el, grad, index) {\n  let i, n, stop;\n\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // We wrap the radial gradient in a pattern element, allowing us to\n    // maintain a circular gradient that matches what canvas provides.\n    let pt = domChild(el, index++, 'pattern', svgns);\n    setAttributes(pt, {\n      id: patternPrefix + grad.id,\n      viewBox: '0,0,1,1',\n      width: '100%',\n      height: '100%',\n      preserveAspectRatio: 'xMidYMid slice'\n    });\n    pt = domChild(pt, 0, 'rect', svgns);\n    setAttributes(pt, {\n      width: 1,\n      height: 1,\n      fill: `url(${href()}#${grad.id})`\n    });\n    el = domChild(el, index++, 'radialGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      fx: grad.x1,\n      fy: grad.y1,\n      fr: grad.r1,\n      cx: grad.x2,\n      cy: grad.y2,\n      r: grad.r2\n    });\n  } else {\n    el = domChild(el, index++, 'linearGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      x1: grad.x1,\n      x2: grad.x2,\n      y1: grad.y1,\n      y2: grad.y2\n    });\n  }\n\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = domChild(el, i, 'stop', svgns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n\n  domClear(el, i);\n  return index;\n} // update clipping path definitions\n\n\nfunction updateClipping(el, clip, index) {\n  let mask;\n  el = domChild(el, index, 'clipPath', svgns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', svgns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', svgns);\n    setAttributes(mask, {\n      x: 0,\n      y: 0,\n      width: clip.width,\n      height: clip.height\n    });\n  }\n\n  domClear(el, 1);\n  return index + 1;\n} // Recursively process group contents.\n\n\nfunction recurse(renderer, el, group) {\n  el = el.lastChild.previousSibling;\n  let prev,\n      idx = 0;\n  visit(group, item => {\n    prev = renderer.mark(el, item, prev);\n    ++idx;\n  }); // remove any extraneous DOM elements\n\n  domClear(el, 1 + idx);\n} // Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\n\n\nfunction bind(item, el, sibling, tag, svg) {\n  let node = item._svg,\n      doc; // create a new dom node if needed\n\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, svgns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {\n        fill: 'default'\n      }; // if group, create background, content, and foreground elements\n\n      if (tag === 'g') {\n        const bg = domCreate(doc, 'path', svgns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n        const cg = domCreate(doc, 'g', svgns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n        const fg = domCreate(doc, 'path', svgns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {\n          fill: 'default'\n        };\n      }\n    }\n  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n\n\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n} // check if two nodes are ordered siblings\n\n\nfunction siblingCheck(node, sibling) {\n  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same\n} // -- Set attributes & styles on SVG elements ---\n\n\nlet element = null,\n    // temp var for current SVG element\nvalues = null; // temp var for current values hash\n// Extra configuration for certain mark types\n\nconst mark_extras = {\n  group(mdef, el, item) {\n    const fg = element = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n    values = el.__values__; // use parent's values hash\n\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n    const bg = element = el.childNodes[0];\n    mdef.background(emit, item, this);\n    const value = item.mark.interactive === false ? 'none' : null;\n\n    if (value !== values.events) {\n      setAttribute(fg, 'pointer-events', value);\n      setAttribute(bg, 'pointer-events', value);\n      values.events = value;\n    }\n\n    if (item.strokeForeground && item.stroke) {\n      const fill = item.fill;\n      setAttribute(fg, 'display', null); // set style of background\n\n      this.style(bg, item);\n      setAttribute(bg, 'stroke', null); // set style of foreground\n\n      if (fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (fill) item.fill = fill; // leave element null to prevent downstream styling\n\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      setAttribute(fg, 'display', 'none');\n    }\n  },\n\n  image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n\n  text(mdef, el, item) {\n    const tl = textLines(item);\n    let key, value, doc, lh;\n\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(_ => textValue(item, _));\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach((t, i) => {\n          const ts = domCreate(doc, 'tspan', svgns);\n          ts.__data__ = item; // data binding\n\n          ts.textContent = t;\n\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n\n    setAttribute(el, 'font-family', fontFamily(item));\n    setAttribute(el, 'font-size', fontSize(item) + 'px');\n    setAttribute(el, 'font-style', item.fontStyle);\n    setAttribute(el, 'font-variant', item.fontVariant);\n    setAttribute(el, 'font-weight', item.fontWeight);\n  }\n\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return; // use appropriate method given namespace (ns)\n\n  if (ns) {\n    setAttributeNS(element, name, value, ns);\n  } else {\n    setAttribute(element, name, value);\n  } // note current value for future comparison\n\n\n  values[name] = value;\n}\n\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n\n    values[name] = value;\n  }\n}\n\nfunction setAttributes(el, attrs) {\n  for (const key in attrs) {\n    setAttribute(el, key, attrs[key]);\n  }\n}\n\nfunction setAttribute(el, name, value) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttribute(name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttribute(name);\n  }\n}\n\nfunction setAttributeNS(el, name, value, ns) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttributeNS(ns, name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttributeNS(ns, name);\n  }\n}\n\nfunction href() {\n  let loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}\n\nfunction SVGStringRenderer(loader) {\n  Renderer.call(this, loader);\n  this._text = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n}\ninherits(SVGStringRenderer, Renderer, {\n  /**\n   * Returns the rendered SVG text string,\n   * or null if rendering has not yet occurred.\n   */\n  svg() {\n    return this._text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    const m = markup(); // svg tag\n\n    m.open('svg', extend({}, metadata, {\n      class: 'marks',\n      width: this._width * this._scale,\n      height: this._height * this._scale,\n      viewBox: `0 0 ${this._width} ${this._height}`\n    })); // background, if defined\n\n    const bg = this._bgcolor;\n\n    if (bg && bg !== 'transparent' && bg !== 'none') {\n      m.open('rect', {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      }).close();\n    } // root content group\n\n\n    m.open('g', rootAttributes, {\n      transform: 'translate(' + this._origin + ')'\n    });\n    this.mark(m, scene);\n    m.close(); // </g>\n    // defs\n\n    this.defs(m); // get SVG text string\n\n    this._text = m.close() + '';\n    return this;\n  },\n\n  /**\n   * Render a set of mark items.\n   * @param {object} m - The markup context.\n   * @param {object} scene - The mark parent to render.\n   */\n  mark(m, scene) {\n    const mdef = Marks[scene.marktype],\n          tag = mdef.tag,\n          attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag\n\n    m.open('g', {\n      'class': cssClass(scene),\n      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null\n    }, ariaMarkAttributes(scene), {\n      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n    }); // render contained elements\n\n    const process = item => {\n      const href = this.href(item);\n      if (href) m.open('a', href);\n      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));\n\n      if (tag === 'text') {\n        const tl = textLines(item);\n\n        if (isArray(tl)) {\n          // multi-line text\n          const attrs = {\n            x: 0,\n            dy: lineHeight(item)\n          };\n\n          for (let i = 0; i < tl.length; ++i) {\n            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();\n          }\n        } else {\n          // single-line text\n          m.text(textValue(item, tl));\n        }\n      } else if (tag === 'g') {\n        const fore = item.strokeForeground,\n              fill = item.fill,\n              stroke = item.stroke;\n\n        if (fore && stroke) {\n          item.stroke = null;\n        }\n\n        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content\n\n        m.open('g', this.attr(scene, item, mdef.content));\n        visit(item, scene => this.mark(m, scene));\n        m.close();\n\n        if (fore && stroke) {\n          if (fill) item.fill = null;\n          item.stroke = stroke;\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();\n          if (fill) item.fill = fill;\n        } else {\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();\n        }\n      }\n\n      m.close(); // </tag>\n\n      if (href) m.close(); // </a>\n    };\n\n    if (mdef.nested) {\n      if (scene.items && scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    } // render closing group tag\n\n\n    return m.close(); // </g>\n  },\n\n  /**\n   * Get href attributes for a hyperlinked mark item.\n   * @param {Item} item - The mark item.\n   */\n  href(item) {\n    const href = item.href;\n    let attr;\n\n    if (href) {\n      if (attr = this._hrefs && this._hrefs[href]) {\n        return attr;\n      } else {\n        this.sanitizeURL(href).then(attr => {\n          // rewrite to use xlink namespace\n          attr['xlink:href'] = attr.href;\n          attr.href = null;\n          (this._hrefs || (this._hrefs = {}))[href] = attr;\n        });\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Get an object of SVG attributes for a mark item.\n   * @param {object} scene - The mark parent.\n   * @param {Item} item - The mark item.\n   * @param {array|function} attrs - One or more attribute emitters.\n   * @param {string} tag - The tag being rendered.\n   */\n  attr(scene, item, attrs, tag) {\n    const object = {},\n          emit = (name, value, ns, prefixed) => {\n      object[prefixed || name] = value;\n    }; // apply mark specific attributes\n\n\n    if (Array.isArray(attrs)) {\n      attrs.forEach(fn => fn(emit, item, this));\n    } else {\n      attrs(emit, item, this);\n    } // apply style attributes\n\n\n    if (tag) {\n      style(object, item, scene, tag, this._defs);\n    }\n\n    return object;\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   * @param {object} m - The markup context.\n   */\n  defs(m) {\n    const gradient = this._defs.gradient,\n          clipping = this._defs.clipping,\n          count = Object.keys(gradient).length + Object.keys(clipping).length;\n    if (count === 0) return; // nothing to do\n\n    m.open('defs');\n\n    for (const id in gradient) {\n      const def = gradient[id],\n            stops = def.stops;\n\n      if (def.gradient === 'radial') {\n        // SVG radial gradients automatically transform to normalized bbox\n        // coordinates, in a way that is cumbersome to replicate in canvas.\n        // We wrap the radial gradient in a pattern element, allowing us to\n        // maintain a circular gradient that matches what canvas provides.\n        m.open('pattern', {\n          id: patternPrefix + id,\n          viewBox: '0,0,1,1',\n          width: '100%',\n          height: '100%',\n          preserveAspectRatio: 'xMidYMid slice'\n        });\n        m.open('rect', {\n          width: '1',\n          height: '1',\n          fill: 'url(#' + id + ')'\n        }).close();\n        m.close(); // </pattern>\n\n        m.open('radialGradient', {\n          id: id,\n          fx: def.x1,\n          fy: def.y1,\n          fr: def.r1,\n          cx: def.x2,\n          cy: def.y2,\n          r: def.r2\n        });\n      } else {\n        m.open('linearGradient', {\n          id: id,\n          x1: def.x1,\n          x2: def.x2,\n          y1: def.y1,\n          y2: def.y2\n        });\n      }\n\n      for (let i = 0; i < stops.length; ++i) {\n        m.open('stop', {\n          offset: stops[i].offset,\n          'stop-color': stops[i].color\n        }).close();\n      }\n\n      m.close();\n    }\n\n    for (const id in clipping) {\n      const def = clipping[id];\n      m.open('clipPath', {\n        id: id\n      });\n\n      if (def.path) {\n        m.open('path', {\n          d: def.path\n        }).close();\n      } else {\n        m.open('rect', {\n          x: 0,\n          y: 0,\n          width: def.width,\n          height: def.height\n        }).close();\n      }\n\n      m.close();\n    }\n\n    m.close();\n  }\n\n}); // Helper function for attr for style presentation attributes\n\nfunction style(s, item, scene, tag, defs) {\n  if (item == null) return s;\n\n  if (tag === 'bgrect' && scene.interactive === false) {\n    s['pointer-events'] = 'none';\n  }\n\n  if (tag === 'bgfore') {\n    if (scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n\n    s.display = 'none';\n    if (item.fill !== null) return s;\n  }\n\n  if (tag === 'image' && item.smooth === false) {\n    s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';\n  }\n\n  if (tag === 'text') {\n    s['font-family'] = fontFamily(item);\n    s['font-size'] = fontSize(item) + 'px';\n    s['font-style'] = item.fontStyle;\n    s['font-variant'] = item.fontVariant;\n    s['font-weight'] = item.fontWeight;\n  }\n\n  for (const prop in styles) {\n    let value = item[prop];\n    const name = styles[prop];\n\n    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {\n      if (isGradient(value)) {\n        value = gradientRef(value, defs.gradient, '');\n      }\n\n      s[name] = value;\n    }\n  }\n\n  return s;\n}\n\nconst Canvas = 'canvas';\nconst PNG = 'png';\nconst SVG = 'svg';\nconst None = 'none';\nconst RenderType = {\n  Canvas: Canvas,\n  PNG: PNG,\n  SVG: SVG,\n  None: None\n};\nconst modules = {};\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler: CanvasHandler\n};\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler: SVGHandler\n};\nmodules[None] = {};\nfunction renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\n\nfunction intersect(scene, bounds, filter) {\n  const hits = [],\n        // intersection results\n  box = new Bounds().union(bounds),\n        // defensive copy\n  type = scene.marktype;\n  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');\n}\n\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    const items = mark.items,\n          type = mark.marktype,\n          n = items.length;\n    let i = 0;\n\n    if (type === 'group') {\n      for (; i < n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (const test = Marks[type].isect; i < n; ++i) {\n        const item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n\n  return hits;\n}\n\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));\n}\n\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  } // recursively test children marks\n  // translate box to group coordinate space\n\n\n  const marks = group.items,\n        n = marks && marks.length;\n\n  if (n) {\n    const x = group.x || 0,\n          y = group.y || 0;\n    box.translate(-x, -y);\n\n    for (let i = 0; i < n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n\n    box.translate(x, y);\n  }\n\n  return hits;\n}\n\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  const bounds = item.bounds;\n  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);\n}\n\nconst clipBounds = new Bounds();\nfunction boundClip (mark) {\n  const clip = mark.clip;\n\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n\n  mark.bounds.intersect(clipBounds);\n}\n\nconst TOLERANCE = 1e-9;\nfunction sceneEqual(a, b, key) {\n  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : isNumber(a) && isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !isObject(a) && !isObject(b) ? a == b : objectEqual(a, b);\n}\nfunction pathEqual(a, b) {\n  return sceneEqual(pathParse(a), pathParse(b));\n}\n\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n      kb = Object.keys(b),\n      key,\n      i;\n  if (ka.length !== kb.length) return false;\n  ka.sort();\n  kb.sort();\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n\n  return typeof a === typeof b;\n}\n\nfunction resetSVGDefIds() {\n  resetSVGClipId();\n  resetSVGGradientId();\n}\n\nexport { Bounds, CanvasHandler, CanvasRenderer, Gradient, GroupItem, Handler, Item, Marks, RenderType, Renderer, ResourceLoader, SVGHandler, SVGRenderer, SVGStringRenderer, Scenegraph, boundClip, boundContext, boundItem, boundMark, boundStroke, domChild, domClear, domCreate, domFind, font, fontFamily, fontSize, intersect, intersectBoxLine, intersectPath, intersectPoint, intersectRule, lineHeight, markup, multiLineOffset, curves as pathCurves, pathEqual, pathParse, vg_rect as pathRectangle, pathRender, symbols as pathSymbols, vg_trail as pathTrail, point, renderModule, resetSVGClipId, resetSVGDefIds, sceneEqual, sceneFromJSON, pickVisit as scenePickVisit, sceneToJSON, visit as sceneVisit, zorder as sceneZOrder, serializeXML, textMetrics };\n"]},"metadata":{},"sourceType":"module"}