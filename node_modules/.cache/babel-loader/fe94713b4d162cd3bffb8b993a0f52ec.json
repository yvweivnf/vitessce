{"ast":null,"code":"import { getPositionScaleChannel, getSizeChannel, POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getViewConfigContinuousSize, getViewConfigDiscreteSize } from '../../config';\nimport { hasDiscreteDomain } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit } from '../split';\nimport { getSizeTypeFromLayoutSizeType } from './component';\nexport function parseLayerLayoutSize(model) {\n  parseChildrenLayoutSize(model);\n  parseNonUnitLayoutSizeForChannel(model, 'width');\n  parseNonUnitLayoutSizeForChannel(model, 'height');\n}\nexport function parseConcatLayoutSize(model) {\n  parseChildrenLayoutSize(model); // for columns === 1 (vconcat), we can completely merge width. Otherwise, we can treat merged width as childWidth.\n\n  const widthType = model.layout.columns === 1 ? 'width' : 'childWidth'; // for columns === undefined (hconcat), we can completely merge height. Otherwise, we can treat merged height as childHeight.\n\n  const heightType = model.layout.columns === undefined ? 'height' : 'childHeight';\n  parseNonUnitLayoutSizeForChannel(model, widthType);\n  parseNonUnitLayoutSizeForChannel(model, heightType);\n}\nexport function parseChildrenLayoutSize(model) {\n  for (const child of model.children) {\n    child.parseLayoutSize();\n  }\n}\n/**\n * Merge child layout size (width or height).\n */\n\nfunction parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {\n  var _a;\n  /*\n   * For concat, the parent width or height might not be the same as the children's shared height.\n   * For example, hconcat's subviews may share width, but the shared width is not the hconcat view's width.\n   *\n   * layoutSizeType represents the output of the view (could be childWidth/childHeight/width/height)\n   * while the sizeType represents the properties of the child.\n   */\n\n\n  const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);\n  const channel = getPositionScaleChannel(sizeType);\n  const resolve = model.component.resolve;\n  const layoutSizeCmpt = model.component.layoutSize;\n  let mergedSize; // Try to merge layout size\n\n  for (const child of model.children) {\n    const childSize = child.component.layoutSize.getWithExplicit(sizeType);\n    const scaleResolve = (_a = resolve.scale[channel]) !== null && _a !== void 0 ? _a : defaultScaleResolve(channel, model);\n\n    if (scaleResolve === 'independent' && childSize.value === 'step') {\n      // Do not merge independent scales with range-step as their size depends\n      // on the scale domains, which can be different between scales.\n      mergedSize = undefined;\n      break;\n    }\n\n    if (mergedSize) {\n      if (scaleResolve === 'independent' && mergedSize.value !== childSize.value) {\n        // For independent scale, only merge if all the sizes are the same.\n        // If the values are different, abandon the merge!\n        mergedSize = undefined;\n        break;\n      }\n\n      mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, '');\n    } else {\n      mergedSize = childSize;\n    }\n  }\n\n  if (mergedSize) {\n    // If merged, rename size and set size of all children.\n    for (const child of model.children) {\n      model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));\n      child.component.layoutSize.set(sizeType, 'merged', false);\n    }\n\n    layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);\n  } else {\n    layoutSizeCmpt.setWithExplicit(layoutSizeType, {\n      explicit: false,\n      value: undefined\n    });\n  }\n}\n\nexport function parseUnitLayoutSize(model) {\n  const {\n    size,\n    component\n  } = model;\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    const sizeType = getSizeChannel(channel);\n\n    if (size[sizeType]) {\n      const specifiedSize = size[sizeType];\n      component.layoutSize.set(sizeType, isStep(specifiedSize) ? 'step' : specifiedSize, true);\n    } else {\n      const defaultSize = defaultUnitSize(model, sizeType);\n      component.layoutSize.set(sizeType, defaultSize, false);\n    }\n  }\n}\n\nfunction defaultUnitSize(model, sizeType) {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const config = model.config;\n  const scaleComponent = model.getScaleComponent(channel);\n\n  if (scaleComponent) {\n    const scaleType = scaleComponent.get('type');\n    const range = scaleComponent.get('range');\n\n    if (hasDiscreteDomain(scaleType)) {\n      const size = getViewConfigDiscreteSize(config.view, sizeType);\n\n      if (isVgRangeStep(range) || isStep(size)) {\n        // For discrete domain with range.step, use dynamic width/height\n        return 'step';\n      } else {\n        return size;\n      }\n    } else {\n      return getViewConfigContinuousSize(config.view, sizeType);\n    }\n  } else if (model.hasProjection || model.mark === 'arc') {\n    // arc should use continuous size by default otherwise the pie is extremely small\n    return getViewConfigContinuousSize(config.view, sizeType);\n  } else {\n    const size = getViewConfigDiscreteSize(config.view, sizeType);\n    return isStep(size) ? size.step : size;\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/layoutsize/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getPositionScaleChannel, getSizeChannel, POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getViewConfigContinuousSize, getViewConfigDiscreteSize } from '../../config';\nimport { hasDiscreteDomain } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit } from '../split';\nimport { getSizeTypeFromLayoutSizeType } from './component';\nexport function parseLayerLayoutSize(model) {\n    parseChildrenLayoutSize(model);\n    parseNonUnitLayoutSizeForChannel(model, 'width');\n    parseNonUnitLayoutSizeForChannel(model, 'height');\n}\nexport function parseConcatLayoutSize(model) {\n    parseChildrenLayoutSize(model);\n    // for columns === 1 (vconcat), we can completely merge width. Otherwise, we can treat merged width as childWidth.\n    const widthType = model.layout.columns === 1 ? 'width' : 'childWidth';\n    // for columns === undefined (hconcat), we can completely merge height. Otherwise, we can treat merged height as childHeight.\n    const heightType = model.layout.columns === undefined ? 'height' : 'childHeight';\n    parseNonUnitLayoutSizeForChannel(model, widthType);\n    parseNonUnitLayoutSizeForChannel(model, heightType);\n}\nexport function parseChildrenLayoutSize(model) {\n    for (const child of model.children) {\n        child.parseLayoutSize();\n    }\n}\n/**\n * Merge child layout size (width or height).\n */\nfunction parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {\n    var _a;\n    /*\n     * For concat, the parent width or height might not be the same as the children's shared height.\n     * For example, hconcat's subviews may share width, but the shared width is not the hconcat view's width.\n     *\n     * layoutSizeType represents the output of the view (could be childWidth/childHeight/width/height)\n     * while the sizeType represents the properties of the child.\n     */\n    const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);\n    const channel = getPositionScaleChannel(sizeType);\n    const resolve = model.component.resolve;\n    const layoutSizeCmpt = model.component.layoutSize;\n    let mergedSize;\n    // Try to merge layout size\n    for (const child of model.children) {\n        const childSize = child.component.layoutSize.getWithExplicit(sizeType);\n        const scaleResolve = (_a = resolve.scale[channel]) !== null && _a !== void 0 ? _a : defaultScaleResolve(channel, model);\n        if (scaleResolve === 'independent' && childSize.value === 'step') {\n            // Do not merge independent scales with range-step as their size depends\n            // on the scale domains, which can be different between scales.\n            mergedSize = undefined;\n            break;\n        }\n        if (mergedSize) {\n            if (scaleResolve === 'independent' && mergedSize.value !== childSize.value) {\n                // For independent scale, only merge if all the sizes are the same.\n                // If the values are different, abandon the merge!\n                mergedSize = undefined;\n                break;\n            }\n            mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, '');\n        }\n        else {\n            mergedSize = childSize;\n        }\n    }\n    if (mergedSize) {\n        // If merged, rename size and set size of all children.\n        for (const child of model.children) {\n            model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));\n            child.component.layoutSize.set(sizeType, 'merged', false);\n        }\n        layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);\n    }\n    else {\n        layoutSizeCmpt.setWithExplicit(layoutSizeType, {\n            explicit: false,\n            value: undefined\n        });\n    }\n}\nexport function parseUnitLayoutSize(model) {\n    const { size, component } = model;\n    for (const channel of POSITION_SCALE_CHANNELS) {\n        const sizeType = getSizeChannel(channel);\n        if (size[sizeType]) {\n            const specifiedSize = size[sizeType];\n            component.layoutSize.set(sizeType, isStep(specifiedSize) ? 'step' : specifiedSize, true);\n        }\n        else {\n            const defaultSize = defaultUnitSize(model, sizeType);\n            component.layoutSize.set(sizeType, defaultSize, false);\n        }\n    }\n}\nfunction defaultUnitSize(model, sizeType) {\n    const channel = sizeType === 'width' ? 'x' : 'y';\n    const config = model.config;\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n        const scaleType = scaleComponent.get('type');\n        const range = scaleComponent.get('range');\n        if (hasDiscreteDomain(scaleType)) {\n            const size = getViewConfigDiscreteSize(config.view, sizeType);\n            if (isVgRangeStep(range) || isStep(size)) {\n                // For discrete domain with range.step, use dynamic width/height\n                return 'step';\n            }\n            else {\n                return size;\n            }\n        }\n        else {\n            return getViewConfigContinuousSize(config.view, sizeType);\n        }\n    }\n    else if (model.hasProjection || model.mark === 'arc') {\n        // arc should use continuous size by default otherwise the pie is extremely small\n        return getViewConfigContinuousSize(config.view, sizeType);\n    }\n    else {\n        const size = getViewConfigDiscreteSize(config.view, sizeType);\n        return isStep(size) ? size.step : size;\n    }\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}