{"ast":null,"code":"import { getFormatMixins, isFieldOrDatumDef, isValueDef } from '../../../channeldef';\nimport { signalOrValueRef } from '../../common';\nimport { formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nexport function text(model, channel = 'text') {\n  const channelDef = model.encoding[channel];\n  return wrapCondition(model, channelDef, channel, cDef => textRef(cDef, model.config));\n}\nexport function textRef(channelDef, config, expr = 'datum') {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return signalOrValueRef(channelDef.value);\n    }\n\n    if (isFieldOrDatumDef(channelDef)) {\n      const {\n        format,\n        formatType\n      } = getFormatMixins(channelDef);\n      return formatSignalRef({\n        fieldOrDatumDef: channelDef,\n        format,\n        formatType,\n        expr,\n        config\n      });\n    }\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/text.ts"],"names":[],"mappings":"AAAA,SAAQ,eAAR,EAAyB,iBAAzB,EAA4C,UAA5C,QAA6D,qBAA7D;AAIA,SAAQ,gBAAR,QAA+B,cAA/B;AACA,SAAQ,eAAR,QAA8B,cAA9B;AAEA,SAAQ,aAAR,QAA4B,eAA5B;AAEA,OAAM,SAAU,IAAV,CAAe,KAAf,EAAiC,OAAA,GAAmD,MAApF,EAA0F;AAC9F,QAAM,UAAU,GAAG,KAAK,CAAC,QAAN,CAAe,OAAf,CAAnB;AACA,SAAO,aAAa,CAAC,KAAD,EAAQ,UAAR,EAAoB,OAApB,EAA6B,IAAI,IAAI,OAAO,CAAC,IAAD,EAAO,KAAK,CAAC,MAAb,CAA5C,CAApB;AACD;AAED,OAAM,SAAU,OAAV,CACJ,UADI,EAEJ,MAFI,EAGJ,IAAA,GAAgC,OAH5B,EAGmC;AAEvC;AACA,MAAI,UAAJ,EAAgB;AACd,QAAI,UAAU,CAAC,UAAD,CAAd,EAA4B;AAC1B,aAAO,gBAAgB,CAAC,UAAU,CAAC,KAAZ,CAAvB;AACD;;AACD,QAAI,iBAAiB,CAAC,UAAD,CAArB,EAAmC;AACjC,YAAM;AAAC,QAAA,MAAD;AAAS,QAAA;AAAT,UAAuB,eAAe,CAAC,UAAD,CAA5C;AACA,aAAO,eAAe,CAAC;AAAC,QAAA,eAAe,EAAE,UAAlB;AAA8B,QAAA,MAA9B;AAAsC,QAAA,UAAtC;AAAkD,QAAA,IAAlD;AAAwD,QAAA;AAAxD,OAAD,CAAtB;AACD;AACF;;AACD,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["import { getFormatMixins, isFieldOrDatumDef, isValueDef } from '../../../channeldef';\nimport { signalOrValueRef } from '../../common';\nimport { formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nexport function text(model, channel = 'text') {\n    const channelDef = model.encoding[channel];\n    return wrapCondition(model, channelDef, channel, cDef => textRef(cDef, model.config));\n}\nexport function textRef(channelDef, config, expr = 'datum') {\n    // text\n    if (channelDef) {\n        if (isValueDef(channelDef)) {\n            return signalOrValueRef(channelDef.value);\n        }\n        if (isFieldOrDatumDef(channelDef)) {\n            const { format, formatType } = getFormatMixins(channelDef);\n            return formatSignalRef({ fieldOrDatumDef: channelDef, format, formatType, expr, config });\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}