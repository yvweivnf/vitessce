{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert, isObjectEmpty, getShaderVersion } from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\nvar Transform = /*#__PURE__*/function () {\n  _createClass(Transform, null, [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return isWebGL2(gl);\n    }\n  }]);\n\n  function Transform(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Transform);\n\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  _createClass(Transform, [{\n    key: \"delete\",\n    value: function _delete() {\n      var model = this.model,\n          bufferTransform = this.bufferTransform,\n          textureTransform = this.textureTransform;\n\n      if (model) {\n        model.delete();\n      }\n\n      if (bufferTransform) {\n        bufferTransform.delete();\n      }\n\n      if (textureTransform) {\n        textureTransform.delete();\n      }\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$clearRenderTarg = opts.clearRenderTarget,\n          clearRenderTarget = _opts$clearRenderTarg === void 0 ? true : _opts$clearRenderTarg;\n\n      var updatedOpts = this._updateDrawOptions(opts);\n\n      if (clearRenderTarget && updatedOpts.framebuffer) {\n        updatedOpts.framebuffer.clear({\n          color: true\n        });\n      }\n\n      this.model.transform(updatedOpts);\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      var swapped = false;\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n      var _iterator = _createForOfIteratorHelper(resourceTransforms),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var resourceTransform = _step.value;\n          swapped = swapped || resourceTransform.swap();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      assert(swapped, 'Nothing to swap');\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n      var _iterator2 = _createForOfIteratorHelper(resourceTransforms),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var resourceTransform = _step2.value;\n          var data = resourceTransform.getData(opts);\n\n          if (data) {\n            return data;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getFramebuffer\",\n    value: function getFramebuffer() {\n      return this.textureTransform && this.textureTransform.getFramebuffer();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if ('elementCount' in opts) {\n        this.model.setVertexCount(opts.elementCount);\n      }\n\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n      var _iterator3 = _createForOfIteratorHelper(resourceTransforms),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var resourceTransform = _step3.value;\n          resourceTransform.update(opts);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var gl = this.gl;\n\n      this._buildResourceTransforms(gl, props);\n\n      props = this._updateModelProps(props);\n      this.model = new Model(gl, Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({\n          version: getShaderVersion(props.vs)\n        }),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || 0,\n        vertexCount: props.elementCount\n      }));\n      this.bufferTransform && this.bufferTransform.setupResources({\n        model: this.model\n      });\n    }\n  }, {\n    key: \"_updateModelProps\",\n    value: function _updateModelProps(props) {\n      var updatedProps = Object.assign({}, props);\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n      var _iterator4 = _createForOfIteratorHelper(resourceTransforms),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var resourceTransform = _step4.value;\n          updatedProps = resourceTransform.updateModelProps(updatedProps);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return updatedProps;\n    }\n  }, {\n    key: \"_buildResourceTransforms\",\n    value: function _buildResourceTransforms(gl, props) {\n      if (canCreateBufferTransform(props)) {\n        this.bufferTransform = new BufferTransform(gl, props);\n      }\n\n      if (canCreateTextureTransform(props)) {\n        this.textureTransform = new TextureTransform(gl, props);\n      }\n\n      assert(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');\n    }\n  }, {\n    key: \"_updateDrawOptions\",\n    value: function _updateDrawOptions(opts) {\n      var updatedOpts = Object.assign({}, opts);\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n      var _iterator5 = _createForOfIteratorHelper(resourceTransforms),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var resourceTransform = _step5.value;\n          updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return updatedOpts;\n    }\n  }]);\n\n  return Transform;\n}();\n\nexport { Transform as default };\n\nfunction canCreateBufferTransform(props) {\n  if (!isObjectEmpty(props.feedbackBuffers) || !isObjectEmpty(props.feedbackMap) || props.varyings && props.varyings.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (!isObjectEmpty(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../src/transform/transform.js"],"names":["isWebGL2","constructor","props","Object","textureTransform","model","bufferTransform","opts","clearRenderTarget","updatedOpts","color","swapped","resourceTransforms","resourceTransform","assert","varyingName","data","gl","fs","getPassthroughFS","version","getShaderVersion","id","drawMode","vertexCount","elementCount","updatedProps","canCreateBufferTransform","canCreateTextureTransform","isObjectEmpty"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert, isObjectEmpty, getShaderVersion} from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      // @ts-ignore\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if ('elementCount' in opts) {\n      // @ts-ignore TODO\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.feedbackBuffers) ||\n    !isObjectEmpty(props.feedbackMap) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}