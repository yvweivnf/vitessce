{"ast":null,"code":"import _toConsumableArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";import tinycolor from'tinycolor2';import isEqual from'lodash/isEqual';/**\n * Execute a callback function based on a keypress event.\n * @param {object} event The event from onKeyPress\n * @param {string} key The key identifier to match.\n * @param {Function} callback The function to execute.\n */export function callbackOnKeyPress(event,key,callback){if(event.key===key){event.preventDefault();callback();}}/**\n * Convert an array of [r, g, b] numbers to a hex color.\n * @param {number[]} rgbArray The color [r, g, b] array.\n * @returns {string} The hex color as a string.\n */export function colorArrayToString(rgbArray){return tinycolor({r:rgbArray[0],g:rgbArray[1],b:rgbArray[2]}).toHexString();}/**\n * Convert a string color representation to an array of [r,g,b].\n * @param {string} colorString The color as a string.\n * @returns {number[]} The color as an array.\n */export function colorStringToArray(colorString){var colorObj=tinycolor(colorString).toRgb();return[colorObj.r,colorObj.g,colorObj.b];}/**\n * Get a string of help text for coloring a particular hierarchy level.\n * @param {integer} i The level. 1 for cluster, 2 for subcluster, etc.\n * @returns {string} The tooltip text for coloring the level.\n */export function getLevelTooltipText(i){if(i===0)return'Color by hierarchy';if(i<=2){var subs=function subs(j){return'sub'.repeat(j);};return\"Color by \".concat(subs(i-1),\"cluster\");}return\"Color by cluster level \".concat(i);}export function isEqualOrPrefix(targetPath,testPath){if(targetPath.length<=testPath.length){return isEqual(targetPath,testPath.slice(0,targetPath.length));}return false;}export function tryRenamePath(targetPath,testPath,nextTargetPath){if(isEqualOrPrefix(targetPath,testPath)){return[].concat(_toConsumableArray(nextTargetPath),_toConsumableArray(testPath.slice(nextTargetPath.length)));}return testPath;}export var PATH_SEP='___';export function pathToKey(path){return path.join(PATH_SEP);}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/utils.js"],"names":["tinycolor","isEqual","callbackOnKeyPress","event","key","callback","preventDefault","colorArrayToString","rgbArray","r","g","b","toHexString","colorStringToArray","colorString","colorObj","toRgb","getLevelTooltipText","i","subs","j","repeat","isEqualOrPrefix","targetPath","testPath","length","slice","tryRenamePath","nextTargetPath","PATH_SEP","pathToKey","path","join"],"mappings":"gMAAA,MAAOA,CAAAA,SAAP,KAAsB,YAAtB,CACA,MAAOC,CAAAA,OAAP,KAAoB,gBAApB,CAEA;;;;;GAMA,MAAO,SAASC,CAAAA,kBAAT,CAA4BC,KAA5B,CAAmCC,GAAnC,CAAwCC,QAAxC,CAAkD,CACvD,GAAIF,KAAK,CAACC,GAAN,GAAcA,GAAlB,CAAuB,CACrBD,KAAK,CAACG,cAAN,GACAD,QAAQ,GACT,CACF,CAED;;;;GAKA,MAAO,SAASE,CAAAA,kBAAT,CAA4BC,QAA5B,CAAsC,CAC3C,MAAOR,CAAAA,SAAS,CAAC,CAAES,CAAC,CAAED,QAAQ,CAAC,CAAD,CAAb,CAAkBE,CAAC,CAAEF,QAAQ,CAAC,CAAD,CAA7B,CAAkCG,CAAC,CAAEH,QAAQ,CAAC,CAAD,CAA7C,CAAD,CAAT,CAA8DI,WAA9D,EAAP,CACD,CAED;;;;GAKA,MAAO,SAASC,CAAAA,kBAAT,CAA4BC,WAA5B,CAAyC,CAC9C,GAAMC,CAAAA,QAAQ,CAAGf,SAAS,CAACc,WAAD,CAAT,CAAuBE,KAAvB,EAAjB,CACA,MAAO,CAACD,QAAQ,CAACN,CAAV,CAAaM,QAAQ,CAACL,CAAtB,CAAyBK,QAAQ,CAACJ,CAAlC,CAAP,CACD,CAED;;;;GAKA,MAAO,SAASM,CAAAA,mBAAT,CAA6BC,CAA7B,CAAgC,CACrC,GAAIA,CAAC,GAAK,CAAV,CAAa,MAAO,oBAAP,CACb,GAAIA,CAAC,EAAI,CAAT,CAAY,CACV,GAAMC,CAAAA,IAAI,CAAG,QAAPA,CAAAA,IAAO,CAAAC,CAAC,QAAK,MAAMC,MAAN,CAAaD,CAAb,CAAL,EAAd,CACA,yBAAmBD,IAAI,CAACD,CAAC,CAAG,CAAL,CAAvB,YACD,CACD,uCAAiCA,CAAjC,EACD,CAED,MAAO,SAASI,CAAAA,eAAT,CAAyBC,UAAzB,CAAqCC,QAArC,CAA+C,CACpD,GAAID,UAAU,CAACE,MAAX,EAAqBD,QAAQ,CAACC,MAAlC,CAA0C,CACxC,MAAOxB,CAAAA,OAAO,CAACsB,UAAD,CAAaC,QAAQ,CAACE,KAAT,CAAe,CAAf,CAAkBH,UAAU,CAACE,MAA7B,CAAb,CAAd,CACD,CACD,MAAO,MAAP,CACD,CAED,MAAO,SAASE,CAAAA,aAAT,CAAuBJ,UAAvB,CAAmCC,QAAnC,CAA6CI,cAA7C,CAA6D,CAClE,GAAIN,eAAe,CAACC,UAAD,CAAaC,QAAb,CAAnB,CAA2C,CACzC,mCAAWI,cAAX,qBAA8BJ,QAAQ,CAACE,KAAT,CAAeE,cAAc,CAACH,MAA9B,CAA9B,GACD,CACD,MAAOD,CAAAA,QAAP,CACD,CAED,MAAO,IAAMK,CAAAA,QAAQ,CAAG,KAAjB,CAEP,MAAO,SAASC,CAAAA,SAAT,CAAmBC,IAAnB,CAAyB,CAC9B,MAAOA,CAAAA,IAAI,CAACC,IAAL,CAAUH,QAAV,CAAP,CACD","sourcesContent":["import tinycolor from 'tinycolor2';\nimport isEqual from 'lodash/isEqual';\n\n/**\n * Execute a callback function based on a keypress event.\n * @param {object} event The event from onKeyPress\n * @param {string} key The key identifier to match.\n * @param {Function} callback The function to execute.\n */\nexport function callbackOnKeyPress(event, key, callback) {\n  if (event.key === key) {\n    event.preventDefault();\n    callback();\n  }\n}\n\n/**\n * Convert an array of [r, g, b] numbers to a hex color.\n * @param {number[]} rgbArray The color [r, g, b] array.\n * @returns {string} The hex color as a string.\n */\nexport function colorArrayToString(rgbArray) {\n  return tinycolor({ r: rgbArray[0], g: rgbArray[1], b: rgbArray[2] }).toHexString();\n}\n\n/**\n * Convert a string color representation to an array of [r,g,b].\n * @param {string} colorString The color as a string.\n * @returns {number[]} The color as an array.\n */\nexport function colorStringToArray(colorString) {\n  const colorObj = tinycolor(colorString).toRgb();\n  return [colorObj.r, colorObj.g, colorObj.b];\n}\n\n/**\n * Get a string of help text for coloring a particular hierarchy level.\n * @param {integer} i The level. 1 for cluster, 2 for subcluster, etc.\n * @returns {string} The tooltip text for coloring the level.\n */\nexport function getLevelTooltipText(i) {\n  if (i === 0) return 'Color by hierarchy';\n  if (i <= 2) {\n    const subs = j => ('sub'.repeat(j));\n    return `Color by ${subs(i - 1)}cluster`;\n  }\n  return `Color by cluster level ${i}`;\n}\n\nexport function isEqualOrPrefix(targetPath, testPath) {\n  if (targetPath.length <= testPath.length) {\n    return isEqual(targetPath, testPath.slice(0, targetPath.length));\n  }\n  return false;\n}\n\nexport function tryRenamePath(targetPath, testPath, nextTargetPath) {\n  if (isEqualOrPrefix(targetPath, testPath)) {\n    return [...nextTargetPath, ...testPath.slice(nextTargetPath.length)];\n  }\n  return testPath;\n}\n\nexport const PATH_SEP = '___';\n\nexport function pathToKey(path) {\n  return path.join(PATH_SEP);\n}\n"]},"metadata":{},"sourceType":"module"}