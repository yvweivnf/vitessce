{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueOrSignalRef } from '../common';\nimport { expression } from '../predicate';\n\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n\n  return title;\n}\n\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  var _d, _e;\n\n  (_a = axis.encode) !== null && _a !== void 0 ? _a : axis.encode = {};\n  (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};\n  (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {}; // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  axis.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleAxis(axisCmpt, kind, config, opt = {\n  header: false\n}) {\n  var _a, _b;\n\n  const _c = axisCmpt.combine(),\n        {\n    disable,\n    orient,\n    scale,\n    labelExpr,\n    title,\n    zindex\n  } = _c,\n        axis = __rest(_c, [\"disable\", \"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]);\n\n  if (disable) {\n    return undefined;\n  }\n\n  for (const prop in axis) {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      const {\n        condition\n      } = propValue,\n            valueOrSignalRef = __rest(propValue, [\"condition\"]);\n\n      const conditions = array(condition);\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex; // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n\n        const vgRef = [...conditions.map(c => {\n          const {\n            test\n          } = c,\n                valueOrSignalCRef = __rest(c, [\"test\"]);\n\n          return Object.assign({\n            test: expression(null, test)\n          }, valueOrSignalCRef);\n        }), valueOrSignalRef];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef = {\n          signal: conditions.map(c => {\n            const {\n              test\n            } = c,\n                  valueOrSignalCRef = __rest(c, [\"test\"]);\n\n            return `${expression(null, test)} ? ${exprFromValueOrSignalRef(valueOrSignalCRef)} : `;\n          }).join('') + exprFromValueOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n\n    } // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n\n\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {\n        grid\n      } = axis.encode;\n      axis.encode = Object.assign({}, grid ? {\n        grid\n      } : {});\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    return Object.assign(Object.assign({\n      scale,\n      orient\n    }, axis), {\n      domain: false,\n      labels: false,\n      aria: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n\n    });\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n\n      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n    return Object.assign(Object.assign(Object.assign(Object.assign({\n      scale,\n      orient,\n      grid: false\n    }, titleString ? {\n      title: titleString\n    } : {}), axis), config.aria === false ? {\n      aria: false\n    } : {}), {\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n\n    });\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\n\nexport function assembleAxisSignals(model) {\n  const {\n    axes\n  } = model.component;\n  const signals = [];\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update: update\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  const {\n    x = [],\n    y = []\n  } = axisComponents;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":{"version":3,"sources":["../../../../src/compile/axis/assemble.ts"],"names":[],"mappings":";;;;;;;;;;;AACA,SAAQ,KAAR,EAAe,OAAf,QAA6B,WAA7B;AACA,SAAQ,UAAR,EAAoB,kBAApB,EAAwC,2BAAxC,EAAqE,sBAArE,QAAkG,YAAlG;AACA,SAAQ,uBAAR,QAAsC,eAAtC;AACA,SAAQ,YAAR,QAAyC,kBAAzC;AAEA,SAAQ,MAAR,QAAqB,aAArB;AACA,SAAQ,QAAR,EAAkB,eAAlB,EAAmC,OAAnC,EAA4C,UAA5C,QAA6D,YAA7D;AACA,SAAQ,WAAR,QAAuD,mBAAvD;AACA,SAAQ,wBAAR,QAAuC,WAAvC;AAEA,SAAQ,UAAR,QAAyB,cAAzB;;AAGA,SAAS,aAAT,CAAuB,KAAvB,EAAyE,MAAzE,EAAuF;AACrF,MAAI,CAAC,KAAL,EAAY;AACV,WAAO,SAAP;AACD;;AACD,MAAI,OAAO,CAAC,KAAD,CAAP,IAAkB,CAAC,MAAM,CAAC,KAAD,CAA7B,EAAsC;AACpC,WAAO,KAAK,CAAC,GAAN,CAAU,QAAQ,IAAI,YAAY,CAAC,QAAD,EAAW,MAAX,CAAlC,EAAsD,IAAtD,CAA2D,IAA3D,CAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAED,SAAS,aAAT,CACE,IADF,EAEE,IAFF,EAGE,MAHF,EAIE,KAJF,EAI2C;;;;;AAEzC,GAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,EAAX,GAAA,IAAI,CAAC,MAAL,GAAgB,EAAhB;AACA,GAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,EAAY,IAAZ,CAAA,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,EAAhB,GAAgB,EAAA,CAAJ,IAAI,CAAA,GAAM,EAAtB;AACA,GAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAA,EAAkB,MAAlB,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,EAAxB,GAAwB,EAAA,CAAN,MAAM,GAAK,EAA7B,CAJyC,CAKzC;;AACC,EAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,EAAkB,MAAlB,CAAyB,MAAzB,IAA2C,KAA3C;AACF;;AAED,OAAM,SAAU,YAAV,CACJ,QADI,EAEJ,IAFI,EAGJ,MAHI,EAIJ,GAAA,GAEI;AAAC,EAAA,MAAM,EAAE;AAAT,CANA,EAMe;;;AAEnB,QAAM,EAAA,GAA8D,QAAQ,CAAC,OAAT,EAApE;AAAA,QAAM;AAAC,IAAA,OAAD;AAAU,IAAA,MAAV;AAAkB,IAAA,KAAlB;AAAyB,IAAA,SAAzB;AAAoC,IAAA,KAApC;AAA2C,IAAA;AAA3C,MAAiD,EAAvD;AAAA,QAA4D,IAAI,GAAA,MAAA,CAAA,EAAA,EAA1D,CAAA,SAAA,EAAA,QAAA,EAAA,OAAA,EAAA,WAAA,EAAA,OAAA,EAAA,QAAA,CAA0D,CAAhE;;AAEA,MAAI,OAAJ,EAAa;AACX,WAAO,SAAP;AACD;;AAED,OAAK,MAAM,IAAX,IAAmB,IAAnB,EAAyB;AACvB,UAAM,QAAQ,GAAG,kBAAkB,CAAC,IAAD,CAAnC;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,IAAD,CAAtB;;AAEA,QAAI,QAAQ,IAAI,QAAQ,KAAK,IAAzB,IAAiC,QAAQ,KAAK,MAAlD,EAA0D;AACxD;AACA,aAAO,IAAI,CAAC,IAAD,CAAX;AACD,KAHD,MAGO,IAAI,sBAAsB,CAAiB,SAAjB,CAA1B,EAAuD;AAC5D;AAEA,YAAM;AAAC,QAAA;AAAD,UAAmC,SAAzC;AAAA,YAAqB,gBAAgB,GAAA,MAAA,CAAI,SAAJ,EAA/B,CAAA,WAAA,CAA+B,CAArC;;AACA,YAAM,UAAU,GAAG,KAAK,CAAC,SAAD,CAAxB;AAEA,YAAM,SAAS,GAAG,2BAA2B,CAAC,IAAD,CAA7C;;AACA,UAAI,SAAJ,EAAe;AACb,cAAM;AAAC,UAAA,MAAD;AAAS,UAAA;AAAT,YAAiB,SAAvB,CADa,CAEb;AACA;;AAEA,cAAM,KAAK,GAAG,CACZ,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,IAAG;AACpB,gBAAM;AAAC,YAAA;AAAD,cAA+B,CAArC;AAAA,gBAAgB,iBAAiB,GAAA,MAAA,CAAI,CAAJ,EAA3B,CAAA,MAAA,CAA2B,CAAjC;;AACA,iBAAA,MAAA,CAAA,MAAA,CAAA;AACE,YAAA,IAAI,EAAE,UAAU,CAAC,IAAD,EAAO,IAAP;AADlB,WAAA,EAEK,iBAFL,CAAA;AAID,SANE,CADS,EAQZ,gBARY,CAAd;AAUA,QAAA,aAAa,CAAC,IAAD,EAAO,IAAP,EAAa,MAAb,EAAqB,KAArB,CAAb;AACA,eAAO,IAAI,CAAC,IAAD,CAAX;AACD,OAjBD,MAiBO,IAAI,SAAS,KAAK,IAAlB,EAAwB;AAC7B;AACA,cAAM,SAAS,GAAc;AAC3B,UAAA,MAAM,EACJ,UAAU,CACP,GADH,CACO,CAAC,IAAG;AACP,kBAAM;AAAC,cAAA;AAAD,gBAA+B,CAArC;AAAA,kBAAgB,iBAAiB,GAAA,MAAA,CAAI,CAAJ,EAA3B,CAAA,MAAA,CAA2B,CAAjC;;AACA,mBAAO,GAAG,UAAU,CAAC,IAAD,EAAO,IAAP,CAAY,MAAM,wBAAwB,CAAC,iBAAD,CAAmB,KAAjF;AACD,WAJH,EAKG,IALH,CAKQ,EALR,IAKc,wBAAwB,CAAC,gBAAD;AAPb,SAA7B;AASA,QAAA,IAAI,CAAC,IAAD,CAAJ,GAAa,SAAb;AACD;AACF,KArCM,MAqCA,IAAI,WAAW,CAAC,SAAD,CAAf,EAA4B;AACjC,YAAM,SAAS,GAAG,2BAA2B,CAAC,IAAD,CAA7C;;AACA,UAAI,SAAJ,EAAe;AACb,cAAM;AAAC,UAAA,MAAD;AAAS,UAAA;AAAT,YAAiB,SAAvB;AACA,QAAA,aAAa,CAAC,IAAD,EAAO,IAAP,EAAa,MAAb,EAAqB,SAArB,CAAb;AACA,eAAO,IAAI,CAAC,IAAD,CAAX;AACD,OANgC,CAM/B;;AACH,KAnDsB,CAqDvB;AACA;;;AACA,QAAI,QAAQ,CAAC,CAAC,YAAD,EAAe,eAAf,CAAD,EAAkC,IAAlC,CAAR,IAAmD,IAAI,CAAC,IAAD,CAAJ,KAAe,IAAtE,EAA4E;AAC1E,aAAO,IAAI,CAAC,IAAD,CAAX;AACD;AACF;;AAED,MAAI,IAAI,KAAK,MAAb,EAAqB;AACnB,QAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;AACd,aAAO,SAAP;AACD,KAHkB,CAKnB;;;AACA,QAAI,IAAI,CAAC,MAAT,EAAiB;AACf;AACA,YAAM;AAAC,QAAA;AAAD,UAAS,IAAI,CAAC,MAApB;AACA,MAAA,IAAI,CAAC,MAAL,GAAW,MAAA,CAAA,MAAA,CAAA,EAAA,EACL,IAAI,GAAG;AAAC,QAAA;AAAD,OAAH,GAAY,EADX,CAAX;;AAIA,UAAI,OAAO,CAAC,IAAI,CAAC,MAAN,CAAX,EAA0B;AACxB,eAAO,IAAI,CAAC,MAAZ;AACD;AACF;;AAED,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACE,MAAA,KADF;AAEE,MAAA;AAFF,KAAA,EAGK,IAHL,CAAA,EAGS;AACP,MAAA,MAAM,EAAE,KADD;AAEP,MAAA,MAAM,EAAE,KAFD;AAGP,MAAA,IAAI,EAAE,KAHC;AAKP;AACA;AACA,MAAA,SAAS,EAAE,CAPJ;AAQP,MAAA,SAAS,EAAE,CARJ;AASP,MAAA,KAAK,EAAE,KATA;AAUP,MAAA,MAAM,EAAE,eAAe,CAAC,MAAD,EAAS,CAAT,CAVhB,CAU4B;;AAV5B,KAHT,CAAA;AAeD,GAjCD,MAiCO;AACL;AAEA,QAAI,CAAC,GAAG,CAAC,MAAL,IAAe,QAAQ,CAAC,aAA5B,EAA2C;AACzC;AACA,aAAO,SAAP;AACD;;AAED,QAAI,SAAS,KAAK,SAAlB,EAA6B;AAC3B,UAAI,IAAI,GAAG,SAAX;;AACA,UAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,MAAb,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,KAAA,CAAnB,GAAmB,EAAA,CAAE,MAArB,KAA+B,WAAW,CAAC,IAAI,CAAC,MAAL,CAAY,MAAZ,CAAmB,MAAnB,CAA0B,IAA3B,CAA9C,EAAgF;AAC9E,QAAA,IAAI,GAAG,UAAU,CAAC,SAAD,EAAY,aAAZ,EAA2B,IAAI,CAAC,MAAL,CAAY,MAAZ,CAAmB,MAAnB,CAA0B,IAA1B,CAA+B,MAA1D,CAAjB;AACD;;AACD,MAAA,aAAa,CAAC,IAAD,EAAO,QAAP,EAAiB,MAAjB,EAAyB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAzB,CAAb;AACD;;AAED,QAAI,IAAI,CAAC,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,aAAO,IAAI,CAAC,UAAZ;AACD,KAlBI,CAoBL;;;AACA,QAAI,IAAI,CAAC,MAAT,EAAiB;AACf,WAAK,MAAM,IAAX,IAAmB,UAAnB,EAA+B;AAC7B,YAAI,CAAC,QAAQ,CAAC,WAAT,CAAqB,IAArB,CAAL,EAAiC;AAC/B,iBAAO,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAP;AACD;AACF;;AACD,UAAI,OAAO,CAAC,IAAI,CAAC,MAAN,CAAX,EAA0B;AACxB,eAAO,IAAI,CAAC,MAAZ;AACD;AACF;;AAED,UAAM,WAAW,GAAG,aAAa,CAAC,KAAD,EAAQ,MAAR,CAAjC;AAEA,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACE,MAAA,KADF;AAEE,MAAA,MAFF;AAGE,MAAA,IAAI,EAAE;AAHR,KAAA,EAIM,WAAW,GAAG;AAAC,MAAA,KAAK,EAAE;AAAR,KAAH,GAA0B,EAJ3C,CAAA,EAKK,IALL,CAAA,EAMM,MAAM,CAAC,IAAP,KAAgB,KAAhB,GAAwB;AAAC,MAAA,IAAI,EAAE;AAAP,KAAxB,GAAwC,EAN9C,CAAA,EAMiD;AAC/C,MAAA,MAAM,EAAE,eAAe,CAAC,MAAD,EAAS,CAAT,CADwB,CACZ;;AADY,KANjD,CAAA;AASD;AACF;AAED;;;;;AAIA,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAA0C;AAC9C,QAAM;AAAC,IAAA;AAAD,MAAS,KAAK,CAAC,SAArB;AACA,QAAM,OAAO,GAAgB,EAA7B;;AAEA,OAAK,MAAM,OAAX,IAAsB,uBAAtB,EAA+C;AAC7C,QAAI,IAAI,CAAC,OAAD,CAAR,EAAmB;AACjB,WAAK,MAAM,IAAX,IAAmB,IAAI,CAAC,OAAD,CAAvB,EAAkC;AAChC,YAAI,CAAC,IAAI,CAAC,GAAL,CAAS,SAAT,CAAD,IAAwB,CAAC,IAAI,CAAC,GAAL,CAAS,WAAT,CAA7B,EAAoD;AAClD;AAEA,gBAAM,QAAQ,GAAG,OAAO,KAAK,GAAZ,GAAkB,QAAlB,GAA6B,OAA9C;AACA,gBAAM,MAAM,GAAG,KAAK,CAAC,gBAAN,CAAuB,QAAvB,EAAiC,MAAhD;;AAEA,cAAI,QAAQ,KAAK,MAAjB,EAAyB;AACvB,YAAA,OAAO,CAAC,IAAR,CAAa;AACX,cAAA,IAAI,EAAE,QADK;AAEX,cAAA,MAAM,EAAE;AAFG,aAAb;AAID;AACF;AACF;AACF;AACF;;AACD,SAAO,OAAP;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,cAAvB,EAA2D,MAA3D,EAAoF;AACxF,QAAM;AAAC,IAAA,CAAC,GAAG,EAAL;AAAS,IAAA,CAAC,GAAG;AAAb,MAAmB,cAAzB;AACA,SAAO,CACL,GAAG,CAAC,CAAC,GAAF,CAAM,CAAC,IAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAvB,CADE,EAEL,GAAG,CAAC,CAAC,GAAF,CAAM,CAAC,IAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAvB,CAFE,EAGL,GAAG,CAAC,CAAC,GAAF,CAAM,CAAC,IAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAvB,CAHE,EAIL,GAAG,CAAC,CAAC,GAAF,CAAM,CAAC,IAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAvB,CAJE,EAKL,MALK,CAKE,CAAC,IAAI,CALP,CAAP,CAFwF,CAOtE;AACnB","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n    if (!title) {\n        return undefined;\n    }\n    if (isArray(title) && !isText(title)) {\n        return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n    }\n    return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n    var _a, _b, _c;\n    var _d, _e;\n    (_a = axis.encode) !== null && _a !== void 0 ? _a : (axis.encode = {});\n    (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : (_d[part] = {});\n    (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : (_e.update = {});\n    // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n    axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {\n    var _a, _b;\n    const _c = axisCmpt.combine(), { disable, orient, scale, labelExpr, title, zindex } = _c, axis = __rest(_c, [\"disable\", \"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]);\n    if (disable) {\n        return undefined;\n    }\n    for (const prop in axis) {\n        const propType = AXIS_PROPERTY_TYPE[prop];\n        const propValue = axis[prop];\n        if (propType && propType !== kind && propType !== 'both') {\n            // Remove properties that are not valid for this kind of axis\n            delete axis[prop];\n        }\n        else if (isConditionalAxisValue(propValue)) {\n            // deal with conditional axis value\n            const { condition } = propValue, valueOrSignalRef = __rest(propValue, [\"condition\"]);\n            const conditions = array(condition);\n            const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n            if (propIndex) {\n                const { vgProp, part } = propIndex;\n                // If there is a corresponding Vega property for the channel,\n                // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n                const vgRef = [\n                    ...conditions.map(c => {\n                        const { test } = c, valueOrSignalCRef = __rest(c, [\"test\"]);\n                        return Object.assign({ test: expression(null, test) }, valueOrSignalCRef);\n                    }),\n                    valueOrSignalRef\n                ];\n                setAxisEncode(axis, part, vgProp, vgRef);\n                delete axis[prop];\n            }\n            else if (propIndex === null) {\n                // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n                const signalRef = {\n                    signal: conditions\n                        .map(c => {\n                        const { test } = c, valueOrSignalCRef = __rest(c, [\"test\"]);\n                        return `${expression(null, test)} ? ${exprFromValueOrSignalRef(valueOrSignalCRef)} : `;\n                    })\n                        .join('') + exprFromValueOrSignalRef(valueOrSignalRef)\n                };\n                axis[prop] = signalRef;\n            }\n        }\n        else if (isSignalRef(propValue)) {\n            const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n            if (propIndex) {\n                const { vgProp, part } = propIndex;\n                setAxisEncode(axis, part, vgProp, propValue);\n                delete axis[prop];\n            } // else do nothing since the property already supports signal\n        }\n        // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n        // Note that we need to use null so the default labelAlign is preserved.\n        if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n            delete axis[prop];\n        }\n    }\n    if (kind === 'grid') {\n        if (!axis.grid) {\n            return undefined;\n        }\n        // Remove unnecessary encode block\n        if (axis.encode) {\n            // Only need to keep encode block for grid\n            const { grid } = axis.encode;\n            axis.encode = Object.assign({}, (grid ? { grid } : {}));\n            if (isEmpty(axis.encode)) {\n                delete axis.encode;\n            }\n        }\n        return Object.assign(Object.assign({ scale,\n            orient }, axis), { domain: false, labels: false, aria: false, \n            // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n            // would not affect gridAxis\n            maxExtent: 0, minExtent: 0, ticks: false, zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n         });\n    }\n    else {\n        // kind === 'main'\n        if (!opt.header && axisCmpt.mainExtracted) {\n            // if mainExtracted has been extracted to a separate facet\n            return undefined;\n        }\n        if (labelExpr !== undefined) {\n            let expr = labelExpr;\n            if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n                expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n            }\n            setAxisEncode(axis, 'labels', 'text', { signal: expr });\n        }\n        if (axis.labelAlign === null) {\n            delete axis.labelAlign;\n        }\n        // Remove unnecessary encode block\n        if (axis.encode) {\n            for (const part of AXIS_PARTS) {\n                if (!axisCmpt.hasAxisPart(part)) {\n                    delete axis.encode[part];\n                }\n            }\n            if (isEmpty(axis.encode)) {\n                delete axis.encode;\n            }\n        }\n        const titleString = assembleTitle(title, config);\n        return Object.assign(Object.assign(Object.assign(Object.assign({ scale,\n            orient, grid: false }, (titleString ? { title: titleString } : {})), axis), (config.aria === false ? { aria: false } : {})), { zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n         });\n    }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model) {\n    const { axes } = model.component;\n    const signals = [];\n    for (const channel of POSITION_SCALE_CHANNELS) {\n        if (axes[channel]) {\n            for (const axis of axes[channel]) {\n                if (!axis.get('disable') && !axis.get('gridScale')) {\n                    // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n                    const sizeType = channel === 'x' ? 'height' : 'width';\n                    const update = model.getSizeSignalRef(sizeType).signal;\n                    if (sizeType !== update) {\n                        signals.push({\n                            name: sizeType,\n                            update: update\n                        });\n                    }\n                }\n            }\n        }\n    }\n    return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n    const { x = [], y = [] } = axisComponents;\n    return [\n        ...x.map(a => assembleAxis(a, 'grid', config)),\n        ...y.map(a => assembleAxis(a, 'grid', config)),\n        ...x.map(a => assembleAxis(a, 'main', config)),\n        ...y.map(a => assembleAxis(a, 'main', config))\n    ].filter(a => a); // filter undefined\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}