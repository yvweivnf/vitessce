{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Geometry } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { default as _MeshLayer } from '../mesh-layer/mesh-layer';\nimport { log } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nvar SINGLE_DATA = [0];\nvar defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  data: null,\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: function value(tileset3d) {},\n    compare: false\n  },\n  onTileLoad: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileUnload: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileError: {\n    type: 'function',\n    value: function value(tile, message, url) {},\n    compare: false\n  },\n  _getMeshColor: {\n    type: 'function',\n    value: function value(tileHeader) {\n      return [255, 255, 255];\n    },\n    compare: false\n  }\n};\n\nvar Tile3DLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(Tile3DLayer, _CompositeLayer);\n\n  var _super = _createSuper(Tile3DLayer);\n\n  function Tile3DLayer() {\n    _classCallCheck(this, Tile3DLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Tile3DLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      if ('onTileLoadFail' in this.props) {\n        log.removed('onTileLoadFail', 'onTileError')();\n      }\n\n      this.state = {\n        layerMap: {},\n        tileset3d: null,\n        activeViewports: {},\n        lastUpdatedViewports: null\n      };\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.data && props.data !== oldProps.data) {\n        this._loadTileset(props.data);\n      }\n\n      if (changeFlags.viewportChanged) {\n        var activeViewports = this.state.activeViewports;\n        var viewportsNumber = Object.keys(activeViewports).length;\n\n        if (viewportsNumber) {\n          this._updateTileset(activeViewports);\n\n          this.state.lastUpdatedViewports = activeViewports;\n          this.state.activeViewports = {};\n        }\n      }\n\n      if (changeFlags.propsChanged) {\n        var layerMap = this.state.layerMap;\n\n        for (var key in layerMap) {\n          layerMap[key].needsUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"activateViewport\",\n    value: function activateViewport(viewport) {\n      var _this$state = this.state,\n          activeViewports = _this$state.activeViewports,\n          lastUpdatedViewports = _this$state.lastUpdatedViewports;\n      this.internalState.viewport = viewport;\n      activeViewports[viewport.id] = viewport;\n      var lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];\n\n      if (!lastViewport || !viewport.equals(lastViewport)) {\n        this.setChangeFlags({\n          viewportChanged: true\n        });\n        this.setNeedsUpdate();\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n          sourceLayer = _ref3.sourceLayer;\n      var layerMap = this.state.layerMap;\n      var layerId = sourceLayer && sourceLayer.id;\n\n      if (layerId) {\n        var substr = layerId.substring(this.id.length + 1);\n        var tileId = substr.substring(substr.indexOf('-') + 1);\n        info.object = layerMap[tileId] && layerMap[tileId].tile;\n      }\n\n      return info;\n    }\n  }, {\n    key: \"filterSubLayer\",\n    value: function filterSubLayer(_ref4) {\n      var layer = _ref4.layer,\n          viewport = _ref4.viewport;\n      var tile = layer.props.tile;\n      var viewportId = viewport.id;\n      return tile.selected && tile.viewportIds.includes(viewportId);\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      if (info.sourceLayer) {\n        info.sourceLayer.updateAutoHighlight(info);\n      }\n    }\n  }, {\n    key: \"_loadTileset\",\n    value: function () {\n      var _loadTileset2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tilesetUrl) {\n        var _this$props$loadOptio, loadOptions, loader, options, preloadOptions, tilesetJson, tileset3d;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$props$loadOptio = this.props.loadOptions, loadOptions = _this$props$loadOptio === void 0 ? {} : _this$props$loadOptio;\n                loader = this.props.loader || this.props.loaders;\n\n                if (Array.isArray(loader)) {\n                  loader = loader[0];\n                }\n\n                options = {\n                  loadOptions: _objectSpread({}, loadOptions)\n                };\n\n                if (!loader.preload) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 7;\n                return loader.preload(tilesetUrl, loadOptions);\n\n              case 7:\n                preloadOptions = _context.sent;\n\n                if (preloadOptions.headers) {\n                  options.loadOptions.fetch = _objectSpread({}, options.loadOptions.fetch, {\n                    headers: preloadOptions.headers\n                  });\n                }\n\n                Object.assign(options, preloadOptions);\n\n              case 10:\n                _context.next = 12;\n                return load(tilesetUrl, loader, options.loadOptions);\n\n              case 12:\n                tilesetJson = _context.sent;\n                tileset3d = new Tileset3D(tilesetJson, _objectSpread({\n                  onTileLoad: this._onTileLoad.bind(this),\n                  onTileUnload: this._onTileUnload.bind(this),\n                  onTileLoadFail: this.props.onTileError\n                }, options));\n                this.setState({\n                  tileset3d: tileset3d,\n                  layerMap: {}\n                });\n\n                this._updateTileset(this.state.activeViewports);\n\n                this.props.onTilesetLoad(tileset3d);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _loadTileset(_x) {\n        return _loadTileset2.apply(this, arguments);\n      }\n\n      return _loadTileset;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tileHeader) {\n      var lastUpdatedViewports = this.state.lastUpdatedViewports;\n      this.props.onTileLoad(tileHeader);\n\n      this._updateTileset(lastUpdatedViewports);\n\n      this.setNeedsUpdate();\n    }\n  }, {\n    key: \"_onTileUnload\",\n    value: function _onTileUnload(tileHeader) {\n      delete this.state.layerMap[tileHeader.id];\n      this.props.onTileUnload(tileHeader);\n    }\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset(viewports) {\n      var tileset3d = this.state.tileset3d;\n      var timeline = this.context.timeline;\n      var viewportsNumber = Object.keys(viewports).length;\n\n      if (!timeline || !viewportsNumber || !tileset3d) {\n        return;\n      }\n\n      var frameNumber = tileset3d.update(Object.values(viewports));\n      var tilesetChanged = this.state.frameNumber !== frameNumber;\n\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber: frameNumber\n        });\n      }\n    }\n  }, {\n    key: \"_getSubLayer\",\n    value: function _getSubLayer(tileHeader, oldLayer) {\n      if (!tileHeader.content) {\n        return null;\n      }\n\n      switch (tileHeader.type) {\n        case TILE_TYPE.POINTCLOUD:\n          return this._makePointCloudLayer(tileHeader, oldLayer);\n\n        case TILE_TYPE.SCENEGRAPH:\n          return this._make3DModelLayer(tileHeader, oldLayer);\n\n        case TILE_TYPE.MESH:\n          return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n\n        default:\n          throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n      }\n    }\n  }, {\n    key: \"_makePointCloudLayer\",\n    value: function _makePointCloudLayer(tileHeader, oldLayer) {\n      var _tileHeader$content = tileHeader.content,\n          attributes = _tileHeader$content.attributes,\n          pointCount = _tileHeader$content.pointCount,\n          constantRGBA = _tileHeader$content.constantRGBA,\n          cartographicOrigin = _tileHeader$content.cartographicOrigin,\n          modelMatrix = _tileHeader$content.modelMatrix;\n      var positions = attributes.positions,\n          normals = attributes.normals,\n          colors = attributes.colors;\n\n      if (!positions) {\n        return null;\n      }\n\n      var data = oldLayer && oldLayer.props.data || {\n        header: {\n          vertexCount: pointCount\n        },\n        attributes: {\n          POSITION: positions,\n          NORMAL: normals,\n          COLOR_0: colors\n        }\n      };\n      var _this$props = this.props,\n          pointSize = _this$props.pointSize,\n          getPointColor = _this$props.getPointColor;\n      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n      return new SubLayerClass({\n        pointSize: pointSize\n      }, this.getSubLayerProps({\n        id: 'pointcloud'\n      }), {\n        id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n        tile: tileHeader,\n        data: data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"_make3DModelLayer\",\n    value: function _make3DModelLayer(tileHeader) {\n      var _tileHeader$content2 = tileHeader.content,\n          gltf = _tileHeader$content2.gltf,\n          instances = _tileHeader$content2.instances,\n          cartographicOrigin = _tileHeader$content2.cartographicOrigin,\n          modelMatrix = _tileHeader$content2.modelMatrix;\n      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n      return new SubLayerClass({\n        _lighting: 'pbr'\n      }, this.getSubLayerProps({\n        id: 'scenegraph'\n      }), {\n        id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getTransformMatrix: function getTransformMatrix(instance) {\n          return instance.modelMatrix;\n        },\n        getPosition: [0, 0, 0],\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"_makeSimpleMeshLayer\",\n    value: function _makeSimpleMeshLayer(tileHeader, oldLayer) {\n      var content = tileHeader.content;\n      var attributes = content.attributes,\n          indices = content.indices,\n          modelMatrix = content.modelMatrix,\n          cartographicOrigin = content.cartographicOrigin,\n          material = content.material,\n          featureIds = content.featureIds;\n      var _getMeshColor = this.props._getMeshColor;\n      var geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n        drawMode: 4,\n        attributes: getMeshGeometry(attributes),\n        indices: indices\n      });\n      var SubLayerClass = this.getSubLayerClass('mesh', _MeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix: modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        featureIds: featureIds,\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n\n      var _this$state2 = this.state,\n          tileset3d = _this$state2.tileset3d,\n          layerMap = _this$state2.layerMap;\n\n      if (!tileset3d) {\n        return null;\n      }\n\n      return tileset3d.tiles.map(function (tile) {\n        var layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n          tile: tile\n        };\n        var layer = layerCache.layer;\n\n        if (tile.selected) {\n          if (!layer) {\n            layer = _this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            layer = _this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n\n        layerCache.layer = layer;\n        return layer;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      var tileset3d = this.state.tileset3d;\n      return tileset3d && tileset3d.isLoaded();\n    }\n  }]);\n\n  return Tile3DLayer;\n}(CompositeLayer);\n\nexport { Tile3DLayer as default };\n\nfunction getMeshGeometry(contentAttributes) {\n  var attributes = {};\n  attributes.positions = _objectSpread({}, contentAttributes.positions, {\n    value: new Float32Array(contentAttributes.positions.value)\n  });\n\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/tile-3d-layer/tile-3d-layer.js"],"names":["default","SINGLE_DATA","defaultProps","getPointColor","type","value","pointSize","data","loader","onTilesetLoad","tileset3d","compare","onTileLoad","tileHeader","onTileUnload","onTileError","_getMeshColor","log","layerMap","activeViewports","lastUpdatedViewports","changeFlags","props","oldProps","viewportsNumber","Object","viewport","lastViewport","viewportChanged","sourceLayer","layerId","substr","tileId","info","tile","layer","id","viewportId","loadOptions","Array","options","preloadOptions","headers","tilesetJson","load","onTileLoadFail","timeline","frameNumber","tilesetChanged","TILE_TYPE","modelMatrix","colors","oldLayer","header","vertexCount","pointCount","attributes","POSITION","NORMAL","COLOR_0","SubLayerClass","coordinateSystem","COORDINATE_SYSTEM","coordinateOrigin","getColor","constantRGBA","_offset","_lighting","instances","scenegraph","getTransformMatrix","instance","getPosition","content","featureIds","geometry","drawMode","getMeshGeometry","indices","mesh","pbrMaterial","layerCache","contentAttributes","Tile3DLayer"],"mappings":";;;;;;;AACA,SAAA,QAAA,QAAA,eAAA;AACA,SAAA,iBAAA,EAAA,cAAA,QAAA,eAAA;AACA,SAAA,eAAA,QAAA,iBAAA;AACA,SAAA,eAAA,QAAA,sBAAA;AACA,SAAQA,OAAO,IAAf,UAAA,QAAA,0BAAA;AACA,SAAA,GAAA,QAAA,eAAA;AAEA,SAAA,IAAA,QAAA,kBAAA;AACA,SAAA,SAAA,EAAA,SAAA,QAAA,mBAAA;AACA,SAAA,aAAA,QAAA,sBAAA;AAEA,IAAMC,WAAW,GAAG,CAApB,CAAoB,CAApB;AAEA,IAAMC,YAAY,GAAG;AACnBC,EAAAA,aAAa,EAAE;AAACC,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA;AAA1B,GADI;AAEnBC,EAAAA,SAAS,EAFU,GAAA;AAInBC,EAAAA,IAAI,EAJe,IAAA;AAKnBC,EAAAA,MAAM,EALa,aAAA;AAOnBC,EAAAA,aAAa,EAAE;AAACL,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAEK,eAAAA,SAAS,EAAI,CAAvC,CAAA;AAA2CC,IAAAA,OAAO,EAAE;AAApD,GAPI;AAQnBC,EAAAA,UAAU,EAAE;AAACR,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAEQ,eAAAA,UAAU,EAAI,CAAxC,CAAA;AAA4CF,IAAAA,OAAO,EAAE;AAArD,GARO;AASnBG,EAAAA,YAAY,EAAE;AAACV,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAEQ,eAAAA,UAAU,EAAI,CAAxC,CAAA;AAA4CF,IAAAA,OAAO,EAAE;AAArD,GATK;AAUnBI,EAAAA,WAAW,EAAE;AAACX,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAE,eAAA,IAAA,EAAA,OAAA,EAAA,GAAA,EAAwB,CAAlD,CAAA;AAAsDM,IAAAA,OAAO,EAAE;AAA/D,GAVM;AAWnBK,EAAAA,aAAa,EAAE;AAACZ,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAEQ,eAAAA,UAAU;AAAA,aAAI,CAAA,GAAA,EAAA,GAAA,EAAxC,GAAwC,CAAJ;AAAA,KAApC;AAAyDF,IAAAA,OAAO,EAAE;AAAlE;AAXI,CAArB;;IAce,W;;;;;;;;;;;;;sCACK;AAChB,UAAI,oBAAoB,KAAxB,KAAA,EAAoC;AAClCM,QAAAA,GAAG,CAAHA,OAAAA,CAAAA,gBAAAA,EAAAA,aAAAA;AACD;;AAED,WAAA,KAAA,GAAa;AACXC,QAAAA,QAAQ,EADG,EAAA;AAEXR,QAAAA,SAAS,EAFE,IAAA;AAGXS,QAAAA,eAAe,EAHJ,EAAA;AAIXC,QAAAA,oBAAoB,EAAE;AAJX,OAAb;AAMD;;;sCAOgB,I,EAAgB;AAAA,UAAdC,WAAc,GAAA,IAAA,CAAdA,WAAc;AAC/B,aAAOA,WAAW,CAAlB,gBAAA;AACD;;;gCAEU,K,EAAiC;AAAA,UAAhC,KAAgC,GAAA,KAAA,CAAhC,KAAgC;AAAA,UAAhC,QAAgC,GAAA,KAAA,CAAhC,QAAgC;AAAA,UAAdA,WAAc,GAAA,KAAA,CAAdA,WAAc;;AAC1C,UAAIC,KAAK,CAALA,IAAAA,IAAcA,KAAK,CAALA,IAAAA,KAAeC,QAAQ,CAAzC,IAAA,EAAgD;AAC9C,aAAA,YAAA,CAAkBD,KAAK,CAAvB,IAAA;AACD;;AAED,UAAID,WAAW,CAAf,eAAA,EAAiC;AAAA,YACxBF,eADwB,GACL,KAA1B,KAD+B,CACxBA,eADwB;AAE/B,YAAMK,eAAe,GAAGC,MAAM,CAANA,IAAAA,CAAAA,eAAAA,EAAxB,MAAA;;AACA,YAAA,eAAA,EAAqB;AACnB,eAAA,cAAA,CAAA,eAAA;;AACA,eAAA,KAAA,CAAA,oBAAA,GAAA,eAAA;AACA,eAAA,KAAA,CAAA,eAAA,GAAA,EAAA;AACD;AACF;;AACD,UAAIJ,WAAW,CAAf,YAAA,EAA8B;AAAA,YACrBH,QADqB,GACT,KAAnB,KAD4B,CACrBA,QADqB;;AAE5B,aAAK,IAAL,GAAA,IAAA,QAAA,EAA4B;AAC1BA,UAAAA,QAAQ,CAARA,GAAQ,CAARA,CAAAA,WAAAA,GAAAA,IAAAA;AACD;AACF;AACF;;;qCAEe,Q,EAAW;AAAA,wBACuB,KAAhD,KADyB;AAAA,UACnB,eADmB,eACnB,eADmB;AAAA,UACDE,oBADC,eACDA,oBADC;AAEzB,WAAA,aAAA,CAAA,QAAA,GAAA,QAAA;AAEAD,MAAAA,eAAe,CAACO,QAAQ,CAAxBP,EAAe,CAAfA,GAAAA,QAAAA;AACA,UAAMQ,YAAY,GAAGP,oBAAH,KAAA,IAAGA,IAAAA,oBAAH,KAAA,KAAA,CAAGA,GAAH,KAAA,CAAGA,GAAAA,oBAAoB,CAAGM,QAAQ,CAApD,EAAyC,CAAzC;;AACA,UAAI,CAAA,YAAA,IAAiB,CAACA,QAAQ,CAARA,MAAAA,CAAtB,YAAsBA,CAAtB,EAAqD;AACnD,aAAA,cAAA,CAAoB;AAACE,UAAAA,eAAe,EAAE;AAAlB,SAApB;AACA,aAAA,cAAA;AACD;AACF;;;mCAEa,K,EAAsB;AAAA,UAArB,IAAqB,GAAA,KAAA,CAArB,IAAqB;AAAA,UAAdC,WAAc,GAAA,KAAA,CAAdA,WAAc;AAAA,UAC3BX,QAD2B,GACf,KAAnB,KADkC,CAC3BA,QAD2B;AAElC,UAAMY,OAAO,GAAGD,WAAW,IAAIA,WAAW,CAA1C,EAAA;;AACA,UAAA,OAAA,EAAa;AAEX,YAAME,MAAM,GAAGD,OAAO,CAAPA,SAAAA,CAAkB,KAAA,EAAA,CAAA,MAAA,GAAjC,CAAeA,CAAf;AACA,YAAME,MAAM,GAAGD,MAAM,CAANA,SAAAA,CAAiBA,MAAM,CAANA,OAAAA,CAAAA,GAAAA,IAAhC,CAAeA,CAAf;AACAE,QAAAA,IAAI,CAAJA,MAAAA,GAAcf,QAAQ,CAARA,MAAQ,CAARA,IAAoBA,QAAQ,CAARA,MAAQ,CAARA,CAAlCe,IAAAA;AACD;;AAED,aAAA,IAAA;AACD;;;mCAEa,K,EAAoB;AAAA,UAAnB,KAAmB,GAAA,KAAA,CAAnB,KAAmB;AAAA,UAAXP,QAAW,GAAA,KAAA,CAAXA,QAAW;AAAA,UACzBQ,IADyB,GACjBC,KAAK,CAApB,KADgC,CACzBD,IADyB;AAAA,UAErBG,UAFqB,GAEhC,QAFgC,CAEzBD,EAFyB;AAGhC,aAAOF,IAAI,CAAJA,QAAAA,IAAiBA,IAAI,CAAJA,WAAAA,CAAAA,QAAAA,CAAxB,UAAwBA,CAAxB;AACD;;;yCAEmB,I,EAAO;AACzB,UAAID,IAAI,CAAR,WAAA,EAAsB;AACpBA,QAAAA,IAAI,CAAJA,WAAAA,CAAAA,mBAAAA,CAAAA,IAAAA;AACD;AACF;;;;oGAEiB,U;;;;;;;wCACW,KAA3B,K,CAAOK,W,EAAAA,W,sCAAc,E;AAGjB9B,gBAAAA,M,GAAS,KAAA,KAAA,CAAA,MAAA,IAAqB,KAAA,KAAA,CAAlC,O;;AACA,oBAAI+B,KAAK,CAALA,OAAAA,CAAJ,MAAIA,CAAJ,EAA2B;AACzB/B,kBAAAA,MAAM,GAAGA,MAAM,CAAfA,CAAe,CAAfA;AACD;;AAEKgC,gBAAAA,O,GAAU;AAACF,kBAAAA,WAAW,oBAAMA,WAAN;AAAZ,iB;;qBACZ9B,MAAM,CAAV,O;;;;;;uBAC+BA,MAAM,CAANA,OAAAA,CAAAA,UAAAA,EAA7B,WAA6BA,C;;;AAAvBiC,gBAAAA,c;;AAEN,oBAAIA,cAAc,CAAlB,OAAA,EAA4B;AAC1BD,kBAAAA,OAAO,CAAPA,WAAAA,CAAAA,KAAAA,qBACKA,OAAO,CAAPA,WAAAA,CADuB,KAA5BA;AAEEE,oBAAAA,OAAO,EAAED,cAAc,CAACC;AAF1BF;AAID;;AACDf,gBAAAA,MAAM,CAANA,MAAAA,CAAAA,OAAAA,EAAAA,cAAAA;;;;uBAEwBmB,IAAI,CAAA,UAAA,EAAA,MAAA,EAAqBJ,OAAO,CAA1D,WAA8B,C;;;AAAxBG,gBAAAA,W;AAEAjC,gBAAAA,S,GAAY,IAAA,SAAA,CAAA,WAAA;AAChBE,kBAAAA,UAAU,EAAE,KAAA,WAAA,CAAA,IAAA,CAD+B,IAC/B,CADI;AAEhBE,kBAAAA,YAAY,EAAE,KAAA,aAAA,CAAA,IAAA,CAF6B,IAE7B,CAFE;AAGhB+B,kBAAAA,cAAc,EAAE,KAAA,KAAA,CAH2B;AAA3B,mBAIbL,OAJa,E;AAOlB,qBAAA,QAAA,CAAc;AACZ9B,kBAAAA,SADY,EACZA,SADY;AAEZQ,kBAAAA,QAAQ,EAAE;AAFE,iBAAd;;AAKA,qBAAA,cAAA,CAAoB,KAAA,KAAA,CAApB,eAAA;;AACA,qBAAA,KAAA,CAAA,aAAA,CAAA,SAAA;;;;;;;;;;;;;;;;;;gCAGS,U,EAAa;AAAA,UACfE,oBADe,GACS,KAA/B,KADsB,CACfA,oBADe;AAEtB,WAAA,KAAA,CAAA,UAAA,CAAA,UAAA;;AACA,WAAA,cAAA,CAAA,oBAAA;;AACA,WAAA,cAAA;AACD;;;kCAEY,U,EAAa;AAExB,aAAO,KAAA,KAAA,CAAA,QAAA,CAAoBP,UAAU,CAArC,EAAO,CAAP;AACA,WAAA,KAAA,CAAA,YAAA,CAAA,UAAA;AACD;;;mCAEa,S,EAAY;AAAA,UACjBH,SADiB,GACJ,KAApB,KADwB,CACjBA,SADiB;AAAA,UAEjBoC,QAFiB,GAEL,KAAnB,OAFwB,CAEjBA,QAFiB;AAGxB,UAAMtB,eAAe,GAAGC,MAAM,CAANA,IAAAA,CAAAA,SAAAA,EAAxB,MAAA;;AACA,UAAI,CAAA,QAAA,IAAa,CAAb,eAAA,IAAiC,CAArC,SAAA,EAAiD;AAC/C;AACD;;AACD,UAAMsB,WAAW,GAAGrC,SAAS,CAATA,MAAAA,CAAiBe,MAAM,CAANA,MAAAA,CAArC,SAAqCA,CAAjBf,CAApB;AACA,UAAMsC,cAAc,GAAG,KAAA,KAAA,CAAA,WAAA,KAAvB,WAAA;;AACA,UAAA,cAAA,EAAoB;AAClB,aAAA,QAAA,CAAc;AAACD,UAAAA,WAAAA,EAAAA;AAAD,SAAd;AACD;AACF;;;iCAEW,U,EAAA,Q,EAAuB;AACjC,UAAI,CAAClC,UAAU,CAAf,OAAA,EAAyB;AACvB,eAAA,IAAA;AACD;;AAED,cAAQA,UAAU,CAAlB,IAAA;AACE,aAAKoC,SAAS,CAAd,UAAA;AACE,iBAAO,KAAA,oBAAA,CAAA,UAAA,EAAP,QAAO,CAAP;;AACF,aAAKA,SAAS,CAAd,UAAA;AACE,iBAAO,KAAA,iBAAA,CAAA,UAAA,EAAP,QAAO,CAAP;;AACF,aAAKA,SAAS,CAAd,IAAA;AACE,iBAAO,KAAA,oBAAA,CAAA,UAAA,EAAP,QAAO,CAAP;;AACF;AACE,gBAAM,IAAA,KAAA,CAAA,+CAAA,MAAA,CAAyDpC,UAAU,CAAVA,OAAAA,CAA/D,IAAM,CAAA,CAAN;AARJ;AAUD;;;yCAEmB,U,EAAA,Q,EAAuB;AAAA,gCAOrCA,UAAU,CANd,OADyC;AAAA,UACnC,UADmC,uBACnC,UADmC;AAAA,UACnC,UADmC,uBACnC,UADmC;AAAA,UACnC,YADmC,uBACnC,YADmC;AAAA,UACnC,kBADmC,uBACnC,kBADmC;AAAA,UAMvCqC,WANuC,uBAMvCA,WANuC;AAAA,UAQnC,SARmC,GAQzC,UARyC,CAQnC,SARmC;AAAA,UAQnC,OARmC,GAQzC,UARyC,CAQnC,OARmC;AAAA,UAQdC,MARc,GAQzC,UARyC,CAQdA,MARc;;AAUzC,UAAI,CAAJ,SAAA,EAAgB;AACd,eAAA,IAAA;AACD;;AACD,UAAM5C,IAAI,GAAI6C,QAAQ,IAAIA,QAAQ,CAARA,KAAAA,CAAb,IAACA,IAAoC;AAChDC,QAAAA,MAAM,EAAE;AACNC,UAAAA,WAAW,EAAEC;AADP,SADwC;AAIhDC,QAAAA,UAAU,EAAE;AACVC,UAAAA,QAAQ,EADE,SAAA;AAEVC,UAAAA,MAAM,EAFI,OAAA;AAGVC,UAAAA,OAAO,EAAER;AAHC;AAJoC,OAAlD;AAbyC,wBAwBN,KAAnC,KAxByC;AAAA,UAwBnC,SAxBmC,eAwBnC,SAxBmC;AAAA,UAwBvBhD,aAxBuB,eAwBvBA,aAxBuB;AAyBzC,UAAMyD,aAAa,GAAG,KAAA,gBAAA,CAAA,YAAA,EAAtB,eAAsB,CAAtB;AACA,aAAO,IAAA,aAAA,CACL;AACEtD,QAAAA,SAAAA,EAAAA;AADF,OADK,EAIL,KAAA,gBAAA,CAAsB;AACpB8B,QAAAA,EAAE,EAAE;AADgB,OAAtB,CAJK,EAOL;AACEA,QAAAA,EAAE,EAAA,GAAA,MAAA,CAAK,KAAL,EAAA,EAAA,cAAA,EAAA,MAAA,CAA2BvB,UAAU,CADzC,EACI,CADJ;AAEEqB,QAAAA,IAAI,EAFN,UAAA;AAGE3B,QAAAA,IAHF,EAGEA,IAHF;AAIEsD,QAAAA,gBAAgB,EAAEC,iBAAiB,CAJrC,aAAA;AAKEC,QAAAA,gBAAgB,EALlB,kBAAA;AAMEb,QAAAA,WANF,EAMEA,WANF;AAOEc,QAAAA,QAAQ,EAAEC,YAAY,IAPxB,aAAA;AAQEC,QAAAA,OAAO,EAAE;AARX,OAPK,CAAP;AAkBD;;;sCAEgB,U,EAAa;AAAA,iCAC+BrD,UAAU,CAArE,OAD4B;AAAA,UACtB,IADsB,wBACtB,IADsB;AAAA,UACtB,SADsB,wBACtB,SADsB;AAAA,UACtB,kBADsB,wBACtB,kBADsB;AAAA,UACgBqC,WADhB,wBACgBA,WADhB;AAG5B,UAAMU,aAAa,GAAG,KAAA,gBAAA,CAAA,YAAA,EAAtB,eAAsB,CAAtB;AAEA,aAAO,IAAA,aAAA,CACL;AACEO,QAAAA,SAAS,EAAE;AADb,OADK,EAIL,KAAA,gBAAA,CAAsB;AACpB/B,QAAAA,EAAE,EAAE;AADgB,OAAtB,CAJK,EAOL;AACEA,QAAAA,EAAE,EAAA,GAAA,MAAA,CAAK,KAAL,EAAA,EAAA,cAAA,EAAA,MAAA,CAA2BvB,UAAU,CADzC,EACI,CADJ;AAEEqB,QAAAA,IAAI,EAFN,UAAA;AAGE3B,QAAAA,IAAI,EAAE6D,SAAS,IAHjB,WAAA;AAIEC,QAAAA,UAAU,EAJZ,IAAA;AAMER,QAAAA,gBAAgB,EAAEC,iBAAiB,CANrC,aAAA;AAOEC,QAAAA,gBAAgB,EAPlB,kBAAA;AAQEb,QAAAA,WARF,EAQEA,WARF;AASEoB,QAAAA,kBAAkB,EAAEC,4BAAAA,QAAQ;AAAA,iBAAIA,QAAQ,CAT1C,WAS8B;AAAA,SAT9B;AAUEC,QAAAA,WAAW,EAAE,CAAA,CAAA,EAAA,CAAA,EAVf,CAUe,CAVf;AAWEN,QAAAA,OAAO,EAAE;AAXX,OAPK,CAAP;AAqBD;;;yCAEmB,U,EAAA,Q,EAAuB;AACzC,UAAMO,OAAO,GAAG5D,UAAU,CAA1B,OAAA;AADyC,UAEnC,UAFmC,GAEzC,OAFyC,CAEnC,UAFmC;AAAA,UAEnC,OAFmC,GAEzC,OAFyC,CAEnC,OAFmC;AAAA,UAEnC,WAFmC,GAEzC,OAFyC,CAEnC,WAFmC;AAAA,UAEnC,kBAFmC,GAEzC,OAFyC,CAEnC,kBAFmC;AAAA,UAEnC,QAFmC,GAEzC,OAFyC,CAEnC,QAFmC;AAAA,UAE8B6D,UAF9B,GAEzC,OAFyC,CAE8BA,UAF9B;AAAA,UAGlC1D,aAHkC,GAGjB,KAAxB,KAHyC,CAGlCA,aAHkC;AAKzC,UAAM2D,QAAQ,GACXvB,QAAQ,IAAIA,QAAQ,CAARA,KAAAA,CAAb,IAACA,IACD,IAAA,QAAA,CAAa;AACXwB,QAAAA,QAAQ,EADG,CAAA;AAEXpB,QAAAA,UAAU,EAAEqB,eAAe,CAFhB,UAEgB,CAFhB;AAGXC,QAAAA,OAAAA,EAAAA;AAHW,OAAb,CAFF;AAQA,UAAMlB,aAAa,GAAG,KAAA,gBAAA,CAAA,MAAA,EAAtB,UAAsB,CAAtB;AAEA,aAAO,IAAA,aAAA,CACL,KAAA,gBAAA,CAAsB;AACpBxB,QAAAA,EAAE,EAAE;AADgB,OAAtB,CADK,EAIL;AACEA,QAAAA,EAAE,EAAA,GAAA,MAAA,CAAK,KAAL,EAAA,EAAA,QAAA,EAAA,MAAA,CAAqBvB,UAAU,CADnC,EACI,CADJ;AAEEqB,QAAAA,IAAI,EAFN,UAAA;AAGE6C,QAAAA,IAAI,EAHN,QAAA;AAIExE,QAAAA,IAAI,EAJN,WAAA;AAKEyD,QAAAA,QAAQ,EAAEhD,aAAa,CALzB,UAKyB,CALzB;AAMEgE,QAAAA,WAAW,EANb,QAAA;AAOE9B,QAAAA,WAPF,EAOEA,WAPF;AAQEa,QAAAA,gBAAgB,EARlB,kBAAA;AASEF,QAAAA,gBAAgB,EAAEC,iBAAiB,CATrC,aAAA;AAUEY,QAAAA,UAVF,EAUEA,UAVF;AAWER,QAAAA,OAAO,EAAE;AAXX,OAJK,CAAP;AAkBD;;;mCAEc;AAAA;;AAAA,yBACiB,KAA9B,KADa;AAAA,UACP,SADO,gBACP,SADO;AAAA,UACKhD,QADL,gBACKA,QADL;;AAEb,UAAI,CAAJ,SAAA,EAAgB;AACd,eAAA,IAAA;AACD;;AAED,aAAO,SAAS,CAAT,KAAA,CAAA,GAAA,CACAgB,UAAAA,IAAI,EAAI;AACX,YAAM+C,UAAU,GAAI/D,QAAQ,CAACgB,IAAI,CAAbhB,EAAQ,CAARA,GAAoBA,QAAQ,CAACgB,IAAI,CAAbhB,EAAQ,CAARA,IAAqB;AAACgB,UAAAA,IAAAA,EAAAA;AAAD,SAA7D;AADW,YAENC,KAFM,GAEX,UAFW,CAENA,KAFM;;AAGX,YAAID,IAAI,CAAR,QAAA,EAAmB;AAEjB,cAAI,CAAJ,KAAA,EAAY;AAEVC,YAAAA,KAAK,GAAG,KAAA,CAAA,YAAA,CAARA,IAAQ,CAARA;AAFF,WAAA,MAGO,IAAI8C,UAAU,CAAd,WAAA,EAA4B;AAEjC9C,YAAAA,KAAK,GAAG,KAAA,CAAA,YAAA,CAAA,IAAA,EAARA,KAAQ,CAARA;AACA8C,YAAAA,UAAU,CAAVA,WAAAA,GAAAA,KAAAA;AACD;AACF;;AACDA,QAAAA,UAAU,CAAVA,KAAAA,GAAAA,KAAAA;AACA,eAAA,KAAA;AAhBG,OAAA,EAAA,MAAA,CAAP,OAAO,CAAP;AAmBD;;;wBA7Rc;AAAA,UACNvE,SADM,GACO,KAApB,KADa,CACNA,SADM;AAEb,aAAOA,SAAS,IAAIA,SAAS,CAA7B,QAAoBA,EAApB;AACD;;;;EAjBY,c;;SAAA,W;;AA8Sf,SAAA,eAAA,CAAA,iBAAA,EAA4C;AAC1C,MAAM8C,UAAU,GAAhB,EAAA;AACAA,EAAAA,UAAU,CAAVA,SAAAA,qBACK0B,iBAAiB,CADC,SAAvB1B;AAEEnD,IAAAA,KAAK,EAAE,IAAA,YAAA,CAAiB6E,iBAAiB,CAAjBA,SAAAA,CAAjB,KAAA;AAFT1B;;AAIA,MAAI0B,iBAAiB,CAArB,OAAA,EAA+B;AAC7B1B,IAAAA,UAAU,CAAVA,OAAAA,GAAqB0B,iBAAiB,CAAtC1B,OAAAA;AACD;;AACD,MAAI0B,iBAAiB,CAArB,SAAA,EAAiC;AAC/B1B,IAAAA,UAAU,CAAVA,SAAAA,GAAuB0B,iBAAiB,CAAxC1B,SAAAA;AACD;;AACD,MAAI0B,iBAAiB,CAArB,MAAA,EAA8B;AAC5B1B,IAAAA,UAAU,CAAVA,MAAAA,GAAoB0B,iBAAiB,CAArC1B,MAAAA;AACD;;AACD,MAAI0B,iBAAiB,CAArB,SAAA,EAAiC;AAC/B1B,IAAAA,UAAU,CAAVA,SAAAA,GAAuB0B,iBAAiB,CAAxC1B,SAAAA;AACD;;AACD,SAAA,UAAA;AACD;;AAED2B,WAAW,CAAXA,SAAAA,GAAAA,aAAAA;AACAA,WAAW,CAAXA,YAAAA,GAAAA,YAAAA","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\nimport {COORDINATE_SYSTEM, CompositeLayer} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer} from '@deck.gl/mesh-layers';\nimport {default as _MeshLayer} from '../mesh-layer/mesh-layer';\nimport {log} from '@deck.gl/core';\n\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst SINGLE_DATA = [0];\n\nconst defaultProps = {\n  getPointColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  pointSize: 1.0,\n\n  data: null,\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: {type: 'function', value: tileset3d => {}, compare: false},\n  onTileLoad: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileUnload: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileError: {type: 'function', value: (tile, message, url) => {}, compare: false},\n  _getMeshColor: {type: 'function', value: tileHeader => [255, 255, 255], compare: false}\n};\n\nexport default class Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded() {\n    const {tileset3d} = this.state;\n    return tileset3d && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {activeViewports} = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {layerMap} = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport) {\n    const {activeViewports, lastUpdatedViewports} = this.state;\n    this.internalState.viewport = viewport;\n\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({viewportChanged: true});\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    const {layerMap} = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n    if (layerId) {\n      // layerId: this.id-[scenegraph|pointcloud]-tileId\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  filterSubLayer({layer, viewport}) {\n    const {tile} = layer.props;\n    const {id: viewportId} = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  _updateAutoHighlight(info) {\n    if (info.sourceLayer) {\n      info.sourceLayer.updateAutoHighlight(info);\n    }\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {loadOptions = {}} = this.props;\n\n    // TODO: deprecate `loader` in v9.0\n    let loader = this.props.loader || this.props.loaders;\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {loadOptions: {...loadOptions}};\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileLoadFail: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    const {lastUpdatedViewports} = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(viewports) {\n    const {tileset3d} = this.state;\n    const {timeline} = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n    const frameNumber = tileset3d.update(Object.values(viewports));\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (tilesetChanged) {\n      this.setState({frameNumber});\n    }\n  }\n\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader, oldLayer);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n    const data = (oldLayer && oldLayer.props.data) || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        tile: tileHeader,\n        data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      }\n    );\n  }\n\n  _make3DModelLayer(tileHeader) {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: [0, 0, 0],\n        _offset: 0\n      }\n    );\n  }\n\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {attributes, indices, modelMatrix, cartographicOrigin, material, featureIds} = content;\n    const {_getMeshColor} = this.props;\n\n    const geometry =\n      (oldLayer && oldLayer.props.mesh) ||\n      new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: getMeshGeometry(attributes),\n        indices\n      });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', _MeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        featureIds,\n        _offset: 0\n      }\n    );\n  }\n\n  renderLayers() {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles\n      .map(tile => {\n        const layerCache = (layerMap[tile.id] = layerMap[tile.id] || {tile});\n        let {layer} = layerCache;\n        if (tile.selected) {\n          // render selected tiles\n          if (!layer) {\n            // create layer\n            layer = this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            // props have changed, rerender layer\n            layer = this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n        layerCache.layer = layer;\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}