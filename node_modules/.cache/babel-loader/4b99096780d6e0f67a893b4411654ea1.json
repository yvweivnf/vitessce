{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isMobile } from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\nvar WorkerPool = /*#__PURE__*/function () {\n  function WorkerPool(props) {\n    _classCallCheck(this, WorkerPool);\n\n    _defineProperty(this, \"name\", 'unnamed');\n\n    _defineProperty(this, \"source\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"maxConcurrency\", 1);\n\n    _defineProperty(this, \"maxMobileConcurrency\", 1);\n\n    _defineProperty(this, \"onDebug\", function () {});\n\n    _defineProperty(this, \"reuseWorkers\", true);\n\n    _defineProperty(this, \"props\", {});\n\n    _defineProperty(this, \"jobQueue\", []);\n\n    _defineProperty(this, \"idleQueue\", []);\n\n    _defineProperty(this, \"count\", 0);\n\n    _defineProperty(this, \"isDestroyed\", false);\n\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  _createClass(WorkerPool, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.idleQueue.forEach(function (worker) {\n        return worker.destroy();\n      });\n      this.isDestroyed = true;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this.props = _objectSpread({}, this.props, {}, props);\n\n      if (props.name !== undefined) {\n        this.name = props.name;\n      }\n\n      if (props.maxConcurrency !== undefined) {\n        this.maxConcurrency = props.maxConcurrency;\n      }\n\n      if (props.maxMobileConcurrency !== undefined) {\n        this.maxMobileConcurrency = props.maxMobileConcurrency;\n      }\n\n      if (props.reuseWorkers !== undefined) {\n        this.reuseWorkers = props.reuseWorkers;\n      }\n\n      if (props.onDebug !== undefined) {\n        this.onDebug = props.onDebug;\n      }\n    }\n  }, {\n    key: \"startJob\",\n    value: function () {\n      var _startJob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name) {\n        var _this = this;\n\n        var onMessage,\n            onError,\n            startPromise,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                onMessage = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (job, type, data) {\n                  return job.done(data);\n                };\n                onError = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (job, error) {\n                  return job.error(error);\n                };\n                startPromise = new Promise(function (onStart) {\n                  _this.jobQueue.push({\n                    name: name,\n                    onMessage: onMessage,\n                    onError: onError,\n                    onStart: onStart\n                  });\n\n                  return _this;\n                });\n\n                this._startQueuedJob();\n\n                _context.next = 6;\n                return startPromise;\n\n              case 6:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function startJob(_x) {\n        return _startJob.apply(this, arguments);\n      }\n\n      return startJob;\n    }()\n  }, {\n    key: \"_startQueuedJob\",\n    value: function () {\n      var _startQueuedJob2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var workerThread, queuedJob, job;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.jobQueue.length) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                workerThread = this._getAvailableWorker();\n\n                if (workerThread) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 5:\n                queuedJob = this.jobQueue.shift();\n\n                if (!queuedJob) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                this.onDebug({\n                  message: 'Starting job',\n                  name: queuedJob.name,\n                  workerThread: workerThread,\n                  backlog: this.jobQueue.length\n                });\n                job = new WorkerJob(queuedJob.name, workerThread);\n\n                workerThread.onMessage = function (data) {\n                  return queuedJob.onMessage(job, data.type, data.payload);\n                };\n\n                workerThread.onError = function (error) {\n                  return queuedJob.onError(job, error);\n                };\n\n                queuedJob.onStart(job);\n                _context2.prev = 12;\n                _context2.next = 15;\n                return job.result;\n\n              case 15:\n                _context2.prev = 15;\n                this.returnWorkerToQueue(workerThread);\n                return _context2.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[12,, 15, 18]]);\n      }));\n\n      function _startQueuedJob() {\n        return _startQueuedJob2.apply(this, arguments);\n      }\n\n      return _startQueuedJob;\n    }()\n  }, {\n    key: \"returnWorkerToQueue\",\n    value: function returnWorkerToQueue(worker) {\n      var shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n      if (shouldDestroyWorker) {\n        worker.destroy();\n        this.count--;\n      } else {\n        this.idleQueue.push(worker);\n      }\n\n      if (!this.isDestroyed) {\n        this._startQueuedJob();\n      }\n    }\n  }, {\n    key: \"_getAvailableWorker\",\n    value: function _getAvailableWorker() {\n      if (this.idleQueue.length > 0) {\n        return this.idleQueue.shift() || null;\n      }\n\n      if (this.count < this._getMaxConcurrency()) {\n        this.count++;\n        var name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n        return new WorkerThread({\n          name: name,\n          source: this.source,\n          url: this.url\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getMaxConcurrency\",\n    value: function _getMaxConcurrency() {\n      return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n    }\n  }]);\n\n  return WorkerPool;\n}();\n\nexport { WorkerPool as default };","map":{"version":3,"sources":["../../../../src/lib/worker-farm/worker-pool.ts"],"names":["constructor","props","worker","onMessage","job","onError","startPromise","onStart","name","workerThread","queuedJob","message","backlog","length","data","error","shouldDestroyWorker","count","source","url","isMobile"],"mappings":"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","sourcesContent":["import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}