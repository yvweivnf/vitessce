{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      ignoreRange = _ref.ignoreRange;\n\n  parseScaleCore(model);\n  parseScaleDomain(model);\n\n  var _iterator = _createForOfIteratorHelper(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var prop = _step.value;\n      parseScaleProperty(model, prop);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\n\nfunction parseUnitScaleCore(model) {\n  var encoding = model.encoding,\n      mark = model.mark,\n      markDef = model.markDef;\n  return SCALE_CHANNELS.reduce(function (scaleComponents, channel) {\n    var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n    // Don't generate scale for shape of geoshape\n\n    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    var specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n\n    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : specifiedScale = {};\n      var sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(\"\".concat(channel), true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n\n    return scaleComponents;\n  }, {});\n}\n\nvar scaleTypeTieBreaker = tieBreakByComparing(function (st1, st2) {\n  return scaleTypePrecedence(st1) - scaleTypePrecedence(st2);\n});\n\nfunction parseNonUnitScaleCore(model) {\n  var _a;\n\n  var _b;\n\n  var scaleComponents = model.component.scales = {};\n  var scaleTypeWithExplicitIndex = {};\n  var resolve = model.component.resolve; // Parse each child scale and determine if a particular channel can be merged.\n\n  var _iterator2 = _createForOfIteratorHelper(model.children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      parseScaleCore(child); // Instead of always merging right away -- check if it is compatible to merge first!\n\n      var _iterator4 = _createForOfIteratorHelper(keys(child.component.scales)),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var channel = _step4.value;\n          // if resolve is undefined, set default first\n          (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : _b[channel] = defaultScaleResolve(channel, model);\n\n          if (resolve.scale[channel] === 'shared') {\n            var explicitScaleType = scaleTypeWithExplicitIndex[channel];\n            var childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n            if (explicitScaleType) {\n              if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n                // merge scale component if type are compatible\n                scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n              } else {\n                // Otherwise, update conflicting channel to be independent\n                resolve.scale[channel] = 'independent'; // Remove from the index so they don't get merged\n\n                delete scaleTypeWithExplicitIndex[channel];\n              }\n            } else {\n              scaleTypeWithExplicitIndex[channel] = childScaleType;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    } // Merge each channel listed in the index\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(keys(scaleTypeWithExplicitIndex)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _channel = _step3.value;\n      // Create new merged scale component\n      var name = model.scaleName(_channel, true);\n      var typeWithExplicit = scaleTypeWithExplicitIndex[_channel];\n      scaleComponents[_channel] = new ScaleComponent(name, typeWithExplicit); // rename each child and mark them as merged\n\n      var _iterator5 = _createForOfIteratorHelper(model.children),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _child = _step5.value;\n          var childScale = _child.component.scales[_channel];\n\n          if (childScale) {\n            _child.renameScale(childScale.get('name'), name);\n\n            childScale.merged = true;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return scaleComponents;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model, { ignoreRange } = {}) {\n    parseScaleCore(model);\n    parseScaleDomain(model);\n    for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n        parseScaleProperty(model, prop);\n    }\n    if (!ignoreRange) {\n        // range depends on zero\n        parseScaleRange(model);\n    }\n}\nexport function parseScaleCore(model) {\n    if (isUnitModel(model)) {\n        model.component.scales = parseUnitScaleCore(model);\n    }\n    else {\n        model.component.scales = parseNonUnitScaleCore(model);\n    }\n}\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model) {\n    const { encoding, mark, markDef } = model;\n    return SCALE_CHANNELS.reduce((scaleComponents, channel) => {\n        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n        // Don't generate scale for shape of geoshape\n        if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n            return scaleComponents;\n        }\n        let specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n        if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n            specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : (specifiedScale = {});\n            const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef);\n            scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n                value: sType,\n                explicit: specifiedScale.type === sType\n            });\n        }\n        return scaleComponents;\n    }, {});\n}\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\nfunction parseNonUnitScaleCore(model) {\n    var _a;\n    var _b;\n    const scaleComponents = (model.component.scales = {});\n    const scaleTypeWithExplicitIndex = {};\n    const resolve = model.component.resolve;\n    // Parse each child scale and determine if a particular channel can be merged.\n    for (const child of model.children) {\n        parseScaleCore(child);\n        // Instead of always merging right away -- check if it is compatible to merge first!\n        for (const channel of keys(child.component.scales)) {\n            // if resolve is undefined, set default first\n            (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : (_b[channel] = defaultScaleResolve(channel, model));\n            if (resolve.scale[channel] === 'shared') {\n                const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n                const childScaleType = child.component.scales[channel].getWithExplicit('type');\n                if (explicitScaleType) {\n                    if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n                        // merge scale component if type are compatible\n                        scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n                    }\n                    else {\n                        // Otherwise, update conflicting channel to be independent\n                        resolve.scale[channel] = 'independent';\n                        // Remove from the index so they don't get merged\n                        delete scaleTypeWithExplicitIndex[channel];\n                    }\n                }\n                else {\n                    scaleTypeWithExplicitIndex[channel] = childScaleType;\n                }\n            }\n        }\n    }\n    // Merge each channel listed in the index\n    for (const channel of keys(scaleTypeWithExplicitIndex)) {\n        // Create new merged scale component\n        const name = model.scaleName(channel, true);\n        const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n        scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n        // rename each child and mark them as merged\n        for (const child of model.children) {\n            const childScale = child.component.scales[channel];\n            if (childScale) {\n                child.renameScale(childScale.get('name'), name);\n                childScale.merged = true;\n            }\n        }\n    }\n    return scaleComponents;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}