{"ast":null,"code":"import { fieldIntersection, hash, hasIntersection, isEmpty, keys, some } from '../../util';\nimport { requiresSelectionId } from '../selection';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { OutputNode } from './dataflow';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { ParseNode } from './formatparse';\nimport { IdentifierNode } from './identifier';\nimport { BottomUpOptimizer, isDataSourceNode, Optimizer, TopDownOptimizer } from './optimizer';\nimport { SourceNode } from './source';\nimport { TimeUnitNode } from './timeunit';\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\n\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  mergeNodes(parent, nodes) {\n    const mergedNode = nodes.shift();\n\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n\n  run(node) {\n    const hashes = node.children.map(x => x.hash());\n    const buckets = {};\n\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setModified();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n  }\n\n}\n/**\n * Optimizer that removes identifier nodes that are not needed for selections.\n */\n\nexport class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {\n  constructor(model) {\n    super();\n    this.requiresSelectionId = model && requiresSelectionId(model);\n  }\n\n  run(node) {\n    if (node instanceof IdentifierNode) {\n      // Only preserve IdentifierNodes if we have default discrete selections\n      // in our model tree, and if the nodes come after tuple producing nodes.\n      if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {\n        this.setModified();\n        node.remove();\n      }\n    }\n  }\n\n}\n/**\n * Removes duplicate time unit nodes (as determined by the name of the output field) that may be generated due to\n * selections projected over time units. Only keeps the first time unit in any branch.\n *\n * This optimizer is a custom top down optimizer that keep track of produced fields in a branch.\n */\n\nexport class RemoveDuplicateTimeUnits extends Optimizer {\n  optimize(node) {\n    this.run(node, new Set());\n    return this.modifiedFlag;\n  }\n\n  run(node, timeUnitFields) {\n    let producedFields = new Set();\n\n    if (node instanceof TimeUnitNode) {\n      producedFields = node.producedFields();\n\n      if (hasIntersection(producedFields, timeUnitFields)) {\n        this.setModified();\n        node.removeFormulas(timeUnitFields);\n\n        if (node.producedFields.length === 0) {\n          node.remove();\n        }\n      }\n    }\n\n    for (const child of node.children) {\n      this.run(child, new Set([...timeUnitFields, ...producedFields]));\n    }\n  }\n\n}\n/**\n * Remove output nodes that are not required.\n */\n\nexport class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {\n  constructor() {\n    super();\n  }\n\n  run(node) {\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setModified();\n      node.remove();\n    }\n  }\n\n}\n/**\n * Move parse nodes up to forks and merges them if possible.\n */\n\nexport class MoveParseUp extends BottomUpOptimizer {\n  run(node) {\n    if (isDataSourceNode(node)) {\n      return;\n    }\n\n    if (node.numChildren() > 1) {\n      // Don't move parse further up but continue with parent.\n      return;\n    }\n\n    for (const child of node.children) {\n      if (child instanceof ParseNode) {\n        if (node instanceof ParseNode) {\n          this.setModified();\n          node.merge(child);\n        } else {\n          // Don't swap with nodes that produce something that the parse node depends on (e.g. lookup).\n          if (fieldIntersection(node.producedFields(), child.dependentFields())) {\n            continue;\n          }\n\n          this.setModified();\n          child.swapWithParent();\n        }\n      }\n    }\n\n    return;\n  }\n\n}\n/**\n * Inserts an intermediate ParseNode containing all non-conflicting parse fields and removes the empty ParseNodes.\n *\n * We assume that dependent paths that do not have a parse node can be just merged.\n */\n\nexport class MergeParse extends BottomUpOptimizer {\n  run(node) {\n    const originalChildren = [...node.children];\n    const parseChildren = node.children.filter(child => child instanceof ParseNode);\n\n    if (node.numChildren() > 1 && parseChildren.length >= 1) {\n      const commonParse = {};\n      const conflictingParse = new Set();\n\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n\n        for (const k of keys(parse)) {\n          if (!(k in commonParse)) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            conflictingParse.add(k);\n          }\n        }\n      }\n\n      for (const field of conflictingParse) {\n        delete commonParse[field];\n      }\n\n      if (!isEmpty(commonParse)) {\n        this.setModified();\n        const mergedParseNode = new ParseNode(node, commonParse);\n\n        for (const childNode of originalChildren) {\n          if (childNode instanceof ParseNode) {\n            for (const key of keys(commonParse)) {\n              delete childNode.parse[key];\n            }\n          }\n\n          node.removeChild(childNode);\n          childNode.parent = mergedParseNode; // remove empty parse nodes\n\n          if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {\n            childNode.remove();\n          }\n        }\n      }\n    }\n  }\n\n}\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\n\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  run(node) {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {// no need to continue with parent because it is output node or will have children (there was a fork)\n    } else if (node instanceof SourceNode) {// ignore empty unused sources as they will be removed in optimizationDataflowHelper\n    } else {\n      this.setModified();\n      node.remove();\n    }\n  }\n\n}\n/**\n * Merge adjacent time unit nodes.\n */\n\nexport class MergeTimeUnits extends BottomUpOptimizer {\n  run(node) {\n    const timeUnitChildren = node.children.filter(x => x instanceof TimeUnitNode);\n    const combination = timeUnitChildren.pop();\n\n    for (const timeUnit of timeUnitChildren) {\n      this.setModified();\n      combination.merge(timeUnit);\n    }\n  }\n\n}\nexport class MergeAggregates extends BottomUpOptimizer {\n  run(node) {\n    const aggChildren = node.children.filter(child => child instanceof AggregateNode); // Object which we'll use to map the fields which an aggregate is grouped by to\n    // the set of aggregates with that grouping. This is useful as only aggregates\n    // with the same group by can be merged\n\n    const groupedAggregates = {}; // Build groupedAggregates\n\n    for (const agg of aggChildren) {\n      const groupBys = hash(agg.groupBy);\n\n      if (!(groupBys in groupedAggregates)) {\n        groupedAggregates[groupBys] = [];\n      }\n\n      groupedAggregates[groupBys].push(agg);\n    } // Merge aggregateNodes with same key in groupedAggregates\n\n\n    for (const group of keys(groupedAggregates)) {\n      const mergeableAggs = groupedAggregates[group];\n\n      if (mergeableAggs.length > 1) {\n        const mergedAggs = mergeableAggs.pop();\n\n        for (const agg of mergeableAggs) {\n          if (mergedAggs.merge(agg)) {\n            node.removeChild(agg);\n            agg.parent = mergedAggs;\n            agg.remove();\n            this.setModified();\n          }\n        }\n      }\n    }\n  }\n\n}\n/**\n * Merge bin nodes and move them up through forks. Stop at filters, parse, identifier as we want them to stay before the bin node.\n */\n\nexport class MergeBins extends BottomUpOptimizer {\n  constructor(model) {\n    super();\n    this.model = model;\n  }\n\n  run(node) {\n    const moveBinsUp = !(isDataSourceNode(node) || node instanceof FilterNode || node instanceof ParseNode || node instanceof IdentifierNode);\n    const promotableBins = [];\n    const remainingBins = [];\n\n    for (const child of node.children) {\n      if (child instanceof BinNode) {\n        if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {\n          promotableBins.push(child);\n        } else {\n          remainingBins.push(child);\n        }\n      }\n    }\n\n    if (promotableBins.length > 0) {\n      const promotedBin = promotableBins.pop();\n\n      for (const bin of promotableBins) {\n        promotedBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n\n      this.setModified();\n\n      if (node instanceof BinNode) {\n        node.merge(promotedBin, this.model.renameSignal.bind(this.model));\n      } else {\n        promotedBin.swapWithParent();\n      }\n    }\n\n    if (remainingBins.length > 1) {\n      const remainingBin = remainingBins.pop();\n\n      for (const bin of remainingBins) {\n        remainingBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n\n      this.setModified();\n    }\n  }\n\n}\n/**\n * This optimizer takes output nodes that are at a fork and moves them before the fork.\n *\n * The algorithm iterates over the children and tries to find the last output node in a chain of output nodes.\n * It then moves all output nodes before that main output node. All other children (and the children of the output nodes)\n * are inserted after the main output node.\n */\n\nexport class MergeOutputs extends BottomUpOptimizer {\n  run(node) {\n    const children = [...node.children];\n    const hasOutputChild = some(children, child => child instanceof OutputNode);\n\n    if (!hasOutputChild || node.numChildren() <= 1) {\n      return;\n    }\n\n    const otherChildren = []; // The output node we will connect all other nodes to.\n    // Output nodes will be added before the new node, other nodes after.\n\n    let mainOutput;\n\n    for (const child of children) {\n      if (child instanceof OutputNode) {\n        let lastOutput = child;\n\n        while (lastOutput.numChildren() === 1) {\n          const [theChild] = lastOutput.children;\n\n          if (theChild instanceof OutputNode) {\n            lastOutput = theChild;\n          } else {\n            break;\n          }\n        }\n\n        otherChildren.push(...lastOutput.children);\n\n        if (mainOutput) {\n          // Move the output nodes before the mainOutput. We do this by setting\n          // the parent of the first not to the parent of the main output and\n          // the main output's parent to the last output.\n          // note: the child is the first output\n          node.removeChild(child);\n          child.parent = mainOutput.parent;\n          mainOutput.parent.removeChild(mainOutput);\n          mainOutput.parent = lastOutput;\n          this.setModified();\n        } else {\n          mainOutput = lastOutput;\n        }\n      } else {\n        otherChildren.push(child);\n      }\n    }\n\n    if (otherChildren.length) {\n      this.setModified();\n\n      for (const child of otherChildren) {\n        child.parent.removeChild(child);\n        child.parent = mainOutput;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/optimizers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { fieldIntersection, hash, hasIntersection, isEmpty, keys, some } from '../../util';\nimport { requiresSelectionId } from '../selection';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { OutputNode } from './dataflow';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { ParseNode } from './formatparse';\nimport { IdentifierNode } from './identifier';\nimport { BottomUpOptimizer, isDataSourceNode, Optimizer, TopDownOptimizer } from './optimizer';\nimport { SourceNode } from './source';\nimport { TimeUnitNode } from './timeunit';\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n    mergeNodes(parent, nodes) {\n        const mergedNode = nodes.shift();\n        for (const node of nodes) {\n            parent.removeChild(node);\n            node.parent = mergedNode;\n            node.remove();\n        }\n    }\n    run(node) {\n        const hashes = node.children.map(x => x.hash());\n        const buckets = {};\n        for (let i = 0; i < hashes.length; i++) {\n            if (buckets[hashes[i]] === undefined) {\n                buckets[hashes[i]] = [node.children[i]];\n            }\n            else {\n                buckets[hashes[i]].push(node.children[i]);\n            }\n        }\n        for (const k of keys(buckets)) {\n            if (buckets[k].length > 1) {\n                this.setModified();\n                this.mergeNodes(node, buckets[k]);\n            }\n        }\n    }\n}\n/**\n * Optimizer that removes identifier nodes that are not needed for selections.\n */\nexport class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {\n    constructor(model) {\n        super();\n        this.requiresSelectionId = model && requiresSelectionId(model);\n    }\n    run(node) {\n        if (node instanceof IdentifierNode) {\n            // Only preserve IdentifierNodes if we have default discrete selections\n            // in our model tree, and if the nodes come after tuple producing nodes.\n            if (!(this.requiresSelectionId &&\n                (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {\n                this.setModified();\n                node.remove();\n            }\n        }\n    }\n}\n/**\n * Removes duplicate time unit nodes (as determined by the name of the output field) that may be generated due to\n * selections projected over time units. Only keeps the first time unit in any branch.\n *\n * This optimizer is a custom top down optimizer that keep track of produced fields in a branch.\n */\nexport class RemoveDuplicateTimeUnits extends Optimizer {\n    optimize(node) {\n        this.run(node, new Set());\n        return this.modifiedFlag;\n    }\n    run(node, timeUnitFields) {\n        let producedFields = new Set();\n        if (node instanceof TimeUnitNode) {\n            producedFields = node.producedFields();\n            if (hasIntersection(producedFields, timeUnitFields)) {\n                this.setModified();\n                node.removeFormulas(timeUnitFields);\n                if (node.producedFields.length === 0) {\n                    node.remove();\n                }\n            }\n        }\n        for (const child of node.children) {\n            this.run(child, new Set([...timeUnitFields, ...producedFields]));\n        }\n    }\n}\n/**\n * Remove output nodes that are not required.\n */\nexport class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {\n    constructor() {\n        super();\n    }\n    run(node) {\n        if (node instanceof OutputNode && !node.isRequired()) {\n            this.setModified();\n            node.remove();\n        }\n    }\n}\n/**\n * Move parse nodes up to forks and merges them if possible.\n */\nexport class MoveParseUp extends BottomUpOptimizer {\n    run(node) {\n        if (isDataSourceNode(node)) {\n            return;\n        }\n        if (node.numChildren() > 1) {\n            // Don't move parse further up but continue with parent.\n            return;\n        }\n        for (const child of node.children) {\n            if (child instanceof ParseNode) {\n                if (node instanceof ParseNode) {\n                    this.setModified();\n                    node.merge(child);\n                }\n                else {\n                    // Don't swap with nodes that produce something that the parse node depends on (e.g. lookup).\n                    if (fieldIntersection(node.producedFields(), child.dependentFields())) {\n                        continue;\n                    }\n                    this.setModified();\n                    child.swapWithParent();\n                }\n            }\n        }\n        return;\n    }\n}\n/**\n * Inserts an intermediate ParseNode containing all non-conflicting parse fields and removes the empty ParseNodes.\n *\n * We assume that dependent paths that do not have a parse node can be just merged.\n */\nexport class MergeParse extends BottomUpOptimizer {\n    run(node) {\n        const originalChildren = [...node.children];\n        const parseChildren = node.children.filter((child) => child instanceof ParseNode);\n        if (node.numChildren() > 1 && parseChildren.length >= 1) {\n            const commonParse = {};\n            const conflictingParse = new Set();\n            for (const parseNode of parseChildren) {\n                const parse = parseNode.parse;\n                for (const k of keys(parse)) {\n                    if (!(k in commonParse)) {\n                        commonParse[k] = parse[k];\n                    }\n                    else if (commonParse[k] !== parse[k]) {\n                        conflictingParse.add(k);\n                    }\n                }\n            }\n            for (const field of conflictingParse) {\n                delete commonParse[field];\n            }\n            if (!isEmpty(commonParse)) {\n                this.setModified();\n                const mergedParseNode = new ParseNode(node, commonParse);\n                for (const childNode of originalChildren) {\n                    if (childNode instanceof ParseNode) {\n                        for (const key of keys(commonParse)) {\n                            delete childNode.parse[key];\n                        }\n                    }\n                    node.removeChild(childNode);\n                    childNode.parent = mergedParseNode;\n                    // remove empty parse nodes\n                    if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {\n                        childNode.remove();\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n    run(node) {\n        if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n            // no need to continue with parent because it is output node or will have children (there was a fork)\n        }\n        else if (node instanceof SourceNode) {\n            // ignore empty unused sources as they will be removed in optimizationDataflowHelper\n        }\n        else {\n            this.setModified();\n            node.remove();\n        }\n    }\n}\n/**\n * Merge adjacent time unit nodes.\n */\nexport class MergeTimeUnits extends BottomUpOptimizer {\n    run(node) {\n        const timeUnitChildren = node.children.filter((x) => x instanceof TimeUnitNode);\n        const combination = timeUnitChildren.pop();\n        for (const timeUnit of timeUnitChildren) {\n            this.setModified();\n            combination.merge(timeUnit);\n        }\n    }\n}\nexport class MergeAggregates extends BottomUpOptimizer {\n    run(node) {\n        const aggChildren = node.children.filter((child) => child instanceof AggregateNode);\n        // Object which we'll use to map the fields which an aggregate is grouped by to\n        // the set of aggregates with that grouping. This is useful as only aggregates\n        // with the same group by can be merged\n        const groupedAggregates = {};\n        // Build groupedAggregates\n        for (const agg of aggChildren) {\n            const groupBys = hash(agg.groupBy);\n            if (!(groupBys in groupedAggregates)) {\n                groupedAggregates[groupBys] = [];\n            }\n            groupedAggregates[groupBys].push(agg);\n        }\n        // Merge aggregateNodes with same key in groupedAggregates\n        for (const group of keys(groupedAggregates)) {\n            const mergeableAggs = groupedAggregates[group];\n            if (mergeableAggs.length > 1) {\n                const mergedAggs = mergeableAggs.pop();\n                for (const agg of mergeableAggs) {\n                    if (mergedAggs.merge(agg)) {\n                        node.removeChild(agg);\n                        agg.parent = mergedAggs;\n                        agg.remove();\n                        this.setModified();\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Merge bin nodes and move them up through forks. Stop at filters, parse, identifier as we want them to stay before the bin node.\n */\nexport class MergeBins extends BottomUpOptimizer {\n    constructor(model) {\n        super();\n        this.model = model;\n    }\n    run(node) {\n        const moveBinsUp = !(isDataSourceNode(node) ||\n            node instanceof FilterNode ||\n            node instanceof ParseNode ||\n            node instanceof IdentifierNode);\n        const promotableBins = [];\n        const remainingBins = [];\n        for (const child of node.children) {\n            if (child instanceof BinNode) {\n                if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {\n                    promotableBins.push(child);\n                }\n                else {\n                    remainingBins.push(child);\n                }\n            }\n        }\n        if (promotableBins.length > 0) {\n            const promotedBin = promotableBins.pop();\n            for (const bin of promotableBins) {\n                promotedBin.merge(bin, this.model.renameSignal.bind(this.model));\n            }\n            this.setModified();\n            if (node instanceof BinNode) {\n                node.merge(promotedBin, this.model.renameSignal.bind(this.model));\n            }\n            else {\n                promotedBin.swapWithParent();\n            }\n        }\n        if (remainingBins.length > 1) {\n            const remainingBin = remainingBins.pop();\n            for (const bin of remainingBins) {\n                remainingBin.merge(bin, this.model.renameSignal.bind(this.model));\n            }\n            this.setModified();\n        }\n    }\n}\n/**\n * This optimizer takes output nodes that are at a fork and moves them before the fork.\n *\n * The algorithm iterates over the children and tries to find the last output node in a chain of output nodes.\n * It then moves all output nodes before that main output node. All other children (and the children of the output nodes)\n * are inserted after the main output node.\n */\nexport class MergeOutputs extends BottomUpOptimizer {\n    run(node) {\n        const children = [...node.children];\n        const hasOutputChild = some(children, child => child instanceof OutputNode);\n        if (!hasOutputChild || node.numChildren() <= 1) {\n            return;\n        }\n        const otherChildren = [];\n        // The output node we will connect all other nodes to.\n        // Output nodes will be added before the new node, other nodes after.\n        let mainOutput;\n        for (const child of children) {\n            if (child instanceof OutputNode) {\n                let lastOutput = child;\n                while (lastOutput.numChildren() === 1) {\n                    const [theChild] = lastOutput.children;\n                    if (theChild instanceof OutputNode) {\n                        lastOutput = theChild;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                otherChildren.push(...lastOutput.children);\n                if (mainOutput) {\n                    // Move the output nodes before the mainOutput. We do this by setting\n                    // the parent of the first not to the parent of the main output and\n                    // the main output's parent to the last output.\n                    // note: the child is the first output\n                    node.removeChild(child);\n                    child.parent = mainOutput.parent;\n                    mainOutput.parent.removeChild(mainOutput);\n                    mainOutput.parent = lastOutput;\n                    this.setModified();\n                }\n                else {\n                    mainOutput = lastOutput;\n                }\n            }\n            else {\n                otherChildren.push(child);\n            }\n        }\n        if (otherChildren.length) {\n            this.setModified();\n            for (const child of otherChildren) {\n                child.parent.removeChild(child);\n                child.parent = mainOutput;\n            }\n        }\n    }\n}\n//# sourceMappingURL=optimizers.js.map"]},"metadata":{},"sourceType":"module"}