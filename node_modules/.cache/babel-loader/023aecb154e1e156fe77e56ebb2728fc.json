{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toDeckColor = toDeckColor;\nexports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;\nexports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;\nexports.distance2d = distance2d;\nexports.mix = mix;\nexports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;\n\nvar _destination = _interopRequireDefault(require(\"@turf/destination\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _pointToLineDistance = _interopRequireDefault(require(\"@turf/point-to-line-distance\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _viewportMercatorProject = _interopRequireDefault(require(\"viewport-mercator-project\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction toDeckColor(color) {\n  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];\n\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n} //\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\n\n\nfunction recursivelyTraverseNestedArrays(array, prefix, fn) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n\n  return false;\n}\n\nfunction generatePointsParallelToLinePoints(p1, p2, groundCoords) {\n  var lineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  var pt = (0, _helpers.point)(groundCoords);\n  var ddistance = (0, _pointToLineDistance[\"default\"])(pt, lineString);\n  var lineBearing = (0, _bearing[\"default\"])(p1, p2); // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n\n  var isPointToLeftOfLine = (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string\n\n  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n\n  var p3 = (0, _destination[\"default\"])(p2, ddistance, orthogonalBearing);\n  var p4 = (0, _destination[\"default\"])(p1, ddistance, orthogonalBearing); //@ts-ignore\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nfunction distance2d(x1, y1, x2, y2) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction mix(a, b, ratio) {\n  return b * ratio + a * (1 - ratio);\n}\n\nfunction nearestPointOnProjectedLine(line, inPoint, viewport) {\n  var wmViewport = new _viewportMercatorProject[\"default\"](viewport); // Project the line to viewport, then find the nearest point\n\n  var coordinates = line.geometry.coordinates;\n  var projectedCoords = coordinates.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        x = _ref2[0],\n        y = _ref2[1],\n        _ref2$ = _ref2[2],\n        z = _ref2$ === void 0 ? 0 : _ref2$;\n\n    return wmViewport.project([x, y, z]);\n  }); //@ts-ignore\n\n  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),\n      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),\n      x = _wmViewport$project2[0],\n      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n\n  var minDistance = Infinity;\n  var minPointInfo = {};\n  projectedCoords.forEach(function (_ref3, index) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        x2 = _ref4[0],\n        y2 = _ref4[1];\n\n    if (index === 0) {\n      return;\n    }\n\n    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),\n        x1 = _projectedCoords[0],\n        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n\n\n    var A = y1 - y2;\n    var B = x2 - x1;\n    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n\n    var div = A * A + B * B;\n    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index: index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div\n      };\n    }\n  }); //@ts-ignore\n\n  var _minPointInfo = minPointInfo,\n      index = _minPointInfo.index,\n      x0 = _minPointInfo.x0,\n      y0 = _minPointInfo.y0;\n\n  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),\n      x1 = _projectedCoords2[0],\n      y1 = _projectedCoords2[1],\n      _projectedCoords2$ = _projectedCoords2[2],\n      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;\n\n  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),\n      x2 = _projectedCoords$inde[0],\n      y2 = _projectedCoords$inde[1],\n      _projectedCoords$inde2 = _projectedCoords$inde[2],\n      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z\n\n\n  var lineLength = distance2d(x1, y1, x2, y2);\n  var startToPointLength = distance2d(x1, y1, x0, y0);\n  var ratio = startToPointLength / lineLength;\n  var z0 = mix(z1, z2, ratio);\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0])\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1\n    }\n  };\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":["defaultColor","Array","color","array","i","recursivelyTraverseNestedArrays","fn","lineString","type","coordinates","pt","ddistance","lineBearing","isPointToLeftOfLine","groundCoords","p1","p2","orthogonalBearing","p3","p4","dx","x1","dy","y1","Math","b","a","wmViewport","WebMercatorViewport","line","projectedCoords","x","y","z","inPoint","minDistance","minPointInfo","x2","y2","index","A","B","C","div","distance","x0","y0","z1","z2","lineLength","distance2d","startToPointLength","ratio","z0","mix","geometry","properties","dist"],"mappings":";;;;;;;;;;;;AAAA,IAAA,YAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,IAAA,oBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,8BAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AASA,IAAA,wBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,2BAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMO,SAAA,WAAA,CAAA,KAAA,EAG6B;AAAA,MADlCA,YACkC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADe,CAAA,GAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,CACf;;AAClC,MAAI,CAACC,KAAK,CAALA,OAAAA,CAAL,KAAKA,CAAL,EAA2B;AACzB,WAAA,YAAA;AACD;;AACD,SAAO,CAACC,KAAK,CAALA,CAAK,CAALA,GAAD,GAAA,EAAiBA,KAAK,CAALA,CAAK,CAALA,GAAjB,GAAA,EAAiCA,KAAK,CAALA,CAAK,CAALA,GAAjC,GAAA,EAAiDA,KAAK,CAALA,CAAK,CAALA,GAAxD,GAAO,CAAP;EAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAAA,+BAAA,CAAA,KAAA,EAAA,MAAA,EAAA,EAAA,EAIL;AACA,MAAI,CAACD,KAAK,CAALA,OAAAA,CAAcE,KAAK,CAAxB,CAAwB,CAAnBF,CAAL,EAA8B;AAC5B,WAAA,IAAA;AACD;;AACD,OAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,KAAK,CAAzB,MAAA,EAAkCC,CAAlC,EAAA,EAAuC;AACrC,QAAIC,+BAA+B,CAACF,KAAK,CAAN,CAAM,CAAN,EAAA,GAAA,MAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,EAAnC,EAAmC,CAAnC,EAAmE;AACjEG,MAAAA,EAAE,CAAA,KAAA,EAAFA,MAAE,CAAFA;AACA;AACD;AACF;;AACD,SAAA,KAAA;AACD;;AAEM,SAAA,kCAAA,CAAA,EAAA,EAAA,EAAA,EAAA,YAAA,EAIO;AACZ,MAAMC,UAAsB,GAAG;AAC7BC,IAAAA,IAAI,EADyB,YAAA;AAE7BC,IAAAA,WAAW,EAAE,CAAA,EAAA,EAAA,EAAA;AAFgB,GAA/B;AAIA,MAAMC,EAAE,GAAG,CAAA,GAAA,QAAA,CAAA,KAAA,EAAX,YAAW,CAAX;AACA,MAAMC,SAAS,GAAG,CAAA,GAAA,oBAAA,CAAA,SAAA,CAAA,EAAA,EAAA,EAAlB,UAAkB,CAAlB;AACA,MAAMC,WAAW,GAAG,CAAA,GAAA,QAAA,CAAA,SAAA,CAAA,EAAA,EAAA,EAPR,EAOQ,CAApB,CAPY,CASZ;AACA;AACA;;AACA,MAAMC,mBAAmB,GACvB,CAACC,YAAY,CAAZA,CAAY,CAAZA,GAAkBC,EAAE,CAArB,CAAqB,CAArB,KAA6BC,EAAE,CAAFA,CAAE,CAAFA,GAAQD,EAAE,CAAvC,CAAuC,CAAvC,IAA8C,CAACD,YAAY,CAAZA,CAAY,CAAZA,GAAkBC,EAAE,CAArB,CAAqB,CAArB,KAA6BC,EAAE,CAAFA,CAAE,CAAFA,GAAQD,EAAE,CAb3E,CAa2E,CAAvC,CADhD,CAZY,CAeZ;;AACA,MAAME,iBAAiB,GAAGJ,mBAAmB,GAAnBA,CAAAA,GAA0BD,WAAW,GAArCC,EAAAA,GAA6CD,WAAW,GAhBtE,GAgBZ,CAhBY,CAkBZ;AACA;;AACA,MAAMM,EAAE,GAAG,CAAA,GAAA,YAAA,CAAA,SAAA,CAAA,EAAA,EAAA,EAAA,SAAA,EAAX,iBAAW,CAAX;AACA,MAAMC,EAAE,GAAG,CAAA,GAAA,YAAA,CAAA,SAAA,CAAA,EAAA,EAAA,EAAA,SAAA,EArBC,iBAqBD,CAAX,CArBY,CAsBZ;;AACA,SAAO,CAACD,EAAE,CAAFA,QAAAA,CAAD,WAAA,EAA0BC,EAAE,CAAFA,QAAAA,CAAjC,WAAO,CAAP;AACD;;AAEM,SAAA,UAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAA4E;AACjF,MAAMC,EAAE,GAAGC,EAAE,GAAb,EAAA;AACA,MAAMC,EAAE,GAAGC,EAAE,GAAb,EAAA;AACA,SAAOC,IAAI,CAAJA,IAAAA,CAAUJ,EAAE,GAAFA,EAAAA,GAAUE,EAAE,GAA7B,EAAOE,CAAP;AACD;;AAEM,SAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EAA0D;AAC/D,SAAOC,CAAC,GAADA,KAAAA,GAAYC,CAAC,IAAI,IAAxB,KAAoB,CAApB;AACD;;AAEM,SAAA,2BAAA,CAAA,IAAA,EAAA,OAAA,EAAA,QAAA,EAIa;AAClB,MAAMC,UAAU,GAAG,IAAIC,wBAAAA,CAAJ,SAAIA,CAAJ,CADD,QACC,CAAnB,CADkB,CAElB;;AACA,MAAMnB,WAAiC,GAAGoB,IAAI,CAAJA,QAAAA,CAA1C,WAAA;AACA,MAAMC,eAAe,GAAG,WAAW,CAAX,GAAA,CAAgB,UAAA,IAAA,EAAA;AAAA,QAAA,KAAA,GAAA,cAAA,CAAA,IAAA,EAAA,CAAA,CAAA;AAAA,QAAEC,CAAF,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,QAAKC,CAAL,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,QAAA,MAAA,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,QAAQC,CAAR,GAAA,MAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,MAAA;;AAAA,WAAmBN,UAAU,CAAVA,OAAAA,CAAmB,CAAA,CAAA,EAAA,CAAA,EAAtC,CAAsC,CAAnBA,CAAnB;AAJtB,GAIM,CAAxB,CAJkB,CAKlB;;AALkB,MAAA,mBAAA,GAMHA,UAAU,CAAVA,OAAAA,CAAmBO,OAAO,CAAPA,QAAAA,CANhB,WAMHP,CANG;AAAA,MAAA,oBAAA,GAAA,cAAA,CAAA,mBAAA,EAAA,CAAA,CAAA;AAAA,MAMXI,CANW,GAAA,oBAAA,CAAA,CAAA,CAAA;AAAA,MAMRC,CANQ,GAAA,oBAAA,CAAA,CAAA,CAAA,CAAA,CAOlB;;;AAEA,MAAIG,WAAW,GAAf,QAAA;AACA,MAAIC,YAAY,GAAhB,EAAA;AAEAN,EAAAA,eAAe,CAAfA,OAAAA,CAAwB,UAAA,KAAA,EAAA,KAAA,EAAqB;AAAA,QAAA,KAAA,GAAA,cAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,QAAnBO,EAAmB,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,QAAfC,EAAe,GAAA,KAAA,CAAA,CAAA,CAAA;;AAC3C,QAAIC,KAAK,KAAT,CAAA,EAAiB;AACf;AACD;;AAH0C,QAAA,gBAAA,GAAA,cAAA,CAK1BT,eAAe,CAACS,KAAK,GALK,CAKX,CALW,EAAA,CAAA,CAAA;AAAA,QAKpClB,EALoC,GAAA,gBAAA,CAAA,CAAA,CAAA;AAAA,QAKhCE,EALgC,GAAA,gBAAA,CAAA,CAAA,CAAA,CAAA,CAO3C;AACA;;;AACA,QAAMiB,CAAC,GAAGjB,EAAE,GAAZ,EAAA;AACA,QAAMkB,CAAC,GAAGJ,EAAE,GAAZ,EAAA;AACA,QAAMK,CAAC,GAAGrB,EAAE,GAAFA,EAAAA,GAAUgB,EAAE,GAXqB,EAW3C,CAX2C,CAa3C;;AACA,QAAMM,GAAG,GAAGH,CAAC,GAADA,CAAAA,GAAQC,CAAC,GAArB,CAAA;AACA,QAAMG,QAAQ,GAAGpB,IAAI,CAAJA,GAAAA,CAASgB,CAAC,GAADA,CAAAA,GAAQC,CAAC,GAATD,CAAAA,GAAThB,CAAAA,IAA8BA,IAAI,CAAJA,IAAAA,CAfJ,GAeIA,CAA/C,CAf2C,CAiB3C;;AAEA,QAAIoB,QAAQ,GAAZ,WAAA,EAA4B;AAC1BT,MAAAA,WAAW,GAAXA,QAAAA;AACAC,MAAAA,YAAY,GAAG;AACbG,QAAAA,KAAK,EADQ,KAAA;AAEbM,QAAAA,EAAE,EAAE,CAACJ,CAAC,IAAIA,CAAC,GAADA,CAAAA,GAAQD,CAAC,GAAdC,CAAC,CAADA,GAAsBD,CAAC,GAAxB,CAAA,IAFS,GAAA;AAGbM,QAAAA,EAAE,EAAE,CAACN,CAAC,IAAI,CAAA,CAAA,GAAA,CAAA,GAASA,CAAC,GAAfA,CAAC,CAADA,GAAuBC,CAAC,GAAzB,CAAA,IAAiCE;AAHxB,OAAfP;AAKD;AAtCe,GAYlBN,EAZkB,CAwClB;;AAxCkB,MAAA,aAAA,GAAA,YAAA;AAAA,MAyCVS,KAzCU,GAAA,aAAA,CAAA,KAAA;AAAA,MAyCHM,EAzCG,GAAA,aAAA,CAAA,EAAA;AAAA,MAyCCC,EAzCD,GAAA,aAAA,CAAA,EAAA;;AAAA,MAAA,iBAAA,GAAA,cAAA,CA0COhB,eAAe,CAACS,KAAK,GA1C5B,CA0CsB,CA1CtB,EAAA,CAAA,CAAA;AAAA,MA0CXlB,EA1CW,GAAA,iBAAA,CAAA,CAAA,CAAA;AAAA,MA0CPE,EA1CO,GAAA,iBAAA,CAAA,CAAA,CAAA;AAAA,MAAA,kBAAA,GAAA,iBAAA,CAAA,CAAA,CAAA;AAAA,MA0CHwB,EA1CG,GAAA,kBAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,kBAAA;;AAAA,MAAA,qBAAA,GAAA,cAAA,CA2COjB,eAAe,CA3CtB,KA2CsB,CA3CtB,EAAA,CAAA,CAAA;AAAA,MA2CXO,EA3CW,GAAA,qBAAA,CAAA,CAAA,CAAA;AAAA,MA2CPC,EA3CO,GAAA,qBAAA,CAAA,CAAA,CAAA;AAAA,MAAA,sBAAA,GAAA,qBAAA,CAAA,CAAA,CAAA;AAAA,MA2CHU,EA3CG,GAAA,sBAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,sBAAA,CAAA,CA6ClB;;;AACA,MAAMC,UAAU,GAAGC,UAAU,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAA7B,EAA6B,CAA7B;AACA,MAAMC,kBAAkB,GAAGD,UAAU,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAArC,EAAqC,CAArC;AACA,MAAME,KAAK,GAAGD,kBAAkB,GAAhC,UAAA;AACA,MAAME,EAAE,GAAGC,GAAG,CAAA,EAAA,EAAA,EAAA,EAAd,KAAc,CAAd;AAEA,SAAO;AACL9C,IAAAA,IAAI,EADC,SAAA;AAEL+C,IAAAA,QAAQ,EAAE;AACR/C,MAAAA,IAAI,EADI,OAAA;AAERC,MAAAA,WAAW,EAAEkB,UAAU,CAAVA,SAAAA,CAAqB,CAAA,EAAA,EAAA,EAAA,EAArBA,EAAqB,CAArBA;AAFL,KAFL;AAML6B,IAAAA,UAAU,EAAE;AACV;AACAC,MAAAA,IAAI,EAFM,WAAA;AAGVlB,MAAAA,KAAK,EAAEA,KAAK,GAAG;AAHL;AANP,GAAP;AAYD","sourcesContent":["import destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { point } from '@turf/helpers';\nimport {\n  Position,\n  Point,\n  LineString,\n  FeatureOf,\n  FeatureWithProps,\n  Viewport,\n} from '@nebula.gl/edit-modes';\nimport WebMercatorViewport from 'viewport-mercator-project';\n\n// TODO edit-modes: delete and use edit-modes/utils instead\n\nexport type NearestPointType = FeatureWithProps<Point, { dist: number; index: number }>;\n\nexport function toDeckColor(\n  color?: [number, number, number, number] | number,\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  groundCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2],\n  };\n  const pt = point(groundCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n  //@ts-ignore\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nexport function distance2d(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function mix(a: number, b: number, ratio: number): number {\n  return b * ratio + a * (1 - ratio);\n}\n\nexport function nearestPointOnProjectedLine(\n  line: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport: Viewport\n): NearestPointType {\n  const wmViewport = new WebMercatorViewport(viewport);\n  // Project the line to viewport, then find the nearest point\n  const coordinates: Array<Array<number>> = line.geometry.coordinates as any;\n  const projectedCoords = coordinates.map(([x, y, z = 0]) => wmViewport.project([x, y, z]));\n  //@ts-ignore\n  const [x, y] = wmViewport.project(inPoint.geometry.coordinates);\n  // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n  let minDistance = Infinity;\n  let minPointInfo = {};\n\n  projectedCoords.forEach(([x2, y2], index) => {\n    if (index === 0) {\n      return;\n    }\n\n    const [x1, y1] = projectedCoords[index - 1];\n\n    // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n    const A = y1 - y2;\n    const B = x2 - x1;\n    const C = x1 * y2 - x2 * y1;\n\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    const div = A * A + B * B;\n    const distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);\n\n    // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div,\n      };\n    }\n  });\n  //@ts-ignore\n  const { index, x0, y0 } = minPointInfo;\n  const [x1, y1, z1 = 0] = projectedCoords[index - 1];\n  const [x2, y2, z2 = 0] = projectedCoords[index];\n\n  // calculate what ratio of the line we are on to find the proper z\n  const lineLength = distance2d(x1, y1, x2, y2);\n  const startToPointLength = distance2d(x1, y1, x0, y0);\n  const ratio = startToPointLength / lineLength;\n  const z0 = mix(z1, z2, ratio);\n\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0]),\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}