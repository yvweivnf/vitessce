{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear as _clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nvar LOG_DRAW_PRIORITY = 2;\nvar LOG_DRAW_TIMEOUT = 10000;\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nvar NOOP = function NOOP() {};\n\nvar DRAW_PARAMS = {};\n\nvar Model = /*#__PURE__*/function () {\n  function Model(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Model);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('model') : _props$id;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  _createClass(Model, [{\n    key: \"initialize\",\n    value: function initialize(props) {\n      this.props = {};\n      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n      this._programManagerState = -1;\n      this._managedProgram = false;\n      var _props$program = props.program,\n          program = _props$program === void 0 ? null : _props$program,\n          vs = props.vs,\n          fs = props.fs,\n          modules = props.modules,\n          defines = props.defines,\n          inject = props.inject,\n          varyings = props.varyings,\n          bufferMode = props.bufferMode,\n          transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this.program = null;\n      this.vertexArray = null;\n      this._programDirty = true;\n      this.userData = {};\n      this.needsRedraw = true;\n      this._attributes = {};\n      this.attributes = {};\n      this.uniforms = {};\n      this.pickable = true;\n\n      this._checkProgram();\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n      this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n      this.vertexCount = props.vertexCount || 0;\n      this.geometryBuffers = {};\n      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n      this._setModelProps(props);\n\n      this.geometry = {};\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this._setModelProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var key in this._attributes) {\n        if (this._attributes[key] !== this.attributes[key]) {\n          this._attributes[key].delete();\n        }\n      }\n\n      if (this._managedProgram) {\n        this.programManager.release(this.program);\n        this._managedProgram = false;\n      }\n\n      this.vertexArray.delete();\n\n      this._deleteGeometryBuffers();\n    }\n  }, {\n    key: \"getDrawMode\",\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getProgram\",\n    value: function getProgram() {\n      return this.program;\n    }\n  }, {\n    key: \"setProgram\",\n    value: function setProgram(props) {\n      var program = props.program,\n          vs = props.vs,\n          fs = props.fs,\n          modules = props.modules,\n          defines = props.defines,\n          inject = props.inject,\n          varyings = props.varyings,\n          bufferMode = props.bufferMode,\n          transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this._programDirty = true;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      return this.uniforms;\n    }\n  }, {\n    key: \"setDrawMode\",\n    value: function setDrawMode(drawMode) {\n      this.drawMode = drawMode;\n      return this;\n    }\n  }, {\n    key: \"setVertexCount\",\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: \"setInstanceCount\",\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    }\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(geometry) {\n      this.drawMode = geometry.drawMode;\n      this.vertexCount = geometry.getVertexCount();\n\n      this._deleteGeometryBuffers();\n\n      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n      this.vertexArray.setAttributes(this.geometryBuffers);\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(attributes)) {\n        return this;\n      }\n\n      var normalizedAttributes = {};\n\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n      }\n\n      this.vertexArray.setAttributes(normalizedAttributes);\n      return this;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.assign(this.uniforms, uniforms);\n      return this;\n    }\n  }, {\n    key: \"getModuleUniforms\",\n    value: function getModuleUniforms(opts) {\n      this._checkProgram();\n\n      var getUniforms = this.programManager.getUniforms(this.program);\n\n      if (getUniforms) {\n        return getUniforms(opts);\n      }\n\n      return {};\n    }\n  }, {\n    key: \"updateModuleSettings\",\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts || {});\n      return this.setUniforms(uniforms);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(opts) {\n      _clear(this.program.gl, opts);\n\n      return this;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._checkProgram();\n\n      var _opts$moduleSettings = opts.moduleSettings,\n          moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,\n          framebuffer = opts.framebuffer,\n          _opts$uniforms = opts.uniforms,\n          uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,\n          _opts$attributes = opts.attributes,\n          attributes = _opts$attributes === void 0 ? {} : _opts$attributes,\n          _opts$transformFeedba = opts.transformFeedback,\n          transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,\n          _opts$parameters = opts.parameters,\n          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,\n          _opts$vertexArray = opts.vertexArray,\n          vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray;\n      this.setAttributes(attributes);\n      this.updateModuleSettings(moduleSettings);\n      this.setUniforms(uniforms);\n      var logPriority;\n\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n      }\n\n      var drawParams = this.vertexArray.getDrawParams();\n      var _this$props = this.props,\n          _this$props$isIndexed = _this$props.isIndexed,\n          isIndexed = _this$props$isIndexed === void 0 ? drawParams.isIndexed : _this$props$isIndexed,\n          _this$props$indexType = _this$props.indexType,\n          indexType = _this$props$indexType === void 0 ? drawParams.indexType : _this$props$indexType,\n          _this$props$indexOffs = _this$props.indexOffset,\n          indexOffset = _this$props$indexOffs === void 0 ? drawParams.indexOffset : _this$props$indexOffs,\n          _this$props$vertexArr = _this$props.vertexArrayInstanced,\n          vertexArrayInstanced = _this$props$vertexArr === void 0 ? drawParams.isInstanced : _this$props$vertexArr;\n\n      if (vertexArrayInstanced && !this.isInstanced) {\n        log.warn('Found instanced attributes on non-instanced model', this.id)();\n      }\n\n      var isInstanced = this.isInstanced,\n          instanceCount = this.instanceCount;\n      var _this$props2 = this.props,\n          _this$props2$onBefore = _this$props2.onBeforeRender,\n          onBeforeRender = _this$props2$onBefore === void 0 ? NOOP : _this$props2$onBefore,\n          _this$props2$onAfterR = _this$props2.onAfterRender,\n          onAfterRender = _this$props2$onAfterR === void 0 ? NOOP : _this$props2$onAfterR;\n      onBeforeRender();\n      this.program.setUniforms(this.uniforms);\n      var didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n        logPriority: logPriority,\n        uniforms: null,\n        framebuffer: framebuffer,\n        parameters: parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray: vertexArray,\n        transformFeedback: transformFeedback,\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      }));\n      onAfterRender();\n\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n      }\n\n      return didDraw;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$discard = opts.discard,\n          discard = _opts$discard === void 0 ? true : _opts$discard,\n          feedbackBuffers = opts.feedbackBuffers,\n          _opts$unbindModels = opts.unbindModels,\n          unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;\n      var parameters = opts.parameters;\n\n      if (feedbackBuffers) {\n        this._setFeedbackBuffers(feedbackBuffers);\n      }\n\n      if (discard) {\n        parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));\n      }\n\n      unbindModels.forEach(function (model) {\n        return model.vertexArray.unbindBuffers();\n      });\n\n      try {\n        this.draw(Object.assign({}, opts, {\n          parameters: parameters\n        }));\n      } finally {\n        unbindModels.forEach(function (model) {\n          return model.vertexArray.bindBuffers();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n      return this.setUniforms(uniforms).draw();\n    }\n  }, {\n    key: \"_setModelProps\",\n    value: function _setModelProps(props) {\n      Object.assign(this.props, props);\n\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms);\n      }\n\n      if ('pickable' in props) {\n        this.pickable = props.pickable;\n      }\n\n      if ('instanceCount' in props) {\n        this.instanceCount = props.instanceCount;\n      }\n\n      if ('geometry' in props) {\n        this.setGeometry(props.geometry);\n      }\n\n      if ('attributes' in props) {\n        this.setAttributes(props.attributes);\n      }\n\n      if ('_feedbackBuffers' in props) {\n        this._setFeedbackBuffers(props._feedbackBuffers);\n      }\n    }\n  }, {\n    key: \"_checkProgram\",\n    value: function _checkProgram() {\n      var needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n      if (!needsUpdate) {\n        return;\n      }\n\n      var program = this.programProps.program;\n\n      if (program) {\n        this._managedProgram = false;\n      } else {\n        var _this$programProps = this.programProps,\n            vs = _this$programProps.vs,\n            fs = _this$programProps.fs,\n            modules = _this$programProps.modules,\n            inject = _this$programProps.inject,\n            defines = _this$programProps.defines,\n            varyings = _this$programProps.varyings,\n            bufferMode = _this$programProps.bufferMode,\n            transpileToGLSL100 = _this$programProps.transpileToGLSL100;\n        program = this.programManager.get({\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          varyings: varyings,\n          bufferMode: bufferMode,\n          transpileToGLSL100: transpileToGLSL100\n        });\n\n        if (this.program && this._managedProgram) {\n          this.programManager.release(this.program);\n        }\n\n        this._programManagerState = this.programManager.stateHash;\n        this._managedProgram = true;\n      }\n\n      assert(program instanceof Program, 'Model needs a program');\n      this._programDirty = false;\n\n      if (program === this.program) {\n        return;\n      }\n\n      this.program = program;\n\n      if (this.vertexArray) {\n        this.vertexArray.setProps({\n          program: this.program,\n          attributes: this.vertexArray.attributes\n        });\n      } else {\n        this.vertexArray = new VertexArray(this.gl, {\n          program: this.program\n        });\n      }\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n    }\n  }, {\n    key: \"_deleteGeometryBuffers\",\n    value: function _deleteGeometryBuffers() {\n      for (var name in this.geometryBuffers) {\n        var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n\n        if (buffer instanceof Buffer) {\n          buffer.delete();\n        }\n      }\n    }\n  }, {\n    key: \"_setAnimationProps\",\n    value: function _setAnimationProps(animationProps) {\n      if (this.animated) {\n        assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      }\n    }\n  }, {\n    key: \"_setFeedbackBuffers\",\n    value: function _setFeedbackBuffers() {\n      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(feedbackBuffers)) {\n        return this;\n      }\n\n      var gl = this.program.gl;\n      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n        program: this.program\n      });\n      this.transformFeedback.setBuffers(feedbackBuffers);\n      return this;\n    }\n  }, {\n    key: \"_logDrawCallStart\",\n    value: function _logDrawCallStart(logLevel) {\n      var logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n      if (Date.now() - this.lastLogTime < logDrawTimeout) {\n        return undefined;\n      }\n\n      this.lastLogTime = Date.now();\n      log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n        collapsed: log.level <= 2\n      })();\n      return logLevel;\n    }\n  }, {\n    key: \"_logDrawCallEnd\",\n    value: function _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n      if (logLevel === undefined) {\n        return;\n      }\n\n      var attributeTable = getDebugTableForVertexArray({\n        vertexArray: vertexArray,\n        header: \"\".concat(this.id, \" attributes\"),\n        attributes: this._attributes\n      });\n\n      var _getDebugTableForUnif = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms)\n      }),\n          uniformTable = _getDebugTableForUnif.table,\n          unusedTable = _getDebugTableForUnif.unusedTable,\n          unusedCount = _getDebugTableForUnif.unusedCount;\n\n      var _getDebugTableForUnif2 = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms),\n        undefinedOnly: true\n      }),\n          missingTable = _getDebugTableForUnif2.table,\n          missingCount = _getDebugTableForUnif2.count;\n\n      if (missingCount > 0) {\n        log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      }\n\n      if (unusedCount > 0) {\n        log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      }\n\n      var configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n      log.table(logLevel, attributeTable)();\n      log.table(logLevel, uniformTable)();\n      log.table(logLevel + 1, configTable)();\n\n      if (framebuffer) {\n        framebuffer.log({\n          logLevel: LOG_DRAW_PRIORITY,\n          message: \"Rendered to \".concat(framebuffer.id)\n        });\n      }\n\n      log.groupEnd(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id))();\n    }\n  }]);\n\n  return Model;\n}();\n\nexport { Model as default };","map":{"version":3,"sources":["../../../src/lib/model.js"],"names":["clear","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","constructor","props","id","uid","assert","isWebGL","ProgramManager","program","transpileToGLSL100","vs","fs","modules","defines","inject","varyings","bufferMode","Object","Number","geometry","getBuffersFromGeometry","attributes","isObjectEmpty","normalizedAttributes","attribute","uniforms","getUniforms","opts","moduleSettings","transformFeedback","parameters","vertexArray","log","logPriority","drawParams","isIndexed","indexType","indexOffset","vertexArrayInstanced","isInstanced","instanceCount","onBeforeRender","onAfterRender","didDraw","framebuffer","drawMode","vertexCount","offset","discard","unbindModels","model","needsUpdate","buffer","feedbackBuffers","gl","logDrawTimeout","logLevel","Date","collapsed","attributeTable","getDebugTableForVertexArray","header","_attributes","table","unusedCount","getDebugTableForUniforms","count","missingCount","undefinedOnly","configTable","getDebugTableForProgramConfiguration","message"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      // @ts-ignore TODO\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      // const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      // Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      // @ts-ignore\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}