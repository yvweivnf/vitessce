{"ast":null,"code":"import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\nimport { BaseClient, BaseResponse } from './base';\nimport { AbortError } from '../../utils';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = this.parsedUrl.protocol === 'http:' ? http : https;\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get({ ...this.parsedUrl,\n        headers\n      }, response => {\n        const dataPromise = new Promise(resolve => {\n          const chunks = []; // collect chunks\n\n          response.on('data', chunk => {\n            chunks.push(chunk);\n          }); // concatenate all chunks and resolve the promise with the resulting buffer\n\n          response.on('end', () => {\n            const data = Buffer.concat(chunks).buffer;\n            resolve(data);\n          });\n          response.on('error', reject);\n        });\n        resolve(new HttpResponse(response, dataPromise));\n      });\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({\n    headers,\n    signal\n  } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/geotiff/src/source/client/http.js"],"names":["http","https","urlMod","BaseClient","BaseResponse","AbortError","HttpResponse","constructor","response","dataPromise","status","statusCode","getHeader","name","headers","getData","data","HttpClient","url","parsedUrl","parse","httpApi","protocol","constructRequest","signal","Promise","resolve","reject","request","get","chunks","on","chunk","push","Buffer","concat","buffer","aborted","destroy","addEventListener"],"mappings":"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","sourcesContent":["import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base';\nimport { AbortError } from '../../utils';\n\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolve) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolve(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}