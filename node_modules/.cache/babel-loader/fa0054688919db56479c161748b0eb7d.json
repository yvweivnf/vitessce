{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNEL_INDEX, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model, property) {\n  var localScaleComponents = model.component.scales;\n  var config = model.config,\n      encoding = model.encoding,\n      markDef = model.markDef,\n      specifiedScales = model.specifiedScales;\n\n  var _iterator = _createForOfIteratorHelper(keys(localScaleComponents)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      var specifiedScale = specifiedScales[channel];\n      var localScaleCmpt = localScaleComponents[channel];\n      var mergedScaleCmpt = model.getScaleComponent(channel);\n      var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n      var specifiedValue = specifiedScale[property];\n      var scaleType = mergedScaleCmpt.get('type');\n      var scalePadding = mergedScaleCmpt.get('padding');\n      var scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n      var supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      var channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n      if (specifiedValue !== undefined) {\n        // If there is a specified value, check if it is compatible with scale type and channel\n        if (!supportedByScaleType) {\n          log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n        } else if (channelIncompatability) {\n          // channel\n          log.warn(channelIncompatability);\n        }\n      }\n\n      if (supportedByScaleType && channelIncompatability === undefined) {\n        if (specifiedValue !== undefined) {\n          var timeUnit = fieldOrDatumDef['timeUnit'];\n          var type = fieldOrDatumDef.type;\n\n          switch (property) {\n            // domainMax/Min to signal if the value is a datetime object\n            case 'domainMax':\n            case 'domainMin':\n              if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n                localScaleCmpt.set(property, {\n                  signal: valueExpr(specifiedScale[property], {\n                    type: type,\n                    timeUnit: timeUnit\n                  })\n                }, true);\n              } else {\n                localScaleCmpt.set(property, specifiedScale[property], true);\n              }\n\n              break;\n\n            default:\n              localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n          }\n        } else {\n          var value = property in scaleRules ? scaleRules[property]({\n            model: model,\n            channel: channel,\n            fieldOrDatumDef: fieldOrDatumDef,\n            scaleType: scaleType,\n            scalePadding: scalePadding,\n            scalePaddingInner: scalePaddingInner,\n            domain: specifiedScale.domain,\n            markDef: markDef,\n            config: config\n          }) : config.scale[property];\n\n          if (value !== undefined) {\n            localScaleCmpt.set(property, value, false);\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nexport var scaleRules = {\n  bins: function bins(_ref) {\n    var model = _ref.model,\n        fieldOrDatumDef = _ref.fieldOrDatumDef;\n    return isFieldDef(fieldOrDatumDef) ? _bins(model, fieldOrDatumDef) : undefined;\n  },\n  interpolate: function interpolate(_ref2) {\n    var channel = _ref2.channel,\n        fieldOrDatumDef = _ref2.fieldOrDatumDef;\n    return _interpolate(channel, fieldOrDatumDef.type);\n  },\n  nice: function nice(_ref3) {\n    var scaleType = _ref3.scaleType,\n        channel = _ref3.channel,\n        domain = _ref3.domain,\n        fieldOrDatumDef = _ref3.fieldOrDatumDef;\n    return _nice(scaleType, channel, domain, fieldOrDatumDef);\n  },\n  padding: function padding(_ref4) {\n    var channel = _ref4.channel,\n        scaleType = _ref4.scaleType,\n        fieldOrDatumDef = _ref4.fieldOrDatumDef,\n        markDef = _ref4.markDef,\n        config = _ref4.config;\n    return _padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar);\n  },\n  paddingInner: function paddingInner(_ref5) {\n    var scalePadding = _ref5.scalePadding,\n        channel = _ref5.channel,\n        markDef = _ref5.markDef,\n        config = _ref5.config;\n    return _paddingInner(scalePadding, channel, markDef.type, config.scale);\n  },\n  paddingOuter: function paddingOuter(_ref6) {\n    var scalePadding = _ref6.scalePadding,\n        channel = _ref6.channel,\n        scaleType = _ref6.scaleType,\n        markDef = _ref6.markDef,\n        scalePaddingInner = _ref6.scalePaddingInner,\n        config = _ref6.config;\n    return _paddingOuter(scalePadding, channel, scaleType, markDef.type, scalePaddingInner, config.scale);\n  },\n  reverse: function reverse(_ref7) {\n    var fieldOrDatumDef = _ref7.fieldOrDatumDef,\n        scaleType = _ref7.scaleType,\n        channel = _ref7.channel,\n        config = _ref7.config;\n    var sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return _reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: function zero(_ref8) {\n    var channel = _ref8.channel,\n        fieldOrDatumDef = _ref8.fieldOrDatumDef,\n        domain = _ref8.domain,\n        markDef = _ref8.markDef,\n        scaleType = _ref8.scaleType;\n    return _zero(channel, fieldOrDatumDef, domain, markDef, scaleType);\n  }\n}; // This method is here rather than in range.ts to avoid circular dependency.\n\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  var localScaleComponents = model.component.scales;\n\n  var _iterator2 = _createForOfIteratorHelper(model.children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n\n      if (property === 'range') {\n        parseScaleRange(child);\n      } else {\n        parseScaleProperty(child, property);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(keys(localScaleComponents)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var channel = _step3.value;\n      var valueWithExplicit = void 0;\n\n      var _iterator4 = _createForOfIteratorHelper(model.children),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _child = _step4.value;\n          var childComponent = _child.component.scales[channel];\n\n          if (childComponent) {\n            var childValueWithExplicit = childComponent.getWithExplicit(property);\n            valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing(function (v1, v2) {\n              switch (property) {\n                case 'range':\n                  // For step, prefer larger step\n                  if (v1.step && v2.step) {\n                    return v1.step - v2.step;\n                  }\n\n                  return 0;\n                // TODO: precedence rule for other properties\n              }\n\n              return 0;\n            }));\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nfunction _bins(model, fieldDef) {\n  var bin = fieldDef.bin;\n\n  if (isBinning(bin)) {\n    var binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(function () {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n\n  return undefined;\n}\n\nexport { _bins as bins };\n\nfunction _interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n\n  return undefined;\n}\n\nexport { _interpolate as interpolate };\n\nfunction _nice(scaleType, channel, specifiedDomain, fieldOrDatumDef) {\n  var _a;\n\n  if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) || isArray(specifiedDomain) || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n\n  return channel in POSITION_SCALE_CHANNEL_INDEX ? true : undefined;\n}\n\nexport { _nice as nice };\n\nfunction _padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n  if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      var type = markDef.type,\n          orient = markDef.orient;\n\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n\n  return undefined;\n}\n\nexport { _padding as padding };\n\nfunction _paddingInner(paddingValue, channel, mark, scaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    var bandPaddingInner = scaleConfig.bandPaddingInner,\n        barBandPaddingInner = scaleConfig.barBandPaddingInner,\n        rectBandPaddingInner = scaleConfig.rectBandPaddingInner;\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  }\n\n  return undefined;\n}\n\nexport { _paddingInner as paddingInner };\n\nfunction _paddingOuter(paddingValue, channel, scaleType, mark, paddingInnerValue, scaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      var bandPaddingOuter = scaleConfig.bandPaddingOuter;\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      isSignalRef(paddingInnerValue) ? {\n        signal: \"\".concat(paddingInnerValue.signal, \"/2\")\n      } : paddingInnerValue / 2);\n    }\n  }\n\n  return undefined;\n}\n\nexport { _paddingOuter as paddingOuter };\n\nfunction _reverse(scaleType, sort, channel, scaleConfig) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {\n          signal: \"!\".concat(scaleConfig.xReverse.signal)\n        };\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n\n    return scaleConfig.xReverse;\n  }\n\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n\n  return undefined;\n}\n\nexport { _reverse as reverse };\n\nfunction _zero(channel, fieldDef, specifiedDomain, markDef, scaleType) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  var hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        var first = specifiedDomain[0];\n        var last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n\n      return false;\n    }\n  } // If there is no custom domain, return true only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n\n\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  } // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n\n\n  if (!(isFieldDef(fieldDef) && fieldDef.bin) && util.contains([].concat(_toConsumableArray(POSITION_SCALE_CHANNELS), _toConsumableArray(POLAR_POSITION_SCALE_CHANNELS)), channel)) {\n    var orient = markDef.orient,\n        type = markDef.type;\n\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nexport { _zero as zero };","map":{"version":3,"sources":["../../../../src/compile/scale/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNEL_INDEX, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n    if (isUnitModel(model)) {\n        parseUnitScaleProperty(model, property);\n    }\n    else {\n        parseNonUnitScaleProperty(model, property);\n    }\n}\nfunction parseUnitScaleProperty(model, property) {\n    const localScaleComponents = model.component.scales;\n    const { config, encoding, markDef, specifiedScales } = model;\n    for (const channel of keys(localScaleComponents)) {\n        const specifiedScale = specifiedScales[channel];\n        const localScaleCmpt = localScaleComponents[channel];\n        const mergedScaleCmpt = model.getScaleComponent(channel);\n        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n        const specifiedValue = specifiedScale[property];\n        const scaleType = mergedScaleCmpt.get('type');\n        const scalePadding = mergedScaleCmpt.get('padding');\n        const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n        const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n        const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n        if (specifiedValue !== undefined) {\n            // If there is a specified value, check if it is compatible with scale type and channel\n            if (!supportedByScaleType) {\n                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n            }\n            else if (channelIncompatability) {\n                // channel\n                log.warn(channelIncompatability);\n            }\n        }\n        if (supportedByScaleType && channelIncompatability === undefined) {\n            if (specifiedValue !== undefined) {\n                const timeUnit = fieldOrDatumDef['timeUnit'];\n                const type = fieldOrDatumDef.type;\n                switch (property) {\n                    // domainMax/Min to signal if the value is a datetime object\n                    case 'domainMax':\n                    case 'domainMin':\n                        if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n                            localScaleCmpt.set(property, { signal: valueExpr(specifiedScale[property], { type, timeUnit }) }, true);\n                        }\n                        else {\n                            localScaleCmpt.set(property, specifiedScale[property], true);\n                        }\n                        break;\n                    default:\n                        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n                }\n            }\n            else {\n                const value = property in scaleRules\n                    ? scaleRules[property]({\n                        model,\n                        channel,\n                        fieldOrDatumDef,\n                        scaleType,\n                        scalePadding,\n                        scalePaddingInner,\n                        domain: specifiedScale.domain,\n                        markDef,\n                        config\n                    })\n                    : config.scale[property];\n                if (value !== undefined) {\n                    localScaleCmpt.set(property, value, false);\n                }\n            }\n        }\n    }\n}\nexport const scaleRules = {\n    bins: ({ model, fieldOrDatumDef }) => (isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined),\n    interpolate: ({ channel, fieldOrDatumDef }) => interpolate(channel, fieldOrDatumDef.type),\n    nice: ({ scaleType, channel, domain, fieldOrDatumDef }) => nice(scaleType, channel, domain, fieldOrDatumDef),\n    padding: ({ channel, scaleType, fieldOrDatumDef, markDef, config }) => padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n    paddingInner: ({ scalePadding, channel, markDef, config }) => paddingInner(scalePadding, channel, markDef.type, config.scale),\n    paddingOuter: ({ scalePadding, channel, scaleType, markDef, scalePaddingInner, config }) => paddingOuter(scalePadding, channel, scaleType, markDef.type, scalePaddingInner, config.scale),\n    reverse: ({ fieldOrDatumDef, scaleType, channel, config }) => {\n        const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n        return reverse(scaleType, sort, channel, config.scale);\n    },\n    zero: ({ channel, fieldOrDatumDef, domain, markDef, scaleType }) => zero(channel, fieldOrDatumDef, domain, markDef, scaleType)\n};\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model) {\n    if (isUnitModel(model)) {\n        parseUnitScaleRange(model);\n    }\n    else {\n        parseNonUnitScaleProperty(model, 'range');\n    }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n    const localScaleComponents = model.component.scales;\n    for (const child of model.children) {\n        if (property === 'range') {\n            parseScaleRange(child);\n        }\n        else {\n            parseScaleProperty(child, property);\n        }\n    }\n    for (const channel of keys(localScaleComponents)) {\n        let valueWithExplicit;\n        for (const child of model.children) {\n            const childComponent = child.component.scales[channel];\n            if (childComponent) {\n                const childValueWithExplicit = childComponent.getWithExplicit(property);\n                valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n                    switch (property) {\n                        case 'range':\n                            // For step, prefer larger step\n                            if (v1.step && v2.step) {\n                                return v1.step - v2.step;\n                            }\n                            return 0;\n                        // TODO: precedence rule for other properties\n                    }\n                    return 0;\n                }));\n            }\n        }\n        localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n    }\n}\nexport function bins(model, fieldDef) {\n    const bin = fieldDef.bin;\n    if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return new SignalRefWrapper(() => {\n            return model.getSignalName(binSignal);\n        });\n    }\n    else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n        // start and stop will be determined from the scale domain\n        return {\n            step: bin.step\n        };\n    }\n    return undefined;\n}\nexport function interpolate(channel, type) {\n    if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n        return 'hcl';\n    }\n    return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, fieldOrDatumDef) {\n    var _a;\n    if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) ||\n        isArray(specifiedDomain) ||\n        util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n        return undefined;\n    }\n    return channel in POSITION_SCALE_CHANNEL_INDEX ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n    if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n        if (isContinuousToContinuous(scaleType)) {\n            if (scaleConfig.continuousPadding !== undefined) {\n                return scaleConfig.continuousPadding;\n            }\n            const { type, orient } = markDef;\n            if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n                if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n                    return barConfig.continuousBandSize;\n                }\n            }\n        }\n        if (scaleType === ScaleType.POINT) {\n            return scaleConfig.pointPadding;\n        }\n    }\n    return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleConfig) {\n    if (paddingValue !== undefined) {\n        // If user has already manually specified \"padding\", no need to add default paddingInner.\n        return undefined;\n    }\n    if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n        // Padding is only set for X and Y by default.\n        // Basically it doesn't make sense to add padding for color and size.\n        // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n        const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner } = scaleConfig;\n        return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n    }\n    return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, mark, paddingInnerValue, scaleConfig) {\n    if (paddingValue !== undefined) {\n        // If user has already manually specified \"padding\", no need to add default paddingOuter.\n        return undefined;\n    }\n    if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n        // Padding is only set for X and Y by default.\n        // Basically it doesn't make sense to add padding for color and size.\n        if (scaleType === ScaleType.BAND) {\n            const { bandPaddingOuter } = scaleConfig;\n            return getFirstDefined(bandPaddingOuter, \n            /* By default, paddingOuter is paddingInner / 2. The reason is that\n              size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n              and we want the width/height to be integer by default.\n              Note that step (by default) and cardinality are integers.) */\n            isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2);\n        }\n    }\n    return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n    if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n        if (hasContinuousDomain(scaleType) && sort === 'descending') {\n            if (isSignalRef(scaleConfig.xReverse)) {\n                return { signal: `!${scaleConfig.xReverse.signal}` };\n            }\n            else {\n                return !scaleConfig.xReverse;\n            }\n        }\n        return scaleConfig.xReverse;\n    }\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n        // For continuous domain scales, Vega does not support domain sort.\n        // Thus, we reverse range instead if sort is descending\n        return true;\n    }\n    return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType) {\n    // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n    const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n    if (hasCustomDomain) {\n        if (hasContinuousDomain(scaleType)) {\n            if (isArray(specifiedDomain)) {\n                const first = specifiedDomain[0];\n                const last = specifiedDomain[specifiedDomain.length - 1];\n                if (first <= 0 && last >= 0) {\n                    // if the domain includes zero, make zero remains true\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    // If there is no custom domain, return true only for the following cases:\n    // 1) using quantitative field with size\n    // While this can be either ratio or interval fields, our assumption is that\n    // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n    // false so that range doesn't start at zero\n    if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n        return true;\n    }\n    // 2) non-binned, quantitative x-scale or y-scale\n    // (For binning, we should not include zero by default because binning are calculated without zero.)\n    if (!(isFieldDef(fieldDef) && fieldDef.bin) &&\n        util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n        const { orient, type } = markDef;\n        if (contains(['bar', 'area', 'line', 'trail'], type)) {\n            if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}