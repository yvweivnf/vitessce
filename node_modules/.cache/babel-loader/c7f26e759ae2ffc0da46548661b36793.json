{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { getBlobOrSVGDataUrl } from './svg-utils';\nexport default function parseToImage(_x, _x2, _x3) {\n  return _parseToImage.apply(this, arguments);\n}\n\nfunction _parseToImage() {\n  _parseToImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(arrayBuffer, options, url) {\n    var blobOrDataUrl, URL, objectUrl;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n            URL = self.URL || self.webkitURL;\n            objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n            _context.prev = 3;\n            _context.next = 6;\n            return loadToImage(objectUrl || blobOrDataUrl, options);\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n            _context.prev = 7;\n\n            if (objectUrl) {\n              URL.revokeObjectURL(objectUrl);\n            }\n\n            return _context.finish(7);\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3,, 7, 10]]);\n  }));\n  return _parseToImage.apply(this, arguments);\n}\n\nexport function loadToImage(_x4, _x5) {\n  return _loadToImage.apply(this, arguments);\n}\n\nfunction _loadToImage() {\n  _loadToImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url, options) {\n    var image;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            image = new Image();\n            image.src = url;\n\n            if (!(options.image && options.image.decode && image.decode)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 5;\n            return image.decode();\n\n          case 5:\n            return _context2.abrupt(\"return\", image);\n\n          case 6:\n            _context2.next = 8;\n            return new Promise(function (resolve, reject) {\n              try {\n                image.onload = function () {\n                  return resolve(image);\n                };\n\n                image.onerror = function (err) {\n                  return reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n                };\n              } catch (error) {\n                reject(error);\n              }\n            });\n\n          case 8:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadToImage.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.ts"],"names":["blobOrDataUrl","getBlobOrSVGDataUrl","URL","self","objectUrl","loadToImage","image","options","resolve","err","reject"],"mappings":";;AACA,SAAA,mBAAA,QAAA,aAAA;AAGA,wBAAe,YAAf;AAAA;AAAA;;;2EAAe,iBAAA,WAAA,EAAA,OAAA,EAAA,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASPA,YAAAA,aATO,GASSC,mBAAmB,CAAA,WAAA,EAAzC,GAAyC,CAT5B;AAUPC,YAAAA,GAVO,GAUDC,IAAI,CAAJA,GAAAA,IAAYA,IAAI,CAA5B,SAVa;AAWPC,YAAAA,SAXO,GAWK,OAAA,aAAA,KAAA,QAAA,IAAqCF,GAAG,CAAHA,eAAAA,CAAvD,aAAuDA,CAX1C;AAAA;AAAA;AAAA,mBAaEG,WAAW,CAACD,SAAS,IAAV,aAAA,EAAxB,OAAwB,CAbb;;AAAA;AAAA;;AAAA;AAAA;;AAeX,gBAAA,SAAA,EAAe;AACbF,cAAAA,GAAG,CAAHA,eAAAA,CAAAA,SAAAA;AACD;;AAjBU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAqBf,gBAAO,WAAP;AAAA;AAAA;;;0EAAO,kBAAA,GAAA,EAAA,OAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACCI,YAAAA,KADD,GACS,IAAd,KAAc,EADT;AAELA,YAAAA,KAAK,CAALA,GAAAA,GAAAA,GAAAA;;AAFK,kBAWDC,OAAO,CAAPA,KAAAA,IAAiBA,OAAO,CAAPA,KAAAA,CAAjBA,MAAAA,IAAyCD,KAAK,CAAlD,MAXK;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAYGA,KAAK,CAAX,MAAMA,EAZH;;AAAA;AAAA,8CAaH,KAbG;;AAAA;AAAA;AAAA,mBAiBQ,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AAC5C,kBAAI;AACFA,gBAAAA,KAAK,CAALA,MAAAA,GAAe;AAAA,yBAAME,OAAO,CAA5BF,KAA4B,CAAb;AAAA,iBAAfA;;AACAA,gBAAAA,KAAK,CAALA,OAAAA,GAAiBG,UAAAA,GAAD;AAAA,yBAASC,MAAM,CAAC,IAAA,KAAA,CAAA,wBAAA,MAAA,CAAA,GAAA,EAAA,IAAA,EAAA,MAAA,CAAhCJ,GAAgC,CAAA,CAAD,CAAf;AAAA,iBAAhBA;AAFF,eAAA,CAGE,OAAA,KAAA,EAAc;AACdI,gBAAAA,MAAM,CAANA,KAAM,CAANA;AACD;AANH,aAAa,CAjBR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import type {ImageLoaderOptions} from '../../image-loader';\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(\n  arrayBuffer: ArrayBuffer,\n  options: ImageLoaderOptions,\n  url?: string\n): Promise<HTMLImageElement> {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options): Promise<HTMLImageElement> {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}