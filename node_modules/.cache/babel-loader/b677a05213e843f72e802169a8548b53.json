{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { concatenateTypedArrays } from '@loaders.gl/loader-utils';\nexport function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {\n  var outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);\n  var newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n  var newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n  var newTriangles = new triangles.constructor(outsideEdges.length * 6);\n\n  for (var i = 0; i < outsideEdges.length; i++) {\n    var edge = outsideEdges[i];\n    updateAttributesForNewEdge({\n      edge: edge,\n      edgeIndex: i,\n      attributes: attributes,\n      skirtHeight: skirtHeight,\n      newPosition: newPosition,\n      newTexcoord0: newTexcoord0,\n      newTriangles: newTriangles\n    });\n  }\n\n  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n  var resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);\n  return {\n    attributes: attributes,\n    triangles: resultTriangles\n  };\n}\n\nfunction getOutsideEdgesFromTriangles(triangles) {\n  var edges = [];\n\n  for (var i = 0; i < triangles.length; i += 3) {\n    edges.push([triangles[i], triangles[i + 1]]);\n    edges.push([triangles[i + 1], triangles[i + 2]]);\n    edges.push([triangles[i + 2], triangles[i]]);\n  }\n\n  edges.sort(function (a, b) {\n    return Math.min.apply(Math, _toConsumableArray(a)) - Math.min.apply(Math, _toConsumableArray(b)) || Math.max.apply(Math, _toConsumableArray(a)) - Math.max.apply(Math, _toConsumableArray(b));\n  });\n  var outsideEdges = [];\n  var index = 0;\n\n  while (index < edges.length) {\n    var _edges, _edges2;\n\n    if (edges[index][0] === ((_edges = edges[index + 1]) === null || _edges === void 0 ? void 0 : _edges[1]) && edges[index][1] === ((_edges2 = edges[index + 1]) === null || _edges2 === void 0 ? void 0 : _edges2[0])) {\n      index += 2;\n    } else {\n      outsideEdges.push(edges[index]);\n      index++;\n    }\n  }\n\n  return outsideEdges;\n}\n\nfunction getOutsideEdgesFromIndices(indices, position) {\n  indices.westIndices.sort(function (a, b) {\n    return position[3 * a + 1] - position[3 * b + 1];\n  });\n  indices.eastIndices.sort(function (a, b) {\n    return position[3 * b + 1] - position[3 * a + 1];\n  });\n  indices.southIndices.sort(function (a, b) {\n    return position[3 * b] - position[3 * a];\n  });\n  indices.northIndices.sort(function (a, b) {\n    return position[3 * a] - position[3 * b];\n  });\n  var edges = [];\n\n  for (var index in indices) {\n    var indexGroup = indices[index];\n\n    for (var i = 0; i < indexGroup.length - 1; i++) {\n      edges.push([indexGroup[i], indexGroup[i + 1]]);\n    }\n  }\n\n  return edges;\n}\n\nfunction updateAttributesForNewEdge(_ref) {\n  var edge = _ref.edge,\n      edgeIndex = _ref.edgeIndex,\n      attributes = _ref.attributes,\n      skirtHeight = _ref.skirtHeight,\n      newPosition = _ref.newPosition,\n      newTexcoord0 = _ref.newTexcoord0,\n      newTriangles = _ref.newTriangles;\n  var positionsLength = attributes.POSITION.value.length;\n  var vertex1Offset = edgeIndex * 2;\n  var vertex2Offset = edgeIndex * 2 + 1;\n  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);\n  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;\n  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);\n  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;\n  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);\n  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);\n  var triangle1Offset = edgeIndex * 2 * 3;\n  newTriangles[triangle1Offset] = edge[0];\n  newTriangles[triangle1Offset + 1] = edge[1];\n  newTriangles[triangle1Offset + 2] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 4] = positionsLength / 3 + vertex1Offset;\n  newTriangles[triangle1Offset + 5] = edge[0];\n}","map":{"version":3,"sources":["../../../../src/lib/helpers/skirt.ts"],"names":["outsideEdges","outsideIndices","getOutsideEdgesFromIndices","attributes","getOutsideEdgesFromTriangles","newPosition","newTexcoord0","newTriangles","triangles","i","edge","updateAttributesForNewEdge","edgeIndex","skirtHeight","concatenateTypedArrays","resultTriangles","edges","Math","index","indices","position","indexGroup","positionsLength","vertex1Offset","vertex2Offset","triangle1Offset"],"mappings":";AAAA,SAAA,sBAAA,QAAA,0BAAA;AAiBA,OAAO,SAAA,QAAA,CAAA,UAAA,EAAA,SAAA,EAAA,WAAA,EAAA,cAAA,EAA4F;AACjG,MAAMA,YAAY,GAAGC,cAAc,GAC/BC,0BAA0B,CAAA,cAAA,EAAiBC,UAAU,CAAVA,QAAAA,CADZ,KACL,CADK,GAE/BC,4BAA4B,CAFhC,SAEgC,CAFhC;AAKA,MAAMC,WAAW,GAAG,IAAIF,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,CAAJ,WAAA,CAA0CH,YAAY,CAAZA,MAAAA,GAA9D,CAAoB,CAApB;AACA,MAAMM,YAAY,GAAG,IAAIH,UAAU,CAAVA,UAAAA,CAAAA,KAAAA,CAAJ,WAAA,CAA4CH,YAAY,CAAZA,MAAAA,GAAjE,CAAqB,CAArB;AAGA,MAAMO,YAAY,GAAG,IAAIC,SAAS,CAAb,WAAA,CAA0BR,YAAY,CAAZA,MAAAA,GAA/C,CAAqB,CAArB;;AAEA,OAAK,IAAIS,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGT,YAAY,CAAhC,MAAA,EAAyCS,CAAzC,EAAA,EAA8C;AAC5C,QAAMC,IAAI,GAAGV,YAAY,CAAzB,CAAyB,CAAzB;AAEAW,IAAAA,0BAA0B,CAAC;AACzBD,MAAAA,IADyB,EACzBA,IADyB;AAEzBE,MAAAA,SAAS,EAFgB,CAAA;AAGzBT,MAAAA,UAHyB,EAGzBA,UAHyB;AAIzBU,MAAAA,WAJyB,EAIzBA,WAJyB;AAKzBR,MAAAA,WALyB,EAKzBA,WALyB;AAMzBC,MAAAA,YANyB,EAMzBA,YANyB;AAOzBC,MAAAA,YAAAA,EAAAA;AAPyB,KAAD,CAA1BI;AASD;;AAEDR,EAAAA,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,GAA4BW,sBAAsB,CAACX,UAAU,CAAVA,QAAAA,CAAD,KAAA,EAAlDA,WAAkD,CAAlDA;AACAA,EAAAA,UAAU,CAAVA,UAAAA,CAAAA,KAAAA,GAA8BW,sBAAsB,CAACX,UAAU,CAAVA,UAAAA,CAAD,KAAA,EAApDA,YAAoD,CAApDA;AACA,MAAMY,eAAe,GACnBP,SAAS,YAATA,KAAAA,GACIA,SAAS,CAATA,MAAAA,CADJA,YACIA,CADJA,GAEIM,sBAAsB,CAAA,SAAA,EAH5B,YAG4B,CAH5B;AAKA,SAAO;AACLX,IAAAA,UADK,EACLA,UADK;AAELK,IAAAA,SAAS,EAAEO;AAFN,GAAP;AAID;;AAOD,SAAA,4BAAA,CAAA,SAAA,EAAiD;AAC/C,MAAMC,KAAiB,GAAvB,EAAA;;AACA,OAAK,IAAIP,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,SAAS,CAA7B,MAAA,EAAsCC,CAAC,IAAvC,CAAA,EAA8C;AAC5CO,IAAAA,KAAK,CAALA,IAAAA,CAAW,CAACR,SAAS,CAAV,CAAU,CAAV,EAAeA,SAAS,CAACC,CAAC,GAArCO,CAAmC,CAAxB,CAAXA;AACAA,IAAAA,KAAK,CAALA,IAAAA,CAAW,CAACR,SAAS,CAACC,CAAC,GAAZ,CAAU,CAAV,EAAmBD,SAAS,CAACC,CAAC,GAAzCO,CAAuC,CAA5B,CAAXA;AACAA,IAAAA,KAAK,CAALA,IAAAA,CAAW,CAACR,SAAS,CAACC,CAAC,GAAZ,CAAU,CAAV,EAAmBD,SAAS,CAAvCQ,CAAuC,CAA5B,CAAXA;AACD;;AAEDA,EAAAA,KAAK,CAALA,IAAAA,CAAW,UAAA,CAAA,EAAA,CAAA;AAAA,WAAUC,IAAI,CAAJA,GAAAA,OAAAA,IAAI,qBAAJA,CAAI,EAAJA,GAAiBA,IAAI,CAAJA,GAAAA,OAAAA,IAAI,qBAArBA,CAAqB,EAArBA,IAAmCA,IAAI,CAAJA,GAAAA,OAAAA,IAAI,qBAAJA,CAAI,EAAJA,GAAiBA,IAAI,CAAJA,GAAAA,OAAAA,IAAI,qBAA7ED,CAA6E,EAAlE;AAAA,GAAXA;AAEA,MAAMhB,YAAwB,GAA9B,EAAA;AACA,MAAIkB,KAAK,GAAT,CAAA;;AACA,SAAOA,KAAK,GAAGF,KAAK,CAApB,MAAA,EAA6B;AAAA,QAAA,MAAA,EAAA,OAAA;;AAC3B,QAAIA,KAAK,CAALA,KAAK,CAALA,CAAAA,CAAAA,OAAAA,CAAAA,MAAAA,GAAoBA,KAAK,CAACE,KAAK,GAA/BF,CAAyB,CAAzBA,MAAAA,IAAAA,IAAAA,MAAAA,KAAAA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAoBA,MAAAA,CAApBA,CAAoBA,CAApBA,KAA6CA,KAAK,CAALA,KAAK,CAALA,CAAAA,CAAAA,OAAAA,CAAAA,OAAAA,GAAoBA,KAAK,CAACE,KAAK,GAA/BF,CAAyB,CAAzBA,MAAAA,IAAAA,IAAAA,OAAAA,KAAAA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAoBA,OAAAA,CAArE,CAAqEA,CAApBA,CAAjD,EAA4F;AAC1FE,MAAAA,KAAK,IAALA,CAAAA;AADF,KAAA,MAEO;AACLlB,MAAAA,YAAY,CAAZA,IAAAA,CAAkBgB,KAAK,CAAvBhB,KAAuB,CAAvBA;AACAkB,MAAAA,KAAK;AACN;AACF;;AACD,SAAA,YAAA;AACD;;AAQD,SAAA,0BAAA,CAAA,OAAA,EAAA,QAAA,EAAoE;AAElEC,EAAAA,OAAO,CAAPA,WAAAA,CAAAA,IAAAA,CAAyB,UAAA,CAAA,EAAA,CAAA;AAAA,WAAUC,QAAQ,CAAC,IAAA,CAAA,GAATA,CAAQ,CAARA,GAAsBA,QAAQ,CAAC,IAAA,CAAA,GAAlED,CAAiE,CAAxC;AAAA,GAAzBA;AAEAA,EAAAA,OAAO,CAAPA,WAAAA,CAAAA,IAAAA,CAAyB,UAAA,CAAA,EAAA,CAAA;AAAA,WAAUC,QAAQ,CAAC,IAAA,CAAA,GAATA,CAAQ,CAARA,GAAsBA,QAAQ,CAAC,IAAA,CAAA,GAAlED,CAAiE,CAAxC;AAAA,GAAzBA;AACAA,EAAAA,OAAO,CAAPA,YAAAA,CAAAA,IAAAA,CAA0B,UAAA,CAAA,EAAA,CAAA;AAAA,WAAUC,QAAQ,CAAC,IAATA,CAAQ,CAARA,GAAkBA,QAAQ,CAAC,IAA/DD,CAA8D,CAApC;AAAA,GAA1BA;AAEAA,EAAAA,OAAO,CAAPA,YAAAA,CAAAA,IAAAA,CAA0B,UAAA,CAAA,EAAA,CAAA;AAAA,WAAUC,QAAQ,CAAC,IAATA,CAAQ,CAARA,GAAkBA,QAAQ,CAAC,IAA/DD,CAA8D,CAApC;AAAA,GAA1BA;AAEA,MAAMH,KAAiB,GAAvB,EAAA;;AACA,OAAK,IAAL,KAAA,IAAA,OAAA,EAA6B;AAC3B,QAAMK,UAAU,GAAGF,OAAO,CAA1B,KAA0B,CAA1B;;AACA,SAAK,IAAIV,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGY,UAAU,CAAVA,MAAAA,GAApB,CAAA,EAA2CZ,CAA3C,EAAA,EAAgD;AAC9CO,MAAAA,KAAK,CAALA,IAAAA,CAAW,CAACK,UAAU,CAAX,CAAW,CAAX,EAAgBA,UAAU,CAACZ,CAAC,GAAvCO,CAAqC,CAA1B,CAAXA;AACD;AACF;;AACD,SAAA,KAAA;AACD;;AAcD,SAAA,0BAAA,OAQG;AAAA,MARiC,IAQjC,QARiC,IAQjC;AAAA,MARiC,SAQjC,QARiC,SAQjC;AAAA,MARiC,UAQjC,QARiC,UAQjC;AAAA,MARiC,WAQjC,QARiC,WAQjC;AAAA,MARiC,WAQjC,QARiC,WAQjC;AAAA,MARiC,YAQjC,QARiC,YAQjC;AAAA,MADDT,YACC,QADDA,YACC;AACD,MAAMe,eAAe,GAAGnB,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,CAAxB,MAAA;AACA,MAAMoB,aAAa,GAAGX,SAAS,GAA/B,CAAA;AACA,MAAMY,aAAa,GAAGZ,SAAS,GAATA,CAAAA,GAAtB,CAAA;AAGAP,EAAAA,WAAW,CAAXA,GAAAA,CACEF,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAmCO,IAAI,CAAJA,CAAI,CAAJA,GAAnCP,CAAAA,EAAgDO,IAAI,CAAJA,CAAI,CAAJA,GAAAA,CAAAA,GADlDL,CACEF,CADFE,EAEEkB,aAAa,GAFflB,CAAAA;AAIAA,EAAAA,WAAW,CAACkB,aAAa,GAAbA,CAAAA,GAAZlB,CAAW,CAAXA,GAAqCA,WAAW,CAACkB,aAAa,GAAbA,CAAAA,GAAZlB,CAAW,CAAXA,GAArCA,WAAAA;AAGAA,EAAAA,WAAW,CAAXA,GAAAA,CACEF,UAAU,CAAVA,QAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAmCO,IAAI,CAAJA,CAAI,CAAJA,GAAnCP,CAAAA,EAAgDO,IAAI,CAAJA,CAAI,CAAJA,GAAAA,CAAAA,GADlDL,CACEF,CADFE,EAEEmB,aAAa,GAFfnB,CAAAA;AAIAA,EAAAA,WAAW,CAACmB,aAAa,GAAbA,CAAAA,GAAZnB,CAAW,CAAXA,GAAqCA,WAAW,CAACmB,aAAa,GAAbA,CAAAA,GAAZnB,CAAW,CAAXA,GAArCA,WAAAA;AAGAC,EAAAA,YAAY,CAAZA,GAAAA,CACEH,UAAU,CAAVA,UAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAqCO,IAAI,CAAJA,CAAI,CAAJA,GAArCP,CAAAA,EAAkDO,IAAI,CAAJA,CAAI,CAAJA,GAAAA,CAAAA,GADpDJ,CACEH,CADFG,EAEEiB,aAAa,GAFfjB,CAAAA;AAIAA,EAAAA,YAAY,CAAZA,GAAAA,CACEH,UAAU,CAAVA,UAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAqCO,IAAI,CAAJA,CAAI,CAAJA,GAArCP,CAAAA,EAAkDO,IAAI,CAAJA,CAAI,CAAJA,GAAAA,CAAAA,GADpDJ,CACEH,CADFG,EAEEkB,aAAa,GAFflB,CAAAA;AAMA,MAAMmB,eAAe,GAAGb,SAAS,GAATA,CAAAA,GAAxB,CAAA;AACAL,EAAAA,YAAY,CAAZA,eAAY,CAAZA,GAAgCG,IAAI,CAApCH,CAAoC,CAApCA;AACAA,EAAAA,YAAY,CAACkB,eAAe,GAA5BlB,CAAY,CAAZA,GAAoCG,IAAI,CAAxCH,CAAwC,CAAxCA;AACAA,EAAAA,YAAY,CAACkB,eAAe,GAA5BlB,CAAY,CAAZA,GAAoCe,eAAe,GAAfA,CAAAA,GAApCf,aAAAA;AAEAA,EAAAA,YAAY,CAACkB,eAAe,GAA5BlB,CAAY,CAAZA,GAAoCe,eAAe,GAAfA,CAAAA,GAApCf,aAAAA;AACAA,EAAAA,YAAY,CAACkB,eAAe,GAA5BlB,CAAY,CAAZA,GAAoCe,eAAe,GAAfA,CAAAA,GAApCf,aAAAA;AACAA,EAAAA,YAAY,CAACkB,eAAe,GAA5BlB,CAAY,CAAZA,GAAoCG,IAAI,CAAxCH,CAAwC,CAAxCA;AACD","sourcesContent":["import {concatenateTypedArrays} from '@loaders.gl/loader-utils';\n\nexport type EdgeIndices = {\n  westIndices: number[];\n  northIndices: number[];\n  eastIndices: number[];\n  southIndices: number[];\n};\n\n/**\n * Add skirt to existing mesh\n * @param {object} attributes - POSITION and TEXCOOD_0 attributes data\n * @param {any} triangles - indices array of the mesh geometry\n * @param skirtHeight - height of the skirt geometry\n * @param outsideIndices - edge indices from quantized mesh data\n * @returns - geometry data with added skirt\n */\nexport function addSkirt(attributes, triangles, skirtHeight: number, outsideIndices?: EdgeIndices) {\n  const outsideEdges = outsideIndices\n    ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value)\n    : getOutsideEdgesFromTriangles(triangles);\n\n  // 2 new vertices for each outside edge\n  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n\n  // 2 new triangles for each outside edge\n  const newTriangles = new triangles.constructor(outsideEdges.length * 6);\n\n  for (let i = 0; i < outsideEdges.length; i++) {\n    const edge = outsideEdges[i];\n\n    updateAttributesForNewEdge({\n      edge,\n      edgeIndex: i,\n      attributes,\n      skirtHeight,\n      newPosition,\n      newTexcoord0,\n      newTriangles\n    });\n  }\n\n  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n  const resultTriangles =\n    triangles instanceof Array\n      ? triangles.concat(newTriangles)\n      : concatenateTypedArrays(triangles, newTriangles);\n\n  return {\n    attributes,\n    triangles: resultTriangles\n  };\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {any} triangles - indices array of the mesh geometry\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromTriangles(triangles) {\n  const edges: number[][] = [];\n  for (let i = 0; i < triangles.length; i += 3) {\n    edges.push([triangles[i], triangles[i + 1]]);\n    edges.push([triangles[i + 1], triangles[i + 2]]);\n    edges.push([triangles[i + 2], triangles[i]]);\n  }\n\n  edges.sort((a, b) => Math.min(...a) - Math.min(...b) || Math.max(...a) - Math.max(...b));\n\n  const outsideEdges: number[][] = [];\n  let index = 0;\n  while (index < edges.length) {\n    if (edges[index][0] === edges[index + 1]?.[1] && edges[index][1] === edges[index + 1]?.[0]) {\n      index += 2;\n    } else {\n      outsideEdges.push(edges[index]);\n      index++;\n    }\n  }\n  return outsideEdges;\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} indices - edge indices from quantized mesh data\n * @param {TypedArray} position - position attribute geometry data\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromIndices(indices: EdgeIndices, position) {\n  // Sort skirt indices to create adjacent triangles\n  indices.westIndices.sort((a, b) => position[3 * a + 1] - position[3 * b + 1]);\n  // Reverse (b - a) to match triangle winding\n  indices.eastIndices.sort((a, b) => position[3 * b + 1] - position[3 * a + 1]);\n  indices.southIndices.sort((a, b) => position[3 * b] - position[3 * a]);\n  // Reverse (b - a) to match triangle winding\n  indices.northIndices.sort((a, b) => position[3 * a] - position[3 * b]);\n\n  const edges: number[][] = [];\n  for (const index in indices) {\n    const indexGroup = indices[index];\n    for (let i = 0; i < indexGroup.length - 1; i++) {\n      edges.push([indexGroup[i], indexGroup[i + 1]]);\n    }\n  }\n  return edges;\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} args\n * @param {number[]} args.edge - edge indices in geometry\n * @param {number} args.edgeIndex - edge index in outsideEdges array\n * @param {object} args.attributes - POSITION and TEXCOORD_0 attributes\n * @param {number} args.skirtHeight - height of the skirt geometry\n * @param {TypedArray} args.newPosition - POSITION array for skirt data\n * @param {TypedArray} args.newTexcoord0 - TEXCOORD_0 array for skirt data\n * @param {TypedArray | Array} args.newTriangles - trinagle indices array for skirt data\n * @returns {void}\n */\nfunction updateAttributesForNewEdge({\n  edge,\n  edgeIndex,\n  attributes,\n  skirtHeight,\n  newPosition,\n  newTexcoord0,\n  newTriangles\n}) {\n  const positionsLength = attributes.POSITION.value.length;\n  const vertex1Offset = edgeIndex * 2;\n  const vertex2Offset = edgeIndex * 2 + 1;\n\n  // Define POSITION for new 1st vertex\n  newPosition.set(\n    attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3),\n    vertex1Offset * 3\n  );\n  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n\n  // Define POSITION for new 2nd vertex\n  newPosition.set(\n    attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3),\n    vertex2Offset * 3\n  );\n  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n\n  // Use same TEXCOORDS for skirt vertices\n  newTexcoord0.set(\n    attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2),\n    vertex1Offset * 2\n  );\n  newTexcoord0.set(\n    attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2),\n    vertex2Offset * 2\n  );\n\n  // Define new triangles\n  const triangle1Offset = edgeIndex * 2 * 3;\n  newTriangles[triangle1Offset] = edge[0];\n  newTriangles[triangle1Offset + 1] = edge[1];\n  newTriangles[triangle1Offset + 2] = positionsLength / 3 + vertex2Offset;\n\n  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 4] = positionsLength / 3 + vertex1Offset;\n  newTriangles[triangle1Offset + 5] = edge[0];\n}\n"]},"metadata":{},"sourceType":"module"}