{"ast":null,"code":"/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\"); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  const value = obj[key];\n\n  if (value == null) {\n    return undefined;\n  }\n\n  if (typeof value !== \"function\") {\n    throw new TypeError(value + \" is not a function\");\n  }\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  let ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(error) {\n  if (hostReportError.log) {\n    hostReportError.log(error);\n  } else {\n    setTimeout(() => {\n      throw error;\n    }, 0);\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(() => {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  const cleanup = subscription._cleanup;\n\n  if (cleanup === undefined) {\n    return;\n  }\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === \"function\") {\n      cleanup();\n    } else {\n      const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = \"closed\";\n}\n\nfunction flushSubscription(subscription) {\n  const queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = \"ready\";\n\n  for (const item of queue) {\n    notifySubscription(subscription, item.type, item.value);\n\n    if (subscription._state === \"closed\") {\n      break;\n    }\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = \"running\";\n  const observer = subscription._observer;\n\n  try {\n    const m = observer ? getMethod(observer, type) : undefined;\n\n    switch (type) {\n      case \"next\":\n        if (m) m.call(observer, value);\n        break;\n\n      case \"error\":\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case \"complete\":\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === \"closed\") {\n    cleanupSubscription(subscription);\n  } else if (subscription._state === \"running\") {\n    subscription._state = \"ready\";\n  }\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === \"closed\") {\n    return;\n  }\n\n  if (subscription._state === \"buffering\") {\n    subscription._queue = subscription._queue || [];\n\n    subscription._queue.push({\n      type,\n      value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== \"ready\") {\n    subscription._state = \"buffering\";\n    subscription._queue = [{\n      type,\n      value\n    }];\n    enqueue(() => flushSubscription(subscription));\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nexport class Subscription {\n  constructor(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = \"initializing\";\n    const subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === \"initializing\") {\n      this._state = \"ready\";\n    }\n  }\n\n  get closed() {\n    return this._state === \"closed\";\n  }\n\n  unsubscribe() {\n    if (this._state !== \"closed\") {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  }\n\n}\nexport class SubscriptionObserver {\n  constructor(subscription) {\n    this._subscription = subscription;\n  }\n\n  get closed() {\n    return this._subscription._state === \"closed\";\n  }\n\n  next(value) {\n    onNotify(this._subscription, \"next\", value);\n  }\n\n  error(value) {\n    onNotify(this._subscription, \"error\", value);\n  }\n\n  complete() {\n    onNotify(this._subscription, \"complete\");\n  }\n\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\n\nexport class Observable {\n  constructor(subscriber) {\n    if (!(this instanceof Observable)) {\n      throw new TypeError(\"Observable cannot be called as a function\");\n    }\n\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Observable initializer must be a function\");\n    }\n\n    this._subscriber = subscriber;\n  }\n\n  subscribe(nextOrObserver, onError, onComplete) {\n    if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n      nextOrObserver = {\n        next: nextOrObserver,\n        error: onError,\n        complete: onComplete\n      };\n    }\n\n    return new Subscription(nextOrObserver, this._subscriber);\n  }\n\n  pipe(first, ...mappers) {\n    // tslint:disable-next-line no-this-assignment\n    let intermediate = this;\n\n    for (const mapper of [first, ...mappers]) {\n      intermediate = mapper(intermediate);\n    }\n\n    return intermediate;\n  }\n\n  tap(nextOrObserver, onError, onComplete) {\n    const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null ? {\n      next: nextOrObserver,\n      error: onError,\n      complete: onComplete\n    } : nextOrObserver;\n    return new Observable(observer => {\n      return this.subscribe({\n        next(value) {\n          tapObserver.next && tapObserver.next(value);\n          observer.next(value);\n        },\n\n        error(error) {\n          tapObserver.error && tapObserver.error(error);\n          observer.error(error);\n        },\n\n        complete() {\n          tapObserver.complete && tapObserver.complete();\n          observer.complete();\n        },\n\n        start(subscription) {\n          tapObserver.start && tapObserver.start(subscription);\n        }\n\n      });\n    });\n  }\n\n  forEach(fn) {\n    return new Promise((resolve, reject) => {\n      if (typeof fn !== \"function\") {\n        reject(new TypeError(fn + \" is not a function\"));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve(undefined);\n      }\n\n      const subscription = this.subscribe({\n        next(value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n\n        error(error) {\n          reject(error);\n        },\n\n        complete() {\n          resolve(undefined);\n        }\n\n      });\n    });\n  }\n\n  map(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        let propagatedValue = value;\n\n        try {\n          propagatedValue = fn(value);\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(propagatedValue);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  filter(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          if (!fn(value)) return;\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  reduce(fn, seed) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    const hasSeed = arguments.length > 1;\n    let hasValue = false;\n    let acc = seed;\n    return new C(observer => this.subscribe({\n      next(value) {\n        const first = !hasValue;\n        hasValue = true;\n\n        if (!first || hasSeed) {\n          try {\n            acc = fn(acc, value);\n          } catch (e) {\n            return observer.error(e);\n          }\n        } else {\n          acc = value;\n        }\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        if (!hasValue && !hasSeed) {\n          return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n        }\n\n        observer.next(acc);\n        observer.complete();\n      }\n\n    }));\n  }\n\n  concat(...sources) {\n    const C = getSpecies(this);\n    return new C(observer => {\n      let subscription;\n      let index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next(v) {\n            observer.next(v);\n          },\n\n          error(e) {\n            observer.error(e);\n          },\n\n          complete() {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n\n        });\n      }\n\n      startNext(this);\n      return () => {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  }\n\n  flatMap(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    return new C(observer => {\n      const subscriptions = [];\n      const outer = this.subscribe({\n        next(value) {\n          let normalizedValue;\n\n          if (fn) {\n            try {\n              normalizedValue = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            normalizedValue = value;\n          }\n\n          const inner = C.from(normalizedValue).subscribe({\n            next(innerValue) {\n              observer.next(innerValue);\n            },\n\n            error(e) {\n              observer.error(e);\n            },\n\n            complete() {\n              const i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n\n          });\n          subscriptions.push(inner);\n        },\n\n        error(e) {\n          observer.error(e);\n        },\n\n        complete() {\n          completeIfDone();\n        }\n\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) {\n          observer.complete();\n        }\n      }\n\n      return () => {\n        subscriptions.forEach(s => s.unsubscribe());\n        outer.unsubscribe();\n      };\n    });\n  }\n\n  [(Symbol.observable, SymbolObservable)]() {\n    return this;\n  }\n\n  static from(x) {\n    const C = typeof this === \"function\" ? this : Observable;\n\n    if (x == null) {\n      throw new TypeError(x + \" is not an object\");\n    }\n\n    const observableMethod = getMethod(x, SymbolObservable);\n\n    if (observableMethod) {\n      const observable = observableMethod.call(x);\n\n      if (Object(observable) !== observable) {\n        throw new TypeError(observable + \" is not an object\");\n      }\n\n      if (isObservable(observable) && observable.constructor === C) {\n        return observable;\n      }\n\n      return new C(observer => observable.subscribe(observer));\n    }\n\n    if (hasSymbol(\"iterator\")) {\n      const iteratorMethod = getMethod(x, SymbolIterator);\n\n      if (iteratorMethod) {\n        return new C(observer => {\n          enqueue(() => {\n            if (observer.closed) return;\n\n            for (const item of iteratorMethod.call(x)) {\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(observer => {\n        enqueue(() => {\n          if (observer.closed) return;\n\n          for (const item of x) {\n            observer.next(item);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + \" is not observable\");\n  }\n\n  static of(...items) {\n    const C = typeof this === \"function\" ? this : Observable;\n    return new C(observer => {\n      enqueue(() => {\n        if (observer.closed) return;\n\n        for (const item of items) {\n          observer.next(item);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  }\n\n  static get [SymbolSpecies]() {\n    return this;\n  }\n\n}\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol(\"extensions\"), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport default Observable;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/observable-fns/dist.esm/observable.js"],"names":["getSymbol","hasSymbol","hasSymbols","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","obj","key","value","undefined","TypeError","getSpecies","ctor","constructor","Observable","isObservable","x","hostReportError","error","log","setTimeout","enqueue","fn","Promise","resolve","then","e","cleanupSubscription","subscription","cleanup","_cleanup","unsubscribe","call","closeSubscription","_observer","_queue","_state","flushSubscription","queue","item","notifySubscription","type","observer","m","onNotify","push","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","closed","_subscription","next","complete","_subscriber","subscribe","nextOrObserver","onError","onComplete","pipe","first","mappers","intermediate","mapper","tap","tapObserver","start","forEach","reject","done","map","C","propagatedValue","filter","reduce","seed","hasSeed","arguments","length","hasValue","acc","concat","sources","index","startNext","v","from","flatMap","subscriptions","outer","normalizedValue","inner","innerValue","i","indexOf","splice","completeIfDone","s","Symbol","observable","observableMethod","Object","iteratorMethod","Array","isArray","of","items","defineProperty","symbol","configurable"],"mappings":"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","sourcesContent":["/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n    const value = obj[key];\n    if (value == null) {\n        return undefined;\n    }\n    if (typeof value !== \"function\") {\n        throw new TypeError(value + \" is not a function\");\n    }\n    return value;\n}\nfunction getSpecies(obj) {\n    let ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(error) {\n    if (hostReportError.log) {\n        hostReportError.log(error);\n    }\n    else {\n        setTimeout(() => { throw error; }, 0);\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(() => {\n        try {\n            fn();\n        }\n        catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    const cleanup = subscription._cleanup;\n    if (cleanup === undefined) {\n        return;\n    }\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        }\n        else {\n            const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    const queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for (const item of queue) {\n        notifySubscription(subscription, item.type, item.value);\n        if (subscription._state === \"closed\") {\n            break;\n        }\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    const observer = subscription._observer;\n    try {\n        const m = observer ? getMethod(observer, type) : undefined;\n        switch (type) {\n            case \"next\":\n                if (m)\n                    m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer, value);\n                else\n                    throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer);\n                break;\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") {\n        cleanupSubscription(subscription);\n    }\n    else if (subscription._state === \"running\") {\n        subscription._state = \"ready\";\n    }\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") {\n        return;\n    }\n    if (subscription._state === \"buffering\") {\n        subscription._queue = subscription._queue || [];\n        subscription._queue.push({ type, value });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [{ type, value }];\n        enqueue(() => flushSubscription(subscription));\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nexport class Subscription {\n    constructor(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        const subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        }\n        catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") {\n            this._state = \"ready\";\n        }\n    }\n    get closed() {\n        return this._state === \"closed\";\n    }\n    unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    }\n}\nexport class SubscriptionObserver {\n    constructor(subscription) { this._subscription = subscription; }\n    get closed() { return this._subscription._state === \"closed\"; }\n    next(value) { onNotify(this._subscription, \"next\", value); }\n    error(value) { onNotify(this._subscription, \"error\", value); }\n    complete() { onNotify(this._subscription, \"complete\"); }\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nexport class Observable {\n    constructor(subscriber) {\n        if (!(this instanceof Observable)) {\n            throw new TypeError(\"Observable cannot be called as a function\");\n        }\n        if (typeof subscriber !== \"function\") {\n            throw new TypeError(\"Observable initializer must be a function\");\n        }\n        this._subscriber = subscriber;\n    }\n    subscribe(nextOrObserver, onError, onComplete) {\n        if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n            nextOrObserver = {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            };\n        }\n        return new Subscription(nextOrObserver, this._subscriber);\n    }\n    pipe(first, ...mappers) {\n        // tslint:disable-next-line no-this-assignment\n        let intermediate = this;\n        for (const mapper of [first, ...mappers]) {\n            intermediate = mapper(intermediate);\n        }\n        return intermediate;\n    }\n    tap(nextOrObserver, onError, onComplete) {\n        const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null\n            ? {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            }\n            : nextOrObserver;\n        return new Observable(observer => {\n            return this.subscribe({\n                next(value) {\n                    tapObserver.next && tapObserver.next(value);\n                    observer.next(value);\n                },\n                error(error) {\n                    tapObserver.error && tapObserver.error(error);\n                    observer.error(error);\n                },\n                complete() {\n                    tapObserver.complete && tapObserver.complete();\n                    observer.complete();\n                },\n                start(subscription) {\n                    tapObserver.start && tapObserver.start(subscription);\n                }\n            });\n        });\n    }\n    forEach(fn) {\n        return new Promise((resolve, reject) => {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve(undefined);\n            }\n            const subscription = this.subscribe({\n                next(value) {\n                    try {\n                        fn(value, done);\n                    }\n                    catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error(error) {\n                    reject(error);\n                },\n                complete() {\n                    resolve(undefined);\n                }\n            });\n        });\n    }\n    map(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                let propagatedValue = value;\n                try {\n                    propagatedValue = fn(value);\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(propagatedValue);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    filter(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                try {\n                    if (!fn(value))\n                        return;\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(value);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    reduce(fn, seed) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        const hasSeed = arguments.length > 1;\n        let hasValue = false;\n        let acc = seed;\n        return new C(observer => this.subscribe({\n            next(value) {\n                const first = !hasValue;\n                hasValue = true;\n                if (!first || hasSeed) {\n                    try {\n                        acc = fn(acc, value);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                }\n                else {\n                    acc = value;\n                }\n            },\n            error(e) { observer.error(e); },\n            complete() {\n                if (!hasValue && !hasSeed) {\n                    return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                }\n                observer.next(acc);\n                observer.complete();\n            },\n        }));\n    }\n    concat(...sources) {\n        const C = getSpecies(this);\n        return new C(observer => {\n            let subscription;\n            let index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next(v) { observer.next(v); },\n                    error(e) { observer.error(e); },\n                    complete() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        }\n                        else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    },\n                });\n            }\n            startNext(this);\n            return () => {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    }\n    flatMap(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => {\n            const subscriptions = [];\n            const outer = this.subscribe({\n                next(value) {\n                    let normalizedValue;\n                    if (fn) {\n                        try {\n                            normalizedValue = fn(value);\n                        }\n                        catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    else {\n                        normalizedValue = value;\n                    }\n                    const inner = C.from(normalizedValue).subscribe({\n                        next(innerValue) { observer.next(innerValue); },\n                        error(e) { observer.error(e); },\n                        complete() {\n                            const i = subscriptions.indexOf(inner);\n                            if (i >= 0)\n                                subscriptions.splice(i, 1);\n                            completeIfDone();\n                        },\n                    });\n                    subscriptions.push(inner);\n                },\n                error(e) { observer.error(e); },\n                complete() { completeIfDone(); },\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) {\n                    observer.complete();\n                }\n            }\n            return () => {\n                subscriptions.forEach(s => s.unsubscribe());\n                outer.unsubscribe();\n            };\n        });\n    }\n    [(Symbol.observable, SymbolObservable)]() { return this; }\n    static from(x) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        if (x == null) {\n            throw new TypeError(x + \" is not an object\");\n        }\n        const observableMethod = getMethod(x, SymbolObservable);\n        if (observableMethod) {\n            const observable = observableMethod.call(x);\n            if (Object(observable) !== observable) {\n                throw new TypeError(observable + \" is not an object\");\n            }\n            if (isObservable(observable) && observable.constructor === C) {\n                return observable;\n            }\n            return new C(observer => observable.subscribe(observer));\n        }\n        if (hasSymbol(\"iterator\")) {\n            const iteratorMethod = getMethod(x, SymbolIterator);\n            if (iteratorMethod) {\n                return new C(observer => {\n                    enqueue(() => {\n                        if (observer.closed)\n                            return;\n                        for (const item of iteratorMethod.call(x)) {\n                            observer.next(item);\n                            if (observer.closed)\n                                return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(observer => {\n                enqueue(() => {\n                    if (observer.closed)\n                        return;\n                    for (const item of x) {\n                        observer.next(item);\n                        if (observer.closed)\n                            return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    }\n    static of(...items) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        return new C(observer => {\n            enqueue(() => {\n                if (observer.closed)\n                    return;\n                for (const item of items) {\n                    observer.next(item);\n                    if (observer.closed)\n                        return;\n                }\n                observer.complete();\n            });\n        });\n    }\n    static get [SymbolSpecies]() { return this; }\n}\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError,\n        },\n        configurable: true,\n    });\n}\nexport default Observable;\n"]},"metadata":{},"sourceType":"module"}