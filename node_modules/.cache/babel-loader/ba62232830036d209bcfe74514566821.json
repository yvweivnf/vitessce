{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\n\nexport function pointOrRangePosition(channel, model, _ref) {\n  var defaultPos = _ref.defaultPos,\n      defaultPos2 = _ref.defaultPos2,\n      range = _ref.range;\n\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos: defaultPos,\n      defaultPos2: defaultPos2\n    });\n  }\n\n  return pointPosition(channel, model, {\n    defaultPos: defaultPos\n  });\n}\nexport function rangePosition(channel, model, _ref2) {\n  var defaultPos = _ref2.defaultPos,\n      defaultPos2 = _ref2.defaultPos2;\n  var markDef = model.markDef,\n      config = model.config;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var sizeChannel = getSizeChannel(channel);\n  var pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n  var vgChannel = pos2Mixins[sizeChannel] ? // If there is width/height, we need to position the marks based on the alignment.\n  vgAlignedPositionChannel(channel, markDef, config) : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n  getVgPositionChannel(channel);\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos: defaultPos,\n    vgChannel: vgChannel\n  })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\n\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n  var _position2orSize;\n\n  var encoding = model.encoding,\n      mark = model.mark,\n      markDef = model.markDef,\n      stack = model.stack,\n      config = model.config;\n  var baseChannel = getMainRangeChannel(channel);\n  var sizeChannel = getSizeChannel(channel);\n  var vgChannel = getVgPositionChannel(channel);\n  var channelDef = encoding[baseChannel];\n  var scaleName = model.scaleName(baseChannel);\n  var scale = model.getScaleComponent(baseChannel);\n  var offset = channel in encoding || channel in markDef ? getOffset(channel, model.markDef) : getOffset(baseChannel, model.markDef);\n\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    var vgSizeChannel = getSizeChannel(channel);\n    var size = model.markDef[vgSizeChannel];\n\n    if (size != null) {\n      return _defineProperty({}, vgSizeChannel, {\n        value: size\n      });\n    } else {\n      return _defineProperty({}, vgChannel, {\n        field: model.getName(channel)\n      });\n    }\n  }\n\n  var valueRef = position2Ref({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: encoding[channel],\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return _defineProperty({}, vgChannel, valueRef);\n  } // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n\n  return position2orSize(channel, markDef) || position2orSize(channel, (_position2orSize = {}, _defineProperty(_position2orSize, channel, getMarkStyleConfig(channel, markDef, config.style)), _defineProperty(_position2orSize, sizeChannel, getMarkStyleConfig(sizeChannel, markDef, config.style)), _position2orSize)) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || _defineProperty({}, vgChannel, pointPositionDefaultRef({\n    model: model,\n    defaultPos: defaultPos,\n    channel: channel,\n    scaleName: scaleName,\n    scale: scale\n  })());\n}\n\nexport function position2Ref(_ref7) {\n  var channel = _ref7.channel,\n      channelDef = _ref7.channelDef,\n      channel2Def = _ref7.channel2Def,\n      markDef = _ref7.markDef,\n      config = _ref7.config,\n      scaleName = _ref7.scaleName,\n      scale = _ref7.scale,\n      stack = _ref7.stack,\n      offset = _ref7.offset,\n      defaultRef = _ref7.defaultRef;\n\n  if (isFieldOrDatumDef(channelDef) && stack && // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset: offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest({\n    channel: channel,\n    channelDef: channel2Def,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    markDef: markDef,\n    config: config,\n    offset: offset,\n    defaultRef: defaultRef\n  });\n}\n\nfunction position2orSize(channel, markDef) {\n  var sizeChannel = getSizeChannel(channel);\n  var vgChannel = getVgPositionChannel(channel);\n\n  if (markDef[vgChannel] !== undefined) {\n    return _defineProperty({}, vgChannel, ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel]));\n  } else if (markDef[channel] !== undefined) {\n    return _defineProperty({}, vgChannel, ref.widthHeightValueOrSignalRef(channel, markDef[channel]));\n  } else if (markDef[sizeChannel]) {\n    var dimensionSize = markDef[sizeChannel];\n\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return _defineProperty({}, sizeChannel, ref.widthHeightValueOrSignalRef(channel, dimensionSize));\n    }\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-range.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range }) {\n    if (range) {\n        return rangePosition(channel, model, { defaultPos, defaultPos2 });\n    }\n    return pointPosition(channel, model, { defaultPos });\n}\nexport function rangePosition(channel, model, { defaultPos, defaultPos2 }) {\n    const { markDef, config } = model;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n    const vgChannel = pos2Mixins[sizeChannel]\n        ? // If there is width/height, we need to position the marks based on the alignment.\n            vgAlignedPositionChannel(channel, markDef, config)\n        : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n            getVgPositionChannel(channel);\n    return Object.assign(Object.assign({}, pointPosition(channel, model, { defaultPos, vgChannel })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n    const { encoding, mark, markDef, stack, config } = model;\n    const baseChannel = getMainRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const channelDef = encoding[baseChannel];\n    const scaleName = model.scaleName(baseChannel);\n    const scale = model.getScaleComponent(baseChannel);\n    const offset = channel in encoding || channel in markDef\n        ? getOffset(channel, model.markDef)\n        : getOffset(baseChannel, model.markDef);\n    if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n        const vgSizeChannel = getSizeChannel(channel);\n        const size = model.markDef[vgSizeChannel];\n        if (size != null) {\n            return {\n                [vgSizeChannel]: { value: size }\n            };\n        }\n        else {\n            return {\n                [vgChannel]: { field: model.getName(channel) }\n            };\n        }\n    }\n    const valueRef = position2Ref({\n        channel,\n        channelDef,\n        channel2Def: encoding[channel],\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: undefined\n    });\n    if (valueRef !== undefined) {\n        return { [vgChannel]: valueRef };\n    }\n    // TODO: check width/height encoding here once we add them\n    // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n    // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n    return (position2orSize(channel, markDef) ||\n        position2orSize(channel, {\n            [channel]: getMarkStyleConfig(channel, markDef, config.style),\n            [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n        }) ||\n        position2orSize(channel, config[mark]) ||\n        position2orSize(channel, config.mark) || {\n        [vgChannel]: pointPositionDefaultRef({\n            model,\n            defaultPos,\n            channel,\n            scaleName,\n            scale\n        })()\n    });\n}\nexport function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack, offset, defaultRef }) {\n    if (isFieldOrDatumDef(channelDef) &&\n        stack &&\n        // If fieldChannel is X and channel is X2 (or Y and Y2)\n        channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n        return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: 'start' }, { offset });\n    }\n    return ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: channel2Def,\n        scaleName,\n        scale,\n        stack,\n        markDef,\n        config,\n        offset,\n        defaultRef\n    });\n}\nfunction position2orSize(channel, markDef) {\n    const sizeChannel = getSizeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    if (markDef[vgChannel] !== undefined) {\n        return { [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };\n    }\n    else if (markDef[channel] !== undefined) {\n        return { [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel]) };\n    }\n    else if (markDef[sizeChannel]) {\n        const dimensionSize = markDef[sizeChannel];\n        if (isRelativeBandSize(dimensionSize)) {\n            log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n        }\n        else {\n            return { [sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize) };\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=position-range.js.map"]},"metadata":{},"sourceType":"module"}