{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nvar point = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'point';\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var _a;\n\n    var name = selCmpt.name;\n    var fieldsSg = name + TUPLE_FIELDS;\n    var project = selCmpt.project;\n    var datum = '(item().isVoronoi ? datum.datum : datum)';\n    var values = project.items.map(function (p) {\n      var fieldDef = model.fieldDef(p.channel); // Binned fields should capture extents, for a range test against the raw field.\n\n      return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) ? \"[\".concat(datum, \"[\").concat(stringValue(model.vgField(p.channel, {})), \"], \") + \"\".concat(datum, \"[\").concat(stringValue(model.vgField(p.channel, {\n        binSuffix: 'end'\n      })), \"]]\") : \"\".concat(datum, \"[\").concat(stringValue(p.field), \"]\");\n    }).join(', '); // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n\n    var update = \"unit: \".concat(unitName(model), \", fields: \").concat(fieldsSg, \", values\");\n    var events = selCmpt.events;\n    var brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, cmpt) {\n      return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n    }, []).map(function (b) {\n      return \"indexof(item().mark.name, '\".concat(b, \"') < 0\");\n    }).join(' && ');\n    var test = \"datum && item().mark.marktype !== 'group'\" + (brushes ? \" && \".concat(brushes) : '');\n    return _signals.concat([{\n      name: name + TUPLE,\n      on: events ? [{\n        events: events,\n        update: \"\".concat(test, \" ? {\").concat(update, \": [\").concat(values, \"]} : null\"),\n        force: true\n      }] : []\n    }]);\n  }\n};\nexport default point;","map":{"version":3,"sources":["../../../../src/compile/selection/point.ts"],"names":[],"mappings":"AACA,SAAQ,WAAR,QAA0B,WAA1B;AACA,SAA2B,KAA3B,EAAkC,QAAlC,QAAiD,GAAjD;AACA,SAAQ,IAAR,QAAmB,YAAnB;AACA,SAAQ,KAAR,QAAoB,YAApB;AACA,SAAQ,YAAR,QAA2B,WAA3B;AAEA,IAAM,KAAK,GAA+B;AACxC,EAAA,OAAO,EAAE,iBAAA,OAAO;AAAA,WAAI,OAAO,CAAC,IAAR,KAAiB,OAArB;AAAA,GADwB;AAGxC,EAAA,OAAO,EAAE,iBAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA4B;;;AACnC,QAAM,IAAI,GAAG,OAAO,CAAC,IAArB;AACA,QAAM,QAAQ,GAAG,IAAI,GAAG,YAAxB;AACA,QAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;AACA,QAAM,KAAK,GAAG,0CAAd;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,KAAR,CACZ,GADY,CACR,UAAA,CAAC,EAAG;AACP,UAAM,QAAQ,GAAG,KAAK,CAAC,QAAN,CAAe,CAAC,CAAC,OAAjB,CAAjB,CADO,CAEP;;AACA,aAAO,CAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,GAAV,IACH,WAAI,KAAJ,cAAa,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB,EAAzB,CAAD,CAAxB,qBACK,KADL,cACc,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB;AAAC,QAAA,SAAS,EAAE;AAAZ,OAAzB,CAAD,CADzB,OADG,aAGA,KAHA,cAGS,WAAW,CAAC,CAAC,CAAC,KAAH,CAHpB,MAAP;AAID,KARY,EASZ,IATY,CASP,IATO,CAAf,CALmC,CAgBnC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAM,MAAM,mBAAY,QAAQ,CAAC,KAAD,CAApB,uBAAwC,QAAxC,aAAZ;AAEA,QAAM,MAAM,GAAa,OAAO,CAAC,MAAjC;AAEA,QAAM,OAAO,GAAG,IAAI,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,SAAN,CAAgB,SAAhB,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,EAAzB,GAA6B,EAA9B,CAAJ,CACb,MADa,CACN,UAAC,GAAD,EAAM,IAAN,EAAc;AACpB,aAAO,IAAI,CAAC,IAAL,KAAc,UAAd,GAA2B,GAAG,CAAC,MAAJ,CAAW,IAAI,CAAC,IAAL,GAAY,KAAvB,CAA3B,GAA2D,GAAlE;AACD,KAHa,EAGX,EAHW,EAIb,GAJa,CAIT,UAAA,CAAC;AAAA,kDAAkC,CAAlC;AAAA,KAJQ,EAKb,IALa,CAKR,MALQ,CAAhB;AAOA,QAAM,IAAI,GAAG,+CAA+C,OAAO,iBAAU,OAAV,IAAsB,EAA5E,CAAb;AAEA,WAAO,QAAO,CAAC,MAAR,CAAe,CACpB;AACE,MAAA,IAAI,EAAE,IAAI,GAAG,KADf;AAEE,MAAA,EAAE,EAAE,MAAM,GACN,CACE;AACE,QAAA,MAAM,EAAN,MADF;AAEE,QAAA,MAAM,YAAK,IAAL,iBAAgB,MAAhB,gBAA4B,MAA5B,cAFR;AAGE,QAAA,KAAK,EAAE;AAHT,OADF,CADM,GAQN;AAVN,KADoB,CAAf,CAAP;AAcD;AArDuC,CAA1C;AAwDA,eAAe,KAAf","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nconst point = {\n    defined: selCmpt => selCmpt.type === 'point',\n    signals: (model, selCmpt, signals) => {\n        var _a;\n        const name = selCmpt.name;\n        const fieldsSg = name + TUPLE_FIELDS;\n        const project = selCmpt.project;\n        const datum = '(item().isVoronoi ? datum.datum : datum)';\n        const values = project.items\n            .map(p => {\n            const fieldDef = model.fieldDef(p.channel);\n            // Binned fields should capture extents, for a range test against the raw field.\n            return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin)\n                ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n                    `${datum}[${stringValue(model.vgField(p.channel, { binSuffix: 'end' }))}]]`\n                : `${datum}[${stringValue(p.field)}]`;\n        })\n            .join(', ');\n        // Only add a discrete selection to the store if a datum is present _and_\n        // the interaction isn't occurring on a group mark. This guards against\n        // polluting interactive state with invalid values in faceted displays\n        // as the group marks are also data-driven. We force the update to account\n        // for constant null states but varying toggles (e.g., shift-click in\n        // whitespace followed by a click in whitespace; the store should only\n        // be cleared on the second click).\n        const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n        const events = selCmpt.events;\n        const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})\n            .reduce((acc, cmpt) => {\n            return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n        }, [])\n            .map(b => `indexof(item().mark.name, '${b}') < 0`)\n            .join(' && ');\n        const test = `datum && item().mark.marktype !== 'group'` + (brushes ? ` && ${brushes}` : '');\n        return signals.concat([\n            {\n                name: name + TUPLE,\n                on: events\n                    ? [\n                        {\n                            events,\n                            update: `${test} ? {${update}: [${values}]} : null`,\n                            force: true\n                        }\n                    ]\n                    : []\n            }\n        ]);\n    }\n};\nexport default point;\n//# sourceMappingURL=point.js.map"]},"metadata":{},"sourceType":"module"}