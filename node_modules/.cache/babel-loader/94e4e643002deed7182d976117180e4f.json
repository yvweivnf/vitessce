{"ast":null,"code":"/* eslint-disable no-control-regex */\nimport { InternMap } from 'internmap';\nimport { treeInitialize, nodeAppendChild, initializeCellSetColor } from '../../components/sets/cell-set-utils';\nimport { SETS_DATATYPE_CELL } from '../../components/sets/constants';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\nimport LoaderResult from '../LoaderResult';\nexport function dataToCellSetsTree(data, options) {\n  const [cellNames, cellSets, cellSetScores] = data;\n  const cellSetsTree = treeInitialize(SETS_DATATYPE_CELL);\n  cellSets.forEach((cellSetIds, j) => {\n    const name = options[j].groupName;\n    let levelZeroNode = {\n      name,\n      children: []\n    };\n\n    if (cellSetIds.length > 0 && Array.isArray(cellSetIds[0])) {\n      // Multi-level case.\n      const levelSets = new InternMap([], JSON.stringify);\n      cellNames.forEach((id, i) => {\n        const classes = cellSetIds.map(col => col[i]);\n\n        if (levelSets.has(classes)) {\n          levelSets.get(classes).push([id, null]);\n        } else {\n          levelSets.set(classes, [[id, null]]);\n        }\n      });\n      const levels = Array.from(levelSets.keys());\n\n      const getNextLevelNames = levelSuffixes => {\n        const nextLevelNames = Array.from(new Set(levelSuffixes.map(l => l[0])));\n        return nextLevelNames.sort((a, b) => a.localeCompare(b));\n      }; // Recursive function to create nodes.\n\n\n      const getNode = (parentLevelPrefixes, currLevelName, childLevelSuffixes) => {\n        const isLeaf = childLevelSuffixes.length === 0;\n        const resultNode = {\n          name: currLevelName\n        };\n\n        if (isLeaf) {\n          // Base case: this is a leaf node.\n          resultNode.set = levelSets.get([...parentLevelPrefixes, currLevelName]);\n        } else {\n          // Are the remaining suffices redundant?\n          // Consider [\"Parent\", \"Child\", \"Child\"]\n          // where parentLevelPrefixes is [\"Parent\"] and currLevelName is \"Child\".\n          const shouldBeLeaf = childLevelSuffixes.length === 1 && currLevelName === childLevelSuffixes[0][childLevelSuffixes[0].length - 1];\n\n          if (shouldBeLeaf) {\n            resultNode.set = levelSets.get([...parentLevelPrefixes, currLevelName, ...childLevelSuffixes[0]]);\n          } else {\n            // Recursion, run getNode() on each of the unique names at the next level.\n            const nextLevelNames = getNextLevelNames(childLevelSuffixes);\n            resultNode.children = nextLevelNames.map(nextLevelName => getNode([...parentLevelPrefixes, currLevelName], nextLevelName, childLevelSuffixes.filter(l => l[0] === nextLevelName).map(l => l.slice(1)).filter(v => v.length > 0)));\n          }\n        }\n\n        return resultNode;\n      }; // Start the recursion.\n\n\n      const levelOneNodes = getNextLevelNames(levels).map(levelOneName => getNode([], levelOneName, levels.filter(l => l[0] === levelOneName).map(l => l.slice(1))));\n      levelZeroNode.children = levelOneNodes;\n    } else {\n      // Single-level case.\n      // Check for the optional corresponding confidence score column name.\n      const uniqueCellSetIds = Array.from(new Set(cellSetIds)).sort();\n      const clusters = {}; // eslint-disable-next-line no-return-assign\n\n      uniqueCellSetIds.forEach(id => clusters[id] = {\n        name: id,\n        set: []\n      });\n\n      if (cellSetScores[j]) {\n        cellSetIds.forEach((id, i) => clusters[id].set.push([cellNames[i], cellSetScores[j][i]]));\n      } else {\n        cellSetIds.forEach((id, i) => clusters[id].set.push([cellNames[i], null]));\n      }\n\n      Object.values(clusters).forEach( // eslint-disable-next-line no-return-assign\n      cluster => levelZeroNode = nodeAppendChild(levelZeroNode, cluster));\n    }\n\n    cellSetsTree.tree.push(levelZeroNode);\n  });\n  return cellSetsTree;\n}\n/**\n * Loader for converting zarr into the cell sets json schema.\n */\n\nexport default class CellSetsZarrLoader extends AbstractTwoStepLoader {\n  loadCellSetIds() {\n    const {\n      options\n    } = this;\n    const cellSetZarrLocation = options.map(({\n      setName\n    }) => setName);\n    return this.dataSource.loadObsColumns(cellSetZarrLocation);\n  }\n\n  loadCellSetScores() {\n    const {\n      options\n    } = this;\n    const cellSetScoreZarrLocation = options.map(option => option.scoreName || undefined);\n    return this.dataSource.loadObsColumns(cellSetScoreZarrLocation);\n  }\n\n  async load() {\n    if (!this.cellSetsTree) {\n      const {\n        options\n      } = this;\n      this.cellSetsTree = Promise.all([this.dataSource.loadObsIndex(), this.loadCellSetIds(), this.loadCellSetScores()]).then(data => dataToCellSetsTree(data, options));\n    }\n\n    const cellSetsTree = await this.cellSetsTree;\n    const coordinationValues = {};\n    const {\n      tree\n    } = cellSetsTree;\n    const newAutoSetSelectionParentName = tree[0].name; // Create a list of set paths to initally select.\n\n    const newAutoSetSelections = tree[0].children.map(node => [newAutoSetSelectionParentName, node.name]); // Create a list of cell set objects with color mappings.\n\n    const newAutoSetColors = initializeCellSetColor(cellSetsTree, []);\n    coordinationValues.obsSetSelection = newAutoSetSelections;\n    coordinationValues.obsSetColor = newAutoSetColors;\n    return Promise.resolve(new LoaderResult(cellSetsTree, null, coordinationValues));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/anndata-loaders/CellSetsZarrLoader.js"],"names":["InternMap","treeInitialize","nodeAppendChild","initializeCellSetColor","SETS_DATATYPE_CELL","AbstractTwoStepLoader","LoaderResult","dataToCellSetsTree","data","options","cellNames","cellSets","cellSetScores","cellSetsTree","forEach","cellSetIds","j","name","groupName","levelZeroNode","children","length","Array","isArray","levelSets","JSON","stringify","id","i","classes","map","col","has","get","push","set","levels","from","keys","getNextLevelNames","levelSuffixes","nextLevelNames","Set","l","sort","a","b","localeCompare","getNode","parentLevelPrefixes","currLevelName","childLevelSuffixes","isLeaf","resultNode","shouldBeLeaf","nextLevelName","filter","slice","v","levelOneNodes","levelOneName","uniqueCellSetIds","clusters","Object","values","cluster","tree","CellSetsZarrLoader","loadCellSetIds","cellSetZarrLocation","setName","dataSource","loadObsColumns","loadCellSetScores","cellSetScoreZarrLocation","option","scoreName","undefined","load","Promise","all","loadObsIndex","then","coordinationValues","newAutoSetSelectionParentName","newAutoSetSelections","node","newAutoSetColors","obsSetSelection","obsSetColor","resolve"],"mappings":"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","sourcesContent":["/* eslint-disable no-control-regex */\nimport { InternMap } from 'internmap';\nimport {\n  treeInitialize,\n  nodeAppendChild,\n  initializeCellSetColor,\n} from '../../components/sets/cell-set-utils';\nimport {\n  SETS_DATATYPE_CELL,\n} from '../../components/sets/constants';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\nimport LoaderResult from '../LoaderResult';\n\nexport function dataToCellSetsTree(data, options) {\n  const [cellNames, cellSets, cellSetScores] = data;\n  const cellSetsTree = treeInitialize(SETS_DATATYPE_CELL);\n  cellSets.forEach((cellSetIds, j) => {\n    const name = options[j].groupName;\n    let levelZeroNode = {\n      name,\n      children: [],\n    };\n    if (cellSetIds.length > 0 && Array.isArray(cellSetIds[0])) {\n      // Multi-level case.\n      const levelSets = new InternMap([], JSON.stringify);\n\n      cellNames.forEach((id, i) => {\n        const classes = cellSetIds.map(col => col[i]);\n        if (levelSets.has(classes)) {\n          levelSets.get(classes).push([id, null]);\n        } else {\n          levelSets.set(classes, [[id, null]]);\n        }\n      });\n\n      const levels = Array.from(levelSets.keys());\n\n      const getNextLevelNames = (levelSuffixes) => {\n        const nextLevelNames = Array.from(new Set(levelSuffixes.map(l => l[0])));\n        return nextLevelNames.sort((a, b) => a.localeCompare(b));\n      };\n\n      // Recursive function to create nodes.\n      const getNode = (parentLevelPrefixes, currLevelName, childLevelSuffixes) => {\n        const isLeaf = childLevelSuffixes.length === 0;\n        const resultNode = {\n          name: currLevelName,\n        };\n        if (isLeaf) {\n          // Base case: this is a leaf node.\n          resultNode.set = levelSets.get([...parentLevelPrefixes, currLevelName]);\n        } else {\n          // Are the remaining suffices redundant?\n          // Consider [\"Parent\", \"Child\", \"Child\"]\n          // where parentLevelPrefixes is [\"Parent\"] and currLevelName is \"Child\".\n          const shouldBeLeaf = (\n            childLevelSuffixes.length === 1\n            && currLevelName === childLevelSuffixes[0][childLevelSuffixes[0].length - 1]\n          );\n          if (shouldBeLeaf) {\n            resultNode.set = levelSets.get(\n              [...parentLevelPrefixes, currLevelName, ...childLevelSuffixes[0]],\n            );\n          } else {\n            // Recursion, run getNode() on each of the unique names at the next level.\n            const nextLevelNames = getNextLevelNames(childLevelSuffixes);\n\n            resultNode.children = nextLevelNames\n              .map(nextLevelName => getNode(\n                [...parentLevelPrefixes, currLevelName],\n                nextLevelName,\n                childLevelSuffixes\n                  .filter(l => l[0] === nextLevelName)\n                  .map(l => l.slice(1))\n                  .filter(v => v.length > 0),\n              ));\n          }\n        }\n        return resultNode;\n      };\n      // Start the recursion.\n      const levelOneNodes = getNextLevelNames(levels)\n        .map(levelOneName => getNode(\n          [],\n          levelOneName,\n          levels.filter(l => l[0] === levelOneName).map(l => l.slice(1)),\n        ));\n\n      levelZeroNode.children = levelOneNodes;\n    } else {\n      // Single-level case.\n      // Check for the optional corresponding confidence score column name.\n      const uniqueCellSetIds = Array.from(new Set(cellSetIds)).sort();\n      const clusters = {};\n      // eslint-disable-next-line no-return-assign\n      uniqueCellSetIds.forEach(id => (clusters[id] = { name: id, set: [] }));\n      if (cellSetScores[j]) {\n        cellSetIds.forEach((id, i) => clusters[id].set.push([cellNames[i], cellSetScores[j][i]]));\n      } else {\n        cellSetIds.forEach((id, i) => clusters[id].set.push([cellNames[i], null]));\n      }\n      Object.values(clusters).forEach(\n        // eslint-disable-next-line no-return-assign\n        cluster => (levelZeroNode = nodeAppendChild(levelZeroNode, cluster)),\n      );\n    }\n    cellSetsTree.tree.push(levelZeroNode);\n  });\n  return cellSetsTree;\n}\n\n/**\n * Loader for converting zarr into the cell sets json schema.\n */\nexport default class CellSetsZarrLoader extends AbstractTwoStepLoader {\n  loadCellSetIds() {\n    const { options } = this;\n    const cellSetZarrLocation = options.map(({ setName }) => setName);\n    return this.dataSource.loadObsColumns(cellSetZarrLocation);\n  }\n\n  loadCellSetScores() {\n    const { options } = this;\n    const cellSetScoreZarrLocation = options.map(option => option.scoreName || undefined);\n    return this.dataSource.loadObsColumns(cellSetScoreZarrLocation);\n  }\n\n  async load() {\n    if (!this.cellSetsTree) {\n      const { options } = this;\n      this.cellSetsTree = Promise.all([\n        this.dataSource.loadObsIndex(),\n        this.loadCellSetIds(),\n        this.loadCellSetScores(),\n      ]).then(data => dataToCellSetsTree(data, options));\n    }\n    const cellSetsTree = await this.cellSetsTree;\n    const coordinationValues = {};\n    const { tree } = cellSetsTree;\n    const newAutoSetSelectionParentName = tree[0].name;\n    // Create a list of set paths to initally select.\n    const newAutoSetSelections = tree[0].children.map(node => [\n      newAutoSetSelectionParentName,\n      node.name,\n    ]);\n    // Create a list of cell set objects with color mappings.\n    const newAutoSetColors = initializeCellSetColor(cellSetsTree, []);\n    coordinationValues.obsSetSelection = newAutoSetSelections;\n    coordinationValues.obsSetColor = newAutoSetColors;\n    return Promise.resolve(\n      new LoaderResult(cellSetsTree, null, coordinationValues),\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}