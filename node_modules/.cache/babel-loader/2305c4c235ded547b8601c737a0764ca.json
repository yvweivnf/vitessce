{"ast":null,"code":"import GLTFScenegraph from '../api/gltf-scenegraph';\nimport { isMeshoptSupported, meshoptDecodeGltfBuffer } from '../../meshopt/meshopt-decoder';\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const name = EXT_MESHOPT_COMPRESSION;\nexport function preprocess(gltfData) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) && !isMeshoptSupported()) {\n    throw new Error(\"gltf: Required extension \".concat(EXT_MESHOPT_COMPRESSION, \" not supported by browser\"));\n  }\n}\nexport async function decode(gltfData, options) {\n  var _options$gltf;\n\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n\n  const promises = [];\n\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  await Promise.all(promises);\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\nasync function decodeMeshoptBufferView(scenegraph, bufferView) {\n  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n\n  if (meshoptExtension) {\n    const buffer = bufferView.buffer;\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/EXT_meshopt_compression.ts"],"names":["DEFAULT_MESHOPT_OPTIONS","byteOffset","filter","EXT_MESHOPT_COMPRESSION","name","scenegraph","isMeshoptSupported","options","promises","gltfData","decodeMeshoptBufferView","Promise","meshoptExtension","buffer","bufferView","byteLength","source","result","count","meshoptDecodeGltfBuffer"],"mappings":"AAGA,OAAA,cAAA,MAAA,wBAAA;AACA,SAAA,kBAAA,EAAA,uBAAA,QAAA,+BAAA;AAIA,MAAMA,uBAAuB,GAAG;AAC9BC,EAAAA,UAAU,EADoB,CAAA;AAE9BC,EAAAA,MAAM,EAAE;AAFsB,CAAhC;AAMA,MAAMC,uBAAuB,GAA7B,yBAAA;AAEA,OAAO,MAAMC,IAAI,GAAV,uBAAA;AAEP,OAAO,SAAA,UAAA,CAAA,QAAA,EAA4C;AACjD,QAAMC,UAAU,GAAG,IAAA,cAAA,CAAnB,QAAmB,CAAnB;;AACA,MACEA,UAAU,CAAVA,qBAAAA,GAAAA,QAAAA,CAAAA,uBAAAA,KACA,CAACC,kBAFH,EAAA,EAGE;AACA,UAAM,IAAA,KAAA,CAAA,4BAAA,MAAA,CAAA,uBAAA,EAAN,2BAAM,CAAA,CAAN;AACD;AACF;AAED,OAAO,eAAA,MAAA,CAAA,QAAA,EAAA,OAAA,EAA0E;AAAA,MAAA,aAAA;;AAC/E,QAAMD,UAAU,GAAG,IAAA,cAAA,CAAnB,QAAmB,CAAnB;;AAEA,MAAI,EAACE,OAAD,KAAA,IAACA,IAAAA,OAAD,KAAA,KAAA,CAACA,IAAD,CAAA,aAAA,GAACA,OAAO,CAAR,IAAA,MAAA,IAACA,IAAD,aAAA,KAAA,KAAA,CAACA,IAAAA,aAAAA,CAAL,gBAAI,CAAJ,EAAsC;AACpC;AACD;;AAED,QAAMC,QAAwB,GAA9B,EAAA;;AACA,OAAK,MAAL,eAAA,IAA8BC,QAAQ,CAARA,IAAAA,CAAAA,WAAAA,IAA9B,EAAA,EAA+D;AAC7DD,IAAAA,QAAQ,CAARA,IAAAA,CAAcE,uBAAuB,CAAA,UAAA,EAArCF,eAAqC,CAArCA;AACD;;AAGD,QAAMG,OAAO,CAAPA,GAAAA,CAAN,QAAMA,CAAN;AAGAN,EAAAA,UAAU,CAAVA,eAAAA,CAAAA,uBAAAA;AACD;;AAGD,eAAA,uBAAA,CAAA,UAAA,EAAA,UAAA,EAG+B;AAC7B,QAAMO,gBAAgB,GAAGP,UAAU,CAAVA,kBAAAA,CAAAA,UAAAA,EAAzB,uBAAyBA,CAAzB;;AAIA,MAAA,gBAAA,EAAsB;AACpB,UAAMQ,MAAM,GAAGC,UAAU,CAAzB,MAAA;AAEA,UAAM;AACJb,MAAAA,UAAU,GADN,CAAA;AAEJc,MAAAA,UAAU,GAFN,CAAA;AAAA,MAAA,UAAA;AAAA,MAAA,KAAA;AAAA,MAAA,IAAA;AAMJb,MAAAA,MAAM,GAAG;AANL,QAAN,gBAAA;AAUA,UAAMc,MAAM,GAAG,IAAA,UAAA,CAAA,MAAA,EAAA,UAAA,EAAf,UAAe,CAAf;AACA,UAAMC,MAAM,GAAG,IAAA,WAAA,CAAgBC,KAAK,GAApC,UAAe,CAAf;AACA,UAAMC,uBAAuB,CAAC,IAAA,UAAA,CAAD,MAAC,CAAD,EAAA,KAAA,EAAA,UAAA,EAAA,MAAA,EAAA,IAAA,EAA7B,MAA6B,CAA7B;AACA,WAAA,MAAA;AACD;;AAED,SAAA,IAAA;AACD","sourcesContent":["/* eslint-disable camelcase */\nimport type {GLTF, GLTFBufferView, GLTF_EXT_meshopt_compression} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {isMeshoptSupported, meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nexport const name = EXT_MESHOPT_COMPRESSION;\n\nexport function preprocess(gltfData: {json: GLTF}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  if (\n    scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) &&\n    !isMeshoptSupported()\n  ) {\n    throw new Error(`gltf: Required extension ${EXT_MESHOPT_COMPRESSION} not supported by browser`);\n  }\n}\n\nexport async function decode(gltfData: {json: GLTF}, options: GLTFLoaderOptions) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(\n  scenegraph: GLTFScenegraph,\n  bufferView: GLTFBufferView\n): Promise<ArrayBuffer | null> {\n  const meshoptExtension = scenegraph.getObjectExtension<GLTF_EXT_meshopt_compression>(\n    bufferView,\n    EXT_MESHOPT_COMPRESSION\n  );\n  if (meshoptExtension) {\n    const buffer = bufferView.buffer;\n\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n\n    // @ts-expect-error TODO - fix buffer handling\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}