{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\n\nvar _SRC_TEX_PARAMETER_OV;\n\nimport { cloneTextureFrom, readPixelsToArray, getShaderVersion, Buffer, Texture2D, Framebuffer } from '@luma.gl/webgl';\nimport { _transform as transformModule, getPassthroughFS, typeToChannelCount, combineInjects } from '@luma.gl/shadertools';\nimport { updateForTextures, getSizeUniforms } from './transform-shader-utils';\nvar SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, _defineProperty(_SRC_TEX_PARAMETER_OV, 10241, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10240, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10242, 33071), _defineProperty(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);\nvar FS_OUTPUT_VARIABLE = 'transform_output';\n\nvar TextureTransform = /*#__PURE__*/function () {\n  function TextureTransform(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TextureTransform);\n\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = [];\n    this.resources = {};\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  _createClass(TextureTransform, [{\n    key: \"updateModelProps\",\n    value: function updateModelProps() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var updatedModelProps = this._processVertexShader(props);\n\n      return Object.assign({}, props, updatedModelProps);\n    }\n  }, {\n    key: \"getDrawOptions\",\n    value: function getDrawOptions() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$bindings$this$c = this.bindings[this.currentIndex],\n          sourceBuffers = _this$bindings$this$c.sourceBuffers,\n          sourceTextures = _this$bindings$this$c.sourceTextures,\n          framebuffer = _this$bindings$this$c.framebuffer,\n          targetTexture = _this$bindings$this$c.targetTexture;\n      var attributes = Object.assign({}, sourceBuffers, opts.attributes);\n      var uniforms = Object.assign({}, opts.uniforms);\n      var parameters = Object.assign({}, opts.parameters);\n      var discard = opts.discard;\n\n      if (this.hasSourceTextures || this.hasTargetTexture) {\n        attributes.transform_elementID = this.elementIDBuffer;\n\n        for (var sampler in this.samplerTextureMap) {\n          var textureName = this.samplerTextureMap[sampler];\n          uniforms[sampler] = sourceTextures[textureName];\n        }\n\n        this._setSourceTextureParameters();\n\n        var sizeUniforms = getSizeUniforms({\n          sourceTextureMap: sourceTextures,\n          targetTextureVarying: this.targetTextureVarying,\n          targetTexture: targetTexture\n        });\n        Object.assign(uniforms, sizeUniforms);\n      }\n\n      if (this.hasTargetTexture) {\n        discard = false;\n        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n      }\n\n      return {\n        attributes: attributes,\n        framebuffer: framebuffer,\n        uniforms: uniforms,\n        discard: discard,\n        parameters: parameters\n      };\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      if (this._swapTexture) {\n        this.currentIndex = this._getNextIndex();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._setupTextures(opts);\n    }\n  }, {\n    key: \"getTargetTexture\",\n    value: function getTargetTexture() {\n      var targetTexture = this.bindings[this.currentIndex].targetTexture;\n      return targetTexture;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$packed = _ref.packed,\n          packed = _ref$packed === void 0 ? false : _ref$packed;\n\n      var framebuffer = this.bindings[this.currentIndex].framebuffer;\n      var pixels = readPixelsToArray(framebuffer);\n\n      if (!packed) {\n        return pixels;\n      }\n\n      var ArrayType = pixels.constructor;\n      var channelCount = typeToChannelCount(this.targetTextureType);\n      var packedPixels = new ArrayType(pixels.length * channelCount / 4);\n      var packCount = 0;\n\n      for (var i = 0; i < pixels.length; i += 4) {\n        for (var j = 0; j < channelCount; j++) {\n          packedPixels[packCount++] = pixels[i + j];\n        }\n      }\n\n      return packedPixels;\n    }\n  }, {\n    key: \"getFramebuffer\",\n    value: function getFramebuffer() {\n      var currentResources = this.bindings[this.currentIndex];\n      return currentResources.framebuffer;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      if (this.ownTexture) {\n        this.ownTexture.delete();\n      }\n\n      if (this.elementIDBuffer) {\n        this.elementIDBuffer.delete();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _targetTextureVarying = props._targetTextureVarying,\n          _swapTexture = props._swapTexture;\n      this._swapTexture = _swapTexture;\n      this.targetTextureVarying = _targetTextureVarying;\n      this.hasTargetTexture = _targetTextureVarying;\n\n      this._setupTextures(props);\n    }\n  }, {\n    key: \"_createTargetTexture\",\n    value: function _createTargetTexture(props) {\n      var sourceTextures = props.sourceTextures,\n          textureOrReference = props.textureOrReference;\n\n      if (textureOrReference instanceof Texture2D) {\n        return textureOrReference;\n      }\n\n      var refTexture = sourceTextures[textureOrReference];\n\n      if (!refTexture) {\n        return null;\n      }\n\n      this._targetRefTexName = textureOrReference;\n      return this._createNewTexture(refTexture);\n    }\n  }, {\n    key: \"_setupTextures\",\n    value: function _setupTextures() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var sourceBuffers = props.sourceBuffers,\n          _props$_sourceTexture = props._sourceTextures,\n          _sourceTextures = _props$_sourceTexture === void 0 ? {} : _props$_sourceTexture,\n          _targetTexture = props._targetTexture;\n\n      var targetTexture = this._createTargetTexture({\n        sourceTextures: _sourceTextures,\n        textureOrReference: _targetTexture\n      });\n\n      this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;\n\n      this._updateBindings({\n        sourceBuffers: sourceBuffers,\n        sourceTextures: _sourceTextures,\n        targetTexture: targetTexture\n      });\n\n      if ('elementCount' in props) {\n        this._updateElementIDBuffer(props.elementCount);\n      }\n    }\n  }, {\n    key: \"_updateElementIDBuffer\",\n    value: function _updateElementIDBuffer(elementCount) {\n      if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n        return;\n      }\n\n      var elementIds = new Float32Array(elementCount);\n      elementIds.forEach(function (_, index, array) {\n        array[index] = index;\n      });\n\n      if (!this.elementIDBuffer) {\n        this.elementIDBuffer = new Buffer(this.gl, {\n          data: elementIds,\n          accessor: {\n            size: 1\n          }\n        });\n      } else {\n        this.elementIDBuffer.setData({\n          data: elementIds\n        });\n      }\n\n      this.elementCount = elementCount;\n    }\n  }, {\n    key: \"_updateBindings\",\n    value: function _updateBindings(opts) {\n      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n\n      if (this._swapTexture) {\n        var _this$_swapTextures = this._swapTextures(this.bindings[this.currentIndex]),\n            sourceTextures = _this$_swapTextures.sourceTextures,\n            targetTexture = _this$_swapTextures.targetTexture;\n\n        var nextIndex = this._getNextIndex();\n\n        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n          sourceTextures: sourceTextures,\n          targetTexture: targetTexture\n        });\n      }\n    }\n  }, {\n    key: \"_updateBinding\",\n    value: function _updateBinding(binding, opts) {\n      var sourceBuffers = opts.sourceBuffers,\n          sourceTextures = opts.sourceTextures,\n          targetTexture = opts.targetTexture;\n\n      if (!binding) {\n        binding = {\n          sourceBuffers: {},\n          sourceTextures: {},\n          targetTexture: null\n        };\n      }\n\n      Object.assign(binding.sourceTextures, sourceTextures);\n      Object.assign(binding.sourceBuffers, sourceBuffers);\n\n      if (targetTexture) {\n        binding.targetTexture = targetTexture;\n        var width = targetTexture.width,\n            height = targetTexture.height;\n        var _binding = binding,\n            framebuffer = _binding.framebuffer;\n\n        if (framebuffer) {\n          framebuffer.update({\n            attachments: _defineProperty({}, 36064, targetTexture),\n            resizeAttachments: false\n          });\n          framebuffer.resize({\n            width: width,\n            height: height\n          });\n        } else {\n          binding.framebuffer = new Framebuffer(this.gl, {\n            id: \"transform-framebuffer\",\n            width: width,\n            height: height,\n            attachments: _defineProperty({}, 36064, targetTexture)\n          });\n        }\n      }\n\n      return binding;\n    }\n  }, {\n    key: \"_setSourceTextureParameters\",\n    value: function _setSourceTextureParameters() {\n      var index = this.currentIndex;\n      var sourceTextures = this.bindings[index].sourceTextures;\n\n      for (var name in sourceTextures) {\n        sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n      }\n    }\n  }, {\n    key: \"_swapTextures\",\n    value: function _swapTextures(opts) {\n      if (!this._swapTexture) {\n        return null;\n      }\n\n      var sourceTextures = Object.assign({}, opts.sourceTextures);\n      sourceTextures[this._swapTexture] = opts.targetTexture;\n      var targetTexture = opts.sourceTextures[this._swapTexture];\n      return {\n        sourceTextures: sourceTextures,\n        targetTexture: targetTexture\n      };\n    }\n  }, {\n    key: \"_createNewTexture\",\n    value: function _createNewTexture(refTexture) {\n      var _parameters;\n\n      var texture = cloneTextureFrom(refTexture, {\n        parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9728), _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters),\n        pixelStore: _defineProperty({}, 37440, false)\n      });\n\n      if (this.ownTexture) {\n        this.ownTexture.delete();\n      }\n\n      this.ownTexture = texture;\n      return texture;\n    }\n  }, {\n    key: \"_getNextIndex\",\n    value: function _getNextIndex() {\n      return (this.currentIndex + 1) % 2;\n    }\n  }, {\n    key: \"_processVertexShader\",\n    value: function _processVertexShader() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$bindings$this$c2 = this.bindings[this.currentIndex],\n          sourceTextures = _this$bindings$this$c2.sourceTextures,\n          targetTexture = _this$bindings$this$c2.targetTexture;\n\n      var _updateForTextures = updateForTextures({\n        vs: props.vs,\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture: targetTexture\n      }),\n          vs = _updateForTextures.vs,\n          uniforms = _updateForTextures.uniforms,\n          targetTextureType = _updateForTextures.targetTextureType,\n          inject = _updateForTextures.inject,\n          samplerTextureMap = _updateForTextures.samplerTextureMap;\n\n      var combinedInject = combineInjects([props.inject || {}, inject]);\n      this.targetTextureType = targetTextureType;\n      this.samplerTextureMap = samplerTextureMap;\n      var fs = props._fs || getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n      var modules = this.hasSourceTextures || this.targetTextureVarying ? [transformModule].concat(props.modules || []) : props.modules;\n      return {\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        uniforms: uniforms,\n        inject: combinedInject\n      };\n    }\n  }]);\n\n  return TextureTransform;\n}();\n\nexport { TextureTransform as default };","map":{"version":3,"sources":["../../../src/transform/texture-transform.js"],"names":["_transform","SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","constructor","props","Object","updatedModelProps","opts","targetTexture","attributes","uniforms","parameters","discard","textureName","sourceTextures","sizeUniforms","getSizeUniforms","sourceTextureMap","targetTextureVarying","framebuffer","packed","pixels","readPixelsToArray","ArrayType","channelCount","typeToChannelCount","packedPixels","packCount","i","j","currentResources","_swapTexture","textureOrReference","refTexture","_sourceTextures","_targetTexture","sourceBuffers","elementIds","array","data","accessor","size","nextIndex","binding","height","attachments","resizeAttachments","width","id","index","texture","cloneTextureFrom","pixelStore","samplerTextureMap","updateForTextures","vs","combinedInject","combineInjects","fs","getPassthroughFS","version","getShaderVersion","input","inputType","output","modules","inject"],"mappings":"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","sourcesContent":["/** @typedef {import('./transform').TransformProps} TransformProps */\nimport GL from '@luma.gl/constants';\n\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\n\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\n\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceBuffers, sourceTextures, framebuffer, targetTexture} = this.bindings[\n      this.currentIndex\n    ];\n\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    // @ts-ignore\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  /** @param {TransformProps} props */\n  _setupTextures(props = {}) {\n    const {sourceBuffers, _sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceBuffers, sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceBuffers, sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `transform-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    // @ts-ignore TODO - uniforms is not present\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}