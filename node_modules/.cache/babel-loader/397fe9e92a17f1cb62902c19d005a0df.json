{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\nvar GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\nvar GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\nvar GLTFV1Normalizer = /*#__PURE__*/function () {\n  function GLTFV1Normalizer() {\n    _classCallCheck(this, GLTFV1Normalizer);\n\n    _defineProperty(this, \"idToIndexMap\", {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    });\n\n    _defineProperty(this, \"json\", void 0);\n  }\n\n  _createClass(GLTFV1Normalizer, [{\n    key: \"normalize\",\n    value: function normalize(gltf, options) {\n      this.json = gltf.json;\n      var json = gltf.json;\n\n      switch (json.asset && json.asset.version) {\n        case '2.0':\n          return;\n\n        case undefined:\n        case '1.0':\n          break;\n\n        default:\n          console.warn(\"glTF: Unknown version \".concat(json.asset.version));\n          return;\n      }\n\n      if (!options.normalize) {\n        throw new Error('glTF v1 is not supported.');\n      }\n\n      console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n      this._addAsset(json);\n\n      this._convertTopLevelObjectsToArrays(json);\n\n      KHR_binary_glTF.preprocess(gltf);\n\n      this._convertObjectIdsToArrayIndices(json);\n\n      this._updateObjects(json);\n\n      this._updateMaterial(json);\n    }\n  }, {\n    key: \"_addAsset\",\n    value: function _addAsset(json) {\n      json.asset = json.asset || {};\n      json.asset.version = '2.0';\n      json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n    }\n  }, {\n    key: \"_convertTopLevelObjectsToArrays\",\n    value: function _convertTopLevelObjectsToArrays(json) {\n      for (var arrayName in GLTF_ARRAYS) {\n        this._convertTopLevelObjectToArray(json, arrayName);\n      }\n    }\n  }, {\n    key: \"_convertTopLevelObjectToArray\",\n    value: function _convertTopLevelObjectToArray(json, mapName) {\n      var objectMap = json[mapName];\n\n      if (!objectMap || Array.isArray(objectMap)) {\n        return;\n      }\n\n      json[mapName] = [];\n\n      for (var id in objectMap) {\n        var object = objectMap[id];\n        object.id = object.id || id;\n        var index = json[mapName].length;\n        json[mapName].push(object);\n        this.idToIndexMap[mapName][id] = index;\n      }\n    }\n  }, {\n    key: \"_convertObjectIdsToArrayIndices\",\n    value: function _convertObjectIdsToArrayIndices(json) {\n      for (var arrayName in GLTF_ARRAYS) {\n        this._convertIdsToIndices(json, arrayName);\n      }\n\n      if ('scene' in json) {\n        json.scene = this._convertIdToIndex(json.scene, 'scene');\n      }\n\n      var _iterator = _createForOfIteratorHelper(json.textures),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var texture = _step.value;\n\n          this._convertTextureIds(texture);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(json.meshes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mesh = _step2.value;\n\n          this._convertMeshIds(mesh);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(json.nodes),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var node = _step3.value;\n\n          this._convertNodeIds(node);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(json.scenes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _node = _step4.value;\n\n          this._convertSceneIds(_node);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_convertTextureIds\",\n    value: function _convertTextureIds(texture) {\n      if (texture.source) {\n        texture.source = this._convertIdToIndex(texture.source, 'image');\n      }\n    }\n  }, {\n    key: \"_convertMeshIds\",\n    value: function _convertMeshIds(mesh) {\n      var _iterator5 = _createForOfIteratorHelper(mesh.primitives),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var primitive = _step5.value;\n          var attributes = primitive.attributes,\n              indices = primitive.indices,\n              material = primitive.material;\n\n          for (var attributeName in attributes) {\n            attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n          }\n\n          if (indices) {\n            primitive.indices = this._convertIdToIndex(indices, 'accessor');\n          }\n\n          if (material) {\n            primitive.material = this._convertIdToIndex(material, 'material');\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"_convertNodeIds\",\n    value: function _convertNodeIds(node) {\n      var _this = this;\n\n      if (node.children) {\n        node.children = node.children.map(function (child) {\n          return _this._convertIdToIndex(child, 'node');\n        });\n      }\n\n      if (node.meshes) {\n        node.meshes = node.meshes.map(function (mesh) {\n          return _this._convertIdToIndex(mesh, 'mesh');\n        });\n      }\n    }\n  }, {\n    key: \"_convertSceneIds\",\n    value: function _convertSceneIds(scene) {\n      var _this2 = this;\n\n      if (scene.nodes) {\n        scene.nodes = scene.nodes.map(function (node) {\n          return _this2._convertIdToIndex(node, 'node');\n        });\n      }\n    }\n  }, {\n    key: \"_convertIdsToIndices\",\n    value: function _convertIdsToIndices(json, topLevelArrayName) {\n      if (!json[topLevelArrayName]) {\n        console.warn(\"gltf v1: json doesn't contain attribute \".concat(topLevelArrayName));\n        json[topLevelArrayName] = [];\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(json[topLevelArrayName]),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var object = _step6.value;\n\n          for (var key in object) {\n            var id = object[key];\n\n            var index = this._convertIdToIndex(id, key);\n\n            object[key] = index;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"_convertIdToIndex\",\n    value: function _convertIdToIndex(id, key) {\n      var arrayName = GLTF_KEYS[key];\n\n      if (arrayName in this.idToIndexMap) {\n        var index = this.idToIndexMap[arrayName][id];\n\n        if (!Number.isFinite(index)) {\n          throw new Error(\"gltf v1: failed to resolve \".concat(key, \" with id \").concat(id));\n        }\n\n        return index;\n      }\n\n      return id;\n    }\n  }, {\n    key: \"_updateObjects\",\n    value: function _updateObjects(json) {\n      var _iterator7 = _createForOfIteratorHelper(this.json.buffers),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var buffer = _step7.value;\n          delete buffer.type;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"_updateMaterial\",\n    value: function _updateMaterial(json) {\n      var _iterator8 = _createForOfIteratorHelper(json.materials),\n          _step8;\n\n      try {\n        var _loop = function _loop() {\n          var material = _step8.value;\n          material.pbrMetallicRoughness = {\n            baseColorFactor: [1, 1, 1, 1],\n            metallicFactor: 1,\n            roughnessFactor: 1\n          };\n          var textureId = material.values && material.values.tex;\n          var textureIndex = json.textures.findIndex(function (texture) {\n            return texture.id === textureId;\n          });\n\n          if (textureIndex !== -1) {\n            material.pbrMetallicRoughness.baseColorTexture = {\n              index: textureIndex\n            };\n          }\n        };\n\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }]);\n\n  return GLTFV1Normalizer;\n}();\n\nexport function normalizeGLTFV1(gltf) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}","map":{"version":3,"sources":["../../../../src/lib/api/normalize-gltf-v1.ts"],"names":["GLTF_ARRAYS","accessors","animations","buffers","bufferViews","images","materials","meshes","nodes","samplers","scenes","skins","textures","GLTF_KEYS","accessor","buffer","bufferView","image","material","mesh","node","sampler","scene","skin","texture","gltf","json","console","options","KHR_binary_glTF","objectMap","Array","object","index","attributes","primitive","child","id","arrayName","Number","baseColorFactor","metallicFactor","roughnessFactor","textureId","textureIndex"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  idToIndexMap = {\n    animations: {},\n    accessors: {},\n    buffers: {},\n    bufferViews: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    samplers: {},\n    scenes: {},\n    skins: {},\n    textures: {}\n  };\n\n  json;\n\n  // constructor() {}\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    // TODO can this be handled by standard extension processing instead of called explicitly?\n    KHR_binary_glTF.preprocess(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId = material.values && material.values.tex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n"]},"metadata":{},"sourceType":"module"}