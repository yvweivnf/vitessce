{"ast":null,"code":"import { getWebGL2Context, assertWebGL2Context, log } from '@luma.gl/gltools';\nimport Resource from './resource';\nimport Texture2D from './texture-2d';\nimport Renderbuffer from './renderbuffer';\nimport { clear, clearBuffer } from './clear';\nimport { copyToDataUrl } from './copy-and-blit.js';\nimport { getFeatures } from '../features';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { assert } from '../utils/assert';\nconst ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';\nexport default class Framebuffer extends Resource {\n  static isSupported(gl, options = {}) {\n    const {\n      colorBufferFloat,\n      colorBufferHalfFloat\n    } = options;\n    let supported = true;\n\n    if (colorBufferFloat) {\n      supported = Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float') || gl.getExtension('OES_texture_float'));\n    }\n\n    if (colorBufferHalfFloat) {\n      supported = supported && Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('EXT_color_buffer_half_float'));\n    }\n\n    return supported;\n  }\n\n  static getDefaultFramebuffer(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {\n      id: 'default-framebuffer',\n      handle: null,\n      attachments: {}\n    });\n    return gl.luma.defaultFramebuffer;\n  }\n\n  get MAX_COLOR_ATTACHMENTS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);\n  }\n\n  get MAX_DRAW_BUFFERS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);\n  }\n\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n    this.width = null;\n    this.height = null;\n    this.attachments = {};\n    this.readBuffer = 36064;\n    this.drawBuffers = [36064];\n    this.ownResources = [];\n    this.initialize(opts);\n    Object.seal(this);\n  }\n\n  get color() {\n    return this.attachments[36064] || null;\n  }\n\n  get texture() {\n    return this.attachments[36064] || null;\n  }\n\n  get depth() {\n    return this.attachments[36096] || this.attachments[33306] || null;\n  }\n\n  get stencil() {\n    return this.attachments[36128] || this.attachments[33306] || null;\n  }\n\n  initialize({\n    width = 1,\n    height = 1,\n    attachments = null,\n    color = true,\n    depth = true,\n    stencil = false,\n    check = true,\n    readBuffer = undefined,\n    drawBuffers = undefined\n  }) {\n    assert(width >= 0 && height >= 0, 'Width and height need to be integers');\n    this.width = width;\n    this.height = height;\n\n    if (attachments) {\n      for (const attachment in attachments) {\n        const target = attachments[attachment];\n        const object = Array.isArray(target) ? target[0] : target;\n        object.resize({\n          width,\n          height\n        });\n      }\n    } else {\n      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);\n    }\n\n    this.update({\n      clearAttachments: true,\n      attachments,\n      readBuffer,\n      drawBuffers\n    });\n\n    if (attachments && check) {\n      this.checkStatus();\n    }\n  }\n\n  delete() {\n    for (const resource of this.ownResources) {\n      resource.delete();\n    }\n\n    super.delete();\n    return this;\n  }\n\n  update({\n    attachments = {},\n    readBuffer,\n    drawBuffers,\n    clearAttachments = false,\n    resizeAttachments = true\n  }) {\n    this.attach(attachments, {\n      clearAttachments,\n      resizeAttachments\n    });\n    const {\n      gl\n    } = this;\n    const prevHandle = gl.bindFramebuffer(36160, this.handle);\n\n    if (readBuffer) {\n      this._setReadBuffer(readBuffer);\n    }\n\n    if (drawBuffers) {\n      this._setDrawBuffers(drawBuffers);\n    }\n\n    gl.bindFramebuffer(36160, prevHandle || null);\n    return this;\n  }\n\n  resize(options = {}) {\n    let {\n      width,\n      height\n    } = options;\n\n    if (this.handle === null) {\n      assert(width === undefined && height === undefined);\n      this.width = this.gl.drawingBufferWidth;\n      this.height = this.gl.drawingBufferHeight;\n      return this;\n    }\n\n    if (width === undefined) {\n      width = this.gl.drawingBufferWidth;\n    }\n\n    if (height === undefined) {\n      height = this.gl.drawingBufferHeight;\n    }\n\n    if (width !== this.width && height !== this.height) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`)();\n    }\n\n    for (const attachmentPoint in this.attachments) {\n      this.attachments[attachmentPoint].resize({\n        width,\n        height\n      });\n    }\n\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  attach(attachments, {\n    clearAttachments = false,\n    resizeAttachments = true\n  } = {}) {\n    const newAttachments = {};\n\n    if (clearAttachments) {\n      Object.keys(this.attachments).forEach(key => {\n        newAttachments[key] = null;\n      });\n    }\n\n    Object.assign(newAttachments, attachments);\n    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);\n\n    for (const key in newAttachments) {\n      assert(key !== undefined, 'Misspelled framebuffer binding point?');\n      const attachment = Number(key);\n      const descriptor = newAttachments[attachment];\n      let object = descriptor;\n\n      if (!object) {\n        this._unattach(attachment);\n      } else if (object instanceof Renderbuffer) {\n        this._attachRenderbuffer({\n          attachment,\n          renderbuffer: object\n        });\n      } else if (Array.isArray(descriptor)) {\n        const [texture, layer = 0, level = 0] = descriptor;\n        object = texture;\n\n        this._attachTexture({\n          attachment,\n          texture,\n          layer,\n          level\n        });\n      } else {\n        this._attachTexture({\n          attachment,\n          texture: object,\n          layer: 0,\n          level: 0\n        });\n      }\n\n      if (resizeAttachments && object) {\n        object.resize({\n          width: this.width,\n          height: this.height\n        });\n      }\n    }\n\n    this.gl.bindFramebuffer(36160, prevHandle || null);\n    Object.assign(this.attachments, attachments);\n    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {\n      delete this.attachments[key];\n    });\n  }\n\n  checkStatus() {\n    const {\n      gl\n    } = this;\n    const status = this.getStatus();\n\n    if (status !== 36053) {\n      throw new Error(_getFrameBufferStatus(status));\n    }\n\n    return this;\n  }\n\n  getStatus() {\n    const {\n      gl\n    } = this;\n    const prevHandle = gl.bindFramebuffer(36160, this.handle);\n    const status = gl.checkFramebufferStatus(36160);\n    gl.bindFramebuffer(36160, prevHandle || null);\n    return status;\n  }\n\n  clear(options = {}) {\n    const {\n      color,\n      depth,\n      stencil,\n      drawBuffers = []\n    } = options;\n    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);\n\n    if (color || depth || stencil) {\n      clear(this.gl, {\n        color,\n        depth,\n        stencil\n      });\n    }\n\n    drawBuffers.forEach((value, drawBuffer) => {\n      clearBuffer(this.gl, {\n        drawBuffer,\n        value\n      });\n    });\n    this.gl.bindFramebuffer(36160, prevHandle || null);\n    return this;\n  }\n\n  readPixels(opts = {}) {\n    log.error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();\n    return null;\n  }\n\n  readPixelsToBuffer(opts = {}) {\n    log.error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();\n    return null;\n  }\n\n  copyToDataUrl(opts = {}) {\n    log.error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();\n    return null;\n  }\n\n  copyToImage(opts = {}) {\n    log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();\n    return null;\n  }\n\n  copyToTexture(opts = {}) {\n    log.error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();\n    return null;\n  }\n\n  blit(opts = {}) {\n    log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();\n    return null;\n  }\n\n  invalidate({\n    attachments = [],\n    x = 0,\n    y = 0,\n    width,\n    height\n  }) {\n    const gl2 = assertWebGL2Context(this.gl);\n    const prevHandle = gl2.bindFramebuffer(36008, this.handle);\n    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;\n\n    if (invalidateAll) {\n      gl2.invalidateFramebuffer(36008, attachments);\n    } else {\n      gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);\n    }\n\n    gl2.bindFramebuffer(36008, prevHandle);\n    return this;\n  }\n\n  getAttachmentParameter(attachment, pname, keys) {\n    let value = this._getAttachmentParameterFallback(pname);\n\n    if (value === null) {\n      this.gl.bindFramebuffer(36160, this.handle);\n      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);\n      this.gl.bindFramebuffer(36160, null);\n    }\n\n    if (keys && value > 1000) {\n      value = getKey(this.gl, value);\n    }\n\n    return value;\n  }\n\n  getAttachmentParameters(attachment = 36064, keys, parameters = this.constructor.ATTACHMENT_PARAMETERS || []) {\n    const values = {};\n\n    for (const pname of parameters) {\n      const key = keys ? getKey(this.gl, pname) : pname;\n      values[key] = this.getAttachmentParameter(attachment, pname, keys);\n    }\n\n    return values;\n  }\n\n  getParameters(keys = true) {\n    const attachments = Object.keys(this.attachments);\n    const parameters = {};\n\n    for (const attachmentName of attachments) {\n      const attachment = Number(attachmentName);\n      const key = keys ? getKey(this.gl, attachment) : attachment;\n      parameters[key] = this.getAttachmentParameters(attachment, keys);\n    }\n\n    return parameters;\n  }\n\n  show() {\n    if (typeof window !== 'undefined') {\n      window.open(copyToDataUrl(this), 'luma-debug-texture');\n    }\n\n    return this;\n  }\n\n  log(logLevel = 0, message = '') {\n    if (logLevel > log.level || typeof window === 'undefined') {\n      return this;\n    }\n\n    message = message || `Framebuffer ${this.id}`;\n    const image = copyToDataUrl(this, {\n      targetMaxHeight: 100\n    });\n    log.image({\n      logLevel,\n      message,\n      image\n    }, message)();\n    return this;\n  }\n\n  bind({\n    target = 36160\n  } = {}) {\n    this.gl.bindFramebuffer(target, this.handle);\n    return this;\n  }\n\n  unbind({\n    target = 36160\n  } = {}) {\n    this.gl.bindFramebuffer(target, null);\n    return this;\n  }\n\n  _createDefaultAttachments(color, depth, stencil, width, height) {\n    let defaultAttachments = null;\n\n    if (color) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[36064] = new Texture2D(this.gl, {\n        id: `${this.id}-color0`,\n        pixels: null,\n        format: 6408,\n        type: 5121,\n        width,\n        height,\n        mipmaps: false,\n        parameters: {\n          [10241]: 9729,\n          [10240]: 9729,\n          [10242]: 33071,\n          [10243]: 33071\n        }\n      });\n      this.ownResources.push(defaultAttachments[36064]);\n    }\n\n    if (depth && stencil) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[33306] = new Renderbuffer(this.gl, {\n        id: `${this.id}-depth-stencil`,\n        format: 35056,\n        width,\n        height: 111\n      });\n      this.ownResources.push(defaultAttachments[33306]);\n    } else if (depth) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[36096] = new Renderbuffer(this.gl, {\n        id: `${this.id}-depth`,\n        format: 33189,\n        width,\n        height\n      });\n      this.ownResources.push(defaultAttachments[36096]);\n    } else if (stencil) {\n      assert(false);\n    }\n\n    return defaultAttachments;\n  }\n\n  _unattach(attachment) {\n    const oldAttachment = this.attachments[attachment];\n\n    if (!oldAttachment) {\n      return;\n    }\n\n    if (oldAttachment instanceof Renderbuffer) {\n      this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);\n    } else {\n      this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);\n    }\n\n    delete this.attachments[attachment];\n  }\n\n  _attachRenderbuffer({\n    attachment = 36064,\n    renderbuffer\n  }) {\n    const {\n      gl\n    } = this;\n    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);\n    this.attachments[attachment] = renderbuffer;\n  }\n\n  _attachTexture({\n    attachment = 36064,\n    texture,\n    layer,\n    level\n  }) {\n    const {\n      gl\n    } = this;\n    gl.bindTexture(texture.target, texture.handle);\n\n    switch (texture.target) {\n      case 35866:\n      case 32879:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);\n        break;\n\n      case 34067:\n        const face = mapIndexToCubeMapFace(layer);\n        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);\n        break;\n\n      case 3553:\n        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);\n        break;\n\n      default:\n        assert(false, 'Illegal texture type');\n    }\n\n    gl.bindTexture(texture.target, null);\n    this.attachments[attachment] = texture;\n  }\n\n  _setReadBuffer(readBuffer) {\n    const gl2 = getWebGL2Context(this.gl);\n\n    if (gl2) {\n      gl2.readBuffer(readBuffer);\n    } else {\n      assert(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);\n    }\n\n    this.readBuffer = readBuffer;\n  }\n\n  _setDrawBuffers(drawBuffers) {\n    const {\n      gl\n    } = this;\n    const gl2 = assertWebGL2Context(gl);\n\n    if (gl2) {\n      gl2.drawBuffers(drawBuffers);\n    } else {\n      const ext = gl.getExtension('WEBGL_draw_buffers');\n\n      if (ext) {\n        ext.drawBuffersWEBGL(drawBuffers);\n      } else {\n        assert(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);\n      }\n    }\n\n    this.drawBuffers = drawBuffers;\n  }\n\n  _getAttachmentParameterFallback(pname) {\n    const caps = getFeatures(this.gl);\n\n    switch (pname) {\n      case 36052:\n        return !caps.WEBGL2 ? 0 : null;\n\n      case 33298:\n      case 33299:\n      case 33300:\n      case 33301:\n      case 33302:\n      case 33303:\n        return !caps.WEBGL2 ? 8 : null;\n\n      case 33297:\n        return !caps.WEBGL2 ? 5125 : null;\n\n      case 33296:\n        return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;\n\n      default:\n        return null;\n    }\n  }\n\n  _createHandle() {\n    return this.gl.createFramebuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteFramebuffer(this.handle);\n  }\n\n  _bindHandle(handle) {\n    return this.gl.bindFramebuffer(36160, handle);\n  }\n\n}\n\nfunction mapIndexToCubeMapFace(layer) {\n  return layer < 34069 ? layer + 34069 : layer;\n}\n\nfunction _getFrameBufferStatus(status) {\n  const STATUS = Framebuffer.STATUS || {};\n  return STATUS[status] || `Framebuffer error ${status}`;\n}\n\nexport const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];\nFramebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;","map":{"version":3,"sources":["../../../src/classes/framebuffer.js"],"names":["ERR_MULTIPLE_RENDERTARGETS","options","colorBufferHalfFloat","supported","Boolean","gl","id","handle","attachments","gl2","assertWebGL2Context","constructor","opts","Object","initialize","width","height","color","depth","stencil","check","readBuffer","drawBuffers","undefined","assert","target","object","Array","clearAttachments","delete","resource","update","resizeAttachments","prevHandle","resize","log","attach","newAttachments","key","attachment","Number","descriptor","renderbuffer","layer","level","texture","checkStatus","status","_getFrameBufferStatus","getStatus","clear","clearBuffer","value","readPixels","readPixelsToBuffer","copyToDataUrl","copyToImage","copyToTexture","blit","invalidate","x","y","invalidateAll","getAttachmentParameter","keys","getKey","getAttachmentParameters","parameters","values","getParameters","show","window","logLevel","message","image","targetMaxHeight","bind","unbind","_createDefaultAttachments","defaultAttachments","pixels","format","type","mipmaps","_unattach","oldAttachment","_attachRenderbuffer","_attachTexture","face","mapIndexToCubeMapFace","_setReadBuffer","getWebGL2Context","_setDrawBuffers","ext","_getAttachmentParameterFallback","caps","getFeatures","_createHandle","_deleteHandle","_bindHandle","STATUS","Framebuffer","FRAMEBUFFER_ATTACHMENT_PARAMETERS"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {getWebGL2Context, assertWebGL2Context, log} from '@luma.gl/gltools';\nimport Resource from './resource';\nimport Texture2D from './texture-2d';\nimport Renderbuffer from './renderbuffer';\nimport {clear, clearBuffer} from './clear';\nimport {copyToDataUrl} from './copy-and-blit.js';\n\nimport {getFeatures} from '../features';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {assert} from '../utils/assert';\n\nconst ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';\n\nexport default class Framebuffer extends Resource {\n  static isSupported(gl, options = {}) {\n    const {\n      colorBufferFloat, // Whether floating point textures can be rendered and read\n      colorBufferHalfFloat // Whether half float textures can be rendered and read\n    } = options;\n    let supported = true;\n\n    if (colorBufferFloat) {\n      supported = Boolean(\n        // WebGL 2\n        gl.getExtension('EXT_color_buffer_float') ||\n          // WebGL 1, not exposed on all platforms\n          gl.getExtension('WEBGL_color_buffer_float') ||\n          // WebGL 1, implicitly enables float render targets https://www.khronos.org/registry/webgl/extensions/OES_texture_float/\n          gl.getExtension('OES_texture_float')\n      );\n    }\n\n    if (colorBufferHalfFloat) {\n      supported =\n        supported &&\n        Boolean(\n          // WebGL 2\n          gl.getExtension('EXT_color_buffer_float') ||\n            // WebGL 1\n            gl.getExtension('EXT_color_buffer_half_float')\n        );\n    }\n\n    return supported;\n  }\n\n  // Create a Framebuffer wrapper for the default framebuffer (target === null)\n  static getDefaultFramebuffer(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultFramebuffer =\n      gl.luma.defaultFramebuffer ||\n      new Framebuffer(gl, {\n        id: 'default-framebuffer',\n        handle: null,\n        attachments: {}\n      });\n    // TODO - can we query for and get a handle to the GL.FRONT renderbuffer?\n    return gl.luma.defaultFramebuffer;\n  }\n\n  get MAX_COLOR_ATTACHMENTS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);\n  }\n\n  get MAX_DRAW_BUFFERS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);\n  }\n\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    // Public members\n    this.width = null;\n    this.height = null;\n    this.attachments = {};\n    this.readBuffer = GL.COLOR_ATTACHMENT0;\n    this.drawBuffers = [GL.COLOR_ATTACHMENT0];\n    this.ownResources = [];\n    this.initialize(opts);\n\n    Object.seal(this);\n  }\n\n  get color() {\n    return this.attachments[GL.COLOR_ATTACHMENT0] || null;\n  }\n\n  get texture() {\n    return this.attachments[GL.COLOR_ATTACHMENT0] || null;\n  }\n\n  get depth() {\n    return (\n      this.attachments[GL.DEPTH_ATTACHMENT] || this.attachments[GL.DEPTH_STENCIL_ATTACHMENT] || null\n    );\n  }\n\n  get stencil() {\n    return (\n      this.attachments[GL.STENCIL_ATTACHMENT] ||\n      this.attachments[GL.DEPTH_STENCIL_ATTACHMENT] ||\n      null\n    );\n  }\n\n  initialize({\n    width = 1,\n    height = 1,\n    attachments = null,\n    color = true,\n    depth = true,\n    stencil = false,\n    check = true,\n    readBuffer = undefined,\n    drawBuffers = undefined\n  }) {\n    assert(width >= 0 && height >= 0, 'Width and height need to be integers');\n\n    // Store actual width and height for diffing\n    this.width = width;\n    this.height = height;\n\n    // Resize any provided attachments - note that resize only resizes if needed\n    // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)\n    if (attachments) {\n      for (const attachment in attachments) {\n        const target = attachments[attachment];\n        const object = Array.isArray(target) ? target[0] : target;\n        object.resize({width, height});\n      }\n    } else {\n      // Create any requested default attachments\n      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);\n    }\n\n    this.update({clearAttachments: true, attachments, readBuffer, drawBuffers});\n\n    // Checks that framebuffer was properly set up, if not, throws an explanatory error\n    if (attachments && check) {\n      this.checkStatus();\n    }\n  }\n\n  delete() {\n    for (const resource of this.ownResources) {\n      resource.delete();\n    }\n    super.delete();\n    return this;\n  }\n\n  update({\n    attachments = {},\n    readBuffer,\n    drawBuffers,\n    clearAttachments = false,\n    resizeAttachments = true\n  }) {\n    this.attach(attachments, {clearAttachments, resizeAttachments});\n\n    const {gl} = this;\n    // Multiple render target support, set read buffer and draw buffers\n    const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    if (readBuffer) {\n      this._setReadBuffer(readBuffer);\n    }\n    if (drawBuffers) {\n      this._setDrawBuffers(drawBuffers);\n    }\n    // @ts-ignore\n    gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // Attachment resize is expected to be a noop if size is same\n  resize(options = {}) {\n    let {width, height} = options;\n    // for default framebuffer, just update the stored size\n    if (this.handle === null) {\n      assert(width === undefined && height === undefined);\n      this.width = this.gl.drawingBufferWidth;\n      this.height = this.gl.drawingBufferHeight;\n      return this;\n    }\n\n    if (width === undefined) {\n      width = this.gl.drawingBufferWidth;\n    }\n    if (height === undefined) {\n      height = this.gl.drawingBufferHeight;\n    }\n\n    if (width !== this.width && height !== this.height) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`)();\n    }\n    for (const attachmentPoint in this.attachments) {\n      this.attachments[attachmentPoint].resize({width, height});\n    }\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  // Attach from a map of attachments\n  attach(attachments, {clearAttachments = false, resizeAttachments = true} = {}) {\n    const newAttachments = {};\n\n    // Any current attachments need to be removed, add null values to map\n    if (clearAttachments) {\n      Object.keys(this.attachments).forEach(key => {\n        newAttachments[key] = null;\n      });\n    }\n\n    // Overlay the new attachments\n    Object.assign(newAttachments, attachments);\n\n    const prevHandle = this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n\n    // Walk the attachments\n    for (const key in newAttachments) {\n      // Ensure key is not undefined\n      assert(key !== undefined, 'Misspelled framebuffer binding point?');\n\n      const attachment = Number(key);\n\n      const descriptor = newAttachments[attachment];\n      let object = descriptor;\n      if (!object) {\n        this._unattach(attachment);\n      } else if (object instanceof Renderbuffer) {\n        this._attachRenderbuffer({attachment, renderbuffer: object});\n      } else if (Array.isArray(descriptor)) {\n        const [texture, layer = 0, level = 0] = descriptor;\n        object = texture;\n        this._attachTexture({attachment, texture, layer, level});\n      } else {\n        this._attachTexture({attachment, texture: object, layer: 0, level: 0});\n      }\n\n      // Resize objects\n      if (resizeAttachments && object) {\n        object.resize({width: this.width, height: this.height});\n      }\n    }\n\n    // @ts-ignore\n    this.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    // Assign to attachments and remove any nulls to get a clean attachment map\n    Object.assign(this.attachments, attachments);\n    Object.keys(this.attachments)\n      .filter(key => !this.attachments[key])\n      .forEach(key => {\n        delete this.attachments[key];\n      });\n  }\n\n  checkStatus() {\n    const {gl} = this;\n    const status = this.getStatus();\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n      throw new Error(_getFrameBufferStatus(status));\n    }\n    return this;\n  }\n\n  getStatus() {\n    const {gl} = this;\n    const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    const status = gl.checkFramebufferStatus(GL.FRAMEBUFFER);\n    // @ts-ignore\n    gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n    return status;\n  }\n\n  clear(options = {}) {\n    const {color, depth, stencil, drawBuffers = []} = options;\n\n    // Bind framebuffer and delegate to global clear functions\n    const prevHandle = this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n\n    if (color || depth || stencil) {\n      clear(this.gl, {color, depth, stencil});\n    }\n\n    drawBuffers.forEach((value, drawBuffer) => {\n      clearBuffer(this.gl, {drawBuffer, value});\n    });\n\n    // @ts-ignore\n    this.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // NOTE: Slow requires roundtrip to GPU\n  // App can provide pixelArray or have it auto allocated by this method\n  // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n  //  newly allocated by this method unless provided by app.\n  readPixels(opts = {}) {\n    log.error(\n      'Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)'\n    )();\n    return null;\n  }\n\n  // Reads data into provided buffer object asynchronously\n  // This function doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n  readPixelsToBuffer(opts = {}) {\n    log.error(\n      'Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)'\n    )();\n    return null;\n  }\n\n  // Reads pixels as a dataUrl\n  copyToDataUrl(opts = {}) {\n    log.error(\n      'Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)'\n    )();\n    return null;\n  }\n\n  // Reads pixels into an HTML Image\n  copyToImage(opts = {}) {\n    log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();\n    return null;\n  }\n\n  // copyToFramebuffer({width, height}) {\n  //   const scaleX = width / this.width;\n  //   const scaleY = height / this.height;\n  //   const scale = Math.min(scaleX, scaleY);\n  //   width = width * scale;\n  //   height = height * scale;\n  //   const scaledFramebuffer = new Framebuffer(this.gl, {width, height});\n  //   this.blit();\n  // }\n\n  // Copy a rectangle from a framebuffer attachment into a texture (at an offset)\n  // NOTE: assumes texture has enough storage allocated\n  // eslint-disable-next-line complexity\n  copyToTexture(opts = {}) {\n    log.error(\n      'Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})'\n    )();\n    return null;\n  }\n\n  // WEBGL2 INTERFACE\n\n  // Copies a rectangle of pixels between framebuffers\n  // eslint-disable-next-line complexity\n  blit(opts = {}) {\n    log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();\n    return null;\n  }\n\n  // signals to the GL that it need not preserve all pixels of a specified region of the framebuffer\n  invalidate({attachments = [], x = 0, y = 0, width, height}) {\n    const gl2 = assertWebGL2Context(this.gl);\n    const prevHandle = gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, this.handle);\n    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;\n    if (invalidateAll) {\n      gl2.invalidateFramebuffer(GL.READ_FRAMEBUFFER, attachments);\n    } else {\n      // TODO - why does type checking fail on this line\n      // @ts-ignore\n      gl2.invalidateFramebuffer(GL.READ_FRAMEBUFFER, attachments, x, y, width, height);\n    }\n    // @ts-ignore\n    gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, prevHandle);\n    return this;\n  }\n\n  // Return the value for `pname` of the specified attachment.\n  // The type returned is the type of the requested pname\n  getAttachmentParameter(attachment, pname, keys) {\n    let value = this._getAttachmentParameterFallback(pname);\n    if (value === null) {\n      this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n      value = this.gl.getFramebufferAttachmentParameter(GL.FRAMEBUFFER, attachment, pname);\n      this.gl.bindFramebuffer(GL.FRAMEBUFFER, null);\n    }\n    if (keys && value > 1000) {\n      // @ts-ignore\n      value = getKey(this.gl, value);\n    }\n    return value;\n  }\n\n  getAttachmentParameters(\n    attachment = GL.COLOR_ATTACHMENT0,\n    keys,\n    // @ts-ignore\n    parameters = this.constructor.ATTACHMENT_PARAMETERS || []\n  ) {\n    const values = {};\n    for (const pname of parameters) {\n      const key = keys ? getKey(this.gl, pname) : pname;\n      values[key] = this.getAttachmentParameter(attachment, pname, keys);\n    }\n    return values;\n  }\n\n  getParameters(keys = true) {\n    const attachments = Object.keys(this.attachments);\n    // if (this === this.gl.luma.defaultFramebuffer) {\n    //   attachments = [GL.COLOR_ATTACHMENT0, GL.DEPTH_STENCIL_ATTACHMENT];\n    // }\n    const parameters = {};\n    for (const attachmentName of attachments) {\n      const attachment = Number(attachmentName);\n      const key = keys ? getKey(this.gl, attachment) : attachment;\n      parameters[key] = this.getAttachmentParameters(attachment, keys);\n    }\n    return parameters;\n  }\n\n  // DEBUG\n\n  // Note: Will only work when called in an event handler\n  show() {\n    if (typeof window !== 'undefined') {\n      window.open(copyToDataUrl(this), 'luma-debug-texture');\n    }\n    return this;\n  }\n\n  log(logLevel = 0, message = '') {\n    if (logLevel > log.level || typeof window === 'undefined') {\n      return this;\n    }\n    message = message || `Framebuffer ${this.id}`;\n    const image = copyToDataUrl(this, {targetMaxHeight: 100});\n    log.image({logLevel, message, image}, message)();\n    return this;\n  }\n\n  // WEBGL INTERFACE\n  bind({target = GL.FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, this.handle);\n    return this;\n  }\n\n  unbind({target = GL.FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _createDefaultAttachments(color, depth, stencil, width, height) {\n    let defaultAttachments = null;\n\n    // Add a color buffer if requested and not supplied\n    if (color) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.COLOR_ATTACHMENT0] = new Texture2D(this.gl, {\n        id: `${this.id}-color0`,\n        pixels: null, // reserves texture memory, but texels are undefined\n        format: GL.RGBA,\n        type: GL.UNSIGNED_BYTE,\n        width,\n        height,\n        // Note: Mipmapping can be disabled by texture resource when we resize the texture\n        // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant\n        // behavior we always disable mipmaps.\n        mipmaps: false,\n        // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.\n        // Use LINEAR so subpixel algos like fxaa work.\n        // Set WRAP modes that support NPOT textures too.\n        parameters: {\n          [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n          [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n          [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n        }\n      });\n      // track to delete later\n      this.ownResources.push(defaultAttachments[GL.COLOR_ATTACHMENT0]);\n    }\n\n    if (depth && stencil) {\n      // TODO - handle separate stencil\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.DEPTH_STENCIL_ATTACHMENT] = new Renderbuffer(this.gl, {\n        id: `${this.id}-depth-stencil`,\n        format: GL.DEPTH24_STENCIL8,\n        width,\n        height: 111\n      });\n      // track to delete later\n      this.ownResources.push(defaultAttachments[GL.DEPTH_STENCIL_ATTACHMENT]);\n      // TODO - optional texture\n      // new Texture2D(this.gl, {\n      //   id: `${this.id}-depth-stencil`,\n      //   format: GL.DEPTH24_STENCIL8,\n      //   dataFormat: GL.DEPTH_STENCIL,\n      //   type: GL.UNSIGNED_INT_24_8,\n      //   width,\n      //   height,\n      //   mipmaps: false\n      // });\n    } else if (depth) {\n      // Add a depth buffer if requested and not supplied\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.DEPTH_ATTACHMENT] = new Renderbuffer(this.gl, {\n        id: `${this.id}-depth`,\n        format: GL.DEPTH_COMPONENT16,\n        width,\n        height\n      });\n      // track to delete later\n      this.ownResources.push(defaultAttachments[GL.DEPTH_ATTACHMENT]);\n    } else if (stencil) {\n      // TODO - handle separate stencil\n      assert(false);\n    }\n\n    return defaultAttachments;\n  }\n\n  _unattach(attachment) {\n    const oldAttachment = this.attachments[attachment];\n    if (!oldAttachment) {\n      return;\n    }\n    if (oldAttachment instanceof Renderbuffer) {\n      // render buffer\n      this.gl.framebufferRenderbuffer(GL.FRAMEBUFFER, attachment, GL.RENDERBUFFER, null);\n    } else {\n      // Must be a texture attachment\n      this.gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, GL.TEXTURE_2D, null, 0);\n    }\n    delete this.attachments[attachment];\n  }\n\n  _attachRenderbuffer({attachment = GL.COLOR_ATTACHMENT0, renderbuffer}) {\n    const {gl} = this;\n    // TODO - is the bind needed?\n    // gl.bindRenderbuffer(GL.RENDERBUFFER, renderbuffer.handle);\n    gl.framebufferRenderbuffer(GL.FRAMEBUFFER, attachment, GL.RENDERBUFFER, renderbuffer.handle);\n    // TODO - is the unbind needed?\n    // gl.bindRenderbuffer(GL.RENDERBUFFER, null);\n\n    this.attachments[attachment] = renderbuffer;\n  }\n\n  // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`\n  // level = 0 - mipmapLevel (must be 0 in WebGL1)\n  _attachTexture({attachment = GL.COLOR_ATTACHMENT0, texture, layer, level}) {\n    const {gl} = this;\n    gl.bindTexture(texture.target, texture.handle);\n\n    switch (texture.target) {\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.framebufferTextureLayer(GL.FRAMEBUFFER, attachment, texture.target, level, layer);\n        break;\n\n      case GL.TEXTURE_CUBE_MAP:\n        // layer must be a cubemap face (or if index, converted to cube map face)\n        const face = mapIndexToCubeMapFace(layer);\n        gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, face, texture.handle, level);\n        break;\n\n      case GL.TEXTURE_2D:\n        gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, GL.TEXTURE_2D, texture.handle, level);\n        break;\n\n      default:\n        assert(false, 'Illegal texture type');\n    }\n\n    gl.bindTexture(texture.target, null);\n    this.attachments[attachment] = texture;\n  }\n\n  // Expects framebuffer to be bound\n  _setReadBuffer(readBuffer) {\n    const gl2 = getWebGL2Context(this.gl);\n    if (gl2) {\n      gl2.readBuffer(readBuffer);\n    } else {\n      // Setting to color attachment 0 is a noop, so allow it in WebGL1\n      assert(\n        readBuffer === GL.COLOR_ATTACHMENT0 || readBuffer === GL.BACK,\n        ERR_MULTIPLE_RENDERTARGETS\n      );\n    }\n    this.readBuffer = readBuffer;\n  }\n\n  // Expects framebuffer to be bound\n  _setDrawBuffers(drawBuffers) {\n    const {gl} = this;\n    const gl2 = assertWebGL2Context(gl);\n    if (gl2) {\n      gl2.drawBuffers(drawBuffers);\n    } else {\n      // TODO - is this not handled by polyfills?\n      const ext = gl.getExtension('WEBGL_draw_buffers');\n      if (ext) {\n        ext.drawBuffersWEBGL(drawBuffers);\n      } else {\n        // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1\n        assert(\n          drawBuffers.length === 1 &&\n            (drawBuffers[0] === GL.COLOR_ATTACHMENT0 || drawBuffers[0] === GL.BACK),\n          ERR_MULTIPLE_RENDERTARGETS\n        );\n      }\n    }\n    this.drawBuffers = drawBuffers;\n  }\n\n  // Attempt to provide workable defaults for WebGL2 symbols under WebGL1\n  // null means OK to query\n  // TODO - move to webgl1 polyfills\n  /* eslint-disable complexity */\n  _getAttachmentParameterFallback(pname) {\n    const caps = getFeatures(this.gl);\n\n    switch (pname) {\n      case GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: // GLint\n        return !caps.WEBGL2 ? 0 : null;\n      case GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: // GLint\n        return !caps.WEBGL2 ? 8 : null;\n      case GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: // GLenum\n        return !caps.WEBGL2 ? GL.UNSIGNED_INT : null;\n      case GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:\n        return !caps.WEBGL2 && !caps.EXT_sRGB ? GL.LINEAR : null;\n      default:\n        return null;\n    }\n  }\n  /* eslint-enable complexity */\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createFramebuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteFramebuffer(this.handle);\n  }\n\n  _bindHandle(handle) {\n    return this.gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  }\n}\n\n// PUBLIC METHODS\n\n// Map an index to a cube map face constant\nfunction mapIndexToCubeMapFace(layer) {\n  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)\n  // if smaller assume layer is index, otherwise assume it is already a cube map face constant\n  return layer < GL.TEXTURE_CUBE_MAP_POSITIVE_X ? layer + GL.TEXTURE_CUBE_MAP_POSITIVE_X : layer;\n}\n\n// Helper METHODS\n// Get a string describing the framebuffer error if installed\nfunction _getFrameBufferStatus(status) {\n  // Use error mapping if installed\n  // @ts-ignore\n  const STATUS = Framebuffer.STATUS || {};\n  return STATUS[status] || `Framebuffer error ${status}`;\n}\n\nexport const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [\n  GL.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, // WebGLRenderbuffer or WebGLTexture\n  GL.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, // GL.RENDERBUFFER, GL.TEXTURE, GL.NONE\n  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE, // GL.TEXTURE_CUBE_MAP_POSITIVE_X, etc.\n  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, // GLint\n  // EXT_sRGB or WebGL2\n  GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, // GL.LINEAR, GL.SRBG\n  // WebGL2\n  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE // GLint\n  // GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\n  // GL.FLOAT, GL.INT, GL.UNSIGNED_INT, GL.SIGNED_NORMALIZED, OR GL.UNSIGNED_NORMALIZED.\n];\n\nFramebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;\n"]},"metadata":{},"sourceType":"module"}