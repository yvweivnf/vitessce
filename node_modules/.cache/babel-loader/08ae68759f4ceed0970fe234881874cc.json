{"ast":null,"code":"import { cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical } from \"../cartesian\";\nimport { circleStream } from \"../circle\";\nimport { abs, cos, epsilon, pi, sqrt } from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\nexport default function (radius, delta) {\n  var cr = cos(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  } // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n\n\n  function clipLine(stream) {\n    var point0, // previous point\n    c0, // code for previous point\n    v0, // visibility of previous point\n    v00, // visibility of first point\n    _clean; // no intersections\n\n\n    return {\n      lineStart: function lineStart() {\n        v00 = v0 = false;\n        _clean = 1;\n      },\n      point: function point(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n\n        if (v !== v0) {\n          _clean = 0;\n\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t; // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            _clean = 0;\n\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function lineEnd() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function clean() {\n        return _clean | (v00 && v0) << 1;\n      }\n    };\n  } // Intersects the great circle between a and b with the clip circle.\n\n\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b); // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n\n    var n1 = [1, 0, 0],\n        // normal\n    n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0],\n        // cartesianDot(n1, n2),\n    determinant = n2n2 - n1n2 * n1n2; // Two polar points.\n\n    if (!determinant) return !two && a;\n    var c1 = cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B); // Solve |p(t)|^2 = 1.\n\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n    if (t2 < 0) return;\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n    if (!two) return q; // Two intersection points.\n\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.\n\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  } // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n\n\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/d3-geo/src/clip/circle.js"],"names":["cartesian","cartesianAddInPlace","cartesianCross","cartesianDot","cartesianScale","spherical","circleStream","abs","cos","epsilon","pi","sqrt","pointEqual","clip","radius","delta","cr","smallRadius","notHemisphere","interpolate","from","to","direction","stream","visible","lambda","phi","clipLine","point0","c0","v0","v00","clean","lineStart","point","point1","point2","v","c","code","intersect","lineEnd","t","a","b","two","pa","pb","n1","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","A","B","u","w","uu","t2","q","lambda0","lambda1","phi0","phi1","z","polar","meridian","q1","r"],"mappings":"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","sourcesContent":["import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian\";\nimport {circleStream} from \"../circle\";\nimport {abs, cos, epsilon, pi, sqrt} from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\n\nexport default function(radius, delta) {\n  var cr = cos(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n"]},"metadata":{},"sourceType":"module"}