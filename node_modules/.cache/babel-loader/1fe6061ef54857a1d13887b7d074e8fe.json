{"ast":null,"code":"import { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\n\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n  // TODO: add special casing to add conditional value based on orient signal\n  return Object.assign.apply(null, [{}, ...configTypes.map(configType => {\n    if (configType === 'axisOrient') {\n      const orient1 = channel === 'x' ? 'bottom' : 'left';\n      const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n      const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n      const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n      const conditionalOrientAxisConfig = {};\n\n      for (const prop of props.values()) {\n        conditionalOrientAxisConfig[prop] = {\n          // orient is surely signal in this case\n          signal: `${orient['signal']} === \"${orient1}\" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`\n        };\n      }\n\n      return conditionalOrientAxisConfig;\n    }\n\n    return config[configType];\n  })]);\n}\n\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n  const typeBasedConfigTypes = scaleType === 'band' ? ['axisDiscrete', 'axisBand'] : scaleType === 'point' ? ['axisDiscrete', 'axisPoint'] : isQuantitative(scaleType) ? ['axisQuantitative'] : scaleType === 'time' || scaleType === 'utc' ? ['axisTemporal'] : [];\n  const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n  const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n\n  const vlOnlyConfigTypes = [// technically Vega does have axisBand, but if we make another separation here,\n  // it will further introduce complexity in the code\n  ...typeBasedConfigTypes, ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))];\n  const vgConfigTypes = ['axis', axisOrient, axisChannel];\n  return {\n    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n  };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n  var _a;\n\n  const toMerge = [{}];\n\n  for (const configType of axisConfigTypes) {\n    // TODO: add special casing to add conditional value based on orient signal\n    let style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;\n\n    if (style) {\n      style = array(style);\n\n      for (const s of style) {\n        toMerge.push(config.style[s]);\n      }\n    }\n  }\n\n  return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style, axisConfigs = {}) {\n  var _a;\n\n  const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n\n  if (styleConfig !== undefined) {\n    return {\n      configFrom: 'style',\n      configValue: styleConfig\n    };\n  }\n\n  for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {\n    if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {\n      return {\n        configFrom,\n        configValue: axisConfigs[configFrom][property]\n      };\n    }\n  }\n\n  return {};\n}","map":{"version":3,"sources":["../../../../src/compile/axis/config.ts"],"names":[],"mappings":"AACA,SAAQ,KAAR,QAAoB,WAApB;AAIA,SAAQ,cAAR,QAA6B,aAA7B;AACA,SAAQ,IAAR,EAAc,SAAd,QAA8B,YAA9B;AACA,SAAQ,WAAR,QAA0B,mBAA1B;AACA,SAAQ,cAAR,EAAwB,mBAAxB,QAAkD,WAAlD;;AAEA,SAAS,4BAAT,CACE,WADF,EAEE,MAFF,EAGE,OAHF,EAIE,MAJF,EAI4B;AAE1B;AACA,SAAO,MAAM,CAAC,MAAP,CAAc,KAAd,CAAoB,IAApB,EAA0B,CAC/B,EAD+B,EAE/B,GAAG,WAAW,CAAC,GAAZ,CAAgB,UAAU,IAAG;AAC9B,QAAI,UAAU,KAAK,YAAnB,EAAiC;AAC/B,YAAM,OAAO,GAAG,OAAO,KAAK,GAAZ,GAAkB,QAAlB,GAA6B,MAA7C;AACA,YAAM,aAAa,GAAG,MAAM,CAAC,OAAO,KAAK,GAAZ,GAAkB,YAAlB,GAAiC,UAAlC,CAAN,IAAuD,EAA7E;AACA,YAAM,aAAa,GAAG,MAAM,CAAC,OAAO,KAAK,GAAZ,GAAkB,SAAlB,GAA8B,WAA/B,CAAN,IAAqD,EAA3E;AAEA,YAAM,KAAK,GAAG,IAAI,GAAJ,CAAQ,CAAC,GAAG,IAAI,CAAC,aAAD,CAAR,EAAyB,GAAG,IAAI,CAAC,aAAD,CAAhC,CAAR,CAAd;AAEA,YAAM,2BAA2B,GAAG,EAApC;;AACA,WAAK,MAAM,IAAX,IAAmB,KAAK,CAAC,MAAN,EAAnB,EAAmC;AACjC,QAAA,2BAA2B,CAAC,IAAD,CAA3B,GAAoC;AAClC;AACA,UAAA,MAAM,EAAE,GAAG,MAAM,CAAC,QAAD,CAAU,SAAS,OAAO,OAAO,mBAAmB,CACnE,aAAa,CAAC,IAAD,CADsD,CAEpE,MAAM,mBAAmB,CAAC,aAAa,CAAC,IAAD,CAAd,CAAqB;AAJb,SAApC;AAMD;;AAED,aAAO,2BAAP;AACD;;AAED,WAAO,MAAM,CAAC,UAAD,CAAb;AACD,GAtBE,CAF4B,CAA1B,CAAP;AA0BD;;AAID,OAAM,SAAU,cAAV,CACJ,OADI,EAEJ,SAFI,EAGJ,MAHI,EAIJ,MAJI,EAIU;AAEd,QAAM,oBAAoB,GACxB,SAAS,KAAK,MAAd,GACI,CAAC,cAAD,EAAiB,UAAjB,CADJ,GAEI,SAAS,KAAK,OAAd,GACA,CAAC,cAAD,EAAiB,WAAjB,CADA,GAEA,cAAc,CAAC,SAAD,CAAd,GACA,CAAC,kBAAD,CADA,GAEA,SAAS,KAAK,MAAd,IAAwB,SAAS,KAAK,KAAtC,GACA,CAAC,cAAD,CADA,GAEA,EATN;AAWA,QAAM,WAAW,GAAG,OAAO,KAAK,GAAZ,GAAkB,OAAlB,GAA4B,OAAhD;AACA,QAAM,UAAU,GAAG,WAAW,CAAC,MAAD,CAAX,GAAsB,YAAtB,GAAqC,OAAO,SAAS,CAAC,MAAD,CAAQ,EAAhF,CAdc,CAcsE;;AAEpF,QAAM,iBAAiB,GAAG,CACxB;AACA;AACA,KAAG,oBAHqB,EAIxB,GAAG,oBAAoB,CAAC,GAArB,CAAyB,CAAC,IAAI,WAAW,GAAG,CAAC,CAAC,MAAF,CAAS,CAAT,CAA5C,CAJqB,CAA1B;AAOA,QAAM,aAAa,GAAG,CAAC,MAAD,EAAS,UAAT,EAAqB,WAArB,CAAtB;AAEA,SAAO;AACL,IAAA,gBAAgB,EAAE,4BAA4B,CAAC,iBAAD,EAAoB,MAApB,EAA4B,OAA5B,EAAqC,MAArC,CADzC;AAEL,IAAA,YAAY,EAAE,4BAA4B,CAAC,aAAD,EAAgB,MAAhB,EAAwB,OAAxB,EAAiC,MAAjC,CAFrC;AAGL,IAAA,eAAe,EAAE,kBAAkB,CAAC,CAAC,GAAG,aAAJ,EAAmB,GAAG,iBAAtB,CAAD,EAA2C,MAA3C;AAH9B,GAAP;AAKD;AAED,OAAM,SAAU,kBAAV,CAA6B,eAA7B,EAAwD,MAAxD,EAAsE;;;AAC1E,QAAM,OAAO,GAAG,CAAC,EAAD,CAAhB;;AACA,OAAK,MAAM,UAAX,IAAyB,eAAzB,EAA0C;AACxC;AACA,QAAI,KAAK,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,UAAD,CAAN,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,KAAhC;;AACA,QAAI,KAAJ,EAAW;AACT,MAAA,KAAK,GAAG,KAAK,CAAC,KAAD,CAAb;;AACA,WAAK,MAAM,CAAX,IAAgB,KAAhB,EAAuB;AACrB,QAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,KAAP,CAAa,CAAb,CAAb;AACD;AACF;AACF;;AACD,SAAO,MAAM,CAAC,MAAP,CAAc,KAAd,CAAoB,IAApB,EAA0B,OAA1B,CAAP;AACD;AACD,OAAM,SAAU,aAAV,CACJ,QADI,EAEJ,gBAFI,EAGJ,KAHI,EAIJ,WAAA,GAAoC,EAJhC,EAIkC;;;AAEtC,QAAM,WAAW,GAAG,cAAc,CAAC,QAAD,EAAW,KAAX,EAAkB,gBAAlB,CAAlC;;AAEA,MAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,WAAO;AACL,MAAA,UAAU,EAAE,OADP;AAEL,MAAA,WAAW,EAAE;AAFR,KAAP;AAID;;AAED,OAAK,MAAM,UAAX,IAAyB,CAAC,kBAAD,EAAqB,cAArB,EAAqC,iBAArC,CAAzB,EAAkF;AAChF,QAAI,CAAA,CAAA,EAAA,GAAA,WAAW,CAAC,UAAD,CAAX,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,KAAA,CAAvB,GAAuB,EAAA,CAAG,QAAH,CAAvB,MAAwC,SAA5C,EAAuD;AACrD,aAAO;AAAC,QAAA,UAAD;AAAa,QAAA,WAAW,EAAE,WAAW,CAAC,UAAD,CAAX,CAAwB,QAAxB;AAA1B,OAAP;AACD;AACF;;AACD,SAAO,EAAP;AACD","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n    // TODO: add special casing to add conditional value based on orient signal\n    return Object.assign.apply(null, [\n        {},\n        ...configTypes.map(configType => {\n            if (configType === 'axisOrient') {\n                const orient1 = channel === 'x' ? 'bottom' : 'left';\n                const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n                const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n                const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n                const conditionalOrientAxisConfig = {};\n                for (const prop of props.values()) {\n                    conditionalOrientAxisConfig[prop] = {\n                        // orient is surely signal in this case\n                        signal: `${orient['signal']} === \"${orient1}\" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`\n                    };\n                }\n                return conditionalOrientAxisConfig;\n            }\n            return config[configType];\n        })\n    ]);\n}\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n    const typeBasedConfigTypes = scaleType === 'band'\n        ? ['axisDiscrete', 'axisBand']\n        : scaleType === 'point'\n            ? ['axisDiscrete', 'axisPoint']\n            : isQuantitative(scaleType)\n                ? ['axisQuantitative']\n                : scaleType === 'time' || scaleType === 'utc'\n                    ? ['axisTemporal']\n                    : [];\n    const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n    const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n    const vlOnlyConfigTypes = [\n        // technically Vega does have axisBand, but if we make another separation here,\n        // it will further introduce complexity in the code\n        ...typeBasedConfigTypes,\n        ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))\n    ];\n    const vgConfigTypes = ['axis', axisOrient, axisChannel];\n    return {\n        vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n        vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n        axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n    };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n    var _a;\n    const toMerge = [{}];\n    for (const configType of axisConfigTypes) {\n        // TODO: add special casing to add conditional value based on orient signal\n        let style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;\n        if (style) {\n            style = array(style);\n            for (const s of style) {\n                toMerge.push(config.style[s]);\n            }\n        }\n    }\n    return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style, axisConfigs = {}) {\n    var _a;\n    const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n    if (styleConfig !== undefined) {\n        return {\n            configFrom: 'style',\n            configValue: styleConfig\n        };\n    }\n    for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {\n        if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {\n            return { configFrom, configValue: axisConfigs[configFrom][property] };\n        }\n    }\n    return {};\n}\n//# sourceMappingURL=config.js.map"]},"metadata":{},"sourceType":"module"}