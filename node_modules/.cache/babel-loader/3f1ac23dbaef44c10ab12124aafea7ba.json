{"ast":null,"code":"import { getMarkPropOrConfig } from '../common';\nimport * as encode from './encode';\nexport var text = {\n  vgMark: 'text',\n  encodeEntry: function encodeEntry(model) {\n    var config = model.config,\n        encoding = model.encoding;\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n      align: 'include',\n      baseline: 'include',\n      color: 'include',\n      size: 'ignore',\n      orient: 'ignore',\n      theta: 'include'\n    })), encode.pointPosition('x', model, {\n      defaultPos: 'mid'\n    })), encode.pointPosition('y', model, {\n      defaultPos: 'mid'\n    })), encode.text(model)), encode.nonPosition('size', model, {\n      vgChannel: 'fontSize' // VL's text size is fontSize\n\n    })), encode.nonPosition('angle', model)), encode.valueIfDefined('align', align(model.markDef, encoding, config))), encode.valueIfDefined('baseline', baseline(model.markDef, encoding, config))), encode.pointPosition('radius', model, {\n      defaultPos: null\n    })), encode.pointPosition('theta', model, {\n      defaultPos: null\n    }));\n  }\n};\n\nfunction align(markDef, encoding, config) {\n  var a = getMarkPropOrConfig('align', markDef, config);\n\n  if (a === undefined) {\n    return 'center';\n  } // If there is a config, Vega-parser will process this already.\n\n\n  return undefined;\n}\n\nfunction baseline(markDef, encoding, config) {\n  var b = getMarkPropOrConfig('baseline', markDef, config);\n\n  if (b === undefined) {\n    return 'middle';\n  } // If there is a config, Vega-parser will process this already.\n\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/mark/text.ts"],"names":[],"mappings":"AAIA,SAAQ,mBAAR,QAAkC,WAAlC;AAGA,OAAO,KAAK,MAAZ,MAAwB,UAAxB;AAEA,OAAO,IAAM,IAAI,GAAiB;AAChC,EAAA,MAAM,EAAE,MADwB;AAGhC,EAAA,WAAW,EAAE,qBAAC,KAAD,EAAqB;AAAA,QACzB,MADyB,GACL,KADK,CACzB,MADyB;AAAA,QACjB,QADiB,GACL,KADK,CACjB,QADiB;AAGhC,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,MAAM,CAAC,eAAP,CAAuB,KAAvB,EAA8B;AAC/B,MAAA,KAAK,EAAE,SADwB;AAE/B,MAAA,QAAQ,EAAE,SAFqB;AAG/B,MAAA,KAAK,EAAE,SAHwB;AAI/B,MAAA,IAAI,EAAE,QAJyB;AAK/B,MAAA,MAAM,EAAE,QALuB;AAM/B,MAAA,KAAK,EAAE;AANwB,KAA9B,CADL,CAAA,EASK,MAAM,CAAC,aAAP,CAAqB,GAArB,EAA0B,KAA1B,EAAiC;AAAC,MAAA,UAAU,EAAE;AAAb,KAAjC,CATL,CAAA,EAUK,MAAM,CAAC,aAAP,CAAqB,GAArB,EAA0B,KAA1B,EAAiC;AAAC,MAAA,UAAU,EAAE;AAAb,KAAjC,CAVL,CAAA,EAWK,MAAM,CAAC,IAAP,CAAY,KAAZ,CAXL,CAAA,EAYK,MAAM,CAAC,WAAP,CAAmB,MAAnB,EAA2B,KAA3B,EAAkC;AACnC,MAAA,SAAS,EAAE,UADwB,CACb;;AADa,KAAlC,CAZL,CAAA,EAeK,MAAM,CAAC,WAAP,CAAmB,OAAnB,EAA4B,KAA5B,CAfL,CAAA,EAgBK,MAAM,CAAC,cAAP,CAAsB,OAAtB,EAA+B,KAAK,CAAC,KAAK,CAAC,OAAP,EAAgB,QAAhB,EAA0B,MAA1B,CAApC,CAhBL,CAAA,EAiBK,MAAM,CAAC,cAAP,CAAsB,UAAtB,EAAkC,QAAQ,CAAC,KAAK,CAAC,OAAP,EAAgB,QAAhB,EAA0B,MAA1B,CAA1C,CAjBL,CAAA,EAkBK,MAAM,CAAC,aAAP,CAAqB,QAArB,EAA+B,KAA/B,EAAsC;AAAC,MAAA,UAAU,EAAE;AAAb,KAAtC,CAlBL,CAAA,EAmBK,MAAM,CAAC,aAAP,CAAqB,OAArB,EAA8B,KAA9B,EAAqC;AAAC,MAAA,UAAU,EAAE;AAAb,KAArC,CAnBL,CAAA;AAqBD;AA3B+B,CAA3B;;AA8BP,SAAS,KAAT,CAAe,OAAf,EAAiC,QAAjC,EAA6D,MAA7D,EAAsF;AACpF,MAAM,CAAC,GAAG,mBAAmB,CAAC,OAAD,EAAU,OAAV,EAAmB,MAAnB,CAA7B;;AACA,MAAI,CAAC,KAAK,SAAV,EAAqB;AACnB,WAAO,QAAP;AACD,GAJmF,CAKpF;;;AACA,SAAO,SAAP;AACD;;AAED,SAAS,QAAT,CAAkB,OAAlB,EAAoC,QAApC,EAAgE,MAAhE,EAAyF;AACvF,MAAM,CAAC,GAAG,mBAAmB,CAAC,UAAD,EAAa,OAAb,EAAsB,MAAtB,CAA7B;;AACA,MAAI,CAAC,KAAK,SAAV,EAAqB;AACnB,WAAO,QAAP;AACD,GAJsF,CAKvF;;;AACA,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["import { getMarkPropOrConfig } from '../common';\nimport * as encode from './encode';\nexport const text = {\n    vgMark: 'text',\n    encodeEntry: (model) => {\n        const { config, encoding } = model;\n        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n            align: 'include',\n            baseline: 'include',\n            color: 'include',\n            size: 'ignore',\n            orient: 'ignore',\n            theta: 'include'\n        })), encode.pointPosition('x', model, { defaultPos: 'mid' })), encode.pointPosition('y', model, { defaultPos: 'mid' })), encode.text(model)), encode.nonPosition('size', model, {\n            vgChannel: 'fontSize' // VL's text size is fontSize\n        })), encode.nonPosition('angle', model)), encode.valueIfDefined('align', align(model.markDef, encoding, config))), encode.valueIfDefined('baseline', baseline(model.markDef, encoding, config))), encode.pointPosition('radius', model, { defaultPos: null })), encode.pointPosition('theta', model, { defaultPos: null }));\n    }\n};\nfunction align(markDef, encoding, config) {\n    const a = getMarkPropOrConfig('align', markDef, config);\n    if (a === undefined) {\n        return 'center';\n    }\n    // If there is a config, Vega-parser will process this already.\n    return undefined;\n}\nfunction baseline(markDef, encoding, config) {\n    const b = getMarkPropOrConfig('baseline', markDef, config);\n    if (b === undefined) {\n        return 'middle';\n    }\n    // If there is a config, Vega-parser will process this already.\n    return undefined;\n}\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}