{"ast":null,"code":"import * as encode from './encode';\nexport const rule = {\n  vgMark: 'rule',\n  encodeEntry: model => {\n    const {\n      markDef\n    } = model;\n    const orient = markDef.orient;\n\n    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {\n      // Show nothing if we have none of x, y, lat, and long.\n      return {};\n    }\n\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n      align: 'ignore',\n      baseline: 'ignore',\n      color: 'include',\n      orient: 'ignore',\n      size: 'ignore',\n      theta: 'ignore'\n    })), encode.pointOrRangePosition('x', model, {\n      defaultPos: orient === 'horizontal' ? 'zeroOrMax' : 'mid',\n      defaultPos2: 'zeroOrMin',\n      range: orient !== 'vertical' // include x2 for horizontal or line segment rule\n\n    })), encode.pointOrRangePosition('y', model, {\n      defaultPos: orient === 'vertical' ? 'zeroOrMax' : 'mid',\n      defaultPos2: 'zeroOrMin',\n      range: orient !== 'horizontal' // include y2 for vertical or line segment rule\n\n    })), encode.nonPosition('size', model, {\n      vgChannel: 'strokeWidth' // VL's rule size is strokeWidth\n\n    }));\n  }\n};","map":{"version":3,"sources":["../../../../src/compile/mark/rule.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,MAAZ,MAAwB,UAAxB;AAEA,OAAO,MAAM,IAAI,GAAiB;AAChC,EAAA,MAAM,EAAE,MADwB;AAEhC,EAAA,WAAW,EAAG,KAAD,IAAqB;AAChC,UAAM;AAAC,MAAA;AAAD,QAAY,KAAlB;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;;AAEA,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,CAAhB,IAAqB,CAAC,KAAK,CAAC,QAAN,CAAe,CAArC,IAA0C,CAAC,KAAK,CAAC,QAAN,CAAe,QAA1D,IAAsE,CAAC,KAAK,CAAC,QAAN,CAAe,SAA1F,EAAqG;AACnG;AACA,aAAO,EAAP;AACD;;AAED,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,MAAM,CAAC,eAAP,CAAuB,KAAvB,EAA8B;AAC/B,MAAA,KAAK,EAAE,QADwB;AAE/B,MAAA,QAAQ,EAAE,QAFqB;AAG/B,MAAA,KAAK,EAAE,SAHwB;AAI/B,MAAA,MAAM,EAAE,QAJuB;AAK/B,MAAA,IAAI,EAAE,QALyB;AAM/B,MAAA,KAAK,EAAE;AANwB,KAA9B,CADL,CAAA,EASK,MAAM,CAAC,oBAAP,CAA4B,GAA5B,EAAiC,KAAjC,EAAwC;AACzC,MAAA,UAAU,EAAE,MAAM,KAAK,YAAX,GAA0B,WAA1B,GAAwC,KADX;AAEzC,MAAA,WAAW,EAAE,WAF4B;AAGzC,MAAA,KAAK,EAAE,MAAM,KAAK,UAHuB,CAGZ;;AAHY,KAAxC,CATL,CAAA,EAcK,MAAM,CAAC,oBAAP,CAA4B,GAA5B,EAAiC,KAAjC,EAAwC;AACzC,MAAA,UAAU,EAAE,MAAM,KAAK,UAAX,GAAwB,WAAxB,GAAsC,KADT;AAEzC,MAAA,WAAW,EAAE,WAF4B;AAGzC,MAAA,KAAK,EAAE,MAAM,KAAK,YAHuB,CAGV;;AAHU,KAAxC,CAdL,CAAA,EAmBK,MAAM,CAAC,WAAP,CAAmB,MAAnB,EAA2B,KAA3B,EAAkC;AACnC,MAAA,SAAS,EAAE,aADwB,CACV;;AADU,KAAlC,CAnBL,CAAA;AAuBD;AAlC+B,CAA3B","sourceRoot":"","sourcesContent":["import * as encode from './encode';\nexport const rule = {\n    vgMark: 'rule',\n    encodeEntry: (model) => {\n        const { markDef } = model;\n        const orient = markDef.orient;\n        if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {\n            // Show nothing if we have none of x, y, lat, and long.\n            return {};\n        }\n        return Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n            align: 'ignore',\n            baseline: 'ignore',\n            color: 'include',\n            orient: 'ignore',\n            size: 'ignore',\n            theta: 'ignore'\n        })), encode.pointOrRangePosition('x', model, {\n            defaultPos: orient === 'horizontal' ? 'zeroOrMax' : 'mid',\n            defaultPos2: 'zeroOrMin',\n            range: orient !== 'vertical' // include x2 for horizontal or line segment rule\n        })), encode.pointOrRangePosition('y', model, {\n            defaultPos: orient === 'vertical' ? 'zeroOrMax' : 'mid',\n            defaultPos2: 'zeroOrMin',\n            range: orient !== 'horizontal' // include y2 for vertical or line segment rule\n        })), encode.nonPosition('size', model, {\n            vgChannel: 'strokeWidth' // VL's rule size is strokeWidth\n        }));\n    }\n};\n//# sourceMappingURL=rule.js.map"]},"metadata":{},"sourceType":"module"}