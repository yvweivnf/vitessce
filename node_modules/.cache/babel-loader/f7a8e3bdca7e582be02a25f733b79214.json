{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModifyMode = void 0;\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar ModifyMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(ModifyMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(ModifyMode);\n\n  function ModifyMode() {\n    _classCallCheck(this, ModifyMode);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ModifyMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var _this = this;\n\n      var handles = [];\n      var data = props.data,\n          lastPointerMoveEvent = props.lastPointerMoveEvent;\n      var features = data.features;\n      var picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n      var mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;\n\n      var _iterator = _createForOfIteratorHelper(props.selectedIndexes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _index = _step.value;\n\n          if (_index < features.length) {\n            var geometry = features[_index].geometry;\n            handles.push.apply(handles, _toConsumableArray((0, _utils.getEditHandlesForGeometry)(geometry, _index)));\n          } else {\n            console.warn(\"selectedFeatureIndexes out of range \".concat(_index)); // eslint-disable-line no-console,no-undef\n          }\n        } // intermediate edit handle\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (picks && picks.length && mapCoords) {\n        var existingEditHandle = (0, _utils.getPickedExistingEditHandle)(picks); // don't show intermediate point when too close to an existing edit handle\n\n        var featureAsPick = !existingEditHandle && picks.find(function (pick) {\n          return !pick.isGuide;\n        }); // is the feature in the pick selected\n\n        if (featureAsPick && !featureAsPick.object.geometry.type.includes('Point') && props.selectedIndexes.includes(featureAsPick.index)) {\n          var intermediatePoint = null;\n          var positionIndexPrefix = [];\n          var referencePoint = (0, _helpers.point)(mapCoords); // process all lines of the (single) feature\n\n          (0, _utils.recursivelyTraverseNestedArrays)(featureAsPick.object.geometry.coordinates, [], function (lineString, prefix) {\n            var lineStringFeature = (0, _helpers.lineString)(lineString);\n\n            var candidateIntermediatePoint = _this.getNearestPoint( // @ts-ignore\n            lineStringFeature, referencePoint, props.modeConfig && props.modeConfig.viewport);\n\n            if (!intermediatePoint || candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }); // tack on the lone intermediate point to the set of handles\n\n          if (intermediatePoint) {\n            var _intermediatePoint = intermediatePoint,\n                position = _intermediatePoint.geometry.coordinates,\n                index = _intermediatePoint.properties.index;\n            handles.push({\n              type: 'Feature',\n              properties: {\n                guideType: 'editHandle',\n                editHandleType: 'intermediate',\n                featureIndex: featureAsPick.index,\n                positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [index + 1])\n              },\n              geometry: {\n                type: 'Point',\n                coordinates: position\n              }\n            });\n          }\n        }\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: handles\n      };\n    } // turf.js does not support elevation for nearestPointOnLine\n\n  }, {\n    key: \"getNearestPoint\",\n    value: function getNearestPoint(line, inPoint, viewport) {\n      var coordinates = line.geometry.coordinates;\n\n      if (coordinates.some(function (coord) {\n        return coord.length > 2;\n      })) {\n        if (viewport) {\n          // This line has elevation, we need to use alternative algorithm\n          return (0, _utils.nearestPointOnProjectedLine)(line, inPoint, viewport);\n        } // eslint-disable-next-line no-console,no-undef\n\n\n        console.log('Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.');\n      }\n\n      return (0, _utils.nearestPointOnLine)(line, inPoint, viewport);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event, props) {\n      var pickedExistingHandle = (0, _utils.getPickedExistingEditHandle)(event.picks);\n      var pickedIntermediateHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);\n\n      if (pickedExistingHandle) {\n        var _pickedExistingHandle = pickedExistingHandle.properties,\n            featureIndex = _pickedExistingHandle.featureIndex,\n            positionIndexes = _pickedExistingHandle.positionIndexes;\n        var updatedData;\n\n        try {\n          updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).removePosition(featureIndex, positionIndexes).getObject();\n        } catch (ignored) {// This happens if user attempts to remove the last point\n        }\n\n        if (updatedData) {\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'removePosition',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: pickedExistingHandle.geometry.coordinates\n            }\n          });\n        }\n      } else if (pickedIntermediateHandle) {\n        var _pickedIntermediateHa = pickedIntermediateHandle.properties,\n            _featureIndex = _pickedIntermediateHa.featureIndex,\n            _positionIndexes = _pickedIntermediateHa.positionIndexes;\n\n        var _updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(_featureIndex, _positionIndexes, pickedIntermediateHandle.geometry.coordinates).getObject();\n\n        if (_updatedData) {\n          props.onEdit({\n            updatedData: _updatedData,\n            editType: 'addPosition',\n            editContext: {\n              featureIndexes: [_featureIndex],\n              positionIndexes: _positionIndexes,\n              position: pickedIntermediateHandle.geometry.coordinates\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (editHandle) {\n        // Cancel map panning if pointer went down on an edit handle\n        event.cancelPan();\n        var editHandleProperties = editHandle.properties;\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(editHandleProperties.featureIndex, editHandleProperties.positionIndexes, event.mapCoords).getObject();\n        props.onEdit({\n          updatedData: updatedData,\n          editType: 'movePosition',\n          editContext: {\n            featureIndexes: [editHandleProperties.featureIndex],\n            positionIndexes: editHandleProperties.positionIndexes,\n            position: event.mapCoords\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      var cursor = this.getCursor(event);\n      props.onUpdateCursor(cursor);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var editHandleProperties = editHandle.properties;\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(editHandleProperties.featureIndex, editHandleProperties.positionIndexes, event.mapCoords).getObject();\n        props.onEdit({\n          updatedData: updatedData,\n          editType: 'addPosition',\n          editContext: {\n            featureIndexes: [editHandleProperties.featureIndex],\n            positionIndexes: editHandleProperties.positionIndexes,\n            position: event.mapCoords\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedEditHandle)(event.picks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var editHandleProperties = editHandle.properties;\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(editHandleProperties.featureIndex, editHandleProperties.positionIndexes, event.mapCoords).getObject();\n        props.onEdit({\n          updatedData: updatedData,\n          editType: 'finishMovePosition',\n          editContext: {\n            featureIndexes: [editHandleProperties.featureIndex],\n            positionIndexes: editHandleProperties.positionIndexes,\n            position: event.mapCoords\n          }\n        });\n      }\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(event) {\n      var picks = event && event.picks || [];\n      var handlesPicked = (0, _utils.getPickedEditHandles)(picks);\n\n      if (handlesPicked.length) {\n        return 'cell';\n      }\n\n      return null;\n    }\n  }]);\n\n  return ModifyMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.ModifyMode = ModifyMode;","map":{"version":3,"sources":["../../src/lib/modify-mode.ts"],"names":["ModifyMode","GeoJsonEditMode","props","handles","data","lastPointerMoveEvent","features","picks","mapCoords","index","geometry","console","existingEditHandle","featureAsPick","pick","intermediatePoint","positionIndexPrefix","referencePoint","lineStringFeature","candidateIntermediatePoint","position","type","properties","guideType","editHandleType","featureIndex","positionIndexes","coordinates","line","inPoint","viewport","coord","event","pickedExistingHandle","pickedIntermediateHandle","updatedData","ImmutableFeatureCollection","editType","editContext","featureIndexes","editHandle","editHandleProperties","cursor","selectedFeatureIndexes","handlesPicked"],"mappings":"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","sourcesContent":["import { point, lineString as toLineString } from '@turf/helpers';\nimport {\n  recursivelyTraverseNestedArrays,\n  nearestPointOnProjectedLine,\n  nearestPointOnLine,\n  getEditHandlesForGeometry,\n  getPickedEditHandles,\n  getPickedEditHandle,\n  getPickedExistingEditHandle,\n  getPickedIntermediateEditHandle,\n  NearestPointType,\n} from '../utils';\nimport { LineString, Point, FeatureCollection, FeatureOf } from '../geojson-types';\nimport {\n  ModeProps,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  Viewport,\n  GuideFeatureCollection,\n} from '../types';\nimport { GeoJsonEditMode } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ModifyMode extends GeoJsonEditMode {\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    const handles = [];\n\n    const { data, lastPointerMoveEvent } = props;\n    const { features } = data;\n    const picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n    const mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;\n\n    for (const index of props.selectedIndexes) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index));\n      } else {\n        console.warn(`selectedFeatureIndexes out of range ${index}`); // eslint-disable-line no-console,no-undef\n      }\n    }\n\n    // intermediate edit handle\n    if (picks && picks.length && mapCoords) {\n      const existingEditHandle = getPickedExistingEditHandle(picks);\n      // don't show intermediate point when too close to an existing edit handle\n      const featureAsPick = !existingEditHandle && picks.find((pick) => !pick.isGuide);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        !featureAsPick.object.geometry.type.includes('Point') &&\n        props.selectedIndexes.includes(featureAsPick.index)\n      ) {\n        let intermediatePoint: NearestPointType | null | undefined = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(mapCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.getNearestPoint(\n              // @ts-ignore\n              lineStringFeature,\n              referencePoint,\n              props.modeConfig && props.modeConfig.viewport\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index },\n          } = intermediatePoint;\n          handles.push({\n            type: 'Feature',\n            properties: {\n              guideType: 'editHandle',\n              editHandleType: 'intermediate',\n              featureIndex: featureAsPick.index,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n            },\n            geometry: {\n              type: 'Point',\n              coordinates: position,\n            },\n          });\n        }\n      }\n    }\n\n    return {\n      type: 'FeatureCollection',\n      features: handles,\n    };\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  getNearestPoint(\n    line: FeatureOf<LineString>,\n    inPoint: FeatureOf<Point>,\n    viewport: Viewport | null | undefined\n  ): NearestPointType {\n    const { coordinates } = line.geometry;\n    if (coordinates.some((coord) => coord.length > 2)) {\n      if (viewport) {\n        // This line has elevation, we need to use alternative algorithm\n        return nearestPointOnProjectedLine(line, inPoint, viewport);\n      }\n      // eslint-disable-next-line no-console,no-undef\n      console.log(\n        'Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.'\n      );\n    }\n    return nearestPointOnLine(line, inPoint, viewport);\n  }\n\n  handleClick(event: ClickEvent, props: ModeProps<FeatureCollection>) {\n    const pickedExistingHandle = getPickedExistingEditHandle(event.picks);\n    const pickedIntermediateHandle = getPickedIntermediateEditHandle(event.picks);\n\n    if (pickedExistingHandle) {\n      const { featureIndex, positionIndexes } = pickedExistingHandle.properties;\n\n      let updatedData;\n      try {\n        updatedData = new ImmutableFeatureCollection(props.data)\n          .removePosition(featureIndex, positionIndexes)\n          .getObject();\n      } catch (ignored) {\n        // This happens if user attempts to remove the last point\n      }\n\n      if (updatedData) {\n        props.onEdit({\n          updatedData,\n          editType: 'removePosition',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes,\n            position: pickedExistingHandle.geometry.coordinates,\n          },\n        });\n      }\n    } else if (pickedIntermediateHandle) {\n      const { featureIndex, positionIndexes } = pickedIntermediateHandle.properties;\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .addPosition(featureIndex, positionIndexes, pickedIntermediateHandle.geometry.coordinates)\n        .getObject();\n\n      if (updatedData) {\n        props.onEdit({\n          updatedData,\n          editType: 'addPosition',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes,\n            position: pickedIntermediateHandle.geometry.coordinates,\n          },\n        });\n      }\n    }\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (editHandle) {\n      // Cancel map panning if pointer went down on an edit handle\n      event.cancelPan();\n\n      const editHandleProperties = editHandle.properties;\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replacePosition(\n          editHandleProperties.featureIndex,\n          editHandleProperties.positionIndexes,\n          event.mapCoords\n        )\n        .getObject();\n\n      props.onEdit({\n        updatedData,\n        editType: 'movePosition',\n        editContext: {\n          featureIndexes: [editHandleProperties.featureIndex],\n          positionIndexes: editHandleProperties.positionIndexes,\n          position: event.mapCoords,\n        },\n      });\n    }\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    const cursor = this.getCursor(event);\n    props.onUpdateCursor(cursor);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const editHandle = getPickedIntermediateEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const editHandleProperties = editHandle.properties;\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .addPosition(\n          editHandleProperties.featureIndex,\n          editHandleProperties.positionIndexes,\n          event.mapCoords\n        )\n        .getObject();\n\n      props.onEdit({\n        updatedData,\n        editType: 'addPosition',\n        editContext: {\n          featureIndexes: [editHandleProperties.featureIndex],\n          positionIndexes: editHandleProperties.positionIndexes,\n          position: event.mapCoords,\n        },\n      });\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const editHandleProperties = editHandle.properties;\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replacePosition(\n          editHandleProperties.featureIndex,\n          editHandleProperties.positionIndexes,\n          event.mapCoords\n        )\n        .getObject();\n\n      props.onEdit({\n        updatedData,\n        editType: 'finishMovePosition',\n        editContext: {\n          featureIndexes: [editHandleProperties.featureIndex],\n          positionIndexes: editHandleProperties.positionIndexes,\n          position: event.mapCoords,\n        },\n      });\n    }\n  }\n\n  getCursor(event: PointerMoveEvent): string | null | undefined {\n    const picks = (event && event.picks) || [];\n\n    const handlesPicked = getPickedEditHandles(picks);\n    if (handlesPicked.length) {\n      return 'cell';\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}