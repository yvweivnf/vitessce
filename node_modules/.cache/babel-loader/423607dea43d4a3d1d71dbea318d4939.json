{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource';\nimport { AbortError, AggregateError, wait, zip } from '../utils';\n\nvar Block = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  function Block(offset, length) {\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, Block);\n\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n  /**\n   * @returns {number} the top byte border\n   */\n\n\n  _createClass(Block, [{\n    key: \"top\",\n    get: function get() {\n      return this.offset + this.length;\n    }\n  }]);\n\n  return Block;\n}();\n\nvar BlockGroup =\n/**\n *\n * @param {number} offset\n * @param {number} length\n * @param {number[]} blockIds\n */\nfunction BlockGroup(offset, length, blockIds) {\n  _classCallCheck(this, BlockGroup);\n\n  this.offset = offset;\n  this.length = length;\n  this.blockIds = blockIds;\n};\n\nexport var BlockedSource = /*#__PURE__*/function (_BaseSource) {\n  _inherits(BlockedSource, _BaseSource);\n\n  var _super = _createSuper(BlockedSource);\n\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  function BlockedSource(source) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$blockSize = _ref.blockSize,\n        blockSize = _ref$blockSize === void 0 ? 65536 : _ref$blockSize,\n        _ref$cacheSize = _ref.cacheSize,\n        cacheSize = _ref$cacheSize === void 0 ? 100 : _ref$cacheSize;\n\n    _classCallCheck(this, BlockedSource);\n\n    _this = _super.call(this);\n    _this.source = source;\n    _this.blockSize = blockSize;\n    _this.blockCache = new LRUCache({\n      max: cacheSize\n    }); // mapping blockId -> Block instance\n\n    _this.blockRequests = new Map(); // set of blockIds missing for the current requests\n\n    _this.blockIdsToFetch = new Set();\n    _this.abortedBlockIds = new Set();\n    return _this;\n  }\n\n  _createClass(BlockedSource, [{\n    key: \"fetch\",\n\n    /**\n     *\n     * @param {basesource/Slice[]} slices\n     */\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(slices, signal) {\n        var _this2 = this;\n\n        var blockRequests, missingBlockIds, allBlockIds, _iterator, _step, _step$value, offset, length, top, fileSize, firstBlockOffset, current, _blockId2, missingRequests, _i, _missingBlockIds, blockId, abortedBlockRequests, abortedBlockIds, _iterator2, _step2, _blockId, block, blocks, failedBlocks, requiredBlocks;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                blockRequests = [];\n                missingBlockIds = [];\n                allBlockIds = [];\n                _iterator = _createForOfIteratorHelper(slices);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _step$value = _step.value, offset = _step$value.offset, length = _step$value.length;\n                    top = offset + length;\n                    fileSize = this.fileSize;\n\n                    if (fileSize !== null) {\n                      top = Math.min(top, fileSize);\n                    }\n\n                    firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n                    for (current = firstBlockOffset; current < top; current += this.blockSize) {\n                      _blockId2 = Math.floor(current / this.blockSize);\n\n                      if (!this.blockCache.has(_blockId2) && !this.blockRequests.has(_blockId2)) {\n                        this.blockIdsToFetch.add(_blockId2);\n                        missingBlockIds.push(_blockId2);\n                      }\n\n                      if (this.blockRequests.has(_blockId2)) {\n                        blockRequests.push(this.blockRequests.get(_blockId2));\n                      }\n\n                      allBlockIds.push(_blockId2);\n                    }\n                  } // allow additional block requests to accumulate\n\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context.next = 7;\n                return wait();\n\n              case 7:\n                this.fetchBlocks(signal); // Gather all of the new requests that this fetch call is contributing to `fetch`.\n\n                missingRequests = [];\n\n                for (_i = 0, _missingBlockIds = missingBlockIds; _i < _missingBlockIds.length; _i++) {\n                  blockId = _missingBlockIds[_i];\n\n                  // The requested missing block could already be in the cache\n                  // instead of having its request still be outstanding.\n                  if (this.blockRequests.has(blockId)) {\n                    missingRequests.push(this.blockRequests.get(blockId));\n                  }\n                } // Actually await all pending requests that are needed for this `fetch`.\n\n\n                _context.next = 12;\n                return Promise.allSettled(blockRequests.values());\n\n              case 12:\n                _context.next = 14;\n                return Promise.allSettled(missingRequests.values());\n\n              case 14:\n                // Perform retries if a block was interrupted by a previous signal\n                abortedBlockRequests = [];\n                abortedBlockIds = allBlockIds.filter(function (id) {\n                  return _this2.abortedBlockIds.has(id) || !_this2.blockCache.has(id);\n                });\n                abortedBlockIds.forEach(function (id) {\n                  return _this2.blockIdsToFetch.add(id);\n                }); // start the retry of some blocks if required\n\n                if (!(abortedBlockIds.length > 0 && signal && !signal.aborted)) {\n                  _context.next = 40;\n                  break;\n                }\n\n                this.fetchBlocks(null);\n                _iterator2 = _createForOfIteratorHelper(abortedBlockIds);\n                _context.prev = 20;\n\n                _iterator2.s();\n\n              case 22:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 30;\n                  break;\n                }\n\n                _blockId = _step2.value;\n                block = this.blockRequests.get(_blockId);\n\n                if (block) {\n                  _context.next = 27;\n                  break;\n                }\n\n                throw new Error(\"Block \".concat(_blockId, \" is not in the block requests\"));\n\n              case 27:\n                abortedBlockRequests.push(block);\n\n              case 28:\n                _context.next = 22;\n                break;\n\n              case 30:\n                _context.next = 35;\n                break;\n\n              case 32:\n                _context.prev = 32;\n                _context.t0 = _context[\"catch\"](20);\n\n                _iterator2.e(_context.t0);\n\n              case 35:\n                _context.prev = 35;\n\n                _iterator2.f();\n\n                return _context.finish(35);\n\n              case 38:\n                _context.next = 40;\n                return Promise.allSettled(Array.from(abortedBlockRequests.values()));\n\n              case 40:\n                if (!(signal && signal.aborted)) {\n                  _context.next = 42;\n                  break;\n                }\n\n                throw new AbortError('Request was aborted');\n\n              case 42:\n                blocks = allBlockIds.map(function (id) {\n                  return _this2.blockCache.get(id);\n                });\n                failedBlocks = blocks.filter(function (i) {\n                  return !i;\n                });\n\n                if (!failedBlocks.length) {\n                  _context.next = 46;\n                  break;\n                }\n\n                throw new AggregateError(failedBlocks, 'Request failed');\n\n              case 46:\n                // create a final Map, with all required blocks for this request to satisfy\n                requiredBlocks = new Map(zip(allBlockIds, blocks)); // TODO: satisfy each slice\n\n                return _context.abrupt(\"return\", this.readSliceData(slices, requiredBlocks));\n\n              case 48:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[20, 32, 35, 38]]);\n      }));\n\n      function fetch(_x, _x2) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n    /**\n     *\n     * @param {AbortSignal} signal\n     */\n\n  }, {\n    key: \"fetchBlocks\",\n    value: function fetchBlocks(signal) {\n      var _this3 = this;\n\n      // check if we still need to\n      if (this.blockIdsToFetch.size > 0) {\n        (function () {\n          var groups = _this3.groupBlocks(_this3.blockIdsToFetch); // start requesting slices of data\n\n\n          var groupRequests = _this3.source.fetch(groups, signal);\n\n          var _loop = function _loop(groupIndex) {\n            var group = groups[groupIndex];\n\n            var _iterator3 = _createForOfIteratorHelper(group.blockIds),\n                _step3;\n\n            try {\n              var _loop2 = function _loop2() {\n                var blockId = _step3.value;\n\n                // make an async IIFE for each block\n                _this3.blockRequests.set(blockId, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  var response, blockOffset, o, t, data, block;\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.prev = 0;\n                          _context2.next = 3;\n                          return groupRequests;\n\n                        case 3:\n                          _context2.t0 = groupIndex;\n                          response = _context2.sent[_context2.t0];\n                          blockOffset = blockId * _this3.blockSize;\n                          o = blockOffset - response.offset;\n                          t = Math.min(o + _this3.blockSize, response.data.byteLength);\n                          data = response.data.slice(o, t);\n                          block = new Block(blockOffset, data.byteLength, data, blockId);\n\n                          _this3.blockCache.set(blockId, block);\n\n                          _this3.abortedBlockIds.delete(blockId);\n\n                          _context2.next = 23;\n                          break;\n\n                        case 14:\n                          _context2.prev = 14;\n                          _context2.t1 = _context2[\"catch\"](0);\n\n                          if (!(_context2.t1.name === 'AbortError')) {\n                            _context2.next = 22;\n                            break;\n                          }\n\n                          // store the signal here, we need it to determine later if an\n                          // error was caused by this signal\n                          _context2.t1.signal = signal;\n\n                          _this3.blockCache.del(blockId);\n\n                          _this3.abortedBlockIds.add(blockId);\n\n                          _context2.next = 23;\n                          break;\n\n                        case 22:\n                          throw _context2.t1;\n\n                        case 23:\n                          _context2.prev = 23;\n\n                          _this3.blockRequests.delete(blockId);\n\n                          return _context2.finish(23);\n\n                        case 26:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[0, 14, 23, 26]]);\n                }))());\n              };\n\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          };\n\n          for (var groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n            _loop(groupIndex);\n          }\n\n          _this3.blockIdsToFetch.clear();\n        })();\n      }\n    }\n    /**\n     *\n     * @param {Set} blockIds\n     * @returns {BlockGroup[]}\n     */\n\n  }, {\n    key: \"groupBlocks\",\n    value: function groupBlocks(blockIds) {\n      var sortedBlockIds = Array.from(blockIds).sort(function (a, b) {\n        return a - b;\n      });\n\n      if (sortedBlockIds.length === 0) {\n        return [];\n      }\n\n      var current = [];\n      var lastBlockId = null;\n      var groups = [];\n\n      var _iterator4 = _createForOfIteratorHelper(sortedBlockIds),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var blockId = _step4.value;\n\n          if (lastBlockId === null || lastBlockId + 1 === blockId) {\n            current.push(blockId);\n            lastBlockId = blockId;\n          } else {\n            groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n            current = [blockId];\n            lastBlockId = blockId;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n      return groups;\n    }\n    /**\n     *\n     * @param {Slice[]} slices\n     * @param {Map} blocks\n     */\n\n  }, {\n    key: \"readSliceData\",\n    value: function readSliceData(slices, blocks) {\n      var _this4 = this;\n\n      return slices.map(function (slice) {\n        var top = slice.offset + slice.length;\n\n        if (_this4.fileSize !== null) {\n          top = Math.min(_this4.fileSize, top);\n        }\n\n        var blockIdLow = Math.floor(slice.offset / _this4.blockSize);\n        var blockIdHigh = Math.floor(top / _this4.blockSize);\n        var sliceData = new ArrayBuffer(slice.length);\n        var sliceView = new Uint8Array(sliceData);\n\n        for (var blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n          var block = blocks.get(blockId);\n          var delta = block.offset - slice.offset;\n          var topDelta = block.top - top;\n          var blockInnerOffset = 0;\n          var rangeInnerOffset = 0;\n          var usedBlockLength = void 0;\n\n          if (delta < 0) {\n            blockInnerOffset = -delta;\n          } else if (delta > 0) {\n            rangeInnerOffset = delta;\n          }\n\n          if (topDelta < 0) {\n            usedBlockLength = block.length - blockInnerOffset;\n          } else {\n            usedBlockLength = top - block.offset - blockInnerOffset;\n          }\n\n          var blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n          sliceView.set(blockView, rangeInnerOffset);\n        }\n\n        return sliceData;\n      });\n    }\n  }, {\n    key: \"fileSize\",\n    get: function get() {\n      return this.source.fileSize;\n    }\n  }]);\n\n  return BlockedSource;\n}(BaseSource);","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/geotiff/src/source/blockedsource.js"],"names":["LRUCache","BaseSource","AbortError","AggregateError","wait","zip","Block","offset","length","data","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","max","blockRequests","Map","blockIdsToFetch","Set","abortedBlockIds","slices","signal","missingBlockIds","allBlockIds","top","fileSize","Math","min","firstBlockOffset","floor","current","blockId","has","add","push","get","fetchBlocks","missingRequests","Promise","allSettled","values","abortedBlockRequests","filter","id","forEach","aborted","block","Error","Array","from","blocks","map","failedBlocks","i","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","fetch","groupIndex","group","set","response","blockOffset","o","t","byteLength","slice","delete","name","del","clear","sortedBlockIds","sort","a","b","lastBlockId","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","Uint8Array","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView"],"mappings":"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","sourcesContent":["import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource';\nimport { AbortError, AggregateError, wait, zip } from '../utils';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = []\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests.values());\n    await Promise.allSettled(missingRequests.values());\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter(id => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach(id => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(Array.from(abortedBlockRequests.values()));\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.del(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}