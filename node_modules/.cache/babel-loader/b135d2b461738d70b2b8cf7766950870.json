{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n  var _a, _b, _c, _d;\n\n  const {\n    config,\n    encoding,\n    markDef\n  } = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const channelDef = encoding[channel];\n  const channelDef2 = encoding[channel2];\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaleName = model.scaleName(channel);\n  const orient = markDef.orient;\n  const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal'); // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !hasDiscreteDomain(scaleType)) {\n    const bandSize = getBandSize({\n      channel,\n      fieldDef: channelDef,\n      markDef,\n      config,\n      scaleType\n    });\n    const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n    const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel,\n      markDef,\n      scaleName,\n      bandSize,\n      axisTranslate,\n      spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n      reverse: scale.get('reverse'),\n      config\n    });\n  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType) || isBarBand) && !channelDef2) {\n    return positionAndSize(channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {\n  if (isRelativeBandSize(bandSize)) {\n    if (scale) {\n      const scaleType = scale.get('type');\n\n      if (scaleType === 'band') {\n        return {\n          scale: scaleName,\n          band: bandSize.band\n        };\n      } else if (bandSize.band !== 1) {\n        log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n        bandSize = undefined;\n      }\n    } else {\n      return {\n        mult: bandSize.band,\n        field: {\n          group: sizeChannel\n        }\n      };\n    }\n  } else if (isSignalRef(bandSize)) {\n    return bandSize;\n  } else if (bandSize) {\n    return {\n      value: bandSize\n    };\n  } // no valid band size\n\n\n  if (scale) {\n    const scaleRange = scale.get('range');\n\n    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n      return {\n        value: scaleRange.step - 2\n      };\n    }\n  }\n\n  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n  return {\n    value: defaultStep - 2\n  };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\n\n\nfunction positionAndSize(fieldDef, channel, model) {\n  const {\n    markDef,\n    encoding,\n    config,\n    stack\n  } = model;\n  const orient = markDef.orient;\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const vgSizeChannel = getSizeChannel(channel);\n  const channel2 = getSecondaryRangeChannel(channel); // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n\n  const useVlSizeChannel = orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x'; // Use size encoding / mark property / config if it exists\n\n  let sizeMixins;\n\n  if (encoding.size || markDef.size) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultRef: signalOrValueRef(markDef.size)\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  } // Otherwise, apply default value\n\n\n  const bandSize = getBandSize({\n    channel,\n    fieldDef,\n    markDef,\n    config,\n    scaleType: scale === null || scale === void 0 ? void 0 : scale.get('type'),\n    useVlSizeChannel\n  });\n  sizeMixins = sizeMixins || {\n    [vgSizeChannel]: defaultSizeRef(vgSizeChannel, scaleName, scale, config, bandSize)\n  };\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n       Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n\n  const defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]) ? 'middle' : 'top';\n  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n  const center = vgChannel === 'xc' || vgChannel === 'yc';\n  const offset = getOffset(channel, markDef);\n  const posRef = ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: fieldDef,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: pointPositionDefaultRef({\n      model,\n      defaultPos: 'mid',\n      channel,\n      scaleName,\n      scale\n    }),\n    bandPosition: center ? 0.5 : isSignalRef(bandSize) ? {\n      signal: `(1-${bandSize})/2`\n    } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0\n  });\n\n  if (vgSizeChannel) {\n    return Object.assign({\n      [vgChannel]: posRef\n    }, sizeMixins);\n  } else {\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const sizeRef = sizeMixins[vgSizeChannel];\n    const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), {\n      offset\n    }) : sizeRef;\n    return {\n      [vgChannel]: posRef,\n      // posRef might be an array that wraps position invalid test\n      [vgChannel2]: isArray(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), {\n        offset: sizeOffset\n      })] : Object.assign(Object.assign({}, posRef), {\n        offset: sizeOffset\n      })\n    };\n  }\n}\n\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n\n  const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n    const reverseExpr = signalOrStringValue(reverse);\n    const offsetExpr = signalOrStringValue(offset);\n    const translateExpr = signalOrStringValue(translate);\n    const t = translateExpr ? `${translateExpr} + ` : '';\n    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n    const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\n\nexport function rectBinPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  bandSize,\n  scaleName,\n  markDef,\n  spacing = 0,\n  axisTranslate,\n  reverse,\n  config\n}) {\n  const channel2 = getSecondaryRangeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const vgChannel2 = getVgPositionChannel(channel2);\n  const offset = getOffset(channel, markDef);\n  const bandPosition = isSignalRef(bandSize) ? {\n    signal: `(1-${bandSize.signal})/2`\n  } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    return {\n      [vgChannel2]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        bandPosition,\n        offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n        config\n      }),\n      [vgChannel]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        bandPosition: isSignalRef(bandPosition) ? {\n          signal: `1-${bandPosition.signal}`\n        } : 1 - bandPosition,\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n        config\n      })\n    };\n  } else if (isBinned(fieldDef.bin)) {\n    const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n    });\n\n    if (isFieldDef(fieldDef2)) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {\n          offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n        })\n      };\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: {\n          signal: `scale(\"${scaleName}\", ${vgField(fieldDef, {\n            expr: 'datum'\n          })} + ${fieldDef.bin.step})`,\n          offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n        }\n      };\n    }\n  }\n\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function rectBinRef({\n  channel,\n  fieldDef,\n  scaleName,\n  markDef,\n  bandPosition,\n  offset,\n  config\n}) {\n  const r = ref.interpolatedSignalRef({\n    scaleName,\n    fieldOrDatumDef: fieldDef,\n    bandPosition,\n    offset\n  });\n  return ref.wrapPositionInvalidTest({\n    fieldDef,\n    channel,\n    markDef,\n    ref: r,\n    config\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-rect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n    var _a, _b, _c, _d;\n    const { config, encoding, markDef } = model;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const channelDef = encoding[channel];\n    const channelDef2 = encoding[channel2];\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const scaleName = model.scaleName(channel);\n    const orient = markDef.orient;\n    const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, { vgChannel: sizeChannel });\n    const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal');\n    // x, x2, and width -- we must specify two of these in all conditions\n    if (isFieldDef(channelDef) &&\n        (isBinning(channelDef.bin) || isBinned(channelDef.bin) || (channelDef.timeUnit && !channelDef2)) &&\n        !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) &&\n        !hasDiscreteDomain(scaleType)) {\n        const bandSize = getBandSize({ channel, fieldDef: channelDef, markDef, config, scaleType });\n        const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n        const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n        return rectBinPosition({\n            fieldDef: channelDef,\n            fieldDef2: channelDef2,\n            channel,\n            markDef,\n            scaleName,\n            bandSize,\n            axisTranslate,\n            spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n            reverse: scale.get('reverse'),\n            config\n        });\n    }\n    else if (((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType)) || isBarBand) && !channelDef2) {\n        return positionAndSize(channelDef, channel, model);\n    }\n    else {\n        return rangePosition(channel, model, { defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin' });\n    }\n}\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {\n    if (isRelativeBandSize(bandSize)) {\n        if (scale) {\n            const scaleType = scale.get('type');\n            if (scaleType === 'band') {\n                return { scale: scaleName, band: bandSize.band };\n            }\n            else if (bandSize.band !== 1) {\n                log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n                bandSize = undefined;\n            }\n        }\n        else {\n            return {\n                mult: bandSize.band,\n                field: { group: sizeChannel }\n            };\n        }\n    }\n    else if (isSignalRef(bandSize)) {\n        return bandSize;\n    }\n    else if (bandSize) {\n        return { value: bandSize };\n    }\n    // no valid band size\n    if (scale) {\n        const scaleRange = scale.get('range');\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n            return { value: scaleRange.step - 2 };\n        }\n    }\n    const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n    return { value: defaultStep - 2 };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(fieldDef, channel, model) {\n    const { markDef, encoding, config, stack } = model;\n    const orient = markDef.orient;\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const vgSizeChannel = getSizeChannel(channel);\n    const channel2 = getSecondaryRangeChannel(channel);\n    // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n    const useVlSizeChannel = (orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x');\n    // Use size encoding / mark property / config if it exists\n    let sizeMixins;\n    if (encoding.size || markDef.size) {\n        if (useVlSizeChannel) {\n            sizeMixins = nonPosition('size', model, {\n                vgChannel: vgSizeChannel,\n                defaultRef: signalOrValueRef(markDef.size)\n            });\n        }\n        else {\n            log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n        }\n    }\n    // Otherwise, apply default value\n    const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scale === null || scale === void 0 ? void 0 : scale.get('type'), useVlSizeChannel });\n    sizeMixins = sizeMixins || { [vgSizeChannel]: defaultSizeRef(vgSizeChannel, scaleName, scale, config, bandSize) };\n    /*\n      Band scales with size value and all point scales, use xc/yc + band=0.5\n  \n      Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n      In this case, size_band is the band specified in the x/y-encoding.\n      By default band is 1, so `(1 - band) / 2` = 0.\n      If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n     */\n    const defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]) ? 'middle' : 'top';\n    const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n    const center = vgChannel === 'xc' || vgChannel === 'yc';\n    const offset = getOffset(channel, markDef);\n    const posRef = ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: fieldDef,\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: pointPositionDefaultRef({ model, defaultPos: 'mid', channel, scaleName, scale }),\n        bandPosition: center\n            ? 0.5\n            : isSignalRef(bandSize)\n                ? { signal: `(1-${bandSize})/2` }\n                : isRelativeBandSize(bandSize)\n                    ? (1 - bandSize.band) / 2\n                    : 0\n    });\n    if (vgSizeChannel) {\n        return Object.assign({ [vgChannel]: posRef }, sizeMixins);\n    }\n    else {\n        // otherwise, we must simulate size by setting position2 = position + size\n        // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n        const vgChannel2 = getVgPositionChannel(channel2);\n        const sizeRef = sizeMixins[vgSizeChannel];\n        const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), { offset }) : sizeRef;\n        return {\n            [vgChannel]: posRef,\n            // posRef might be an array that wraps position invalid test\n            [vgChannel2]: isArray(posRef)\n                ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })]\n                : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })\n        };\n    }\n}\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n    if (isPolarPositionChannel(channel)) {\n        return 0;\n    }\n    const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n    if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n        const reverseExpr = signalOrStringValue(reverse);\n        const offsetExpr = signalOrStringValue(offset);\n        const translateExpr = signalOrStringValue(translate);\n        const t = translateExpr ? `${translateExpr} + ` : '';\n        const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n        const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n        return {\n            signal: t + r + o\n        };\n    }\n    else {\n        offset = offset || 0;\n        return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n    }\n}\nexport function rectBinPosition({ fieldDef, fieldDef2, channel, bandSize, scaleName, markDef, spacing = 0, axisTranslate, reverse, config }) {\n    const channel2 = getSecondaryRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const offset = getOffset(channel, markDef);\n    const bandPosition = isSignalRef(bandSize)\n        ? { signal: `(1-${bandSize.signal})/2` }\n        : isRelativeBandSize(bandSize)\n            ? (1 - bandSize.band) / 2\n            : 0.5;\n    if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n        return {\n            [vgChannel2]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                bandPosition,\n                offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n                config\n            }),\n            [vgChannel]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                bandPosition: isSignalRef(bandPosition) ? { signal: `1-${bandPosition.signal}` } : 1 - bandPosition,\n                offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n                config\n            })\n        };\n    }\n    else if (isBinned(fieldDef.bin)) {\n        const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset) });\n        if (isFieldDef(fieldDef2)) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset) })\n            };\n        }\n        else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: {\n                    signal: `scale(\"${scaleName}\", ${vgField(fieldDef, { expr: 'datum' })} + ${fieldDef.bin.step})`,\n                    offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n                }\n            };\n        }\n    }\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n}\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef({ channel, fieldDef, scaleName, markDef, bandPosition, offset, config }) {\n    const r = ref.interpolatedSignalRef({\n        scaleName,\n        fieldOrDatumDef: fieldDef,\n        bandPosition,\n        offset\n    });\n    return ref.wrapPositionInvalidTest({\n        fieldDef,\n        channel,\n        markDef,\n        ref: r,\n        config\n    });\n}\n//# sourceMappingURL=position-rect.js.map"]},"metadata":{},"sourceType":"module"}