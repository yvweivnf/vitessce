{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport DebugLogger from \"debug\";\nimport { multicast, Observable, Subject } from \"observable-fns\";\nimport { allSettled } from \"../ponyfills\";\nimport { defaultPoolSize } from \"./implementation\";\nimport { PoolEventType } from \"./pool-types\";\nimport { Thread } from \"./thread\";\nexport { PoolEventType, Thread };\nvar nextPoolID = 1;\n\nfunction createArray(size) {\n  var array = [];\n\n  for (var index = 0; index < size; index++) {\n    array.push(index);\n  }\n\n  return array;\n}\n\nfunction delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n\nfunction flatMap(array, mapper) {\n  return array.reduce(function (flattened, element) {\n    return [].concat(_toConsumableArray(flattened), _toConsumableArray(mapper(element)));\n  }, []);\n}\n\nfunction slugify(text) {\n  return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\n\nfunction spawnWorkers(spawnWorker, count) {\n  return createArray(count).map(function () {\n    return {\n      init: spawnWorker(),\n      runningTasks: []\n    };\n  });\n}\n\nvar WorkerPool = /*#__PURE__*/function () {\n  function WorkerPool(spawnWorker, optionsOrSize) {\n    var _this = this;\n\n    _classCallCheck(this, WorkerPool);\n\n    this.eventSubject = new Subject();\n    this.initErrors = [];\n    this.isClosing = false;\n    this.nextTaskID = 1;\n    this.taskQueue = [];\n    var options = typeof optionsOrSize === \"number\" ? {\n      size: optionsOrSize\n    } : optionsOrSize || {};\n    var _options$size = options.size,\n        size = _options$size === void 0 ? defaultPoolSize : _options$size;\n    this.debug = DebugLogger(\"threads:pool:\".concat(slugify(options.name || String(nextPoolID++))));\n    this.options = options;\n    this.workers = spawnWorkers(spawnWorker, size);\n    this.eventObservable = multicast(Observable.from(this.eventSubject));\n    Promise.all(this.workers.map(function (worker) {\n      return worker.init;\n    })).then(function () {\n      return _this.eventSubject.next({\n        type: PoolEventType.initialized,\n        size: _this.workers.length\n      });\n    }, function (error) {\n      _this.debug(\"Error while initializing pool worker:\", error);\n\n      _this.eventSubject.error(error);\n\n      _this.initErrors.push(error);\n    });\n  }\n\n  _createClass(WorkerPool, [{\n    key: \"findIdlingWorker\",\n    value: function findIdlingWorker() {\n      var _this$options$concurr = this.options.concurrency,\n          concurrency = _this$options$concurr === void 0 ? 1 : _this$options$concurr;\n      return this.workers.find(function (worker) {\n        return worker.runningTasks.length < concurrency;\n      });\n    }\n  }, {\n    key: \"runPoolTask\",\n    value: function runPoolTask(worker, task) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var workerID, returnValue;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                workerID = this.workers.indexOf(worker) + 1;\n                this.debug(\"Running task #\".concat(task.id, \" on worker #\").concat(workerID, \"...\"));\n                this.eventSubject.next({\n                  type: PoolEventType.taskStart,\n                  taskID: task.id,\n                  workerID: workerID\n                });\n                _context.prev = 3;\n                _context.t0 = task;\n                _context.next = 7;\n                return worker.init;\n\n              case 7:\n                _context.t1 = _context.sent;\n                _context.next = 10;\n                return _context.t0.run.call(_context.t0, _context.t1);\n\n              case 10:\n                returnValue = _context.sent;\n                this.debug(\"Task #\".concat(task.id, \" completed successfully\"));\n                this.eventSubject.next({\n                  type: PoolEventType.taskCompleted,\n                  returnValue: returnValue,\n                  taskID: task.id,\n                  workerID: workerID\n                });\n                _context.next = 19;\n                break;\n\n              case 15:\n                _context.prev = 15;\n                _context.t2 = _context[\"catch\"](3);\n                this.debug(\"Task #\".concat(task.id, \" failed\"));\n                this.eventSubject.next({\n                  type: PoolEventType.taskFailed,\n                  taskID: task.id,\n                  error: _context.t2,\n                  workerID: workerID\n                });\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 15]]);\n      }));\n    }\n  }, {\n    key: \"run\",\n    value: function run(worker, task) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var runPromise;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                runPromise = function () {\n                  return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                    var removeTaskFromWorkersRunningTasks;\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            removeTaskFromWorkersRunningTasks = function removeTaskFromWorkersRunningTasks() {\n                              worker.runningTasks = worker.runningTasks.filter(function (someRunPromise) {\n                                return someRunPromise !== runPromise;\n                              });\n                            }; // Defer task execution by one tick to give handlers time to subscribe\n\n\n                            _context2.next = 3;\n                            return delay(0);\n\n                          case 3:\n                            _context2.prev = 3;\n                            _context2.next = 6;\n                            return this.runPoolTask(worker, task);\n\n                          case 6:\n                            _context2.prev = 6;\n                            removeTaskFromWorkersRunningTasks();\n\n                            if (!this.isClosing) {\n                              this.scheduleWork();\n                            }\n\n                            return _context2.finish(6);\n\n                          case 10:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, this, [[3,, 6, 10]]);\n                  }));\n                }();\n\n                worker.runningTasks.push(runPromise);\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n    }\n  }, {\n    key: \"scheduleWork\",\n    value: function scheduleWork() {\n      this.debug(\"Attempt de-queueing a task in order to run it...\");\n      var availableWorker = this.findIdlingWorker();\n      if (!availableWorker) return;\n      var nextTask = this.taskQueue.shift();\n\n      if (!nextTask) {\n        this.debug(\"Task queue is empty\");\n        this.eventSubject.next({\n          type: PoolEventType.taskQueueDrained\n        });\n        return;\n      }\n\n      this.run(availableWorker, nextTask);\n    }\n  }, {\n    key: \"taskCompletion\",\n    value: function taskCompletion(taskID) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var eventSubscription = _this3.events().subscribe(function (event) {\n          if (event.type === PoolEventType.taskCompleted && event.taskID === taskID) {\n            eventSubscription.unsubscribe();\n            resolve(event.returnValue);\n          } else if (event.type === PoolEventType.taskFailed && event.taskID === taskID) {\n            eventSubscription.unsubscribe();\n            reject(event.error);\n          } else if (event.type === PoolEventType.terminated) {\n            eventSubscription.unsubscribe();\n            reject(Error(\"Pool has been terminated before task was run.\"));\n          }\n        });\n      });\n    }\n  }, {\n    key: \"settled\",\n    value: function settled() {\n      var allowResolvingImmediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this4 = this;\n\n        var getCurrentlyRunningTasks, taskFailures, failureSubscription;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                getCurrentlyRunningTasks = function getCurrentlyRunningTasks() {\n                  return flatMap(_this4.workers, function (worker) {\n                    return worker.runningTasks;\n                  });\n                };\n\n                taskFailures = [];\n                failureSubscription = this.eventObservable.subscribe(function (event) {\n                  if (event.type === PoolEventType.taskFailed) {\n                    taskFailures.push(event.error);\n                  }\n                });\n\n                if (!(this.initErrors.length > 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.reject(this.initErrors[0]));\n\n              case 5:\n                if (!(allowResolvingImmediately && this.taskQueue.length === 0)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                _context4.next = 8;\n                return allSettled(getCurrentlyRunningTasks());\n\n              case 8:\n                return _context4.abrupt(\"return\", taskFailures);\n\n              case 9:\n                _context4.next = 11;\n                return new Promise(function (resolve, reject) {\n                  var subscription = _this4.eventObservable.subscribe({\n                    next: function next(event) {\n                      if (event.type === PoolEventType.taskQueueDrained) {\n                        subscription.unsubscribe();\n                        resolve(void 0);\n                      }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n\n                  });\n                });\n\n              case 11:\n                _context4.next = 13;\n                return allSettled(getCurrentlyRunningTasks());\n\n              case 13:\n                failureSubscription.unsubscribe();\n                return _context4.abrupt(\"return\", taskFailures);\n\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"completed\",\n    value: function completed() {\n      var allowResolvingImmediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this5 = this;\n\n        var settlementPromise, earlyExitPromise, errors;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                settlementPromise = this.settled(allowResolvingImmediately);\n                earlyExitPromise = new Promise(function (resolve, reject) {\n                  var subscription = _this5.eventObservable.subscribe({\n                    next: function next(event) {\n                      if (event.type === PoolEventType.taskQueueDrained) {\n                        subscription.unsubscribe();\n                        resolve(settlementPromise);\n                      } else if (event.type === PoolEventType.taskFailed) {\n                        subscription.unsubscribe();\n                        reject(event.error);\n                      }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n\n                  });\n                });\n                _context5.next = 4;\n                return Promise.race([settlementPromise, earlyExitPromise]);\n\n              case 4:\n                errors = _context5.sent;\n\n                if (!(errors.length > 0)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                throw errors[0];\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"events\",\n    value: function events() {\n      return this.eventObservable;\n    }\n  }, {\n    key: \"queue\",\n    value: function queue(taskFunction) {\n      var _this6 = this;\n\n      var _this$options$maxQueu = this.options.maxQueuedJobs,\n          maxQueuedJobs = _this$options$maxQueu === void 0 ? Infinity : _this$options$maxQueu;\n\n      if (this.isClosing) {\n        throw Error(\"Cannot schedule pool tasks after terminate() has been called.\");\n      }\n\n      if (this.initErrors.length > 0) {\n        throw this.initErrors[0];\n      }\n\n      var taskID = this.nextTaskID++;\n      var taskCompletion = this.taskCompletion(taskID);\n      taskCompletion.catch(function (error) {\n        // Prevent unhandled rejections here as we assume the user will use\n        // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n        _this6.debug(\"Task #\".concat(taskID, \" errored:\"), error);\n      });\n      var task = {\n        id: taskID,\n        run: taskFunction,\n        cancel: function cancel() {\n          if (_this6.taskQueue.indexOf(task) === -1) return;\n          _this6.taskQueue = _this6.taskQueue.filter(function (someTask) {\n            return someTask !== task;\n          });\n\n          _this6.eventSubject.next({\n            type: PoolEventType.taskCanceled,\n            taskID: task.id\n          });\n        },\n        then: taskCompletion.then.bind(taskCompletion)\n      };\n\n      if (this.taskQueue.length >= maxQueuedJobs) {\n        throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" + \"This usually happens for one of two reasons: We are either at peak \" + \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n      }\n\n      this.debug(\"Queueing task #\".concat(task.id, \"...\"));\n      this.taskQueue.push(task);\n      this.eventSubject.next({\n        type: PoolEventType.taskQueued,\n        taskID: task.id\n      });\n      this.scheduleWork();\n      return task;\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate(force) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this7 = this;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this.isClosing = true;\n\n                if (force) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                _context7.next = 4;\n                return this.completed(true);\n\n              case 4:\n                this.eventSubject.next({\n                  type: PoolEventType.terminated,\n                  remainingQueue: _toConsumableArray(this.taskQueue)\n                });\n                this.eventSubject.complete();\n                _context7.next = 8;\n                return Promise.all(this.workers.map(function (worker) {\n                  return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.t0 = Thread;\n                            _context6.next = 3;\n                            return worker.init;\n\n                          case 3:\n                            _context6.t1 = _context6.sent;\n                            return _context6.abrupt(\"return\", _context6.t0.terminate.call(_context6.t0, _context6.t1));\n\n                          case 5:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n                }));\n\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }]);\n\n  return WorkerPool;\n}();\n\nWorkerPool.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\n\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n  // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n  // If the Pool is a class or not is an implementation detail that should not concern the user.\n  return new WorkerPool(spawnWorker, optionsOrSize);\n}\n\nPoolConstructor.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\n\nexport var Pool = PoolConstructor;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/master/pool.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","DebugLogger","multicast","Observable","Subject","allSettled","defaultPoolSize","PoolEventType","Thread","nextPoolID","createArray","size","array","index","push","delay","ms","setTimeout","flatMap","mapper","reduce","flattened","element","slugify","text","replace","trim","spawnWorkers","spawnWorker","count","map","init","runningTasks","WorkerPool","optionsOrSize","eventSubject","initErrors","isClosing","nextTaskID","taskQueue","options","debug","name","String","workers","eventObservable","from","all","worker","type","initialized","length","error","concurrency","find","task","workerID","indexOf","id","taskStart","taskID","run","returnValue","taskCompleted","taskFailed","runPromise","removeTaskFromWorkersRunningTasks","filter","someRunPromise","runPoolTask","scheduleWork","availableWorker","findIdlingWorker","nextTask","shift","taskQueueDrained","eventSubscription","events","subscribe","event","unsubscribe","terminated","Error","allowResolvingImmediately","getCurrentlyRunningTasks","taskFailures","failureSubscription","subscription","settlementPromise","settled","earlyExitPromise","race","errors","taskFunction","maxQueuedJobs","Infinity","taskCompletion","catch","cancel","someTask","taskCanceled","bind","taskQueued","force","completed","remainingQueue","complete","terminate","EventType","PoolConstructor","Pool"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DebugLogger from \"debug\";\nimport { multicast, Observable, Subject } from \"observable-fns\";\nimport { allSettled } from \"../ponyfills\";\nimport { defaultPoolSize } from \"./implementation\";\nimport { PoolEventType } from \"./pool-types\";\nimport { Thread } from \"./thread\";\nexport { PoolEventType, Thread };\nlet nextPoolID = 1;\nfunction createArray(size) {\n    const array = [];\n    for (let index = 0; index < size; index++) {\n        array.push(index);\n    }\n    return array;\n}\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction flatMap(array, mapper) {\n    return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\nfunction slugify(text) {\n    return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n    return createArray(count).map(() => ({\n        init: spawnWorker(),\n        runningTasks: []\n    }));\n}\nclass WorkerPool {\n    constructor(spawnWorker, optionsOrSize) {\n        this.eventSubject = new Subject();\n        this.initErrors = [];\n        this.isClosing = false;\n        this.nextTaskID = 1;\n        this.taskQueue = [];\n        const options = typeof optionsOrSize === \"number\"\n            ? { size: optionsOrSize }\n            : optionsOrSize || {};\n        const { size = defaultPoolSize } = options;\n        this.debug = DebugLogger(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n        this.options = options;\n        this.workers = spawnWorkers(spawnWorker, size);\n        this.eventObservable = multicast(Observable.from(this.eventSubject));\n        Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n            type: PoolEventType.initialized,\n            size: this.workers.length\n        }), error => {\n            this.debug(\"Error while initializing pool worker:\", error);\n            this.eventSubject.error(error);\n            this.initErrors.push(error);\n        });\n    }\n    findIdlingWorker() {\n        const { concurrency = 1 } = this.options;\n        return this.workers.find(worker => worker.runningTasks.length < concurrency);\n    }\n    runPoolTask(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workerID = this.workers.indexOf(worker) + 1;\n            this.debug(`Running task #${task.id} on worker #${workerID}...`);\n            this.eventSubject.next({\n                type: PoolEventType.taskStart,\n                taskID: task.id,\n                workerID\n            });\n            try {\n                const returnValue = yield task.run(yield worker.init);\n                this.debug(`Task #${task.id} completed successfully`);\n                this.eventSubject.next({\n                    type: PoolEventType.taskCompleted,\n                    returnValue,\n                    taskID: task.id,\n                    workerID\n                });\n            }\n            catch (error) {\n                this.debug(`Task #${task.id} failed`);\n                this.eventSubject.next({\n                    type: PoolEventType.taskFailed,\n                    taskID: task.id,\n                    error,\n                    workerID\n                });\n            }\n        });\n    }\n    run(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n                const removeTaskFromWorkersRunningTasks = () => {\n                    worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n                };\n                // Defer task execution by one tick to give handlers time to subscribe\n                yield delay(0);\n                try {\n                    yield this.runPoolTask(worker, task);\n                }\n                finally {\n                    removeTaskFromWorkersRunningTasks();\n                    if (!this.isClosing) {\n                        this.scheduleWork();\n                    }\n                }\n            }))();\n            worker.runningTasks.push(runPromise);\n        });\n    }\n    scheduleWork() {\n        this.debug(`Attempt de-queueing a task in order to run it...`);\n        const availableWorker = this.findIdlingWorker();\n        if (!availableWorker)\n            return;\n        const nextTask = this.taskQueue.shift();\n        if (!nextTask) {\n            this.debug(`Task queue is empty`);\n            this.eventSubject.next({ type: PoolEventType.taskQueueDrained });\n            return;\n        }\n        this.run(availableWorker, nextTask);\n    }\n    taskCompletion(taskID) {\n        return new Promise((resolve, reject) => {\n            const eventSubscription = this.events().subscribe(event => {\n                if (event.type === PoolEventType.taskCompleted && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    resolve(event.returnValue);\n                }\n                else if (event.type === PoolEventType.taskFailed && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    reject(event.error);\n                }\n                else if (event.type === PoolEventType.terminated) {\n                    eventSubscription.unsubscribe();\n                    reject(Error(\"Pool has been terminated before task was run.\"));\n                }\n            });\n        });\n    }\n    settled(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n            const taskFailures = [];\n            const failureSubscription = this.eventObservable.subscribe(event => {\n                if (event.type === PoolEventType.taskFailed) {\n                    taskFailures.push(event.error);\n                }\n            });\n            if (this.initErrors.length > 0) {\n                return Promise.reject(this.initErrors[0]);\n            }\n            if (allowResolvingImmediately && this.taskQueue.length === 0) {\n                yield allSettled(getCurrentlyRunningTasks());\n                return taskFailures;\n            }\n            yield new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(void 0);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            yield allSettled(getCurrentlyRunningTasks());\n            failureSubscription.unsubscribe();\n            return taskFailures;\n        });\n    }\n    completed(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const settlementPromise = this.settled(allowResolvingImmediately);\n            const earlyExitPromise = new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(settlementPromise);\n                        }\n                        else if (event.type === PoolEventType.taskFailed) {\n                            subscription.unsubscribe();\n                            reject(event.error);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            const errors = yield Promise.race([\n                settlementPromise,\n                earlyExitPromise\n            ]);\n            if (errors.length > 0) {\n                throw errors[0];\n            }\n        });\n    }\n    events() {\n        return this.eventObservable;\n    }\n    queue(taskFunction) {\n        const { maxQueuedJobs = Infinity } = this.options;\n        if (this.isClosing) {\n            throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n        }\n        if (this.initErrors.length > 0) {\n            throw this.initErrors[0];\n        }\n        const taskID = this.nextTaskID++;\n        const taskCompletion = this.taskCompletion(taskID);\n        taskCompletion.catch((error) => {\n            // Prevent unhandled rejections here as we assume the user will use\n            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n            this.debug(`Task #${taskID} errored:`, error);\n        });\n        const task = {\n            id: taskID,\n            run: taskFunction,\n            cancel: () => {\n                if (this.taskQueue.indexOf(task) === -1)\n                    return;\n                this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n                this.eventSubject.next({\n                    type: PoolEventType.taskCanceled,\n                    taskID: task.id\n                });\n            },\n            then: taskCompletion.then.bind(taskCompletion)\n        };\n        if (this.taskQueue.length >= maxQueuedJobs) {\n            throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" +\n                \"This usually happens for one of two reasons: We are either at peak \" +\n                \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n        }\n        this.debug(`Queueing task #${task.id}...`);\n        this.taskQueue.push(task);\n        this.eventSubject.next({\n            type: PoolEventType.taskQueued,\n            taskID: task.id\n        });\n        this.scheduleWork();\n        return task;\n    }\n    terminate(force) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.isClosing = true;\n            if (!force) {\n                yield this.completed(true);\n            }\n            this.eventSubject.next({\n                type: PoolEventType.terminated,\n                remainingQueue: [...this.taskQueue]\n            });\n            this.eventSubject.complete();\n            yield Promise.all(this.workers.map((worker) => __awaiter(this, void 0, void 0, function* () { return Thread.terminate(yield worker.init); })));\n        });\n    }\n}\nWorkerPool.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n    // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n    // If the Pool is a class or not is an implementation detail that should not concern the user.\n    return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexport const Pool = PoolConstructor;\n"]},"metadata":{},"sourceType":"module"}