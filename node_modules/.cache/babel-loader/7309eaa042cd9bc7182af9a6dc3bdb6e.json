{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { isWebGL, createGLContext, instrumentGLContext, resizeGLContext, resetParameters } from '@luma.gl/gltools';\nimport { requestAnimationFrame, cancelAnimationFrame, Query, lumaStats, Framebuffer, log, assert } from '@luma.gl/webgl';\nimport { isBrowser } from 'probe.gl/env';\nvar isPage = isBrowser() && typeof document !== 'undefined';\nvar statIdCounter = 0;\n\nvar AnimationLoop = /*#__PURE__*/function () {\n  function AnimationLoop() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, AnimationLoop);\n\n    var _props$onCreateContex = props.onCreateContext,\n        onCreateContext = _props$onCreateContex === void 0 ? function (opts) {\n      return createGLContext(opts);\n    } : _props$onCreateContex,\n        _props$onAddHTML = props.onAddHTML,\n        onAddHTML = _props$onAddHTML === void 0 ? null : _props$onAddHTML,\n        _props$onInitialize = props.onInitialize,\n        onInitialize = _props$onInitialize === void 0 ? function () {} : _props$onInitialize,\n        _props$onRender = props.onRender,\n        onRender = _props$onRender === void 0 ? function () {} : _props$onRender,\n        _props$onFinalize = props.onFinalize,\n        onFinalize = _props$onFinalize === void 0 ? function () {} : _props$onFinalize,\n        onError = props.onError,\n        _props$gl = props.gl,\n        gl = _props$gl === void 0 ? null : _props$gl,\n        _props$glOptions = props.glOptions,\n        glOptions = _props$glOptions === void 0 ? {} : _props$glOptions,\n        _props$debug = props.debug,\n        debug = _props$debug === void 0 ? false : _props$debug,\n        _props$createFramebuf = props.createFramebuffer,\n        createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf,\n        _props$autoResizeView = props.autoResizeViewport,\n        autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView,\n        _props$autoResizeDraw = props.autoResizeDrawingBuffer,\n        autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw,\n        _props$stats = props.stats,\n        stats = _props$stats === void 0 ? lumaStats.get(\"animation-loop-\".concat(statIdCounter++)) : _props$stats;\n    var _props$useDevicePixel = props.useDevicePixels,\n        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext: onCreateContext,\n      onAddHTML: onAddHTML,\n      onInitialize: onInitialize,\n      onRender: onRender,\n      onFinalize: onFinalize,\n      onError: onError,\n      gl: gl,\n      glOptions: glOptions,\n      debug: debug,\n      createFramebuffer: createFramebuffer\n    };\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n    this.setProps({\n      autoResizeViewport: autoResizeViewport,\n      autoResizeDrawingBuffer: autoResizeDrawingBuffer,\n      useDevicePixels: useDevicePixels\n    });\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._pageLoadPromise = null;\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  _createClass(AnimationLoop, [{\n    key: \"delete\",\n    value: function _delete() {\n      this.stop();\n\n      this._setDisplay(null);\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      assert(typeof reason === 'string');\n      this.needsRedraw = this.needsRedraw || reason;\n      return this;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('autoResizeViewport' in props) {\n        this.autoResizeViewport = props.autoResizeViewport;\n      }\n\n      if ('autoResizeDrawingBuffer' in props) {\n        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n      }\n\n      if ('useDevicePixels' in props) {\n        this.useDevicePixels = props.useDevicePixels;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._running) {\n        return this;\n      }\n\n      this._running = true;\n\n      var startPromise = this._getPageLoadPromise().then(function () {\n        if (!_this._running || _this._initialized) {\n          return null;\n        }\n\n        _this._createWebGLContext(opts);\n\n        _this._createFramebuffer();\n\n        _this._startEventHandling();\n\n        _this._initializeCallbackData();\n\n        _this._updateCallbackData();\n\n        _this._resizeCanvasDrawingBuffer();\n\n        _this._resizeViewport();\n\n        _this._gpuTimeQuery = Query.isSupported(_this.gl, ['timers']) ? new Query(_this.gl) : null;\n        _this._initialized = true;\n        return _this.onInitialize(_this.animationProps);\n      }).then(function (appContext) {\n        if (_this._running) {\n          _this._addCallbackData(appContext || {});\n\n          if (appContext !== false) {\n            _this._startLoop();\n          }\n        }\n      });\n\n      if (this.props.onError) {\n        startPromise.catch(this.props.onError);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      if (this.isContextLost()) {\n        return this;\n      }\n\n      this._beginTimers();\n\n      this._setupFrame();\n\n      this._updateCallbackData();\n\n      this._renderFrame(this.animationProps);\n\n      this._clearNeedsRedraw();\n\n      if (this.offScreen && this.gl.commit) {\n        this.gl.commit();\n      }\n\n      if (this._resolveNextFrame) {\n        this._resolveNextFrame(this);\n\n        this._nextFramePromise = null;\n        this._resolveNextFrame = null;\n      }\n\n      this._endTimers();\n\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._running) {\n        this._finalizeCallbackData();\n\n        this._cancelAnimationFrame(this._animationFrameId);\n\n        this._nextFramePromise = null;\n        this._resolveNextFrame = null;\n        this._animationFrameId = null;\n        this._running = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"attachTimeline\",\n    value: function attachTimeline(timeline) {\n      this.timeline = timeline;\n      return this.timeline;\n    }\n  }, {\n    key: \"detachTimeline\",\n    value: function detachTimeline() {\n      this.timeline = null;\n    }\n  }, {\n    key: \"waitForRender\",\n    value: function waitForRender() {\n      var _this2 = this;\n\n      this.setNeedsRedraw('waitForRender');\n\n      if (!this._nextFramePromise) {\n        this._nextFramePromise = new Promise(function (resolve) {\n          _this2._resolveNextFrame = resolve;\n        });\n      }\n\n      return this._nextFramePromise;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function () {\n      var _toDataURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.setNeedsRedraw('toDataURL');\n                _context.next = 3;\n                return this.waitForRender();\n\n              case 3:\n                return _context.abrupt(\"return\", this.gl.canvas.toDataURL());\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function toDataURL() {\n        return _toDataURL.apply(this, arguments);\n      }\n\n      return toDataURL;\n    }()\n  }, {\n    key: \"isContextLost\",\n    value: function isContextLost() {\n      return this.gl.isContextLost();\n    }\n  }, {\n    key: \"onCreateContext\",\n    value: function onCreateContext() {\n      var _this$props;\n\n      return (_this$props = this.props).onCreateContext.apply(_this$props, arguments);\n    }\n  }, {\n    key: \"onInitialize\",\n    value: function onInitialize() {\n      var _this$props2;\n\n      return (_this$props2 = this.props).onInitialize.apply(_this$props2, arguments);\n    }\n  }, {\n    key: \"onRender\",\n    value: function onRender() {\n      var _this$props3;\n\n      return (_this$props3 = this.props).onRender.apply(_this$props3, arguments);\n    }\n  }, {\n    key: \"onFinalize\",\n    value: function onFinalize() {\n      var _this$props4;\n\n      return (_this$props4 = this.props).onFinalize.apply(_this$props4, arguments);\n    }\n  }, {\n    key: \"getHTMLControlValue\",\n    value: function getHTMLControlValue(id) {\n      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var element = document.getElementById(id);\n      return element ? Number(element.value) : defaultValue;\n    }\n  }, {\n    key: \"setViewParameters\",\n    value: function setViewParameters() {\n      log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n      return this;\n    }\n  }, {\n    key: \"_startLoop\",\n    value: function _startLoop() {\n      var _this3 = this;\n\n      var renderFrame = function renderFrame() {\n        if (!_this3._running) {\n          return;\n        }\n\n        _this3.redraw();\n\n        _this3._animationFrameId = _this3._requestAnimationFrame(renderFrame);\n      };\n\n      this._cancelAnimationFrame(this._animationFrameId);\n\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    }\n  }, {\n    key: \"_getPageLoadPromise\",\n    value: function _getPageLoadPromise() {\n      if (!this._pageLoadPromise) {\n        this._pageLoadPromise = isPage ? new Promise(function (resolve, reject) {\n          if (isPage && document.readyState === 'complete') {\n            resolve(document);\n            return;\n          }\n\n          window.addEventListener('load', function () {\n            resolve(document);\n          });\n        }) : Promise.resolve({});\n      }\n\n      return this._pageLoadPromise;\n    }\n  }, {\n    key: \"_setDisplay\",\n    value: function _setDisplay(display) {\n      if (this.display) {\n        this.display.delete();\n        this.display.animationLoop = null;\n      }\n\n      if (display) {\n        display.animationLoop = this;\n      }\n\n      this.display = display;\n    }\n  }, {\n    key: \"_cancelAnimationFrame\",\n    value: function _cancelAnimationFrame(animationFrameId) {\n      if (this.display && this.display.cancelAnimationFrame) {\n        return this.display.cancelAnimationFrame(animationFrameId);\n      }\n\n      return cancelAnimationFrame(animationFrameId);\n    }\n  }, {\n    key: \"_requestAnimationFrame\",\n    value: function _requestAnimationFrame(renderFrameCallback) {\n      if (this._running) {\n        if (this.display && this.display.requestAnimationFrame) {\n          return this.display.requestAnimationFrame(renderFrameCallback);\n        }\n\n        return requestAnimationFrame(renderFrameCallback);\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"_renderFrame\",\n    value: function _renderFrame() {\n      if (this.display) {\n        var _this$display;\n\n        (_this$display = this.display)._renderFrame.apply(_this$display, arguments);\n\n        return;\n      }\n\n      this.onRender.apply(this, arguments);\n    }\n  }, {\n    key: \"_clearNeedsRedraw\",\n    value: function _clearNeedsRedraw() {\n      this.needsRedraw = null;\n    }\n  }, {\n    key: \"_setupFrame\",\n    value: function _setupFrame() {\n      this._resizeCanvasDrawingBuffer();\n\n      this._resizeViewport();\n\n      this._resizeFramebuffer();\n    }\n  }, {\n    key: \"_initializeCallbackData\",\n    value: function _initializeCallbackData() {\n      this.animationProps = {\n        gl: this.gl,\n        stop: this.stop,\n        canvas: this.gl.canvas,\n        framebuffer: this.framebuffer,\n        useDevicePixels: this.useDevicePixels,\n        needsRedraw: null,\n        startTime: Date.now(),\n        engineTime: 0,\n        tick: 0,\n        tock: 0,\n        time: 0,\n        _timeline: this.timeline,\n        _loop: this,\n        _animationLoop: this,\n        _mousePosition: null\n      };\n    }\n  }, {\n    key: \"_updateCallbackData\",\n    value: function _updateCallbackData() {\n      var _this$_getSizeAndAspe = this._getSizeAndAspect(),\n          width = _this$_getSizeAndAspe.width,\n          height = _this$_getSizeAndAspe.height,\n          aspect = _this$_getSizeAndAspe.aspect;\n\n      if (width !== this.animationProps.width || height !== this.animationProps.height) {\n        this.setNeedsRedraw('drawing buffer resized');\n      }\n\n      if (aspect !== this.animationProps.aspect) {\n        this.setNeedsRedraw('drawing buffer aspect changed');\n      }\n\n      this.animationProps.width = width;\n      this.animationProps.height = height;\n      this.animationProps.aspect = aspect;\n      this.animationProps.needsRedraw = this.needsRedraw;\n      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n      if (this.timeline) {\n        this.timeline.update(this.animationProps.engineTime);\n      }\n\n      this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n      this.animationProps.tock++;\n      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;\n      this.animationProps._offScreen = this.offScreen;\n    }\n  }, {\n    key: \"_finalizeCallbackData\",\n    value: function _finalizeCallbackData() {\n      this.onFinalize(this.animationProps);\n    }\n  }, {\n    key: \"_addCallbackData\",\n    value: function _addCallbackData(appContext) {\n      if (typeof appContext === 'object' && appContext !== null) {\n        this.animationProps = Object.assign({}, this.animationProps, appContext);\n      }\n    }\n  }, {\n    key: \"_createWebGLContext\",\n    value: function _createWebGLContext(opts) {\n      this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;\n      opts = Object.assign({}, opts, this.props.glOptions);\n      this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n\n      if (!isWebGL(this.gl)) {\n        throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n      }\n\n      resetParameters(this.gl);\n\n      this._createInfoDiv();\n    }\n  }, {\n    key: \"_createInfoDiv\",\n    value: function _createInfoDiv() {\n      if (this.gl.canvas && this.props.onAddHTML) {\n        var wrapperDiv = document.createElement('div');\n        document.body.appendChild(wrapperDiv);\n        wrapperDiv.style.position = 'relative';\n        var div = document.createElement('div');\n        div.style.position = 'absolute';\n        div.style.left = '10px';\n        div.style.bottom = '10px';\n        div.style.width = '300px';\n        div.style.background = 'white';\n        wrapperDiv.appendChild(this.gl.canvas);\n        wrapperDiv.appendChild(div);\n        var html = this.props.onAddHTML(div);\n\n        if (html) {\n          div.innerHTML = html;\n        }\n      }\n    }\n  }, {\n    key: \"_getSizeAndAspect\",\n    value: function _getSizeAndAspect() {\n      var width = this.gl.drawingBufferWidth;\n      var height = this.gl.drawingBufferHeight;\n      var aspect = 1;\n      var canvas = this.gl.canvas;\n\n      if (canvas && canvas.clientHeight) {\n        aspect = canvas.clientWidth / canvas.clientHeight;\n      } else if (width > 0 && height > 0) {\n        aspect = width / height;\n      }\n\n      return {\n        width: width,\n        height: height,\n        aspect: aspect\n      };\n    }\n  }, {\n    key: \"_resizeViewport\",\n    value: function _resizeViewport() {\n      if (this.autoResizeViewport) {\n        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n      }\n    }\n  }, {\n    key: \"_resizeCanvasDrawingBuffer\",\n    value: function _resizeCanvasDrawingBuffer() {\n      if (this.autoResizeDrawingBuffer) {\n        resizeGLContext(this.gl, {\n          useDevicePixels: this.useDevicePixels\n        });\n      }\n    }\n  }, {\n    key: \"_createFramebuffer\",\n    value: function _createFramebuffer() {\n      if (this.props.createFramebuffer) {\n        this.framebuffer = new Framebuffer(this.gl);\n      }\n    }\n  }, {\n    key: \"_resizeFramebuffer\",\n    value: function _resizeFramebuffer() {\n      if (this.framebuffer) {\n        this.framebuffer.resize({\n          width: this.gl.drawingBufferWidth,\n          height: this.gl.drawingBufferHeight\n        });\n      }\n    }\n  }, {\n    key: \"_beginTimers\",\n    value: function _beginTimers() {\n      this.frameRate.timeEnd();\n      this.frameRate.timeStart();\n\n      if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {\n        this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n      }\n\n      if (this._gpuTimeQuery) {\n        this._gpuTimeQuery.beginTimeElapsedQuery();\n      }\n\n      this.cpuTime.timeStart();\n    }\n  }, {\n    key: \"_endTimers\",\n    value: function _endTimers() {\n      this.cpuTime.timeEnd();\n\n      if (this._gpuTimeQuery) {\n        this._gpuTimeQuery.end();\n      }\n    }\n  }, {\n    key: \"_startEventHandling\",\n    value: function _startEventHandling() {\n      var canvas = this.gl.canvas;\n\n      if (canvas) {\n        canvas.addEventListener('mousemove', this._onMousemove);\n        canvas.addEventListener('mouseleave', this._onMouseleave);\n      }\n    }\n  }, {\n    key: \"_onMousemove\",\n    value: function _onMousemove(e) {\n      this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n    }\n  }, {\n    key: \"_onMouseleave\",\n    value: function _onMouseleave(e) {\n      this.animationProps._mousePosition = null;\n    }\n  }]);\n\n  return AnimationLoop;\n}();\n\nexport { AnimationLoop as default };","map":{"version":3,"sources":["../../../src/lib/animation-loop.js"],"names":["isPage","isBrowser","statIdCounter","constructor","props","onCreateContext","opts","createGLContext","onAddHTML","onInitialize","onRender","onFinalize","gl","glOptions","debug","createFramebuffer","autoResizeViewport","autoResizeDrawingBuffer","stats","lumaStats","useDevicePixels","log","onError","assert","startPromise","Query","appContext","resolve","defaultValue","element","document","Number","renderFrame","window","Promise","display","cancelAnimationFrame","requestAnimationFrame","stop","canvas","framebuffer","needsRedraw","startTime","Date","engineTime","tick","tock","time","_timeline","_loop","_animationLoop","_mousePosition","aspect","width","height","Math","Object","instrumentGLContext","isWebGL","resetParameters","wrapperDiv","div","html","resizeGLContext","drawingBufferHeight","e"],"mappings":"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","sourcesContent":["import {\n  isWebGL,\n  createGLContext,\n  instrumentGLContext,\n  resizeGLContext,\n  resetParameters\n} from '@luma.gl/gltools';\n\nimport {\n  requestAnimationFrame,\n  cancelAnimationFrame,\n  Query,\n  lumaStats,\n  // TODO - remove dependency on framebuffer (bundle size impact)\n  Framebuffer,\n  log,\n  assert\n} from '@luma.gl/webgl';\n\nimport {isBrowser} from 'probe.gl/env';\n\nconst isPage = isBrowser() && typeof document !== 'undefined';\n\nlet statIdCounter = 0;\n\nexport default class AnimationLoop {\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props = {}) {\n    const {\n      onCreateContext = opts => createGLContext(opts),\n      onAddHTML = null,\n      onInitialize = () => {},\n      onRender = () => {},\n      onFinalize = () => {},\n      onError,\n\n      gl = null,\n      glOptions = {},\n      debug = false,\n\n      createFramebuffer = false,\n\n      // view parameters\n      autoResizeViewport = true,\n      autoResizeDrawingBuffer = true,\n      stats = lumaStats.get(`animation-loop-${statIdCounter++}`)\n    } = props;\n\n    let {useDevicePixels = true} = props;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      // @ts-ignore\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext,\n      onAddHTML,\n      onInitialize,\n      onRender,\n      onFinalize,\n      onError,\n\n      gl,\n      glOptions,\n      debug,\n      createFramebuffer\n    };\n\n    // state\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n\n    this.setProps({\n      autoResizeViewport,\n      autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n\n    this._pageLoadPromise = null;\n\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  delete() {\n    this.stop();\n    this._setDisplay(null);\n  }\n\n  setNeedsRedraw(reason) {\n    assert(typeof reason === 'string');\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.autoResizeViewport = props.autoResizeViewport;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n    }\n    if ('useDevicePixels' in props) {\n      this.useDevicePixels = props.useDevicePixels;\n    }\n    return this;\n  }\n\n  // Starts a render loop if not already running\n  // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)\n  start(opts = {}) {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n    // console.debug(`Starting ${this.constructor.name}`);\n    // Wait for start promise before rendering frame\n    const startPromise = this._getPageLoadPromise()\n      .then(() => {\n        if (!this._running || this._initialized) {\n          return null;\n        }\n\n        // Create the WebGL context\n        this._createWebGLContext(opts);\n        this._createFramebuffer();\n        this._startEventHandling();\n\n        // Initialize the callback data\n        this._initializeCallbackData();\n        this._updateCallbackData();\n\n        // Default viewport setup, in case onInitialize wants to render\n        this._resizeCanvasDrawingBuffer();\n        this._resizeViewport();\n\n        this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n\n        this._initialized = true;\n\n        // Note: onIntialize can return a promise (in case it needs to load resources)\n        return this.onInitialize(this.animationProps);\n      })\n      .then(appContext => {\n        if (this._running) {\n          this._addCallbackData(appContext || {});\n          if (appContext !== false) {\n            this._startLoop();\n          }\n        }\n      });\n\n    if (this.props.onError) {\n      startPromise.catch(this.props.onError);\n    }\n\n    return this;\n  }\n\n  // Redraw now\n  redraw() {\n    if (this.isContextLost()) {\n      return this;\n    }\n\n    this._beginTimers();\n\n    this._setupFrame();\n    this._updateCallbackData();\n\n    this._renderFrame(this.animationProps);\n\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/commit\n    // Chrome's offscreen canvas does not require gl.commit\n    if (this.offScreen && this.gl.commit) {\n      this.gl.commit();\n    }\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endTimers();\n\n    return this;\n  }\n\n  // Stops a render loop if already running, finalizing\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      this._finalizeCallbackData();\n      this._cancelAnimationFrame(this._animationFrameId);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._animationFrameId = null;\n      this._running = false;\n    }\n    return this;\n  }\n\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n\n    return this.timeline;\n  }\n\n  detachTimeline() {\n    this.timeline = null;\n  }\n\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n\n    await this.waitForRender();\n\n    return this.gl.canvas.toDataURL();\n  }\n\n  isContextLost() {\n    return this.gl.isContextLost();\n  }\n\n  onCreateContext(...args) {\n    return this.props.onCreateContext(...args);\n  }\n\n  onInitialize(...args) {\n    return this.props.onInitialize(...args);\n  }\n\n  onRender(...args) {\n    return this.props.onRender(...args);\n  }\n\n  onFinalize(...args) {\n    return this.props.onFinalize(...args);\n  }\n\n  // DEPRECATED/REMOVED METHODS\n\n  getHTMLControlValue(id, defaultValue = 1) {\n    const element = document.getElementById(id);\n    // @ts-ignore Not all html elements have value\n    return element ? Number(element.value) : defaultValue;\n  }\n\n  // Update parameters\n  setViewParameters() {\n    log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _startLoop() {\n    const renderFrame = () => {\n      if (!this._running) {\n        return;\n      }\n      this.redraw();\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    };\n\n    // cancel any pending renders to ensure only one loop can ever run\n    this._cancelAnimationFrame(this._animationFrameId);\n    this._animationFrameId = this._requestAnimationFrame(renderFrame);\n  }\n\n  // PRIVATE METHODS\n\n  _getPageLoadPromise() {\n    if (!this._pageLoadPromise) {\n      this._pageLoadPromise = isPage\n        ? new Promise((resolve, reject) => {\n            if (isPage && document.readyState === 'complete') {\n              resolve(document);\n              return;\n            }\n            window.addEventListener('load', () => {\n              resolve(document);\n            });\n          })\n        : Promise.resolve({});\n    }\n    return this._pageLoadPromise;\n  }\n\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.delete();\n      this.display.animationLoop = null;\n    }\n\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _cancelAnimationFrame(animationFrameId) {\n    // E.g. VR display has a separate animation frame to sync with headset\n    if (this.display && this.display.cancelAnimationFrame) {\n      return this.display.cancelAnimationFrame(animationFrameId);\n    }\n\n    return cancelAnimationFrame(animationFrameId);\n  }\n\n  _requestAnimationFrame(renderFrameCallback) {\n    if (this._running) {\n      // E.g. VR display has a separate animation frame to sync with headset\n      if (this.display && this.display.requestAnimationFrame) {\n        return this.display.requestAnimationFrame(renderFrameCallback);\n      }\n\n      return requestAnimationFrame(renderFrameCallback);\n    }\n    return undefined;\n  }\n\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(...args) {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(...args);\n      return;\n    }\n\n    // call callback\n    this.onRender(...args);\n    // end callback\n  }\n\n  _clearNeedsRedraw() {\n    this.needsRedraw = null;\n  }\n\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n    this._resizeFramebuffer();\n  }\n\n  // Initialize the  object that will be passed to app callbacks\n  _initializeCallbackData() {\n    this.animationProps = {\n      gl: this.gl,\n\n      stop: this.stop,\n      canvas: this.gl.canvas,\n      framebuffer: this.framebuffer,\n\n      // Initial values\n      useDevicePixels: this.useDevicePixels,\n      needsRedraw: null,\n\n      // Animation props\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n\n      // Timeline time for back compatibility\n      time: 0,\n\n      // Experimental\n      _timeline: this.timeline,\n      _loop: this,\n      _animationLoop: this,\n      _mousePosition: null // Event props\n    };\n  }\n\n  // Update the context object that will be passed to app callbacks\n  _updateCallbackData() {\n    const {width, height, aspect} = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n\n    this.animationProps.needsRedraw = this.needsRedraw;\n\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n    this.animationProps.tock++;\n\n    // For back compatibility\n    this.animationProps.time = this.timeline\n      ? this.timeline.getTime()\n      : this.animationProps.engineTime;\n\n    // experimental\n    this.animationProps._offScreen = this.offScreen;\n  }\n\n  _finalizeCallbackData() {\n    // call callback\n    this.onFinalize(this.animationProps);\n    // end callback\n  }\n\n  // Add application's data to the app context object\n  _addCallbackData(appContext) {\n    if (typeof appContext === 'object' && appContext !== null) {\n      this.animationProps = Object.assign({}, this.animationProps, appContext);\n    }\n  }\n\n  // Either uses supplied or existing context, or calls provided callback to create one\n  _createWebGLContext(opts) {\n    this.offScreen =\n      opts.canvas &&\n      typeof OffscreenCanvas !== 'undefined' &&\n      opts.canvas instanceof OffscreenCanvas;\n\n    // Create the WebGL context if necessary\n    opts = Object.assign({}, opts, this.props.glOptions);\n    this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n\n    if (!isWebGL(this.gl)) {\n      throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n    }\n\n    // Reset the WebGL context.\n    resetParameters(this.gl);\n\n    this._createInfoDiv();\n  }\n\n  _createInfoDiv() {\n    if (this.gl.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      wrapperDiv.appendChild(this.gl.canvas);\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect() {\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const width = this.gl.drawingBufferWidth;\n    const height = this.gl.drawingBufferHeight;\n\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const {canvas} = this.gl;\n\n    if (canvas && canvas.clientHeight) {\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {width, height, aspect};\n  }\n\n  // Default viewport setup\n  _resizeViewport() {\n    if (this.autoResizeViewport) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n  }\n\n  // Resize the render buffer of the canvas to match canvas client size\n  // Optionally multiplying with devicePixel ratio\n  _resizeCanvasDrawingBuffer() {\n    if (this.autoResizeDrawingBuffer) {\n      resizeGLContext(this.gl, {useDevicePixels: this.useDevicePixels});\n    }\n  }\n\n  // TBD - deprecated?\n  _createFramebuffer() {\n    // Setup default framebuffer\n    if (this.props.createFramebuffer) {\n      this.framebuffer = new Framebuffer(this.gl);\n    }\n  }\n\n  _resizeFramebuffer() {\n    if (this.framebuffer) {\n      this.framebuffer.resize({\n        width: this.gl.drawingBufferWidth,\n        height: this.gl.drawingBufferHeight\n      });\n    }\n  }\n\n  _beginTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    if (\n      this._gpuTimeQuery &&\n      this._gpuTimeQuery.isResultAvailable() &&\n      !this._gpuTimeQuery.isTimerDisjoint()\n    ) {\n      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    }\n\n    if (this._gpuTimeQuery) {\n      // GPU time query start\n      this._gpuTimeQuery.beginTimeElapsedQuery();\n    }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endTimers() {\n    this.cpuTime.timeEnd();\n\n    if (this._gpuTimeQuery) {\n      // GPU time query end. Results will be available on next frame.\n      this._gpuTimeQuery.end();\n    }\n  }\n\n  // Event handling\n\n  _startEventHandling() {\n    const {canvas} = this.gl;\n    if (canvas) {\n      canvas.addEventListener('mousemove', this._onMousemove);\n      canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }\n\n  _onMousemove(e) {\n    this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n  }\n  _onMouseleave(e) {\n    this.animationProps._mousePosition = null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}