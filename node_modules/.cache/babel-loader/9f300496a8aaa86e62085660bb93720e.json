{"ast":null,"code":"import * as log from '../log';\nimport { isHConcatSpec, isVConcatSpec } from '../spec';\nimport { keys } from '../util';\nimport { buildModel } from './buildmodel';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { parseConcatLayoutSize } from './layoutsize/parse';\nimport { Model } from './model';\nexport class ConcatModel extends Model {\n  constructor(spec, parent, parentGivenName, config) {\n    var _a, _b, _c, _d;\n\n    super(spec, 'concat', parent, parentGivenName, config, spec.resolve);\n\n    if (((_b = (_a = spec.resolve) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.x) === 'shared' || ((_d = (_c = spec.resolve) === null || _c === void 0 ? void 0 : _c.axis) === null || _d === void 0 ? void 0 : _d.y) === 'shared') {\n      log.warn(log.message.CONCAT_CANNOT_SHARE_AXIS);\n    }\n\n    this.children = this.getChildren(spec).map((child, i) => {\n      return buildModel(child, this, this.getName(`concat_${i}`), undefined, config);\n    });\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n\n    for (const child of this.children) {\n      child.parseSelections();\n\n      for (const key of keys(child.component.selection)) {\n        this.component.selection[key] = child.component.selection[key];\n      }\n    }\n  }\n\n  parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  parseAxesAndHeaders() {\n    for (const child of this.children) {\n      child.parseAxesAndHeaders();\n    } // TODO(#2415): support shared axes\n\n  }\n\n  getChildren(spec) {\n    if (isVConcatSpec(spec)) {\n      return spec.vconcat;\n    } else if (isHConcatSpec(spec)) {\n      return spec.hconcat;\n    }\n\n    return spec.concat;\n  }\n\n  parseLayoutSize() {\n    parseConcatLayoutSize(this);\n  }\n\n  parseAxisGroup() {\n    return null;\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  assembleSignals() {\n    this.children.forEach(child => child.assembleSignals());\n    return [];\n  }\n\n  assembleLayoutSignals() {\n    const layoutSignals = assembleLayoutSignals(this);\n\n    for (const child of this.children) {\n      layoutSignals.push(...child.assembleLayoutSignals());\n    }\n\n    return layoutSignals;\n  }\n\n  assembleSelectionData(data) {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  assembleMarks() {\n    // only children have marks\n    return this.children.map(child => {\n      const title = child.assembleTitle();\n      const style = child.assembleGroupStyle();\n      const encodeEntry = child.assembleGroupEncodeEntry(false);\n      return Object.assign(Object.assign(Object.assign(Object.assign({\n        type: 'group',\n        name: child.getName('group')\n      }, title ? {\n        title\n      } : {}), style ? {\n        style\n      } : {}), encodeEntry ? {\n        encode: {\n          update: encodeEntry\n        }\n      } : {}), child.assembleGroup());\n    });\n  }\n\n  assembleGroupStyle() {\n    return undefined;\n  }\n\n  assembleDefaultLayout() {\n    const columns = this.layout.columns;\n    return Object.assign(Object.assign({}, columns != null ? {\n      columns: columns\n    } : {}), {\n      bounds: 'full',\n      // Use align each so it can work with multiple plots with different size\n      align: 'each'\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/compile/concat.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../log';\nimport { isHConcatSpec, isVConcatSpec } from '../spec';\nimport { keys } from '../util';\nimport { buildModel } from './buildmodel';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { parseConcatLayoutSize } from './layoutsize/parse';\nimport { Model } from './model';\nexport class ConcatModel extends Model {\n    constructor(spec, parent, parentGivenName, config) {\n        var _a, _b, _c, _d;\n        super(spec, 'concat', parent, parentGivenName, config, spec.resolve);\n        if (((_b = (_a = spec.resolve) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.x) === 'shared' || ((_d = (_c = spec.resolve) === null || _c === void 0 ? void 0 : _c.axis) === null || _d === void 0 ? void 0 : _d.y) === 'shared') {\n            log.warn(log.message.CONCAT_CANNOT_SHARE_AXIS);\n        }\n        this.children = this.getChildren(spec).map((child, i) => {\n            return buildModel(child, this, this.getName(`concat_${i}`), undefined, config);\n        });\n    }\n    parseData() {\n        this.component.data = parseData(this);\n        for (const child of this.children) {\n            child.parseData();\n        }\n    }\n    parseSelections() {\n        // Merge selections up the hierarchy so that they may be referenced\n        // across unit specs. Persist their definitions within each child\n        // to assemble signals which remain within output Vega unit groups.\n        this.component.selection = {};\n        for (const child of this.children) {\n            child.parseSelections();\n            for (const key of keys(child.component.selection)) {\n                this.component.selection[key] = child.component.selection[key];\n            }\n        }\n    }\n    parseMarkGroup() {\n        for (const child of this.children) {\n            child.parseMarkGroup();\n        }\n    }\n    parseAxesAndHeaders() {\n        for (const child of this.children) {\n            child.parseAxesAndHeaders();\n        }\n        // TODO(#2415): support shared axes\n    }\n    getChildren(spec) {\n        if (isVConcatSpec(spec)) {\n            return spec.vconcat;\n        }\n        else if (isHConcatSpec(spec)) {\n            return spec.hconcat;\n        }\n        return spec.concat;\n    }\n    parseLayoutSize() {\n        parseConcatLayoutSize(this);\n    }\n    parseAxisGroup() {\n        return null;\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n    }\n    assembleSignals() {\n        this.children.forEach(child => child.assembleSignals());\n        return [];\n    }\n    assembleLayoutSignals() {\n        const layoutSignals = assembleLayoutSignals(this);\n        for (const child of this.children) {\n            layoutSignals.push(...child.assembleLayoutSignals());\n        }\n        return layoutSignals;\n    }\n    assembleSelectionData(data) {\n        return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n    }\n    assembleMarks() {\n        // only children have marks\n        return this.children.map(child => {\n            const title = child.assembleTitle();\n            const style = child.assembleGroupStyle();\n            const encodeEntry = child.assembleGroupEncodeEntry(false);\n            return Object.assign(Object.assign(Object.assign(Object.assign({ type: 'group', name: child.getName('group') }, (title ? { title } : {})), (style ? { style } : {})), (encodeEntry ? { encode: { update: encodeEntry } } : {})), child.assembleGroup());\n        });\n    }\n    assembleGroupStyle() {\n        return undefined;\n    }\n    assembleDefaultLayout() {\n        const columns = this.layout.columns;\n        return Object.assign(Object.assign({}, (columns != null ? { columns: columns } : {})), { bounds: 'full', \n            // Use align each so it can work with multiple plots with different size\n            align: 'each' });\n    }\n}\n//# sourceMappingURL=concat.js.map"]},"metadata":{},"sourceType":"module"}