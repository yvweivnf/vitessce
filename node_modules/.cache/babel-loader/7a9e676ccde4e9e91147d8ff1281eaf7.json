{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\n\nvar GridAggregationLayer = /*#__PURE__*/function (_AggregationLayer) {\n  _inherits(GridAggregationLayer, _AggregationLayer);\n\n  var _super = _createSuper(GridAggregationLayer);\n\n  function GridAggregationLayer() {\n    _classCallCheck(this, GridAggregationLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GridAggregationLayer, [{\n    key: \"initializeState\",\n    value: function initializeState(_ref) {\n      var dimensions = _ref.dimensions;\n      var gl = this.context.gl;\n\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"initializeState\", this).call(this, dimensions);\n\n      this.setState({\n        layerData: {},\n        gpuGridAggregator: new GPUGridAggregator(gl, {\n          id: \"\".concat(this.id, \"-gpu-aggregator\")\n        }),\n        cpuGridAggregator: pointToDensityGridDataCPU\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"updateState\", this).call(this, opts);\n\n      this.updateAggregationState(opts);\n      var _this$state = this.state,\n          aggregationDataDirty = _this$state.aggregationDataDirty,\n          aggregationWeightsDirty = _this$state.aggregationWeightsDirty,\n          gpuAggregation = _this$state.gpuAggregation;\n\n      if (this.getNumInstances() <= 0) {\n        return;\n      }\n\n      var aggregationDirty = false;\n\n      if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n        this._updateAggregation(opts);\n\n        aggregationDirty = true;\n      }\n\n      if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n        this._updateWeightBins();\n\n        this._uploadAggregationResults();\n\n        aggregationDirty = true;\n      }\n\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      var _this$state$gpuGridAg;\n\n      var count = this.state.weights.count;\n\n      if (count && count.aggregationBuffer) {\n        count.aggregationBuffer.delete();\n      }\n\n      (_this$state$gpuGridAg = this.state.gpuGridAggregator) === null || _this$state$gpuGridAg === void 0 ? void 0 : _this$state$gpuGridAg.delete();\n\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"finalizeState\", this).call(this);\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders(shaders) {\n      if (this.state.gpuAggregation) {\n        this.state.gpuGridAggregator.updateShaders(shaders);\n      }\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      log.assert(false);\n    }\n  }, {\n    key: \"allocateResources\",\n    value: function allocateResources(numRow, numCol) {\n      if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n        var dataBytes = numCol * numRow * 4 * 4;\n        var gl = this.context.gl;\n        var weights = this.state.weights;\n\n        for (var name in weights) {\n          var weight = weights[name];\n\n          if (weight.aggregationBuffer) {\n            weight.aggregationBuffer.delete();\n          }\n\n          weight.aggregationBuffer = new Buffer(gl, {\n            byteLength: dataBytes,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"updateResults\",\n    value: function updateResults(_ref2) {\n      var aggregationData = _ref2.aggregationData,\n          maxMinData = _ref2.maxMinData,\n          maxData = _ref2.maxData,\n          minData = _ref2.minData;\n      var count = this.state.weights.count;\n\n      if (count) {\n        count.aggregationData = aggregationData;\n        count.maxMinData = maxMinData;\n        count.maxData = maxData;\n        count.minData = minData;\n      }\n    }\n  }, {\n    key: \"_updateAggregation\",\n    value: function _updateAggregation(opts) {\n      var _this$state2 = this.state,\n          cpuGridAggregator = _this$state2.cpuGridAggregator,\n          gpuGridAggregator = _this$state2.gpuGridAggregator,\n          gridOffset = _this$state2.gridOffset,\n          posOffset = _this$state2.posOffset,\n          _this$state2$translat = _this$state2.translation,\n          translation = _this$state2$translat === void 0 ? [0, 0] : _this$state2$translat,\n          _this$state2$scaling = _this$state2.scaling,\n          scaling = _this$state2$scaling === void 0 ? [0, 0, 0] : _this$state2$scaling,\n          boundingBox = _this$state2.boundingBox,\n          projectPoints = _this$state2.projectPoints,\n          gpuAggregation = _this$state2.gpuAggregation,\n          numCol = _this$state2.numCol,\n          numRow = _this$state2.numRow;\n      var props = opts.props;\n      var viewport = this.context.viewport;\n      var attributes = this.getAttributes();\n      var vertexCount = this.getNumInstances();\n\n      if (!gpuAggregation) {\n        var result = cpuGridAggregator(props, {\n          gridOffset: gridOffset,\n          projectPoints: projectPoints,\n          attributes: attributes,\n          viewport: viewport,\n          posOffset: posOffset,\n          boundingBox: boundingBox\n        });\n        this.setState({\n          layerData: result\n        });\n      } else {\n        var weights = this.state.weights;\n        gpuGridAggregator.run({\n          weights: weights,\n          cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n          numCol: numCol,\n          numRow: numRow,\n          translation: translation,\n          scaling: scaling,\n          vertexCount: vertexCount,\n          projectPoints: projectPoints,\n          attributes: attributes,\n          moduleSettings: this.getModuleSettings()\n        });\n      }\n    }\n  }, {\n    key: \"_updateWeightBins\",\n    value: function _updateWeightBins() {\n      var getValue = this.state.getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue\n      });\n      this.setState({\n        sortedBins: sortedBins\n      });\n    }\n  }, {\n    key: \"_uploadAggregationResults\",\n    value: function _uploadAggregationResults() {\n      var _this$state3 = this.state,\n          numCol = _this$state3.numCol,\n          numRow = _this$state3.numRow;\n      var data = this.state.layerData.data;\n      var _this$state$sortedBin = this.state.sortedBins,\n          aggregatedBins = _this$state$sortedBin.aggregatedBins,\n          minValue = _this$state$sortedBin.minValue,\n          maxValue = _this$state$sortedBin.maxValue,\n          totalCount = _this$state$sortedBin.totalCount;\n      var ELEMENTCOUNT = 4;\n      var aggregationSize = numCol * numRow * ELEMENTCOUNT;\n      var aggregationData = new Float32Array(aggregationSize).fill(0);\n\n      var _iterator = _createForOfIteratorHelper(aggregatedBins),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var bin = _step.value;\n          var _data$bin$i = data[bin.i],\n              lonIdx = _data$bin$i.lonIdx,\n              latIdx = _data$bin$i.latIdx;\n          var value = bin.value,\n              counts = bin.counts;\n          var cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n          aggregationData[cellIndex] = value;\n          aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n      var maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n      var minData = new Float32Array([minValue, 0, 0, totalCount]);\n      this.updateResults({\n        aggregationData: aggregationData,\n        maxMinData: maxMinData,\n        maxData: maxData,\n        minData: minData\n      });\n    }\n  }]);\n\n  return GridAggregationLayer;\n}(AggregationLayer);\n\nexport { GridAggregationLayer as default };\nGridAggregationLayer.layerName = 'GridAggregationLayer';","map":{"version":3,"sources":["../../src/grid-aggregation-layer.js"],"names":["dimensions","gl","layerData","gpuGridAggregator","id","cpuGridAggregator","pointToDensityGridDataCPU","gpuAggregation","aggregationDirty","aggregationDataDirty","count","log","dataBytes","numCol","weights","weight","byteLength","accessor","size","type","divisor","minData","translation","scaling","numRow","props","viewport","attributes","vertexCount","result","gridOffset","projectPoints","posOffset","boundingBox","cellSize","moduleSettings","getValue","sortedBins","data","totalCount","ELEMENTCOUNT","aggregationSize","aggregationData","latIdx","bin","counts","cellIndex","lonIdx","maxMinData","maxData","GridAggregationLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport default class GridAggregationLayer extends AggregationLayer {\n  initializeState({dimensions}) {\n    const {gl} = this.context;\n    super.initializeState(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState() {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState();\n  }\n\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults() {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n\nGridAggregationLayer.layerName = 'GridAggregationLayer';\n"]},"metadata":{},"sourceType":"module"}