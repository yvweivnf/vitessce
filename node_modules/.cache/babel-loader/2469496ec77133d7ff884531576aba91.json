{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport Buffer from '../classes/buffer';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { getCompositeGLType } from '../webgl-utils/attribute-utils';\nimport { formatValue } from '../utils/format-value';\nexport function getDebugTableForVertexArray(_ref) {\n  var vertexArray = _ref.vertexArray,\n      _ref$header = _ref.header,\n      header = _ref$header === void 0 ? 'Attributes' : _ref$header;\n\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  var table = {};\n\n  if (vertexArray.elements) {\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  var attributes = vertexArray.values;\n\n  for (var attributeLocation in attributes) {\n    var info = vertexArray._getAttributeInfo(attributeLocation);\n\n    if (info) {\n      var rowHeader = \"\".concat(attributeLocation, \": \").concat(info.name);\n      var accessor = vertexArray.accessors[info.location];\n\n      if (accessor) {\n        rowHeader = \"\".concat(attributeLocation, \": \").concat(getGLSLDeclaration(info.name, accessor));\n      }\n\n      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);\n    }\n  }\n\n  return table;\n}\n\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  var _ref4;\n\n  var gl = vertexArray.gl;\n\n  if (!attribute) {\n    var _ref2;\n\n    return _ref2 = {}, _defineProperty(_ref2, header, 'null'), _defineProperty(_ref2, 'Format ', 'N/A'), _ref2;\n  }\n\n  var type = 'NOT PROVIDED';\n  var size = 1;\n  var verts = 0;\n  var bytes = 0;\n  var isInteger;\n  var marker;\n  var value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n    type = String(type).replace('Array', '');\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    var _ref3;\n\n    var buffer = attribute;\n\n    var _buffer$getDebugData = buffer.getDebugData(),\n        data = _buffer$getDebugData.data,\n        changed = _buffer$getDebugData.changed;\n\n    marker = changed ? '*' : '';\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n    var format;\n\n    if (accessor) {\n      var instanced = accessor.divisor > 0;\n      format = \"\".concat(instanced ? 'I ' : 'P ', \" \").concat(verts, \" (x\").concat(size, \"=\").concat(bytes, \" bytes \").concat(getKey(gl, type), \")\");\n    } else {\n      isInteger = true;\n      format = \"\".concat(bytes, \" bytes\");\n    }\n\n    return _ref3 = {}, _defineProperty(_ref3, header, \"\".concat(marker).concat(formatValue(value, {\n      size: size,\n      isInteger: isInteger\n    }))), _defineProperty(_ref3, 'Format ', format), _ref3;\n  }\n\n  value = attribute;\n  size = attribute.length;\n  type = String(attribute.constructor.name).replace('Array', '');\n  isInteger = type.indexOf('nt') !== -1;\n  return _ref4 = {}, _defineProperty(_ref4, header, \"\".concat(formatValue(value, {\n    size: size,\n    isInteger: isInteger\n  }), \" (constant)\")), _defineProperty(_ref4, 'Format ', \"\".concat(size, \"x\").concat(type, \" (constant)\")), _ref4;\n}\n\nfunction getGLSLDeclaration(name, accessor) {\n  var type = accessor.type,\n      size = accessor.size;\n  var typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? \"\".concat(name, \" (\").concat(typeAndName.name, \")\") : name;\n}","map":{"version":3,"sources":["../../../src/debug/debug-vertex-array.js"],"names":["header","vertexArray","table","getDebugTableRow","attributes","info","rowHeader","attributeLocation","accessor","getGLSLDeclaration","gl","type","size","verts","bytes","String","isInteger","attribute","buffer","changed","marker","value","data","instanced","format","getKey","formatValue","typeAndName","getCompositeGLType","name"],"mappings":"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","sourcesContent":["import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils/format-value';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 1;\n  let verts = 0;\n  let bytes = 0;\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, changed} = buffer.getDebugData();\n    marker = changed ? '*' : '';\n\n    value = data;\n    // @ts-ignore\n    bytes = buffer.byteLength;\n    // @ts-ignore\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n"]},"metadata":{},"sourceType":"module"}