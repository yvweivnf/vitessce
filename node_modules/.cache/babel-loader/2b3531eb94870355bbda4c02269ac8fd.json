{"ast":null,"code":"import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, field, peek, identity, array as array$1, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, codegenExpression, constants, functions, parseExpression, CallExpression } from 'vega-expression';\nimport { geoBounds as geoBounds$1, geoCentroid as geoCentroid$1, geoArea as geoArea$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionIdTest, selectionResolve, selectionTuples } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\n\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\n\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n        entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\n\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n\nfunction encode(item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n          target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n\n  return retval !== undefined ? retval : item;\n}\n\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return locale[method](spec)(value);\n};\n\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\n\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\n\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\n\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\n\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\n\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\n\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\n\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {// if data set does not exist, there's nothing to track\n    }\n  }\n}\n\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\n\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {// TODO: error handling? warning?\n    }\n  }\n}\n\nfunction getScale(name, ctx) {\n  let s;\n  return isFunction(name) ? name : isString(name) ? (s = ctx.scales[name]) && s.value : undefined;\n}\n\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions\n\n\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument\n\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n\n\n  return {\n    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,\n    _range: args => `${ref(args[0])}.range()`,\n    _scale: args => `${ref(args[0])}(${codegen(args[1])})`\n  };\n}\n\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\n\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\n\nfunction inScope(item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n\n    item = item.mark.group;\n  }\n  return value;\n}\n\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n\n  return args[args.length - 1];\n}\n\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\n\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\n\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\n\nfunction luminance(color) {\n  const c = rgb(color),\n        r = channel_luminance_value(c.r),\n        g = channel_luminance_value(c.g),\n        b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\n\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n        lum2 = luminance(color2),\n        lumL = Math.max(lum1, lum2),\n        lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\n\nfunction merge() {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\n\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\n\nfunction modify(name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input,\n        stamp = df.stamp();\n  let changes = data.changes,\n      predicate,\n      key;\n\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n\n  if (insert) {\n    changes.insert(insert);\n  }\n\n  if (toggle) {\n    predicate = removePredicate(toggle);\n\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n\n  return 1;\n}\n\nfunction pinchDistance(event) {\n  const t = event.touches,\n        dx = t[0].clientX - t[1].clientX,\n        dy = t[0].clientY - t[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\nconst accessors = {};\n\nfunction pluck(data, name) {\n  const accessor = accessors[name] || (accessors[name] = field(name));\n  return isArray(data) ? data.map(accessor) : accessor(data);\n}\n\nfunction array(seq) {\n  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;\n}\n\nfunction sequence(seq) {\n  return array(seq) || (isString(seq) ? seq : null);\n}\n\nfunction join(seq, ...args) {\n  return array(seq).join(...args);\n}\n\nfunction indexof(seq, ...args) {\n  return sequence(seq).indexOf(...args);\n}\n\nfunction lastindexof(seq, ...args) {\n  return sequence(seq).lastIndexOf(...args);\n}\n\nfunction slice(seq, ...args) {\n  return sequence(seq).slice(...args);\n}\n\nfunction replace(str, pattern, repl) {\n  if (isFunction(repl)) error('Function argument passed to replace.');\n  return String(str).replace(pattern, repl);\n}\n\nfunction reverse(seq) {\n  return array(seq).slice().reverse();\n}\n\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\n\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\n\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\n\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\n\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\n\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\n\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nfunction scaleGradient(scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n      min = stops[0],\n      max = peek(stops),\n      fraction = identity;\n\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\n\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\n\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\n\nconst datum = d => d.data;\n\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\n\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n        s = nodes[source],\n        t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\n\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n\nconst _window = () => typeof window !== 'undefined' && window || null;\n\nfunction screen() {\n  const w = _window();\n\n  return w ? w.screen : {};\n}\n\nfunction windowSize() {\n  const w = _window();\n\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\n\nfunction containerSize() {\n  const view = this.context.dataflow,\n        el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\n\nfunction intersect(b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n        box = new Bounds().set(u[0], u[1], v[0], v[1]),\n        scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\n\nfunction filter(opt) {\n  let p = null;\n\n  if (opt) {\n    const types = array$1(opt.marktype),\n          names = array$1(opt.markname);\n\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n\n  return p;\n}\n\nconst functionContext = {\n  random() {\n    return random();\n  },\n\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n\n  isDefined(_) {\n    return _ !== undefined;\n  },\n\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n\n  toBoolean,\n  toDate,\n  toNumber,\n  toString,\n  indexof,\n  join,\n  lastindexof,\n  replace,\n  reverse,\n  slice,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  pluck,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n  extent,\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n      // event functions\neventPrefix = 'event.vega.',\n      // event function prefix\nthisPrefix = 'this.',\n      // function context prefix\nastVisitors = {}; // AST visitors for dependency analysis\n// export code generator parameters\n\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => `_[${stringValue(SignalPrefix + id)}]`,\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n}; // export code generator\n\nconst codeGenerator = codegenExpression(codegenParams); // Build expression function registry\n\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n} // Register an expression function\n\n\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  } // register with the functionContext\n\n\n  functionContext[name] = fn; // if there is an astVisitor register that, too\n\n  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,\n  // we need to also register the function with it\n\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n} // register expression functions with ast visitors\n\n\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions\n\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionIdTest', selectionIdTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\nexpressionFunction('vlSelectionTuples', selectionTuples);\n\nfunction parser(expr, scope) {\n  const params = {}; // parse the expression to an abstract syntax tree (ast)\n\n  let ast;\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parseExpression(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n          visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  const gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\n\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoShape, inScope, indata, indataVisitor, indexof, info, invert, join, lastindexof, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, pluck, range, replace, reverse, scale, scaleGradient, scaleVisitor, screen, setdata, slice, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-functions/build/vega-functions.module.js"],"names":["truthy","error","hasOwnProperty","isFunction","isString","stringValue","extend","isArray","isObject","field","peek","identity","array","array$1","isBoolean","isDate","isNumber","isRegExp","toBoolean","toDate","toNumber","toString","flush","lerp","pad","span","inrange","truncate","quarter","utcquarter","extent","clampRange","panLinear","panLog","panPow","panSymlog","zoomLinear","zoomLog","zoomPow","zoomSymlog","Literal","codegenExpression","constants","functions","parseExpression","CallExpression","geoBounds","geoBounds$1","geoCentroid","geoCentroid$1","geoArea","geoArea$1","rgb","lab","hcl","hsl","isTuple","bandSpace","scale","scale$1","scaleFraction","Gradient","pathRender","pathParse","Bounds","intersect","intersect$1","selectionVisitor","selectionTest","selectionIdTest","selectionResolve","selectionTuples","random","cumulativeNormal","cumulativeLogNormal","cumulativeUniform","densityNormal","densityLogNormal","densityUniform","quantileNormal","quantileLogNormal","quantileUniform","sampleNormal","sampleLogNormal","sampleUniform","utcOffset","utcSequence","timeOffset","timeSequence","timeUnitSpecifier","week","utcweek","dayofyear","utcdayofyear","range","range$1","data","name","context","values","value","indata","index","entry","get","undefined","count","setdata","tuples","df","dataflow","input","pulse","changeset","remove","insert","encode","item","retval","target","mark","source","wrap","method","spec","locale","format","timeFormat","utcFormat","timeParse","utcParse","dateObj","Date","time","month","day","specifier","Number","isInteger","setYear","setMonth","setDate","call","monthFormat","monthAbbrevFormat","dayFormat","dayAbbrevFormat","DataPrefix","IndexPrefix","ScalePrefix","SignalPrefix","dataVisitor","args","scope","params","type","dataName","getData","tuplesRef","err","indataVisitor","indexName","indataRef","scaleVisitor","addScaleDependency","scales","scaleName","scaleRef","getScale","ctx","s","internalScaleFunctions","codegen","fnctx","visitors","__bandwidth","bandwidth","_bandwidth","_range","_scale","ref","arg","geoMethod","methodName","globalMethod","projection","geojson","group","p","path","inScope","log","apply","concat","slice","warn","length","arguments","info","debug","channel_luminance_value","channelValue","val","Math","pow","luminance","color","c","r","g","b","contrast","color1","color2","lum1","lum2","lumL","max","lumD","min","merge","unshift","equal","a","equalArray","equalObject","i","n","key","removePredicate","props","_","modify","toggle","stamp","changes","predicate","_trigger","runAfter","modified","run","some","pinchDistance","event","t","touches","dx","clientX","dy","clientY","sqrt","pinchAngle","atan2","accessors","pluck","accessor","map","seq","ArrayBuffer","isView","sequence","join","indexof","indexOf","lastindexof","lastIndexOf","replace","str","pattern","repl","String","reverse","bandspace","paddingInner","paddingOuter","copy","domain","invert","invertRange","invertExtent","scaleGradient","p0","p1","gradient","stops","fraction","interpolator","interpolate","ticks","push","forEach","stop","geoShape","pathShape","datum","d","treeNodes","tree","root","lookup","treePath","nodes","treeAncestors","node","ancestors","_window","window","screen","w","windowSize","innerWidth","innerHeight","containerSize","view","el","container","clientWidth","clientHeight","opt","u","v","box","set","scene","scenegraph","filter","types","marktype","names","markname","functionContext","isDefined","isValid","eventFunctions","eventPrefix","thisPrefix","astVisitors","codegenParams","forbidden","allowed","fieldvar","globalvar","id","buildFunctions","codeGenerator","fn","expressionFunction","visitor","parser","expr","ast","visit","callee","gen","globals","signalName","getSignal","signalRef","$expr","code","options","$fields","fields","$params"],"mappings":"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","sourcesContent":["import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, field, peek, identity, array as array$1, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, codegenExpression, constants, functions, parseExpression, CallExpression } from 'vega-expression';\nimport { geoBounds as geoBounds$1, geoCentroid as geoCentroid$1, geoArea as geoArea$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionIdTest, selectionResolve, selectionTuples } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\n\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n        entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n\nfunction encode (item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n          target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n\n  return retval !== undefined ? retval : item;\n}\n\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return locale[method](spec)(value);\n};\n\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\n\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\n\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\n\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\n\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {// if data set does not exist, there's nothing to track\n    }\n  }\n}\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {// TODO: error handling? warning?\n    }\n  }\n}\n\nfunction getScale(name, ctx) {\n  let s;\n  return isFunction(name) ? name : isString(name) ? (s = ctx.scales[name]) && s.value : undefined;\n}\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions\n\n\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument\n\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n\n\n  return {\n    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,\n    _range: args => `${ref(args[0])}.range()`,\n    _scale: args => `${ref(args[0])}(${codegen(args[1])})`\n  };\n}\n\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\n\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\n\nfunction inScope (item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n\n    item = item.mark.group;\n  }\n  return value;\n}\n\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n\n  return args[args.length - 1];\n}\n\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\n\nfunction luminance(color) {\n  const c = rgb(color),\n        r = channel_luminance_value(c.r),\n        g = channel_luminance_value(c.g),\n        b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n        lum2 = luminance(color2),\n        lumL = Math.max(lum1, lum2),\n        lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\n\nfunction merge () {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\n\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\n\nfunction modify (name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input,\n        stamp = df.stamp();\n  let changes = data.changes,\n      predicate,\n      key;\n\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n\n  if (insert) {\n    changes.insert(insert);\n  }\n\n  if (toggle) {\n    predicate = removePredicate(toggle);\n\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n\n  return 1;\n}\n\nfunction pinchDistance(event) {\n  const t = event.touches,\n        dx = t[0].clientX - t[1].clientX,\n        dy = t[0].clientY - t[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n}\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\nconst accessors = {};\nfunction pluck (data, name) {\n  const accessor = accessors[name] || (accessors[name] = field(name));\n  return isArray(data) ? data.map(accessor) : accessor(data);\n}\n\nfunction array(seq) {\n  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;\n}\n\nfunction sequence(seq) {\n  return array(seq) || (isString(seq) ? seq : null);\n}\n\nfunction join(seq, ...args) {\n  return array(seq).join(...args);\n}\nfunction indexof(seq, ...args) {\n  return sequence(seq).indexOf(...args);\n}\nfunction lastindexof(seq, ...args) {\n  return sequence(seq).lastIndexOf(...args);\n}\nfunction slice(seq, ...args) {\n  return sequence(seq).slice(...args);\n}\nfunction replace(str, pattern, repl) {\n  if (isFunction(repl)) error('Function argument passed to replace.');\n  return String(str).replace(pattern, repl);\n}\nfunction reverse(seq) {\n  return array(seq).slice().reverse();\n}\n\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nfunction scaleGradient (scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n      min = stops[0],\n      max = peek(stops),\n      fraction = identity;\n\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\n\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\n\nconst datum = d => d.data;\n\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\n\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n        s = nodes[source],\n        t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n\nconst _window = () => typeof window !== 'undefined' && window || null;\n\nfunction screen() {\n  const w = _window();\n\n  return w ? w.screen : {};\n}\nfunction windowSize() {\n  const w = _window();\n\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\nfunction containerSize() {\n  const view = this.context.dataflow,\n        el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\n\nfunction intersect (b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n        box = new Bounds().set(u[0], u[1], v[0], v[1]),\n        scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\n\nfunction filter(opt) {\n  let p = null;\n\n  if (opt) {\n    const types = array$1(opt.marktype),\n          names = array$1(opt.markname);\n\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n\n  return p;\n}\n\nconst functionContext = {\n  random() {\n    return random();\n  },\n\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n\n  isDefined(_) {\n    return _ !== undefined;\n  },\n\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n\n  toBoolean,\n  toDate,\n  toNumber,\n  toString,\n  indexof,\n  join,\n  lastindexof,\n  replace,\n  reverse,\n  slice,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  pluck,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n  extent,\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n      // event functions\neventPrefix = 'event.vega.',\n      // event function prefix\nthisPrefix = 'this.',\n      // function context prefix\nastVisitors = {}; // AST visitors for dependency analysis\n// export code generator parameters\n\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => `_[${stringValue(SignalPrefix + id)}]`,\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n}; // export code generator\n\nconst codeGenerator = codegenExpression(codegenParams); // Build expression function registry\n\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n} // Register an expression function\n\n\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  } // register with the functionContext\n\n\n  functionContext[name] = fn; // if there is an astVisitor register that, too\n\n  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,\n  // we need to also register the function with it\n\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n} // register expression functions with ast visitors\n\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions\n\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionIdTest', selectionIdTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\nexpressionFunction('vlSelectionTuples', selectionTuples);\n\nfunction parser (expr, scope) {\n  const params = {}; // parse the expression to an abstract syntax tree (ast)\n\n  let ast;\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parseExpression(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n          visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  const gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\n\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoShape, inScope, indata, indataVisitor, indexof, info, invert, join, lastindexof, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, pluck, range, replace, reverse, scale, scaleGradient, scaleVisitor, screen, setdata, slice, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };\n"]},"metadata":{},"sourceType":"module"}