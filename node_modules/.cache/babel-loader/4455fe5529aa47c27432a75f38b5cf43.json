{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { dashShaders, offsetShaders } from './shaders.glsl';\nimport { dist } from 'gl-matrix/vec3';\nvar defaultProps = {\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getOffset: {\n    type: 'accessor',\n    value: 0\n  },\n  dashJustified: false,\n  dashGapPickable: false\n};\n\nvar PathStyleExtension = /*#__PURE__*/function (_LayerExtension) {\n  _inherits(PathStyleExtension, _LayerExtension);\n\n  var _super = _createSuper(PathStyleExtension);\n\n  function PathStyleExtension() {\n    _classCallCheck(this, PathStyleExtension);\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$dash = _ref.dash,\n        dash = _ref$dash === void 0 ? false : _ref$dash,\n        _ref$offset = _ref.offset,\n        offset = _ref$offset === void 0 ? false : _ref$offset,\n        _ref$highPrecisionDas = _ref.highPrecisionDash,\n        highPrecisionDash = _ref$highPrecisionDas === void 0 ? false : _ref$highPrecisionDas;\n\n    return _super.call(this, {\n      dash: dash || highPrecisionDash,\n      offset: offset,\n      highPrecisionDash: highPrecisionDash\n    });\n  }\n\n  _createClass(PathStyleExtension, [{\n    key: \"isEnabled\",\n    value: function isEnabled(layer) {\n      return layer.state.pathTesselator;\n    }\n  }, {\n    key: \"getShaders\",\n    value: function getShaders(extension) {\n      if (!extension.isEnabled(this)) {\n        return null;\n      }\n\n      var result = {};\n\n      if (extension.opts.dash) {\n        result = mergeShaders(result, dashShaders);\n      }\n\n      if (extension.opts.offset) {\n        result = mergeShaders(result, offsetShaders);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState(context, extension) {\n      var attributeManager = this.getAttributeManager();\n\n      if (!attributeManager || !extension.isEnabled(this)) {\n        return;\n      }\n\n      extension.enabled = true;\n\n      if (extension.opts.dash) {\n        attributeManager.addInstanced({\n          instanceDashArrays: {\n            size: 2,\n            accessor: 'getDashArray'\n          }\n        });\n      }\n\n      if (extension.opts.highPrecisionDash) {\n        attributeManager.addInstanced({\n          instanceDashOffsets: {\n            size: 1,\n            accessor: 'getPath',\n            transform: extension.getDashOffsets.bind(this)\n          }\n        });\n      }\n\n      if (extension.opts.offset) {\n        attributeManager.addInstanced({\n          instanceOffsets: {\n            size: 1,\n            accessor: 'getOffset'\n          }\n        });\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(params, extension) {\n      if (!extension.isEnabled(this)) {\n        return;\n      }\n\n      var uniforms = {};\n\n      if (extension.opts.dash) {\n        uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n        uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n      }\n\n      this.state.model.setUniforms(uniforms);\n    }\n  }, {\n    key: \"getDashOffsets\",\n    value: function getDashOffsets(path) {\n      var result = [0];\n      var positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n      var isNested = Array.isArray(path[0]);\n      var geometrySize = isNested ? path.length : path.length / positionSize;\n      var p;\n      var prevP;\n\n      for (var i = 0; i < geometrySize - 1; i++) {\n        p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n        p = this.projectPosition(p);\n\n        if (i > 0) {\n          result[i] = result[i - 1] + dist(prevP, p);\n        }\n\n        prevP = p;\n      }\n\n      return result;\n    }\n  }]);\n\n  return PathStyleExtension;\n}(LayerExtension);\n\nexport { PathStyleExtension as default };\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/path-style/path-style.js"],"names":["_mergeShaders","defaultProps","getDashArray","type","value","getOffset","dashJustified","dashGapPickable","constructor","dash","offset","highPrecisionDash","layer","extension","result","mergeShaders","attributeManager","instanceDashArrays","size","accessor","instanceDashOffsets","transform","instanceOffsets","uniforms","Boolean","positionSize","isNested","Array","path","geometrySize","i","p","dist","prevP","PathStyleExtension"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\nimport {dist} from 'gl-matrix/vec3';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false,\n  dashGapPickable: false\n};\n\nexport default class PathStyleExtension extends LayerExtension {\n  constructor({dash = false, offset = false, highPrecisionDash = false} = {}) {\n    super({dash: dash || highPrecisionDash, offset, highPrecisionDash});\n  }\n\n  isEnabled(layer) {\n    return layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    extension.enabled = true;\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'}\n      });\n    }\n    if (extension.opts.highPrecisionDash) {\n      attributeManager.addInstanced({\n        instanceDashOffsets: {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n\n  getDashOffsets(path) {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n    return result;\n  }\n}\n\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}