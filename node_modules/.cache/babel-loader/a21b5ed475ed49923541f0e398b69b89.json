{"ast":null,"code":"import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport const legendEncodeRules = {\n  symbols,\n  gradient,\n  labels,\n  entries\n};\nexport function symbols(symbolsSpec, {\n  fieldOrDatumDef,\n  model,\n  channel,\n  legendCmpt,\n  legendType\n}) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n\n  const {\n    markDef,\n    encoding,\n    config,\n    mark\n  } = model;\n  const filled = markDef.filled && mark !== 'trail';\n  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model, {\n    filled\n  })); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const symbolOpacity = (_a = legendCmpt.get('symbolOpacity')) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;\n  const symbolFillColor = (_b = legendCmpt.get('symbolFillColor')) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;\n  const symbolStrokeColor = (_c = legendCmpt.get('symbolStrokeColor')) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;\n  const opacity = symbolOpacity === undefined ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : undefined;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (symbolFillColor) {\n          delete out.fill;\n        } else {\n          out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : 'black');\n          out.fillOpacity = signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1);\n        }\n      } else if (isArray(out.fill)) {\n        const fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : filled && markDef.color;\n\n        if (fill) {\n          out.fill = signalOrValueRef(fill);\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field'] || symbolStrokeColor) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n\n        if (stroke) {\n          out.stroke = {\n            value: stroke\n          };\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n\n    if (condition) {\n      out.opacity = [Object.assign({\n        test: condition\n      }, signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1)), signalOrValueRef(config.legend.unselectedOpacity)];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n\n  out = Object.assign(Object.assign({}, out), symbolsSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, {\n  model,\n  legendType,\n  legendCmpt\n}) {\n  var _a;\n\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n\n  const {\n    config,\n    markDef,\n    encoding\n  } = model;\n  let out = {};\n  const gradientOpacity = (_a = legendCmpt.get('gradientOpacity')) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;\n  const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n\n  out = Object.assign(Object.assign({}, out), gradientSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, {\n  fieldOrDatumDef,\n  model,\n  channel,\n  legendCmpt\n}) {\n  const legend = model.legend(channel) || {};\n  const config = model.config;\n  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  const opacity = condition ? [{\n    test: condition,\n    value: 1\n  }, {\n    value: config.legend.unselectedOpacity\n  }] : undefined;\n  const {\n    format,\n    formatType\n  } = legend;\n  const text = isCustomFormatType(formatType) ? formatCustomType({\n    fieldOrDatumDef,\n    field: 'datum.value',\n    format,\n    formatType,\n    config\n  }) : undefined;\n  const labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity ? {\n    opacity\n  } : {}), text ? {\n    text\n  } : {}), specifiedlabelsSpec);\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, {\n  legendCmpt\n}) {\n  const selections = legendCmpt.get('selections');\n  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), {\n    fill: {\n      value: 'transparent'\n    }\n  }) : entriesSpec;\n}\n\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\n\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n\n  return undefined;\n}\n\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n  const selections = legendCmpt.get('selections');\n  if (!(selections === null || selections === void 0 ? void 0 : selections.length)) return undefined;\n  const field = stringValue(fieldDef.field);\n  return selections.map(name => {\n    const store = stringValue(varName(name) + STORE);\n    return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n  }).join(' || ');\n}","map":{"version":3,"sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"AACA,SAAQ,KAAR,EAAe,OAAf,EAAwB,WAAxB,QAA0C,WAA1C;AACA,SAAQ,KAAR,EAAwC,OAAxC,QAAsD,eAAtD;AACA,SAGE,sBAHF,EAIE,UAJF,EAKE,UALF,QASO,kBATP;AAWA,SAAQ,kBAAR,QAAiC,YAAjC;AACA,SAAQ,eAAR,EAAyB,OAAzB,EAAkC,OAAlC,QAAgD,YAAhD;AACA,SAAQ,eAAR,EAAyB,gBAAzB,QAAgD,WAAhD;AACA,SAAQ,gBAAR,EAA0B,kBAA1B,QAAmD,WAAnD;AACA,OAAO,KAAK,MAAZ,MAAwB,gBAAxB;AACA,SAAQ,KAAR,QAAoB,cAApB;AAYA,OAAO,MAAM,iBAAiB,GAE1B;AACF,EAAA,OADE;AAEF,EAAA,QAFE;AAGF,EAAA,MAHE;AAIF,EAAA;AAJE,CAFG;AASP,OAAM,SAAU,OAAV,CACJ,WADI,EAEJ;AAAC,EAAA,eAAD;AAAkB,EAAA,KAAlB;AAAyB,EAAA,OAAzB;AAAkC,EAAA,UAAlC;AAA8C,EAAA;AAA9C,CAFI,EAEyE;;;AAE7E,MAAI,UAAU,KAAK,QAAnB,EAA6B;AAC3B,WAAO,SAAP;AACD;;AAED,QAAM;AAAC,IAAA,OAAD;AAAU,IAAA,QAAV;AAAoB,IAAA,MAApB;AAA4B,IAAA;AAA5B,MAAoC,KAA1C;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,IAAI,KAAK,OAA1C;AAEA,MAAI,GAAG,GAAG,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACL,eAAe,CAAC,EAAD,EAAK,KAAL,EAAY,kBAAZ,CADV,CAAA,EAEL,MAAM,CAAC,KAAP,CAAa,KAAb,EAAoB;AAAC,IAAA;AAAD,GAApB,CAFK,CAAV,CAT6E,CAYrD;;AAExB,QAAM,aAAa,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,eAAf,CAAA,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,EAA/B,GAAmC,MAAM,CAAC,MAAP,CAAc,aAAvE;AACA,QAAM,eAAe,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,iBAAf,CAAA,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAqC,MAAM,CAAC,MAAP,CAAc,eAA3E;AACA,QAAM,iBAAiB,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,mBAAf,CAAA,MAAmC,IAAnC,IAAmC,EAAA,KAAA,KAAA,CAAnC,GAAmC,EAAnC,GAAuC,MAAM,CAAC,MAAP,CAAc,iBAA/E;AAEA,QAAM,OAAO,GAAG,aAAa,KAAK,SAAlB,GAA8B,CAAA,EAAA,GAAA,WAAW,CAAC,QAAQ,CAAC,OAAV,CAAX,MAA6B,IAA7B,IAA6B,EAAA,KAAA,KAAA,CAA7B,GAA6B,EAA7B,GAAiC,OAAO,CAAC,OAAvE,GAAiF,SAAjG;;AAEA,MAAI,GAAG,CAAC,IAAR,EAAc;AACZ;AACA,QAAI,OAAO,KAAK,MAAZ,IAAuB,MAAM,IAAI,OAAO,KAAK,KAAjD,EAAyD;AACvD,aAAO,GAAG,CAAC,IAAX;AACD,KAFD,MAEO;AACL,UAAI,GAAG,CAAC,IAAJ,CAAS,OAAT,CAAJ,EAAuB;AACrB;AACA,YAAI,eAAJ,EAAqB;AACnB,iBAAO,GAAG,CAAC,IAAX;AACD,SAFD,MAEO;AACL,UAAA,GAAG,CAAC,IAAJ,GAAW,gBAAgB,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,MAAP,CAAc,mBAAd,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAqC,OAAtC,CAA3B;AACA,UAAA,GAAG,CAAC,WAAJ,GAAkB,gBAAgB,CAAC,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,CAAZ,CAAlC;AACD;AACF,OARD,MAQO,IAAI,OAAO,CAAC,GAAG,CAAC,IAAL,CAAX,EAAuB;AAC5B,cAAM,IAAI,GACR,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,sBAAsB,CAAC,CAAA,EAAA,GAAA,QAAQ,CAAC,IAAT,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,EAAb,GAAiB,QAAQ,CAAC,KAA3B,CAAtB,MAAuD,IAAvD,IAAuD,EAAA,KAAA,KAAA,CAAvD,GAAuD,EAAvD,GAA2D,OAAO,CAAC,IAAnE,MAAuE,IAAvE,IAAuE,EAAA,KAAA,KAAA,CAAvE,GAAuE,EAAvE,GAA4E,MAAM,IAAI,OAAO,CAAC,KADhG;;AAEA,YAAI,IAAJ,EAAU;AACR,UAAA,GAAG,CAAC,IAAJ,GAAW,gBAAgB,CAAC,IAAD,CAA3B;AACD;AACF;AACF;AACF;;AAED,MAAI,GAAG,CAAC,MAAR,EAAgB;AACd,QAAI,OAAO,KAAK,QAAZ,IAAyB,CAAC,MAAD,IAAW,OAAO,KAAK,KAApD,EAA4D;AAC1D,aAAO,GAAG,CAAC,MAAX;AACD,KAFD,MAEO;AACL,UAAI,GAAG,CAAC,MAAJ,CAAW,OAAX,KAAuB,iBAA3B,EAA8C;AAC5C;AACA,eAAO,GAAG,CAAC,MAAX;AACD,OAHD,MAGO,IAAI,OAAO,CAAC,GAAG,CAAC,MAAL,CAAX,EAAyB;AAC9B,cAAM,MAAM,GAAG,eAAe,CAC5B,sBAAsB,CAAoB,QAAQ,CAAC,MAAT,IAAmB,QAAQ,CAAC,KAAhD,CADM,EAE5B,OAAO,CAAC,MAFoB,EAG5B,MAAM,GAAG,OAAO,CAAC,KAAX,GAAmB,SAHG,CAA9B;;AAKA,YAAI,MAAJ,EAAY;AACV,UAAA,GAAG,CAAC,MAAJ,GAAa;AAAC,YAAA,KAAK,EAAE;AAAR,WAAb;AACD;AACF;AACF;AACF;;AAED,MAAI,OAAO,KAAK,OAAhB,EAAyB;AACvB,UAAM,SAAS,GAAG,UAAU,CAAC,eAAD,CAAV,IAA+B,iBAAiB,CAAC,KAAD,EAAQ,UAAR,EAAoB,eAApB,CAAlE;;AAEA,QAAI,SAAJ,EAAe;AACb,MAAA,GAAG,CAAC,OAAJ,GAAc,C;AACX,QAAA,IAAI,EAAE;SAAc,gBAAgB,CAAC,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,CAAZ,C,CADzB,EAEZ,gBAAgB,CAAC,MAAM,CAAC,MAAP,CAAc,iBAAf,CAFJ,CAAd;AAID,KALD,MAKO,IAAI,OAAJ,EAAa;AAClB,MAAA,GAAG,CAAC,OAAJ,GAAc,gBAAgB,CAAC,OAAD,CAA9B;AACD;AACF;;AAED,EAAA,GAAG,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,GAAP,CAAA,EAAe,WAAf,CAAH;AAEA,SAAO,OAAO,CAAC,GAAD,CAAP,GAAe,SAAf,GAA2B,GAAlC;AACD;AAED,OAAM,SAAU,QAAV,CAAmB,YAAnB,EAAsC;AAAC,EAAA,KAAD;AAAQ,EAAA,UAAR;AAAoB,EAAA;AAApB,CAAtC,EAAyF;;;AAC7F,MAAI,UAAU,KAAK,UAAnB,EAA+B;AAC7B,WAAO,SAAP;AACD;;AAED,QAAM;AAAC,IAAA,MAAD;AAAS,IAAA,OAAT;AAAkB,IAAA;AAAlB,MAA8B,KAApC;AAEA,MAAI,GAAG,GAAsB,EAA7B;AAEA,QAAM,eAAe,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,iBAAf,CAAA,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAqC,MAAM,CAAC,MAAP,CAAc,eAA3E;AACA,QAAM,OAAO,GAAG,eAAe,KAAK,SAApB,GAAgC,WAAW,CAAC,QAAQ,CAAC,OAAV,CAAX,IAAiC,OAAO,CAAC,OAAzE,GAAmF,SAAnG;;AACA,MAAI,OAAJ,EAAa;AACX;AACA,IAAA,GAAG,CAAC,OAAJ,GAAc,gBAAgB,CAAC,OAAD,CAA9B;AACD;;AAED,EAAA,GAAG,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,GAAP,CAAA,EAAe,YAAf,CAAH;AACA,SAAO,OAAO,CAAC,GAAD,CAAP,GAAe,SAAf,GAA2B,GAAlC;AACD;AAED,OAAM,SAAU,MAAV,CAAiB,mBAAjB,EAA2C;AAAC,EAAA,eAAD;AAAkB,EAAA,KAAlB;AAAyB,EAAA,OAAzB;AAAkC,EAAA;AAAlC,CAA3C,EAA4G;AAChH,QAAM,MAAM,GAAG,KAAK,CAAC,MAAN,CAAa,OAAb,KAAyB,EAAxC;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,MAArB;AAEA,QAAM,SAAS,GAAG,UAAU,CAAC,eAAD,CAAV,GAA8B,iBAAiB,CAAC,KAAD,EAAQ,UAAR,EAAoB,eAApB,CAA/C,GAAsF,SAAxG;AACA,QAAM,OAAO,GAAG,SAAS,GAAG,CAAC;AAAC,IAAA,IAAI,EAAE,SAAP;AAAkB,IAAA,KAAK,EAAE;AAAzB,GAAD,EAA8B;AAAC,IAAA,KAAK,EAAE,MAAM,CAAC,MAAP,CAAc;AAAtB,GAA9B,CAAH,GAA6E,SAAtG;AAEA,QAAM;AAAC,IAAA,MAAD;AAAS,IAAA;AAAT,MAAuB,MAA7B;AAEA,QAAM,IAAI,GAAG,kBAAkB,CAAC,UAAD,CAAlB,GACT,gBAAgB,CAAC;AACf,IAAA,eADe;AAEf,IAAA,KAAK,EAAE,aAFQ;AAGf,IAAA,MAHe;AAIf,IAAA,UAJe;AAKf,IAAA;AALe,GAAD,CADP,GAQT,SARJ;AAUA,QAAM,UAAU,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACV,OAAO,GAAG;AAAC,IAAA;AAAD,GAAH,GAAe,EADZ,CAAA,EAEV,IAAI,GAAG;AAAC,IAAA;AAAD,GAAH,GAAY,EAFN,CAAA,EAGX,mBAHW,CAAhB;AAMA,SAAO,OAAO,CAAC,UAAD,CAAP,GAAsB,SAAtB,GAAkC,UAAzC;AACD;AAED,OAAM,SAAU,OAAV,CAAkB,WAAlB,EAAoC;AAAC,EAAA;AAAD,CAApC,EAAoE;AACxE,QAAM,UAAU,GAAG,UAAU,CAAC,GAAX,CAAe,YAAf,CAAnB;AACA,SAAO,CAAA,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,MAAZ,IAAoB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,WAAL,CAAA,EAAgB;AAAE,IAAA,IAAI,EAAE;AAAC,MAAA,KAAK,EAAE;AAAR;AAAR,GAAhB,CAApB,GAAsE,WAA7E;AACD;;AAED,SAAS,WAAT,CAAqB,UAArB,EAA4D;AAC1D,SAAO,iBAAiB,CAAS,UAAT,EAAqB,CAAC,CAAD,EAAY,cAAZ,KAA+B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,cAAc,CAAC,KAA3B,CAApD,CAAxB;AACD;;AAED,OAAM,SAAU,sBAAV,CACJ,UADI,EACqD;AAEzD,SAAO,iBAAiB,CAAI,UAAJ,EAAgB,CAAC,CAAD,EAAO,cAAP,KAAmD;AACzF,WAAO,eAAe,CAAI,CAAJ,EAAO,cAAc,CAAC,KAAtB,CAAtB;AACD,GAFuB,CAAxB;AAGD;;AAED,SAAS,iBAAT,CACE,UADF,EAEE,OAFF,EAEkE;AAEhE,MAAI,sBAAsB,CAAC,UAAD,CAA1B,EAAwC;AACtC,WAAO,KAAK,CAAC,UAAU,CAAC,SAAZ,CAAL,CAA4B,MAA5B,CAAmC,OAAnC,EAA4C,UAAU,CAAC,KAAvD,CAAP;AACD,GAFD,MAEO,IAAI,UAAU,CAAC,UAAD,CAAd,EAA4B;AACjC,WAAO,UAAU,CAAC,KAAlB;AACD;;AACD,SAAO,SAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,KAA3B,EAA6C,UAA7C,EAA0E,QAA1E,EAAyG;AACvG,QAAM,UAAU,GAAG,UAAU,CAAC,GAAX,CAAe,YAAf,CAAnB;AACA,MAAI,EAAC,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,MAAb,CAAJ,EAAyB,OAAO,SAAP;AAEzB,QAAM,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,KAAV,CAAzB;AACA,SAAO,UAAU,CACd,GADI,CACA,IAAI,IAAG;AACV,UAAM,KAAK,GAAG,WAAW,CAAC,OAAO,CAAC,IAAD,CAAP,GAAgB,KAAjB,CAAzB;AACA,WAAO,iBAAiB,KAAK,UAAU,IAAI,IAAI,KAAK,gBAAgB,IAAI,IAAI,KAAK,wBAAjF;AACD,GAJI,EAKJ,IALI,CAKC,MALD,CAAP;AAMD","sourceRoot":"","sourcesContent":["import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport const legendEncodeRules = {\n    symbols,\n    gradient,\n    labels,\n    entries\n};\nexport function symbols(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType }) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    if (legendType !== 'symbol') {\n        return undefined;\n    }\n    const { markDef, encoding, config, mark } = model;\n    const filled = markDef.filled && mark !== 'trail';\n    let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model, { filled })); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n    const symbolOpacity = (_a = legendCmpt.get('symbolOpacity')) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;\n    const symbolFillColor = (_b = legendCmpt.get('symbolFillColor')) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;\n    const symbolStrokeColor = (_c = legendCmpt.get('symbolStrokeColor')) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;\n    const opacity = symbolOpacity === undefined ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : undefined;\n    if (out.fill) {\n        // for fill legend, we don't want any fill in symbol\n        if (channel === 'fill' || (filled && channel === COLOR)) {\n            delete out.fill;\n        }\n        else {\n            if (out.fill['field']) {\n                // For others, set fill to some opaque value (or nothing if a color is already set)\n                if (symbolFillColor) {\n                    delete out.fill;\n                }\n                else {\n                    out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : 'black');\n                    out.fillOpacity = signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1);\n                }\n            }\n            else if (isArray(out.fill)) {\n                const fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : (filled && markDef.color);\n                if (fill) {\n                    out.fill = signalOrValueRef(fill);\n                }\n            }\n        }\n    }\n    if (out.stroke) {\n        if (channel === 'stroke' || (!filled && channel === COLOR)) {\n            delete out.stroke;\n        }\n        else {\n            if (out.stroke['field'] || symbolStrokeColor) {\n                // For others, remove stroke field\n                delete out.stroke;\n            }\n            else if (isArray(out.stroke)) {\n                const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n                if (stroke) {\n                    out.stroke = { value: stroke };\n                }\n            }\n        }\n    }\n    if (channel !== OPACITY) {\n        const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n        if (condition) {\n            out.opacity = [\n                Object.assign({ test: condition }, signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1)),\n                signalOrValueRef(config.legend.unselectedOpacity)\n            ];\n        }\n        else if (opacity) {\n            out.opacity = signalOrValueRef(opacity);\n        }\n    }\n    out = Object.assign(Object.assign({}, out), symbolsSpec);\n    return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, { model, legendType, legendCmpt }) {\n    var _a;\n    if (legendType !== 'gradient') {\n        return undefined;\n    }\n    const { config, markDef, encoding } = model;\n    let out = {};\n    const gradientOpacity = (_a = legendCmpt.get('gradientOpacity')) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;\n    const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n    if (opacity) {\n        // only apply opacity if it is neither zero or undefined\n        out.opacity = signalOrValueRef(opacity);\n    }\n    out = Object.assign(Object.assign({}, out), gradientSpec);\n    return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {\n    const legend = model.legend(channel) || {};\n    const config = model.config;\n    const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n    const opacity = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : undefined;\n    const { format, formatType } = legend;\n    const text = isCustomFormatType(formatType)\n        ? formatCustomType({\n            fieldOrDatumDef,\n            field: 'datum.value',\n            format,\n            formatType,\n            config\n        })\n        : undefined;\n    const labelsSpec = Object.assign(Object.assign(Object.assign({}, (opacity ? { opacity } : {})), (text ? { text } : {})), specifiedlabelsSpec);\n    return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, { legendCmpt }) {\n    const selections = legendCmpt.get('selections');\n    return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), { fill: { value: 'transparent' } }) : entriesSpec;\n}\nfunction getMaxValue(channelDef) {\n    return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\nexport function getFirstConditionValue(channelDef) {\n    return getConditionValue(channelDef, (v, conditionalDef) => {\n        return getFirstDefined(v, conditionalDef.value);\n    });\n}\nfunction getConditionValue(channelDef, reducer) {\n    if (hasConditionalValueDef(channelDef)) {\n        return array(channelDef.condition).reduce(reducer, channelDef.value);\n    }\n    else if (isValueDef(channelDef)) {\n        return channelDef.value;\n    }\n    return undefined;\n}\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n    const selections = legendCmpt.get('selections');\n    if (!(selections === null || selections === void 0 ? void 0 : selections.length))\n        return undefined;\n    const field = stringValue(fieldDef.field);\n    return selections\n        .map(name => {\n        const store = stringValue(varName(name) + STORE);\n        return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n        .join(' || ');\n}\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"module"}