{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n  direction: ({\n    direction\n  }) => direction,\n  format: ({\n    fieldOrDatumDef,\n    legend,\n    config\n  }) => {\n    const {\n      format,\n      formatType\n    } = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n  formatType: ({\n    legend,\n    fieldOrDatumDef,\n    scaleType\n  }) => {\n    const {\n      formatType\n    } = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  gradientLength: params => {\n    var _a, _b;\n\n    const {\n      legend,\n      legendConfig\n    } = params;\n    return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);\n  },\n  labelOverlap: ({\n    legend,\n    legendConfig,\n    scaleType\n  }) => {\n    var _a, _b;\n\n    return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType);\n  },\n  symbolType: ({\n    legend,\n    markDef,\n    channel,\n    encoding\n  }) => {\n    var _a;\n\n    return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);\n  },\n  title: ({\n    fieldOrDatumDef,\n    config\n  }) => fieldDefTitle(fieldOrDatumDef, config, {\n    allowDisabling: true\n  }),\n  type: ({\n    legendType,\n    scaleType,\n    channel\n  }) => {\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n\n    return legendType;\n  },\n  values: ({\n    fieldOrDatumDef,\n    legend\n  }) => values(legend, fieldOrDatumDef)\n};\nexport function values(legend, fieldOrDatumDef) {\n  const vals = legend.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  var _a;\n\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;\n\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n\n  return undefined;\n}\nexport function getLegendType(params) {\n  const {\n    legend\n  } = params;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType\n}) {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n\n  return 'symbol';\n}\nexport function getDirection({\n  legendConfig,\n  legendType,\n  orient,\n  legend\n}) {\n  var _a, _b;\n\n  return (_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? 'gradientDirection' : 'symbolDirection']) !== null && _b !== void 0 ? _b : defaultDirection(orient, legendType);\n}\nexport function defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\nexport function defaultGradientLength({\n  legendConfig,\n  model,\n  direction,\n  orient,\n  scaleType\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n\n  return undefined;\n}\n\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: `clamp(${sizeSignal}, ${min}, ${max})`\n  };\n}\n\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n    direction: ({ direction }) => direction,\n    format: ({ fieldOrDatumDef, legend, config }) => {\n        const { format, formatType } = legend;\n        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n    },\n    formatType: ({ legend, fieldOrDatumDef, scaleType }) => {\n        const { formatType } = legend;\n        return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n    },\n    gradientLength: params => {\n        var _a, _b;\n        const { legend, legendConfig } = params;\n        return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);\n    },\n    labelOverlap: ({ legend, legendConfig, scaleType }) => { var _a, _b; return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType); },\n    symbolType: ({ legend, markDef, channel, encoding }) => { var _a; return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape); },\n    title: ({ fieldOrDatumDef, config }) => fieldDefTitle(fieldOrDatumDef, config, { allowDisabling: true }),\n    type: ({ legendType, scaleType, channel }) => {\n        if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n            if (legendType === 'gradient') {\n                return undefined;\n            }\n        }\n        else if (legendType === 'symbol') {\n            return undefined;\n        }\n        return legendType;\n    },\n    values: ({ fieldOrDatumDef, legend }) => values(legend, fieldOrDatumDef)\n};\nexport function values(legend, fieldOrDatumDef) {\n    const vals = legend.values;\n    if (isArray(vals)) {\n        return valueArray(fieldOrDatumDef, vals);\n    }\n    else if (isSignalRef(vals)) {\n        return vals;\n    }\n    return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n    var _a;\n    if (channel !== 'shape') {\n        // use the value from the shape encoding or the mark config if they exist\n        const shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;\n        if (shape) {\n            return shape;\n        }\n    }\n    switch (mark) {\n        case 'bar':\n        case 'rect':\n        case 'image':\n        case 'square':\n            return 'square';\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return 'stroke';\n        case 'arc':\n        case 'point':\n        case 'circle':\n        case 'tick':\n        case 'geoshape':\n        case 'area':\n        case 'text':\n            return 'circle';\n    }\n}\nexport function clipHeight(legendType) {\n    if (legendType === 'gradient') {\n        return 20;\n    }\n    return undefined;\n}\nexport function getLegendType(params) {\n    const { legend } = params;\n    return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType({ channel, timeUnit, scaleType }) {\n    // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n    if (isColorChannel(channel)) {\n        if (contains(['quarter', 'month', 'day'], timeUnit)) {\n            return 'symbol';\n        }\n        if (isContinuousToContinuous(scaleType)) {\n            return 'gradient';\n        }\n    }\n    return 'symbol';\n}\nexport function getDirection({ legendConfig, legendType, orient, legend }) {\n    var _a, _b;\n    return ((_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? 'gradientDirection' : 'symbolDirection']) !== null && _b !== void 0 ? _b : defaultDirection(orient, legendType));\n}\nexport function defaultDirection(orient, legendType) {\n    switch (orient) {\n        case 'top':\n        case 'bottom':\n            return 'horizontal';\n        case 'left':\n        case 'right':\n        case 'none':\n        case undefined: // undefined = \"right\" in Vega\n            return undefined; // vertical is Vega's default\n        default:\n            // top-left / ...\n            // For inner legend, uses compact layout like Tableau\n            return legendType === 'gradient' ? 'horizontal' : undefined;\n    }\n}\nexport function defaultGradientLength({ legendConfig, model, direction, orient, scaleType }) {\n    const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;\n    if (isContinuousToContinuous(scaleType)) {\n        if (direction === 'horizontal') {\n            if (orient === 'top' || orient === 'bottom') {\n                return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n            }\n            else {\n                return gradientHorizontalMinLength;\n            }\n        }\n        else {\n            // vertical / undefined (Vega uses vertical by default)\n            return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n        }\n    }\n    return undefined;\n}\nfunction gradientLengthSignal(model, sizeType, min, max) {\n    const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n    return { signal: `clamp(${sizeSignal}, ${min}, ${max})` };\n}\nexport function defaultLabelOverlap(scaleType) {\n    if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n        return 'greedy';\n    }\n    return undefined;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}