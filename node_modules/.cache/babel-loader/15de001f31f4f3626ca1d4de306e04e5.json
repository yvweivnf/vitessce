{"ast":null,"code":"import _regeneratorRuntime from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";import _asyncToGenerator from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _createClass from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";import _inherits from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";import _createSuper from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";import _toConsumableArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";/* eslint-disable no-control-regex */import{InternMap}from'internmap';import{treeInitialize,nodeAppendChild,initializeCellSetColor}from'../../components/sets/cell-set-utils';import{SETS_DATATYPE_CELL}from'../../components/sets/constants';import AbstractTwoStepLoader from'../AbstractTwoStepLoader';import LoaderResult from'../LoaderResult';export function dataToCellSetsTree(data,options){var _data=_slicedToArray(data,3),cellNames=_data[0],cellSets=_data[1],cellSetScores=_data[2];var cellSetsTree=treeInitialize(SETS_DATATYPE_CELL);cellSets.forEach(function(cellSetIds,j){var name=options[j].groupName;var levelZeroNode={name:name,children:[]};if(cellSetIds.length>0&&Array.isArray(cellSetIds[0])){// Multi-level case.\nvar levelSets=new InternMap([],JSON.stringify);cellNames.forEach(function(id,i){var classes=cellSetIds.map(function(col){return col[i];});if(levelSets.has(classes)){levelSets.get(classes).push([id,null]);}else{levelSets.set(classes,[[id,null]]);}});var levels=Array.from(levelSets.keys());var getNextLevelNames=function getNextLevelNames(levelSuffixes){var nextLevelNames=Array.from(new Set(levelSuffixes.map(function(l){return l[0];})));return nextLevelNames.sort(function(a,b){return a.localeCompare(b);});};// Recursive function to create nodes.\nvar getNode=function getNode(parentLevelPrefixes,currLevelName,childLevelSuffixes){var isLeaf=childLevelSuffixes.length===0;var resultNode={name:currLevelName};if(isLeaf){// Base case: this is a leaf node.\nresultNode.set=levelSets.get([].concat(_toConsumableArray(parentLevelPrefixes),[currLevelName]));}else{// Are the remaining suffices redundant?\n// Consider [\"Parent\", \"Child\", \"Child\"]\n// where parentLevelPrefixes is [\"Parent\"] and currLevelName is \"Child\".\nvar shouldBeLeaf=childLevelSuffixes.length===1&&currLevelName===childLevelSuffixes[0][childLevelSuffixes[0].length-1];if(shouldBeLeaf){resultNode.set=levelSets.get([].concat(_toConsumableArray(parentLevelPrefixes),[currLevelName],_toConsumableArray(childLevelSuffixes[0])));}else{// Recursion, run getNode() on each of the unique names at the next level.\nvar nextLevelNames=getNextLevelNames(childLevelSuffixes);resultNode.children=nextLevelNames.map(function(nextLevelName){return getNode([].concat(_toConsumableArray(parentLevelPrefixes),[currLevelName]),nextLevelName,childLevelSuffixes.filter(function(l){return l[0]===nextLevelName;}).map(function(l){return l.slice(1);}).filter(function(v){return v.length>0;}));});}}return resultNode;};// Start the recursion.\nvar levelOneNodes=getNextLevelNames(levels).map(function(levelOneName){return getNode([],levelOneName,levels.filter(function(l){return l[0]===levelOneName;}).map(function(l){return l.slice(1);}));});levelZeroNode.children=levelOneNodes;}else{// Single-level case.\n// Check for the optional corresponding confidence score column name.\nvar uniqueCellSetIds=Array.from(new Set(cellSetIds)).sort();var clusters={};// eslint-disable-next-line no-return-assign\nuniqueCellSetIds.forEach(function(id){return clusters[id]={name:id,set:[]};});if(cellSetScores[j]){cellSetIds.forEach(function(id,i){return clusters[id].set.push([cellNames[i],cellSetScores[j][i]]);});}else{cellSetIds.forEach(function(id,i){return clusters[id].set.push([cellNames[i],null]);});}Object.values(clusters).forEach(// eslint-disable-next-line no-return-assign\nfunction(cluster){return levelZeroNode=nodeAppendChild(levelZeroNode,cluster);});}cellSetsTree.tree.push(levelZeroNode);});return cellSetsTree;}/**\n * Loader for converting zarr into the cell sets json schema.\n */var CellSetsZarrLoader=/*#__PURE__*/function(_AbstractTwoStepLoade){_inherits(CellSetsZarrLoader,_AbstractTwoStepLoade);var _super=_createSuper(CellSetsZarrLoader);function CellSetsZarrLoader(){_classCallCheck(this,CellSetsZarrLoader);return _super.apply(this,arguments);}_createClass(CellSetsZarrLoader,[{key:\"loadCellSetIds\",value:function loadCellSetIds(){var options=this.options;var cellSetZarrLocation=options.map(function(_ref){var setName=_ref.setName;return setName;});return this.dataSource.loadObsColumns(cellSetZarrLocation);}},{key:\"loadCellSetScores\",value:function loadCellSetScores(){var options=this.options;var cellSetScoreZarrLocation=options.map(function(option){return option.scoreName||undefined;});return this.dataSource.loadObsColumns(cellSetScoreZarrLocation);}},{key:\"load\",value:function(){var _load=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var options,cellSetsTree,coordinationValues,tree,newAutoSetSelectionParentName,newAutoSetSelections,newAutoSetColors;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!this.cellSetsTree){options=this.options;this.cellSetsTree=Promise.all([this.dataSource.loadObsIndex(),this.loadCellSetIds(),this.loadCellSetScores()]).then(function(data){return dataToCellSetsTree(data,options);});}_context.next=3;return this.cellSetsTree;case 3:cellSetsTree=_context.sent;coordinationValues={};tree=cellSetsTree.tree;newAutoSetSelectionParentName=tree[0].name;// Create a list of set paths to initally select.\nnewAutoSetSelections=tree[0].children.map(function(node){return[newAutoSetSelectionParentName,node.name];});// Create a list of cell set objects with color mappings.\nnewAutoSetColors=initializeCellSetColor(cellSetsTree,[]);coordinationValues.obsSetSelection=newAutoSetSelections;coordinationValues.obsSetColor=newAutoSetColors;return _context.abrupt(\"return\",Promise.resolve(new LoaderResult(cellSetsTree,null,coordinationValues)));case 12:case\"end\":return _context.stop();}}},_callee,this);}));function load(){return _load.apply(this,arguments);}return load;}()}]);return CellSetsZarrLoader;}(AbstractTwoStepLoader);export{CellSetsZarrLoader as default};","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/anndata-loaders/CellSetsZarrLoader.js"],"names":["InternMap","treeInitialize","nodeAppendChild","initializeCellSetColor","SETS_DATATYPE_CELL","AbstractTwoStepLoader","LoaderResult","dataToCellSetsTree","data","options","cellNames","cellSets","cellSetScores","cellSetsTree","forEach","cellSetIds","j","name","groupName","levelZeroNode","children","length","Array","isArray","levelSets","JSON","stringify","id","i","classes","map","col","has","get","push","set","levels","from","keys","getNextLevelNames","levelSuffixes","nextLevelNames","Set","l","sort","a","b","localeCompare","getNode","parentLevelPrefixes","currLevelName","childLevelSuffixes","isLeaf","resultNode","shouldBeLeaf","nextLevelName","filter","slice","v","levelOneNodes","levelOneName","uniqueCellSetIds","clusters","Object","values","cluster","tree","CellSetsZarrLoader","cellSetZarrLocation","setName","dataSource","loadObsColumns","cellSetScoreZarrLocation","option","scoreName","undefined","Promise","all","loadObsIndex","loadCellSetIds","loadCellSetScores","then","coordinationValues","newAutoSetSelectionParentName","newAutoSetSelections","node","newAutoSetColors","obsSetSelection","obsSetColor","resolve"],"mappings":"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","sourcesContent":["/* eslint-disable no-control-regex */\nimport { InternMap } from 'internmap';\nimport {\n  treeInitialize,\n  nodeAppendChild,\n  initializeCellSetColor,\n} from '../../components/sets/cell-set-utils';\nimport {\n  SETS_DATATYPE_CELL,\n} from '../../components/sets/constants';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\nimport LoaderResult from '../LoaderResult';\n\nexport function dataToCellSetsTree(data, options) {\n  const [cellNames, cellSets, cellSetScores] = data;\n  const cellSetsTree = treeInitialize(SETS_DATATYPE_CELL);\n  cellSets.forEach((cellSetIds, j) => {\n    const name = options[j].groupName;\n    let levelZeroNode = {\n      name,\n      children: [],\n    };\n    if (cellSetIds.length > 0 && Array.isArray(cellSetIds[0])) {\n      // Multi-level case.\n      const levelSets = new InternMap([], JSON.stringify);\n\n      cellNames.forEach((id, i) => {\n        const classes = cellSetIds.map(col => col[i]);\n        if (levelSets.has(classes)) {\n          levelSets.get(classes).push([id, null]);\n        } else {\n          levelSets.set(classes, [[id, null]]);\n        }\n      });\n\n      const levels = Array.from(levelSets.keys());\n\n      const getNextLevelNames = (levelSuffixes) => {\n        const nextLevelNames = Array.from(new Set(levelSuffixes.map(l => l[0])));\n        return nextLevelNames.sort((a, b) => a.localeCompare(b));\n      };\n\n      // Recursive function to create nodes.\n      const getNode = (parentLevelPrefixes, currLevelName, childLevelSuffixes) => {\n        const isLeaf = childLevelSuffixes.length === 0;\n        const resultNode = {\n          name: currLevelName,\n        };\n        if (isLeaf) {\n          // Base case: this is a leaf node.\n          resultNode.set = levelSets.get([...parentLevelPrefixes, currLevelName]);\n        } else {\n          // Are the remaining suffices redundant?\n          // Consider [\"Parent\", \"Child\", \"Child\"]\n          // where parentLevelPrefixes is [\"Parent\"] and currLevelName is \"Child\".\n          const shouldBeLeaf = (\n            childLevelSuffixes.length === 1\n            && currLevelName === childLevelSuffixes[0][childLevelSuffixes[0].length - 1]\n          );\n          if (shouldBeLeaf) {\n            resultNode.set = levelSets.get(\n              [...parentLevelPrefixes, currLevelName, ...childLevelSuffixes[0]],\n            );\n          } else {\n            // Recursion, run getNode() on each of the unique names at the next level.\n            const nextLevelNames = getNextLevelNames(childLevelSuffixes);\n\n            resultNode.children = nextLevelNames\n              .map(nextLevelName => getNode(\n                [...parentLevelPrefixes, currLevelName],\n                nextLevelName,\n                childLevelSuffixes\n                  .filter(l => l[0] === nextLevelName)\n                  .map(l => l.slice(1))\n                  .filter(v => v.length > 0),\n              ));\n          }\n        }\n        return resultNode;\n      };\n      // Start the recursion.\n      const levelOneNodes = getNextLevelNames(levels)\n        .map(levelOneName => getNode(\n          [],\n          levelOneName,\n          levels.filter(l => l[0] === levelOneName).map(l => l.slice(1)),\n        ));\n\n      levelZeroNode.children = levelOneNodes;\n    } else {\n      // Single-level case.\n      // Check for the optional corresponding confidence score column name.\n      const uniqueCellSetIds = Array.from(new Set(cellSetIds)).sort();\n      const clusters = {};\n      // eslint-disable-next-line no-return-assign\n      uniqueCellSetIds.forEach(id => (clusters[id] = { name: id, set: [] }));\n      if (cellSetScores[j]) {\n        cellSetIds.forEach((id, i) => clusters[id].set.push([cellNames[i], cellSetScores[j][i]]));\n      } else {\n        cellSetIds.forEach((id, i) => clusters[id].set.push([cellNames[i], null]));\n      }\n      Object.values(clusters).forEach(\n        // eslint-disable-next-line no-return-assign\n        cluster => (levelZeroNode = nodeAppendChild(levelZeroNode, cluster)),\n      );\n    }\n    cellSetsTree.tree.push(levelZeroNode);\n  });\n  return cellSetsTree;\n}\n\n/**\n * Loader for converting zarr into the cell sets json schema.\n */\nexport default class CellSetsZarrLoader extends AbstractTwoStepLoader {\n  loadCellSetIds() {\n    const { options } = this;\n    const cellSetZarrLocation = options.map(({ setName }) => setName);\n    return this.dataSource.loadObsColumns(cellSetZarrLocation);\n  }\n\n  loadCellSetScores() {\n    const { options } = this;\n    const cellSetScoreZarrLocation = options.map(option => option.scoreName || undefined);\n    return this.dataSource.loadObsColumns(cellSetScoreZarrLocation);\n  }\n\n  async load() {\n    if (!this.cellSetsTree) {\n      const { options } = this;\n      this.cellSetsTree = Promise.all([\n        this.dataSource.loadObsIndex(),\n        this.loadCellSetIds(),\n        this.loadCellSetScores(),\n      ]).then(data => dataToCellSetsTree(data, options));\n    }\n    const cellSetsTree = await this.cellSetsTree;\n    const coordinationValues = {};\n    const { tree } = cellSetsTree;\n    const newAutoSetSelectionParentName = tree[0].name;\n    // Create a list of set paths to initally select.\n    const newAutoSetSelections = tree[0].children.map(node => [\n      newAutoSetSelectionParentName,\n      node.name,\n    ]);\n    // Create a list of cell set objects with color mappings.\n    const newAutoSetColors = initializeCellSetColor(cellSetsTree, []);\n    coordinationValues.obsSetSelection = newAutoSetSelections;\n    coordinationValues.obsSetColor = newAutoSetColors;\n    return Promise.resolve(\n      new LoaderResult(cellSetsTree, null, coordinationValues),\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}