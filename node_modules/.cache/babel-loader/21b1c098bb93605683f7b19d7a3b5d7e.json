{"ast":null,"code":"/**\n * No change to the vertex shader from the base BitmapLayer.\n * Reference: https://github.com/visgl/deck.gl/blob/8.2-release/modules/layers/src/bitmap-layer/bitmap-layer-vertex.js\n */\nexport const vertexShader = \"\\n#define SHADER_NAME heatmap-bitmap-layer-vertex-shader\\n\\nattribute vec2 texCoords;\\nattribute vec3 positions;\\nattribute vec3 positions64Low;\\n\\nvarying vec2 vTexCoord;\\n\\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  geometry.worldPosition = positions;\\n  geometry.uv = texCoords;\\n  geometry.pickingColor = pickingColor;\\n\\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  vTexCoord = texCoords;\\n\\n  vec4 color = vec4(0.0);\\n  DECKGL_FILTER_COLOR(color, geometry);\\n}\\n\";\n/**\n * Fragment shader adapted to perform aggregation and\n * take color scale functions + sliders into account.\n * Reference: https://github.com/visgl/deck.gl/blob/8.2-release/modules/layers/src/bitmap-layer/bitmap-layer-fragment.js\n * Reference: https://github.com/hms-dbmi/viv/blob/06231ae02cac1ff57ba458c71e9bc59ed2fc4f8b/src/layers/XRLayer/xr-layer-fragment-colormap.webgl1.glsl\n */\n\nexport const fragmentShader = \"\\n#define SHADER_NAME heatmap-bitmap-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision mediump float;\\n#endif\\n\\nvec4 rdbu (float x_3554215156) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0.0196078431372549,0.0392156862745098,0.6745098039215687,1);\\n  const float e1 = 0.35;\\n  const vec4 v1 = vec4(0.41568627450980394,0.5372549019607843,0.9686274509803922,1);\\n  const float e2 = 0.5;\\n  const vec4 v2 = vec4(0.7450980392156863,0.7450980392156863,0.7450980392156863,1);\\n  const float e3 = 0.6;\\n  const vec4 v3 = vec4(0.8627450980392157,0.6666666666666666,0.5176470588235295,1);\\n  const float e4 = 0.7;\\n  const vec4 v4 = vec4(0.9019607843137255,0.5686274509803921,0.35294117647058826,1);\\n  const float e5 = 1.0;\\n  const vec4 v5 = vec4(0.6980392156862745,0.0392156862745098,0.10980392156862745,1);\\n  float a0 = smoothstep(e0,e1,x_3554215156);\\n  float a1 = smoothstep(e1,e2,x_3554215156);\\n  float a2 = smoothstep(e2,e3,x_3554215156);\\n  float a3 = smoothstep(e3,e4,x_3554215156);\\n  float a4 = smoothstep(e4,e5,x_3554215156);\\n  return max(mix(v0,v1,a0)*step(e0,x_3554215156)*step(x_3554215156,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_3554215156)*step(x_3554215156,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_3554215156)*step(x_3554215156,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_3554215156)*step(x_3554215156,e4),mix(v4,v5,a4)*step(e4,x_3554215156)*step(x_3554215156,e5)\\n  ))));\\n}\\n\\nvec4 plasma (float x_965077949) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);\\n  const float e1 = 0.13;\\n  const vec4 v1 = vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);\\n  const float e2 = 0.25;\\n  const vec4 v2 = vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);\\n  const float e3 = 0.38;\\n  const vec4 v3 = vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);\\n  const float e4 = 0.5;\\n  const vec4 v4 = vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);\\n  const float e5 = 0.63;\\n  const vec4 v5 = vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);\\n  const float e6 = 0.75;\\n  const vec4 v6 = vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);\\n  const float e7 = 0.88;\\n  const vec4 v7 = vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);\\n  const float e8 = 1.0;\\n  const vec4 v8 = vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);\\n  float a0 = smoothstep(e0,e1,x_965077949);\\n  float a1 = smoothstep(e1,e2,x_965077949);\\n  float a2 = smoothstep(e2,e3,x_965077949);\\n  float a3 = smoothstep(e3,e4,x_965077949);\\n  float a4 = smoothstep(e4,e5,x_965077949);\\n  float a5 = smoothstep(e5,e6,x_965077949);\\n  float a6 = smoothstep(e6,e7,x_965077949);\\n  float a7 = smoothstep(e7,e8,x_965077949);\\n  return max(mix(v0,v1,a0)*step(e0,x_965077949)*step(x_965077949,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_965077949)*step(x_965077949,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_965077949)*step(x_965077949,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_965077949)*step(x_965077949,e4),\\n    max(mix(v4,v5,a4)*step(e4,x_965077949)*step(x_965077949,e5),\\n    max(mix(v5,v6,a5)*step(e5,x_965077949)*step(x_965077949,e6),\\n    max(mix(v6,v7,a6)*step(e6,x_965077949)*step(x_965077949,e7),mix(v7,v8,a7)*step(e7,x_965077949)*step(x_965077949,e8)\\n  )))))));\\n}\\n\\nvec4 viridis (float x_2028846312) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);\\n  const float e1 = 0.13;\\n  const vec4 v1 = vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);\\n  const float e2 = 0.25;\\n  const vec4 v2 = vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);\\n  const float e3 = 0.38;\\n  const vec4 v3 = vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);\\n  const float e4 = 0.5;\\n  const vec4 v4 = vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);\\n  const float e5 = 0.63;\\n  const vec4 v5 = vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);\\n  const float e6 = 0.75;\\n  const vec4 v6 = vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);\\n  const float e7 = 0.88;\\n  const vec4 v7 = vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);\\n  const float e8 = 1.0;\\n  const vec4 v8 = vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);\\n  float a0 = smoothstep(e0,e1,x_2028846312);\\n  float a1 = smoothstep(e1,e2,x_2028846312);\\n  float a2 = smoothstep(e2,e3,x_2028846312);\\n  float a3 = smoothstep(e3,e4,x_2028846312);\\n  float a4 = smoothstep(e4,e5,x_2028846312);\\n  float a5 = smoothstep(e5,e6,x_2028846312);\\n  float a6 = smoothstep(e6,e7,x_2028846312);\\n  float a7 = smoothstep(e7,e8,x_2028846312);\\n  return max(mix(v0,v1,a0)*step(e0,x_2028846312)*step(x_2028846312,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_2028846312)*step(x_2028846312,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_2028846312)*step(x_2028846312,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_2028846312)*step(x_2028846312,e4),\\n    max(mix(v4,v5,a4)*step(e4,x_2028846312)*step(x_2028846312,e5),\\n    max(mix(v5,v6,a5)*step(e5,x_2028846312)*step(x_2028846312,e6),\\n    max(mix(v6,v7,a6)*step(e6,x_2028846312)*step(x_2028846312,e7),mix(v7,v8,a7)*step(e7,x_2028846312)*step(x_2028846312,e8)\\n  )))))));\\n}\\n\\nvec4 greys (float x_3015742898) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,0,1);\\n  const float e1 = 1.0;\\n  const vec4 v1 = vec4(1,1,1,1);\\n  float a0 = smoothstep(e0,e1,x_3015742898);\\n  return mix(v0,v1,a0)*step(e0,x_3015742898)*step(x_3015742898,e1);\\n}\\n\\nvec4 magma (float x_3178904169) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\\n  const float e1 = 0.13;\\n  const vec4 v1 = vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);\\n  const float e2 = 0.25;\\n  const vec4 v2 = vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);\\n  const float e3 = 0.38;\\n  const vec4 v3 = vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);\\n  const float e4 = 0.5;\\n  const vec4 v4 = vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);\\n  const float e5 = 0.63;\\n  const vec4 v5 = vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);\\n  const float e6 = 0.75;\\n  const vec4 v6 = vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);\\n  const float e7 = 0.88;\\n  const vec4 v7 = vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);\\n  const float e8 = 1.0;\\n  const vec4 v8 = vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);\\n  float a0 = smoothstep(e0,e1,x_3178904169);\\n  float a1 = smoothstep(e1,e2,x_3178904169);\\n  float a2 = smoothstep(e2,e3,x_3178904169);\\n  float a3 = smoothstep(e3,e4,x_3178904169);\\n  float a4 = smoothstep(e4,e5,x_3178904169);\\n  float a5 = smoothstep(e5,e6,x_3178904169);\\n  float a6 = smoothstep(e6,e7,x_3178904169);\\n  float a7 = smoothstep(e7,e8,x_3178904169);\\n  return max(mix(v0,v1,a0)*step(e0,x_3178904169)*step(x_3178904169,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_3178904169)*step(x_3178904169,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_3178904169)*step(x_3178904169,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_3178904169)*step(x_3178904169,e4),\\n    max(mix(v4,v5,a4)*step(e4,x_3178904169)*step(x_3178904169,e5),\\n    max(mix(v5,v6,a5)*step(e5,x_3178904169)*step(x_3178904169,e6),\\n    max(mix(v6,v7,a6)*step(e6,x_3178904169)*step(x_3178904169,e7),mix(v7,v8,a7)*step(e7,x_3178904169)*step(x_3178904169,e8)\\n  )))))));\\n}\\n\\nvec4 jet (float x_4253652836) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,0.5137254901960784,1);\\n  const float e1 = 0.125;\\n  const vec4 v1 = vec4(0,0.23529411764705882,0.6666666666666666,1);\\n  const float e2 = 0.375;\\n  const vec4 v2 = vec4(0.0196078431372549,1,1,1);\\n  const float e3 = 0.625;\\n  const vec4 v3 = vec4(1,1,0,1);\\n  const float e4 = 0.875;\\n  const vec4 v4 = vec4(0.9803921568627451,0,0,1);\\n  const float e5 = 1.0;\\n  const vec4 v5 = vec4(0.5019607843137255,0,0,1);\\n  float a0 = smoothstep(e0,e1,x_4253652836);\\n  float a1 = smoothstep(e1,e2,x_4253652836);\\n  float a2 = smoothstep(e2,e3,x_4253652836);\\n  float a3 = smoothstep(e3,e4,x_4253652836);\\n  float a4 = smoothstep(e4,e5,x_4253652836);\\n  return max(mix(v0,v1,a0)*step(e0,x_4253652836)*step(x_4253652836,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_4253652836)*step(x_4253652836,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_4253652836)*step(x_4253652836,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_4253652836)*step(x_4253652836,e4),mix(v4,v5,a4)*step(e4,x_4253652836)*step(x_4253652836,e5)\\n  ))));\\n}\\n\\nvec4 bone (float x_4050060651) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,0,1);\\n  const float e1 = 0.376;\\n  const vec4 v1 = vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);\\n  const float e2 = 0.753;\\n  const vec4 v2 = vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);\\n  const float e3 = 1.0;\\n  const vec4 v3 = vec4(1,1,1,1);\\n  float a0 = smoothstep(e0,e1,x_4050060651);\\n  float a1 = smoothstep(e1,e2,x_4050060651);\\n  float a2 = smoothstep(e2,e3,x_4050060651);\\n  return max(mix(v0,v1,a0)*step(e0,x_4050060651)*step(x_4050060651,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_4050060651)*step(x_4050060651,e2),mix(v2,v3,a2)*step(e2,x_4050060651)*step(x_4050060651,e3)\\n  ));\\n}\\n\\nvec4 copper (float x_2733118543) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,0,1);\\n  const float e1 = 0.804;\\n  const vec4 v1 = vec4(1,0.6274509803921569,0.4,1);\\n  const float e2 = 1.0;\\n  const vec4 v2 = vec4(1,0.7803921568627451,0.4980392156862745,1);\\n  float a0 = smoothstep(e0,e1,x_2733118543);\\n  float a1 = smoothstep(e1,e2,x_2733118543);\\n  return max(mix(v0,v1,a0)*step(e0,x_2733118543)*step(x_2733118543,e1),mix(v1,v2,a1)*step(e1,x_2733118543)*step(x_2733118543,e2)\\n  );\\n}\\n\\nvec4 density (float x_1154134787) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);\\n  const float e1 = 0.13;\\n  const vec4 v1 = vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);\\n  const float e2 = 0.25;\\n  const vec4 v2 = vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);\\n  const float e3 = 0.38;\\n  const vec4 v3 = vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);\\n  const float e4 = 0.5;\\n  const vec4 v4 = vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);\\n  const float e5 = 0.63;\\n  const vec4 v5 = vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);\\n  const float e6 = 0.75;\\n  const vec4 v6 = vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);\\n  const float e7 = 0.88;\\n  const vec4 v7 = vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);\\n  const float e8 = 1.0;\\n  const vec4 v8 = vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);\\n  float a0 = smoothstep(e0,e1,x_1154134787);\\n  float a1 = smoothstep(e1,e2,x_1154134787);\\n  float a2 = smoothstep(e2,e3,x_1154134787);\\n  float a3 = smoothstep(e3,e4,x_1154134787);\\n  float a4 = smoothstep(e4,e5,x_1154134787);\\n  float a5 = smoothstep(e5,e6,x_1154134787);\\n  float a6 = smoothstep(e6,e7,x_1154134787);\\n  float a7 = smoothstep(e7,e8,x_1154134787);\\n  return max(mix(v0,v1,a0)*step(e0,x_1154134787)*step(x_1154134787,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_1154134787)*step(x_1154134787,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_1154134787)*step(x_1154134787,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_1154134787)*step(x_1154134787,e4),\\n    max(mix(v4,v5,a4)*step(e4,x_1154134787)*step(x_1154134787,e5),\\n    max(mix(v5,v6,a5)*step(e5,x_1154134787)*step(x_1154134787,e6),\\n    max(mix(v6,v7,a6)*step(e6,x_1154134787)*step(x_1154134787,e7),mix(v7,v8,a7)*step(e7,x_1154134787)*step(x_1154134787,e8)\\n  )))))));\\n}\\n\\nvec4 inferno (float x_123648472) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\\n  const float e1 = 0.13;\\n  const vec4 v1 = vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);\\n  const float e2 = 0.25;\\n  const vec4 v2 = vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);\\n  const float e3 = 0.38;\\n  const vec4 v3 = vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);\\n  const float e4 = 0.5;\\n  const vec4 v4 = vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);\\n  const float e5 = 0.63;\\n  const vec4 v5 = vec4(0.8901960784313725,0.34901960784313724,0.2,1);\\n  const float e6 = 0.75;\\n  const vec4 v6 = vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);\\n  const float e7 = 0.88;\\n  const vec4 v7 = vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);\\n  const float e8 = 1.0;\\n  const vec4 v8 = vec4(0.9882352941176471,1,0.6431372549019608,1);\\n  float a0 = smoothstep(e0,e1,x_123648472);\\n  float a1 = smoothstep(e1,e2,x_123648472);\\n  float a2 = smoothstep(e2,e3,x_123648472);\\n  float a3 = smoothstep(e3,e4,x_123648472);\\n  float a4 = smoothstep(e4,e5,x_123648472);\\n  float a5 = smoothstep(e5,e6,x_123648472);\\n  float a6 = smoothstep(e6,e7,x_123648472);\\n  float a7 = smoothstep(e7,e8,x_123648472);\\n  return max(mix(v0,v1,a0)*step(e0,x_123648472)*step(x_123648472,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_123648472)*step(x_123648472,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_123648472)*step(x_123648472,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_123648472)*step(x_123648472,e4),\\n    max(mix(v4,v5,a4)*step(e4,x_123648472)*step(x_123648472,e5),\\n    max(mix(v5,v6,a5)*step(e5,x_123648472)*step(x_123648472,e6),\\n    max(mix(v6,v7,a6)*step(e6,x_123648472)*step(x_123648472,e7),mix(v7,v8,a7)*step(e7,x_123648472)*step(x_123648472,e8)\\n  )))))));\\n}\\n\\nvec4 cool (float x_2109465733) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0.49019607843137253,0,0.7019607843137254,1);\\n  const float e1 = 0.13;\\n  const vec4 v1 = vec4(0.4549019607843137,0,0.8549019607843137,1);\\n  const float e2 = 0.25;\\n  const vec4 v2 = vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);\\n  const float e3 = 0.38;\\n  const vec4 v3 = vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);\\n  const float e4 = 0.5;\\n  const vec4 v4 = vec4(0,0.8,0.7725490196078432,1);\\n  const float e5 = 0.63;\\n  const vec4 v5 = vec4(0,0.9686274509803922,0.5725490196078431,1);\\n  const float e6 = 0.75;\\n  const vec4 v6 = vec4(0,1,0.34509803921568627,1);\\n  const float e7 = 0.88;\\n  const vec4 v7 = vec4(0.1568627450980392,1,0.03137254901960784,1);\\n  const float e8 = 1.0;\\n  const vec4 v8 = vec4(0.5764705882352941,1,0,1);\\n  float a0 = smoothstep(e0,e1,x_2109465733);\\n  float a1 = smoothstep(e1,e2,x_2109465733);\\n  float a2 = smoothstep(e2,e3,x_2109465733);\\n  float a3 = smoothstep(e3,e4,x_2109465733);\\n  float a4 = smoothstep(e4,e5,x_2109465733);\\n  float a5 = smoothstep(e5,e6,x_2109465733);\\n  float a6 = smoothstep(e6,e7,x_2109465733);\\n  float a7 = smoothstep(e7,e8,x_2109465733);\\n  return max(mix(v0,v1,a0)*step(e0,x_2109465733)*step(x_2109465733,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_2109465733)*step(x_2109465733,e2),\\n    max(mix(v2,v3,a2)*step(e2,x_2109465733)*step(x_2109465733,e3),\\n    max(mix(v3,v4,a3)*step(e3,x_2109465733)*step(x_2109465733,e4),\\n    max(mix(v4,v5,a4)*step(e4,x_2109465733)*step(x_2109465733,e5),\\n    max(mix(v5,v6,a5)*step(e5,x_2109465733)*step(x_2109465733,e6),\\n    max(mix(v6,v7,a6)*step(e6,x_2109465733)*step(x_2109465733,e7),mix(v7,v8,a7)*step(e7,x_2109465733)*step(x_2109465733,e8)\\n  )))))));\\n}\\n\\nvec4 hot (float x_409246039) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,0,1);\\n  const float e1 = 0.3;\\n  const vec4 v1 = vec4(0.9019607843137255,0,0,1);\\n  const float e2 = 0.6;\\n  const vec4 v2 = vec4(1,0.8235294117647058,0,1);\\n  const float e3 = 1.0;\\n  const vec4 v3 = vec4(1,1,1,1);\\n  float a0 = smoothstep(e0,e1,x_409246039);\\n  float a1 = smoothstep(e1,e2,x_409246039);\\n  float a2 = smoothstep(e2,e3,x_409246039);\\n  return max(mix(v0,v1,a0)*step(e0,x_409246039)*step(x_409246039,e1),\\n    max(mix(v1,v2,a1)*step(e1,x_409246039)*step(x_409246039,e2),mix(v2,v3,a2)*step(e2,x_409246039)*step(x_409246039,e3)\\n  ));\\n}\\n\\nvec4 spring (float x_449505064) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(1,0,1,1);\\n  const float e1 = 1.0;\\n  const vec4 v1 = vec4(1,1,0,1);\\n  float a0 = smoothstep(e0,e1,x_449505064);\\n  return mix(v0,v1,a0)*step(e0,x_449505064)*step(x_449505064,e1);\\n}\\n\\nvec4 summer (float x_1382014568) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0.5019607843137255,0.4,1);\\n  const float e1 = 1.0;\\n  const vec4 v1 = vec4(1,1,0.4,1);\\n  float a0 = smoothstep(e0,e1,x_1382014568);\\n  return mix(v0,v1,a0)*step(e0,x_1382014568)*step(x_1382014568,e1);\\n}\\n\\nvec4 autumn (float x_471540983) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(1,0,0,1);\\n  const float e1 = 1.0;\\n  const vec4 v1 = vec4(1,1,0,1);\\n  float a0 = smoothstep(e0,e1,x_471540983);\\n  return mix(v0,v1,a0)*step(e0,x_471540983)*step(x_471540983,e1);\\n}\\n\\nvec4 winter (float x_662449073) {\\n  const float e0 = 0.0;\\n  const vec4 v0 = vec4(0,0,1,1);\\n  const float e1 = 1.0;\\n  const vec4 v1 = vec4(0,1,0.5019607843137255,1);\\n  float a0 = smoothstep(e0,e1,x_662449073);\\n  return mix(v0,v1,a0)*step(e0,x_662449073)*step(x_662449073,e1);\\n}\\n\\n// The texture (GL.LUMINANCE & Uint8Array).\\nuniform sampler2D uBitmapTexture;\\n\\n// height x width of the data matrix (i.e x and y are flipped compared to the graphics convention)\\nuniform vec2 uOrigDataSize;\\nuniform vec2 uReshapedDataSize;\\n\\nuniform vec2 tileIJ;\\nuniform vec2 dataIJ;\\nuniform vec2 numTiles;\\n\\n// What are the dimensions of the texture (width, height)?\\nuniform vec2 uTextureSize;\\n\\n// How many consecutive pixels should be aggregated together along each axis?\\nuniform vec2 uAggSize;\\n\\n// What are the values of the color scale sliders?\\nuniform vec2 uColorScaleRange;\\n\\n// The texture coordinate, varying (interpolated between values set by the vertex shader).\\nvarying vec2 vTexCoord;\\n\\nvec2 offsetvTexcoord(vec2 coord) {\\n  float xTileToDataRatio = uTextureSize.x / uOrigDataSize.y;\\n  float yTileToDataRatio = uTextureSize.y / uOrigDataSize.x;\\n  vec2 vTexCoordOffset = vec2(\\n    (tileIJ.y * xTileToDataRatio) + (coord.x * xTileToDataRatio),\\n    (tileIJ.x * yTileToDataRatio) + ((1. - coord.y) * yTileToDataRatio)\\n  );\\n  return vTexCoordOffset;\\n}\\n\\nvec2 dataCoordinateFromvTexCoordOffset(vec2 vTexCoordOffset) {\\n  \\n  // True pixel coordinate on scale of uOrigDataSize\\n  vec2 viewCoord = vec2(floor(vTexCoordOffset.x * uOrigDataSize.y), floor(vTexCoordOffset.y * uOrigDataSize.x));\\n  return viewCoord;\\n}\\n\\nfloat getIndexFromViewCoord(vec2 viewCoord) {\\n  return viewCoord.y * uOrigDataSize.y + viewCoord.x;\\n}\\n\\nvec2 transformDataCoordinate(float index) {\\n  float textureX = (floor( index / uReshapedDataSize.x )) / uReshapedDataSize.x;\\n  float textureY = (index - (floor( index / uReshapedDataSize.x ) * uReshapedDataSize.x)) / uReshapedDataSize.y;\\n  vec2 texturedCoord = vec2(textureY, textureX);\\n  return texturedCoord;\\n}\\n\\nvoid main(void) {\\n  // Compute 1 pixel in texture coordinates\\n  vec2 onePixel = vec2(1.0, 1.0) / uTextureSize;\\n  vec2 vTexCoordOffset = offsetvTexcoord(vTexCoord);\\n  vec2 viewCoordTransformed = dataCoordinateFromvTexCoordOffset(vTexCoordOffset);\\n  // Compute (x % aggSizeX, y % aggSizeY).\\n  // These values will be the number of values to the left / above the current position to consider.\\n  vec2 modAggSize = vec2(-1.0 * mod(viewCoordTransformed.x, uAggSize.x), -1.0 * mod(viewCoordTransformed.y, uAggSize.y));\\n  // Take the sum of values along each axis.\\n  float intensitySum = 0.0;\\n  vec2 offsetPixels = vec2(0.0, 0.0);\\n  for(int i = 0; i < 16; i++) {\\n    // Check to break outer loop early.\\n    // Uniforms cannot be used as conditions in GLSL for loops.\\n    if(float(i) >= uAggSize.y) {\\n      // Done in the y direction.\\n      break;\\n    }\\n\\n    offsetPixels = vec2(offsetPixels.x, (modAggSize.y + float(i)));\\n\\n    for(int j = 0; j < 16; j++) {\\n      // Check to break inner loop early.\\n      // Uniforms cannot be used as conditions in GLSL for loops.\\n      if(float(j) >= uAggSize.x) {\\n        // Done in the x direction.\\n        break;\\n      }\\n      offsetPixels = vec2((modAggSize.x + float(j)), offsetPixels.y);\\n      float indexFull = getIndexFromViewCoord(viewCoordTransformed + offsetPixels);\\n      float index = indexFull - (floor(indexFull / (uReshapedDataSize.x * uReshapedDataSize.y)) * (uReshapedDataSize.x * uReshapedDataSize.y));\\n      vec2 vTexCoordTransformed = transformDataCoordinate(index);\\n      intensitySum += texture2D(uBitmapTexture, vTexCoordTransformed).r;\\n    }\\n  }\\n  \\n  // Compute the mean value.\\n  float intensityMean = intensitySum / (uAggSize.x * uAggSize.y);\\n  // Re-scale using the color scale slider values.\\n  float scaledIntensityMean = (intensityMean - uColorScaleRange[0]) / max(0.005, (uColorScaleRange[1] - uColorScaleRange[0]));\\n\\n  gl_FragColor = COLORMAP_FUNC(clamp(scaledIntensityMean, 0.0, 1.0));\\n\\n  geometry.uv = vTexCoord;\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/layers/padded-expression-heatmap-bitmap-layer-shaders.js"],"names":["vertexShader","fragmentShader"],"mappings":"AAEA;;;;AAIA,OAAO,MAAMA,YAAY,0mBAAlB;AA0BP;;;;;;;AAMA,OAAO,MAAMC,cAAc,qjpBAApB","sourcesContent":["import glsl from 'glslify';\n\n/**\n * No change to the vertex shader from the base BitmapLayer.\n * Reference: https://github.com/visgl/deck.gl/blob/8.2-release/modules/layers/src/bitmap-layer/bitmap-layer-vertex.js\n */\nexport const vertexShader = glsl`\n#define SHADER_NAME heatmap-bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n`;\n\n/**\n * Fragment shader adapted to perform aggregation and\n * take color scale functions + sliders into account.\n * Reference: https://github.com/visgl/deck.gl/blob/8.2-release/modules/layers/src/bitmap-layer/bitmap-layer-fragment.js\n * Reference: https://github.com/hms-dbmi/viv/blob/06231ae02cac1ff57ba458c71e9bc59ed2fc4f8b/src/layers/XRLayer/xr-layer-fragment-colormap.webgl1.glsl\n */\nexport const fragmentShader = glsl`\n#define SHADER_NAME heatmap-bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#pragma glslify: rdbu = require(\"glsl-colormap/rdbu\")\n#pragma glslify: plasma = require(\"glsl-colormap/plasma\")\n#pragma glslify: viridis = require(\"glsl-colormap/viridis\")\n#pragma glslify: greys = require(\"glsl-colormap/greys\")\n#pragma glslify: magma = require(\"glsl-colormap/magma\")\n#pragma glslify: jet = require(\"glsl-colormap/jet\")\n#pragma glslify: bone = require(\"glsl-colormap/bone\")\n#pragma glslify: copper = require(\"glsl-colormap/copper\")\n#pragma glslify: density = require(\"glsl-colormap/density\")\n#pragma glslify: inferno = require(\"glsl-colormap/inferno\")\n#pragma glslify: cool = require(\"glsl-colormap/cool\")\n#pragma glslify: hot = require(\"glsl-colormap/hot\")\n#pragma glslify: spring = require(\"glsl-colormap/spring\")\n#pragma glslify: summer = require(\"glsl-colormap/summer\")\n#pragma glslify: autumn = require(\"glsl-colormap/autumn\")\n#pragma glslify: winter = require(\"glsl-colormap/winter\")\n\n// The texture (GL.LUMINANCE & Uint8Array).\nuniform sampler2D uBitmapTexture;\n\n// height x width of the data matrix (i.e x and y are flipped compared to the graphics convention)\nuniform vec2 uOrigDataSize;\nuniform vec2 uReshapedDataSize;\n\nuniform vec2 tileIJ;\nuniform vec2 dataIJ;\nuniform vec2 numTiles;\n\n// What are the dimensions of the texture (width, height)?\nuniform vec2 uTextureSize;\n\n// How many consecutive pixels should be aggregated together along each axis?\nuniform vec2 uAggSize;\n\n// What are the values of the color scale sliders?\nuniform vec2 uColorScaleRange;\n\n// The texture coordinate, varying (interpolated between values set by the vertex shader).\nvarying vec2 vTexCoord;\n\nvec2 offsetvTexcoord(vec2 coord) {\n  float xTileToDataRatio = uTextureSize.x / uOrigDataSize.y;\n  float yTileToDataRatio = uTextureSize.y / uOrigDataSize.x;\n  vec2 vTexCoordOffset = vec2(\n    (tileIJ.y * xTileToDataRatio) + (coord.x * xTileToDataRatio),\n    (tileIJ.x * yTileToDataRatio) + ((1. - coord.y) * yTileToDataRatio)\n  );\n  return vTexCoordOffset;\n}\n\nvec2 dataCoordinateFromvTexCoordOffset(vec2 vTexCoordOffset) {\n  \n  // True pixel coordinate on scale of uOrigDataSize\n  vec2 viewCoord = vec2(floor(vTexCoordOffset.x * uOrigDataSize.y), floor(vTexCoordOffset.y * uOrigDataSize.x));\n  return viewCoord;\n}\n\nfloat getIndexFromViewCoord(vec2 viewCoord) {\n  return viewCoord.y * uOrigDataSize.y + viewCoord.x;\n}\n\nvec2 transformDataCoordinate(float index) {\n  float textureX = (floor( index / uReshapedDataSize.x )) / uReshapedDataSize.x;\n  float textureY = (index - (floor( index / uReshapedDataSize.x ) * uReshapedDataSize.x)) / uReshapedDataSize.y;\n  vec2 texturedCoord = vec2(textureY, textureX);\n  return texturedCoord;\n}\n\nvoid main(void) {\n  // Compute 1 pixel in texture coordinates\n  vec2 onePixel = vec2(1.0, 1.0) / uTextureSize;\n  vec2 vTexCoordOffset = offsetvTexcoord(vTexCoord);\n  vec2 viewCoordTransformed = dataCoordinateFromvTexCoordOffset(vTexCoordOffset);\n  // Compute (x % aggSizeX, y % aggSizeY).\n  // These values will be the number of values to the left / above the current position to consider.\n  vec2 modAggSize = vec2(-1.0 * mod(viewCoordTransformed.x, uAggSize.x), -1.0 * mod(viewCoordTransformed.y, uAggSize.y));\n  // Take the sum of values along each axis.\n  float intensitySum = 0.0;\n  vec2 offsetPixels = vec2(0.0, 0.0);\n  for(int i = 0; i < 16; i++) {\n    // Check to break outer loop early.\n    // Uniforms cannot be used as conditions in GLSL for loops.\n    if(float(i) >= uAggSize.y) {\n      // Done in the y direction.\n      break;\n    }\n\n    offsetPixels = vec2(offsetPixels.x, (modAggSize.y + float(i)));\n\n    for(int j = 0; j < 16; j++) {\n      // Check to break inner loop early.\n      // Uniforms cannot be used as conditions in GLSL for loops.\n      if(float(j) >= uAggSize.x) {\n        // Done in the x direction.\n        break;\n      }\n      offsetPixels = vec2((modAggSize.x + float(j)), offsetPixels.y);\n      float indexFull = getIndexFromViewCoord(viewCoordTransformed + offsetPixels);\n      float index = indexFull - (floor(indexFull / (uReshapedDataSize.x * uReshapedDataSize.y)) * (uReshapedDataSize.x * uReshapedDataSize.y));\n      vec2 vTexCoordTransformed = transformDataCoordinate(index);\n      intensitySum += texture2D(uBitmapTexture, vTexCoordTransformed).r;\n    }\n  }\n  \n  // Compute the mean value.\n  float intensityMean = intensitySum / (uAggSize.x * uAggSize.y);\n  // Re-scale using the color scale slider values.\n  float scaledIntensityMean = (intensityMean - uColorScaleRange[0]) / max(0.005, (uColorScaleRange[1] - uColorScaleRange[0]));\n\n  gl_FragColor = COLORMAP_FUNC(clamp(scaledIntensityMean, 0.0, 1.0));\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n"]},"metadata":{},"sourceType":"module"}