{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport { earcut } from '@math.gl/polygon';\nexport function flatGeojsonToBinary(features, geometryInfo, options) {\n  var propArrayTypes = extractNumericPropTypes(features);\n  var numericPropKeys = Object.keys(propArrayTypes).filter(function (k) {\n    return propArrayTypes[k] !== Array;\n  });\n  return fillArrays(features, _objectSpread({\n    propArrayTypes: propArrayTypes\n  }, geometryInfo), {\n    numericPropKeys: options && options.numericPropKeys || numericPropKeys,\n    PositionDataType: options ? options.PositionDataType : Float32Array\n  });\n}\nexport var TEST_EXPORTS = {\n  extractNumericPropTypes: extractNumericPropTypes\n};\n\nfunction extractNumericPropTypes(features) {\n  var propArrayTypes = {};\n\n  var _iterator = _createForOfIteratorHelper(features),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var feature = _step.value;\n\n      if (feature.properties) {\n        for (var key in feature.properties) {\n          var val = feature.properties[key];\n          propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return propArrayTypes;\n}\n\nfunction fillArrays(features, geometryInfo, options) {\n  var pointPositionsCount = geometryInfo.pointPositionsCount,\n      pointFeaturesCount = geometryInfo.pointFeaturesCount,\n      linePositionsCount = geometryInfo.linePositionsCount,\n      linePathsCount = geometryInfo.linePathsCount,\n      lineFeaturesCount = geometryInfo.lineFeaturesCount,\n      polygonPositionsCount = geometryInfo.polygonPositionsCount,\n      polygonObjectsCount = geometryInfo.polygonObjectsCount,\n      polygonRingsCount = geometryInfo.polygonRingsCount,\n      polygonFeaturesCount = geometryInfo.polygonFeaturesCount,\n      propArrayTypes = geometryInfo.propArrayTypes,\n      coordLength = geometryInfo.coordLength;\n  var _options$numericPropK = options.numericPropKeys,\n      numericPropKeys = _options$numericPropK === void 0 ? [] : _options$numericPropK,\n      _options$PositionData = options.PositionDataType,\n      PositionDataType = _options$PositionData === void 0 ? Float32Array : _options$PositionData;\n  var hasGlobalId = features[0] && 'id' in features[0];\n  var GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  var points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  var lines = {\n    type: 'LineString',\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  var polygons = {\n    type: 'Polygon',\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  for (var _i = 0, _arr = [points, lines, polygons]; _i < _arr.length; _i++) {\n    var object = _arr[_i];\n\n    var _iterator2 = _createForOfIteratorHelper(numericPropKeys),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var propName = _step2.value;\n        var T = propArrayTypes[propName];\n        object.numericProps[propName] = new T(object.positions.length / coordLength);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  var indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  var _iterator3 = _createForOfIteratorHelper(features),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var feature = _step3.value;\n      var geometry = feature.geometry;\n      var properties = feature.properties || {};\n\n      switch (geometry.type) {\n        case 'Point':\n          handlePoint(geometry, points, indexMap, coordLength, properties);\n          points.properties.push(keepStringProperties(properties, numericPropKeys));\n\n          if (hasGlobalId) {\n            points.fields.push({\n              id: feature.id\n            });\n          }\n\n          indexMap.pointFeature++;\n          break;\n\n        case 'LineString':\n          handleLineString(geometry, lines, indexMap, coordLength, properties);\n          lines.properties.push(keepStringProperties(properties, numericPropKeys));\n\n          if (hasGlobalId) {\n            lines.fields.push({\n              id: feature.id\n            });\n          }\n\n          indexMap.lineFeature++;\n          break;\n\n        case 'Polygon':\n          handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n          polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n\n          if (hasGlobalId) {\n            polygons.fields.push({\n              id: feature.id\n            });\n          }\n\n          indexMap.polygonFeature++;\n          break;\n\n        default:\n          throw new Error('Invalid geometry type');\n      }\n\n      indexMap.feature++;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\n\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n\n  for (var i = 0, il = geometry.indices.length; i < il; ++i) {\n    var start = geometry.indices[i];\n    var end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n\n  for (var l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    var startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    var areas = geometry.areas[l];\n    var indices = geometry.indices[l];\n    var nextIndices = geometry.indices[l + 1];\n\n    for (var i = 0, il = indices.length; i < il; ++i) {\n      var start = indices[i];\n      var end = i === il - 1 ? nextIndices === undefined ? geometry.data.length : nextIndices[0] : indices[i + 1];\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    var endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {\n      startPosition: startPosition,\n      endPosition: endPosition,\n      coordLength: coordLength\n    });\n  }\n}\n\nfunction triangulatePolygon(polygons, areas, indices, _ref) {\n  var startPosition = _ref.startPosition,\n      endPosition = _ref.endPosition,\n      coordLength = _ref.coordLength;\n  var start = startPosition * coordLength;\n  var end = endPosition * coordLength;\n  var polygonPositions = polygons.positions.subarray(start, end);\n  var offset = indices[0];\n  var holes = indices.slice(1).map(function (n) {\n    return (n - offset) / coordLength;\n  });\n  var triangles = earcut(polygonPositions, holes, coordLength, areas);\n\n  for (var t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n\nfunction wrapProps(obj, size) {\n  var returnObj = {};\n\n  for (var key in obj) {\n    returnObj[key] = {\n      value: obj[key],\n      size: size\n    };\n  }\n\n  return returnObj;\n}\n\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  return {\n    points: _objectSpread({}, points, {\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(points.numericProps, 1)\n    }),\n    lines: _objectSpread({}, lines, {\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(lines.numericProps, 1)\n    }),\n    polygons: _objectSpread({}, polygons, {\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      triangles: {\n        value: new Uint32Array(polygons.triangles),\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(polygons.numericProps, 1)\n    })\n  };\n}\n\nfunction fillNumericProperties(object, properties, index, length) {\n  for (var numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      var value = properties[numericPropName];\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n\nfunction keepStringProperties(properties, numericKeys) {\n  var props = {};\n\n  for (var key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n\n  return props;\n}\n\nfunction deduceArrayType(x, constructor) {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}","map":{"version":3,"sources":["../../../src/lib/flat-geojson-to-binary.ts"],"names":["propArrayTypes","extractNumericPropTypes","numericPropKeys","Object","k","fillArrays","geometryInfo","options","PositionDataType","Float32Array","TEST_EXPORTS","feature","val","deduceArrayType","coordLength","hasGlobalId","features","GlobalFeatureIdsDataType","points","type","positions","pointPositionsCount","globalFeatureIds","featureIds","pointFeaturesCount","numericProps","properties","fields","lines","pathIndices","linePositionsCount","linePathsCount","lineFeaturesCount","polygons","polygonIndices","polygonPositionsCount","polygonObjectsCount","primitivePolygonIndices","polygonRingsCount","triangles","polygonFeaturesCount","object","T","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","geometry","handlePoint","keepStringProperties","id","handleLineString","handlePolygon","makeAccessorObjects","nPositions","fillNumericProperties","i","il","start","end","l","ll","startPosition","areas","indices","nextIndices","endPosition","triangulatePolygon","polygonPositions","offset","holes","n","earcut","t","tl","returnObj","value","obj","size","wrapProps","numericPropName","index","props","numericKeys","constructor","Number","Math"],"mappings":"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","sourcesContent":["/* eslint-disable indent */\nimport {earcut} from '@math.gl/polygon';\nimport type {\n  BinaryAttribute,\n  BinaryFeatures,\n  FlatFeature,\n  FlatPoint,\n  FlatLineString,\n  FlatPolygon,\n  GeojsonGeometryInfo,\n  TypedArray\n} from '@loaders.gl/schema';\nimport {PropArrayConstructor, Lines, Points, Polygons} from './flat-geojson-to-binary-types';\n\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo,\n  options?: FlatGeojsonToBinaryOptions\n) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);\n  return fillArrays(\n    features,\n    {\n      propArrayTypes,\n      ...geometryInfo\n    },\n    {\n      numericPropKeys: (options && options.numericPropKeys) || numericPropKeys,\n      PositionDataType: options ? options.PositionDataType : Float32Array\n    }\n  );\n}\n\n/**\n * Options for `flatGeojsonToBinary`\n */\nexport type FlatGeojsonToBinaryOptions = {\n  numericPropKeys?: string[];\n  PositionDataType?: Float32ArrayConstructor | Float64ArrayConstructor;\n};\n\nexport const TEST_EXPORTS = {\n  extractNumericPropTypes\n};\n\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features: FlatFeature[]): {\n  [key: string]: PropArrayConstructor;\n} {\n  const propArrayTypes = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return propArrayTypes;\n}\n\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity\nfunction fillArrays(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo & {\n    propArrayTypes: {[key: string]: PropArrayConstructor};\n  },\n  options: FlatGeojsonToBinaryOptions\n) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    propArrayTypes,\n    coordLength\n  } = geometryInfo;\n  const {numericPropKeys = [], PositionDataType = Float32Array} = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points: Points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines: Lines = {\n    type: 'LineString',\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons: Polygons = {\n    type: 'Polygon',\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const T = propArrayTypes[propName];\n      object.numericProps[propName] = new T(object.positions.length / coordLength) as TypedArray;\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({id: feature.id});\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({id: feature.id});\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({id: feature.id});\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(\n  geometry: FlatPoint,\n  points: Points,\n  indexMap: {\n    pointPosition: number;\n    pointFeature: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n  points.featureIds.fill(\n    indexMap.pointFeature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n\n  indexMap.pointPosition += nPositions;\n}\n\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(\n  geometry: FlatLineString,\n  lines: Lines,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition: number;\n    linePath: number;\n    lineFeature: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n  lines.featureIds.fill(\n    indexMap.lineFeature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n\n  for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.indices[i];\n    const end =\n      i === il - 1\n        ? geometry.data.length // last line, so read to end of data\n        : geometry.indices[i + 1]; // start index for next line\n\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(\n  geometry: FlatPolygon,\n  polygons: Polygons,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition: number;\n    polygonObject: number;\n    polygonRing: number;\n    polygonFeature: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n  polygons.featureIds.fill(\n    indexMap.polygonFeature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n\n  // Unlike Point & LineString geometry.indices is a 2D array\n  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n\n    const areas = geometry.areas[l];\n    const indices = geometry.indices[l];\n    const nextIndices = geometry.indices[l + 1];\n\n    for (let i = 0, il = indices.length; i < il; ++i) {\n      const start = indices[i];\n      const end =\n        i === il - 1\n          ? // last line, so either read to:\n            nextIndices === undefined\n            ? geometry.data.length // end of data (no next indices)\n            : nextIndices[0] // start of first line in nextIndices\n          : indices[i + 1]; // start index for next line\n\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {startPosition, endPosition, coordLength});\n  }\n}\n\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(\n  polygons: Polygons,\n  areas: number[],\n  indices: number[],\n  {\n    startPosition,\n    endPosition,\n    coordLength\n  }: {startPosition: number; endPosition: number; coordLength: number}\n): void {\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const offset = indices[0];\n  const holes = indices.slice(1).map((n: number) => (n - offset) / coordLength);\n\n  // Compute triangulation\n  const triangles = earcut(polygonPositions, holes, coordLength, areas);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(\n  obj: {[key: string]: TypedArray},\n  size: number\n): {[key: string]: BinaryAttribute} {\n  const returnObj = {};\n  for (const key in obj) {\n    returnObj[key] = {value: obj[key], size};\n  }\n  return returnObj;\n}\n\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(\n  points: Points,\n  lines: Lines,\n  polygons: Polygons,\n  coordLength: number\n): BinaryFeatures {\n  return {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1},\n      numericProps: wrapProps(points.numericProps, 1)\n    },\n    lines: {\n      ...lines,\n      positions: {value: lines.positions, size: coordLength},\n      pathIndices: {value: lines.pathIndices, size: 1},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1},\n      numericProps: wrapProps(lines.numericProps, 1)\n    },\n    polygons: {\n      ...polygons,\n      positions: {value: polygons.positions, size: coordLength},\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      triangles: {value: new Uint32Array(polygons.triangles), size: 1},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1},\n      numericProps: wrapProps(polygons.numericProps, 1)\n    }\n  };\n}\n\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(\n  object: Points | Lines | Polygons,\n  properties: {[x: string]: string | number | boolean | null},\n  index: number,\n  length: number\n): void {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      const value = properties[numericPropName] as number;\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(\n  properties: {[x: string]: string | number | boolean | null},\n  numericKeys: string[]\n) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x: any, constructor: PropArrayConstructor): PropArrayConstructor {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n"]},"metadata":{},"sourceType":"module"}