{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject } from 'vega';\nimport { isString, toSet } from 'vega-util';\nimport * as CHANNEL from './channel';\nimport { isColorChannel } from './channel';\nimport * as log from './log';\nimport { NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL } from './type';\nimport { contains, keys } from './util';\nexport const ScaleType = {\n  // Continuous - Quantitative\n  LINEAR: 'linear',\n  LOG: 'log',\n  POW: 'pow',\n  SQRT: 'sqrt',\n  SYMLOG: 'symlog',\n  IDENTITY: 'identity',\n  SEQUENTIAL: 'sequential',\n  // Continuous - Time\n  TIME: 'time',\n  UTC: 'utc',\n  // Discretizing scales\n  QUANTILE: 'quantile',\n  QUANTIZE: 'quantize',\n  THRESHOLD: 'threshold',\n  BIN_ORDINAL: 'bin-ordinal',\n  // Discrete scales\n  ORDINAL: 'ordinal',\n  POINT: 'point',\n  BAND: 'band'\n};\n/**\n * Index for scale categories -- only scale of the same categories can be merged together.\n * Current implementation is trying to be conservative and avoid merging scale type that might not work together\n */\n\nexport const SCALE_CATEGORY_INDEX = {\n  linear: 'numeric',\n  log: 'numeric',\n  pow: 'numeric',\n  sqrt: 'numeric',\n  symlog: 'numeric',\n  identity: 'numeric',\n  sequential: 'numeric',\n  time: 'time',\n  utc: 'time',\n  ordinal: 'ordinal',\n  'bin-ordinal': 'bin-ordinal',\n  point: 'ordinal-position',\n  band: 'ordinal-position',\n  quantile: 'discretizing',\n  quantize: 'discretizing',\n  threshold: 'discretizing'\n};\nexport const SCALE_TYPES = keys(SCALE_CATEGORY_INDEX);\n/**\n * Whether the two given scale types can be merged together.\n */\n\nexport function scaleCompatible(scaleType1, scaleType2) {\n  const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];\n  const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];\n  return scaleCategory1 === scaleCategory2 || scaleCategory1 === 'ordinal-position' && scaleCategory2 === 'time' || scaleCategory2 === 'ordinal-position' && scaleCategory1 === 'time';\n}\n/**\n * Index for scale precedence -- high score = higher priority for merging.\n */\n\nconst SCALE_PRECEDENCE_INDEX = {\n  // numeric\n  linear: 0,\n  log: 1,\n  pow: 1,\n  sqrt: 1,\n  symlog: 1,\n  identity: 1,\n  sequential: 1,\n  // time\n  time: 0,\n  utc: 0,\n  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data\n  point: 10,\n  band: 11,\n  // non grouped types\n  ordinal: 0,\n  'bin-ordinal': 0,\n  quantile: 0,\n  quantize: 0,\n  threshold: 0\n};\n/**\n * Return scale categories -- only scale of the same categories can be merged together.\n */\n\nexport function scaleTypePrecedence(scaleType) {\n  return SCALE_PRECEDENCE_INDEX[scaleType];\n}\nexport const CONTINUOUS_TO_CONTINUOUS_SCALES = ['linear', 'log', 'pow', 'sqrt', 'symlog', 'time', 'utc'];\nconst CONTINUOUS_TO_CONTINUOUS_INDEX = toSet(CONTINUOUS_TO_CONTINUOUS_SCALES);\nexport const QUANTITATIVE_SCALES = ['linear', 'log', 'pow', 'sqrt', 'symlog'];\nconst QUANTITATIVE_SCALES_INDEX = toSet(QUANTITATIVE_SCALES);\nexport function isQuantitative(type) {\n  return type in QUANTITATIVE_SCALES_INDEX;\n}\nexport const CONTINUOUS_TO_DISCRETE_SCALES = ['quantile', 'quantize', 'threshold'];\nconst CONTINUOUS_TO_DISCRETE_INDEX = toSet(CONTINUOUS_TO_DISCRETE_SCALES);\nexport const CONTINUOUS_DOMAIN_SCALES = CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['quantile', 'quantize', 'threshold', 'sequential', 'identity']);\nconst CONTINUOUS_DOMAIN_INDEX = toSet(CONTINUOUS_DOMAIN_SCALES);\nexport const DISCRETE_DOMAIN_SCALES = ['ordinal', 'bin-ordinal', 'point', 'band'];\nconst DISCRETE_DOMAIN_INDEX = toSet(DISCRETE_DOMAIN_SCALES);\nexport const TIME_SCALE_TYPES = ['time', 'utc'];\nexport function hasDiscreteDomain(type) {\n  return type in DISCRETE_DOMAIN_INDEX;\n}\nexport function hasContinuousDomain(type) {\n  return type in CONTINUOUS_DOMAIN_INDEX;\n}\nexport function isContinuousToContinuous(type) {\n  return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\nexport function isContinuousToDiscrete(type) {\n  return type in CONTINUOUS_TO_DISCRETE_INDEX;\n}\nexport const defaultScaleConfig = {\n  pointPadding: 0.5,\n  barBandPaddingInner: 0.1,\n  rectBandPaddingInner: 0,\n  minBandSize: 2,\n  minFontSize: 8,\n  maxFontSize: 40,\n  minOpacity: 0.3,\n  maxOpacity: 0.8,\n  // FIXME: revise if these *can* become ratios of width/height step\n  minSize: 9,\n  minStrokeWidth: 1,\n  maxStrokeWidth: 4,\n  quantileCount: 4,\n  quantizeCount: 4\n};\nexport function isExtendedScheme(scheme) {\n  return !isString(scheme) && !!scheme['name'];\n}\nexport function isParameterDomain(domain) {\n  return domain === null || domain === void 0 ? void 0 : domain['param'];\n}\nexport function isDomainUnionWith(domain) {\n  return domain && domain['unionWith'];\n}\nexport function isFieldRange(range) {\n  return isObject(range) && 'field' in range;\n}\nconst SCALE_PROPERTY_INDEX = {\n  type: 1,\n  domain: 1,\n  domainMax: 1,\n  domainMin: 1,\n  domainMid: 1,\n  align: 1,\n  range: 1,\n  rangeMax: 1,\n  rangeMin: 1,\n  scheme: 1,\n  bins: 1,\n  // Other properties\n  reverse: 1,\n  round: 1,\n  // quantitative / time\n  clamp: 1,\n  nice: 1,\n  // quantitative\n  base: 1,\n  exponent: 1,\n  constant: 1,\n  interpolate: 1,\n  zero: 1,\n  // band/point\n  padding: 1,\n  paddingInner: 1,\n  paddingOuter: 1\n};\nexport const SCALE_PROPERTIES = keys(SCALE_PROPERTY_INDEX);\n\nconst {\n  type,\n  domain,\n  range,\n  rangeMax,\n  rangeMin,\n  scheme\n} = SCALE_PROPERTY_INDEX,\n      NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest(SCALE_PROPERTY_INDEX, [\"type\", \"domain\", \"range\", \"rangeMax\", \"rangeMin\", \"scheme\"]);\n\nexport const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);\nexport function scaleTypeSupportProperty(scaleType, propName) {\n  switch (propName) {\n    case 'type':\n    case 'domain':\n    case 'reverse':\n    case 'range':\n      return true;\n\n    case 'scheme':\n    case 'interpolate':\n      return !['point', 'band', 'identity'].includes(scaleType);\n\n    case 'bins':\n      return !['point', 'band', 'identity', 'ordinal'].includes(scaleType);\n\n    case 'round':\n      return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n\n    case 'padding':\n    case 'rangeMin':\n    case 'rangeMax':\n      return isContinuousToContinuous(scaleType) || ['point', 'band'].includes(scaleType);\n\n    case 'paddingOuter':\n    case 'align':\n      return ['point', 'band'].includes(scaleType);\n\n    case 'paddingInner':\n      return scaleType === 'band';\n\n    case 'domainMax':\n    case 'domainMid':\n    case 'domainMin':\n    case 'clamp':\n      return isContinuousToContinuous(scaleType);\n\n    case 'nice':\n      return isContinuousToContinuous(scaleType) || scaleType === 'quantize' || scaleType === 'threshold';\n\n    case 'exponent':\n      return scaleType === 'pow';\n\n    case 'base':\n      return scaleType === 'log';\n\n    case 'constant':\n      return scaleType === 'symlog';\n\n    case 'zero':\n      return hasContinuousDomain(scaleType) && !contains(['log', 'time', 'utc', 'threshold', 'quantile' // quantile depends on distribution so zero does not matter\n      ], scaleType);\n  }\n}\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\n\nexport function channelScalePropertyIncompatability(channel, propName) {\n  switch (propName) {\n    case 'interpolate':\n    case 'scheme':\n    case 'domainMid':\n      if (!isColorChannel(channel)) {\n        return log.message.cannotUseScalePropertyWithNonColor(channel);\n      }\n\n      return undefined;\n\n    case 'align':\n    case 'type':\n    case 'bins':\n    case 'domain':\n    case 'domainMax':\n    case 'domainMin':\n    case 'range':\n    case 'base':\n    case 'exponent':\n    case 'constant':\n    case 'nice':\n    case 'padding':\n    case 'paddingInner':\n    case 'paddingOuter':\n    case 'rangeMax':\n    case 'rangeMin':\n    case 'reverse':\n    case 'round':\n    case 'clamp':\n    case 'zero':\n      return undefined;\n    // GOOD!\n  }\n}\nexport function scaleTypeSupportDataType(specifiedType, fieldDefType) {\n  if (contains([ORDINAL, NOMINAL], fieldDefType)) {\n    return specifiedType === undefined || hasDiscreteDomain(specifiedType);\n  } else if (fieldDefType === TEMPORAL) {\n    return contains([ScaleType.TIME, ScaleType.UTC, undefined], specifiedType);\n  } else if (fieldDefType === QUANTITATIVE) {\n    return contains([ScaleType.LOG, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD, ScaleType.LINEAR, undefined], specifiedType);\n  }\n\n  return true;\n}\nexport function channelSupportScaleType(channel, scaleType) {\n  if (!CHANNEL.isScaleChannel(channel)) {\n    return false;\n  }\n\n  switch (channel) {\n    case CHANNEL.X:\n    case CHANNEL.Y:\n    case CHANNEL.THETA:\n    case CHANNEL.RADIUS:\n      return isContinuousToContinuous(scaleType) || contains(['band', 'point'], scaleType);\n\n    case CHANNEL.SIZE: // TODO: size and opacity can support ordinal with more modification\n\n    case CHANNEL.STROKEWIDTH:\n    case CHANNEL.OPACITY:\n    case CHANNEL.FILLOPACITY:\n    case CHANNEL.STROKEOPACITY:\n    case CHANNEL.ANGLE:\n      // Although it generally doesn't make sense to use band with size and opacity,\n      // it can also work since we use band: 0.5 to get midpoint.\n      return isContinuousToContinuous(scaleType) || isContinuousToDiscrete(scaleType) || contains(['band', 'point', 'ordinal'], scaleType);\n\n    case CHANNEL.COLOR:\n    case CHANNEL.FILL:\n    case CHANNEL.STROKE:\n      return scaleType !== 'band';\n    // band does not make sense with color\n\n    case CHANNEL.STROKEDASH:\n    case CHANNEL.SHAPE:\n      return scaleType === 'ordinal' || isContinuousToDiscrete(scaleType);\n  }\n}","map":{"version":3,"sources":["../../src/scale.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject } from 'vega';\nimport { isString, toSet } from 'vega-util';\nimport * as CHANNEL from './channel';\nimport { isColorChannel } from './channel';\nimport * as log from './log';\nimport { NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL } from './type';\nimport { contains, keys } from './util';\nexport const ScaleType = {\n    // Continuous - Quantitative\n    LINEAR: 'linear',\n    LOG: 'log',\n    POW: 'pow',\n    SQRT: 'sqrt',\n    SYMLOG: 'symlog',\n    IDENTITY: 'identity',\n    SEQUENTIAL: 'sequential',\n    // Continuous - Time\n    TIME: 'time',\n    UTC: 'utc',\n    // Discretizing scales\n    QUANTILE: 'quantile',\n    QUANTIZE: 'quantize',\n    THRESHOLD: 'threshold',\n    BIN_ORDINAL: 'bin-ordinal',\n    // Discrete scales\n    ORDINAL: 'ordinal',\n    POINT: 'point',\n    BAND: 'band'\n};\n/**\n * Index for scale categories -- only scale of the same categories can be merged together.\n * Current implementation is trying to be conservative and avoid merging scale type that might not work together\n */\nexport const SCALE_CATEGORY_INDEX = {\n    linear: 'numeric',\n    log: 'numeric',\n    pow: 'numeric',\n    sqrt: 'numeric',\n    symlog: 'numeric',\n    identity: 'numeric',\n    sequential: 'numeric',\n    time: 'time',\n    utc: 'time',\n    ordinal: 'ordinal',\n    'bin-ordinal': 'bin-ordinal',\n    point: 'ordinal-position',\n    band: 'ordinal-position',\n    quantile: 'discretizing',\n    quantize: 'discretizing',\n    threshold: 'discretizing'\n};\nexport const SCALE_TYPES = keys(SCALE_CATEGORY_INDEX);\n/**\n * Whether the two given scale types can be merged together.\n */\nexport function scaleCompatible(scaleType1, scaleType2) {\n    const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];\n    const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];\n    return (scaleCategory1 === scaleCategory2 ||\n        (scaleCategory1 === 'ordinal-position' && scaleCategory2 === 'time') ||\n        (scaleCategory2 === 'ordinal-position' && scaleCategory1 === 'time'));\n}\n/**\n * Index for scale precedence -- high score = higher priority for merging.\n */\nconst SCALE_PRECEDENCE_INDEX = {\n    // numeric\n    linear: 0,\n    log: 1,\n    pow: 1,\n    sqrt: 1,\n    symlog: 1,\n    identity: 1,\n    sequential: 1,\n    // time\n    time: 0,\n    utc: 0,\n    // ordinal-position -- these have higher precedence than continuous scales as they support more types of data\n    point: 10,\n    band: 11,\n    // non grouped types\n    ordinal: 0,\n    'bin-ordinal': 0,\n    quantile: 0,\n    quantize: 0,\n    threshold: 0\n};\n/**\n * Return scale categories -- only scale of the same categories can be merged together.\n */\nexport function scaleTypePrecedence(scaleType) {\n    return SCALE_PRECEDENCE_INDEX[scaleType];\n}\nexport const CONTINUOUS_TO_CONTINUOUS_SCALES = ['linear', 'log', 'pow', 'sqrt', 'symlog', 'time', 'utc'];\nconst CONTINUOUS_TO_CONTINUOUS_INDEX = toSet(CONTINUOUS_TO_CONTINUOUS_SCALES);\nexport const QUANTITATIVE_SCALES = ['linear', 'log', 'pow', 'sqrt', 'symlog'];\nconst QUANTITATIVE_SCALES_INDEX = toSet(QUANTITATIVE_SCALES);\nexport function isQuantitative(type) {\n    return type in QUANTITATIVE_SCALES_INDEX;\n}\nexport const CONTINUOUS_TO_DISCRETE_SCALES = ['quantile', 'quantize', 'threshold'];\nconst CONTINUOUS_TO_DISCRETE_INDEX = toSet(CONTINUOUS_TO_DISCRETE_SCALES);\nexport const CONTINUOUS_DOMAIN_SCALES = CONTINUOUS_TO_CONTINUOUS_SCALES.concat([\n    'quantile',\n    'quantize',\n    'threshold',\n    'sequential',\n    'identity'\n]);\nconst CONTINUOUS_DOMAIN_INDEX = toSet(CONTINUOUS_DOMAIN_SCALES);\nexport const DISCRETE_DOMAIN_SCALES = ['ordinal', 'bin-ordinal', 'point', 'band'];\nconst DISCRETE_DOMAIN_INDEX = toSet(DISCRETE_DOMAIN_SCALES);\nexport const TIME_SCALE_TYPES = ['time', 'utc'];\nexport function hasDiscreteDomain(type) {\n    return type in DISCRETE_DOMAIN_INDEX;\n}\nexport function hasContinuousDomain(type) {\n    return type in CONTINUOUS_DOMAIN_INDEX;\n}\nexport function isContinuousToContinuous(type) {\n    return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\nexport function isContinuousToDiscrete(type) {\n    return type in CONTINUOUS_TO_DISCRETE_INDEX;\n}\nexport const defaultScaleConfig = {\n    pointPadding: 0.5,\n    barBandPaddingInner: 0.1,\n    rectBandPaddingInner: 0,\n    minBandSize: 2,\n    minFontSize: 8,\n    maxFontSize: 40,\n    minOpacity: 0.3,\n    maxOpacity: 0.8,\n    // FIXME: revise if these *can* become ratios of width/height step\n    minSize: 9,\n    minStrokeWidth: 1,\n    maxStrokeWidth: 4,\n    quantileCount: 4,\n    quantizeCount: 4\n};\nexport function isExtendedScheme(scheme) {\n    return !isString(scheme) && !!scheme['name'];\n}\nexport function isParameterDomain(domain) {\n    return domain === null || domain === void 0 ? void 0 : domain['param'];\n}\nexport function isDomainUnionWith(domain) {\n    return domain && domain['unionWith'];\n}\nexport function isFieldRange(range) {\n    return isObject(range) && 'field' in range;\n}\nconst SCALE_PROPERTY_INDEX = {\n    type: 1,\n    domain: 1,\n    domainMax: 1,\n    domainMin: 1,\n    domainMid: 1,\n    align: 1,\n    range: 1,\n    rangeMax: 1,\n    rangeMin: 1,\n    scheme: 1,\n    bins: 1,\n    // Other properties\n    reverse: 1,\n    round: 1,\n    // quantitative / time\n    clamp: 1,\n    nice: 1,\n    // quantitative\n    base: 1,\n    exponent: 1,\n    constant: 1,\n    interpolate: 1,\n    zero: 1,\n    // band/point\n    padding: 1,\n    paddingInner: 1,\n    paddingOuter: 1\n};\nexport const SCALE_PROPERTIES = keys(SCALE_PROPERTY_INDEX);\nconst { type, domain, range, rangeMax, rangeMin, scheme } = SCALE_PROPERTY_INDEX, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest(SCALE_PROPERTY_INDEX, [\"type\", \"domain\", \"range\", \"rangeMax\", \"rangeMin\", \"scheme\"]);\nexport const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);\nexport function scaleTypeSupportProperty(scaleType, propName) {\n    switch (propName) {\n        case 'type':\n        case 'domain':\n        case 'reverse':\n        case 'range':\n            return true;\n        case 'scheme':\n        case 'interpolate':\n            return !['point', 'band', 'identity'].includes(scaleType);\n        case 'bins':\n            return !['point', 'band', 'identity', 'ordinal'].includes(scaleType);\n        case 'round':\n            return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n        case 'padding':\n        case 'rangeMin':\n        case 'rangeMax':\n            return isContinuousToContinuous(scaleType) || ['point', 'band'].includes(scaleType);\n        case 'paddingOuter':\n        case 'align':\n            return ['point', 'band'].includes(scaleType);\n        case 'paddingInner':\n            return scaleType === 'band';\n        case 'domainMax':\n        case 'domainMid':\n        case 'domainMin':\n        case 'clamp':\n            return isContinuousToContinuous(scaleType);\n        case 'nice':\n            return isContinuousToContinuous(scaleType) || scaleType === 'quantize' || scaleType === 'threshold';\n        case 'exponent':\n            return scaleType === 'pow';\n        case 'base':\n            return scaleType === 'log';\n        case 'constant':\n            return scaleType === 'symlog';\n        case 'zero':\n            return (hasContinuousDomain(scaleType) &&\n                !contains([\n                    'log',\n                    'time',\n                    'utc',\n                    'threshold',\n                    'quantile' // quantile depends on distribution so zero does not matter\n                ], scaleType));\n    }\n}\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nexport function channelScalePropertyIncompatability(channel, propName) {\n    switch (propName) {\n        case 'interpolate':\n        case 'scheme':\n        case 'domainMid':\n            if (!isColorChannel(channel)) {\n                return log.message.cannotUseScalePropertyWithNonColor(channel);\n            }\n            return undefined;\n        case 'align':\n        case 'type':\n        case 'bins':\n        case 'domain':\n        case 'domainMax':\n        case 'domainMin':\n        case 'range':\n        case 'base':\n        case 'exponent':\n        case 'constant':\n        case 'nice':\n        case 'padding':\n        case 'paddingInner':\n        case 'paddingOuter':\n        case 'rangeMax':\n        case 'rangeMin':\n        case 'reverse':\n        case 'round':\n        case 'clamp':\n        case 'zero':\n            return undefined; // GOOD!\n    }\n}\nexport function scaleTypeSupportDataType(specifiedType, fieldDefType) {\n    if (contains([ORDINAL, NOMINAL], fieldDefType)) {\n        return specifiedType === undefined || hasDiscreteDomain(specifiedType);\n    }\n    else if (fieldDefType === TEMPORAL) {\n        return contains([ScaleType.TIME, ScaleType.UTC, undefined], specifiedType);\n    }\n    else if (fieldDefType === QUANTITATIVE) {\n        return contains([\n            ScaleType.LOG,\n            ScaleType.POW,\n            ScaleType.SQRT,\n            ScaleType.SYMLOG,\n            ScaleType.QUANTILE,\n            ScaleType.QUANTIZE,\n            ScaleType.THRESHOLD,\n            ScaleType.LINEAR,\n            undefined\n        ], specifiedType);\n    }\n    return true;\n}\nexport function channelSupportScaleType(channel, scaleType) {\n    if (!CHANNEL.isScaleChannel(channel)) {\n        return false;\n    }\n    switch (channel) {\n        case CHANNEL.X:\n        case CHANNEL.Y:\n        case CHANNEL.THETA:\n        case CHANNEL.RADIUS:\n            return isContinuousToContinuous(scaleType) || contains(['band', 'point'], scaleType);\n        case CHANNEL.SIZE: // TODO: size and opacity can support ordinal with more modification\n        case CHANNEL.STROKEWIDTH:\n        case CHANNEL.OPACITY:\n        case CHANNEL.FILLOPACITY:\n        case CHANNEL.STROKEOPACITY:\n        case CHANNEL.ANGLE:\n            // Although it generally doesn't make sense to use band with size and opacity,\n            // it can also work since we use band: 0.5 to get midpoint.\n            return (isContinuousToContinuous(scaleType) ||\n                isContinuousToDiscrete(scaleType) ||\n                contains(['band', 'point', 'ordinal'], scaleType));\n        case CHANNEL.COLOR:\n        case CHANNEL.FILL:\n        case CHANNEL.STROKE:\n            return scaleType !== 'band'; // band does not make sense with color\n        case CHANNEL.STROKEDASH:\n        case CHANNEL.SHAPE:\n            return scaleType === 'ordinal' || isContinuousToDiscrete(scaleType);\n    }\n}\n//# sourceMappingURL=scale.js.map"]},"metadata":{},"sourceType":"module"}