{"ast":null,"code":"import { getPolygonSignedArea } from '@math.gl/polygon';\nexport function classifyRings(geom) {\n  const len = geom.indices.length;\n  const type = 'Polygon';\n\n  if (len <= 1) {\n    return {\n      type,\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      indices: [geom.indices]\n    };\n  }\n\n  const areas = [];\n  const polygons = [];\n  let ringAreas = [];\n  let polygon = [];\n  let ccw;\n  let offset = 0;\n\n  for (let endIndex, i = 0, startIndex; i < len; i++) {\n    startIndex = geom.indices[i] - offset;\n    endIndex = geom.indices[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n      offset += endIndex - startIndex;\n      continue;\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n  return {\n    type,\n    areas,\n    indices: polygons,\n    data: geom.data\n  };\n}\nexport function project(data, x0, y0, size) {\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = (data[j] + x0) * 360 / size - 180;\n    const y2 = 180 - (data[j + 1] + y0) * 360 / size;\n    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n  }\n}\nexport function readFeature(tag, feature, pbf) {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();else if (tag === 2) readTag(pbf, feature);else if (tag === 3) feature.type = pbf.readVarint();else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\nexport function readTag(pbf, feature) {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n\n    const value = feature._values[pbf.readVarint()];\n\n    feature.properties[key] = value;\n  }\n}","map":{"version":3,"sources":["../../../src/helpers/binary-util-functions.ts"],"names":["len","geom","type","data","areas","getPolygonSignedArea","indices","polygons","ringAreas","polygon","offset","i","startIndex","endIndex","shape","area","before","after","ccw","j","jl","y2","Math","feature","tag","pbf","readTag","end","key","value"],"mappings":"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","sourcesContent":["import Protobuf from 'pbf';\nimport {getPolygonSignedArea} from '@math.gl/polygon';\nimport {FlatIndexedGeometry, FlatPolygon} from '@loaders.gl/schema';\nimport VectorTileFeature from '../lib/binary-vector-tile/vector-tile-feature';\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRings(geom: FlatIndexedGeometry): FlatPolygon {\n  const len = geom.indices.length;\n  const type = 'Polygon';\n\n  if (len <= 1) {\n    return {\n      type,\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      indices: [geom.indices]\n    };\n  }\n\n  const areas: any[] = [];\n  const polygons: any[] = [];\n  let ringAreas: number[] = [];\n  let polygon: number[] = [];\n  let ccw: boolean | undefined;\n  let offset = 0;\n\n  for (let endIndex: number, i = 0, startIndex: number; i < len; i++) {\n    startIndex = geom.indices[i] - offset;\n\n    endIndex = geom.indices[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      // This polygon has no area, so remove it from the shape\n      // Remove the section from the data array\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n\n      // Need to offset any remaining indices as we have\n      // modified the data buffer\n      offset += endIndex - startIndex;\n\n      // Do not add this index to the output and process next shape\n      continue; // eslint-disable-line no-continue\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n\n  return {type, areas, indices: polygons, data: geom.data};\n}\n\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function project(data: number[], x0: number, y0: number, size: number): void {\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = ((data[j] + x0) * 360) / size - 180;\n    const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n    data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n\n/**\n * All code below is unchanged from the original Mapbox implemenation\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag: number, feature?: VectorTileFeature, pbf?: Protobuf): void {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = pbf.readVarint();\n    else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n\n/**\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf: Protobuf, feature: VectorTileFeature): void {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}