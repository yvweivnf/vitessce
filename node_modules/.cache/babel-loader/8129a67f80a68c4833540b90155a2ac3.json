{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Texture2D, ProgramManager } from '@luma.gl/core';\nimport { AmbientLight } from './ambient-light';\nimport { DirectionalLight } from './directional-light';\nimport Effect from '../../lib/effect';\nimport { Matrix4, Vector3 } from 'math.gl';\nimport ShadowPass from '../../passes/shadow-pass';\nimport { default as shadow } from '../../shaderlib/shadow/shadow';\nvar DEFAULT_AMBIENT_LIGHT_PROPS = {\n  color: [255, 255, 255],\n  intensity: 1.0\n};\nvar DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{\n  color: [255, 255, 255],\n  intensity: 1.0,\n  direction: [-1, 3, -1]\n}, {\n  color: [255, 255, 255],\n  intensity: 0.9,\n  direction: [1, -8, -2.5]\n}];\nvar DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\n\nvar LightingEffect = /*#__PURE__*/function (_Effect) {\n  _inherits(LightingEffect, _Effect);\n\n  var _super = _createSuper(LightingEffect);\n\n  function LightingEffect(props) {\n    var _this;\n\n    _classCallCheck(this, LightingEffect);\n\n    _this = _super.call(this, props);\n    _this.ambientLight = null;\n    _this.directionalLights = [];\n    _this.pointLights = [];\n    _this.shadowColor = DEFAULT_SHADOW_COLOR;\n    _this.shadowPasses = [];\n    _this.shadowMaps = [];\n    _this.dummyShadowMap = null;\n    _this.shadow = false;\n    _this.programManager = null;\n\n    for (var key in props) {\n      var lightSource = props[key];\n\n      switch (lightSource.type) {\n        case 'ambient':\n          _this.ambientLight = lightSource;\n          break;\n\n        case 'directional':\n          _this.directionalLights.push(lightSource);\n\n          break;\n\n        case 'point':\n          _this.pointLights.push(lightSource);\n\n          break;\n\n        default:\n      }\n    }\n\n    _this._applyDefaultLights();\n\n    _this.shadow = _this.directionalLights.some(function (light) {\n      return light.shadow;\n    });\n    return _this;\n  }\n\n  _createClass(LightingEffect, [{\n    key: \"preRender\",\n    value: function preRender(gl, _ref) {\n      var layers = _ref.layers,\n          layerFilter = _ref.layerFilter,\n          viewports = _ref.viewports,\n          onViewportActive = _ref.onViewportActive,\n          views = _ref.views;\n      if (!this.shadow) return;\n      this.shadowMatrices = this._createLightMatrix();\n\n      if (this.shadowPasses.length === 0) {\n        this._createShadowPasses(gl);\n      }\n\n      if (!this.programManager) {\n        this.programManager = ProgramManager.getDefaultProgramManager(gl);\n\n        if (shadow) {\n          this.programManager.addDefaultModule(shadow);\n        }\n      }\n\n      if (!this.dummyShadowMap) {\n        this.dummyShadowMap = new Texture2D(gl, {\n          width: 1,\n          height: 1\n        });\n      }\n\n      for (var i = 0; i < this.shadowPasses.length; i++) {\n        var shadowPass = this.shadowPasses[i];\n        shadowPass.render({\n          layers: layers,\n          layerFilter: layerFilter,\n          viewports: viewports,\n          onViewportActive: onViewportActive,\n          views: views,\n          moduleParameters: {\n            shadowLightId: i,\n            dummyShadowMap: this.dummyShadowMap,\n            shadowMatrices: this.shadowMatrices\n          }\n        });\n      }\n    }\n  }, {\n    key: \"getModuleParameters\",\n    value: function getModuleParameters(layer) {\n      var parameters = this.shadow ? {\n        shadowMaps: this.shadowMaps,\n        dummyShadowMap: this.dummyShadowMap,\n        shadowColor: this.shadowColor,\n        shadowMatrices: this.shadowMatrices\n      } : {};\n      parameters.lightSources = {\n        ambientLight: this.ambientLight,\n        directionalLights: this.directionalLights.map(function (directionalLight) {\n          return directionalLight.getProjectedLight({\n            layer: layer\n          });\n        }),\n        pointLights: this.pointLights.map(function (pointLight) {\n          return pointLight.getProjectedLight({\n            layer: layer\n          });\n        })\n      };\n      return parameters;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var _iterator = _createForOfIteratorHelper(this.shadowPasses),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var shadowPass = _step.value;\n          shadowPass.delete();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.shadowPasses.length = 0;\n      this.shadowMaps.length = 0;\n\n      if (this.dummyShadowMap) {\n        this.dummyShadowMap.delete();\n        this.dummyShadowMap = null;\n      }\n\n      if (this.shadow && this.programManager) {\n        this.programManager.removeDefaultModule(shadow);\n        this.programManager = null;\n      }\n    }\n  }, {\n    key: \"_createLightMatrix\",\n    value: function _createLightMatrix() {\n      var lightMatrices = [];\n\n      var _iterator2 = _createForOfIteratorHelper(this.directionalLights),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var light = _step2.value;\n          var viewMatrix = new Matrix4().lookAt({\n            eye: new Vector3(light.direction).negate()\n          });\n          lightMatrices.push(viewMatrix);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return lightMatrices;\n    }\n  }, {\n    key: \"_createShadowPasses\",\n    value: function _createShadowPasses(gl) {\n      for (var i = 0; i < this.directionalLights.length; i++) {\n        var shadowPass = new ShadowPass(gl);\n        this.shadowPasses[i] = shadowPass;\n        this.shadowMaps[i] = shadowPass.shadowMap;\n      }\n    }\n  }, {\n    key: \"_applyDefaultLights\",\n    value: function _applyDefaultLights() {\n      var ambientLight = this.ambientLight,\n          pointLights = this.pointLights,\n          directionalLights = this.directionalLights;\n\n      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n        this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n        this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));\n      }\n    }\n  }]);\n\n  return LightingEffect;\n}(Effect);\n\nexport { LightingEffect as default };","map":{"version":3,"sources":["../../../../src/effects/lighting/lighting-effect.js"],"names":["default","DEFAULT_AMBIENT_LIGHT_PROPS","color","intensity","DEFAULT_DIRECTIONAL_LIGHT_PROPS","direction","DEFAULT_SHADOW_COLOR","constructor","lightSource","props","light","views","ProgramManager","width","height","i","shadowPass","layers","layerFilter","viewports","onViewportActive","moduleParameters","shadowLightId","dummyShadowMap","shadowMatrices","parameters","shadowMaps","shadowColor","ambientLight","directionalLights","directionalLight","layer","pointLights","pointLight","lightMatrices","viewMatrix","eye"],"mappings":"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","sourcesContent":["import {Texture2D, ProgramManager} from '@luma.gl/core';\nimport {AmbientLight} from './ambient-light';\nimport {DirectionalLight} from './directional-light';\nimport Effect from '../../lib/effect';\nimport {Matrix4, Vector3} from 'math.gl';\nimport ShadowPass from '../../passes/shadow-pass';\nimport {default as shadow} from '../../shaderlib/shadow/shadow';\n\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {color: [255, 255, 255], intensity: 1.0};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [\n  {\n    color: [255, 255, 255],\n    intensity: 1.0,\n    direction: [-1, 3, -1]\n  },\n  {\n    color: [255, 255, 255],\n    intensity: 0.9,\n    direction: [1, -8, -2.5]\n  }\n];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\n\n// Class to manage ambient, point and directional light sources in deck\nexport default class LightingEffect extends Effect {\n  constructor(props) {\n    super(props);\n    this.ambientLight = null;\n    this.directionalLights = [];\n    this.pointLights = [];\n\n    this.shadowColor = DEFAULT_SHADOW_COLOR;\n    this.shadowPasses = [];\n    this.shadowMaps = [];\n    this.dummyShadowMap = null;\n    this.shadow = false;\n    this.programManager = null;\n\n    for (const key in props) {\n      const lightSource = props[key];\n\n      switch (lightSource.type) {\n        case 'ambient':\n          this.ambientLight = lightSource;\n          break;\n\n        case 'directional':\n          this.directionalLights.push(lightSource);\n          break;\n\n        case 'point':\n          this.pointLights.push(lightSource);\n          break;\n        default:\n      }\n    }\n    this._applyDefaultLights();\n\n    this.shadow = this.directionalLights.some(light => light.shadow);\n  }\n\n  preRender(gl, {layers, layerFilter, viewports, onViewportActive, views}) {\n    if (!this.shadow) return;\n\n    // create light matrix every frame to make sure always updated from light source\n    this.shadowMatrices = this._createLightMatrix();\n\n    if (this.shadowPasses.length === 0) {\n      this._createShadowPasses(gl);\n    }\n    if (!this.programManager) {\n      // TODO - support multiple contexts\n      this.programManager = ProgramManager.getDefaultProgramManager(gl);\n      if (shadow) {\n        this.programManager.addDefaultModule(shadow);\n      }\n    }\n\n    if (!this.dummyShadowMap) {\n      this.dummyShadowMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        moduleParameters: {\n          shadowLightId: i,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowMatrices: this.shadowMatrices\n        }\n      });\n    }\n  }\n\n  getModuleParameters(layer) {\n    const parameters = this.shadow\n      ? {\n          shadowMaps: this.shadowMaps,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowColor: this.shadowColor,\n          shadowMatrices: this.shadowMatrices\n        }\n      : {};\n\n    // when not rendering to screen, turn off lighting by adding empty light source object\n    // lights shader module relies on the `lightSources` to turn on/off lighting\n    parameters.lightSources = {\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight =>\n        directionalLight.getProjectedLight({layer})\n      ),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({layer}))\n    };\n\n    return parameters;\n  }\n\n  cleanup() {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n    this.shadowPasses.length = 0;\n    this.shadowMaps.length = 0;\n\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.delete();\n      this.dummyShadowMap = null;\n    }\n\n    if (this.shadow && this.programManager) {\n      this.programManager.removeDefaultModule(shadow);\n      this.programManager = null;\n    }\n  }\n\n  _createLightMatrix() {\n    const lightMatrices = [];\n    for (const light of this.directionalLights) {\n      const viewMatrix = new Matrix4().lookAt({\n        eye: new Vector3(light.direction).negate()\n      });\n\n      lightMatrices.push(viewMatrix);\n    }\n    return lightMatrices;\n  }\n\n  _createShadowPasses(gl) {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new ShadowPass(gl);\n      this.shadowPasses[i] = shadowPass;\n      this.shadowMaps[i] = shadowPass.shadowMap;\n    }\n  }\n\n  _applyDefaultLights() {\n    const {ambientLight, pointLights, directionalLights} = this;\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]),\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1])\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}