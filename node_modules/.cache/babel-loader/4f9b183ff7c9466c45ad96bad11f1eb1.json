{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isArray, stringValue } from 'vega-util';\nimport { vgField } from '../channeldef';\nimport { isExprRef } from '../expr';\nimport { isText } from '../title';\nimport { deepEqual, getFirstDefined } from '../util';\nimport { isSignalRef } from '../vega.schema';\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function signalOrValueRefWithCondition(val) {\n  const condition = isArray(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);\n  return Object.assign(Object.assign({}, signalRefOrValue(val)), {\n    condition\n  });\n}\nexport function signalRefOrValue(value) {\n  if (isExprRef(value)) {\n    const {\n      expr\n    } = value,\n          rest = __rest(value, [\"expr\"]);\n\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n\n  return value;\n}\nexport function conditionalSignalRefOrValue(value) {\n  if (isExprRef(value)) {\n    const {\n      expr\n    } = value,\n          rest = __rest(value, [\"expr\"]);\n\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n\n  return value;\n}\nexport function signalOrValueRef(value) {\n  if (isExprRef(value)) {\n    const {\n      expr\n    } = value,\n          rest = __rest(value, [\"expr\"]);\n\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n\n  if (isSignalRef(value)) {\n    return value;\n  }\n\n  return value !== undefined ? {\n    value\n  } : undefined;\n}\nexport function exprFromValueOrSignalRef(ref) {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n\n  return stringValue(ref.value);\n}\nexport function signalOrStringValue(v) {\n  if (isSignalRef(v)) {\n    return v.signal;\n  }\n\n  return v == null ? null : stringValue(v);\n}\nexport function applyMarkConfig(e, model, propsList) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n\n    if (value !== undefined) {\n      e[property] = signalOrValueRef(value);\n    }\n  }\n\n  return e;\n}\nexport function getStyles(mark) {\n  var _a;\n\n  return [].concat(mark.type, (_a = mark.style) !== null && _a !== void 0 ? _a : []);\n}\nexport function getMarkPropOrConfig(channel, mark, config, opt = {}) {\n  const {\n    vgChannel,\n    ignoreVgConfig\n  } = opt;\n\n  if (vgChannel && mark[vgChannel] !== undefined) {\n    return mark[vgChannel];\n  } else if (mark[channel] !== undefined) {\n    return mark[channel];\n  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n    return undefined;\n  }\n\n  return getMarkConfig(channel, mark, config, opt);\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\n\nexport function getMarkConfig(channel, mark, config, {\n  vgChannel\n} = {}) {\n  return getFirstDefined( // style config has highest precedence\n  vgChannel ? getMarkStyleConfig(channel, mark, config.style) : undefined, getMarkStyleConfig(channel, mark, config.style), // then mark-specific config\n  vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel], // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n  // If there is vgChannel, skip vl channel.\n  // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n  vgChannel ? config.mark[vgChannel] : config.mark[channel] // Need to cast for the same reason as above\n  );\n}\nexport function getMarkStyleConfig(prop, mark, styleConfigIndex) {\n  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\nexport function getStyleConfig(p, styles, styleConfigIndex) {\n  styles = array(styles);\n  let value;\n\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n\n  return value;\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\n\nexport function sortParams(orderDef, fieldRefOption) {\n  return array(orderDef).reduce((s, orderChannelDef) => {\n    var _a;\n\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : 'ascending');\n    return s;\n  }, {\n    field: [],\n    order: []\n  });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n  const merged = [...f1];\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\nexport function mergeTitle(title1, title2) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\nexport function mergeTitleComponent(v1, v2) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (isText(v1Val) || isSignalRef(v1Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v1Val\n    };\n  } else if (isText(v2Val) || isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v2Val\n    };\n  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n\n\n  throw new Error('It should never reach here');\n}","map":{"version":3,"sources":["../../../src/compile/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isArray, stringValue } from 'vega-util';\nimport { vgField } from '../channeldef';\nimport { isExprRef } from '../expr';\nimport { isText } from '../title';\nimport { deepEqual, getFirstDefined } from '../util';\nimport { isSignalRef } from '../vega.schema';\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function signalOrValueRefWithCondition(val) {\n    const condition = isArray(val.condition)\n        ? val.condition.map(conditionalSignalRefOrValue)\n        : conditionalSignalRefOrValue(val.condition);\n    return Object.assign(Object.assign({}, signalRefOrValue(val)), { condition });\n}\nexport function signalRefOrValue(value) {\n    if (isExprRef(value)) {\n        const { expr } = value, rest = __rest(value, [\"expr\"]);\n        return Object.assign({ signal: expr }, rest);\n    }\n    return value;\n}\nexport function conditionalSignalRefOrValue(value) {\n    if (isExprRef(value)) {\n        const { expr } = value, rest = __rest(value, [\"expr\"]);\n        return Object.assign({ signal: expr }, rest);\n    }\n    return value;\n}\nexport function signalOrValueRef(value) {\n    if (isExprRef(value)) {\n        const { expr } = value, rest = __rest(value, [\"expr\"]);\n        return Object.assign({ signal: expr }, rest);\n    }\n    if (isSignalRef(value)) {\n        return value;\n    }\n    return value !== undefined ? { value } : undefined;\n}\nexport function exprFromValueOrSignalRef(ref) {\n    if (isSignalRef(ref)) {\n        return ref.signal;\n    }\n    return stringValue(ref.value);\n}\nexport function signalOrStringValue(v) {\n    if (isSignalRef(v)) {\n        return v.signal;\n    }\n    return v == null ? null : stringValue(v);\n}\nexport function applyMarkConfig(e, model, propsList) {\n    for (const property of propsList) {\n        const value = getMarkConfig(property, model.markDef, model.config);\n        if (value !== undefined) {\n            e[property] = signalOrValueRef(value);\n        }\n    }\n    return e;\n}\nexport function getStyles(mark) {\n    var _a;\n    return [].concat(mark.type, (_a = mark.style) !== null && _a !== void 0 ? _a : []);\n}\nexport function getMarkPropOrConfig(channel, mark, config, opt = {}) {\n    const { vgChannel, ignoreVgConfig } = opt;\n    if (vgChannel && mark[vgChannel] !== undefined) {\n        return mark[vgChannel];\n    }\n    else if (mark[channel] !== undefined) {\n        return mark[channel];\n    }\n    else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n        return undefined;\n    }\n    return getMarkConfig(channel, mark, config, opt);\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig(channel, mark, config, { vgChannel } = {}) {\n    return getFirstDefined(\n    // style config has highest precedence\n    vgChannel ? getMarkStyleConfig(channel, mark, config.style) : undefined, getMarkStyleConfig(channel, mark, config.style), \n    // then mark-specific config\n    vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel], // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n    // If there is vgChannel, skip vl channel.\n    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n    vgChannel ? config.mark[vgChannel] : config.mark[channel] // Need to cast for the same reason as above\n    );\n}\nexport function getMarkStyleConfig(prop, mark, styleConfigIndex) {\n    return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\nexport function getStyleConfig(p, styles, styleConfigIndex) {\n    styles = array(styles);\n    let value;\n    for (const style of styles) {\n        const styleConfig = styleConfigIndex[style];\n        if (styleConfig && styleConfig[p] !== undefined) {\n            value = styleConfig[p];\n        }\n    }\n    return value;\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef, fieldRefOption) {\n    return array(orderDef).reduce((s, orderChannelDef) => {\n        var _a;\n        s.field.push(vgField(orderChannelDef, fieldRefOption));\n        s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : 'ascending');\n        return s;\n    }, { field: [], order: [] });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n    const merged = [...f1];\n    f2.forEach(fdToMerge => {\n        for (const fieldDef1 of merged) {\n            // If already exists, no need to append to merged array\n            if (deepEqual(fieldDef1, fdToMerge)) {\n                return;\n            }\n        }\n        merged.push(fdToMerge);\n    });\n    return merged;\n}\nexport function mergeTitle(title1, title2) {\n    if (deepEqual(title1, title2) || !title2) {\n        // if titles are the same or title2 is falsy\n        return title1;\n    }\n    else if (!title1) {\n        // if title1 is falsy\n        return title2;\n    }\n    else {\n        return [...array(title1), ...array(title2)].join(', ');\n    }\n}\nexport function mergeTitleComponent(v1, v2) {\n    const v1Val = v1.value;\n    const v2Val = v2.value;\n    if (v1Val == null || v2Val === null) {\n        return {\n            explicit: v1.explicit,\n            value: null\n        };\n    }\n    else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n        return {\n            explicit: v1.explicit,\n            value: mergeTitle(v1Val, v2Val)\n        };\n    }\n    else if (isText(v1Val) || isSignalRef(v1Val)) {\n        return {\n            explicit: v1.explicit,\n            value: v1Val\n        };\n    }\n    else if (isText(v2Val) || isSignalRef(v2Val)) {\n        return {\n            explicit: v1.explicit,\n            value: v2Val\n        };\n    }\n    else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n        return {\n            explicit: v1.explicit,\n            value: mergeTitleFieldDefs(v1Val, v2Val)\n        };\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n    throw new Error('It should never reach here');\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}