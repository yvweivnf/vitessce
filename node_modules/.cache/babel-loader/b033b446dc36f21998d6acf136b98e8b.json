{"ast":null,"code":"import { array } from 'vega-util';\nimport * as log from '../log';\nimport { isLayerSpec, isUnitSpec } from '../spec';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseLayerAxes } from './axis/parse';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { parseLayerLayoutSize } from './layoutsize/parse';\nimport { assembleLegends } from './legend/assemble';\nimport { Model } from './model';\nimport { assembleLayerSelectionMarks } from './selection/assemble';\nimport { UnitModel } from './unit';\nexport class LayerModel extends Model {\n  constructor(spec, parent, parentGivenName, parentGivenSize, config) {\n    super(spec, 'layer', parent, parentGivenName, config, spec.resolve, spec.view);\n    const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n      width: spec.width\n    } : {}), spec.height ? {\n      height: spec.height\n    } : {});\n    this.children = spec.layer.map((layer, i) => {\n      if (isLayerSpec(layer)) {\n        return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n      } else if (isUnitSpec(layer)) {\n        return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n      }\n\n      throw new Error(log.message.invalidSpec(layer));\n    });\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  parseLayoutSize() {\n    parseLayerLayoutSize(this);\n  }\n\n  parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n\n    for (const child of this.children) {\n      child.parseSelections();\n\n      for (const key of keys(child.component.selection)) {\n        this.component.selection[key] = child.component.selection[key];\n      }\n    }\n  }\n\n  parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  parseAxesAndHeaders() {\n    parseLayerAxes(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  } // TODO: Support same named selections across children.\n\n\n  assembleSignals() {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleSignals());\n    }, assembleAxisSignals(this));\n  }\n\n  assembleLayoutSignals() {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, assembleLayoutSignals(this));\n  }\n\n  assembleSelectionData(data) {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  assembleGroupStyle() {\n    const uniqueStyles = new Set();\n\n    for (const child of this.children) {\n      for (const style of array(child.assembleGroupStyle())) {\n        uniqueStyles.add(style);\n      }\n    }\n\n    const styles = Array.from(uniqueStyles);\n    return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : undefined;\n  }\n\n  assembleTitle() {\n    let title = super.assembleTitle();\n\n    if (title) {\n      return title;\n    } // If title does not provide layer, look into children\n\n\n    for (const child of this.children) {\n      title = child.assembleTitle();\n\n      if (title) {\n        return title;\n      }\n    }\n\n    return undefined;\n  }\n\n  assembleLayout() {\n    return null;\n  }\n\n  assembleMarks() {\n    return assembleLayerSelectionMarks(this, this.children.flatMap(child => {\n      return child.assembleMarks();\n    }));\n  }\n\n  assembleLegends() {\n    return this.children.reduce((legends, child) => {\n      return legends.concat(child.assembleLegends());\n    }, assembleLegends(this));\n  }\n\n}","map":{"version":3,"sources":["../../../src/compile/layer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport * as log from '../log';\nimport { isLayerSpec, isUnitSpec } from '../spec';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseLayerAxes } from './axis/parse';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { parseLayerLayoutSize } from './layoutsize/parse';\nimport { assembleLegends } from './legend/assemble';\nimport { Model } from './model';\nimport { assembleLayerSelectionMarks } from './selection/assemble';\nimport { UnitModel } from './unit';\nexport class LayerModel extends Model {\n    constructor(spec, parent, parentGivenName, parentGivenSize, config) {\n        super(spec, 'layer', parent, parentGivenName, config, spec.resolve, spec.view);\n        const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), (spec.width ? { width: spec.width } : {})), (spec.height ? { height: spec.height } : {}));\n        this.children = spec.layer.map((layer, i) => {\n            if (isLayerSpec(layer)) {\n                return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n            }\n            else if (isUnitSpec(layer)) {\n                return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n            }\n            throw new Error(log.message.invalidSpec(layer));\n        });\n    }\n    parseData() {\n        this.component.data = parseData(this);\n        for (const child of this.children) {\n            child.parseData();\n        }\n    }\n    parseLayoutSize() {\n        parseLayerLayoutSize(this);\n    }\n    parseSelections() {\n        // Merge selections up the hierarchy so that they may be referenced\n        // across unit specs. Persist their definitions within each child\n        // to assemble signals which remain within output Vega unit groups.\n        this.component.selection = {};\n        for (const child of this.children) {\n            child.parseSelections();\n            for (const key of keys(child.component.selection)) {\n                this.component.selection[key] = child.component.selection[key];\n            }\n        }\n    }\n    parseMarkGroup() {\n        for (const child of this.children) {\n            child.parseMarkGroup();\n        }\n    }\n    parseAxesAndHeaders() {\n        parseLayerAxes(this);\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n    }\n    // TODO: Support same named selections across children.\n    assembleSignals() {\n        return this.children.reduce((signals, child) => {\n            return signals.concat(child.assembleSignals());\n        }, assembleAxisSignals(this));\n    }\n    assembleLayoutSignals() {\n        return this.children.reduce((signals, child) => {\n            return signals.concat(child.assembleLayoutSignals());\n        }, assembleLayoutSignals(this));\n    }\n    assembleSelectionData(data) {\n        return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n    }\n    assembleGroupStyle() {\n        const uniqueStyles = new Set();\n        for (const child of this.children) {\n            for (const style of array(child.assembleGroupStyle())) {\n                uniqueStyles.add(style);\n            }\n        }\n        const styles = Array.from(uniqueStyles);\n        return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : undefined;\n    }\n    assembleTitle() {\n        let title = super.assembleTitle();\n        if (title) {\n            return title;\n        }\n        // If title does not provide layer, look into children\n        for (const child of this.children) {\n            title = child.assembleTitle();\n            if (title) {\n                return title;\n            }\n        }\n        return undefined;\n    }\n    assembleLayout() {\n        return null;\n    }\n    assembleMarks() {\n        return assembleLayerSelectionMarks(this, this.children.flatMap(child => {\n            return child.assembleMarks();\n        }));\n    }\n    assembleLegends() {\n        return this.children.reduce((legends, child) => {\n            return legends.concat(child.assembleLegends());\n        }, assembleLegends(this));\n    }\n}\n//# sourceMappingURL=layer.js.map"]},"metadata":{},"sourceType":"module"}