{"ast":null,"code":"import BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc, wrapGetValueFunc } from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\n\nconst defaultGetCellSize = props => props.cellSize;\n\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {\n      oldProps,\n      props,\n      changeFlags\n    } = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n\n    this.setState({\n      aggregationDirty\n    });\n    return this.state;\n  }\n\n  setState(updateObject) {\n    this.state = { ...this.state,\n      ...updateObject\n    };\n  }\n\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: { ...this.state.dimensions,\n        [key]: { ...this.state.dimensions[key],\n          ...updateObject\n        }\n      }\n    });\n  }\n\n  normalizeResult() {\n    let result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (result.hexagons) {\n      return {\n        data: result.hexagons,\n        ...result\n      };\n    } else if (result.layerData) {\n      return {\n        data: result.layerData,\n        ...result\n      };\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {\n        value,\n        weight,\n        aggregation\n      } = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {\n            data: props.data\n          });\n        } else {\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {\n            data: props.data\n          });\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {\n          getValue\n        });\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n  }\n\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension() {\n    let dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    dimensions.forEach(dimension => {\n      const {\n        key\n      } = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters(_ref) {\n    let {\n      key,\n      accessor,\n      pickingInfo,\n      getBins,\n      getDomain,\n      getScaleFunc,\n      nullValue\n    } = _ref;\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {\n        updater: this.getDimensionSortedBins,\n        ...getBins\n      },\n      getDomain: {\n        updater: this.getDimensionValueDomain,\n        ...getDomain\n      },\n      getScaleFunc: {\n        updater: this.getDimensionScale,\n        ...getScaleFunc\n      },\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n      }\n\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    const updaters = [];\n\n    for (const key in this.dimensionUpdaters) {\n      const needUpdate = dimensionSteps.find(step => this.needUpdateDimensionStep(this.dimensionUpdaters[key][step], oldProps, props, changeFlags));\n\n      if (needUpdate) {\n        updaters.push(this.dimensionUpdaters[key][needUpdate].updater.bind(this, props, this.dimensionUpdaters[key]));\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {\n        accessor\n      } = this.dimensionUpdaters[key];\n      updateTriggers[accessor] = {};\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(_ref2 => {\n          let {\n            prop,\n            updateTrigger\n          } = _ref2;\n\n          if (updateTrigger) {\n            const fromProp = _updateTriggers[updateTrigger];\n\n            if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n              Object.assign(updateTriggers[accessor], fromProp);\n            } else if (fromProp !== undefined) {\n              updateTriggers[accessor][prop] = fromProp;\n            }\n          } else {\n            updateTriggers[accessor][prop] = props[prop];\n          }\n        });\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {\n      key\n    } = dimensionUpdater;\n    const {\n      getValue\n    } = this.state.dimensions[key];\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {\n      sortedBins\n    });\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {\n      getDomain,\n      key\n    } = dimensionUpdater;\n    const {\n      triggers: {\n        lowerPercentile,\n        upperPercentile,\n        scaleType\n      }\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n    this.setDimensionState(key, {\n      valueDomain\n    });\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {\n      key,\n      getScaleFunc,\n      getDomain\n    } = dimensionUpdater;\n    const {\n      domain,\n      range\n    } = getScaleFunc.triggers;\n    const {\n      scaleType\n    } = getDomain.triggers;\n    const {\n      onSet\n    } = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {\n      scaleFunc\n    });\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {\n        sortedBins,\n        scaleFunc\n      } = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        return nullValue;\n      }\n\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {\n        accessor\n      } = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo(_ref3) {\n    let {\n      info\n    } = _ref3;\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      const cell = this.state.layerData.data[info.index];\n      const binInfo = {};\n\n      for (const key in this.dimensionUpdaters) {\n        const {\n          pickingInfo\n        } = this.dimensionUpdaters[key];\n        const {\n          sortedBins\n        } = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n\n}","map":{"version":3,"sources":["../../../src/utils/cpu-aggregator.js"],"names":["dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","constructor","layerData","dimensions","opts","updateState","changeFlags","reprojectNeeded","aggregationDirty","dimensionChanges","f","setState","updateObject","setDimensionState","normalizeResult","result","data","getAggregatedData","aggregator","updateGetValueFuncs","getValue","getValueChanged","wrapGetValueFunc","getValueFunc","needsReProjectPoints","addDimension","_addDimension","dimension","sortedBins","scaleFunc","nop","getDimensionUpdaters","updater","attributeAccessor","needUpdateDimensionStep","dimensionStep","item","oldProps","getDimensionChanges","updaters","needUpdate","step","getUpdateTriggers","_updateTriggers","updateTriggers","Object","fromProp","Array","getSortedBins","getDimensionSortedBins","_filterData","getDimensionValueDomain","valueDomain","getDimensionScale","dimensionRange","dimensionDomain","getScaleFunction","getScaleFunctionByScaleType","getSubLayerDimensionAttribute","cell","bin","cv","isValueInDomain","getSubLayerAccessors","accessors","getPickingInfo","info","isPicked","object","binInfo","points","Boolean","getAccessor"],"mappings":"AAmBA,OAAA,SAAA,MAAA,cAAA;AACA,SAAA,2BAAA,QAAA,eAAA;AACA,SAAA,YAAA,EAAA,gBAAA,QAAA,+BAAA;;AAEA,SAAA,GAAA,GAAe,CAAE;;AAEjB,MAAMA,cAAc,GAAG,CAAA,SAAA,EAAA,WAAA,EAAvB,cAAuB,CAAvB;AACA,MAAMC,iBAAiB,GAAG,CACxB;AACEC,EAAAA,GAAG,EADL,WAAA;AAEEC,EAAAA,QAAQ,EAFV,cAAA;AAGEC,EAAAA,WAAW,EAHb,YAAA;AAIEC,EAAAA,OAAO,EAAE;AACPC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,KAAK,EAAE;AACLC,QAAAA,IAAI,EADC,eAAA;AAELC,QAAAA,aAAa,EAAE;AAFV,OADC;AAKRC,MAAAA,MAAM,EAAE;AACNF,QAAAA,IAAI,EADE,gBAAA;AAENC,QAAAA,aAAa,EAAE;AAFT,OALA;AASRE,MAAAA,WAAW,EAAE;AACXH,QAAAA,IAAI,EAAE;AADK,OATL;AAYRI,MAAAA,UAAU,EAAE;AACVJ,QAAAA,IAAI,EADM,aAAA;AAEVC,QAAAA,aAAa,EAAE;AAFL;AAZJ;AADH,GAJX;AAuBEI,EAAAA,SAAS,EAAE;AACTP,IAAAA,QAAQ,EAAE;AACRQ,MAAAA,eAAe,EAAE;AACfN,QAAAA,IAAI,EAAE;AADS,OADT;AAIRO,MAAAA,eAAe,EAAE;AACfP,QAAAA,IAAI,EAAE;AADS,OAJT;AAORQ,MAAAA,SAAS,EAAE;AACTR,QAAAA,IAAI,EAAE;AADG;AAPH;AADD,GAvBb;AAoCES,EAAAA,YAAY,EAAE;AACZX,IAAAA,QAAQ,EAAE;AACRY,MAAAA,MAAM,EAAE;AAACV,QAAAA,IAAI,EAAE;AAAP,OADA;AAERW,MAAAA,KAAK,EAAE;AAACX,QAAAA,IAAI,EAAE;AAAP;AAFC,KADE;AAKZY,IAAAA,KAAK,EAAE;AACLC,MAAAA,KAAK,EAAE;AADF;AALK,GApChB;AA6CEC,EAAAA,SAAS,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA;AA7Cb,CADwB,EAgDxB;AACEpB,EAAAA,GAAG,EADL,WAAA;AAEEC,EAAAA,QAAQ,EAFV,cAAA;AAGEC,EAAAA,WAAW,EAHb,gBAAA;AAIEC,EAAAA,OAAO,EAAE;AACPC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,KAAK,EAAE;AACLC,QAAAA,IAAI,EADC,mBAAA;AAELC,QAAAA,aAAa,EAAE;AAFV,OADC;AAKRC,MAAAA,MAAM,EAAE;AACNF,QAAAA,IAAI,EADE,oBAAA;AAENC,QAAAA,aAAa,EAAE;AAFT,OALA;AASRE,MAAAA,WAAW,EAAE;AACXH,QAAAA,IAAI,EAAE;AADK,OATL;AAYRI,MAAAA,UAAU,EAAE;AACVJ,QAAAA,IAAI,EADM,aAAA;AAEVC,QAAAA,aAAa,EAAE;AAFL;AAZJ;AADH,GAJX;AAuBEI,EAAAA,SAAS,EAAE;AACTP,IAAAA,QAAQ,EAAE;AACRQ,MAAAA,eAAe,EAAE;AACfN,QAAAA,IAAI,EAAE;AADS,OADT;AAIRO,MAAAA,eAAe,EAAE;AACfP,QAAAA,IAAI,EAAE;AADS,OAJT;AAORQ,MAAAA,SAAS,EAAE;AACTR,QAAAA,IAAI,EAAE;AADG;AAPH;AADD,GAvBb;AAoCES,EAAAA,YAAY,EAAE;AACZX,IAAAA,QAAQ,EAAE;AACRY,MAAAA,MAAM,EAAE;AAACV,QAAAA,IAAI,EAAE;AAAP,OADA;AAERW,MAAAA,KAAK,EAAE;AAACX,QAAAA,IAAI,EAAE;AAAP;AAFC,KADE;AAKZY,IAAAA,KAAK,EAAE;AACLC,MAAAA,KAAK,EAAE;AADF;AALK,GApChB;AA6CEC,EAAAA,SAAS,EAAE,CAAC;AA7Cd,CAhDwB,CAA1B;;AAgGA,MAAMC,kBAAkB,GAAGF,KAAK,IAAIA,KAAK,CAAzC,QAAA;;AACA,eAAe,MAAA,aAAA,CAAoB;AACjCG,EAAAA,WAAW,CAAA,IAAA,EAAO;AAChB,SAAA,KAAA,GAAa;AACXC,MAAAA,SAAS,EADE,EAAA;AAEXC,MAAAA,UAAU,EAAE;AAFD,KAAb;AAiBA,SAAA,WAAA,GAAA,EAAA;AACA,SAAA,iBAAA,GAAA,EAAA;AAEA,SAAA,YAAA,GAAoBC,IAAI,CAAJA,WAAAA,IAApB,kBAAA;AACA,SAAA,cAAA,GAAsBA,IAAI,CAA1B,aAAA;;AACA,SAAA,aAAA,CAAmBA,IAAI,CAAJA,UAAAA,IAAnB,iBAAA;AACD;;AAEuB,SAAjB1B,iBAAiB,GAAG;AACzB,WAAA,iBAAA;AACD;;AAED2B,EAAAA,WAAW,CAAA,IAAA,EAAA,iBAAA,EAA0B;AACnC,UAAM;AAAA,MAAA,QAAA;AAAA,MAAA,KAAA;AAAkBC,MAAAA;AAAlB,QAAN,IAAA;AACA,SAAA,mBAAA,CAAA,QAAA,EAAA,KAAA,EAAA,WAAA;AACA,UAAMC,eAAe,GAAG,KAAA,oBAAA,CAAA,QAAA,EAAA,KAAA,EAAxB,WAAwB,CAAxB;AACA,QAAIC,gBAAgB,GAApB,KAAA;;AACA,QAAIF,WAAW,CAAXA,WAAAA,IAAJ,eAAA,EAAgD;AAE9C,WAAA,iBAAA,CAAA,KAAA,EAAA,iBAAA;AACAE,MAAAA,gBAAgB,GAAhBA,IAAAA;AAHF,KAAA,MAIO;AACL,YAAMC,gBAAgB,GAAG,KAAA,mBAAA,CAAA,QAAA,EAAA,KAAA,EAAA,WAAA,KAAzB,EAAA;AAEAA,MAAAA,gBAAgB,CAAhBA,OAAAA,CAAyBC,CAAC,IAAI,OAAA,CAAA,KAAA,UAAA,IAA2BA,CAAzDD,EAAAA;AACAD,MAAAA,gBAAgB,GAAhBA,IAAAA;AACD;;AACD,SAAA,QAAA,CAAc;AAACA,MAAAA;AAAD,KAAd;AAEA,WAAO,KAAP,KAAA;AACD;;AAGDG,EAAAA,QAAQ,CAAA,YAAA,EAAe;AACrB,SAAA,KAAA,GAAa,EAAC,GAAG,KAAJ,KAAA;AAAgB,SAAGC;AAAnB,KAAb;AACD;;AAGDC,EAAAA,iBAAiB,CAAA,GAAA,EAAA,YAAA,EAAoB;AACnC,SAAA,QAAA,CAAc;AACZV,MAAAA,UAAU,EAAE,EACV,GAAG,KAAA,KAAA,CADO,UAAA;AAEV,SAAA,GAAA,GAAO,EAAC,GAAG,KAAA,KAAA,CAAA,UAAA,CAAJ,GAAI,CAAJ;AAAgC,aAAGS;AAAnC;AAFG;AADA,KAAd;AAMD;;AAEDE,EAAAA,eAAe,GAAc;AAAA,QAAbC,MAAa,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;;AAE3B,QAAIA,MAAM,CAAV,QAAA,EAAqB;AACnB,aAAO;AAACC,QAAAA,IAAI,EAAED,MAAM,CAAb,QAAA;AAAwB,WAAGA;AAA3B,OAAP;AADF,KAAA,MAEO,IAAIA,MAAM,CAAV,SAAA,EAAsB;AAC3B,aAAO;AAACC,QAAAA,IAAI,EAAED,MAAM,CAAb,SAAA;AAAyB,WAAGA;AAA5B,OAAP;AACD;;AAED,WAAA,MAAA;AACD;;AAEDE,EAAAA,iBAAiB,CAAA,KAAA,EAAA,iBAAA,EAA2B;AAC1C,UAAMC,UAAU,GAAG,KAAA,cAAA,CAAnB,KAAmB,CAAnB;;AAEA,UAAMH,MAAM,GAAGG,UAAU,CAAA,KAAA,EAAzB,iBAAyB,CAAzB;AACA,SAAA,QAAA,CAAc;AACZhB,MAAAA,SAAS,EAAE,KAAA,eAAA,CAAA,MAAA;AADC,KAAd;AAGA,SAAA,WAAA,GAAmB;AACjBA,MAAAA,SAAS,EAAE;AADM,KAAnB;AAGA,SAAA,aAAA,CAAA,KAAA;AACD;;AAEDiB,EAAAA,mBAAmB,CAAA,QAAA,EAAA,KAAA,EAAA,WAAA,EAA+B;AAChD,SAAK,MAAL,GAAA,IAAkB,KAAlB,iBAAA,EAA0C;AACxC,YAAM;AAAA,QAAA,KAAA;AAAA,QAAA,MAAA;AAAgB/B,QAAAA;AAAhB,UAA+B,KAAA,iBAAA,CAAA,GAAA,EAAA,OAAA,CAArC,QAAA;AACA,UAAIgC,QAAQ,GAAGtB,KAAK,CAACd,KAAK,CAA1B,IAAoB,CAApB;AACA,YAAMqC,eAAe,GAAG,KAAA,uBAAA,CACtB,KAAA,iBAAA,CAAA,GAAA,EADsB,OAAA,EAAA,QAAA,EAAA,KAAA,EAAxB,WAAwB,CAAxB;;AAOA,UAAA,eAAA,EAAqB;AACnB,YAAA,QAAA,EAAc;AACZD,UAAAA,QAAQ,GAAGE,gBAAgB,CAAA,QAAA,EAAW;AAACN,YAAAA,IAAI,EAAElB,KAAK,CAACkB;AAAb,WAAX,CAA3BI;AADF,SAAA,MAEO;AAELA,UAAAA,QAAQ,GAAGG,YAAY,CAACzB,KAAK,CAACV,WAAW,CAAlB,IAAM,CAAN,EAA0BU,KAAK,CAACX,MAAM,CAAtC,IAA+B,CAA/B,EAA8C;AAAC6B,YAAAA,IAAI,EAAElB,KAAK,CAACkB;AAAb,WAA9C,CAAvBI;AACD;AACF;;AAED,UAAA,QAAA,EAAc;AACZ,aAAA,iBAAA,CAAA,GAAA,EAA4B;AAACA,UAAAA;AAAD,SAA5B;AACD;AACF;AACF;;AAEDI,EAAAA,oBAAoB,CAAA,QAAA,EAAA,KAAA,EAAA,WAAA,EAA+B;AACjD,WACE,KAAA,YAAA,CAAA,QAAA,MAAgC,KAAA,YAAA,CAAhC,KAAgC,CAAhC,IACA,KAAA,cAAA,CAAA,QAAA,MAAkC,KAAA,cAAA,CADlC,KACkC,CADlC,IAEClB,WAAW,CAAXA,qBAAAA,KACEA,WAAW,CAAXA,qBAAAA,CAAAA,GAAAA,IAAyCA,WAAW,CAAXA,qBAAAA,CAJ9C,WAGGA,CAHH;AAMD;;AAGDmB,EAAAA,YAAY,CAAA,UAAA,EAAa;AACvB,SAAA,aAAA,CAAA,UAAA;AACD;;AAEDC,EAAAA,aAAa,GAAkB;AAAA,QAAjBvB,UAAiB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAC7BA,IAAAA,UAAU,CAAVA,OAAAA,CAAmBwB,SAAS,IAAI;AAC9B,YAAM;AAAChD,QAAAA;AAAD,UAAN,SAAA;AACA,WAAA,iBAAA,CAAA,GAAA,IAA8B,KAAA,oBAAA,CAA9B,SAA8B,CAA9B;AACA,WAAA,KAAA,CAAA,UAAA,CAAA,GAAA,IAA6B;AAC3ByC,QAAAA,QAAQ,EADmB,IAAA;AAE3BzB,QAAAA,MAAM,EAFqB,IAAA;AAG3BiC,QAAAA,UAAU,EAHiB,IAAA;AAI3BC,QAAAA,SAAS,EAAEC;AAJgB,OAA7B;AAHF3B,KAAAA;AAUD;;AAED4B,EAAAA,oBAAoB,CAAA,IAAA,EAA4E;AAAA,QAA3E;AAAA,MAAA,GAAA;AAAA,MAAA,QAAA;AAAA,MAAA,WAAA;AAAA,MAAA,OAAA;AAAA,MAAA,SAAA;AAAA,MAAA,YAAA;AAA+DhC,MAAAA;AAA/D,QAA2E,IAAA;AAC9F,WAAO;AAAA,MAAA,GAAA;AAAA,MAAA,QAAA;AAAA,MAAA,WAAA;AAILjB,MAAAA,OAAO,EAAE;AAACkD,QAAAA,OAAO,EAAE,KAAV,sBAAA;AAAuC,WAAGlD;AAA1C,OAJJ;AAKLQ,MAAAA,SAAS,EAAE;AAAC0C,QAAAA,OAAO,EAAE,KAAV,uBAAA;AAAwC,WAAG1C;AAA3C,OALN;AAMLI,MAAAA,YAAY,EAAE;AAACsC,QAAAA,OAAO,EAAE,KAAV,iBAAA;AAAkC,WAAGtC;AAArC,OANT;AAOLuC,MAAAA,iBAAiB,EAAE,KAAA,6BAAA,CAAA,GAAA,EAAA,SAAA;AAPd,KAAP;AASD;;AAEDC,EAAAA,uBAAuB,CAAA,aAAA,EAAA,QAAA,EAAA,KAAA,EAAA,WAAA,EAA8C;AAkBnE,WAAO,MAAM,CAAN,MAAA,CAAcC,aAAa,CAA3B,QAAA,EAAA,IAAA,CAA2CC,IAAI,IAAI;AACxD,UAAIA,IAAI,CAAR,aAAA,EAAwB;AAGtB,eACE9B,WAAW,CAAXA,WAAAA,IACCA,WAAW,CAAXA,qBAAAA,KACEA,WAAW,CAAXA,qBAAAA,CAAAA,GAAAA,IACCA,WAAW,CAAXA,qBAAAA,CAAkC8B,IAAI,CAJ5C,aAIM9B,CAFHA,CAFH;AAMD;;AAED,aAAO+B,QAAQ,CAACD,IAAI,CAAbC,IAAQ,CAARA,KAAwBvC,KAAK,CAACsC,IAAI,CAAzC,IAAoC,CAApC;AAZF,KAAO,CAAP;AAcD;;AAEDE,EAAAA,mBAAmB,CAAA,QAAA,EAAA,KAAA,EAAA,WAAA,EAA+B;AAEhD,UAAMC,QAAQ,GAAd,EAAA;;AAGA,SAAK,MAAL,GAAA,IAAkB,KAAlB,iBAAA,EAA0C;AAExC,YAAMC,UAAU,GAAG/D,cAAc,CAAdA,IAAAA,CAAoBgE,IAAI,IACzC,KAAA,uBAAA,CACE,KAAA,iBAAA,CAAA,GAAA,EADF,IACE,CADF,EAAA,QAAA,EAAA,KAAA,EADF,WACE,CADiBhE,CAAnB;;AASA,UAAA,UAAA,EAAgB;AACd8D,QAAAA,QAAQ,CAARA,IAAAA,CACE,KAAA,iBAAA,CAAA,GAAA,EAAA,UAAA,EAAA,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,KAAA,EAGE,KAAA,iBAAA,CAJJA,GAII,CAHF,CADFA;AAOD;AACF;;AAED,WAAOA,QAAQ,CAARA,MAAAA,GAAAA,QAAAA,GAAP,IAAA;AACD;;AAEDG,EAAAA,iBAAiB,CAAA,KAAA,EAAQ;AACvB,UAAMC,eAAe,GAAG7C,KAAK,CAALA,cAAAA,IAAxB,EAAA;;AACA,UAAM8C,cAAc,GAApB,EAAA;;AAEA,SAAK,MAAL,GAAA,IAAkB,KAAlB,iBAAA,EAA0C;AACxC,YAAM;AAAChE,QAAAA;AAAD,UAAa,KAAA,iBAAA,CAAnB,GAAmB,CAAnB;AAEAgE,MAAAA,cAAc,CAAdA,QAAc,CAAdA,GAAAA,EAAAA;AAEAnE,MAAAA,cAAc,CAAdA,OAAAA,CAAuBgE,IAAI,IAAI;AAC7BI,QAAAA,MAAM,CAANA,MAAAA,CAAc,KAAA,iBAAA,CAAA,GAAA,EAAA,IAAA,EAAdA,QAAAA,EAAAA,OAAAA,CACE,KAAA,IAA2B;AAAA,cAA1B;AAAA,YAAA,IAAA;AAAO3D,YAAAA;AAAP,cAA0B,KAAA;;AACzB,cAAA,aAAA,EAAmB;AAIjB,kBAAM4D,QAAQ,GAAGH,eAAe,CAAhC,aAAgC,CAAhC;;AACA,gBAAI,OAAA,QAAA,KAAA,QAAA,IAAgC,CAACI,KAAK,CAALA,OAAAA,CAArC,QAAqCA,CAArC,EAA8D;AAE5DF,cAAAA,MAAM,CAANA,MAAAA,CAAcD,cAAc,CAA5BC,QAA4B,CAA5BA,EAAAA,QAAAA;AAFF,aAAA,MAGO,IAAIC,QAAQ,KAAZ,SAAA,EAA4B;AACjCF,cAAAA,cAAc,CAAdA,QAAc,CAAdA,CAAAA,IAAAA,IAAAA,QAAAA;AACD;AAVH,WAAA,MAWO;AAELA,YAAAA,cAAc,CAAdA,QAAc,CAAdA,CAAAA,IAAAA,IAAiC9C,KAAK,CAAtC8C,IAAsC,CAAtCA;AACD;AAhBLC,SAAAA;AADFpE,OAAAA;AAqBD;;AAED,WAAA,cAAA;AACD;;AAEDuE,EAAAA,aAAa,CAAA,KAAA,EAAQ;AACnB,SAAK,MAAL,GAAA,IAAkB,KAAlB,iBAAA,EAA0C;AACxC,WAAA,sBAAA,CAAA,KAAA,EAAmC,KAAA,iBAAA,CAAnC,GAAmC,CAAnC;AACD;AACF;;AAEDC,EAAAA,sBAAsB,CAAA,KAAA,EAAA,gBAAA,EAA0B;AAC9C,UAAM;AAACtE,MAAAA;AAAD,QAAN,gBAAA;AACA,UAAM;AAACyC,MAAAA;AAAD,QAAa,KAAA,KAAA,CAAA,UAAA,CAAnB,GAAmB,CAAnB;AAEA,UAAMQ,UAAU,GAAG,IAAA,SAAA,CAAc,KAAA,KAAA,CAAA,SAAA,CAAA,IAAA,IAAd,EAAA,EAA+C;AAAA,MAAA,QAAA;AAEhEvC,MAAAA,UAAU,EAAES,KAAK,CAACoD;AAF8C,KAA/C,CAAnB;AAIA,SAAA,iBAAA,CAAA,GAAA,EAA4B;AAACtB,MAAAA;AAAD,KAA5B;AACA,SAAA,uBAAA,CAAA,KAAA,EAAA,gBAAA;AACD;;AAEDuB,EAAAA,uBAAuB,CAAA,KAAA,EAAA,gBAAA,EAA0B;AAC/C,UAAM;AAAA,MAAA,SAAA;AAAYxE,MAAAA;AAAZ,QAAN,gBAAA;AACA,UAAM;AACJI,MAAAA,QAAQ,EAAE;AAAA,QAAA,eAAA;AAAA,QAAA,eAAA;AAAmCU,QAAAA;AAAnC;AADN,QAAN,SAAA;AAGA,UAAM2D,WAAW,GAAG,KAAA,KAAA,CAAA,UAAA,CAAA,GAAA,EAAA,UAAA,CAAA,qBAAA,CAClBtD,KAAK,CAACL,SAAS,CADG,IACb,CADa,EAElB,CAACK,KAAK,CAACP,eAAe,CAAtB,IAAM,CAAN,EAA8BO,KAAK,CAACN,eAAe,CAFrD,IAEqC,CAAnC,CAFkB,CAApB;AAKA,SAAA,iBAAA,CAAA,GAAA,EAA4B;AAAC4D,MAAAA;AAAD,KAA5B;AACA,SAAA,iBAAA,CAAA,KAAA,EAAA,gBAAA;AACD;;AAEDC,EAAAA,iBAAiB,CAAA,KAAA,EAAA,gBAAA,EAA0B;AACzC,UAAM;AAAA,MAAA,GAAA;AAAA,MAAA,YAAA;AAAoB/D,MAAAA;AAApB,QAAN,gBAAA;AACA,UAAM;AAAA,MAAA,MAAA;AAASM,MAAAA;AAAT,QAAkBF,YAAY,CAApC,QAAA;AACA,UAAM;AAACD,MAAAA;AAAD,QAAcH,SAAS,CAA7B,QAAA;AACA,UAAM;AAACO,MAAAA;AAAD,QAAN,YAAA;AACA,UAAMyD,cAAc,GAAGxD,KAAK,CAACF,KAAK,CAAlC,IAA4B,CAA5B;AACA,UAAM2D,eAAe,GAAGzD,KAAK,CAACH,MAAM,CAAZG,IAAK,CAALA,IAAsB,KAAA,KAAA,CAAA,UAAA,CAAA,GAAA,EAA9C,WAAA;AACA,UAAM0D,gBAAgB,GAAGC,2BAA2B,CAAChE,SAAS,IAAIK,KAAK,CAACL,SAAS,CAAjF,IAAuE,CAAnB,CAApD;AACA,UAAMoC,SAAS,GAAG2B,gBAAgB,CAAA,eAAA,EAAlC,cAAkC,CAAlC;;AAEA,QAAI,OAAA,KAAA,KAAA,QAAA,IAA6B,OAAO1D,KAAK,CAACD,KAAK,CAAlB,KAAY,CAAZ,KAAjC,UAAA,EAA2E;AACzEC,MAAAA,KAAK,CAACD,KAAK,CAAXC,KAAK,CAALA,CAAmB+B,SAAS,CAA5B/B,MAAmB+B,EAAnB/B;AACD;;AAED,SAAA,iBAAA,CAAA,GAAA,EAA4B;AAAC+B,MAAAA;AAAD,KAA5B;AACD;;AAED6B,EAAAA,6BAA6B,CAAA,GAAA,EAAA,SAAA,EAAiB;AAC5C,WAAOC,IAAI,IAAI;AACb,YAAM;AAAA,QAAA,UAAA;AAAa9B,QAAAA;AAAb,UAA0B,KAAA,KAAA,CAAA,UAAA,CAAhC,GAAgC,CAAhC;AACA,YAAM+B,GAAG,GAAGhC,UAAU,CAAVA,MAAAA,CAAkB+B,IAAI,CAAlC,KAAY/B,CAAZ;;AAEA,UAAIgC,GAAG,IAAIA,GAAG,CAAHA,MAAAA,KAAX,CAAA,EAA6B;AAE3B,eAAA,SAAA;AACD;;AACD,YAAMC,EAAE,GAAGD,GAAG,IAAIA,GAAG,CAArB,KAAA;AACA,YAAMjE,MAAM,GAAGkC,SAAS,CAAxB,MAAeA,EAAf;AAEA,YAAMiC,eAAe,GAAGD,EAAE,IAAIlE,MAAM,CAAZkE,CAAY,CAAZA,IAAmBA,EAAE,IAAIlE,MAAM,CAACA,MAAM,CAANA,MAAAA,GAAxD,CAAuD,CAAvD;AAGA,aAAOmE,eAAe,GAAGjC,SAAS,CAAZ,EAAY,CAAZ,GAAtB,SAAA;AAdF,KAAA;AAgBD;;AAEDkC,EAAAA,oBAAoB,CAAA,KAAA,EAAQ;AAC1B,UAAMC,SAAS,GAAf,EAAA;;AACA,SAAK,MAAL,GAAA,IAAkB,KAAlB,iBAAA,EAA0C;AACxC,YAAM;AAACpF,QAAAA;AAAD,UAAa,KAAA,iBAAA,CAAnB,GAAmB,CAAnB;AACAoF,MAAAA,SAAS,CAATA,QAAS,CAATA,GAAsB,KAAA,6BAAA,CAAA,KAAA,EAAtBA,GAAsB,CAAtBA;AACD;;AAED,WAAA,SAAA;AACD;;AAEDC,EAAAA,cAAc,CAAA,KAAA,EAAS;AAAA,QAAR;AAACC,MAAAA;AAAD,QAAQ,KAAA;AACrB,UAAMC,QAAQ,GAAGD,IAAI,CAAJA,MAAAA,IAAeA,IAAI,CAAJA,KAAAA,GAAa,CAA7C,CAAA;AACA,QAAIE,MAAM,GAAV,IAAA;;AAEA,QAAA,QAAA,EAAc;AAGZ,YAAMT,IAAI,GAAG,KAAA,KAAA,CAAA,SAAA,CAAA,IAAA,CAA0BO,IAAI,CAA3C,KAAa,CAAb;AAEA,YAAMG,OAAO,GAAb,EAAA;;AACA,WAAK,MAAL,GAAA,IAAkB,KAAlB,iBAAA,EAA0C;AACxC,cAAM;AAACxF,UAAAA;AAAD,YAAgB,KAAA,iBAAA,CAAtB,GAAsB,CAAtB;AACA,cAAM;AAAC+C,UAAAA;AAAD,YAAe,KAAA,KAAA,CAAA,UAAA,CAArB,GAAqB,CAArB;AACA,cAAM5C,KAAK,GAAG4C,UAAU,CAAVA,MAAAA,CAAkB+B,IAAI,CAAtB/B,KAAAA,KAAiCA,UAAU,CAAVA,MAAAA,CAAkB+B,IAAI,CAAtB/B,KAAAA,EAA/C,KAAA;AACAyC,QAAAA,OAAO,CAAPA,WAAO,CAAPA,GAAAA,KAAAA;AACD;;AAEDD,MAAAA,MAAM,GAAG,MAAM,CAAN,MAAA,CAAA,OAAA,EAAA,IAAA,EAA6B;AACpCE,QAAAA,MAAM,EAAEX,IAAI,CAAJA,cAAAA,IAAuBA,IAAI,CAACW;AADA,OAA7B,CAATF;AAGD;;AAGDF,IAAAA,IAAI,CAAJA,MAAAA,GAAcK,OAAO,CAArBL,MAAqB,CAArBA;AACAA,IAAAA,IAAI,CAAJA,MAAAA,GAAAA,MAAAA;AAEA,WAAA,IAAA;AACD;;AAEDM,EAAAA,WAAW,CAAA,YAAA,EAAe;AACxB,QAAI,CAAC,KAAA,iBAAA,CAAA,cAAA,CAAL,YAAK,CAAL,EAA0D;AACxD,aAAA,GAAA;AACD;;AACD,WAAO,KAAA,iBAAA,CAAA,YAAA,EAAP,iBAAA;AACD;;AA9WgC","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}