{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { AXIS_PARTS, isAxisProperty, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getFirstDefined, isEmpty, keys, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, mergeValuesWithExplicit } from '../split';\nimport { AxisComponent, AXIS_COMPONENT_PROPERTIES } from './component';\nimport { getAxisConfig, getAxisConfigs } from './config';\nimport * as encode from './encode';\nimport { axisRules, defaultOrient, getFieldDefTitle, getLabelAngle } from './properties';\nexport function parseUnitAxes(model) {\n  return POSITION_SCALE_CHANNELS.reduce(function (axis, channel) {\n    if (model.component.scales[channel]) {\n      axis[channel] = [parseAxis(channel, model)];\n    }\n\n    return axis;\n  }, {});\n}\nvar OPPOSITE_ORIENT = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'right',\n  right: 'left'\n};\nexport function parseLayerAxes(model) {\n  var _a;\n\n  var _model$component = model.component,\n      axes = _model$component.axes,\n      resolve = _model$component.resolve;\n  var axisCount = {\n    top: 0,\n    bottom: 0,\n    right: 0,\n    left: 0\n  };\n\n  var _iterator = _createForOfIteratorHelper(model.children),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      child.parseAxesAndHeaders();\n\n      var _iterator3 = _createForOfIteratorHelper(keys(child.component.axes)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var channel = _step3.value;\n          resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n\n          if (resolve.axis[channel] === 'shared') {\n            // If the resolve says shared (and has not been overridden)\n            // We will try to merge and see if there is a conflict\n            axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n\n            if (!axes[channel]) {\n              // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n              // Thus, mark axis as independent and remove the axis component.\n              resolve.axis[channel] = 'independent';\n              delete axes[channel];\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    } // Move axes to layer's axis component and merge shared axes\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _channel = _step2.value;\n\n      var _iterator4 = _createForOfIteratorHelper(model.children),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _child = _step4.value;\n\n          if (!_child.component.axes[_channel]) {\n            // skip if the child does not have a particular axis\n            continue;\n          }\n\n          if (resolve.axis[_channel] === 'independent') {\n            // If axes are independent, concat the axisComponent array.\n            axes[_channel] = ((_a = axes[_channel]) !== null && _a !== void 0 ? _a : []).concat(_child.component.axes[_channel]); // Automatically adjust orient\n\n            var _iterator6 = _createForOfIteratorHelper(_child.component.axes[_channel]),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var axisComponent = _step6.value;\n\n                var _axisComponent$getWit = axisComponent.getWithExplicit('orient'),\n                    orient = _axisComponent$getWit.value,\n                    explicit = _axisComponent$getWit.explicit;\n\n                if (isSignalRef(orient)) {\n                  continue;\n                }\n\n                if (axisCount[orient] > 0 && !explicit) {\n                  // Change axis orient if the number do not match\n                  var oppositeOrient = OPPOSITE_ORIENT[orient];\n\n                  if (axisCount[orient] > axisCount[oppositeOrient]) {\n                    axisComponent.set('orient', oppositeOrient, false);\n                  }\n                }\n\n                axisCount[orient]++; // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          } // After merging, make sure to remove axes from child\n\n\n          delete _child.component.axes[_channel];\n        } // Suppress grid lines for dual axis charts (https://github.com/vega/vega-lite/issues/4676)\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (resolve.axis[_channel] === 'independent' && axes[_channel] && axes[_channel].length > 1) {\n        var _iterator5 = _createForOfIteratorHelper(axes[_channel]),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var axisCmpt = _step5.value;\n\n            if (!!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n              axisCmpt.implicit.grid = false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nfunction mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {\n  if (mergedAxisCmpts) {\n    // FIXME: this is a bit wrong once we support multiple axes\n    if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n      return undefined; // Cannot merge axis component with different number of axes.\n    }\n\n    var length = mergedAxisCmpts.length;\n\n    for (var i = 0; i < length; i++) {\n      var merged = mergedAxisCmpts[i];\n      var child = childAxisCmpts[i];\n\n      if (!!merged !== !!child) {\n        return undefined;\n      } else if (merged && child) {\n        var mergedOrient = merged.getWithExplicit('orient');\n        var childOrient = child.getWithExplicit('orient');\n\n        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n          // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n          // Cannot merge due to inconsistent orient\n          return undefined;\n        } else {\n          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n        }\n      }\n    }\n  } else {\n    // For first one, return a copy of the child\n    return childAxisCmpts.map(function (axisComponent) {\n      return axisComponent.clone();\n    });\n  }\n\n  return mergedAxisCmpts;\n}\n\nfunction mergeAxisComponent(merged, child) {\n  var _iterator7 = _createForOfIteratorHelper(AXIS_COMPONENT_PROPERTIES),\n      _step7;\n\n  try {\n    var _loop = function _loop() {\n      var prop = _step7.value;\n      var mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, 'axis', // Tie breaker function\n      function (v1, v2) {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n\n          case 'gridScale':\n            return {\n              explicit: v1.explicit,\n              value: getFirstDefined(v1.value, v2.value)\n            };\n        }\n\n        return defaultTieBreaker(v1, v2, prop, 'axis');\n      });\n      merged.setWithExplicit(prop, mergedValueWithExplicit);\n    };\n\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return merged;\n}\n\nfunction isExplicit(value, property, axis, model, channel) {\n  if (property === 'disable') {\n    return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n  }\n\n  axis = axis || {};\n\n  switch (property) {\n    case 'titleAngle':\n    case 'labelAngle':\n      return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n\n    case 'values':\n      return !!axis.values;\n    // specified axis.values is already respected, but may get transformed.\n\n    case 'encode':\n      // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n      return !!axis.encoding || !!axis.labelAngle;\n\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (value === getFieldDefTitle(model, channel)) {\n        return true;\n      }\n\n  } // Otherwise, things are explicit if the returned value matches the specified property\n\n\n  return value === axis[property];\n}\n/**\n * Properties to always include values from config\n */\n\n\nvar propsToAlwaysIncludeConfig = new Set(['grid', 'translate', // the rest are not axis configs in Vega, but are in VL, so we need to set too.\n'format', 'formatType', 'orient', 'labelExpr', 'tickCount', 'position', 'tickMinStep']);\n\nfunction parseAxis(channel, model) {\n  var _a, _b, _c;\n\n  var axis = model.axis(channel);\n  var axisComponent = new AxisComponent();\n  var fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);\n  var mark = model.mark,\n      config = model.config;\n  var orient = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a = config[channel === 'x' ? 'axisX' : 'axisY']) === null || _a === void 0 ? void 0 : _a.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);\n  var scaleType = model.getScaleComponent(channel).get('type');\n  var axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n  var disable = axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;\n  axisComponent.set('disable', disable, axis !== undefined);\n\n  if (disable) {\n    return axisComponent;\n  }\n\n  axis = axis || {};\n  var labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n  var ruleParams = {\n    fieldOrDatumDef: fieldOrDatumDef,\n    axis: axis,\n    channel: channel,\n    model: model,\n    scaleType: scaleType,\n    orient: orient,\n    labelAngle: labelAngle,\n    mark: mark,\n    config: config\n  }; // 1.2. Add properties\n\n  var _iterator8 = _createForOfIteratorHelper(AXIS_COMPONENT_PROPERTIES),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var property = _step8.value;\n      var value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n      var hasValue = value !== undefined;\n      var explicit = isExplicit(value, property, axis, model, channel);\n\n      if (hasValue && explicit) {\n        axisComponent.set(property, value, explicit);\n      } else {\n        var _ref = isAxisProperty(property) && property !== 'values' ? getAxisConfig(property, config.style, axis.style, axisConfigs) : {},\n            _ref$configValue = _ref.configValue,\n            configValue = _ref$configValue === void 0 ? undefined : _ref$configValue,\n            _ref$configFrom = _ref.configFrom,\n            configFrom = _ref$configFrom === void 0 ? undefined : _ref$configFrom;\n\n        var hasConfigValue = configValue !== undefined;\n\n        if (hasValue && !hasConfigValue) {\n          // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n          axisComponent.set(property, value, explicit);\n        } else if ( // Cases need implicit values\n        // 1. Axis config that aren't available in Vega\n        !(configFrom === 'vgAxisConfig') || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n        propsToAlwaysIncludeConfig.has(property) && hasConfigValue || // 3. Conditional axis values and signals\n        isConditionalAxisValue(configValue) || isSignalRef(configValue)) {\n          // If a config is specified and is conditional, copy conditional value from axis config\n          axisComponent.set(property, configValue, false);\n        }\n      }\n    } // 2) Add guide encode definition groups\n\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  var axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};\n  var axisEncode = AXIS_PARTS.reduce(function (e, part) {\n    var _a;\n\n    if (!axisComponent.hasAxisPart(part)) {\n      // No need to create encode for a disabled part.\n      return e;\n    }\n\n    var axisEncodingPart = guideEncodeEntry((_a = axisEncoding[part]) !== null && _a !== void 0 ? _a : {}, model);\n    var value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n\n    if (value !== undefined && !isEmpty(value)) {\n      e[part] = {\n        update: value\n      };\n    }\n\n    return e;\n  }, {}); // FIXME: By having encode as one property, we won't have fine grained encode merging.\n\n  if (!isEmpty(axisEncode)) {\n    axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n  }\n\n  return axisComponent;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AXIS_PARTS, isAxisProperty, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getFirstDefined, isEmpty, keys, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, mergeValuesWithExplicit } from '../split';\nimport { AxisComponent, AXIS_COMPONENT_PROPERTIES } from './component';\nimport { getAxisConfig, getAxisConfigs } from './config';\nimport * as encode from './encode';\nimport { axisRules, defaultOrient, getFieldDefTitle, getLabelAngle } from './properties';\nexport function parseUnitAxes(model) {\n    return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {\n        if (model.component.scales[channel]) {\n            axis[channel] = [parseAxis(channel, model)];\n        }\n        return axis;\n    }, {});\n}\nconst OPPOSITE_ORIENT = {\n    bottom: 'top',\n    top: 'bottom',\n    left: 'right',\n    right: 'left'\n};\nexport function parseLayerAxes(model) {\n    var _a;\n    const { axes, resolve } = model.component;\n    const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };\n    for (const child of model.children) {\n        child.parseAxesAndHeaders();\n        for (const channel of keys(child.component.axes)) {\n            resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n            if (resolve.axis[channel] === 'shared') {\n                // If the resolve says shared (and has not been overridden)\n                // We will try to merge and see if there is a conflict\n                axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n                if (!axes[channel]) {\n                    // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n                    // Thus, mark axis as independent and remove the axis component.\n                    resolve.axis[channel] = 'independent';\n                    delete axes[channel];\n                }\n            }\n        }\n    }\n    // Move axes to layer's axis component and merge shared axes\n    for (const channel of POSITION_SCALE_CHANNELS) {\n        for (const child of model.children) {\n            if (!child.component.axes[channel]) {\n                // skip if the child does not have a particular axis\n                continue;\n            }\n            if (resolve.axis[channel] === 'independent') {\n                // If axes are independent, concat the axisComponent array.\n                axes[channel] = ((_a = axes[channel]) !== null && _a !== void 0 ? _a : []).concat(child.component.axes[channel]);\n                // Automatically adjust orient\n                for (const axisComponent of child.component.axes[channel]) {\n                    const { value: orient, explicit } = axisComponent.getWithExplicit('orient');\n                    if (isSignalRef(orient)) {\n                        continue;\n                    }\n                    if (axisCount[orient] > 0 && !explicit) {\n                        // Change axis orient if the number do not match\n                        const oppositeOrient = OPPOSITE_ORIENT[orient];\n                        if (axisCount[orient] > axisCount[oppositeOrient]) {\n                            axisComponent.set('orient', oppositeOrient, false);\n                        }\n                    }\n                    axisCount[orient]++;\n                    // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n                }\n            }\n            // After merging, make sure to remove axes from child\n            delete child.component.axes[channel];\n        }\n        // Suppress grid lines for dual axis charts (https://github.com/vega/vega-lite/issues/4676)\n        if (resolve.axis[channel] === 'independent' && axes[channel] && axes[channel].length > 1) {\n            for (const axisCmpt of axes[channel]) {\n                if (!!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n                    axisCmpt.implicit.grid = false;\n                }\n            }\n        }\n    }\n}\nfunction mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {\n    if (mergedAxisCmpts) {\n        // FIXME: this is a bit wrong once we support multiple axes\n        if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n            return undefined; // Cannot merge axis component with different number of axes.\n        }\n        const length = mergedAxisCmpts.length;\n        for (let i = 0; i < length; i++) {\n            const merged = mergedAxisCmpts[i];\n            const child = childAxisCmpts[i];\n            if (!!merged !== !!child) {\n                return undefined;\n            }\n            else if (merged && child) {\n                const mergedOrient = merged.getWithExplicit('orient');\n                const childOrient = child.getWithExplicit('orient');\n                if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n                    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n                    // Cannot merge due to inconsistent orient\n                    return undefined;\n                }\n                else {\n                    mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n                }\n            }\n        }\n    }\n    else {\n        // For first one, return a copy of the child\n        return childAxisCmpts.map(axisComponent => axisComponent.clone());\n    }\n    return mergedAxisCmpts;\n}\nfunction mergeAxisComponent(merged, child) {\n    for (const prop of AXIS_COMPONENT_PROPERTIES) {\n        const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, 'axis', \n        // Tie breaker function\n        (v1, v2) => {\n            switch (prop) {\n                case 'title':\n                    return mergeTitleComponent(v1, v2);\n                case 'gridScale':\n                    return {\n                        explicit: v1.explicit,\n                        value: getFirstDefined(v1.value, v2.value)\n                    };\n            }\n            return defaultTieBreaker(v1, v2, prop, 'axis');\n        });\n        merged.setWithExplicit(prop, mergedValueWithExplicit);\n    }\n    return merged;\n}\nfunction isExplicit(value, property, axis, model, channel) {\n    if (property === 'disable') {\n        return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n    }\n    axis = axis || {};\n    switch (property) {\n        case 'titleAngle':\n        case 'labelAngle':\n            return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n        case 'values':\n            return !!axis.values;\n        // specified axis.values is already respected, but may get transformed.\n        case 'encode':\n            // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n            return !!axis.encoding || !!axis.labelAngle;\n        case 'title':\n            // title can be explicit if fieldDef.title is set\n            if (value === getFieldDefTitle(model, channel)) {\n                return true;\n            }\n    }\n    // Otherwise, things are explicit if the returned value matches the specified property\n    return value === axis[property];\n}\n/**\n * Properties to always include values from config\n */\nconst propsToAlwaysIncludeConfig = new Set([\n    'grid',\n    'translate',\n    // the rest are not axis configs in Vega, but are in VL, so we need to set too.\n    'format',\n    'formatType',\n    'orient',\n    'labelExpr',\n    'tickCount',\n    'position',\n    'tickMinStep'\n]);\nfunction parseAxis(channel, model) {\n    var _a, _b, _c;\n    let axis = model.axis(channel);\n    const axisComponent = new AxisComponent();\n    const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);\n    const { mark, config } = model;\n    const orient = (axis === null || axis === void 0 ? void 0 : axis.orient) ||\n        ((_a = config[channel === 'x' ? 'axisX' : 'axisY']) === null || _a === void 0 ? void 0 : _a.orient) ||\n        ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) ||\n        defaultOrient(channel);\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n    const disable = axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;\n    axisComponent.set('disable', disable, axis !== undefined);\n    if (disable) {\n        return axisComponent;\n    }\n    axis = axis || {};\n    const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n    const ruleParams = {\n        fieldOrDatumDef,\n        axis,\n        channel,\n        model,\n        scaleType,\n        orient,\n        labelAngle,\n        mark,\n        config\n    };\n    // 1.2. Add properties\n    for (const property of AXIS_COMPONENT_PROPERTIES) {\n        const value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n        const hasValue = value !== undefined;\n        const explicit = isExplicit(value, property, axis, model, channel);\n        if (hasValue && explicit) {\n            axisComponent.set(property, value, explicit);\n        }\n        else {\n            const { configValue = undefined, configFrom = undefined } = isAxisProperty(property) && property !== 'values'\n                ? getAxisConfig(property, config.style, axis.style, axisConfigs)\n                : {};\n            const hasConfigValue = configValue !== undefined;\n            if (hasValue && !hasConfigValue) {\n                // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n                axisComponent.set(property, value, explicit);\n            }\n            else if (\n            // Cases need implicit values\n            // 1. Axis config that aren't available in Vega\n            !(configFrom === 'vgAxisConfig') ||\n                // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n                (propsToAlwaysIncludeConfig.has(property) && hasConfigValue) ||\n                // 3. Conditional axis values and signals\n                isConditionalAxisValue(configValue) ||\n                isSignalRef(configValue)) {\n                // If a config is specified and is conditional, copy conditional value from axis config\n                axisComponent.set(property, configValue, false);\n            }\n        }\n    }\n    // 2) Add guide encode definition groups\n    const axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};\n    const axisEncode = AXIS_PARTS.reduce((e, part) => {\n        var _a;\n        if (!axisComponent.hasAxisPart(part)) {\n            // No need to create encode for a disabled part.\n            return e;\n        }\n        const axisEncodingPart = guideEncodeEntry((_a = axisEncoding[part]) !== null && _a !== void 0 ? _a : {}, model);\n        const value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n        if (value !== undefined && !isEmpty(value)) {\n            e[part] = { update: value };\n        }\n        return e;\n    }, {});\n    // FIXME: By having encode as one property, we won't have fine grained encode merging.\n    if (!isEmpty(axisEncode)) {\n        axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n    }\n    return axisComponent;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}