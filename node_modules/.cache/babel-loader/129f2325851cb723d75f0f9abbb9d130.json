{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\src\\\\components\\\\heatmap\\\\Heatmap.js\";\nimport React, { useRef, useState, useCallback, useMemo, useEffect, useReducer, forwardRef } from 'react';\nimport uuidv4 from 'uuid/v4';\nimport DeckGL from 'deck.gl'; // eslint-disable-next-line import/no-extraneous-dependencies\n\nimport GL from '@luma.gl/constants';\nimport { Texture2D } from '@luma.gl/core';\nimport { OrthographicView } from '@deck.gl/core'; // eslint-disable-line import/no-extraneous-dependencies\n\nimport range from 'lodash/range';\nimport clamp from 'lodash/clamp';\nimport isEqual from 'lodash/isEqual';\nimport { getLongestString } from '../../utils';\nimport HeatmapCompositeTextLayer from '../../layers/HeatmapCompositeTextLayer';\nimport PixelatedBitmapLayer from '../../layers/PixelatedBitmapLayer';\nimport PaddedExpressionHeatmapBitmapLayer from '../../layers/PaddedExpressionHeatmapBitmapLayer';\nimport HeatmapBitmapLayer from '../../layers/HeatmapBitmapLayer';\nimport { DEFAULT_GL_OPTIONS, createDefaultUpdateCellsHover, createDefaultUpdateGenesHover, createDefaultUpdateTracksHover, createDefaultUpdateViewInfo, copyUint8Array, getDefaultColor } from '../utils';\nimport { layerFilter, getAxisSizes, mouseToHeatmapPosition, heatmapToMousePosition, mouseToCellColorPosition } from './utils';\nimport { TILE_SIZE, MAX_ROW_AGG, MIN_ROW_AGG, COLOR_BAR_SIZE, AXIS_MARGIN, DATA_TEXTURE_SIZE, PIXELATED_TEXTURE_PARAMETERS } from '../../layers/heatmap-constants';\nimport HeatmapWorkerPool from './HeatmapWorkerPool'; // Only allocate the memory once for the container\n\nconst paddedExpressionContainer = new Uint8Array(DATA_TEXTURE_SIZE * DATA_TEXTURE_SIZE);\n/**\n * Should the \"padded\" implementation\n * be used? Only works if the number of heatmap values is\n * <=  4096^2 = ~16 million.\n * @param {number|null} dataLength The number of heatmap values.\n * @returns {boolean} Whether the more efficient implementation should be used.\n */\n\nfunction shouldUsePaddedImplementation(dataLength) {\n  return dataLength <= DATA_TEXTURE_SIZE ** 2;\n}\n/**\n * A heatmap component for cell x gene matrices.\n * @param {object} props\n * @param {string} props.uuid The uuid of this component,\n * used by tooltips to determine whether to render a tooltip or\n * a crosshair.\n * @param {string} props.theme The current theme name.\n * @param {object} props.viewState The viewState for\n * DeckGL.\n * @param {function} props.setViewState The viewState setter\n * for DeckGL.\n * @param {number} props.width The width of the canvas.\n * @param {number} props.height The height of the canvas.\n * @param {object} props.expressionMatrix An object { rows, cols, matrix },\n * where matrix is a flat Uint8Array, rows is a list of cell ID strings,\n * and cols is a list of gene ID strings.\n * @param {Map} props.cellColors Map of cell ID to color. Optional.\n * If defined, the key ordering is used to order the cell axis of the heatmap.\n * @param {array} props.cellColorLabels array of labels to place beside cell color\n * tracks. Only works for transpose=true.\n * @param {function} props.clearPleaseWait The clear please wait callback,\n * called when the expression matrix has loaded (is not null).\n * @param {function} props.setCellHighlight Callback function called on\n * hover with the cell ID. Optional.\n * @param {function} props.setGeneHighlight Callback function called on\n * hover with the gene ID. Optional.\n * @param {function} props.updateViewInfo Callback function that gets called with an\n * object { uuid, project() } where project is a function that maps (cellId, geneId)\n * to canvas (x,y) coordinates. Used to show tooltips. Optional.\n * @param {boolean} props.transpose By default, false.\n * @param {string} props.variablesTitle By default, 'Genes'.\n * @param {string} props.observationsTitle By default, 'Cells'.\n * @param {number} props.useDevicePixels By default, 1. Higher values\n * e.g. 2 increase text sharpness.\n * @param {boolean} props.hideObservationLabels By default false.\n * @param {boolean} props.hideVariableLabels By default false.\n * @param {string} props.colormap The name of the colormap function to use.\n * @param {array} props.colormapRange A tuple [lower, upper] to adjust the color scale.\n * @param {function} props.setColormapRange The setter function for colormapRange.\n */\n\n\nconst Heatmap = forwardRef((props, deckRef) => {\n  const {\n    uuid,\n    theme,\n    viewState: rawViewState,\n    setViewState,\n    width: viewWidth,\n    height: viewHeight,\n    expressionMatrix: expression,\n    cellColors,\n    cellColorLabels = [''],\n    colormap,\n    colormapRange,\n    clearPleaseWait,\n    setComponentHover,\n    setCellHighlight = createDefaultUpdateCellsHover('Heatmap'),\n    setGeneHighlight = createDefaultUpdateGenesHover('Heatmap'),\n    setTrackHighlight = createDefaultUpdateTracksHover('Heatmap'),\n    updateViewInfo = createDefaultUpdateViewInfo('Heatmap'),\n    setIsRendering = () => {},\n    transpose = false,\n    variablesTitle = 'Genes',\n    observationsTitle = 'Cells',\n    variablesDashes = true,\n    observationsDashes = true,\n    useDevicePixels = 1,\n    hideObservationLabels = false,\n    hideVariableLabels = false\n  } = props;\n  const viewState = { ...rawViewState,\n    target: transpose ? [rawViewState.target[1], rawViewState.target[0]] : rawViewState.target,\n    minZoom: 0\n  };\n  const axisLeftTitle = transpose ? variablesTitle : observationsTitle;\n  const axisTopTitle = transpose ? observationsTitle : variablesTitle;\n  const workerPool = useMemo(() => new HeatmapWorkerPool(), []);\n  useEffect(() => {\n    if (clearPleaseWait && expression) {\n      clearPleaseWait('expression-matrix');\n    }\n  }, [clearPleaseWait, expression]);\n  const tilesRef = useRef();\n  const dataRef = useRef();\n  const [axisLeftLabels, setAxisLeftLabels] = useState([]);\n  const [axisTopLabels, setAxisTopLabels] = useState([]);\n  const [numCellColorTracks, setNumCellColorTracks] = useState([]); // Since we are storing the tile data in a ref,\n  // and updating it asynchronously when the worker finishes,\n  // we need to tie it to a piece of state through this iteration value.\n\n  const [tileIteration, incTileIteration] = useReducer(i => i + 1, 0); // We need to keep a backlog of the tasks for the worker thread,\n  // since the array buffer can only be held by one thread at a time.\n\n  const [backlog, setBacklog] = useState([]); // Store a reference to the matrix Uint8Array in the dataRef,\n  // since we need to access its array buffer to transfer\n  // it back and forth from the worker thread.\n\n  useEffect(() => {\n    // Store the expression matrix Uint8Array in the dataRef.\n    if (expression && expression.matrix && !shouldUsePaddedImplementation(expression.matrix.length)) {\n      dataRef.current = copyUint8Array(expression.matrix);\n    }\n  }, [dataRef, expression]); // Check if the ordering of axis labels needs to be changed,\n  // for example if the cells \"selected\" (technically just colored)\n  // have changed.\n\n  useEffect(() => {\n    if (!expression) {\n      return;\n    }\n\n    const newCellOrdering = !cellColors || cellColors.size === 0 ? expression.rows : Array.from(cellColors.keys());\n    const oldCellOrdering = transpose ? axisTopLabels : axisLeftLabels;\n\n    if (!isEqual(oldCellOrdering, newCellOrdering)) {\n      if (transpose) {\n        setAxisTopLabels(newCellOrdering);\n      } else {\n        setAxisLeftLabels(newCellOrdering);\n      }\n    }\n  }, [expression, cellColors, axisTopLabels, axisLeftLabels, transpose]); // Set the genes ordering.\n\n  useEffect(() => {\n    if (!expression) {\n      return;\n    }\n\n    if (transpose) {\n      setAxisLeftLabels(expression.cols);\n    } else {\n      setAxisTopLabels(expression.cols);\n    }\n  }, [expression, transpose]);\n  const [longestCellLabel, longestGeneLabel] = useMemo(() => {\n    if (!expression) {\n      return ['', ''];\n    }\n\n    return [getLongestString(expression.rows), getLongestString([...expression.cols, ...cellColorLabels])];\n  }, [expression, cellColorLabels]); // Creating a look up dictionary once is faster than calling indexOf many times\n  // i.e when cell ordering changes.\n\n  const expressionRowLookUp = useMemo(() => {\n    const lookUp = new Map();\n\n    if (expression === null || expression === void 0 ? void 0 : expression.rows) {\n      // eslint-disable-next-line no-return-assign\n      expression.rows.forEach((cell, j) => lookUp.set(cell, j));\n    }\n\n    return lookUp;\n  }, [expression]);\n  const width = axisTopLabels.length;\n  const height = axisLeftLabels.length;\n  const [axisOffsetLeft, axisOffsetTop] = getAxisSizes(transpose, longestGeneLabel, longestCellLabel, hideObservationLabels, hideVariableLabels);\n  const [gl, setGlContext] = useState(null);\n  const offsetTop = axisOffsetTop + COLOR_BAR_SIZE * (transpose ? numCellColorTracks : 0);\n  const offsetLeft = axisOffsetLeft + COLOR_BAR_SIZE * (transpose ? 0 : numCellColorTracks);\n  const matrixWidth = viewWidth - offsetLeft;\n  const matrixHeight = viewHeight - offsetTop;\n  const matrixLeft = -matrixWidth / 2;\n  const matrixRight = matrixWidth / 2;\n  const matrixTop = -matrixHeight / 2;\n  const matrixBottom = matrixHeight / 2;\n  const xTiles = Math.ceil(width / TILE_SIZE);\n  const yTiles = Math.ceil(height / TILE_SIZE);\n  const widthRatio = 1 - (TILE_SIZE - width % TILE_SIZE) / (xTiles * TILE_SIZE);\n  const heightRatio = 1 - (TILE_SIZE - height % TILE_SIZE) / (yTiles * TILE_SIZE);\n  const tileWidth = matrixWidth / widthRatio / xTiles;\n  const tileHeight = matrixHeight / heightRatio / yTiles;\n  const scaleFactor = 2 ** viewState.zoom;\n  const cellHeight = matrixHeight * scaleFactor / height;\n  const cellWidth = matrixWidth * scaleFactor / width; // Get power of 2 between 1 and 16,\n  // for number of cells to aggregate together in each direction.\n\n  const aggSizeX = clamp(2 ** Math.ceil(Math.log2(1 / cellWidth)), MIN_ROW_AGG, MAX_ROW_AGG);\n  const aggSizeY = clamp(2 ** Math.ceil(Math.log2(1 / cellHeight)), MIN_ROW_AGG, MAX_ROW_AGG);\n  const [targetX, targetY] = viewState.target; // Emit the viewInfo object on viewState updates\n  // (used by tooltips / crosshair elements).\n\n  useEffect(() => {\n    updateViewInfo({\n      uuid,\n      project: (cellId, geneId) => {\n        const colI = transpose ? axisTopLabels.indexOf(cellId) : axisTopLabels.indexOf(geneId);\n        const rowI = transpose ? axisLeftLabels.indexOf(geneId) : axisLeftLabels.indexOf(cellId);\n        return heatmapToMousePosition(colI, rowI, {\n          offsetLeft,\n          offsetTop,\n          targetX: viewState.target[0],\n          targetY: viewState.target[1],\n          scaleFactor,\n          matrixWidth,\n          matrixHeight,\n          numRows: height,\n          numCols: width\n        });\n      }\n    });\n  }, [uuid, updateViewInfo, transpose, axisTopLabels, axisLeftLabels, offsetLeft, offsetTop, viewState, scaleFactor, matrixWidth, matrixHeight, height, width]); // Listen for viewState changes.\n  // Do not allow the user to zoom and pan outside of the initial window.\n\n  const onViewStateChange = useCallback(({\n    viewState: nextViewState\n  }) => {\n    const {\n      zoom: nextZoom\n    } = nextViewState;\n    const nextScaleFactor = 2 ** nextZoom;\n    const minTargetX = nextZoom === 0 ? 0 : -(matrixRight - matrixRight / nextScaleFactor);\n    const maxTargetX = -1 * minTargetX;\n    const minTargetY = nextZoom === 0 ? 0 : -(matrixBottom - matrixBottom / nextScaleFactor);\n    const maxTargetY = -1 * minTargetY; // Manipulate view state if necessary to keep the user in the window.\n\n    const nextTarget = [clamp(nextViewState.target[0], minTargetX, maxTargetX), clamp(nextViewState.target[1], minTargetY, maxTargetY)];\n    setViewState({\n      zoom: nextZoom,\n      target: transpose ? [nextTarget[1], nextTarget[0]] : nextTarget\n    });\n  }, [matrixRight, matrixBottom, transpose, setViewState]); // If `expression` or `cellOrdering` have changed,\n  // then new tiles need to be generated,\n  // so add a new task to the backlog.\n\n  useEffect(() => {\n    if (!expression || !expression.matrix || expression.matrix.length < DATA_TEXTURE_SIZE ** 2) {\n      return;\n    } // Use a uuid to give the task a unique ID,\n    // to help identify where in the list it is located\n    // after the worker thread asynchronously sends the data back\n    // to this thread.\n\n\n    if (axisTopLabels && axisLeftLabels && xTiles && yTiles) {\n      setBacklog(prev => [...prev, uuidv4()]);\n    }\n  }, [dataRef, expression, axisTopLabels, axisLeftLabels, xTiles, yTiles]); // When the backlog has updated, a new worker job can be submitted if:\n  // - the backlog has length >= 1 (at least one job is waiting), and\n  // - buffer.byteLength is not zero, so the worker does not currently \"own\" the buffer.\n\n  useEffect(() => {\n    if (backlog.length < 1 || shouldUsePaddedImplementation(dataRef.current.length)) {\n      return;\n    }\n\n    const curr = backlog[backlog.length - 1];\n\n    if (dataRef.current && dataRef.current.buffer.byteLength && expressionRowLookUp.size > 0 && !shouldUsePaddedImplementation(dataRef.current.length)) {\n      const {\n        cols,\n        matrix\n      } = expression;\n      const promises = range(yTiles).map(i => range(xTiles).map(async j => workerPool.process({\n        curr,\n        tileI: i,\n        tileJ: j,\n        tileSize: TILE_SIZE,\n        cellOrdering: transpose ? axisTopLabels : axisLeftLabels,\n        cols,\n        transpose,\n        data: matrix.buffer.slice(),\n        expressionRowLookUp\n      })));\n\n      const process = async () => {\n        const tiles = await Promise.all(promises.flat());\n        tilesRef.current = tiles.map(i => i.tile);\n        incTileIteration();\n        dataRef.current = new Uint8Array(tiles[0].buffer);\n        const {\n          curr: currWork\n        } = tiles[0];\n        setBacklog(prev => {\n          const currIndex = prev.indexOf(currWork);\n          return prev.slice(currIndex + 1, prev.length);\n        });\n      };\n\n      process();\n    }\n  }, [axisLeftLabels, axisTopLabels, backlog, expression, transpose, xTiles, yTiles, workerPool, expressionRowLookUp]);\n  useEffect(() => {\n    setIsRendering(backlog.length > 0);\n  }, [backlog, setIsRendering]); // Create the padded expression matrix for holding data which can then be bound to the GPU.\n\n  const paddedExpressions = useMemo(() => {\n    const cellOrdering = transpose ? axisTopLabels : axisLeftLabels;\n\n    if ((expression === null || expression === void 0 ? void 0 : expression.matrix) && cellOrdering.length && gl && shouldUsePaddedImplementation(expression.matrix.length)) {\n      let newIndex = 0;\n\n      for (let cellOrderingIndex = 0; cellOrderingIndex < cellOrdering.length; cellOrderingIndex += 1) {\n        const cell = cellOrdering[cellOrderingIndex];\n        newIndex = transpose ? cellOrderingIndex : newIndex;\n        const cellIndex = expressionRowLookUp.get(cell);\n\n        for (let geneIndex = 0; geneIndex < expression.cols.length; geneIndex += 1) {\n          const index = cellIndex * expression.cols.length + geneIndex;\n          paddedExpressionContainer[newIndex % (DATA_TEXTURE_SIZE * DATA_TEXTURE_SIZE)] = expression.matrix[index];\n          newIndex = transpose ? newIndex + cellOrdering.length : newIndex + 1;\n        }\n      }\n    }\n\n    return gl ? new Texture2D(gl, {\n      data: paddedExpressionContainer,\n      mipmaps: false,\n      parameters: PIXELATED_TEXTURE_PARAMETERS,\n      // Each color contains a single luminance value.\n      // When sampled, rgb are all set to this luminance, alpha is 1.0.\n      // Reference: https://luma.gl/docs/api-reference/webgl/texture#texture-formats\n      format: GL.LUMINANCE,\n      dataFormat: GL.LUMINANCE,\n      type: GL.UNSIGNED_BYTE,\n      width: DATA_TEXTURE_SIZE,\n      height: DATA_TEXTURE_SIZE\n    }) : paddedExpressionContainer;\n  }, [transpose, axisTopLabels, axisLeftLabels, expression, expressionRowLookUp, gl]); // Update the heatmap tiles if:\n  // - new tiles are available (`tileIteration` has changed), or\n  // - the matrix bounds have changed, or\n  // - the `aggSizeX` or `aggSizeY` have changed, or\n  // - the cell ordering has changed.\n\n  const heatmapLayers = useMemo(() => {\n    const usePaddedExpressions = (expression === null || expression === void 0 ? void 0 : expression.matrix) && shouldUsePaddedImplementation(expression === null || expression === void 0 ? void 0 : expression.matrix.length);\n\n    if ((!tilesRef.current || backlog.length) && !usePaddedExpressions) {\n      return [];\n    }\n\n    if (usePaddedExpressions) {\n      const cellOrdering = transpose ? axisTopLabels : axisLeftLabels; // eslint-disable-next-line no-inner-declarations, no-shadow\n\n      function getLayer(i, j) {\n        const {\n          cols\n        } = expression;\n        return new PaddedExpressionHeatmapBitmapLayer({\n          id: `heatmapLayer-${i}-${j}`,\n          image: paddedExpressions,\n          bounds: [matrixLeft + j * tileWidth, matrixTop + i * tileHeight, matrixLeft + (j + 1) * tileWidth, matrixTop + (i + 1) * tileHeight],\n          tileI: i,\n          tileJ: j,\n          numXTiles: xTiles,\n          numYTiles: yTiles,\n          origDataSize: transpose ? [cols.length, cellOrdering.length] : [cellOrdering.length, cols.length],\n          aggSizeX,\n          aggSizeY,\n          colormap,\n          colorScaleLo: colormapRange[0],\n          colorScaleHi: colormapRange[1],\n          updateTriggers: {\n            image: [axisLeftLabels, axisTopLabels],\n            bounds: [tileHeight, tileWidth]\n          }\n        });\n      }\n\n      const layers = range(yTiles * xTiles).map(index => getLayer(Math.floor(index / xTiles), index % xTiles));\n      return layers;\n    }\n\n    function getLayer(i, j, tile) {\n      return new HeatmapBitmapLayer({\n        id: `heatmapLayer-${tileIteration}-${i}-${j}`,\n        image: tile,\n        bounds: [matrixLeft + j * tileWidth, matrixTop + i * tileHeight, matrixLeft + (j + 1) * tileWidth, matrixTop + (i + 1) * tileHeight],\n        aggSizeX,\n        aggSizeY,\n        colormap,\n        colorScaleLo: colormapRange[0],\n        colorScaleHi: colormapRange[1],\n        updateTriggers: {\n          image: [axisLeftLabels, axisTopLabels],\n          bounds: [tileHeight, tileWidth]\n        }\n      });\n    }\n\n    const layers = tilesRef.current.map((tile, index) => getLayer(Math.floor(index / xTiles), index % xTiles, tile));\n    return layers;\n  }, [expression, backlog.length, transpose, axisTopLabels, axisLeftLabels, yTiles, xTiles, paddedExpressions, matrixLeft, tileWidth, matrixTop, tileHeight, aggSizeX, aggSizeY, colormap, colormapRange, tileIteration]);\n  const axisLeftDashes = transpose ? variablesDashes : observationsDashes;\n  const axisTopDashes = transpose ? observationsDashes : variablesDashes; // Map cell and gene names to arrays with indices,\n  // to prepare to render the names in TextLayers.\n\n  const axisTopLabelData = useMemo(() => axisTopLabels.map((d, i) => [i, axisTopDashes ? `- ${d}` : d]), [axisTopLabels, axisTopDashes]);\n  const axisLeftLabelData = useMemo(() => axisLeftLabels.map((d, i) => [i, axisLeftDashes ? `${d} -` : d]), [axisLeftLabels, axisLeftDashes]);\n  const cellColorLabelsData = useMemo(() => cellColorLabels.map((d, i) => [i, d && (transpose ? `${d} -` : `- ${d}`)]), [cellColorLabels, transpose]);\n  const hideTopLabels = transpose ? hideObservationLabels : hideVariableLabels;\n  const hideLeftLabels = transpose ? hideVariableLabels : hideObservationLabels; // Generate the axis label, axis title, and loading indicator text layers.\n\n  const textLayers = [new HeatmapCompositeTextLayer({\n    axis: 'left',\n    id: 'axisLeftCompositeTextLayer',\n    targetX,\n    targetY,\n    scaleFactor,\n    axisLeftLabelData,\n    matrixTop,\n    height,\n    matrixHeight,\n    cellHeight,\n    cellWidth,\n    axisTopLabelData,\n    matrixLeft,\n    width,\n    matrixWidth,\n    viewHeight,\n    viewWidth,\n    theme,\n    axisLeftTitle,\n    axisTopTitle,\n    axisOffsetLeft,\n    axisOffsetTop,\n    hideTopLabels,\n    hideLeftLabels,\n    transpose\n  }), new HeatmapCompositeTextLayer({\n    axis: 'top',\n    id: 'axisTopCompositeTextLayer',\n    targetX,\n    targetY,\n    scaleFactor,\n    axisLeftLabelData,\n    matrixTop,\n    height,\n    matrixHeight,\n    cellHeight,\n    cellWidth,\n    axisTopLabelData,\n    matrixLeft,\n    width,\n    matrixWidth,\n    viewHeight,\n    viewWidth,\n    theme,\n    axisLeftTitle,\n    axisTopTitle,\n    axisOffsetLeft,\n    axisOffsetTop,\n    cellColorLabelsData,\n    hideTopLabels,\n    hideLeftLabels,\n    transpose\n  }), new HeatmapCompositeTextLayer({\n    axis: 'corner',\n    id: 'cellColorLabelCompositeTextLayer',\n    targetX,\n    targetY,\n    scaleFactor,\n    axisLeftLabelData,\n    matrixTop,\n    height,\n    matrixHeight,\n    cellHeight,\n    cellWidth,\n    axisTopLabelData,\n    matrixLeft,\n    width,\n    matrixWidth,\n    viewHeight,\n    viewWidth,\n    theme,\n    axisLeftTitle,\n    axisTopTitle,\n    axisOffsetLeft,\n    axisOffsetTop,\n    cellColorLabelsData,\n    hideTopLabels,\n    hideLeftLabels,\n    transpose\n  })];\n  useEffect(() => {\n    setNumCellColorTracks(cellColorLabels.length);\n  }, [cellColorLabels]); // Create the left color bar with a BitmapLayer.\n  // TODO: find a way to do aggregation for this as well.\n\n  const cellColorsTilesList = useMemo(() => {\n    if (!cellColors) {\n      return null;\n    }\n\n    let cellId;\n    let offset;\n    let color;\n    let rowI;\n    const cellOrdering = transpose ? axisTopLabels : axisLeftLabels;\n    const colorBarTileWidthPx = transpose ? TILE_SIZE : 1;\n    const colorBarTileHeightPx = transpose ? 1 : TILE_SIZE;\n    const result = range(numCellColorTracks).map(track => {\n      const trackResult = range(transpose ? xTiles : yTiles).map(i => {\n        const tileData = new Uint8ClampedArray(TILE_SIZE * 1 * 4);\n        range(TILE_SIZE).forEach(tileY => {\n          rowI = i * TILE_SIZE + tileY; // the row / cell index\n\n          if (rowI < cellOrdering.length) {\n            cellId = cellOrdering[rowI];\n            color = cellColors.get(cellId);\n            offset = (transpose ? tileY : TILE_SIZE - tileY - 1) * 4;\n\n            if (color) {\n              var _color$track;\n\n              // allows color to be [R, G, B] or array of arrays of [R, G, B]\n              if (typeof color[0] !== 'number') color = (_color$track = color[track]) !== null && _color$track !== void 0 ? _color$track : getDefaultColor(theme);\n              const [rValue, gValue, bValue] = color;\n              tileData[offset + 0] = rValue;\n              tileData[offset + 1] = gValue;\n              tileData[offset + 2] = bValue;\n              tileData[offset + 3] = 255;\n            }\n          }\n        });\n        return new ImageData(tileData, colorBarTileWidthPx, colorBarTileHeightPx);\n      });\n      return trackResult;\n    });\n    return result;\n  }, [cellColors, transpose, axisTopLabels, axisLeftLabels, numCellColorTracks, xTiles, yTiles, theme]);\n  const cellColorsLayersList = useMemo(() => {\n    if (!cellColorsTilesList) {\n      return [];\n    }\n\n    const result = cellColorsTilesList.map((cellColorsTiles, track) => cellColorsTiles ? cellColorsTiles.map((tile, i) => new PixelatedBitmapLayer({\n      id: `${transpose ? 'colorsTopLayer' : 'colorsLeftLayer'}-${track}-${i}-${uuidv4()}`,\n      image: tile,\n      bounds: transpose ? [matrixLeft + i * tileWidth, -matrixHeight / 2, matrixLeft + (i + 1) * tileWidth, matrixHeight / 2] : [-matrixWidth / 2, matrixTop + i * tileHeight, matrixWidth / 2, matrixTop + (i + 1) * tileHeight]\n    })) : []);\n    return result;\n  }, [cellColorsTilesList, matrixTop, matrixLeft, matrixHeight, matrixWidth, tileWidth, tileHeight, transpose]);\n  const layers = heatmapLayers.concat(textLayers).concat(...cellColorsLayersList); // Set up the onHover function.\n\n  function onHover(info, event) {\n    if (!expression) {\n      return;\n    }\n\n    const {\n      x: mouseX,\n      y: mouseY\n    } = event.offsetCenter;\n    const [trackColI, trackI] = mouseToCellColorPosition(mouseX, mouseY, {\n      axisOffsetTop,\n      axisOffsetLeft,\n      offsetTop,\n      offsetLeft,\n      colorBarSize: COLOR_BAR_SIZE,\n      numCellColorTracks,\n      transpose,\n      targetX,\n      targetY,\n      scaleFactor,\n      matrixWidth,\n      matrixHeight,\n      numRows: height,\n      numCols: width\n    });\n\n    if (trackI === null || trackColI === null) {\n      setTrackHighlight(null);\n    } else {\n      const obsI = expression.rows.indexOf(axisTopLabels[trackColI]);\n      const cellIndex = expression.rows[obsI];\n      setTrackHighlight([cellIndex, trackI, mouseX, mouseY]);\n    }\n\n    const [colI, rowI] = mouseToHeatmapPosition(mouseX, mouseY, {\n      offsetLeft,\n      offsetTop,\n      targetX,\n      targetY,\n      scaleFactor,\n      matrixWidth,\n      matrixHeight,\n      numRows: height,\n      numCols: width\n    });\n\n    if (colI === null) {\n      if (transpose) {\n        setCellHighlight(null);\n      } else {\n        setGeneHighlight(null);\n      }\n    }\n\n    if (rowI === null) {\n      if (transpose) {\n        setGeneHighlight(null);\n      } else {\n        setCellHighlight(null);\n      }\n    }\n\n    const obsI = expression.rows.indexOf(transpose ? axisTopLabels[colI] : axisLeftLabels[rowI]);\n    const varI = expression.cols.indexOf(transpose ? axisLeftLabels[rowI] : axisTopLabels[colI]);\n    const obsId = expression.rows[obsI];\n    const varId = expression.cols[varI];\n\n    if (setComponentHover) {\n      setComponentHover();\n    }\n\n    setCellHighlight(obsId || null);\n    setGeneHighlight(varId || null);\n  }\n\n  const cellColorsViews = useMemo(() => {\n    const result = range(numCellColorTracks).map(track => {\n      let view;\n\n      if (transpose) {\n        view = new OrthographicView({\n          id: `colorsTop-${track}`,\n          controller: true,\n          x: offsetLeft,\n          y: axisOffsetTop + track * COLOR_BAR_SIZE,\n          width: matrixWidth,\n          height: COLOR_BAR_SIZE - AXIS_MARGIN\n        });\n      } else {\n        view = new OrthographicView({\n          id: `colorsLeft-${track}`,\n          controller: true,\n          x: axisOffsetLeft + track * COLOR_BAR_SIZE,\n          y: offsetTop,\n          width: COLOR_BAR_SIZE - AXIS_MARGIN,\n          height: matrixHeight\n        });\n      }\n\n      return view;\n    });\n    return result;\n  }, [numCellColorTracks, transpose, offsetLeft, axisOffsetTop, matrixWidth, axisOffsetLeft, offsetTop, matrixHeight]);\n  return /*#__PURE__*/React.createElement(DeckGL, {\n    id: `deckgl-overlay-${uuid}`,\n    ref: deckRef,\n    onWebGLInitialized: setGlContext,\n    views: [// Note that there are multiple views here,\n    // but only one viewState.\n    new OrthographicView({\n      id: 'heatmap',\n      controller: true,\n      x: offsetLeft,\n      y: offsetTop,\n      width: matrixWidth,\n      height: matrixHeight\n    }), new OrthographicView({\n      id: 'axisLeft',\n      controller: false,\n      x: 0,\n      y: offsetTop,\n      width: axisOffsetLeft,\n      height: matrixHeight\n    }), new OrthographicView({\n      id: 'axisTop',\n      controller: false,\n      x: offsetLeft,\n      y: 0,\n      width: matrixWidth,\n      height: axisOffsetTop\n    }), new OrthographicView({\n      id: 'cellColorLabel',\n      controller: false,\n      x: transpose ? 0 : axisOffsetLeft,\n      y: transpose ? axisOffsetTop : 0,\n      width: transpose ? axisOffsetLeft : COLOR_BAR_SIZE * numCellColorTracks,\n      height: transpose ? COLOR_BAR_SIZE * numCellColorTracks : axisOffsetTop\n    }), ...cellColorsViews],\n    layers: layers,\n    layerFilter: layerFilter,\n    getCursor: interactionState => interactionState.isDragging ? 'grabbing' : 'default',\n    glOptions: DEFAULT_GL_OPTIONS,\n    onViewStateChange: onViewStateChange,\n    viewState: viewState,\n    onHover: onHover,\n    useDevicePixels: useDevicePixels,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 803,\n      columnNumber: 5\n    }\n  });\n});\nexport default Heatmap;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/heatmap/Heatmap.js"],"names":["React","useRef","useState","useCallback","useMemo","useEffect","useReducer","forwardRef","uuidv4","DeckGL","GL","Texture2D","OrthographicView","range","clamp","isEqual","getLongestString","HeatmapCompositeTextLayer","PixelatedBitmapLayer","PaddedExpressionHeatmapBitmapLayer","HeatmapBitmapLayer","DEFAULT_GL_OPTIONS","createDefaultUpdateCellsHover","createDefaultUpdateGenesHover","createDefaultUpdateTracksHover","createDefaultUpdateViewInfo","copyUint8Array","getDefaultColor","layerFilter","getAxisSizes","mouseToHeatmapPosition","heatmapToMousePosition","mouseToCellColorPosition","TILE_SIZE","MAX_ROW_AGG","MIN_ROW_AGG","COLOR_BAR_SIZE","AXIS_MARGIN","DATA_TEXTURE_SIZE","PIXELATED_TEXTURE_PARAMETERS","HeatmapWorkerPool","paddedExpressionContainer","Uint8Array","shouldUsePaddedImplementation","dataLength","Heatmap","props","deckRef","uuid","theme","viewState","rawViewState","setViewState","width","viewWidth","height","viewHeight","expressionMatrix","expression","cellColors","cellColorLabels","colormap","colormapRange","clearPleaseWait","setComponentHover","setCellHighlight","setGeneHighlight","setTrackHighlight","updateViewInfo","setIsRendering","transpose","variablesTitle","observationsTitle","variablesDashes","observationsDashes","useDevicePixels","hideObservationLabels","hideVariableLabels","target","minZoom","axisLeftTitle","axisTopTitle","workerPool","tilesRef","dataRef","axisLeftLabels","setAxisLeftLabels","axisTopLabels","setAxisTopLabels","numCellColorTracks","setNumCellColorTracks","tileIteration","incTileIteration","i","backlog","setBacklog","matrix","length","current","newCellOrdering","size","rows","Array","from","keys","oldCellOrdering","cols","longestCellLabel","longestGeneLabel","expressionRowLookUp","lookUp","Map","forEach","cell","j","set","axisOffsetLeft","axisOffsetTop","gl","setGlContext","offsetTop","offsetLeft","matrixWidth","matrixHeight","matrixLeft","matrixRight","matrixTop","matrixBottom","xTiles","Math","ceil","yTiles","widthRatio","heightRatio","tileWidth","tileHeight","scaleFactor","zoom","cellHeight","cellWidth","aggSizeX","log2","aggSizeY","targetX","targetY","project","cellId","geneId","colI","indexOf","rowI","numRows","numCols","onViewStateChange","nextViewState","nextZoom","nextScaleFactor","minTargetX","maxTargetX","minTargetY","maxTargetY","nextTarget","prev","curr","buffer","byteLength","promises","map","process","tileI","tileJ","tileSize","cellOrdering","data","slice","tiles","Promise","all","flat","tile","currWork","currIndex","paddedExpressions","newIndex","cellOrderingIndex","cellIndex","get","geneIndex","index","mipmaps","parameters","format","LUMINANCE","dataFormat","type","UNSIGNED_BYTE","heatmapLayers","usePaddedExpressions","getLayer","id","image","bounds","numXTiles","numYTiles","origDataSize","colorScaleLo","colorScaleHi","updateTriggers","layers","floor","axisLeftDashes","axisTopDashes","axisTopLabelData","d","axisLeftLabelData","cellColorLabelsData","hideTopLabels","hideLeftLabels","textLayers","axis","cellColorsTilesList","offset","color","colorBarTileWidthPx","colorBarTileHeightPx","result","track","trackResult","tileData","Uint8ClampedArray","tileY","rValue","gValue","bValue","ImageData","cellColorsLayersList","cellColorsTiles","concat","onHover","info","event","x","mouseX","y","mouseY","offsetCenter","trackColI","trackI","colorBarSize","obsI","varI","obsId","varId","cellColorsViews","view","controller","interactionState","isDragging"],"mappings":"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","sourcesContent":["import React, {\n  useRef, useState, useCallback, useMemo, useEffect, useReducer, forwardRef,\n} from 'react';\nimport uuidv4 from 'uuid/v4';\nimport DeckGL from 'deck.gl';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport GL from '@luma.gl/constants';\nimport { Texture2D } from '@luma.gl/core';\nimport { OrthographicView } from '@deck.gl/core'; // eslint-disable-line import/no-extraneous-dependencies\nimport range from 'lodash/range';\nimport clamp from 'lodash/clamp';\nimport isEqual from 'lodash/isEqual';\nimport { getLongestString } from '../../utils';\nimport HeatmapCompositeTextLayer from '../../layers/HeatmapCompositeTextLayer';\nimport PixelatedBitmapLayer from '../../layers/PixelatedBitmapLayer';\nimport PaddedExpressionHeatmapBitmapLayer from '../../layers/PaddedExpressionHeatmapBitmapLayer';\nimport HeatmapBitmapLayer from '../../layers/HeatmapBitmapLayer';\nimport {\n  DEFAULT_GL_OPTIONS,\n  createDefaultUpdateCellsHover,\n  createDefaultUpdateGenesHover,\n  createDefaultUpdateTracksHover,\n  createDefaultUpdateViewInfo,\n  copyUint8Array,\n  getDefaultColor,\n} from '../utils';\nimport {\n  layerFilter,\n  getAxisSizes,\n  mouseToHeatmapPosition,\n  heatmapToMousePosition,\n  mouseToCellColorPosition,\n} from './utils';\nimport {\n  TILE_SIZE, MAX_ROW_AGG, MIN_ROW_AGG,\n  COLOR_BAR_SIZE,\n  AXIS_MARGIN,\n  DATA_TEXTURE_SIZE,\n  PIXELATED_TEXTURE_PARAMETERS,\n} from '../../layers/heatmap-constants';\nimport HeatmapWorkerPool from './HeatmapWorkerPool';\n// Only allocate the memory once for the container\nconst paddedExpressionContainer = new Uint8Array(DATA_TEXTURE_SIZE * DATA_TEXTURE_SIZE);\n\n/**\n * Should the \"padded\" implementation\n * be used? Only works if the number of heatmap values is\n * <=  4096^2 = ~16 million.\n * @param {number|null} dataLength The number of heatmap values.\n * @returns {boolean} Whether the more efficient implementation should be used.\n */\nfunction shouldUsePaddedImplementation(dataLength) {\n  return dataLength <= DATA_TEXTURE_SIZE ** 2;\n}\n\n/**\n * A heatmap component for cell x gene matrices.\n * @param {object} props\n * @param {string} props.uuid The uuid of this component,\n * used by tooltips to determine whether to render a tooltip or\n * a crosshair.\n * @param {string} props.theme The current theme name.\n * @param {object} props.viewState The viewState for\n * DeckGL.\n * @param {function} props.setViewState The viewState setter\n * for DeckGL.\n * @param {number} props.width The width of the canvas.\n * @param {number} props.height The height of the canvas.\n * @param {object} props.expressionMatrix An object { rows, cols, matrix },\n * where matrix is a flat Uint8Array, rows is a list of cell ID strings,\n * and cols is a list of gene ID strings.\n * @param {Map} props.cellColors Map of cell ID to color. Optional.\n * If defined, the key ordering is used to order the cell axis of the heatmap.\n * @param {array} props.cellColorLabels array of labels to place beside cell color\n * tracks. Only works for transpose=true.\n * @param {function} props.clearPleaseWait The clear please wait callback,\n * called when the expression matrix has loaded (is not null).\n * @param {function} props.setCellHighlight Callback function called on\n * hover with the cell ID. Optional.\n * @param {function} props.setGeneHighlight Callback function called on\n * hover with the gene ID. Optional.\n * @param {function} props.updateViewInfo Callback function that gets called with an\n * object { uuid, project() } where project is a function that maps (cellId, geneId)\n * to canvas (x,y) coordinates. Used to show tooltips. Optional.\n * @param {boolean} props.transpose By default, false.\n * @param {string} props.variablesTitle By default, 'Genes'.\n * @param {string} props.observationsTitle By default, 'Cells'.\n * @param {number} props.useDevicePixels By default, 1. Higher values\n * e.g. 2 increase text sharpness.\n * @param {boolean} props.hideObservationLabels By default false.\n * @param {boolean} props.hideVariableLabels By default false.\n * @param {string} props.colormap The name of the colormap function to use.\n * @param {array} props.colormapRange A tuple [lower, upper] to adjust the color scale.\n * @param {function} props.setColormapRange The setter function for colormapRange.\n */\nconst Heatmap = forwardRef((props, deckRef) => {\n  const {\n    uuid,\n    theme,\n    viewState: rawViewState,\n    setViewState,\n    width: viewWidth,\n    height: viewHeight,\n    expressionMatrix: expression,\n    cellColors,\n    cellColorLabels = [''],\n    colormap,\n    colormapRange,\n    clearPleaseWait,\n    setComponentHover,\n    setCellHighlight = createDefaultUpdateCellsHover('Heatmap'),\n    setGeneHighlight = createDefaultUpdateGenesHover('Heatmap'),\n    setTrackHighlight = createDefaultUpdateTracksHover('Heatmap'),\n    updateViewInfo = createDefaultUpdateViewInfo('Heatmap'),\n    setIsRendering = () => {},\n    transpose = false,\n    variablesTitle = 'Genes',\n    observationsTitle = 'Cells',\n    variablesDashes = true,\n    observationsDashes = true,\n    useDevicePixels = 1,\n    hideObservationLabels = false,\n    hideVariableLabels = false,\n  } = props;\n\n  const viewState = {\n    ...rawViewState,\n    target: (transpose ? [rawViewState.target[1], rawViewState.target[0]] : rawViewState.target),\n    minZoom: 0,\n  };\n\n  const axisLeftTitle = (transpose ? variablesTitle : observationsTitle);\n  const axisTopTitle = (transpose ? observationsTitle : variablesTitle);\n\n  const workerPool = useMemo(() => new HeatmapWorkerPool(), []);\n\n  useEffect(() => {\n    if (clearPleaseWait && expression) {\n      clearPleaseWait('expression-matrix');\n    }\n  }, [clearPleaseWait, expression]);\n\n  const tilesRef = useRef();\n  const dataRef = useRef();\n  const [axisLeftLabels, setAxisLeftLabels] = useState([]);\n  const [axisTopLabels, setAxisTopLabels] = useState([]);\n  const [numCellColorTracks, setNumCellColorTracks] = useState([]);\n\n\n  // Since we are storing the tile data in a ref,\n  // and updating it asynchronously when the worker finishes,\n  // we need to tie it to a piece of state through this iteration value.\n  const [tileIteration, incTileIteration] = useReducer(i => i + 1, 0);\n\n  // We need to keep a backlog of the tasks for the worker thread,\n  // since the array buffer can only be held by one thread at a time.\n  const [backlog, setBacklog] = useState([]);\n\n  // Store a reference to the matrix Uint8Array in the dataRef,\n  // since we need to access its array buffer to transfer\n  // it back and forth from the worker thread.\n  useEffect(() => {\n    // Store the expression matrix Uint8Array in the dataRef.\n    if (expression && expression.matrix\n      && !shouldUsePaddedImplementation(expression.matrix.length)\n    ) {\n      dataRef.current = copyUint8Array(expression.matrix);\n    }\n  }, [dataRef, expression]);\n\n  // Check if the ordering of axis labels needs to be changed,\n  // for example if the cells \"selected\" (technically just colored)\n  // have changed.\n  useEffect(() => {\n    if (!expression) {\n      return;\n    }\n\n    const newCellOrdering = (!cellColors || cellColors.size === 0\n      ? expression.rows\n      : Array.from(cellColors.keys())\n    );\n\n    const oldCellOrdering = (transpose ? axisTopLabels : axisLeftLabels);\n\n    if (!isEqual(oldCellOrdering, newCellOrdering)) {\n      if (transpose) {\n        setAxisTopLabels(newCellOrdering);\n      } else {\n        setAxisLeftLabels(newCellOrdering);\n      }\n    }\n  }, [expression, cellColors, axisTopLabels, axisLeftLabels, transpose]);\n\n  // Set the genes ordering.\n  useEffect(() => {\n    if (!expression) {\n      return;\n    }\n    if (transpose) {\n      setAxisLeftLabels(expression.cols);\n    } else {\n      setAxisTopLabels(expression.cols);\n    }\n  }, [expression, transpose]);\n\n  const [longestCellLabel, longestGeneLabel] = useMemo(() => {\n    if (!expression) {\n      return ['', ''];\n    }\n\n    return [\n      getLongestString(expression.rows),\n      getLongestString([...expression.cols, ...cellColorLabels]),\n    ];\n  }, [expression, cellColorLabels]);\n\n  // Creating a look up dictionary once is faster than calling indexOf many times\n  // i.e when cell ordering changes.\n  const expressionRowLookUp = useMemo(() => {\n    const lookUp = new Map();\n    if (expression?.rows) {\n      // eslint-disable-next-line no-return-assign\n      expression.rows.forEach((cell, j) => (lookUp.set(cell, j)));\n    }\n    return lookUp;\n  }, [expression]);\n\n  const width = axisTopLabels.length;\n  const height = axisLeftLabels.length;\n\n  const [axisOffsetLeft, axisOffsetTop] = getAxisSizes(\n    transpose, longestGeneLabel, longestCellLabel,\n    hideObservationLabels, hideVariableLabels,\n  );\n  const [gl, setGlContext] = useState(null);\n\n  const offsetTop = axisOffsetTop + COLOR_BAR_SIZE * (transpose ? numCellColorTracks : 0);\n  const offsetLeft = axisOffsetLeft + COLOR_BAR_SIZE * (transpose ? 0 : numCellColorTracks);\n\n  const matrixWidth = viewWidth - offsetLeft;\n  const matrixHeight = viewHeight - offsetTop;\n\n  const matrixLeft = -matrixWidth / 2;\n  const matrixRight = matrixWidth / 2;\n  const matrixTop = -matrixHeight / 2;\n  const matrixBottom = matrixHeight / 2;\n\n  const xTiles = Math.ceil(width / TILE_SIZE);\n  const yTiles = Math.ceil(height / TILE_SIZE);\n\n  const widthRatio = 1 - (TILE_SIZE - (width % TILE_SIZE)) / (xTiles * TILE_SIZE);\n  const heightRatio = 1 - (TILE_SIZE - (height % TILE_SIZE)) / (yTiles * TILE_SIZE);\n\n  const tileWidth = (matrixWidth / widthRatio) / (xTiles);\n  const tileHeight = (matrixHeight / heightRatio) / (yTiles);\n\n  const scaleFactor = 2 ** viewState.zoom;\n  const cellHeight = (matrixHeight * scaleFactor) / height;\n  const cellWidth = (matrixWidth * scaleFactor) / width;\n\n  // Get power of 2 between 1 and 16,\n  // for number of cells to aggregate together in each direction.\n  const aggSizeX = clamp(2 ** Math.ceil(Math.log2(1 / cellWidth)), MIN_ROW_AGG, MAX_ROW_AGG);\n  const aggSizeY = clamp(2 ** Math.ceil(Math.log2(1 / cellHeight)), MIN_ROW_AGG, MAX_ROW_AGG);\n\n  const [targetX, targetY] = viewState.target;\n\n  // Emit the viewInfo object on viewState updates\n  // (used by tooltips / crosshair elements).\n  useEffect(() => {\n    updateViewInfo({\n      uuid,\n      project: (cellId, geneId) => {\n        const colI = transpose ? axisTopLabels.indexOf(cellId) : axisTopLabels.indexOf(geneId);\n        const rowI = transpose ? axisLeftLabels.indexOf(geneId) : axisLeftLabels.indexOf(cellId);\n        return heatmapToMousePosition(\n          colI, rowI, {\n            offsetLeft,\n            offsetTop,\n            targetX: viewState.target[0],\n            targetY: viewState.target[1],\n            scaleFactor,\n            matrixWidth,\n            matrixHeight,\n            numRows: height,\n            numCols: width,\n          },\n        );\n      },\n    });\n  }, [uuid, updateViewInfo, transpose, axisTopLabels, axisLeftLabels, offsetLeft,\n    offsetTop, viewState, scaleFactor, matrixWidth, matrixHeight, height, width]);\n\n\n  // Listen for viewState changes.\n  // Do not allow the user to zoom and pan outside of the initial window.\n  const onViewStateChange = useCallback(({ viewState: nextViewState }) => {\n    const { zoom: nextZoom } = nextViewState;\n    const nextScaleFactor = 2 ** nextZoom;\n\n    const minTargetX = nextZoom === 0 ? 0 : -(matrixRight - (matrixRight / nextScaleFactor));\n    const maxTargetX = -1 * minTargetX;\n\n    const minTargetY = nextZoom === 0 ? 0 : -(matrixBottom - (matrixBottom / nextScaleFactor));\n    const maxTargetY = -1 * minTargetY;\n\n    // Manipulate view state if necessary to keep the user in the window.\n    const nextTarget = [\n      clamp(nextViewState.target[0], minTargetX, maxTargetX),\n      clamp(nextViewState.target[1], minTargetY, maxTargetY),\n    ];\n\n    setViewState({\n      zoom: nextZoom,\n      target: (transpose ? [nextTarget[1], nextTarget[0]] : nextTarget),\n    });\n  }, [matrixRight, matrixBottom, transpose, setViewState]);\n\n  // If `expression` or `cellOrdering` have changed,\n  // then new tiles need to be generated,\n  // so add a new task to the backlog.\n  useEffect(() => {\n    if (!expression || !expression.matrix || expression.matrix.length < DATA_TEXTURE_SIZE ** 2) {\n      return;\n    }\n    // Use a uuid to give the task a unique ID,\n    // to help identify where in the list it is located\n    // after the worker thread asynchronously sends the data back\n    // to this thread.\n    if (\n      axisTopLabels && axisLeftLabels && xTiles && yTiles\n    ) {\n      setBacklog(prev => [...prev, uuidv4()]);\n    }\n  }, [dataRef, expression, axisTopLabels, axisLeftLabels, xTiles, yTiles]);\n\n  // When the backlog has updated, a new worker job can be submitted if:\n  // - the backlog has length >= 1 (at least one job is waiting), and\n  // - buffer.byteLength is not zero, so the worker does not currently \"own\" the buffer.\n  useEffect(() => {\n    if (backlog.length < 1 || shouldUsePaddedImplementation(dataRef.current.length)) {\n      return;\n    }\n    const curr = backlog[backlog.length - 1];\n    if (dataRef.current\n      && dataRef.current.buffer.byteLength && expressionRowLookUp.size > 0\n      && !shouldUsePaddedImplementation(dataRef.current.length)) {\n      const { cols, matrix } = expression;\n      const promises = range(yTiles).map(i => range(xTiles).map(async j => workerPool.process({\n        curr,\n        tileI: i,\n        tileJ: j,\n        tileSize: TILE_SIZE,\n        cellOrdering: transpose ? axisTopLabels : axisLeftLabels,\n        cols,\n        transpose,\n        data: matrix.buffer.slice(),\n        expressionRowLookUp,\n      })));\n      const process = async () => {\n        const tiles = await Promise.all(promises.flat());\n        tilesRef.current = tiles.map(i => i.tile);\n        incTileIteration();\n        dataRef.current = new Uint8Array(tiles[0].buffer);\n        const { curr: currWork } = tiles[0];\n        setBacklog((prev) => {\n          const currIndex = prev.indexOf(currWork);\n          return prev.slice(currIndex + 1, prev.length);\n        });\n      };\n      process();\n    }\n  }, [axisLeftLabels, axisTopLabels, backlog, expression, transpose,\n    xTiles, yTiles, workerPool, expressionRowLookUp]);\n\n  useEffect(() => {\n    setIsRendering(backlog.length > 0);\n  }, [backlog, setIsRendering]);\n\n  // Create the padded expression matrix for holding data which can then be bound to the GPU.\n  const paddedExpressions = useMemo(() => {\n    const cellOrdering = transpose ? axisTopLabels : axisLeftLabels;\n    if (expression?.matrix && cellOrdering.length\n      && gl && shouldUsePaddedImplementation(expression.matrix.length)) {\n      let newIndex = 0;\n      for (\n        let cellOrderingIndex = 0;\n        cellOrderingIndex < cellOrdering.length;\n        cellOrderingIndex += 1\n      ) {\n        const cell = cellOrdering[cellOrderingIndex];\n        newIndex = transpose ? cellOrderingIndex : newIndex;\n        const cellIndex = expressionRowLookUp.get(cell);\n        for (\n          let geneIndex = 0;\n          geneIndex < expression.cols.length;\n          geneIndex += 1\n        ) {\n          const index = cellIndex * expression.cols.length + geneIndex;\n          paddedExpressionContainer[\n            newIndex % (DATA_TEXTURE_SIZE * DATA_TEXTURE_SIZE)\n          ] = expression.matrix[index];\n          newIndex = transpose ? newIndex + cellOrdering.length : newIndex + 1;\n        }\n      }\n    }\n    return gl ? new Texture2D(gl, {\n      data: paddedExpressionContainer,\n      mipmaps: false,\n      parameters: PIXELATED_TEXTURE_PARAMETERS,\n      // Each color contains a single luminance value.\n      // When sampled, rgb are all set to this luminance, alpha is 1.0.\n      // Reference: https://luma.gl/docs/api-reference/webgl/texture#texture-formats\n      format: GL.LUMINANCE,\n      dataFormat: GL.LUMINANCE,\n      type: GL.UNSIGNED_BYTE,\n      width: DATA_TEXTURE_SIZE,\n      height: DATA_TEXTURE_SIZE,\n    }) : paddedExpressionContainer;\n  }, [\n    transpose,\n    axisTopLabels,\n    axisLeftLabels,\n    expression,\n    expressionRowLookUp,\n    gl,\n  ]);\n\n  // Update the heatmap tiles if:\n  // - new tiles are available (`tileIteration` has changed), or\n  // - the matrix bounds have changed, or\n  // - the `aggSizeX` or `aggSizeY` have changed, or\n  // - the cell ordering has changed.\n  const heatmapLayers = useMemo(() => {\n    const usePaddedExpressions = expression?.matrix\n      && shouldUsePaddedImplementation(expression?.matrix.length);\n    if ((!tilesRef.current || backlog.length) && !usePaddedExpressions) {\n      return [];\n    }\n    if (usePaddedExpressions) {\n      const cellOrdering = transpose ? axisTopLabels : axisLeftLabels;\n      // eslint-disable-next-line no-inner-declarations, no-shadow\n      function getLayer(i, j) {\n        const { cols } = expression;\n        return new PaddedExpressionHeatmapBitmapLayer({\n          id: `heatmapLayer-${i}-${j}`,\n          image: paddedExpressions,\n          bounds: [\n            matrixLeft + j * tileWidth,\n            matrixTop + i * tileHeight,\n            matrixLeft + (j + 1) * tileWidth,\n            matrixTop + (i + 1) * tileHeight,\n          ],\n          tileI: i,\n          tileJ: j,\n          numXTiles: xTiles,\n          numYTiles: yTiles,\n          origDataSize: transpose\n            ? [cols.length, cellOrdering.length]\n            : [cellOrdering.length, cols.length],\n          aggSizeX,\n          aggSizeY,\n          colormap,\n          colorScaleLo: colormapRange[0],\n          colorScaleHi: colormapRange[1],\n          updateTriggers: {\n            image: [axisLeftLabels, axisTopLabels],\n            bounds: [tileHeight, tileWidth],\n          },\n        });\n      }\n      const layers = range(yTiles * xTiles).map(\n        index => getLayer(Math.floor(index / xTiles), index % xTiles),\n      );\n      return layers;\n    }\n    function getLayer(i, j, tile) {\n      return new HeatmapBitmapLayer({\n        id: `heatmapLayer-${tileIteration}-${i}-${j}`,\n        image: tile,\n        bounds: [\n          matrixLeft + j * tileWidth,\n          matrixTop + i * tileHeight,\n          matrixLeft + (j + 1) * tileWidth,\n          matrixTop + (i + 1) * tileHeight,\n        ],\n        aggSizeX,\n        aggSizeY,\n        colormap,\n        colorScaleLo: colormapRange[0],\n        colorScaleHi: colormapRange[1],\n        updateTriggers: {\n          image: [axisLeftLabels, axisTopLabels],\n          bounds: [tileHeight, tileWidth],\n        },\n      });\n    }\n    const layers = tilesRef.current.map(\n      (tile, index) => getLayer(Math.floor(index / xTiles), index % xTiles, tile),\n    );\n    return layers;\n  }, [expression, backlog.length, transpose, axisTopLabels, axisLeftLabels, yTiles, xTiles,\n    paddedExpressions, matrixLeft, tileWidth, matrixTop, tileHeight,\n    aggSizeX, aggSizeY, colormap, colormapRange, tileIteration]);\n  const axisLeftDashes = (transpose ? variablesDashes : observationsDashes);\n  const axisTopDashes = (transpose ? observationsDashes : variablesDashes);\n\n  // Map cell and gene names to arrays with indices,\n  // to prepare to render the names in TextLayers.\n  const axisTopLabelData = useMemo(() => axisTopLabels.map((d, i) => [i, (axisTopDashes ? `- ${d}` : d)]), [axisTopLabels, axisTopDashes]);\n  const axisLeftLabelData = useMemo(() => axisLeftLabels.map((d, i) => [i, (axisLeftDashes ? `${d} -` : d)]), [axisLeftLabels, axisLeftDashes]);\n  const cellColorLabelsData = useMemo(() => cellColorLabels.map((d, i) => [i, d && (transpose ? `${d} -` : `- ${d}`)]), [cellColorLabels, transpose]);\n\n  const hideTopLabels = (transpose ? hideObservationLabels : hideVariableLabels);\n  const hideLeftLabels = (transpose ? hideVariableLabels : hideObservationLabels);\n\n  // Generate the axis label, axis title, and loading indicator text layers.\n  const textLayers = [\n    new HeatmapCompositeTextLayer({\n      axis: 'left',\n      id: 'axisLeftCompositeTextLayer',\n      targetX,\n      targetY,\n      scaleFactor,\n      axisLeftLabelData,\n      matrixTop,\n      height,\n      matrixHeight,\n      cellHeight,\n      cellWidth,\n      axisTopLabelData,\n      matrixLeft,\n      width,\n      matrixWidth,\n      viewHeight,\n      viewWidth,\n      theme,\n      axisLeftTitle,\n      axisTopTitle,\n      axisOffsetLeft,\n      axisOffsetTop,\n      hideTopLabels,\n      hideLeftLabels,\n      transpose,\n    }),\n    new HeatmapCompositeTextLayer({\n      axis: 'top',\n      id: 'axisTopCompositeTextLayer',\n      targetX,\n      targetY,\n      scaleFactor,\n      axisLeftLabelData,\n      matrixTop,\n      height,\n      matrixHeight,\n      cellHeight,\n      cellWidth,\n      axisTopLabelData,\n      matrixLeft,\n      width,\n      matrixWidth,\n      viewHeight,\n      viewWidth,\n      theme,\n      axisLeftTitle,\n      axisTopTitle,\n      axisOffsetLeft,\n      axisOffsetTop,\n      cellColorLabelsData,\n      hideTopLabels,\n      hideLeftLabels,\n      transpose,\n    }),\n    new HeatmapCompositeTextLayer({\n      axis: 'corner',\n      id: 'cellColorLabelCompositeTextLayer',\n      targetX,\n      targetY,\n      scaleFactor,\n      axisLeftLabelData,\n      matrixTop,\n      height,\n      matrixHeight,\n      cellHeight,\n      cellWidth,\n      axisTopLabelData,\n      matrixLeft,\n      width,\n      matrixWidth,\n      viewHeight,\n      viewWidth,\n      theme,\n      axisLeftTitle,\n      axisTopTitle,\n      axisOffsetLeft,\n      axisOffsetTop,\n      cellColorLabelsData,\n      hideTopLabels,\n      hideLeftLabels,\n      transpose,\n    }),\n  ];\n\n  useEffect(() => {\n    setNumCellColorTracks(cellColorLabels.length);\n  }, [cellColorLabels]);\n\n\n  // Create the left color bar with a BitmapLayer.\n  // TODO: find a way to do aggregation for this as well.\n  const cellColorsTilesList = useMemo(() => {\n    if (!cellColors) {\n      return null;\n    }\n\n    let cellId;\n    let offset;\n    let color;\n    let rowI;\n\n    const cellOrdering = (transpose ? axisTopLabels : axisLeftLabels);\n    const colorBarTileWidthPx = (transpose ? TILE_SIZE : 1);\n    const colorBarTileHeightPx = (transpose ? 1 : TILE_SIZE);\n\n    const result = range(numCellColorTracks).map((track) => {\n      const trackResult = range((transpose ? xTiles : yTiles)).map((i) => {\n        const tileData = new Uint8ClampedArray(TILE_SIZE * 1 * 4);\n\n        range(TILE_SIZE).forEach((tileY) => {\n          rowI = (i * TILE_SIZE) + tileY; // the row / cell index\n          if (rowI < cellOrdering.length) {\n            cellId = cellOrdering[rowI];\n            color = cellColors.get(cellId);\n\n            offset = (transpose ? tileY : (TILE_SIZE - tileY - 1)) * 4;\n\n            if (color) {\n              // allows color to be [R, G, B] or array of arrays of [R, G, B]\n              if (typeof color[0] !== 'number') color = color[track] ?? getDefaultColor(theme);\n\n              const [rValue, gValue, bValue] = color;\n              tileData[offset + 0] = rValue;\n              tileData[offset + 1] = gValue;\n              tileData[offset + 2] = bValue;\n              tileData[offset + 3] = 255;\n            }\n          }\n        });\n\n        return new ImageData(tileData, colorBarTileWidthPx, colorBarTileHeightPx);\n      });\n\n      return trackResult;\n    });\n\n    return result;\n  }, [cellColors, transpose, axisTopLabels, axisLeftLabels,\n    numCellColorTracks, xTiles, yTiles, theme]);\n\n\n  const cellColorsLayersList = useMemo(() => {\n    if (!cellColorsTilesList) {\n      return [];\n    }\n\n    const result = cellColorsTilesList.map((cellColorsTiles, track) => (cellColorsTiles\n      ? cellColorsTiles.map((tile, i) => new PixelatedBitmapLayer({\n        id: `${(transpose ? 'colorsTopLayer' : 'colorsLeftLayer')}-${track}-${i}-${uuidv4()}`,\n        image: tile,\n        bounds: (transpose ? [\n          matrixLeft + i * tileWidth,\n          -matrixHeight / 2,\n          matrixLeft + (i + 1) * tileWidth,\n          matrixHeight / 2,\n        ] : [\n          -matrixWidth / 2,\n          matrixTop + i * tileHeight,\n          matrixWidth / 2,\n          matrixTop + (i + 1) * tileHeight,\n        ]),\n      }))\n      : []));\n\n    return (result);\n  }, [cellColorsTilesList, matrixTop, matrixLeft, matrixHeight,\n    matrixWidth, tileWidth, tileHeight, transpose]);\n\n\n  const layers = heatmapLayers\n    .concat(textLayers)\n    .concat(...cellColorsLayersList);\n\n  // Set up the onHover function.\n  function onHover(info, event) {\n    if (!expression) {\n      return;\n    }\n\n    const { x: mouseX, y: mouseY } = event.offsetCenter;\n\n    const [trackColI, trackI] = mouseToCellColorPosition(mouseX, mouseY, {\n      axisOffsetTop,\n      axisOffsetLeft,\n      offsetTop,\n      offsetLeft,\n      colorBarSize: COLOR_BAR_SIZE,\n      numCellColorTracks,\n      transpose,\n      targetX,\n      targetY,\n      scaleFactor,\n      matrixWidth,\n      matrixHeight,\n      numRows: height,\n      numCols: width,\n    });\n\n    if (trackI === null || trackColI === null) {\n      setTrackHighlight(null);\n    } else {\n      const obsI = expression.rows.indexOf(axisTopLabels[trackColI]);\n      const cellIndex = expression.rows[obsI];\n\n      setTrackHighlight([cellIndex, trackI, mouseX, mouseY]);\n    }\n\n    const [colI, rowI] = mouseToHeatmapPosition(mouseX, mouseY, {\n      offsetLeft,\n      offsetTop,\n      targetX,\n      targetY,\n      scaleFactor,\n      matrixWidth,\n      matrixHeight,\n      numRows: height,\n      numCols: width,\n    });\n\n    if (colI === null) {\n      if (transpose) {\n        setCellHighlight(null);\n      } else {\n        setGeneHighlight(null);\n      }\n    }\n\n    if (rowI === null) {\n      if (transpose) {\n        setGeneHighlight(null);\n      } else {\n        setCellHighlight(null);\n      }\n    }\n\n    const obsI = expression.rows.indexOf(transpose\n      ? axisTopLabels[colI]\n      : axisLeftLabels[rowI]);\n    const varI = expression.cols.indexOf(transpose\n      ? axisLeftLabels[rowI]\n      : axisTopLabels[colI]);\n\n    const obsId = expression.rows[obsI];\n    const varId = expression.cols[varI];\n\n    if (setComponentHover) {\n      setComponentHover();\n    }\n    setCellHighlight(obsId || null);\n    setGeneHighlight(varId || null);\n  }\n\n  const cellColorsViews = useMemo(() => {\n    const result = range(numCellColorTracks).map((track) => {\n      let view;\n      if (transpose) {\n        view = new OrthographicView({\n          id: `colorsTop-${track}`,\n          controller: true,\n          x: offsetLeft,\n          y: axisOffsetTop + track * COLOR_BAR_SIZE,\n          width: matrixWidth,\n          height: COLOR_BAR_SIZE - AXIS_MARGIN,\n        });\n      } else {\n        view = new OrthographicView({\n          id: `colorsLeft-${track}`,\n          controller: true,\n          x: axisOffsetLeft + track * COLOR_BAR_SIZE,\n          y: offsetTop,\n          width: COLOR_BAR_SIZE - AXIS_MARGIN,\n          height: matrixHeight,\n        });\n      }\n      return view;\n    });\n\n    return result;\n  }, [numCellColorTracks, transpose, offsetLeft, axisOffsetTop,\n    matrixWidth, axisOffsetLeft, offsetTop, matrixHeight]);\n\n  return (\n    <DeckGL\n      id={`deckgl-overlay-${uuid}`}\n      ref={deckRef}\n      onWebGLInitialized={setGlContext}\n      views={[\n        // Note that there are multiple views here,\n        // but only one viewState.\n        new OrthographicView({\n          id: 'heatmap',\n          controller: true,\n          x: offsetLeft,\n          y: offsetTop,\n          width: matrixWidth,\n          height: matrixHeight,\n        }),\n        new OrthographicView({\n          id: 'axisLeft',\n          controller: false,\n          x: 0,\n          y: offsetTop,\n          width: axisOffsetLeft,\n          height: matrixHeight,\n        }),\n        new OrthographicView({\n          id: 'axisTop',\n          controller: false,\n          x: offsetLeft,\n          y: 0,\n          width: matrixWidth,\n          height: axisOffsetTop,\n        }),\n        new OrthographicView({\n          id: 'cellColorLabel',\n          controller: false,\n          x: (transpose ? 0 : axisOffsetLeft),\n          y: (transpose ? axisOffsetTop : 0),\n          width: (transpose ? axisOffsetLeft : COLOR_BAR_SIZE * numCellColorTracks),\n          height: (transpose ? COLOR_BAR_SIZE * numCellColorTracks : axisOffsetTop),\n        }),\n        ...cellColorsViews,\n      ]}\n      layers={layers}\n      layerFilter={layerFilter}\n      getCursor={interactionState => (interactionState.isDragging ? 'grabbing' : 'default')}\n      glOptions={DEFAULT_GL_OPTIONS}\n      onViewStateChange={onViewStateChange}\n      viewState={viewState}\n      onHover={onHover}\n      useDevicePixels={useDevicePixels}\n    />\n  );\n});\n\nexport default Heatmap;\n"]},"metadata":{},"sourceType":"module"}