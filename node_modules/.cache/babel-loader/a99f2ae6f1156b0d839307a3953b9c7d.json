{"ast":null,"code":"import { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nconst defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {\n      vs,\n      fs,\n      modules: [picking]\n    };\n  }\n\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        update: this.calculateInstancePositions\n      },\n      instanceCounts: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(_ref2) {\n    let {\n      oldProps,\n      props,\n      changeFlags\n    } = _ref2;\n    super.updateState({\n      oldProps,\n      props,\n      changeFlags\n    });\n    const attributeManager = this.getAttributeManager();\n\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw(_ref3) {\n    let {\n      uniforms\n    } = _ref3;\n    const {\n      parameters,\n      maxTexture\n    } = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {\n      model\n    } = this.state;\n    model.setUniforms(uniforms).setUniforms({\n      minColor,\n      maxColor,\n      maxTexture,\n      colorDomain\n    }).draw({\n      parameters: {\n        depthTest: false,\n        depthMask: false,\n        ...parameters\n      }\n    });\n  }\n\n  calculateInstancePositions(attribute, _ref4) {\n    let {\n      numInstances\n    } = _ref4;\n    const {\n      width,\n      height\n    } = this.context.viewport;\n    const {\n      cellSizePixels\n    } = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n    const {\n      value,\n      size\n    } = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n      value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  _getModel(gl) {\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {\n      minColor,\n      maxColor,\n      colorDomain,\n      colorRange\n    } = this.props;\n\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n\n    if (colorDomain || colorRange) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {\n      model\n    } = this.state;\n\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({\n        shouldUseMinMax: this._shouldUseMinMax()\n      });\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({\n        colorRange: colorRangeToFlatArray(props.colorRange)\n      });\n    }\n\n    if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n      const {\n        width,\n        height\n      } = this.context.viewport;\n      const {\n        cellSizePixels,\n        cellMarginPixels\n      } = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n      const cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n      model.setUniforms({\n        cellScale\n      });\n    }\n  }\n\n}\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/screen-grid-layer/screen-grid-cell-layer.js"],"names":["DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","defaultColorRange","isSupported","hasFeatures","FEATURES","getShaders","modules","initializeState","gl","attributeManager","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","model","shouldUpdateState","changeFlags","updateState","props","oldProps","draw","uniforms","maxTexture","minColor","maxColor","parameters","depthTest","depthMask","numInstances","height","numCol","Math","width","i","x","y","_getModel","id","geometry","drawMode","attributes","positions","isInstanced","_shouldUseMinMax","log","_updateUniforms","key","shouldUseMinMax","colorRangeToFlatArray","margin","cellScale","ScreenGridCellLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {Layer, log, picking} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];\n\nconst defaultProps = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({oldProps, props, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    model\n      .setUniforms(uniforms)\n      .setUniforms({\n        minColor,\n        maxColor,\n        maxTexture,\n        colorDomain\n      })\n      .draw({\n        parameters: {\n          depthTest: false,\n          depthMask: false,\n          ...parameters\n        }\n      });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl) {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}