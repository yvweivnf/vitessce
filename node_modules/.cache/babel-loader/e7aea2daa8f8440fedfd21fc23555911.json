{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, isXorY, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, Y } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport var RANGE_PROPERTIES = ['range', 'scheme'];\n\nfunction getSizeChannel(channel) {\n  return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\n\nexport function parseUnitScaleRange(model) {\n  var localScaleComponents = model.component.scales; // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n\n  var _iterator = _createForOfIteratorHelper(SCALE_CHANNELS),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      var localScaleCmpt = localScaleComponents[channel];\n\n      if (!localScaleCmpt) {\n        continue;\n      }\n\n      var rangeWithExplicit = parseRangeForChannel(channel, model);\n      localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction getBinStepSignal(model, channel) {\n  var fieldDef = model.fieldDef(channel);\n\n  if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {\n    var bin = fieldDef.bin,\n        field = fieldDef.field;\n    var sizeType = getSizeChannel(channel);\n    var sizeSignal = model.getName(sizeType);\n\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(function () {\n        var scaleName = model.scaleName(channel);\n        var binCount = \"(domain(\\\"\".concat(scaleName, \"\\\")[1] - domain(\\\"\").concat(scaleName, \"\\\")[0]) / \").concat(bin.step);\n        return \"\".concat(model.getSignalName(sizeSignal), \" / (\").concat(binCount, \")\");\n      });\n    } else if (isBinning(bin)) {\n      var binSignal = getBinSignalName(model, field, bin); // TODO: extract this to be range step signal\n\n      return new SignalRefWrapper(function () {\n        var updatedName = model.getSignalName(binSignal);\n        var binCount = \"(\".concat(updatedName, \".stop - \").concat(updatedName, \".start) / \").concat(updatedName, \".step\");\n        return \"\".concat(model.getSignalName(sizeSignal), \" / (\").concat(binCount, \")\");\n      });\n    }\n  }\n\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\n\n\nexport function parseRangeForChannel(channel, model) {\n  var specifiedScale = model.specifiedScales[channel];\n  var size = model.size;\n  var mergedScaleCmpt = model.getScaleComponent(channel);\n  var scaleType = mergedScaleCmpt.get('type'); // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n\n  var _iterator2 = _createForOfIteratorHelper(RANGE_PROPERTIES),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var property = _step2.value;\n\n      if (specifiedScale[property] !== undefined) {\n        var supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n        var channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n        if (!supportedByScaleType) {\n          log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n        } else if (channelIncompatability) {\n          // channel\n          log.warn(channelIncompatability);\n        } else {\n          switch (property) {\n            case 'range':\n              {\n                var range = specifiedScale.range;\n\n                if (isArray(range)) {\n                  if (isXorY(channel)) {\n                    return makeExplicit(range.map(function (v) {\n                      if (v === 'width' || v === 'height') {\n                        // get signal for width/height\n                        // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                        var sizeSignal = model.getName(v);\n                        var getSignalName = model.getSignalName.bind(model);\n                        return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                      }\n\n                      return v;\n                    }));\n                  }\n                } else if (isObject(range)) {\n                  return makeExplicit({\n                    data: model.requestDataName(DataSourceType.Main),\n                    field: range.field,\n                    sort: {\n                      op: 'min',\n                      field: model.vgField(channel)\n                    }\n                  });\n                }\n\n                return makeExplicit(range);\n              }\n\n            case 'scheme':\n              return makeExplicit(parseScheme(specifiedScale[property]));\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (channel === X || channel === Y) {\n    var sizeChannel = channel === X ? 'width' : 'height';\n    var sizeValue = size[sizeChannel];\n\n    if (isStep(sizeValue)) {\n      if (hasDiscreteDomain(scaleType)) {\n        return makeExplicit({\n          step: sizeValue.step\n        });\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    }\n  }\n\n  var rangeMin = specifiedScale.rangeMin,\n      rangeMax = specifiedScale.rangeMax;\n  var d = defaultRange(channel, model);\n\n  if ((rangeMin !== undefined || rangeMax !== undefined) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n  scaleTypeSupportProperty(scaleType, 'rangeMin') && isArray(d) && d.length === 2) {\n    return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);\n  }\n\n  return makeImplicit(d);\n}\n\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return Object.assign({\n      scheme: scheme.name\n    }, util.omit(scheme, ['name']));\n  }\n\n  return {\n    scheme: scheme\n  };\n}\n\nfunction defaultRange(channel, model) {\n  var size = model.size,\n      config = model.config,\n      mark = model.mark,\n      encoding = model.encoding;\n  var getSignalName = model.getSignalName.bind(model);\n\n  var _getFieldOrDatumDef = getFieldOrDatumDef(encoding[channel]),\n      type = _getFieldOrDatumDef.type;\n\n  var mergedScaleCmpt = model.getScaleComponent(channel);\n  var scaleType = mergedScaleCmpt.get('type');\n  var _model$specifiedScale = model.specifiedScales[channel],\n      domain = _model$specifiedScale.domain,\n      domainMid = _model$specifiedScale.domainMid;\n\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          if (channel === X && !size.width) {\n            var w = getViewConfigDiscreteSize(config.view, 'width');\n\n            if (isStep(w)) {\n              return w;\n            }\n          } else if (channel === Y && !size.height) {\n            var h = getViewConfigDiscreteSize(config.view, 'height');\n\n            if (isStep(h)) {\n              return h;\n            }\n          }\n        } // If step is null, use zero to width or height.\n        // Note that we use SignalRefWrapper to account for potential merges and renames.\n\n\n        var sizeType = getSizeChannel(channel);\n        var sizeSignal = model.getName(sizeType);\n\n        if (channel === Y && hasContinuousDomain(scaleType)) {\n          // For y continuous scale, we have to start from the height as the bottom part has the max value.\n          return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n        } else {\n          return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n        }\n      }\n\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        var zero = model.component.scales[channel].get('zero');\n        var rangeMin = sizeRangeMin(mark, zero, config);\n        var rangeMax = sizeRangeMax(mark, size, model, config);\n\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n\n    case THETA:\n      return [0, Math.PI * 2];\n\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n\n    case RADIUS:\n      {\n        // max radius = half od min(width,height)\n        return [0, new SignalRefWrapper(function () {\n          var w = model.getSignalName('width');\n          var h = model.getSignalName('height');\n          return \"min(\".concat(w, \",\").concat(h, \")/2\");\n        })];\n      }\n\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n\n    case STROKEDASH:\n      return [// TODO: add this to Vega's config.range?\n      [1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];\n\n    case SHAPE:\n      return 'symbol';\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n\n\n  throw new Error(\"Scale range undefined for channel \".concat(channel));\n}\n\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n\n    case 'quantize':\n      return config.scale.quantizeCount;\n\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel)); // default threshold boundaries for threshold scale since domain has cardinality of 2\n\n        return 3;\n      }\n\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\n\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  var f = function f() {\n    var rMax = signalOrStringValue(rangeMax);\n    var rMin = signalOrStringValue(rangeMin);\n    var step = \"(\".concat(rMax, \" - \").concat(rMin, \") / (\").concat(cardinality, \" - 1)\");\n    return \"sequence(\".concat(rMin, \", \").concat(rMax, \" + \").concat(step, \", \").concat(step, \")\");\n  };\n\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\n\nfunction sizeRangeMin(mark, zero, config) {\n  if (zero) {\n    if (isSignalRef(zero)) {\n      return {\n        signal: \"\".concat(zero.signal, \" ? 0 : \").concat(sizeRangeMin(mark, false, config))\n      };\n    } else {\n      return 0;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n\n    case 'text':\n      return config.scale.minFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport var MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark, size, model, config) {\n  var xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n\n        var min = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(function () {\n            return \"\".concat(min.signal, \" - 1\");\n          });\n        }\n      }\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n\n    case 'text':\n      return config.scale.maxFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n\n        var pointStep = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(function () {\n            return \"pow(\".concat(MAX_SIZE_RANGE_STEP_RATIO, \" * \").concat(pointStep.signal, \", 2)\");\n          });\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\n\n\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  var widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  var heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(function () {\n      var exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return \"min(\".concat(exprs.join(', '), \")\");\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}","map":{"version":3,"sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, isXorY, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, Y } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\nfunction getSizeChannel(channel) {\n    return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\nexport function parseUnitScaleRange(model) {\n    const localScaleComponents = model.component.scales;\n    // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n    for (const channel of SCALE_CHANNELS) {\n        const localScaleCmpt = localScaleComponents[channel];\n        if (!localScaleCmpt) {\n            continue;\n        }\n        const rangeWithExplicit = parseRangeForChannel(channel, model);\n        localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n    }\n}\nfunction getBinStepSignal(model, channel) {\n    const fieldDef = model.fieldDef(channel);\n    if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {\n        const { bin, field } = fieldDef;\n        const sizeType = getSizeChannel(channel);\n        const sizeSignal = model.getName(sizeType);\n        if (isObject(bin) && bin.binned && bin.step !== undefined) {\n            return new SignalRefWrapper(() => {\n                const scaleName = model.scaleName(channel);\n                const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n                return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n            });\n        }\n        else if (isBinning(bin)) {\n            const binSignal = getBinSignalName(model, field, bin);\n            // TODO: extract this to be range step signal\n            return new SignalRefWrapper(() => {\n                const updatedName = model.getSignalName(binSignal);\n                const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n                return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n            });\n        }\n    }\n    return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel, model) {\n    const specifiedScale = model.specifiedScales[channel];\n    const { size } = model;\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const scaleType = mergedScaleCmpt.get('type');\n    // Check if any of the range properties is specified.\n    // If so, check if it is compatible and make sure that we only output one of the properties\n    for (const property of RANGE_PROPERTIES) {\n        if (specifiedScale[property] !== undefined) {\n            const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n            const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n            if (!supportedByScaleType) {\n                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n            }\n            else if (channelIncompatability) {\n                // channel\n                log.warn(channelIncompatability);\n            }\n            else {\n                switch (property) {\n                    case 'range': {\n                        const range = specifiedScale.range;\n                        if (isArray(range)) {\n                            if (isXorY(channel)) {\n                                return makeExplicit(range.map(v => {\n                                    if (v === 'width' || v === 'height') {\n                                        // get signal for width/height\n                                        // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                                        const sizeSignal = model.getName(v);\n                                        const getSignalName = model.getSignalName.bind(model);\n                                        return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                                    }\n                                    return v;\n                                }));\n                            }\n                        }\n                        else if (isObject(range)) {\n                            return makeExplicit({\n                                data: model.requestDataName(DataSourceType.Main),\n                                field: range.field,\n                                sort: { op: 'min', field: model.vgField(channel) }\n                            });\n                        }\n                        return makeExplicit(range);\n                    }\n                    case 'scheme':\n                        return makeExplicit(parseScheme(specifiedScale[property]));\n                }\n            }\n        }\n    }\n    if (channel === X || channel === Y) {\n        const sizeChannel = channel === X ? 'width' : 'height';\n        const sizeValue = size[sizeChannel];\n        if (isStep(sizeValue)) {\n            if (hasDiscreteDomain(scaleType)) {\n                return makeExplicit({ step: sizeValue.step });\n            }\n            else {\n                log.warn(log.message.stepDropped(sizeChannel));\n            }\n        }\n    }\n    const { rangeMin, rangeMax } = specifiedScale;\n    const d = defaultRange(channel, model);\n    if ((rangeMin !== undefined || rangeMax !== undefined) &&\n        // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n        scaleTypeSupportProperty(scaleType, 'rangeMin') &&\n        isArray(d) &&\n        d.length === 2) {\n        return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);\n    }\n    return makeImplicit(d);\n}\nfunction parseScheme(scheme) {\n    if (isExtendedScheme(scheme)) {\n        return Object.assign({ scheme: scheme.name }, util.omit(scheme, ['name']));\n    }\n    return { scheme: scheme };\n}\nfunction defaultRange(channel, model) {\n    const { size, config, mark, encoding } = model;\n    const getSignalName = model.getSignalName.bind(model);\n    const { type } = getFieldOrDatumDef(encoding[channel]);\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const scaleType = mergedScaleCmpt.get('type');\n    const { domain, domainMid } = model.specifiedScales[channel];\n    switch (channel) {\n        case X:\n        case Y: {\n            // If there is no explicit width/height for discrete x/y scales\n            if (util.contains(['point', 'band'], scaleType)) {\n                if (channel === X && !size.width) {\n                    const w = getViewConfigDiscreteSize(config.view, 'width');\n                    if (isStep(w)) {\n                        return w;\n                    }\n                }\n                else if (channel === Y && !size.height) {\n                    const h = getViewConfigDiscreteSize(config.view, 'height');\n                    if (isStep(h)) {\n                        return h;\n                    }\n                }\n            }\n            // If step is null, use zero to width or height.\n            // Note that we use SignalRefWrapper to account for potential merges and renames.\n            const sizeType = getSizeChannel(channel);\n            const sizeSignal = model.getName(sizeType);\n            if (channel === Y && hasContinuousDomain(scaleType)) {\n                // For y continuous scale, we have to start from the height as the bottom part has the max value.\n                return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n            }\n            else {\n                return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n            }\n        }\n        case SIZE: {\n            // TODO: support custom rangeMin, rangeMax\n            const zero = model.component.scales[channel].get('zero');\n            const rangeMin = sizeRangeMin(mark, zero, config);\n            const rangeMax = sizeRangeMax(mark, size, model, config);\n            if (isContinuousToDiscrete(scaleType)) {\n                return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n            }\n            else {\n                return [rangeMin, rangeMax];\n            }\n        }\n        case THETA:\n            return [0, Math.PI * 2];\n        case ANGLE:\n            // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n            // (It's weird to add just config.scale.min/maxAngleDegree for now)\n            return [0, 360];\n        case RADIUS: {\n            // max radius = half od min(width,height)\n            return [\n                0,\n                new SignalRefWrapper(() => {\n                    const w = model.getSignalName('width');\n                    const h = model.getSignalName('height');\n                    return `min(${w},${h})/2`;\n                })\n            ];\n        }\n        case STROKEWIDTH:\n            // TODO: support custom rangeMin, rangeMax\n            return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n        case STROKEDASH:\n            return [\n                // TODO: add this to Vega's config.range?\n                [1, 0],\n                [4, 2],\n                [2, 1],\n                [1, 1],\n                [1, 2, 4, 2]\n            ];\n        case SHAPE:\n            return 'symbol';\n        case COLOR:\n        case FILL:\n        case STROKE:\n            if (scaleType === 'ordinal') {\n                // Only nominal data uses ordinal scale by default\n                return type === 'nominal' ? 'category' : 'ordinal';\n            }\n            else {\n                if (domainMid !== undefined) {\n                    return 'diverging';\n                }\n                else {\n                    return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n                }\n            }\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n            // TODO: support custom rangeMin, rangeMax\n            return [config.scale.minOpacity, config.scale.maxOpacity];\n    }\n    /* istanbul ignore next: should never reach here */\n    throw new Error(`Scale range undefined for channel ${channel}`);\n}\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n    switch (scaleType) {\n        case 'quantile':\n            return config.scale.quantileCount;\n        case 'quantize':\n            return config.scale.quantizeCount;\n        case 'threshold':\n            if (domain !== undefined && isArray(domain)) {\n                return domain.length + 1;\n            }\n            else {\n                log.warn(log.message.domainRequiredForThresholdScale(channel));\n                // default threshold boundaries for threshold scale since domain has cardinality of 2\n                return 3;\n            }\n    }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n    // always return a signal since it's better to compute the sequence in Vega later\n    const f = () => {\n        const rMax = signalOrStringValue(rangeMax);\n        const rMin = signalOrStringValue(rangeMin);\n        const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n        return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n    };\n    if (isSignalRef(rangeMax)) {\n        return new SignalRefWrapper(f);\n    }\n    else {\n        return { signal: f() };\n    }\n}\nfunction sizeRangeMin(mark, zero, config) {\n    if (zero) {\n        if (isSignalRef(zero)) {\n            return { signal: `${zero.signal} ? 0 : ${sizeRangeMin(mark, false, config)}` };\n        }\n        else {\n            return 0;\n        }\n    }\n    switch (mark) {\n        case 'bar':\n        case 'tick':\n            return config.scale.minBandSize;\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return config.scale.minStrokeWidth;\n        case 'text':\n            return config.scale.minFontSize;\n        case 'point':\n        case 'square':\n        case 'circle':\n            return config.scale.minSize;\n    }\n    /* istanbul ignore next: should never reach here */\n    // sizeRangeMin not implemented for the mark\n    throw new Error(log.message.incompatibleChannel('size', mark));\n}\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\nfunction sizeRangeMax(mark, size, model, config) {\n    const xyStepSignals = {\n        x: getBinStepSignal(model, 'x'),\n        y: getBinStepSignal(model, 'y')\n    };\n    switch (mark) {\n        case 'bar':\n        case 'tick': {\n            if (config.scale.maxBandSize !== undefined) {\n                return config.scale.maxBandSize;\n            }\n            const min = minXYStep(size, xyStepSignals, config.view);\n            if (isNumber(min)) {\n                return min - 1;\n            }\n            else {\n                return new SignalRefWrapper(() => `${min.signal} - 1`);\n            }\n        }\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return config.scale.maxStrokeWidth;\n        case 'text':\n            return config.scale.maxFontSize;\n        case 'point':\n        case 'square':\n        case 'circle': {\n            if (config.scale.maxSize) {\n                return config.scale.maxSize;\n            }\n            const pointStep = minXYStep(size, xyStepSignals, config.view);\n            if (isNumber(pointStep)) {\n                return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n            }\n            else {\n                return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n            }\n        }\n    }\n    /* istanbul ignore next: should never reach here */\n    // sizeRangeMax not implemented for the mark\n    throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n    const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n    const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n    if (xyStepSignals.x || xyStepSignals.y) {\n        return new SignalRefWrapper(() => {\n            const exprs = [\n                xyStepSignals.x ? xyStepSignals.x.signal : widthStep,\n                xyStepSignals.y ? xyStepSignals.y.signal : heightStep\n            ];\n            return `min(${exprs.join(', ')})`;\n        });\n    }\n    return Math.min(widthStep, heightStep);\n}\n//# sourceMappingURL=range.js.map"]},"metadata":{},"sourceType":"module"}