{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _Optimizer_modified;\n\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\n\nexport function isDataSourceNode(node) {\n  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\n\nexport class Optimizer {\n  constructor() {\n    _Optimizer_modified.set(this, void 0);\n\n    __classPrivateFieldSet(this, _Optimizer_modified, false, \"f\");\n  } // Once true, #modified is never set to false\n\n\n  setModified() {\n    __classPrivateFieldSet(this, _Optimizer_modified, true, \"f\");\n  }\n\n  get modifiedFlag() {\n    return __classPrivateFieldGet(this, _Optimizer_modified, \"f\");\n  }\n\n}\n_Optimizer_modified = new WeakMap();\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\n\nexport class BottomUpOptimizer extends Optimizer {\n  /**\n   * Compute a map of node depths that we can use to determine a topological sort order.\n   */\n  getNodeDepths(node, depth, depths) {\n    depths.set(node, depth);\n\n    for (const child of node.children) {\n      this.getNodeDepths(child, depth + 1, depths);\n    }\n\n    return depths;\n  }\n  /**\n   * Run the optimizer on all nodes starting from the leaves.\n   */\n\n\n  optimize(node) {\n    const depths = this.getNodeDepths(node, 0, new Map());\n    const topologicalSort = [...depths.entries()].sort((a, b) => b[1] - a[1]);\n\n    for (const tuple of topologicalSort) {\n      this.run(tuple[0]);\n    }\n\n    return this.modifiedFlag;\n  }\n\n}\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\n\nexport class TopDownOptimizer extends Optimizer {\n  /**\n   * Run the optimizer depth first on all nodes starting from the roots.\n   */\n  optimize(node) {\n    this.run(node);\n\n    for (const child of node.children) {\n      this.optimize(child);\n    }\n\n    return this.modifiedFlag;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/optimizer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,UAAR,QAAyB,UAAzB;AAEA;;;;AAGA,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAA6C;AACjD,SAAO,IAAI,YAAY,UAAhB,IAA8B,IAAI,YAAY,aAA9C,IAA+D,IAAI,YAAY,YAAtF;AACD;AAED;;;;;AAIA,OAAM,MAAgB,SAAhB,CAAyB;AAG7B,EAAA,WAAA,GAAA;AAFA,IAAA,mBAAA,CAAA,GAAA,CAAA,IAAA,EAAA,KAAA,CAAA;;AAGE,IAAA,sBAAA,CAAA,IAAA,EAAI,mBAAJ,EAAiB,KAAjB,EAAsB,GAAtB,CAAA;AACD,GAL4B,CAO7B;;;AACO,EAAA,WAAW,GAAA;AAChB,IAAA,sBAAA,CAAA,IAAA,EAAI,mBAAJ,EAAiB,IAAjB,EAAqB,GAArB,CAAA;AACD;;AAED,MAAI,YAAJ,GAAgB;AACd,WAAO,sBAAA,CAAA,IAAA,EAAI,mBAAJ,EAAI,GAAJ,CAAP;AACD;;AAd4B;;AAsB/B;;;;;AAIA,OAAM,MAAgB,iBAAhB,SAA0C,SAA1C,CAAmD;AAMvD;;;AAGQ,EAAA,aAAa,CACnB,IADmB,EAEnB,KAFmB,EAGnB,MAHmB,EAGc;AAEjC,IAAA,MAAM,CAAC,GAAP,CAAW,IAAX,EAAiB,KAAjB;;AAEA,SAAK,MAAM,KAAX,IAAoB,IAAI,CAAC,QAAzB,EAAmC;AACjC,WAAK,aAAL,CAAmB,KAAnB,EAA0B,KAAK,GAAG,CAAlC,EAAqC,MAArC;AACD;;AAED,WAAO,MAAP;AACD;AAED;;;;;AAGO,EAAA,QAAQ,CAAC,IAAD,EAAmB;AAChC,UAAM,MAAM,GAAG,KAAK,aAAL,CAAmB,IAAnB,EAAyB,CAAzB,EAA4B,IAAI,GAAJ,EAA5B,CAAf;AACA,UAAM,eAAe,GAAG,CAAC,GAAG,MAAM,CAAC,OAAP,EAAJ,EAAsB,IAAtB,CAA2B,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAA7C,CAAxB;;AAEA,SAAK,MAAM,KAAX,IAAoB,eAApB,EAAqC;AACnC,WAAK,GAAL,CAAS,KAAK,CAAC,CAAD,CAAd;AACD;;AAED,WAAO,KAAK,YAAZ;AACD;;AAnCsD;AAsCzD;;;;AAGA,OAAM,MAAgB,gBAAhB,SAAyC,SAAzC,CAAkD;AAMtD;;;AAGO,EAAA,QAAQ,CAAC,IAAD,EAAmB;AAChC,SAAK,GAAL,CAAS,IAAT;;AAEA,SAAK,MAAM,KAAX,IAAoB,IAAI,CAAC,QAAzB,EAAmC;AACjC,WAAK,QAAL,CAAc,KAAd;AACD;;AAED,WAAO,KAAK,YAAZ;AACD;;AAjBqD","sourceRoot":"","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Optimizer_modified;\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\nexport function isDataSourceNode(node) {\n    return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\nexport class Optimizer {\n    constructor() {\n        _Optimizer_modified.set(this, void 0);\n        __classPrivateFieldSet(this, _Optimizer_modified, false, \"f\");\n    }\n    // Once true, #modified is never set to false\n    setModified() {\n        __classPrivateFieldSet(this, _Optimizer_modified, true, \"f\");\n    }\n    get modifiedFlag() {\n        return __classPrivateFieldGet(this, _Optimizer_modified, \"f\");\n    }\n}\n_Optimizer_modified = new WeakMap();\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\nexport class BottomUpOptimizer extends Optimizer {\n    /**\n     * Compute a map of node depths that we can use to determine a topological sort order.\n     */\n    getNodeDepths(node, depth, depths) {\n        depths.set(node, depth);\n        for (const child of node.children) {\n            this.getNodeDepths(child, depth + 1, depths);\n        }\n        return depths;\n    }\n    /**\n     * Run the optimizer on all nodes starting from the leaves.\n     */\n    optimize(node) {\n        const depths = this.getNodeDepths(node, 0, new Map());\n        const topologicalSort = [...depths.entries()].sort((a, b) => b[1] - a[1]);\n        for (const tuple of topologicalSort) {\n            this.run(tuple[0]);\n        }\n        return this.modifiedFlag;\n    }\n}\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\nexport class TopDownOptimizer extends Optimizer {\n    /**\n     * Run the optimizer depth first on all nodes starting from the roots.\n     */\n    optimize(node) {\n        this.run(node);\n        for (const child of node.children) {\n            this.optimize(child);\n        }\n        return this.modifiedFlag;\n    }\n}\n//# sourceMappingURL=optimizer.js.map"]},"metadata":{},"sourceType":"module"}