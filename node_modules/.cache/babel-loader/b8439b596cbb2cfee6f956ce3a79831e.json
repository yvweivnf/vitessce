{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _editModes = require(\"@nebula.gl/edit-modes\");\n\nvar _editableLayer = _interopRequireDefault(require(\"./editable-layer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0x99];\nvar DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nvar DEFAULT_SELECTED_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nvar DEFAULT_SELECTED_FILL_COLOR = [0x0, 0x0, 0x90, 0x90];\nvar DEFAULT_TENTATIVE_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nvar DEFAULT_TENTATIVE_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nvar DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nvar DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nvar DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nvar DEFAULT_EDITING_POINT_OUTLINE_COLOR = [0xff, 0xff, 0xff, 0xff];\nvar DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nvar DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nvar DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\nvar DEFAULT_EDIT_MODE = _editModes.DrawPolygonMode;\n\nfunction guideAccessor(accessor) {\n  if (!accessor || typeof accessor !== 'function') {\n    return accessor;\n  }\n\n  return function (guideMaybeWrapped) {\n    return accessor(unwrapGuide(guideMaybeWrapped));\n  };\n} // The object handed to us from deck.gl is different depending on the version of deck.gl used, unwrap as necessary\n\n\nfunction unwrapGuide(guideMaybeWrapped) {\n  if (guideMaybeWrapped.__source) {\n    return guideMaybeWrapped.__source.object;\n  } else if (guideMaybeWrapped.sourceFeature) {\n    return guideMaybeWrapped.sourceFeature.feature;\n  } // It is not wrapped, return as is\n\n\n  return guideMaybeWrapped;\n}\n\nfunction getEditHandleColor(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n\n    case 'snap-source':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleOutlineColor(handle) {\n  return DEFAULT_EDITING_POINT_OUTLINE_COLOR;\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nvar defaultProps = {\n  mode: DEFAULT_EDIT_MODE,\n  // Edit and interaction events\n  onEdit: function onEdit() {},\n  pickable: true,\n  pickingRadius: 10,\n  pickingDepth: 5,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'pixels',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  getLineColor: function getLineColor(feature, isSelected, mode) {\n    return isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR;\n  },\n  getFillColor: function getFillColor(feature, isSelected, mode) {\n    return isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR;\n  },\n  getRadius: function getRadius(f) {\n    return f && f.properties && f.properties.radius || f && f.properties && f.properties.size || 1;\n  },\n  getLineWidth: function getLineWidth(f) {\n    return f && f.properties && f.properties.lineWidth || 3;\n  },\n  // Tentative feature rendering\n  getTentativeLineColor: function getTentativeLineColor(f) {\n    return DEFAULT_TENTATIVE_LINE_COLOR;\n  },\n  getTentativeFillColor: function getTentativeFillColor(f) {\n    return DEFAULT_TENTATIVE_FILL_COLOR;\n  },\n  getTentativeLineWidth: function getTentativeLineWidth(f) {\n    return f && f.properties && f.properties.lineWidth || 3;\n  },\n  editHandleType: 'point',\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: true,\n  editHandlePointStrokeWidth: 2,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointOutlineColor: getEditHandleOutlineColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: function getEditHandleIcon(handle) {\n    return handle.properties.editHandleType;\n  },\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n  // misc\n  billboard: true\n}; // Mapping of mode name to mode class (for legacy purposes)\n\nvar modeNameMapping = {\n  view: _editModes.ViewMode,\n  // Alter modes\n  modify: _editModes.ModifyMode,\n  translate: new _editModes.SnappableMode(new _editModes.TranslateMode()),\n  transform: new _editModes.SnappableMode(new _editModes.TransformMode()),\n  scale: _editModes.ScaleMode,\n  rotate: _editModes.RotateMode,\n  duplicate: _editModes.DuplicateMode,\n  split: _editModes.SplitPolygonMode,\n  extrude: _editModes.ExtrudeMode,\n  elevation: _editModes.ElevationMode,\n  // Draw modes\n  drawPoint: _editModes.DrawPointMode,\n  drawLineString: _editModes.DrawLineStringMode,\n  drawPolygon: _editModes.DrawPolygonMode,\n  drawRectangle: _editModes.DrawRectangleMode,\n  drawSquareFromCenter: _editModes.DrawSquareFromCenterMode,\n  drawCircleFromCenter: _editModes.DrawCircleFromCenterMode,\n  drawCircleByBoundingBox: _editModes.DrawCircleByDiameterMode,\n  drawEllipseByBoundingBox: _editModes.DrawEllipseByBoundingBoxMode,\n  drawRectangleUsing3Points: _editModes.DrawRectangleUsingThreePointsMode,\n  drawEllipseUsing3Points: _editModes.DrawEllipseUsingThreePointsMode,\n  draw90DegreePolygon: _editModes.Draw90DegreePolygonMode,\n  drawPolygonByDragging: _editModes.DrawPolygonByDraggingMode\n}; // type State = {\n//   mode: GeoJsonEditMode,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nvar EditableGeoJsonLayer = /*#__PURE__*/function (_EditableLayer) {\n  _inherits(EditableGeoJsonLayer, _EditableLayer);\n\n  var _super = _createSuper(EditableGeoJsonLayer);\n\n  function EditableGeoJsonLayer() {\n    _classCallCheck(this, EditableGeoJsonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EditableGeoJsonLayer, [{\n    key: \"renderLayers\",\n    // props: Props;\n    // setState: ($Shape<State>) => void;\n    value: function renderLayers() {\n      var subLayerProps = this.getSubLayerProps({\n        id: 'geojson',\n        // Proxy most GeoJsonLayer props as-is\n        data: this.props.data,\n        fp64: this.props.fp64,\n        filled: this.props.filled,\n        stroked: this.props.stroked,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        pointRadiusScale: this.props.pointRadiusScale,\n        pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n        pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n        getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n        getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n        getRadius: this.selectionAwareAccessor(this.props.getRadius),\n        getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n        _subLayerProps: {\n          'line-strings': {\n            billboard: this.props.billboard\n          },\n          'polygons-stroke': {\n            billboard: this.props.billboard\n          }\n        },\n        updateTriggers: {\n          getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n          getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n          getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n          getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode]\n        }\n      });\n      var layers = [new _layers.GeoJsonLayer(subLayerProps)];\n      layers = layers.concat(this.createGuidesLayers(), this.createTooltipsLayers());\n      return layers;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      _get(_getPrototypeOf(EditableGeoJsonLayer.prototype), \"initializeState\", this).call(this);\n\n      this.setState({\n        selectedFeatures: [],\n        editHandles: []\n      });\n    } // TODO: is this the best way to properly update state from an outside event handler?\n\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(opts) {\n      // console.log(\n      //   'shouldUpdateState',\n      //   opts.changeFlags.propsOrDataChanged,\n      //   opts.changeFlags.stateChanged\n      // );\n      return _get(_getPrototypeOf(EditableGeoJsonLayer.prototype), \"shouldUpdateState\", this).call(this, opts) || opts.changeFlags.stateChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags; // @ts-ignore\n\n      _get(_getPrototypeOf(EditableGeoJsonLayer.prototype), \"updateState\", this).call(this, {\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      });\n\n      if (changeFlags.propsOrDataChanged) {\n        var modePropChanged = Object.keys(oldProps).length === 0 || props.mode !== oldProps.mode;\n\n        if (modePropChanged) {\n          var mode;\n\n          if (typeof props.mode === 'function') {\n            // They passed a constructor/class, so new it up\n            var ModeConstructor = props.mode;\n            mode = new ModeConstructor();\n          } else if (typeof props.mode === 'string') {\n            // Lookup the mode based on its name (for backwards compatibility)\n            mode = modeNameMapping[props.mode]; // eslint-disable-next-line no-console\n\n            console.warn(\"Deprecated use of passing `mode` as a string. Pass the mode's class constructor instead.\");\n          } else {\n            // Should be an instance of EditMode in this case\n            mode = props.mode;\n          }\n\n          if (!mode) {\n            console.warn(\"No mode configured for \".concat(String(props.mode))); // eslint-disable-line no-console,no-undef\n            // Use default mode\n\n            mode = new DEFAULT_EDIT_MODE();\n          }\n\n          if (mode !== this.state.mode) {\n            this.setState({\n              mode: mode,\n              cursor: null\n            });\n          }\n        }\n      }\n\n      var selectedFeatures = [];\n\n      if (Array.isArray(props.selectedFeatureIndexes)) {\n        // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n        selectedFeatures = props.selectedFeatureIndexes.map(function (elem) {\n          return props.data.features[elem];\n        });\n      }\n\n      this.setState({\n        selectedFeatures: selectedFeatures\n      });\n    }\n  }, {\n    key: \"getModeProps\",\n    value: function getModeProps(props) {\n      var _this = this;\n\n      return {\n        modeConfig: props.modeConfig,\n        data: props.data,\n        selectedIndexes: props.selectedFeatureIndexes,\n        lastPointerMoveEvent: this.state.lastPointerMoveEvent,\n        cursor: this.state.cursor,\n        onEdit: function onEdit(editAction) {\n          // Force a re-render\n          // This supports double-click where we need to ensure that there's a re-render between the two clicks\n          // even though the data wasn't changed, just the internal tentative feature.\n          _this.setNeedsUpdate();\n\n          props.onEdit(editAction);\n        },\n        onUpdateCursor: function onUpdateCursor(cursor) {\n          _this.setState({\n            cursor: cursor\n          });\n        }\n      };\n    }\n  }, {\n    key: \"selectionAwareAccessor\",\n    value: function selectionAwareAccessor(accessor) {\n      var _this2 = this;\n\n      if (typeof accessor !== 'function') {\n        return accessor;\n      }\n\n      return function (feature) {\n        return accessor(feature, _this2.isFeatureSelected(feature), _this2.props.mode);\n      };\n    }\n  }, {\n    key: \"isFeatureSelected\",\n    value: function isFeatureSelected(feature) {\n      if (!this.props.data || !this.props.selectedFeatureIndexes) {\n        return false;\n      }\n\n      if (!this.props.selectedFeatureIndexes.length) {\n        return false;\n      }\n\n      var featureIndex = this.props.data.features.indexOf(feature);\n      return this.props.selectedFeatureIndexes.includes(featureIndex);\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info,\n          sourceLayer = _ref2.sourceLayer;\n\n      if (sourceLayer.id.endsWith('guides')) {\n        // If user is picking an editing handle, add additional data to the info\n        info.isGuide = true;\n      }\n\n      return info;\n    }\n  }, {\n    key: \"createGuidesLayers\",\n    value: function createGuidesLayers() {\n      var mode = this.getActiveMode();\n      var guides = mode.getGuides(this.getModeProps(this.props));\n\n      if (!guides || !guides.features.length) {\n        return [];\n      }\n\n      var pointLayerProps;\n\n      if (this.props.editHandleType === 'icon') {\n        pointLayerProps = {\n          type: _layers.IconLayer,\n          iconAtlas: this.props.editHandleIconAtlas,\n          iconMapping: this.props.editHandleIconMapping,\n          sizeScale: this.props.editHandleIconSizeScale,\n          getIcon: guideAccessor(this.props.getEditHandleIcon),\n          getSize: guideAccessor(this.props.getEditHandleIconSize),\n          getColor: guideAccessor(this.props.getEditHandleIconColor),\n          getAngle: guideAccessor(this.props.getEditHandleIconAngle)\n        };\n      } else {\n        pointLayerProps = {\n          type: _layers.ScatterplotLayer,\n          radiusScale: this.props.editHandlePointRadiusScale,\n          stroked: this.props.editHandlePointOutline,\n          getLineWidth: this.props.editHandlePointStrokeWidth,\n          radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n          radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n          getRadius: guideAccessor(this.props.getEditHandlePointRadius),\n          getFillColor: guideAccessor(this.props.getEditHandlePointColor),\n          getLineColor: guideAccessor(this.props.getEditHandlePointOutlineColor)\n        };\n      }\n\n      var layer = new _layers.GeoJsonLayer(this.getSubLayerProps({\n        id: \"guides\",\n        data: guides,\n        fp64: this.props.fp64,\n        _subLayerProps: {\n          points: pointLayerProps\n        },\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        getLineColor: guideAccessor(this.props.getTentativeLineColor),\n        getLineWidth: guideAccessor(this.props.getTentativeLineWidth),\n        getFillColor: guideAccessor(this.props.getTentativeFillColor)\n      }));\n      return [layer];\n    }\n  }, {\n    key: \"createTooltipsLayers\",\n    value: function createTooltipsLayers() {\n      var mode = this.getActiveMode();\n      var tooltips = mode.getTooltips(this.getModeProps(this.props));\n      var layer = new _layers.TextLayer(this.getSubLayerProps({\n        id: \"tooltips\",\n        data: tooltips\n      }));\n      return [layer];\n    }\n  }, {\n    key: \"onLayerClick\",\n    value: function onLayerClick(event) {\n      this.getActiveMode().handleClick(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onLayerKeyUp\",\n    value: function onLayerKeyUp(event) {\n      this.getActiveMode().handleKeyUp(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onStartDragging\",\n    value: function onStartDragging(event) {\n      this.getActiveMode().handleStartDragging(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onDragging\",\n    value: function onDragging(event) {\n      this.getActiveMode().handleDragging(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onStopDragging\",\n    value: function onStopDragging(event) {\n      this.getActiveMode().handleStopDragging(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(event) {\n      this.setState({\n        lastPointerMoveEvent: event\n      });\n      this.getActiveMode().handlePointerMove(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(_ref3) {\n      var isDragging = _ref3.isDragging;\n\n      if (this.state === null) {\n        // Layer in 'Awaiting state'\n        return null;\n      }\n\n      var cursor = this.state.cursor;\n\n      if (!cursor) {\n        // default cursor\n        cursor = isDragging ? 'grabbing' : 'grab';\n      }\n\n      return cursor;\n    }\n  }, {\n    key: \"getActiveMode\",\n    value: function getActiveMode() {\n      return this.state.mode;\n    }\n  }]);\n\n  return EditableGeoJsonLayer;\n}(_editableLayer[\"default\"]);\n\nexports[\"default\"] = EditableGeoJsonLayer;\n\n_defineProperty(EditableGeoJsonLayer, \"layerName\", 'EditableGeoJsonLayer');\n\n_defineProperty(EditableGeoJsonLayer, \"defaultProps\", defaultProps);","map":{"version":3,"sources":["../../src/layers/editable-geojson-layer.ts"],"names":["DEFAULT_LINE_COLOR","DEFAULT_FILL_COLOR","DEFAULT_SELECTED_LINE_COLOR","DEFAULT_SELECTED_FILL_COLOR","DEFAULT_TENTATIVE_LINE_COLOR","DEFAULT_TENTATIVE_FILL_COLOR","DEFAULT_EDITING_EXISTING_POINT_COLOR","DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","DEFAULT_EDITING_SNAP_POINT_COLOR","DEFAULT_EDITING_POINT_OUTLINE_COLOR","DEFAULT_EDITING_EXISTING_POINT_RADIUS","DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","DEFAULT_EDITING_SNAP_POINT_RADIUS","DEFAULT_EDIT_MODE","DrawPolygonMode","accessor","unwrapGuide","guideMaybeWrapped","handle","defaultProps","mode","onEdit","pickable","pickingRadius","pickingDepth","fp64","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","Number","lineWidthUnits","lineJointRounded","lineMiterLimit","pointRadiusScale","pointRadiusMinPixels","pointRadiusMaxPixels","getLineColor","isSelected","getFillColor","getRadius","f","getLineWidth","getTentativeLineColor","getTentativeFillColor","getTentativeLineWidth","editHandleType","editHandlePointRadiusScale","editHandlePointOutline","editHandlePointStrokeWidth","editHandlePointRadiusMinPixels","editHandlePointRadiusMaxPixels","getEditHandlePointColor","getEditHandlePointOutlineColor","getEditHandlePointRadius","editHandleIconAtlas","editHandleIconMapping","editHandleIconSizeScale","getEditHandleIcon","getEditHandleIconSize","getEditHandleIconColor","getEditHandleIconAngle","billboard","modeNameMapping","view","ViewMode","modify","ModifyMode","translate","SnappableMode","TranslateMode","transform","TransformMode","scale","ScaleMode","rotate","RotateMode","duplicate","DuplicateMode","split","SplitPolygonMode","extrude","ExtrudeMode","elevation","ElevationMode","drawPoint","DrawPointMode","drawLineString","DrawLineStringMode","drawPolygon","drawRectangle","DrawRectangleMode","drawSquareFromCenter","DrawSquareFromCenterMode","drawCircleFromCenter","DrawCircleFromCenterMode","drawCircleByBoundingBox","DrawCircleByDiameterMode","drawEllipseByBoundingBox","DrawEllipseByBoundingBoxMode","drawRectangleUsing3Points","DrawRectangleUsingThreePointsMode","drawEllipseUsing3Points","DrawEllipseUsingThreePointsMode","draw90DegreePolygon","Draw90DegreePolygonMode","drawPolygonByDragging","DrawPolygonByDraggingMode","EditableGeoJsonLayer","EditableLayer","subLayerProps","id","data","_subLayerProps","updateTriggers","layers","GeoJsonLayer","selectedFeatures","editHandles","opts","props","oldProps","changeFlags","modePropChanged","Object","ModeConstructor","console","String","cursor","Array","modeConfig","selectedIndexes","lastPointerMoveEvent","onUpdateCursor","feature","featureIndex","info","sourceLayer","guides","pointLayerProps","type","IconLayer","iconAtlas","iconMapping","sizeScale","getIcon","guideAccessor","getSize","getColor","getAngle","ScatterplotLayer","radiusScale","radiusMinPixels","radiusMaxPixels","layer","points","tooltips","TextLayer","event","isDragging"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer, TextLayer } from '@deck.gl/layers';\n\nimport {\n  ViewMode,\n  ModifyMode,\n  TranslateMode,\n  ScaleMode,\n  RotateMode,\n  DuplicateMode,\n  SplitPolygonMode,\n  ExtrudeMode,\n  ElevationMode,\n  DrawPointMode,\n  DrawLineStringMode,\n  DrawPolygonMode,\n  DrawRectangleMode,\n  DrawSquareFromCenterMode,\n  DrawCircleFromCenterMode,\n  DrawCircleByDiameterMode,\n  DrawEllipseByBoundingBoxMode,\n  DrawRectangleUsingThreePointsMode,\n  DrawEllipseUsingThreePointsMode,\n  Draw90DegreePolygonMode,\n  DrawPolygonByDraggingMode,\n  SnappableMode,\n  TransformMode,\n  EditAction,\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  PointerMoveEvent,\n  GeoJsonEditModeType,\n  GeoJsonEditModeConstructor,\n  FeatureCollection,\n} from '@nebula.gl/edit-modes';\n\nimport EditableLayer from './editable-layer';\n\nconst DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0x99];\nconst DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR = [0x0, 0x0, 0x90, 0x90];\nconst DEFAULT_TENTATIVE_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_TENTATIVE_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_POINT_OUTLINE_COLOR = [0xff, 0xff, 0xff, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\n\nconst DEFAULT_EDIT_MODE = DrawPolygonMode;\n\nfunction guideAccessor(accessor) {\n  if (!accessor || typeof accessor !== 'function') {\n    return accessor;\n  }\n  return (guideMaybeWrapped) => accessor(unwrapGuide(guideMaybeWrapped));\n}\n\n// The object handed to us from deck.gl is different depending on the version of deck.gl used, unwrap as necessary\nfunction unwrapGuide(guideMaybeWrapped) {\n  if (guideMaybeWrapped.__source) {\n    return guideMaybeWrapped.__source.object;\n  } else if (guideMaybeWrapped.sourceFeature) {\n    return guideMaybeWrapped.sourceFeature.feature;\n  }\n  // It is not wrapped, return as is\n  return guideMaybeWrapped;\n}\n\nfunction getEditHandleColor(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap-source':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleOutlineColor(handle) {\n  return DEFAULT_EDITING_POINT_OUTLINE_COLOR;\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nconst defaultProps = {\n  mode: DEFAULT_EDIT_MODE,\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  pickingRadius: 10,\n  pickingDepth: 5,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'pixels',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: (f) =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: (f) => (f && f.properties && f.properties.lineWidth) || 3,\n\n  // Tentative feature rendering\n  getTentativeLineColor: (f) => DEFAULT_TENTATIVE_LINE_COLOR,\n  getTentativeFillColor: (f) => DEFAULT_TENTATIVE_FILL_COLOR,\n  getTentativeLineWidth: (f) => (f && f.properties && f.properties.lineWidth) || 3,\n\n  editHandleType: 'point',\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: true,\n  editHandlePointStrokeWidth: 2,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointOutlineColor: getEditHandleOutlineColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: (handle) => handle.properties.editHandleType,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // misc\n  billboard: true,\n};\n\n// Mapping of mode name to mode class (for legacy purposes)\nconst modeNameMapping = {\n  view: ViewMode,\n\n  // Alter modes\n  modify: ModifyMode,\n  translate: new SnappableMode(new TranslateMode()),\n\n  transform: new SnappableMode(new TransformMode()),\n  scale: ScaleMode,\n  rotate: RotateMode,\n  duplicate: DuplicateMode,\n  split: SplitPolygonMode,\n  extrude: ExtrudeMode,\n  elevation: ElevationMode,\n\n  // Draw modes\n  drawPoint: DrawPointMode,\n  drawLineString: DrawLineStringMode,\n  drawPolygon: DrawPolygonMode,\n  drawRectangle: DrawRectangleMode,\n  drawSquareFromCenter: DrawSquareFromCenterMode,\n  drawCircleFromCenter: DrawCircleFromCenterMode,\n  drawCircleByBoundingBox: DrawCircleByDiameterMode,\n  drawEllipseByBoundingBox: DrawEllipseByBoundingBoxMode,\n  drawRectangleUsing3Points: DrawRectangleUsingThreePointsMode,\n  drawEllipseUsing3Points: DrawEllipseUsingThreePointsMode,\n  draw90DegreePolygon: Draw90DegreePolygonMode,\n  drawPolygonByDragging: DrawPolygonByDraggingMode,\n};\n\ntype Props = {\n  mode: string | GeoJsonEditModeConstructor | GeoJsonEditModeType;\n  onEdit: (arg0: EditAction<FeatureCollection>) => void;\n  // TODO: type the rest\n\n  [key: string]: any;\n};\n\n// type State = {\n//   mode: GeoJsonEditMode,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nexport default class EditableGeoJsonLayer extends EditableLayer {\n  static layerName = 'EditableGeoJsonLayer';\n  static defaultProps = defaultProps;\n  // props: Props;\n\n  // setState: ($Shape<State>) => void;\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n\n      _subLayerProps: {\n        'line-strings': {\n          billboard: this.props.billboard,\n        },\n        'polygons-stroke': {\n          billboard: this.props.billboard,\n        },\n      },\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n      },\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createGuidesLayers(), this.createTooltipsLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      selectedFeatures: [],\n      editHandles: [],\n    });\n  }\n\n  // TODO: is this the best way to properly update state from an outside event handler?\n  shouldUpdateState(opts: any) {\n    // console.log(\n    //   'shouldUpdateState',\n    //   opts.changeFlags.propsOrDataChanged,\n    //   opts.changeFlags.stateChanged\n    // );\n    return super.shouldUpdateState(opts) || opts.changeFlags.stateChanged;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags,\n  }: {\n    props: Props;\n    oldProps: Props;\n    changeFlags: any;\n  }) {\n    // @ts-ignore\n    super.updateState({ oldProps, props, changeFlags });\n\n    if (changeFlags.propsOrDataChanged) {\n      const modePropChanged = Object.keys(oldProps).length === 0 || props.mode !== oldProps.mode;\n      if (modePropChanged) {\n        let mode;\n        if (typeof props.mode === 'function') {\n          // They passed a constructor/class, so new it up\n          const ModeConstructor = props.mode;\n          mode = new ModeConstructor();\n        } else if (typeof props.mode === 'string') {\n          // Lookup the mode based on its name (for backwards compatibility)\n          mode = modeNameMapping[props.mode];\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"Deprecated use of passing `mode` as a string. Pass the mode's class constructor instead.\"\n          );\n        } else {\n          // Should be an instance of EditMode in this case\n          mode = props.mode;\n        }\n\n        if (!mode) {\n          console.warn(`No mode configured for ${String(props.mode)}`); // eslint-disable-line no-console,no-undef\n          // Use default mode\n          mode = new DEFAULT_EDIT_MODE();\n        }\n\n        if (mode !== this.state.mode) {\n          this.setState({ mode, cursor: null });\n        }\n      }\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map((elem) => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  getModeProps(props: Props) {\n    return {\n      modeConfig: props.modeConfig,\n      data: props.data,\n      selectedIndexes: props.selectedFeatureIndexes,\n      lastPointerMoveEvent: this.state.lastPointerMoveEvent,\n      cursor: this.state.cursor,\n      onEdit: (editAction: EditAction<FeatureCollection>) => {\n        // Force a re-render\n        // This supports double-click where we need to ensure that there's a re-render between the two clicks\n        // even though the data wasn't changed, just the internal tentative feature.\n        this.setNeedsUpdate();\n        props.onEdit(editAction);\n      },\n      onUpdateCursor: (cursor: string | null | undefined) => {\n        this.setState({ cursor });\n      },\n    };\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Record<string, any>) =>\n      accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Record<string, any>) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Record<string, any>) {\n    if (sourceLayer.id.endsWith('guides')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isGuide = true;\n    }\n\n    return info;\n  }\n\n  createGuidesLayers() {\n    const mode = this.getActiveMode();\n    const guides: FeatureCollection = mode.getGuides(this.getModeProps(this.props));\n\n    if (!guides || !guides.features.length) {\n      return [];\n    }\n\n    let pointLayerProps;\n    if (this.props.editHandleType === 'icon') {\n      pointLayerProps = {\n        type: IconLayer,\n        iconAtlas: this.props.editHandleIconAtlas,\n        iconMapping: this.props.editHandleIconMapping,\n        sizeScale: this.props.editHandleIconSizeScale,\n        getIcon: guideAccessor(this.props.getEditHandleIcon),\n        getSize: guideAccessor(this.props.getEditHandleIconSize),\n        getColor: guideAccessor(this.props.getEditHandleIconColor),\n        getAngle: guideAccessor(this.props.getEditHandleIconAngle),\n      };\n    } else {\n      pointLayerProps = {\n        type: ScatterplotLayer,\n        radiusScale: this.props.editHandlePointRadiusScale,\n        stroked: this.props.editHandlePointOutline,\n        getLineWidth: this.props.editHandlePointStrokeWidth,\n        radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: guideAccessor(this.props.getEditHandlePointRadius),\n        getFillColor: guideAccessor(this.props.getEditHandlePointColor),\n        getLineColor: guideAccessor(this.props.getEditHandlePointOutlineColor),\n      };\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: `guides`,\n        data: guides,\n        fp64: this.props.fp64,\n        _subLayerProps: {\n          points: pointLayerProps,\n        },\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        getLineColor: guideAccessor(this.props.getTentativeLineColor),\n        getLineWidth: guideAccessor(this.props.getTentativeLineWidth),\n        getFillColor: guideAccessor(this.props.getTentativeFillColor),\n      })\n    );\n\n    return [layer];\n  }\n\n  createTooltipsLayers() {\n    const mode = this.getActiveMode();\n    const tooltips = mode.getTooltips(this.getModeProps(this.props));\n\n    const layer = new TextLayer(\n      this.getSubLayerProps({\n        id: `tooltips`,\n        data: tooltips,\n      })\n    );\n\n    return [layer];\n  }\n\n  onLayerClick(event: ClickEvent) {\n    this.getActiveMode().handleClick(event, this.getModeProps(this.props));\n  }\n\n  onLayerKeyUp(event: KeyboardEvent) {\n    this.getActiveMode().handleKeyUp(event, this.getModeProps(this.props));\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    this.getActiveMode().handleStartDragging(event, this.getModeProps(this.props));\n  }\n\n  onDragging(event: DraggingEvent) {\n    this.getActiveMode().handleDragging(event, this.getModeProps(this.props));\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    this.getActiveMode().handleStopDragging(event, this.getModeProps(this.props));\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    this.setState({ lastPointerMoveEvent: event });\n    this.getActiveMode().handlePointerMove(event, this.getModeProps(this.props));\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    if (this.state === null) {\n      // Layer in 'Awaiting state'\n      return null;\n    }\n\n    let { cursor } = this.state;\n    if (!cursor) {\n      // default cursor\n      cursor = isDragging ? 'grabbing' : 'grab';\n    }\n    return cursor;\n  }\n\n  getActiveMode(): GeoJsonEditModeType {\n    return this.state.mode;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}