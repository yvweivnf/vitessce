{"ast":null,"code":"import { regressionLoess, sampleCurve, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\n\nfunction partition(data, groupby) {\n  var groups = [],\n      get = function get(f) {\n    return f(t);\n  },\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\n\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\n\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      var source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby),\n          names = (_.groupby || []).map(accessorName),\n          m = names.length,\n          as = _.as || [accessorName(_.x), accessorName(_.y)],\n          values = [];\n      groups.forEach(function (g) {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(function (p) {\n          var t = {};\n\n          for (var i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\nvar Methods = {\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\n\nvar degreesOfFreedom = function degreesOfFreedom(method, order) {\n  return method === 'poly' ? order : method === 'quad' ? 2 : 1;\n};\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\n\n\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\n\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      var source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby),\n          names = (_.groupby || []).map(accessorName),\n          method = _.method || 'linear',\n          order = _.order || 3,\n          dof = degreesOfFreedom(method, order),\n          as = _.as || [accessorName(_.x), accessorName(_.y)],\n          fit = Methods[method],\n          values = [];\n      var domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(function (g) {\n        var n = g.length;\n\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        var model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        var dom = domain || extent(g, _.x),\n            add = function add(p) {\n          var t = {};\n\n          for (var i = 0; i < names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        };\n\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(function (x) {\n            return add([x, model.predict(x)]);\n          });\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\nexport { Loess as loess, Regression as regression };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-regression/build/vega-regression.module.js"],"names":["regressionLoess","sampleCurve","regressionLinear","regressionLog","regressionExp","regressionPow","regressionQuad","regressionPoly","Transform","ingest","inherits","accessorName","hasOwnProperty","error","extent","partition","data","groupby","groups","get","f","t","map","i","n","k","g","push","length","dims","Loess","params","call","Definition","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","names","m","as","x","y","values","forEach","bandwidth","p","rem","add","Methods","linear","log","exp","pow","quad","poly","degreesOfFreedom","method","order","Regression","Object","keys","dof","fit","domain","dataflow","warn","model","coef","rSquared","dom","predict","loess","regression"],"mappings":"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","sourcesContent":["import { regressionLoess, sampleCurve, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\n\nfunction partition (data, groupby) {\n  var groups = [],\n      get = function (f) {\n    return f(t);\n  },\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            m = names.length,\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            values = [];\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n\n          for (let i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nconst Methods = {\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\n\nconst degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\n\n\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            method = _.method || 'linear',\n            order = _.order || 3,\n            dof = degreesOfFreedom(method, order),\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            fit = Methods[method],\n            values = [];\n      let domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(g => {\n        const n = g.length;\n\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        const model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        const dom = domain || extent(g, _.x),\n              add = p => {\n          const t = {};\n\n          for (let i = 0; i < names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        };\n\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nexport { Loess as loess, Regression as regression };\n"]},"metadata":{},"sourceType":"module"}