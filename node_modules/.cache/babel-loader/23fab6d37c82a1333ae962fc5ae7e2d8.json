{"ast":null,"code":"import { useRef, useCallback, useMemo } from 'react';\nimport create from 'zustand';\nimport createContext from 'zustand/context';\nimport shallow from 'zustand/shallow';\nimport { CoordinationType } from '../constants';\nimport { fromEntries, capitalize } from '../../utils'; // Reference: https://github.com/pmndrs/zustand#react-context\n// Reference: https://github.com/pmndrs/zustand/blob/e47ea03/tests/context.test.tsx#L60\n\nconst {\n  Provider: ViewConfigProviderLocal,\n  useStore: useViewConfigStoreLocal,\n  useStoreApi: useViewConfigStoreApiLocal\n} = createContext();\nexport const ViewConfigProvider = ViewConfigProviderLocal;\nexport const useViewConfigStore = useViewConfigStoreLocal;\nexport const useViewConfigStoreApi = useViewConfigStoreApiLocal;\nconst {\n  Provider: AuxiliaryProviderLocal,\n  useStore: useAuxiliaryStoreLocal\n} = createContext();\nexport const AuxiliaryProvider = AuxiliaryProviderLocal;\nexport const useAuxiliaryStore = useAuxiliaryStoreLocal;\n/**\n * The useViewConfigStore hook is initialized via the zustand\n * create() function, which sets up both the state variables\n * and the reducer-type functions.\n * Reference: https://github.com/react-spring/zustand\n * @returns {function} The useStore hook.\n */\n\nexport const createViewConfigStore = () => create(set => ({\n  // State:\n  // The viewConfig is an object which must conform to the schema\n  // found in src/schemas/config.schema.json.\n  viewConfig: null,\n  // The loaders object is a mapping from dataset ID to\n  // data type to loader object instance.\n  loaders: null,\n  // Reducer functions which update the state\n  // (although technically also part of state):\n  setViewConfig: viewConfig => set({\n    viewConfig\n  }),\n  setLoaders: loaders => set({\n    loaders\n  }),\n  setCoordinationValue: ({\n    parameter,\n    scope,\n    value\n  }) => set(state => ({\n    viewConfig: { ...state.viewConfig,\n      coordinationSpace: { ...state.viewConfig.coordinationSpace,\n        [parameter]: { ...state.viewConfig.coordinationSpace[parameter],\n          [scope]: value\n        }\n      }\n    }\n  })),\n  removeComponent: uid => set(state => {\n    const newLayout = state.viewConfig.layout.filter(c => c.uid !== uid);\n    return {\n      viewConfig: { ...state.viewConfig,\n        layout: newLayout\n      }\n    };\n  }),\n  changeLayout: newComponentProps => set(state => {\n    const newLayout = state.viewConfig.layout.slice();\n    newComponentProps.forEach(([i, newProps]) => {\n      newLayout[i] = { ...newLayout[i],\n        ...newProps\n      };\n    });\n    return {\n      viewConfig: { ...state.viewConfig,\n        layout: newLayout\n      }\n    };\n  })\n}));\n/**\n * Hook for getting components' layout from the view config based on\n * matching all coordination scopes.\n * @returns {Object} The components' layout.\n */\n\nexport const useComponentLayout = (component, scopes, coordinationScopes) => useViewConfigStore(state => state.viewConfig.layout.filter(l => l.component === component).filter(l => scopes.every(scope => l.coordinationScopes[scope] === coordinationScopes[scope])));\n/**\n * The useAuxiliaryStore hook is initialized via the zustand\n * create() function, which sets up both the state variables\n * and the reducer-type functions.\n * Reference: https://github.com/react-spring/zustand\n * It is meant to be used for non-viewconfig-based coordination between components.\n * For example, as currently happens, the layer controller can coordinate\n * on-load callbacks with spatial view based on whether or not they are\n * coordinated via `spatialImageLayer` - the callbacks are not part of the view config\n * though so they live here.\n * @returns {function} The useStore hook.\n */\n\nexport const createAuxiliaryStore = () => create(set => ({\n  auxiliaryStore: null,\n  setCoordinationValue: ({\n    parameter,\n    scope,\n    value\n  }) => set(state => ({\n    auxiliaryStore: { ...state.auxiliaryStore,\n      [parameter]: {\n        [scope]: value\n      }\n    }\n  }))\n}));\n/**\n * The hover store can be used to store global state\n * related to which component is currently hovered,\n * which is required for tooltip / crossover elements.\n * @returns {function} The useStore hook.\n */\n\nconst useHoverStore = create(set => ({\n  // Components may need to know if they are the \"hover source\"\n  // for tooltip interactions. This value should be a unique\n  // component ID, such as its index in the view config layout.\n  componentHover: null,\n  setComponentHover: componentHover => set({\n    componentHover\n  })\n}));\n/**\n * The warning store can be used to store global state\n * related to app warning messages.\n * @returns {function} The useStore hook.\n */\n\nconst useWarnStore = create(set => ({\n  // Want a global state to collect warning messages\n  // that occur anywhere in the app.\n  warning: null,\n  setWarning: warning => set({\n    warning\n  })\n}));\n/**\n * The view info store can be used to store component-level\n * viewInfo objects,\n * which are required for tooltip / crossover elements.\n * @returns {function} The useStore hook.\n */\n\nconst useViewInfoStore = create(set => ({\n  // The viewInfo object is a mapping from\n  // component IDs to component view info objects.\n  // Each view info object must have a project() function.\n  viewInfo: {},\n  setComponentViewInfo: (uuid, viewInfo) => set(state => ({\n    viewInfo: { ...state.viewInfo,\n      [uuid]: viewInfo\n    }\n  }))\n}));\n/**\n * The grid size store can be used to store a\n * counter which updates on each window or react-grid-layout\n * resize event.\n * @returns {function} The useStore hook.\n */\n\nconst useGridSizeStore = create(set => ({\n  resizeCount: {},\n  incrementResizeCount: () => set(state => ({\n    resizeCount: state.resizeCount + 1\n  }))\n}));\n/**\n * The useCoordination hook returns both the\n * values and setter functions for the coordination objects\n * in a particular coordination scope mapping.\n * This hook is intended to be used within the ___Subscriber\n * components to allow them to \"hook into\" only those coordination\n * objects and setter functions of relevance.\n * @param {string[]} parameters Array of coordination types.\n * @param {object} coordinationScopes Mapping of coordination types\n * to scope names.\n * @returns {array} Returns a tuple [values, setters]\n * where values is an object containing all coordination values,\n * and setters is an object containing all coordination setter\n * functions for the values in `values`, named with a \"set\"\n * prefix.\n */\n\nexport function useCoordination(parameters, coordinationScopes) {\n  const setCoordinationValue = useViewConfigStore(state => state.setCoordinationValue);\n  const values = useViewConfigStore(state => {\n    const {\n      coordinationSpace\n    } = state.viewConfig;\n    return fromEntries(parameters.map(parameter => {\n      if (coordinationSpace && coordinationSpace[parameter]) {\n        const value = coordinationSpace[parameter][coordinationScopes[parameter]];\n        return [parameter, value];\n      }\n\n      return [parameter, undefined];\n    }));\n  }, shallow);\n  const setters = useMemo(() => fromEntries(parameters.map(parameter => {\n    const setterName = `set${capitalize(parameter)}`;\n\n    const setterFunc = value => setCoordinationValue({\n      parameter,\n      scope: coordinationScopes[parameter],\n      value\n    });\n\n    return [setterName, setterFunc]; // eslint-disable-next-line react-hooks/exhaustive-deps\n  })), [parameters, coordinationScopes]);\n  return [values, setters];\n}\n/**\n * Get a mapping from dataset coordination scopes to dataset UIDs.\n * @param {object} coordinationScopes The coordination scope mapping object for a view.\n * @returns {object} Mapping from dataset coordination scope names to dataset UIDs.\n */\n\nexport function useDatasetUids(coordinationScopes) {\n  const parameter = CoordinationType.DATASET;\n  const datasetScopes = coordinationScopes[parameter]; // Mapping from dataset coordination scope name to dataset uid\n\n  const datasetUids = useViewConfigStore(state => {\n    const {\n      coordinationSpace\n    } = state.viewConfig; // Convert a single scope to an array of scopes to be consistent.\n\n    const datasetScopesArr = Array.isArray(datasetScopes) ? datasetScopes : [datasetScopes];\n    return fromEntries(datasetScopesArr.map(datasetScope => {\n      if (coordinationSpace && coordinationSpace[parameter]) {\n        const value = coordinationSpace[parameter][datasetScope];\n        return [datasetScope, value];\n      }\n\n      return [datasetScope, undefined];\n    }));\n  }, shallow);\n  return datasetUids;\n}\n/**\n * Use coordination values and coordination setter functions corresponding to\n * dataset-specific coordination scopes for each coordination type.\n * @param {string[]} parameters An array of coordination types supported by a view.\n * @param {object} coordinationScopes The coordination scope mapping object for a view.\n * @returns {array} [cValues, cSetters] where\n * cValues is a mapping from coordination scope name to { coordinationType: coordinationValue },\n * and cSetters is a mapping from coordination scope name to { setCoordinationType }\n * setter functions.\n */\n\nexport function useMultiDatasetCoordination(parameters, coordinationScopes) {\n  const setCoordinationValue = useViewConfigStore(state => state.setCoordinationValue);\n  const datasetScopes = coordinationScopes[CoordinationType.DATASET]; // Convert a single scope to an array of scopes to be consistent.\n\n  const datasetScopesArr = Array.isArray(datasetScopes) ? datasetScopes : [datasetScopes];\n  const values = useViewConfigStore(state => {\n    const {\n      coordinationSpace\n    } = state.viewConfig;\n    return fromEntries(datasetScopesArr.map(datasetScope => {\n      const datasetValues = fromEntries(parameters.map(parameter => {\n        if (coordinationSpace && coordinationSpace[parameter]) {\n          let value;\n          const parameterSpace = coordinationSpace[parameter];\n          const parameterScope = coordinationScopes[parameter];\n\n          if (typeof parameterScope === 'object') {\n            value = parameterSpace[parameterScope[datasetScope]];\n          } else if (typeof parameterScope === 'string') {\n            value = parameterSpace[parameterScope];\n          } else {\n            console.error(`coordination scope for ${parameter} must be of type string or object.`);\n          }\n\n          return [parameter, value];\n        }\n\n        return [parameter, undefined];\n      }));\n      return [datasetScope, datasetValues];\n    }));\n  }, shallow);\n  const setters = useMemo(() => fromEntries(datasetScopesArr.map(datasetScope => {\n    const datasetSetters = fromEntries(parameters.map(parameter => {\n      const setterName = `set${capitalize(parameter)}`;\n      let setterFunc;\n      const parameterScope = coordinationScopes[parameter];\n\n      if (typeof parameterScope === 'object') {\n        setterFunc = value => setCoordinationValue({\n          parameter,\n          scope: parameterScope[datasetScope],\n          value\n        });\n      } else if (typeof parameterScope === 'string') {\n        setterFunc = value => setCoordinationValue({\n          parameter,\n          scope: parameterScope,\n          value\n        });\n      } else {\n        console.error(`coordination scope for ${parameter} must be of type string or object.`);\n      }\n\n      return [setterName, setterFunc];\n    }));\n    return [datasetScope, datasetSetters]; // eslint-disable-next-line react-hooks/exhaustive-deps\n  })), [parameters, coordinationScopes]);\n  return [values, setters];\n}\nconst AUXILIARY_COORDINATION_TYPES_MAP = {\n  spatialImageLayer: ['rasterLayersCallbacks', 'areLoadingRasterChannnels']\n};\n/**\n * The maps the coordination types of incoming scopes to new types\n * for the auxiliary store.\n * @param {object} coordinationScopes Mapping of coordination types\n * to scope names.\n * @returns {object} Mapping of coordination types\n * to new scope names for the auxiliary store.\n */\n\nconst mapCoordinationScopes = coordinationScopes => {\n  const newCoordinationScopes = {};\n  Object.keys(coordinationScopes).forEach(key => {\n    const newCoordinationTypes = AUXILIARY_COORDINATION_TYPES_MAP[key] || [];\n    newCoordinationTypes.forEach(coordinationType => {\n      newCoordinationScopes[coordinationType || key] = coordinationScopes[key];\n    });\n  });\n  return newCoordinationScopes;\n};\n\nconst mapParameters = parameters => parameters.map(parameter => AUXILIARY_COORDINATION_TYPES_MAP[parameter]).filter(Boolean).flat();\n/**\n * The useAuxiliaryCoordination hook returns both the\n * values and setter functions for the auxiliary coordination objects\n * in a particular coordination scope mapping.\n * This hook is intended to be used within the ___Subscriber\n * components to allow them to \"hook into\" only those auxiliary coordination\n * objects and setter functions of relevance, for example \"on load\" callbacks.\n * @param {string[]} parameters Array of coordination types.\n * @param {object} coordinationScopes Mapping of coordination types\n * to scope names.\n * @returns {array} Returns a tuple [values, setters]\n * where values is an object containing all coordination values,\n * and setters is an object containing all coordination setter\n * functions for the values in `values`, named with a \"set\"\n * prefix.\n */\n\n\nexport function useAuxiliaryCoordination(parameters, coordinationScopes) {\n  const setCoordinationValue = useAuxiliaryStore(state => state.setCoordinationValue);\n  const mappedCoordinationScopes = mapCoordinationScopes(coordinationScopes);\n  const mappedParameters = mapParameters(parameters);\n  const values = useAuxiliaryStore(state => {\n    const {\n      auxiliaryStore\n    } = state;\n    return fromEntries(mappedParameters.map(parameter => {\n      if (auxiliaryStore && auxiliaryStore[parameter]) {\n        const value = auxiliaryStore[parameter][mappedCoordinationScopes[parameter]];\n        return [parameter, value];\n      }\n\n      return [parameter, undefined];\n    }));\n  }, shallow);\n  const setters = useMemo(() => fromEntries(mappedParameters.map(parameter => {\n    const setterName = `set${capitalize(parameter)}`;\n\n    const setterFunc = value => setCoordinationValue({\n      parameter,\n      scope: mappedCoordinationScopes[parameter],\n      value\n    });\n\n    return [setterName, setterFunc]; // eslint-disable-next-line react-hooks/exhaustive-deps\n  })), [parameters, coordinationScopes]);\n  return [values, setters];\n}\n/**\n * Obtain the loaders object from\n * the global app state.\n * @returns {object} The loaders object\n * in the `useViewConfigStore` store.\n */\n\nexport function useLoaders() {\n  return useViewConfigStore(state => state.loaders);\n}\n/**\n * Obtain the view config layout array from\n * the global app state.\n * @returns {object[]} The layout array\n * in the `useViewConfigStore` store.\n */\n\nexport function useLayout() {\n  return useViewConfigStore(state => {\n    var _state$viewConfig;\n\n    return (_state$viewConfig = state.viewConfig) === null || _state$viewConfig === void 0 ? void 0 : _state$viewConfig.layout;\n  });\n}\n/**\n * Obtain the component removal function from\n * the global app state.\n * @returns {function} The remove component function\n * in the `useViewInfoStore` store.\n */\n\nexport function useRemoveComponent() {\n  return useViewConfigStore(state => state.removeComponent);\n}\n/**\n * Obtain the component prop setter function from\n * the global app state.\n * @returns {function} The set component props function\n * in the `useViewInfoStore` store.\n */\n\nexport function useChangeLayout() {\n  return useViewConfigStore(state => state.changeLayout);\n}\n/**\n * Obtain the loaders setter function from\n * the global app state.\n * @returns {function} The loaders setter function\n * in the `useViewConfigStore` store.\n */\n\nexport function useSetLoaders() {\n  return useViewConfigStore(state => state.setLoaders);\n}\n/**\n * Obtain the view config setter function from\n * the global app state.\n * @returns {function} The view config setter function\n * in the `useViewConfigStore` store.\n */\n\nexport function useSetViewConfig(viewConfigStoreApi) {\n  const setViewConfigRef = useRef(viewConfigStoreApi.getState().setViewConfig);\n  const setViewConfig = setViewConfigRef.current;\n  return setViewConfig;\n}\n/**\n * Obtain the component hover value from\n * the global app state.\n * @returns {number} The hovered component ID\n * in the `useHoverStore` store.\n */\n\nexport function useComponentHover() {\n  return useHoverStore(state => state.componentHover);\n}\n/**\n * Obtain the component hover setter function from\n * the global app state.\n * @returns {function} The component hover setter function\n * in the `useHoverStore` store.\n */\n\nexport function useSetComponentHover() {\n  return useHoverStore(state => state.setComponentHover);\n}\n/**\n * Obtain the warning message from\n * the global app state.\n * @returns {string} The warning message\n * in the `useWarnStore` store.\n */\n\nexport function useWarning() {\n  return useWarnStore(state => state.warning);\n}\n/**\n * Obtain the warning setter function from\n * the global app state.\n * @returns {function} The warning setter function\n * in the `useWarnStore` store.\n */\n\nexport function useSetWarning() {\n  return useWarnStore(state => state.setWarning);\n}\n/**\n * Obtain the component view info value from\n * the global app state.\n * @returns {object} The view info object for the component\n * in the `useViewInfoStore` store.\n */\n\nexport function useComponentViewInfo(uuid) {\n  return useViewInfoStore(useCallback(state => state.viewInfo[uuid], [uuid]));\n}\n/**\n * Obtain the component view info setter function from\n * the global app state.\n * @returns {function} The component view info setter function\n * in the `useViewInfoStore` store.\n */\n\nexport function useSetComponentViewInfo(uuid) {\n  const setViewInfoRef = useRef(useViewInfoStore.getState().setComponentViewInfo);\n\n  const setComponentViewInfo = viewInfo => setViewInfoRef.current(uuid, viewInfo);\n\n  return setComponentViewInfo;\n}\n/**\n * Obtain the grid resize count value\n * from the global app state.\n * @returns {number} The grid resize increment value.\n */\n\nexport function useGridResize() {\n  return useGridSizeStore(state => state.resizeCount);\n}\n/**\n * Obtain the grid resize count increment function\n * from the global app state.\n * @returns {function} The grid resize count increment\n * function.\n */\n\nexport function useEmitGridResize() {\n  return useGridSizeStore(state => state.incrementResizeCount);\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/app/state/hooks.js"],"names":["useRef","useCallback","useMemo","create","createContext","shallow","CoordinationType","fromEntries","capitalize","Provider","ViewConfigProviderLocal","useStore","useViewConfigStoreLocal","useStoreApi","useViewConfigStoreApiLocal","ViewConfigProvider","useViewConfigStore","useViewConfigStoreApi","AuxiliaryProviderLocal","useAuxiliaryStoreLocal","AuxiliaryProvider","useAuxiliaryStore","createViewConfigStore","set","viewConfig","loaders","setViewConfig","setLoaders","setCoordinationValue","parameter","scope","value","state","coordinationSpace","removeComponent","uid","newLayout","layout","filter","c","changeLayout","newComponentProps","slice","forEach","i","newProps","useComponentLayout","component","scopes","coordinationScopes","l","every","createAuxiliaryStore","auxiliaryStore","useHoverStore","componentHover","setComponentHover","useWarnStore","warning","setWarning","useViewInfoStore","viewInfo","setComponentViewInfo","uuid","useGridSizeStore","resizeCount","incrementResizeCount","useCoordination","parameters","values","map","undefined","setters","setterName","setterFunc","useDatasetUids","DATASET","datasetScopes","datasetUids","datasetScopesArr","Array","isArray","datasetScope","useMultiDatasetCoordination","datasetValues","parameterSpace","parameterScope","console","error","datasetSetters","AUXILIARY_COORDINATION_TYPES_MAP","spatialImageLayer","mapCoordinationScopes","newCoordinationScopes","Object","keys","key","newCoordinationTypes","coordinationType","mapParameters","Boolean","flat","useAuxiliaryCoordination","mappedCoordinationScopes","mappedParameters","useLoaders","useLayout","useRemoveComponent","useChangeLayout","useSetLoaders","useSetViewConfig","viewConfigStoreApi","setViewConfigRef","getState","current","useComponentHover","useSetComponentHover","useWarning","useSetWarning","useComponentViewInfo","useSetComponentViewInfo","setViewInfoRef","useGridResize","useEmitGridResize"],"mappings":"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","sourcesContent":["import { useRef, useCallback, useMemo } from 'react';\nimport create from 'zustand';\nimport createContext from 'zustand/context';\nimport shallow from 'zustand/shallow';\nimport { CoordinationType } from '../constants';\nimport { fromEntries, capitalize } from '../../utils';\n\n// Reference: https://github.com/pmndrs/zustand#react-context\n// Reference: https://github.com/pmndrs/zustand/blob/e47ea03/tests/context.test.tsx#L60\nconst {\n  Provider: ViewConfigProviderLocal,\n  useStore: useViewConfigStoreLocal,\n  useStoreApi: useViewConfigStoreApiLocal,\n} = createContext();\n\nexport const ViewConfigProvider = ViewConfigProviderLocal;\nexport const useViewConfigStore = useViewConfigStoreLocal;\nexport const useViewConfigStoreApi = useViewConfigStoreApiLocal;\n\nconst {\n  Provider: AuxiliaryProviderLocal,\n  useStore: useAuxiliaryStoreLocal,\n} = createContext();\n\nexport const AuxiliaryProvider = AuxiliaryProviderLocal;\nexport const useAuxiliaryStore = useAuxiliaryStoreLocal;\n\n\n/**\n * The useViewConfigStore hook is initialized via the zustand\n * create() function, which sets up both the state variables\n * and the reducer-type functions.\n * Reference: https://github.com/react-spring/zustand\n * @returns {function} The useStore hook.\n */\nexport const createViewConfigStore = () => create(set => ({\n  // State:\n  // The viewConfig is an object which must conform to the schema\n  // found in src/schemas/config.schema.json.\n  viewConfig: null,\n  // The loaders object is a mapping from dataset ID to\n  // data type to loader object instance.\n  loaders: null,\n  // Reducer functions which update the state\n  // (although technically also part of state):\n  setViewConfig: viewConfig => set({ viewConfig }),\n  setLoaders: loaders => set({ loaders }),\n  setCoordinationValue: ({ parameter, scope, value }) => set(state => ({\n    viewConfig: {\n      ...state.viewConfig,\n      coordinationSpace: {\n        ...state.viewConfig.coordinationSpace,\n        [parameter]: {\n          ...state.viewConfig.coordinationSpace[parameter],\n          [scope]: value,\n        },\n      },\n    },\n  })),\n  removeComponent: uid => set((state) => {\n    const newLayout = state.viewConfig.layout.filter(c => c.uid !== uid);\n    return {\n      viewConfig: {\n        ...state.viewConfig,\n        layout: newLayout,\n      },\n    };\n  }),\n  changeLayout: newComponentProps => set((state) => {\n    const newLayout = state.viewConfig.layout.slice();\n    newComponentProps.forEach(([i, newProps]) => {\n      newLayout[i] = {\n        ...newLayout[i],\n        ...newProps,\n      };\n    });\n    return {\n      viewConfig: {\n        ...state.viewConfig,\n        layout: newLayout,\n      },\n    };\n  }),\n}));\n\n/**\n * Hook for getting components' layout from the view config based on\n * matching all coordination scopes.\n * @returns {Object} The components' layout.\n */\nexport const useComponentLayout = (component, scopes, coordinationScopes) => useViewConfigStore(\n  state => state.viewConfig.layout.filter(l => l.component === component).filter(\n    l => scopes.every(scope => l.coordinationScopes[scope]\n          === coordinationScopes[scope]),\n  ),\n);\n\n/**\n * The useAuxiliaryStore hook is initialized via the zustand\n * create() function, which sets up both the state variables\n * and the reducer-type functions.\n * Reference: https://github.com/react-spring/zustand\n * It is meant to be used for non-viewconfig-based coordination between components.\n * For example, as currently happens, the layer controller can coordinate\n * on-load callbacks with spatial view based on whether or not they are\n * coordinated via `spatialImageLayer` - the callbacks are not part of the view config\n * though so they live here.\n * @returns {function} The useStore hook.\n */\nexport const createAuxiliaryStore = () => create(set => ({\n  auxiliaryStore: null,\n  setCoordinationValue: ({ parameter, scope, value }) => set(state => ({\n    auxiliaryStore: {\n      ...state.auxiliaryStore,\n      [parameter]: {\n        [scope]: value,\n      },\n    },\n  })),\n}));\n\n/**\n * The hover store can be used to store global state\n * related to which component is currently hovered,\n * which is required for tooltip / crossover elements.\n * @returns {function} The useStore hook.\n */\nconst useHoverStore = create(set => ({\n  // Components may need to know if they are the \"hover source\"\n  // for tooltip interactions. This value should be a unique\n  // component ID, such as its index in the view config layout.\n  componentHover: null,\n  setComponentHover: componentHover => set({ componentHover }),\n}));\n\n/**\n * The warning store can be used to store global state\n * related to app warning messages.\n * @returns {function} The useStore hook.\n */\nconst useWarnStore = create(set => ({\n  // Want a global state to collect warning messages\n  // that occur anywhere in the app.\n  warning: null,\n  setWarning: warning => set({ warning }),\n}));\n\n/**\n * The view info store can be used to store component-level\n * viewInfo objects,\n * which are required for tooltip / crossover elements.\n * @returns {function} The useStore hook.\n */\nconst useViewInfoStore = create(set => ({\n  // The viewInfo object is a mapping from\n  // component IDs to component view info objects.\n  // Each view info object must have a project() function.\n  viewInfo: {},\n  setComponentViewInfo: (uuid, viewInfo) => set(state => ({\n    viewInfo: {\n      ...state.viewInfo,\n      [uuid]: viewInfo,\n    },\n  })),\n}));\n\n/**\n * The grid size store can be used to store a\n * counter which updates on each window or react-grid-layout\n * resize event.\n * @returns {function} The useStore hook.\n */\nconst useGridSizeStore = create(set => ({\n  resizeCount: {},\n  incrementResizeCount: () => set(state => ({\n    resizeCount: state.resizeCount + 1,\n  })),\n}));\n\n/**\n * The useCoordination hook returns both the\n * values and setter functions for the coordination objects\n * in a particular coordination scope mapping.\n * This hook is intended to be used within the ___Subscriber\n * components to allow them to \"hook into\" only those coordination\n * objects and setter functions of relevance.\n * @param {string[]} parameters Array of coordination types.\n * @param {object} coordinationScopes Mapping of coordination types\n * to scope names.\n * @returns {array} Returns a tuple [values, setters]\n * where values is an object containing all coordination values,\n * and setters is an object containing all coordination setter\n * functions for the values in `values`, named with a \"set\"\n * prefix.\n */\nexport function useCoordination(parameters, coordinationScopes) {\n  const setCoordinationValue = useViewConfigStore(state => state.setCoordinationValue);\n\n  const values = useViewConfigStore((state) => {\n    const { coordinationSpace } = state.viewConfig;\n    return fromEntries(parameters.map((parameter) => {\n      if (coordinationSpace && coordinationSpace[parameter]) {\n        const value = coordinationSpace[parameter][coordinationScopes[parameter]];\n        return [parameter, value];\n      }\n      return [parameter, undefined];\n    }));\n  }, shallow);\n\n  const setters = useMemo(() => fromEntries(parameters.map((parameter) => {\n    const setterName = `set${capitalize(parameter)}`;\n    const setterFunc = value => setCoordinationValue({\n      parameter,\n      scope: coordinationScopes[parameter],\n      value,\n    });\n    return [setterName, setterFunc];\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  })), [parameters, coordinationScopes]);\n\n  return [values, setters];\n}\n\n/**\n * Get a mapping from dataset coordination scopes to dataset UIDs.\n * @param {object} coordinationScopes The coordination scope mapping object for a view.\n * @returns {object} Mapping from dataset coordination scope names to dataset UIDs.\n */\nexport function useDatasetUids(coordinationScopes) {\n  const parameter = CoordinationType.DATASET;\n  const datasetScopes = coordinationScopes[parameter];\n\n  // Mapping from dataset coordination scope name to dataset uid\n  const datasetUids = useViewConfigStore((state) => {\n    const { coordinationSpace } = state.viewConfig;\n    // Convert a single scope to an array of scopes to be consistent.\n    const datasetScopesArr = Array.isArray(datasetScopes) ? datasetScopes : [datasetScopes];\n    return fromEntries(datasetScopesArr.map((datasetScope) => {\n      if (coordinationSpace && coordinationSpace[parameter]) {\n        const value = coordinationSpace[parameter][datasetScope];\n        return [datasetScope, value];\n      }\n      return [datasetScope, undefined];\n    }));\n  }, shallow);\n\n  return datasetUids;\n}\n\n/**\n * Use coordination values and coordination setter functions corresponding to\n * dataset-specific coordination scopes for each coordination type.\n * @param {string[]} parameters An array of coordination types supported by a view.\n * @param {object} coordinationScopes The coordination scope mapping object for a view.\n * @returns {array} [cValues, cSetters] where\n * cValues is a mapping from coordination scope name to { coordinationType: coordinationValue },\n * and cSetters is a mapping from coordination scope name to { setCoordinationType }\n * setter functions.\n */\nexport function useMultiDatasetCoordination(parameters, coordinationScopes) {\n  const setCoordinationValue = useViewConfigStore(state => state.setCoordinationValue);\n\n  const datasetScopes = coordinationScopes[CoordinationType.DATASET];\n\n  // Convert a single scope to an array of scopes to be consistent.\n  const datasetScopesArr = Array.isArray(datasetScopes) ? datasetScopes : [datasetScopes];\n\n  const values = useViewConfigStore((state) => {\n    const { coordinationSpace } = state.viewConfig;\n    return fromEntries(datasetScopesArr.map((datasetScope) => {\n      const datasetValues = fromEntries(parameters.map((parameter) => {\n        if (coordinationSpace && coordinationSpace[parameter]) {\n          let value;\n          const parameterSpace = coordinationSpace[parameter];\n          const parameterScope = coordinationScopes[parameter];\n          if (typeof parameterScope === 'object') {\n            value = parameterSpace[parameterScope[datasetScope]];\n          } else if (typeof parameterScope === 'string') {\n            value = parameterSpace[parameterScope];\n          } else {\n            console.error(`coordination scope for ${parameter} must be of type string or object.`);\n          }\n          return [parameter, value];\n        }\n        return [parameter, undefined];\n      }));\n      return [datasetScope, datasetValues];\n    }));\n  }, shallow);\n\n  const setters = useMemo(() => fromEntries(datasetScopesArr.map((datasetScope) => {\n    const datasetSetters = fromEntries(parameters.map((parameter) => {\n      const setterName = `set${capitalize(parameter)}`;\n      let setterFunc;\n      const parameterScope = coordinationScopes[parameter];\n      if (typeof parameterScope === 'object') {\n        setterFunc = value => setCoordinationValue({\n          parameter,\n          scope: parameterScope[datasetScope],\n          value,\n        });\n      } else if (typeof parameterScope === 'string') {\n        setterFunc = value => setCoordinationValue({\n          parameter,\n          scope: parameterScope,\n          value,\n        });\n      } else {\n        console.error(`coordination scope for ${parameter} must be of type string or object.`);\n      }\n      return [setterName, setterFunc];\n    }));\n    return [datasetScope, datasetSetters];\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  })), [parameters, coordinationScopes]);\n\n  return [values, setters];\n}\n\nconst AUXILIARY_COORDINATION_TYPES_MAP = {\n  spatialImageLayer: ['rasterLayersCallbacks', 'areLoadingRasterChannnels'],\n};\n\n/**\n * The maps the coordination types of incoming scopes to new types\n * for the auxiliary store.\n * @param {object} coordinationScopes Mapping of coordination types\n * to scope names.\n * @returns {object} Mapping of coordination types\n * to new scope names for the auxiliary store.\n */\nconst mapCoordinationScopes = (coordinationScopes) => {\n  const newCoordinationScopes = {};\n  Object.keys(coordinationScopes).forEach((key) => {\n    const newCoordinationTypes = AUXILIARY_COORDINATION_TYPES_MAP[key] || [];\n    newCoordinationTypes.forEach((coordinationType) => {\n      newCoordinationScopes[coordinationType || key] = coordinationScopes[key];\n    });\n  });\n  return newCoordinationScopes;\n};\n\nconst mapParameters = parameters => parameters\n  .map(parameter => AUXILIARY_COORDINATION_TYPES_MAP[parameter]).filter(Boolean).flat();\n\n/**\n * The useAuxiliaryCoordination hook returns both the\n * values and setter functions for the auxiliary coordination objects\n * in a particular coordination scope mapping.\n * This hook is intended to be used within the ___Subscriber\n * components to allow them to \"hook into\" only those auxiliary coordination\n * objects and setter functions of relevance, for example \"on load\" callbacks.\n * @param {string[]} parameters Array of coordination types.\n * @param {object} coordinationScopes Mapping of coordination types\n * to scope names.\n * @returns {array} Returns a tuple [values, setters]\n * where values is an object containing all coordination values,\n * and setters is an object containing all coordination setter\n * functions for the values in `values`, named with a \"set\"\n * prefix.\n */\nexport function useAuxiliaryCoordination(parameters, coordinationScopes) {\n  const setCoordinationValue = useAuxiliaryStore(state => state.setCoordinationValue);\n  const mappedCoordinationScopes = mapCoordinationScopes(coordinationScopes);\n  const mappedParameters = mapParameters(parameters);\n  const values = useAuxiliaryStore((state) => {\n    const { auxiliaryStore } = state;\n    return fromEntries(mappedParameters.map((parameter) => {\n      if (auxiliaryStore && auxiliaryStore[parameter]) {\n        const value = auxiliaryStore[parameter][mappedCoordinationScopes[parameter]];\n        return [parameter, value];\n      }\n      return [parameter, undefined];\n    }));\n  }, shallow);\n  const setters = useMemo(() => fromEntries(mappedParameters.map((parameter) => {\n    const setterName = `set${capitalize(parameter)}`;\n    const setterFunc = value => setCoordinationValue({\n      parameter,\n      scope: mappedCoordinationScopes[parameter],\n      value,\n    });\n    return [setterName, setterFunc];\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  })), [parameters, coordinationScopes]);\n\n  return [values, setters];\n}\n\n/**\n * Obtain the loaders object from\n * the global app state.\n * @returns {object} The loaders object\n * in the `useViewConfigStore` store.\n */\nexport function useLoaders() {\n  return useViewConfigStore(state => state.loaders);\n}\n\n/**\n * Obtain the view config layout array from\n * the global app state.\n * @returns {object[]} The layout array\n * in the `useViewConfigStore` store.\n */\nexport function useLayout() {\n  return useViewConfigStore(state => state.viewConfig?.layout);\n}\n\n/**\n * Obtain the component removal function from\n * the global app state.\n * @returns {function} The remove component function\n * in the `useViewInfoStore` store.\n */\nexport function useRemoveComponent() {\n  return useViewConfigStore(state => state.removeComponent);\n}\n\n/**\n * Obtain the component prop setter function from\n * the global app state.\n * @returns {function} The set component props function\n * in the `useViewInfoStore` store.\n */\nexport function useChangeLayout() {\n  return useViewConfigStore(state => state.changeLayout);\n}\n\n/**\n * Obtain the loaders setter function from\n * the global app state.\n * @returns {function} The loaders setter function\n * in the `useViewConfigStore` store.\n */\nexport function useSetLoaders() {\n  return useViewConfigStore(state => state.setLoaders);\n}\n\n/**\n * Obtain the view config setter function from\n * the global app state.\n * @returns {function} The view config setter function\n * in the `useViewConfigStore` store.\n */\nexport function useSetViewConfig(viewConfigStoreApi) {\n  const setViewConfigRef = useRef(viewConfigStoreApi.getState().setViewConfig);\n  const setViewConfig = setViewConfigRef.current;\n  return setViewConfig;\n}\n\n/**\n * Obtain the component hover value from\n * the global app state.\n * @returns {number} The hovered component ID\n * in the `useHoverStore` store.\n */\nexport function useComponentHover() {\n  return useHoverStore(state => state.componentHover);\n}\n\n/**\n * Obtain the component hover setter function from\n * the global app state.\n * @returns {function} The component hover setter function\n * in the `useHoverStore` store.\n */\nexport function useSetComponentHover() {\n  return useHoverStore(state => state.setComponentHover);\n}\n\n/**\n * Obtain the warning message from\n * the global app state.\n * @returns {string} The warning message\n * in the `useWarnStore` store.\n */\nexport function useWarning() {\n  return useWarnStore(state => state.warning);\n}\n\n/**\n * Obtain the warning setter function from\n * the global app state.\n * @returns {function} The warning setter function\n * in the `useWarnStore` store.\n */\nexport function useSetWarning() {\n  return useWarnStore(state => state.setWarning);\n}\n\n/**\n * Obtain the component view info value from\n * the global app state.\n * @returns {object} The view info object for the component\n * in the `useViewInfoStore` store.\n */\nexport function useComponentViewInfo(uuid) {\n  return useViewInfoStore(useCallback(state => state.viewInfo[uuid], [uuid]));\n}\n\n/**\n * Obtain the component view info setter function from\n * the global app state.\n * @returns {function} The component view info setter function\n * in the `useViewInfoStore` store.\n */\nexport function useSetComponentViewInfo(uuid) {\n  const setViewInfoRef = useRef(useViewInfoStore.getState().setComponentViewInfo);\n  const setComponentViewInfo = viewInfo => setViewInfoRef.current(uuid, viewInfo);\n  return setComponentViewInfo;\n}\n\n/**\n * Obtain the grid resize count value\n * from the global app state.\n * @returns {number} The grid resize increment value.\n */\nexport function useGridResize() {\n  return useGridSizeStore(state => state.resizeCount);\n}\n\n/**\n * Obtain the grid resize count increment function\n * from the global app state.\n * @returns {function} The grid resize count increment\n * function.\n */\nexport function useEmitGridResize() {\n  return useGridSizeStore(state => state.incrementResizeCount);\n}\n"]},"metadata":{},"sourceType":"module"}