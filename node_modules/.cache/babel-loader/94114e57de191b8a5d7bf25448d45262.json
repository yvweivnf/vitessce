{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams } from '../common';\nimport { arc } from './arc';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nconst markCompiler = {\n  arc,\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    const details = pathGroupingFields(model.mark, model.encoding);\n\n    if (details.length > 0) {\n      return getPathGroups(model, details);\n    } // otherwise use standard mark groups\n\n  } else if (model.mark === BAR) {\n    const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop => getMarkPropOrConfig(prop, model.markDef, model.config));\n\n    if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n      return getGroupsForStackedBarWithCornerRadius(model);\n    }\n  }\n\n  return getMarkGroup(model);\n}\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction getPathGroups(model, details) {\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n  return [{\n    name: model.getName('pathgroup'),\n    type: 'group',\n    from: {\n      facet: {\n        name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n        data: model.requestDataName(DataSourceType.Main),\n        groupby: details\n      }\n    },\n    encode: {\n      update: {\n        width: {\n          field: {\n            group: 'width'\n          }\n        },\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      }\n    },\n    // With subfacet for line/area group, need to use faceted data from above.\n    marks: getMarkGroup(model, {\n      fromPrefix: FACETED_PATH_PREFIX\n    })\n  }];\n}\n\nconst STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\n\nfunction getGroupsForStackedBarWithCornerRadius(model) {\n  // Generate the mark\n  const [mark] = getMarkGroup(model, {\n    fromPrefix: STACK_GROUP_PREFIX\n  }); // Get the scale for the stacked field\n\n  const fieldScale = model.scaleName(model.stack.fieldChannel);\n\n  const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt); // Find the min/max of the pixel value on the stacked direction\n\n\n  const stackFieldGroup = (func, expr) => {\n    const vgFieldMinMax = [stackField({\n      prefix: 'min',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'min',\n      suffix: 'end',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'end',\n      expr\n    })];\n    return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n  };\n\n  let groupUpdate;\n  let innerGroupUpdate; // Build the encoding for group and an inner group\n\n  if (model.stack.fieldChannel === 'x') {\n    // Move cornerRadius, y/yc/y2/height properties to group\n    // Group x/x2 should be the min/max of the marks within\n    groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS])), {\n      x: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      x2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    }); // Inner group should revert the x translation, and pass height through\n\n    innerGroupUpdate = {\n      x: {\n        field: {\n          group: 'x'\n        },\n        mult: -1\n      },\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    }; // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n    // This is why size encoding is not supported yet\n\n    mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['y', 'yc', 'y2'])), {\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    });\n  } else {\n    groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['x', 'xc', 'x2', 'width'])), {\n      y: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      y2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    });\n    innerGroupUpdate = {\n      y: {\n        field: {\n          group: 'y'\n        },\n        mult: -1\n      },\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    };\n    mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['x', 'xc', 'x2'])), {\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    });\n  } // Deal with cornerRadius properties\n\n\n  for (const key of VG_CORNERRADIUS_CHANNELS) {\n    const configValue = getMarkConfig(key, model.markDef, model.config); // Move from mark to group\n\n    if (mark.encode.update[key]) {\n      groupUpdate[key] = mark.encode.update[key];\n      delete mark.encode.update[key];\n    } else if (configValue) {\n      groupUpdate[key] = signalOrValueRef(configValue);\n    } // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n\n\n    if (configValue) {\n      mark.encode.update[key] = {\n        value: 0\n      };\n    }\n  }\n\n  const groupby = [];\n\n  if (model.stack.groupbyChannel) {\n    // For bin and time unit, we have to add bin/timeunit -end channels.\n    const groupByField = model.fieldDef(model.stack.groupbyChannel);\n    const field = vgField(groupByField);\n\n    if (field) {\n      groupby.push(field);\n    }\n\n    if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {\n      groupby.push(vgField(groupByField, {\n        binSuffix: 'end'\n      }));\n    }\n  }\n\n  const strokeProperties = ['stroke', 'strokeWidth', 'strokeJoin', 'strokeCap', 'strokeDash', 'strokeDashOffset', 'strokeMiterLimit', 'strokeOpacity']; // Generate stroke properties for the group\n\n  groupUpdate = strokeProperties.reduce((encode, prop) => {\n    if (mark.encode.update[prop]) {\n      return Object.assign(Object.assign({}, encode), {\n        [prop]: mark.encode.update[prop]\n      });\n    } else {\n      const configValue = getMarkConfig(prop, model.markDef, model.config);\n\n      if (configValue !== undefined) {\n        return Object.assign(Object.assign({}, encode), {\n          [prop]: signalOrValueRef(configValue)\n        });\n      } else {\n        return encode;\n      }\n    }\n  }, groupUpdate); // Apply strokeForeground and strokeOffset if stroke is used\n\n  if (groupUpdate.stroke) {\n    groupUpdate.strokeForeground = {\n      value: true\n    };\n    groupUpdate.strokeOffset = {\n      value: 0\n    };\n  }\n\n  return [{\n    type: 'group',\n    from: {\n      facet: {\n        data: model.requestDataName(DataSourceType.Main),\n        name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n        groupby,\n        aggregate: {\n          fields: [stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'end'\n          }), stackField({\n            suffix: 'end'\n          })],\n          ops: ['min', 'max', 'min', 'max']\n        }\n      }\n    },\n    encode: {\n      update: groupUpdate\n    },\n    marks: [{\n      type: 'group',\n      encode: {\n        update: innerGroupUpdate\n      },\n      marks: [mark]\n    }]\n  }];\n}\n\nexport function getSort(model) {\n  var _a;\n\n  const {\n    encoding,\n    stack,\n    mark,\n    markDef,\n    config\n  } = model;\n  const order = encoding.order;\n\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {\n            prefix: dimensionChannel,\n            suffix: 'sort_index',\n            expr: 'datum'\n          })\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }, {\n            expr: 'datum'\n          })\n        };\n      } else if (isSortByEncoding(s)) {\n        const fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {\n            expr: 'datum'\n          }),\n          order: s.order\n        };\n      } else if (s === null) {\n        return undefined;\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n  return undefined;\n}\n\nfunction getMarkGroup(model, opt = {\n  fromPrefix: ''\n}) {\n  const {\n    mark,\n    markDef,\n    encoding,\n    config\n  } = model;\n  const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(markDef);\n  const key = encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n  const aria = getMarkPropOrConfig('aria', markDef, config);\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark\n  }, clip ? {\n    clip: true\n  } : {}), style ? {\n    style\n  } : {}), key ? {\n    key: key.field\n  } : {}), sort ? {\n    sort\n  } : {}), interactive ? interactive : {}), aria === false ? {\n    aria\n  } : {}), {\n    from: {\n      data: opt.fromPrefix + model.requestDataName(DataSourceType.Main)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    }\n  }), postEncodingTransform ? {\n    transform: postEncodingTransform\n  } : {})];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\n\n\nfunction scaleClip(model) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return xScale && xScale.get('selectionExtent') || yScale && yScale.get('selectionExtent') ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\n\n\nfunction projectionClip(model) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\n\n\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n\n  return parentCount ? {\n    interactive: unitCount > 0 || !!model.encoding.tooltip\n  } : null;\n}","map":{"version":3,"sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams } from '../common';\nimport { arc } from './arc';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nconst markCompiler = {\n    arc,\n    area,\n    bar,\n    circle,\n    geoshape,\n    image,\n    line,\n    point,\n    rect,\n    rule,\n    square,\n    text,\n    tick,\n    trail\n};\nexport function parseMarkGroups(model) {\n    if (contains([LINE, AREA, TRAIL], model.mark)) {\n        const details = pathGroupingFields(model.mark, model.encoding);\n        if (details.length > 0) {\n            return getPathGroups(model, details);\n        }\n        // otherwise use standard mark groups\n    }\n    else if (model.mark === BAR) {\n        const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop => getMarkPropOrConfig(prop, model.markDef, model.config));\n        if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n            return getGroupsForStackedBarWithCornerRadius(model);\n        }\n    }\n    return getMarkGroup(model);\n}\nconst FACETED_PATH_PREFIX = 'faceted_path_';\nfunction getPathGroups(model, details) {\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n    return [\n        {\n            name: model.getName('pathgroup'),\n            type: 'group',\n            from: {\n                facet: {\n                    name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n                    data: model.requestDataName(DataSourceType.Main),\n                    groupby: details\n                }\n            },\n            encode: {\n                update: {\n                    width: { field: { group: 'width' } },\n                    height: { field: { group: 'height' } }\n                }\n            },\n            // With subfacet for line/area group, need to use faceted data from above.\n            marks: getMarkGroup(model, { fromPrefix: FACETED_PATH_PREFIX })\n        }\n    ];\n}\nconst STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getGroupsForStackedBarWithCornerRadius(model) {\n    // Generate the mark\n    const [mark] = getMarkGroup(model, { fromPrefix: STACK_GROUP_PREFIX });\n    // Get the scale for the stacked field\n    const fieldScale = model.scaleName(model.stack.fieldChannel);\n    const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);\n    // Find the min/max of the pixel value on the stacked direction\n    const stackFieldGroup = (func, expr) => {\n        const vgFieldMinMax = [\n            stackField({ prefix: 'min', suffix: 'start', expr }),\n            stackField({ prefix: 'max', suffix: 'start', expr }),\n            stackField({ prefix: 'min', suffix: 'end', expr }),\n            stackField({ prefix: 'max', suffix: 'end', expr })\n        ];\n        return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n    };\n    let groupUpdate;\n    let innerGroupUpdate;\n    // Build the encoding for group and an inner group\n    if (model.stack.fieldChannel === 'x') {\n        // Move cornerRadius, y/yc/y2/height properties to group\n        // Group x/x2 should be the min/max of the marks within\n        groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS])), { x: { signal: stackFieldGroup('min', 'datum') }, x2: { signal: stackFieldGroup('max', 'datum') }, clip: { value: true } });\n        // Inner group should revert the x translation, and pass height through\n        innerGroupUpdate = {\n            x: { field: { group: 'x' }, mult: -1 },\n            height: { field: { group: 'height' } }\n        };\n        // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n        // This is why size encoding is not supported yet\n        mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['y', 'yc', 'y2'])), { height: { field: { group: 'height' } } });\n    }\n    else {\n        groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['x', 'xc', 'x2', 'width'])), { y: { signal: stackFieldGroup('min', 'datum') }, y2: { signal: stackFieldGroup('max', 'datum') }, clip: { value: true } });\n        innerGroupUpdate = {\n            y: { field: { group: 'y' }, mult: -1 },\n            width: { field: { group: 'width' } }\n        };\n        mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['x', 'xc', 'x2'])), { width: { field: { group: 'width' } } });\n    }\n    // Deal with cornerRadius properties\n    for (const key of VG_CORNERRADIUS_CHANNELS) {\n        const configValue = getMarkConfig(key, model.markDef, model.config);\n        // Move from mark to group\n        if (mark.encode.update[key]) {\n            groupUpdate[key] = mark.encode.update[key];\n            delete mark.encode.update[key];\n        }\n        else if (configValue) {\n            groupUpdate[key] = signalOrValueRef(configValue);\n        }\n        // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n        if (configValue) {\n            mark.encode.update[key] = { value: 0 };\n        }\n    }\n    const groupby = [];\n    if (model.stack.groupbyChannel) {\n        // For bin and time unit, we have to add bin/timeunit -end channels.\n        const groupByField = model.fieldDef(model.stack.groupbyChannel);\n        const field = vgField(groupByField);\n        if (field) {\n            groupby.push(field);\n        }\n        if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {\n            groupby.push(vgField(groupByField, { binSuffix: 'end' }));\n        }\n    }\n    const strokeProperties = [\n        'stroke',\n        'strokeWidth',\n        'strokeJoin',\n        'strokeCap',\n        'strokeDash',\n        'strokeDashOffset',\n        'strokeMiterLimit',\n        'strokeOpacity'\n    ];\n    // Generate stroke properties for the group\n    groupUpdate = strokeProperties.reduce((encode, prop) => {\n        if (mark.encode.update[prop]) {\n            return Object.assign(Object.assign({}, encode), { [prop]: mark.encode.update[prop] });\n        }\n        else {\n            const configValue = getMarkConfig(prop, model.markDef, model.config);\n            if (configValue !== undefined) {\n                return Object.assign(Object.assign({}, encode), { [prop]: signalOrValueRef(configValue) });\n            }\n            else {\n                return encode;\n            }\n        }\n    }, groupUpdate);\n    // Apply strokeForeground and strokeOffset if stroke is used\n    if (groupUpdate.stroke) {\n        groupUpdate.strokeForeground = { value: true };\n        groupUpdate.strokeOffset = { value: 0 };\n    }\n    return [\n        {\n            type: 'group',\n            from: {\n                facet: {\n                    data: model.requestDataName(DataSourceType.Main),\n                    name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n                    groupby,\n                    aggregate: {\n                        fields: [\n                            stackField({ suffix: 'start' }),\n                            stackField({ suffix: 'start' }),\n                            stackField({ suffix: 'end' }),\n                            stackField({ suffix: 'end' })\n                        ],\n                        ops: ['min', 'max', 'min', 'max']\n                    }\n                }\n            },\n            encode: {\n                update: groupUpdate\n            },\n            marks: [\n                {\n                    type: 'group',\n                    encode: { update: innerGroupUpdate },\n                    marks: [mark]\n                }\n            ]\n        }\n    ];\n}\nexport function getSort(model) {\n    var _a;\n    const { encoding, stack, mark, markDef, config } = model;\n    const order = encoding.order;\n    if ((!isArray(order) && isValueDef(order) && isNullOrFalse(order.value)) ||\n        (!order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config)))) {\n        return undefined;\n    }\n    else if ((isArray(order) || isFieldDef(order)) && !stack) {\n        // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n        return sortParams(order, { expr: 'datum' });\n    }\n    else if (isPathMark(mark)) {\n        // For both line and area, we sort values based on dimension by default\n        const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n        const dimensionChannelDef = encoding[dimensionChannel];\n        if (isFieldDef(dimensionChannelDef)) {\n            const s = dimensionChannelDef.sort;\n            if (isArray(s)) {\n                return {\n                    field: vgField(dimensionChannelDef, { prefix: dimensionChannel, suffix: 'sort_index', expr: 'datum' })\n                };\n            }\n            else if (isSortField(s)) {\n                return {\n                    field: vgField({\n                        // FIXME: this op might not already exist?\n                        // FIXME: what if dimensionChannel (x or y) contains custom domain?\n                        aggregate: isAggregate(model.encoding) ? s.op : undefined,\n                        field: s.field\n                    }, { expr: 'datum' })\n                };\n            }\n            else if (isSortByEncoding(s)) {\n                const fieldDefToSort = model.fieldDef(s.encoding);\n                return {\n                    field: vgField(fieldDefToSort, { expr: 'datum' }),\n                    order: s.order\n                };\n            }\n            else if (s === null) {\n                return undefined;\n            }\n            else {\n                return {\n                    field: vgField(dimensionChannelDef, {\n                        // For stack with imputation, we only have bin_mid\n                        binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? 'mid' : undefined,\n                        expr: 'datum'\n                    })\n                };\n            }\n        }\n        return undefined;\n    }\n    return undefined;\n}\nfunction getMarkGroup(model, opt = { fromPrefix: '' }) {\n    const { mark, markDef, encoding, config } = model;\n    const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n    const style = getStyles(markDef);\n    const key = encoding.key;\n    const sort = getSort(model);\n    const interactive = interactiveFlag(model);\n    const aria = getMarkPropOrConfig('aria', markDef, config);\n    const postEncodingTransform = markCompiler[mark].postEncodingTransform\n        ? markCompiler[mark].postEncodingTransform(model)\n        : null;\n    return [\n        Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName('marks'), type: markCompiler[mark].vgMark }, (clip ? { clip: true } : {})), (style ? { style } : {})), (key ? { key: key.field } : {})), (sort ? { sort } : {})), (interactive ? interactive : {})), (aria === false ? { aria } : {})), { from: { data: opt.fromPrefix + model.requestDataName(DataSourceType.Main) }, encode: {\n                update: markCompiler[mark].encodeEntry(model)\n            } }), (postEncodingTransform\n            ? {\n                transform: postEncodingTransform\n            }\n            : {}))\n    ];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model) {\n    const xScale = model.getScaleComponent('x');\n    const yScale = model.getScaleComponent('y');\n    return (xScale && xScale.get('selectionExtent')) || (yScale && yScale.get('selectionExtent')) ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model) {\n    const projection = model.component.projection;\n    return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model) {\n    if (!model.component.selection)\n        return null;\n    const unitCount = keys(model.component.selection).length;\n    let parentCount = unitCount;\n    let parent = model.parent;\n    while (parent && parentCount === 0) {\n        parentCount = keys(parent.component.selection).length;\n        parent = parent.parent;\n    }\n    return parentCount\n        ? {\n            interactive: unitCount > 0 || !!model.encoding.tooltip\n        }\n        : null;\n}\n//# sourceMappingURL=mark.js.map"]},"metadata":{},"sourceType":"module"}