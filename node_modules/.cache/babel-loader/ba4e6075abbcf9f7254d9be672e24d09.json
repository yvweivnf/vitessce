{"ast":null,"code":"// algorithm: ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf\nconst buffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(buffer);\nconst uint32View = new Uint32Array(buffer);\nconst baseTable = new Uint32Array(512);\nconst shiftTable = new Uint32Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127; // very small number (0, -0)\n\n  if (e < -27) {\n    baseTable[i | 0x000] = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i | 0x000] = 24;\n    shiftTable[i | 0x100] = 24; // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i | 0x000] = 0x0400 >> -e - 14;\n    baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;\n    shiftTable[i | 0x000] = -e - 1;\n    shiftTable[i | 0x100] = -e - 1; // normal number\n  } else if (e <= 15) {\n    baseTable[i | 0x000] = e + 15 << 10;\n    baseTable[i | 0x100] = e + 15 << 10 | 0x8000;\n    shiftTable[i | 0x000] = 13;\n    shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i | 0x000] = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i | 0x000] = 24;\n    shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i | 0x000] = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i | 0x000] = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n/**\n * round a number to a half float number bits.\n * @param {number} num\n */\n\n\nexport function roundToFloat16Bits(num) {\n  floatView[0] = num;\n  const f = uint32View[0];\n  const e = f >> 23 & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\nconst mantissaTable = new Uint32Array(2048);\nconst exponentTable = new Uint32Array(64);\nconst offsetTable = new Uint32Array(64);\nmantissaTable[0] = 0;\n\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n\n  let e = 0; // zero exponent\n  // normalized\n\n  while ((m & 0x00800000) === 0) {\n    e -= 0x00800000; // decrement exponent\n\n    m <<= 1;\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\n\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + (i - 1024 << 13);\n}\n\nexponentTable[0] = 0;\n\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\n\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\n\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + (i - 32 << 23);\n}\n\nexponentTable[63] = 0xc7800000;\noffsetTable[0] = 0;\n\nfor (let i = 1; i < 64; ++i) {\n  if (i === 32) {\n    offsetTable[i] = 0;\n  } else {\n    offsetTable[i] = 1024;\n  }\n}\n/**\n * convert a half float number bits to a number.\n * @param {number} float16bits - half float number bits\n */\n\n\nexport function convertToNumber(float16bits) {\n  const m = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];\n  return floatView[0];\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@petamoriken/float16/src/lib.js"],"names":["buffer","ArrayBuffer","floatView","Float32Array","uint32View","Uint32Array","baseTable","shiftTable","i","e","roundToFloat16Bits","num","f","mantissaTable","exponentTable","offsetTable","m","convertToNumber","float16bits"],"mappings":"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","sourcesContent":["// algorithm: ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf\n\nconst buffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(buffer);\nconst uint32View = new Uint32Array(buffer);\n\n\nconst baseTable = new Uint32Array(512);\nconst shiftTable = new Uint32Array(512);\n\nfor(let i = 0; i < 256; ++i) {\n    const e = i - 127;\n\n    // very small number (0, -0)\n    if(e < -27) {\n        baseTable[i | 0x000] = 0x0000;\n        baseTable[i | 0x100] = 0x8000;\n        shiftTable[i | 0x000] = 24;\n        shiftTable[i | 0x100] = 24;\n\n    // small number (denorm)\n    } else if(e < -14) {\n        baseTable[i | 0x000] =  0x0400 >> (-e - 14);\n        baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n        shiftTable[i | 0x000] = -e - 1;\n        shiftTable[i | 0x100] = -e - 1;\n\n    // normal number\n    } else if(e <= 15) {\n        baseTable[i | 0x000] =  (e + 15) << 10;\n        baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n        shiftTable[i | 0x000] = 13;\n        shiftTable[i | 0x100] = 13;\n\n    // large number (Infinity, -Infinity)\n    } else if(e < 128) {\n        baseTable[i | 0x000] = 0x7c00;\n        baseTable[i | 0x100] = 0xfc00;\n        shiftTable[i | 0x000] = 24;\n        shiftTable[i | 0x100] = 24;\n\n    // stay (NaN, Infinity, -Infinity)\n    } else {\n        baseTable[i | 0x000] = 0x7c00;\n        baseTable[i | 0x100] = 0xfc00;\n        shiftTable[i | 0x000] = 13;\n        shiftTable[i | 0x100] = 13;\n    }\n}\n\n/**\n * round a number to a half float number bits.\n * @param {number} num\n */\nexport function roundToFloat16Bits(num) {\n    floatView[0] = num;\n\n    const f = uint32View[0];\n    const e = (f >> 23) & 0x1ff;\n    return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\n\nconst mantissaTable = new Uint32Array(2048);\nconst exponentTable = new Uint32Array(64);\nconst offsetTable = new Uint32Array(64);\n\nmantissaTable[0] = 0;\nfor(let i = 1; i < 1024; ++i) {\n    let m = i << 13;    // zero pad mantissa bits\n    let e = 0;          // zero exponent\n\n    // normalized\n    while((m & 0x00800000) === 0) {\n        e -= 0x00800000;    // decrement exponent\n        m <<= 1;\n    }\n\n    m &= ~0x00800000;   // clear leading 1 bit\n    e += 0x38800000;    // adjust bias\n\n    mantissaTable[i] = m | e;\n}\nfor(let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nexponentTable[0] = 0;\nfor(let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor(let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\noffsetTable[0] = 0;\nfor(let i = 1; i < 64; ++i) {\n    if(i === 32) {\n        offsetTable[i] = 0;\n    } else {\n        offsetTable[i] = 1024;\n    }\n}\n\n/**\n * convert a half float number bits to a number.\n * @param {number} float16bits - half float number bits\n */\nexport function convertToNumber(float16bits) {\n    const m = float16bits >> 10;\n    uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];\n    return floatView[0];\n}\n"]},"metadata":{},"sourceType":"module"}