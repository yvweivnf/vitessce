{"ast":null,"code":"import { geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEquidistant, geoConicConformal, geoConicEqualArea, geoConicEquidistant, geoEqualEarth, geoEquirectangular, geoGnomonic, geoIdentity, geoMercator, geoNaturalEarth1, geoOrthographic, geoStereographic, geoTransverseMercator } from 'd3-geo';\nimport { geoMollweide } from 'd3-geo-projection';\nconst defaultPath = geoPath();\nconst projectionProperties = [// standard properties in d3-geo\n'clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'parallels', 'precision', 'reflectX', 'reflectY', // extended properties in d3-geo-projections\n'coefficient', 'distance', 'fraction', 'lobes', 'parallel', 'radius', 'ratio', 'spacing', 'tilt'];\n/**\n * Augment projections with their type and a copy method.\n */\n\nfunction create(type, constructor) {\n  return function projection() {\n    const p = constructor();\n    p.type = type;\n    p.path = geoPath().projection(p);\n\n    p.copy = p.copy || function () {\n      const c = projection();\n      projectionProperties.forEach(prop => {\n        if (p[prop]) c[prop](p[prop]());\n      });\n      c.path.pointRadius(p.path.pointRadius());\n      return c;\n    };\n\n    return p;\n  };\n}\n\nfunction projection(type, proj) {\n  if (!type || typeof type !== 'string') {\n    throw new Error('Projection type must be a name string.');\n  }\n\n  type = type.toLowerCase();\n\n  if (arguments.length > 1) {\n    projections[type] = create(type, proj);\n    return this;\n  } else {\n    return projections[type] || null;\n  }\n}\n\nfunction getProjectionPath(proj) {\n  return proj && proj.path || defaultPath;\n}\n\nconst projections = {\n  // base d3-geo projection types\n  albers: geoAlbers,\n  albersusa: geoAlbersUsa,\n  azimuthalequalarea: geoAzimuthalEqualArea,\n  azimuthalequidistant: geoAzimuthalEquidistant,\n  conicconformal: geoConicConformal,\n  conicequalarea: geoConicEqualArea,\n  conicequidistant: geoConicEquidistant,\n  equalEarth: geoEqualEarth,\n  equirectangular: geoEquirectangular,\n  gnomonic: geoGnomonic,\n  identity: geoIdentity,\n  mercator: geoMercator,\n  mollweide: geoMollweide,\n  naturalEarth1: geoNaturalEarth1,\n  orthographic: geoOrthographic,\n  stereographic: geoStereographic,\n  transversemercator: geoTransverseMercator\n};\n\nfor (const key in projections) {\n  projection(key, projections[key]);\n}\n\nexport { getProjectionPath, projection, projectionProperties };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-projection/build/vega-projection.module.js"],"names":["geoPath","geoAlbers","geoAlbersUsa","geoAzimuthalEqualArea","geoAzimuthalEquidistant","geoConicConformal","geoConicEqualArea","geoConicEquidistant","geoEqualEarth","geoEquirectangular","geoGnomonic","geoIdentity","geoMercator","geoNaturalEarth1","geoOrthographic","geoStereographic","geoTransverseMercator","geoMollweide","defaultPath","projectionProperties","create","type","constructor","projection","p","path","copy","c","forEach","prop","pointRadius","proj","Error","toLowerCase","arguments","length","projections","getProjectionPath","albers","albersusa","azimuthalequalarea","azimuthalequidistant","conicconformal","conicequalarea","conicequidistant","equalEarth","equirectangular","gnomonic","identity","mercator","mollweide","naturalEarth1","orthographic","stereographic","transversemercator","key"],"mappings":"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","sourcesContent":["import { geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEquidistant, geoConicConformal, geoConicEqualArea, geoConicEquidistant, geoEqualEarth, geoEquirectangular, geoGnomonic, geoIdentity, geoMercator, geoNaturalEarth1, geoOrthographic, geoStereographic, geoTransverseMercator } from 'd3-geo';\nimport { geoMollweide } from 'd3-geo-projection';\n\nconst defaultPath = geoPath();\nconst projectionProperties = [// standard properties in d3-geo\n'clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'parallels', 'precision', 'reflectX', 'reflectY', // extended properties in d3-geo-projections\n'coefficient', 'distance', 'fraction', 'lobes', 'parallel', 'radius', 'ratio', 'spacing', 'tilt'];\n/**\n * Augment projections with their type and a copy method.\n */\n\nfunction create(type, constructor) {\n  return function projection() {\n    const p = constructor();\n    p.type = type;\n    p.path = geoPath().projection(p);\n\n    p.copy = p.copy || function () {\n      const c = projection();\n      projectionProperties.forEach(prop => {\n        if (p[prop]) c[prop](p[prop]());\n      });\n      c.path.pointRadius(p.path.pointRadius());\n      return c;\n    };\n\n    return p;\n  };\n}\n\nfunction projection(type, proj) {\n  if (!type || typeof type !== 'string') {\n    throw new Error('Projection type must be a name string.');\n  }\n\n  type = type.toLowerCase();\n\n  if (arguments.length > 1) {\n    projections[type] = create(type, proj);\n    return this;\n  } else {\n    return projections[type] || null;\n  }\n}\nfunction getProjectionPath(proj) {\n  return proj && proj.path || defaultPath;\n}\nconst projections = {\n  // base d3-geo projection types\n  albers: geoAlbers,\n  albersusa: geoAlbersUsa,\n  azimuthalequalarea: geoAzimuthalEqualArea,\n  azimuthalequidistant: geoAzimuthalEquidistant,\n  conicconformal: geoConicConformal,\n  conicequalarea: geoConicEqualArea,\n  conicequidistant: geoConicEquidistant,\n  equalEarth: geoEqualEarth,\n  equirectangular: geoEquirectangular,\n  gnomonic: geoGnomonic,\n  identity: geoIdentity,\n  mercator: geoMercator,\n  mollweide: geoMollweide,\n  naturalEarth1: geoNaturalEarth1,\n  orthographic: geoOrthographic,\n  stereographic: geoStereographic,\n  transversemercator: geoTransverseMercator\n};\n\nfor (const key in projections) {\n  projection(key, projections[key]);\n}\n\nexport { getProjectionPath, projection, projectionProperties };\n"]},"metadata":{},"sourceType":"module"}