{"ast":null,"code":"import _regeneratorRuntime from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";import _asyncToGenerator from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _createClass from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";import _inherits from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";import _createSuper from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";/* eslint-disable no-underscore-dangle */import{openArray,slice}from'zarr';import{extent}from'd3-array';import LoaderResult from'../LoaderResult';import AbstractTwoStepLoader from'../AbstractTwoStepLoader';var normalize=function normalize(arr){var _extent=extent(arr),_extent2=_slicedToArray(_extent,2),min=_extent2[0],max=_extent2[1];var ratio=255/(max-min);var data=new Uint8Array(arr.map(function(i){return Math.floor((i-min)*ratio);}));return{data:data};};var concatenateColumnVectors=function concatenateColumnVectors(arr){var numCols=arr.length;var numRows=arr[0].length;var BYTES_PER_ELEMENT=arr[0].BYTES_PER_ELEMENT;var view=new DataView(new ArrayBuffer(numCols*numRows*BYTES_PER_ELEMENT));var TypedArray=arr[0].constructor;var dtype=TypedArray.name.replace('Array','');for(var i=0;i<numCols;i+=1){for(var j=0;j<numRows;j+=1){view[\"set\".concat(dtype)](BYTES_PER_ELEMENT*(j*numCols+i),arr[i][j],true);}}return new TypedArray(view.buffer);};/**\n * Loader for converting zarr into the a cell x gene matrix for use in Genes/Heatmap components.\n */var MatrixZarrLoader=/*#__PURE__*/function(_AbstractTwoStepLoade){_inherits(MatrixZarrLoader,_AbstractTwoStepLoade);var _super=_createSuper(MatrixZarrLoader);function MatrixZarrLoader(){_classCallCheck(this,MatrixZarrLoader);return _super.apply(this,arguments);}_createClass(MatrixZarrLoader,[{key:\"loadFilteredGeneNames\",/**\n   * Class method for loading the genes list from AnnData.var,\n   * filtered if a there is a `geneFilterZarr` present in the view config.\n   * @returns {Promise} A promise for the zarr array contianing the gene names.\n   */value:function(){var _loadFilteredGeneNames=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var _this=this;var _this$options,geneFilterZarr,geneAlias,getFilterFn,geneNamesPromise;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!this.filteredGeneNames){_context2.next=2;break;}return _context2.abrupt(\"return\",this.filteredGeneNames);case 2:_this$options=this.options,geneFilterZarr=_this$options.geneFilter,geneAlias=_this$options.geneAlias;getFilterFn=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var geneFilter;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(geneFilterZarr){_context.next=2;break;}return _context.abrupt(\"return\",function(data){return data;});case 2:_context.next=4;return _this.dataSource.getFlatArrDecompressed(geneFilterZarr);case 4:geneFilter=_context.sent;return _context.abrupt(\"return\",function(data){return data.filter(function(_,j){return geneFilter[j];});});case 6:case\"end\":return _context.stop();}}},_callee);}));return function getFilterFn(){return _ref.apply(this,arguments);};}();geneNamesPromise=geneAlias?this.dataSource.loadVarAlias(geneAlias):this.dataSource.loadVarIndex();this.filteredGeneNames=Promise.all([geneNamesPromise,getFilterFn()]).then(function(_ref2){var _ref3=_slicedToArray(_ref2,2),data=_ref3[0],filter=_ref3[1];return filter(data);});return _context2.abrupt(\"return\",this.filteredGeneNames);case 7:case\"end\":return _context2.stop();}}},_callee2,this);}));function loadFilteredGeneNames(){return _loadFilteredGeneNames.apply(this,arguments);}return loadFilteredGeneNames;}()/**\n   * Class method for loading a filtered subset of the genes list\n   * @param {String} filterZarr A location in the zarr store to fetch a boolean array from.\n   * @returns {Array} A list of filtered genes.\n   */},{key:\"_getFilteredGenes\",value:function(){var _getFilteredGenes2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(filterZarr){var filter,geneNames,genes;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return this.dataSource.getFlatArrDecompressed(filterZarr);case 2:filter=_context3.sent;_context3.next=5;return this.loadFilteredGeneNames();case 5:geneNames=_context3.sent;genes=geneNames.filter(function(_,i){return filter[i];});return _context3.abrupt(\"return\",genes);case 8:case\"end\":return _context3.stop();}}},_callee3,this);}));function _getFilteredGenes(_x){return _getFilteredGenes2.apply(this,arguments);}return _getFilteredGenes;}()/**\n   * Class method for getting the integer indices of a selection of genes within a list.\n   * @param {Array} selection A list of gene names.\n   * @returns {Array} A list of integer indices.\n   */},{key:\"_getGeneIndices\",value:function(){var _getGeneIndices2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(selection){var geneNames;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return this.loadFilteredGeneNames();case 2:geneNames=_context4.sent;return _context4.abrupt(\"return\",selection.map(function(gene){return geneNames.indexOf(gene);}));case 4:case\"end\":return _context4.stop();}}},_callee4,this);}));function _getGeneIndices(_x2){return _getGeneIndices2.apply(this,arguments);}return _getGeneIndices;}()/**\n   * Class method for getting the number of cells i.e entries in `obs`.\n   * @returns {Number} The number of cells.\n   */},{key:\"_getNumCells\",value:function(){var _getNumCells2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(){var cells;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return this.dataSource.loadObsIndex();case 2:cells=_context5.sent;return _context5.abrupt(\"return\",cells.length);case 4:case\"end\":return _context5.stop();}}},_callee5,this);}));function _getNumCells(){return _getNumCells2.apply(this,arguments);}return _getNumCells;}()/**\n   * Class method for getting the number of genes i.e entries in `var`,\n   * potentially filtered by `genesFilter`.\n   * @returns {Number} The number of genes.\n   */},{key:\"_getNumGenes\",value:function(){var _getNumGenes2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(){var genes;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.next=2;return this.loadFilteredGeneNames();case 2:genes=_context6.sent;return _context6.abrupt(\"return\",genes.length);case 4:case\"end\":return _context6.stop();}}},_callee6,this);}));function _getNumGenes(){return _getNumGenes2.apply(this,arguments);}return _getNumGenes;}()/**\n   * Class method for opening the sparse matrix arrays in zarr.\n   * @returns {Array} A list of promises pointing to the indptr, indices, and data of the matrix.\n   */},{key:\"_openSparseArrays\",value:function(){var _openSparseArrays2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(){var matrix,store;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:matrix=this.options.matrix;store=this.dataSource.store;if(!this.sparseArrays){_context7.next=4;break;}return _context7.abrupt(\"return\",this.sparseArrays);case 4:this.sparseArrays=Promise.all(['indptr','indices','data'].map(function(name){return openArray({store:store,path:\"\".concat(matrix,\"/\").concat(name),mode:'r'});}));return _context7.abrupt(\"return\",this.sparseArrays);case 6:case\"end\":return _context7.stop();}}},_callee7,this);}));function _openSparseArrays(){return _openSparseArrays2.apply(this,arguments);}return _openSparseArrays;}()/**\n   * Class method for loading a gene selection from a CSC matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */},{key:\"_loadCSCGeneSelection\",value:function(){var _loadCSCGeneSelection2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(selection){var indices,_yield$this$_openSpar,_yield$this$_openSpar2,indptrArr,indexArr,cellXGeneArr,numCells,_yield$indptrArr$getR,cols;return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return this._getGeneIndices(selection);case 2:indices=_context9.sent;_context9.next=5;return this._openSparseArrays();case 5:_yield$this$_openSpar=_context9.sent;_yield$this$_openSpar2=_slicedToArray(_yield$this$_openSpar,3);indptrArr=_yield$this$_openSpar2[0];indexArr=_yield$this$_openSpar2[1];cellXGeneArr=_yield$this$_openSpar2[2];_context9.next=12;return this._getNumCells();case 12:numCells=_context9.sent;_context9.next=15;return indptrArr.getRaw(null);case 15:_yield$indptrArr$getR=_context9.sent;cols=_yield$indptrArr$getR.data;return _context9.abrupt(\"return\",Promise.all(indices.map(/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(index){var startRowIndex,endRowIndex,isColumnAllZeros,geneData,_yield$indexArr$get,rowIndices,_yield$cellXGeneArr$g,cellXGeneData,rowIndex;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:startRowIndex=cols[index];endRowIndex=cols[index+1];isColumnAllZeros=startRowIndex===endRowIndex;geneData=new Float32Array(numCells).fill(0);if(!isColumnAllZeros){_context8.next=6;break;}return _context8.abrupt(\"return\",geneData);case 6:_context8.next=8;return indexArr.get([slice(startRowIndex,endRowIndex)]);case 8:_yield$indexArr$get=_context8.sent;rowIndices=_yield$indexArr$get.data;_context8.next=12;return cellXGeneArr.get([slice(startRowIndex,endRowIndex)]);case 12:_yield$cellXGeneArr$g=_context8.sent;cellXGeneData=_yield$cellXGeneArr$g.data;for(rowIndex=0;rowIndex<rowIndices.length;rowIndex+=1){geneData[rowIndices[rowIndex]]=cellXGeneData[rowIndex];}return _context8.abrupt(\"return\",geneData);case 16:case\"end\":return _context8.stop();}}},_callee8);}));return function(_x4){return _ref4.apply(this,arguments);};}())));case 18:case\"end\":return _context9.stop();}}},_callee9,this);}));function _loadCSCGeneSelection(_x3){return _loadCSCGeneSelection2.apply(this,arguments);}return _loadCSCGeneSelection;}()/**\n   * Class method for loading a gene selection from a CSR matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */},{key:\"_loadCSRGeneSelection\",value:function(){var _loadCSRGeneSelection2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(selection){var indices,numGenes,numCells,cellXGene;return _regeneratorRuntime.wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_context10.next=2;return this._getGeneIndices(selection);case 2:indices=_context10.sent;_context10.next=5;return this._getNumGenes();case 5:numGenes=_context10.sent;_context10.next=8;return this._getNumCells();case 8:numCells=_context10.sent;_context10.next=11;return this._loadCSRSparseCellXGene();case 11:cellXGene=_context10.sent;return _context10.abrupt(\"return\",indices.map(function(index){var geneData=new Float32Array(numCells).fill(0);for(var i=0;i<numCells;i+=1){geneData[i]=cellXGene[i*numGenes+index];}return geneData;}));case 13:case\"end\":return _context10.stop();}}},_callee10,this);}));function _loadCSRGeneSelection(_x5){return _loadCSRGeneSelection2.apply(this,arguments);}return _loadCSRGeneSelection;}()/**\n   * Class method for loading row oriented (CSR) sparse data from zarr.\n   *\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */},{key:\"_loadCSRSparseCellXGene\",value:function(){var _loadCSRSparseCellXGene2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee13(){var _this2=this;return _regeneratorRuntime.wrap(function _callee13$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:if(!this._sparseMatrix){_context13.next=2;break;}return _context13.abrupt(\"return\",this._sparseMatrix);case 2:this._sparseMatrix=this._openSparseArrays().then(/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee12(sparseArrays){var matrix,_yield$_this2$dataSou,shape,_yield$Promise$all,_yield$Promise$all2,rows,cols,cellXGene,cellXGeneMatrix,row;return _regeneratorRuntime.wrap(function _callee12$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:matrix=_this2.options.matrix;_context12.next=3;return _this2.dataSource.getJson(\"\".concat(matrix,\"/.zattrs\"));case 3:_yield$_this2$dataSou=_context12.sent;shape=_yield$_this2$dataSou.shape;_context12.next=7;return Promise.all(sparseArrays.map(/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(arr){var _yield$arr$getRaw,data;return _regeneratorRuntime.wrap(function _callee11$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:_context11.next=2;return arr.getRaw(null);case 2:_yield$arr$getRaw=_context11.sent;data=_yield$arr$getRaw.data;return _context11.abrupt(\"return\",data);case 5:case\"end\":return _context11.stop();}}},_callee11);}));return function(_x7){return _ref6.apply(this,arguments);};}()));case 7:_yield$Promise$all=_context12.sent;_yield$Promise$all2=_slicedToArray(_yield$Promise$all,3);rows=_yield$Promise$all2[0];cols=_yield$Promise$all2[1];cellXGene=_yield$Promise$all2[2];cellXGeneMatrix=new Float32Array(shape[0]*shape[1]).fill(0);row=0;rows.forEach(function(_,index){var rowStart=rows[index];var rowEnd=rows[index+1];for(var i=rowStart;i<rowEnd;i+=1){var val=cellXGene[i];var col=cols[i];cellXGeneMatrix[row*shape[1]+col]=val;}row+=1;});return _context12.abrupt(\"return\",cellXGeneMatrix);case 16:case\"end\":return _context12.stop();}}},_callee12);}));return function(_x6){return _ref5.apply(this,arguments);};}());return _context13.abrupt(\"return\",this._sparseMatrix);case 4:case\"end\":return _context13.stop();}}},_callee13,this);}));function _loadCSRSparseCellXGene(){return _loadCSRSparseCellXGene2.apply(this,arguments);}return _loadCSRSparseCellXGene;}()/**\n   * Class method for loading column oriented (CSC) sparse data from zarr.\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */},{key:\"_loadCSCSparseCellXGene\",value:function(){var _loadCSCSparseCellXGene2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee16(){var _this3=this;return _regeneratorRuntime.wrap(function _callee16$(_context16){while(1){switch(_context16.prev=_context16.next){case 0:if(!this._sparseMatrix){_context16.next=2;break;}return _context16.abrupt(\"return\",this._sparseMatrix);case 2:this._sparseMatrix=this._openSparseArrays().then(/*#__PURE__*/function(){var _ref7=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee15(sparseArrays){var matrix,_yield$_this3$dataSou,shape,_yield$Promise$all3,_yield$Promise$all4,cols,rows,cellXGene,cellXGeneMatrix,col;return _regeneratorRuntime.wrap(function _callee15$(_context15){while(1){switch(_context15.prev=_context15.next){case 0:matrix=_this3.options.matrix;_context15.next=3;return _this3.dataSource.getJson(\"\".concat(matrix,\"/.zattrs\"));case 3:_yield$_this3$dataSou=_context15.sent;shape=_yield$_this3$dataSou.shape;_context15.next=7;return Promise.all(sparseArrays.map(/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee14(arr){var _yield$arr$getRaw2,data;return _regeneratorRuntime.wrap(function _callee14$(_context14){while(1){switch(_context14.prev=_context14.next){case 0:_context14.next=2;return arr.getRaw(null);case 2:_yield$arr$getRaw2=_context14.sent;data=_yield$arr$getRaw2.data;return _context14.abrupt(\"return\",data);case 5:case\"end\":return _context14.stop();}}},_callee14);}));return function(_x9){return _ref8.apply(this,arguments);};}()));case 7:_yield$Promise$all3=_context15.sent;_yield$Promise$all4=_slicedToArray(_yield$Promise$all3,3);cols=_yield$Promise$all4[0];rows=_yield$Promise$all4[1];cellXGene=_yield$Promise$all4[2];cellXGeneMatrix=new Float32Array(shape[0]*shape[1]).fill(0);col=0;cols.forEach(function(_,index){var colStart=cols[index];var colEnd=cols[index+1];for(var i=colStart;i<colEnd;i+=1){var val=cellXGene[i];var row=rows[i];cellXGeneMatrix[row*shape[1]+col]=val;}col+=1;});return _context15.abrupt(\"return\",cellXGeneMatrix);case 16:case\"end\":return _context15.stop();}}},_callee15);}));return function(_x8){return _ref7.apply(this,arguments);};}());return _context16.abrupt(\"return\",this._sparseMatrix);case 4:case\"end\":return _context16.stop();}}},_callee16,this);}));function _loadCSCSparseCellXGene(){return _loadCSCSparseCellXGene2.apply(this,arguments);}return _loadCSCSparseCellXGene;}()/**\n   * Class method for loading the cell x gene matrix.\n   * @returns {Promise} A promise for the zarr array contianing the cell x gene data.\n   */},{key:\"loadCellXGene\",value:function(){var _loadCellXGene=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee18(){var _this4=this;var store,_this$options2,matrix,matrixGeneFilter,encodingType,genes;return _regeneratorRuntime.wrap(function _callee18$(_context18){while(1){switch(_context18.prev=_context18.next){case 0:store=this.dataSource.store;if(!this.cellXGene){_context18.next=3;break;}return _context18.abrupt(\"return\",this.cellXGene);case 3:_this$options2=this.options,matrix=_this$options2.matrix,matrixGeneFilter=_this$options2.matrixGeneFilter;if(this._matrixZattrs){_context18.next=8;break;}_context18.next=7;return this.dataSource.getJson(\"\".concat(matrix,\"/.zattrs\"));case 7:this._matrixZattrs=_context18.sent;case 8:encodingType=this._matrixZattrs['encoding-type'];if(matrixGeneFilter){_context18.next=13;break;}if(encodingType==='csr_matrix'){this.cellXGene=this._loadCSRSparseCellXGene().then(function(data){return normalize(data);});}else if(encodingType==='csc_matrix'){this.cellXGene=this._loadCSCSparseCellXGene().then(function(data){return normalize(data);});}else{if(!this.arr){this.arr=openArray({store:store,path:matrix,mode:'r'});}this.cellXGene=this.arr.then(function(z){return z.getRaw(null).then(function(_ref9){var data=_ref9.data;return normalize(data);});});}_context18.next=21;break;case 13:if(!(encodingType==='csr_matrix')){_context18.next=17;break;}this.cellXGene=this._loadCSRSparseCellXGene().then(/*#__PURE__*/function(){var _ref10=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee17(cellXGene){var filteredGenes,numGenesFiltered,geneNames,numGenes,numCells,cellXGeneMatrixFiltered,i,index,j;return _regeneratorRuntime.wrap(function _callee17$(_context17){while(1){switch(_context17.prev=_context17.next){case 0:_context17.next=2;return _this4._getFilteredGenes(matrixGeneFilter);case 2:filteredGenes=_context17.sent;numGenesFiltered=filteredGenes.length;_context17.next=6;return _this4.loadFilteredGeneNames();case 6:geneNames=_context17.sent;numGenes=geneNames.length;_context17.next=10;return _this4._getNumCells();case 10:numCells=_context17.sent;cellXGeneMatrixFiltered=new Float32Array(numCells*numGenesFiltered).fill(0);for(i=0;i<numGenesFiltered;i+=1){index=geneNames.indexOf(filteredGenes[i]);for(j=0;j<numCells;j+=1){cellXGeneMatrixFiltered[j*numGenesFiltered+i]=cellXGene[j*numGenes+index];}}return _context17.abrupt(\"return\",normalize(cellXGeneMatrixFiltered));case 14:case\"end\":return _context17.stop();}}},_callee17);}));return function(_x10){return _ref10.apply(this,arguments);};}());_context18.next=21;break;case 17:_context18.next=19;return this._getFilteredGenes(matrixGeneFilter);case 19:genes=_context18.sent;this.cellXGene=this.loadGeneSelection({selection:genes,shouldNormalize:false}).then(function(_ref11){var data=_ref11.data;return normalize(concatenateColumnVectors(data));});case 21:return _context18.abrupt(\"return\",this.cellXGene);case 22:case\"end\":return _context18.stop();}}},_callee18,this);}));function loadCellXGene(){return _loadCellXGene.apply(this,arguments);}return loadCellXGene;}()/**\n   * Class method for loading a gene selection.\n   * @param {Object} args\n   * @param {Array} args.selection A list of gene names whose data should be fetched.\n   * @param {Boolean} args.shouldNormalize A list of gene names whose data should be fetched.\n   * @returns {Object} { data } containing an array of gene expression data.\n   */},{key:\"loadGeneSelection\",value:function(){var _loadGeneSelection=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee19(_ref12){var _this5=this;var selection,_ref12$shouldNormaliz,shouldNormalize,matrix,store,encodingType,genes,indices;return _regeneratorRuntime.wrap(function _callee19$(_context19){while(1){switch(_context19.prev=_context19.next){case 0:selection=_ref12.selection,_ref12$shouldNormaliz=_ref12.shouldNormalize,shouldNormalize=_ref12$shouldNormaliz===void 0?true:_ref12$shouldNormaliz;matrix=this.options.matrix;store=this.dataSource.store;if(this._matrixZattrs){_context19.next=7;break;}_context19.next=6;return this.dataSource.getJson(\"\".concat(matrix,\"/.zattrs\"));case 6:this._matrixZattrs=_context19.sent;case 7:encodingType=this._matrixZattrs['encoding-type'];if(!(encodingType==='csc_matrix')){_context19.next=14;break;}_context19.next=11;return this._loadCSCGeneSelection(selection);case 11:genes=_context19.sent;_context19.next=27;break;case 14:if(!(encodingType==='csr_matrix')){_context19.next=20;break;}_context19.next=17;return this._loadCSRGeneSelection(selection);case 17:genes=_context19.sent;_context19.next=27;break;case 20:if(!this.arr){this.arr=openArray({store:store,path:matrix,mode:'r'});}_context19.next=23;return this._getGeneIndices(selection);case 23:indices=_context19.sent;_context19.next=26;return Promise.all(indices.map(function(index){return _this5.arr.then(function(z){return z.get([null,index]);}).then(function(_ref13){var data=_ref13.data;return data;});}));case 26:genes=_context19.sent;case 27:return _context19.abrupt(\"return\",{data:genes.map(function(i){return shouldNormalize?normalize(i).data:i;}),url:null});case 28:case\"end\":return _context19.stop();}}},_callee19,this);}));function loadGeneSelection(_x11){return _loadGeneSelection.apply(this,arguments);}return loadGeneSelection;}()/**\n   * Class method for loading only attributes i.e rows and columns\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Object} { data: { rows, cols }, url } containing row and col labels for the matrix.\n   */},{key:\"loadAttrs\",value:function loadAttrs(){return Promise.all([this.dataSource.loadObsIndex(),this.loadFilteredGeneNames()]).then(function(d){var _d=_slicedToArray(d,2),cellNames=_d[0],geneNames=_d[1];var attrs={rows:cellNames,cols:geneNames};return{data:attrs,url:null};});}},{key:\"load\",value:function load(){var _this6=this;return Promise.all([this.loadAttrs(),this.loadCellXGene()]).then(/*#__PURE__*/function(){var _ref14=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee20(d){var _d2,attrs,cellXGene,matrixGeneFilterZarr,matrixGeneFilter;return _regeneratorRuntime.wrap(function _callee20$(_context20){while(1){switch(_context20.prev=_context20.next){case 0:_d2=_slicedToArray(d,2),attrs=_d2[0].data,cellXGene=_d2[1];matrixGeneFilterZarr=_this6.options.matrixGeneFilter;// In order to return the correct gene list with the heatmap data,\n// we need to filter the columns of attrs so it matches the cellXGene data.\nif(!matrixGeneFilterZarr){_context20.next=7;break;}_context20.next=5;return _this6.dataSource.getFlatArrDecompressed(matrixGeneFilterZarr);case 5:matrixGeneFilter=_context20.sent;attrs.cols=attrs.cols.filter(function(_,i){return matrixGeneFilter[i];});case 7:return _context20.abrupt(\"return\",Promise.resolve(new LoaderResult([attrs,cellXGene],null)));case 8:case\"end\":return _context20.stop();}}},_callee20);}));return function(_x12){return _ref14.apply(this,arguments);};}());}}]);return MatrixZarrLoader;}(AbstractTwoStepLoader);export{MatrixZarrLoader as default};","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/anndata-loaders/MatrixZarrLoader.js"],"names":["openArray","slice","extent","LoaderResult","AbstractTwoStepLoader","normalize","arr","min","max","ratio","data","Uint8Array","map","i","Math","floor","concatenateColumnVectors","numCols","length","numRows","BYTES_PER_ELEMENT","view","DataView","ArrayBuffer","TypedArray","constructor","dtype","name","replace","j","buffer","MatrixZarrLoader","filteredGeneNames","options","geneFilterZarr","geneFilter","geneAlias","getFilterFn","dataSource","getFlatArrDecompressed","filter","_","geneNamesPromise","loadVarAlias","loadVarIndex","Promise","all","then","filterZarr","loadFilteredGeneNames","geneNames","genes","selection","gene","indexOf","loadObsIndex","cells","matrix","store","sparseArrays","path","mode","_getGeneIndices","indices","_openSparseArrays","indptrArr","indexArr","cellXGeneArr","_getNumCells","numCells","getRaw","cols","index","startRowIndex","endRowIndex","isColumnAllZeros","geneData","Float32Array","fill","get","rowIndices","cellXGeneData","rowIndex","_getNumGenes","numGenes","_loadCSRSparseCellXGene","cellXGene","_sparseMatrix","getJson","shape","rows","cellXGeneMatrix","row","forEach","rowStart","rowEnd","val","col","colStart","colEnd","matrixGeneFilter","_matrixZattrs","encodingType","_loadCSCSparseCellXGene","z","_getFilteredGenes","filteredGenes","numGenesFiltered","cellXGeneMatrixFiltered","loadGeneSelection","shouldNormalize","_loadCSCGeneSelection","_loadCSRGeneSelection","url","d","cellNames","attrs","loadAttrs","loadCellXGene","matrixGeneFilterZarr","resolve"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { openArray, slice } from 'zarr';\nimport { extent } from 'd3-array';\nimport LoaderResult from '../LoaderResult';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\n\nconst normalize = (arr) => {\n  const [min, max] = extent(arr);\n  const ratio = 255 / (max - min);\n  const data = new Uint8Array(\n    arr.map(i => Math.floor((i - min) * ratio)),\n  );\n  return { data };\n};\n\nconst concatenateColumnVectors = (arr) => {\n  const numCols = arr.length;\n  const numRows = arr[0].length;\n  const { BYTES_PER_ELEMENT } = arr[0];\n  const view = new DataView(new ArrayBuffer(numCols * numRows * BYTES_PER_ELEMENT));\n  const TypedArray = arr[0].constructor;\n  const dtype = TypedArray.name.replace('Array', '');\n  for (let i = 0; i < numCols; i += 1) {\n    for (let j = 0; j < numRows; j += 1) {\n      view[`set${dtype}`](BYTES_PER_ELEMENT * (j * numCols + i), arr[i][j], true);\n    }\n  }\n  return new TypedArray(view.buffer);\n};\n\n/**\n * Loader for converting zarr into the a cell x gene matrix for use in Genes/Heatmap components.\n */\nexport default class MatrixZarrLoader extends AbstractTwoStepLoader {\n  /**\n   * Class method for loading the genes list from AnnData.var,\n   * filtered if a there is a `geneFilterZarr` present in the view config.\n   * @returns {Promise} A promise for the zarr array contianing the gene names.\n   */\n  async loadFilteredGeneNames() {\n    if (this.filteredGeneNames) {\n      return this.filteredGeneNames;\n    }\n    const { geneFilter: geneFilterZarr, geneAlias } = this.options;\n    const getFilterFn = async () => {\n      if (!geneFilterZarr) return data => data;\n      const geneFilter = await this.dataSource.getFlatArrDecompressed(geneFilterZarr);\n      return data => data.filter((_, j) => geneFilter[j]);\n    };\n    const geneNamesPromise = geneAlias\n      ? this.dataSource.loadVarAlias(geneAlias)\n      : this.dataSource.loadVarIndex();\n    this.filteredGeneNames = Promise.all([\n      geneNamesPromise,\n      getFilterFn(),\n    ]).then(([data, filter]) => filter(data));\n    return this.filteredGeneNames;\n  }\n\n  /**\n   * Class method for loading a filtered subset of the genes list\n   * @param {String} filterZarr A location in the zarr store to fetch a boolean array from.\n   * @returns {Array} A list of filtered genes.\n   */\n  async _getFilteredGenes(filterZarr) {\n    const filter = await this.dataSource.getFlatArrDecompressed(filterZarr);\n    const geneNames = await this.loadFilteredGeneNames();\n    const genes = geneNames.filter((_, i) => filter[i]);\n    return genes;\n  }\n\n  /**\n   * Class method for getting the integer indices of a selection of genes within a list.\n   * @param {Array} selection A list of gene names.\n   * @returns {Array} A list of integer indices.\n   */\n  async _getGeneIndices(selection) {\n    const geneNames = await this.loadFilteredGeneNames();\n    return selection.map(gene => geneNames.indexOf(gene));\n  }\n\n  /**\n   * Class method for getting the number of cells i.e entries in `obs`.\n   * @returns {Number} The number of cells.\n   */\n  async _getNumCells() {\n    const cells = await this.dataSource.loadObsIndex();\n    return cells.length;\n  }\n\n  /**\n   * Class method for getting the number of genes i.e entries in `var`,\n   * potentially filtered by `genesFilter`.\n   * @returns {Number} The number of genes.\n   */\n  async _getNumGenes() {\n    const genes = await this.loadFilteredGeneNames();\n    return genes.length;\n  }\n\n  /**\n   * Class method for opening the sparse matrix arrays in zarr.\n   * @returns {Array} A list of promises pointing to the indptr, indices, and data of the matrix.\n   */\n  async _openSparseArrays() {\n    const { options: { matrix } } = this;\n    const { store } = this.dataSource;\n    if (this.sparseArrays) {\n      return this.sparseArrays;\n    }\n    this.sparseArrays = Promise.all(\n      ['indptr', 'indices', 'data'].map(name => openArray({ store, path: `${matrix}/${name}`, mode: 'r' })),\n    );\n    return this.sparseArrays;\n  }\n\n  /**\n   * Class method for loading a gene selection from a CSC matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */\n  async _loadCSCGeneSelection(selection) {\n    const indices = await this._getGeneIndices(selection);\n    const [indptrArr, indexArr, cellXGeneArr] = await this._openSparseArrays();\n    const numCells = await this._getNumCells();\n    const { data: cols } = await indptrArr.getRaw(null);\n    // If there is not change in the column indexer, then the data is all zeros\n    return Promise.all(\n      indices.map(async (index) => {\n        const startRowIndex = cols[index];\n        const endRowIndex = cols[index + 1];\n        const isColumnAllZeros = startRowIndex === endRowIndex;\n        const geneData = new Float32Array(numCells).fill(0);\n        if (isColumnAllZeros) {\n          return geneData;\n        }\n        const { data: rowIndices } = await indexArr.get([\n          slice(startRowIndex, endRowIndex),\n        ]);\n        const { data: cellXGeneData } = await cellXGeneArr.get([\n          slice(startRowIndex, endRowIndex),\n        ]);\n        for (let rowIndex = 0; rowIndex < rowIndices.length; rowIndex += 1) {\n          geneData[rowIndices[rowIndex]] = cellXGeneData[rowIndex];\n        }\n        return geneData;\n      }),\n    );\n  }\n\n  /**\n   * Class method for loading a gene selection from a CSR matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */\n  async _loadCSRGeneSelection(selection) {\n    const indices = await this._getGeneIndices(selection);\n    const numGenes = await this._getNumGenes();\n    const numCells = await this._getNumCells();\n    const cellXGene = await this._loadCSRSparseCellXGene();\n    return indices.map((index) => {\n      const geneData = new Float32Array(numCells).fill(0);\n      for (let i = 0; i < numCells; i += 1) {\n        geneData[i] = cellXGene[i * numGenes + index];\n      }\n      return geneData;\n    });\n  }\n\n  /**\n   * Class method for loading row oriented (CSR) sparse data from zarr.\n   *\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */\n  async _loadCSRSparseCellXGene() {\n    if (this._sparseMatrix) {\n      return this._sparseMatrix;\n    }\n    this._sparseMatrix = this._openSparseArrays().then(async (sparseArrays) => {\n      const { options: { matrix } } = this;\n      const { shape } = await this.dataSource.getJson(`${matrix}/.zattrs`);\n      const [rows, cols, cellXGene] = await Promise.all(\n        sparseArrays.map(async (arr) => {\n          const { data } = await arr.getRaw(null);\n          return data;\n        }),\n      );\n      const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);\n      let row = 0;\n      rows.forEach((_, index) => {\n        const rowStart = rows[index];\n        const rowEnd = rows[index + 1];\n        for (let i = rowStart; i < rowEnd; i += 1) {\n          const val = cellXGene[i];\n          const col = cols[i];\n          cellXGeneMatrix[row * shape[1] + col] = val;\n        }\n        row += 1;\n      });\n      return cellXGeneMatrix;\n    });\n    return this._sparseMatrix;\n  }\n\n  /**\n   * Class method for loading column oriented (CSC) sparse data from zarr.\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */\n  async _loadCSCSparseCellXGene() {\n    if (this._sparseMatrix) {\n      return this._sparseMatrix;\n    }\n    this._sparseMatrix = this._openSparseArrays().then(async (sparseArrays) => {\n      const { options: { matrix } } = this;\n      const { shape } = await this.dataSource.getJson(`${matrix}/.zattrs`);\n      const [cols, rows, cellXGene] = await Promise.all(\n        sparseArrays.map(async (arr) => {\n          const { data } = await arr.getRaw(null);\n          return data;\n        }),\n      );\n      const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);\n      let col = 0;\n      cols.forEach((_, index) => {\n        const colStart = cols[index];\n        const colEnd = cols[index + 1];\n        for (let i = colStart; i < colEnd; i += 1) {\n          const val = cellXGene[i];\n          const row = rows[i];\n          cellXGeneMatrix[row * shape[1] + col] = val;\n        }\n        col += 1;\n      });\n      return cellXGeneMatrix;\n    });\n    return this._sparseMatrix;\n  }\n\n  /**\n   * Class method for loading the cell x gene matrix.\n   * @returns {Promise} A promise for the zarr array contianing the cell x gene data.\n   */\n  async loadCellXGene() {\n    const { store } = this.dataSource;\n    if (this.cellXGene) {\n      return this.cellXGene;\n    }\n    const { options: { matrix, matrixGeneFilter } } = this;\n    if (!this._matrixZattrs) {\n      this._matrixZattrs = await this.dataSource.getJson(`${matrix}/.zattrs`);\n    }\n    const encodingType = this._matrixZattrs['encoding-type'];\n    if (!matrixGeneFilter) {\n      if (encodingType === 'csr_matrix') {\n        this.cellXGene = this._loadCSRSparseCellXGene().then(data => normalize(data));\n      } else if (encodingType === 'csc_matrix') {\n        this.cellXGene = this._loadCSCSparseCellXGene().then(data => normalize(data));\n      } else {\n        if (!this.arr) {\n          this.arr = openArray({ store, path: matrix, mode: 'r' });\n        }\n        this.cellXGene = this.arr.then(z => z.getRaw(null).then(({ data }) => normalize(data)));\n      }\n    } else if (encodingType === 'csr_matrix') {\n      this.cellXGene = this._loadCSRSparseCellXGene().then(\n        async (cellXGene) => {\n          const filteredGenes = await this._getFilteredGenes(matrixGeneFilter);\n          const numGenesFiltered = filteredGenes.length;\n          const geneNames = await this.loadFilteredGeneNames();\n          const numGenes = geneNames.length;\n          const numCells = await this._getNumCells();\n          const cellXGeneMatrixFiltered = new Float32Array(\n            numCells * numGenesFiltered,\n          ).fill(0);\n          for (let i = 0; i < numGenesFiltered; i += 1) {\n            const index = geneNames.indexOf(filteredGenes[i]);\n            for (let j = 0; j < numCells; j += 1) {\n              cellXGeneMatrixFiltered[j * numGenesFiltered + i] = cellXGene[j * numGenes + index];\n            }\n          }\n          return normalize(cellXGeneMatrixFiltered);\n        },\n      );\n    } else {\n      const genes = await this._getFilteredGenes(matrixGeneFilter);\n      this.cellXGene = this.loadGeneSelection({ selection: genes, shouldNormalize: false })\n        .then(({ data }) => (normalize(concatenateColumnVectors(data))));\n    }\n    return this.cellXGene;\n  }\n\n  /**\n   * Class method for loading a gene selection.\n   * @param {Object} args\n   * @param {Array} args.selection A list of gene names whose data should be fetched.\n   * @param {Boolean} args.shouldNormalize A list of gene names whose data should be fetched.\n   * @returns {Object} { data } containing an array of gene expression data.\n   */\n  async loadGeneSelection({ selection, shouldNormalize = true }) {\n    const { options: { matrix } } = this;\n    const { store } = this.dataSource;\n    if (!this._matrixZattrs) {\n      this._matrixZattrs = await this.dataSource.getJson(`${matrix}/.zattrs`);\n    }\n    const encodingType = this._matrixZattrs['encoding-type'];\n    let genes;\n    if (encodingType === 'csc_matrix') {\n      genes = await this._loadCSCGeneSelection(selection);\n    } else if (encodingType === 'csr_matrix') {\n      genes = await this._loadCSRGeneSelection(selection);\n    } else {\n      if (!this.arr) {\n        this.arr = openArray({ store, path: matrix, mode: 'r' });\n      }\n      const indices = await this._getGeneIndices(selection);\n      // We can index directly into a normal dense array zarr store via `get`.\n      genes = await Promise.all(\n        indices.map(index => this.arr.then(z => z.get([null, index])).then(({ data }) => data)),\n      );\n    }\n    return { data: genes.map(i => (shouldNormalize ? normalize(i).data : i)), url: null };\n  }\n\n  /**\n   * Class method for loading only attributes i.e rows and columns\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Object} { data: { rows, cols }, url } containing row and col labels for the matrix.\n   */\n  loadAttrs() {\n    return Promise.all([this.dataSource.loadObsIndex(), this.loadFilteredGeneNames()])\n      .then((d) => {\n        const [cellNames, geneNames] = d;\n        const attrs = { rows: cellNames, cols: geneNames };\n        return {\n          data: attrs,\n          url: null,\n        };\n      });\n  }\n\n  load() {\n    return Promise.all([this.loadAttrs(), this.loadCellXGene()]).then(\n      async (d) => {\n        const [{ data: attrs }, cellXGene] = d;\n        const {\n          options: { matrixGeneFilter: matrixGeneFilterZarr },\n        } = this;\n        // In order to return the correct gene list with the heatmap data,\n        // we need to filter the columns of attrs so it matches the cellXGene data.\n        if (matrixGeneFilterZarr) {\n          const matrixGeneFilter = await this.dataSource.getFlatArrDecompressed(\n            matrixGeneFilterZarr,\n          );\n          attrs.cols = attrs.cols.filter((_, i) => matrixGeneFilter[i]);\n        }\n        return Promise.resolve(new LoaderResult([attrs, cellXGene], null));\n      },\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}