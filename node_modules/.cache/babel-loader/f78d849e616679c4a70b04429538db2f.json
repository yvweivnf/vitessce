{"ast":null,"code":"import { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport class FilterInvalidNode extends DataFlowNode {\n  constructor(parent, filter) {\n    super(parent);\n    this.filter = filter;\n  }\n\n  clone() {\n    return new FilterInvalidNode(null, Object.assign({}, this.filter));\n  }\n\n  static make(parent, model) {\n    const {\n      config,\n      mark,\n      markDef\n    } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n    if (invalid !== 'filter') {\n      return null;\n    }\n\n    const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n\n      if (scaleComponent) {\n        const scaleType = scaleComponent.get('type'); // While discrete domain scales can handle invalid values, continuous scales can't.\n        // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n        // (For path marks, we will use \"defined\" property and skip these values instead.)\n\n        if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n          aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n        }\n      }\n\n      return aggregator;\n    }, {});\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  dependentFields() {\n    return new Set(keys(this.filter));\n  }\n\n  producedFields() {\n    return new Set(); // filter does not produce any new fields\n  }\n\n  hash() {\n    return `FilterInvalid ${hash(this.filter)}`;\n  }\n  /**\n   * Create the VgTransforms for each of the filtered fields.\n   */\n\n\n  assemble() {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {\n        expr: 'datum'\n      });\n\n      if (fieldDef !== null) {\n        if (fieldDef.type === 'temporal') {\n          vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`);\n        } else if (fieldDef.type === 'quantitative') {\n          vegaFilters.push(`isValid(${ref})`);\n          vegaFilters.push(`isFinite(+${ref})`);\n        } else {// should never get here\n        }\n      }\n\n      return vegaFilters;\n    }, []);\n    return filters.length > 0 ? {\n      type: 'filter',\n      expr: filters.join(' && ')\n    } : null;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/filterinvalid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport class FilterInvalidNode extends DataFlowNode {\n    constructor(parent, filter) {\n        super(parent);\n        this.filter = filter;\n    }\n    clone() {\n        return new FilterInvalidNode(null, Object.assign({}, this.filter));\n    }\n    static make(parent, model) {\n        const { config, mark, markDef } = model;\n        const invalid = getMarkPropOrConfig('invalid', markDef, config);\n        if (invalid !== 'filter') {\n            return null;\n        }\n        const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n            const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n            if (scaleComponent) {\n                const scaleType = scaleComponent.get('type');\n                // While discrete domain scales can handle invalid values, continuous scales can't.\n                // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n                // (For path marks, we will use \"defined\" property and skip these values instead.)\n                if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n                    aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n                }\n            }\n            return aggregator;\n        }, {});\n        if (!keys(filter).length) {\n            return null;\n        }\n        return new FilterInvalidNode(parent, filter);\n    }\n    dependentFields() {\n        return new Set(keys(this.filter));\n    }\n    producedFields() {\n        return new Set(); // filter does not produce any new fields\n    }\n    hash() {\n        return `FilterInvalid ${hash(this.filter)}`;\n    }\n    /**\n     * Create the VgTransforms for each of the filtered fields.\n     */\n    assemble() {\n        const filters = keys(this.filter).reduce((vegaFilters, field) => {\n            const fieldDef = this.filter[field];\n            const ref = fieldRef(fieldDef, { expr: 'datum' });\n            if (fieldDef !== null) {\n                if (fieldDef.type === 'temporal') {\n                    vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`);\n                }\n                else if (fieldDef.type === 'quantitative') {\n                    vegaFilters.push(`isValid(${ref})`);\n                    vegaFilters.push(`isFinite(+${ref})`);\n                }\n                else {\n                    // should never get here\n                }\n            }\n            return vegaFilters;\n        }, []);\n        return filters.length > 0\n            ? {\n                type: 'filter',\n                expr: filters.join(' && ')\n            }\n            : null;\n    }\n}\n//# sourceMappingURL=filterinvalid.js.map"]},"metadata":{},"sourceType":"module"}