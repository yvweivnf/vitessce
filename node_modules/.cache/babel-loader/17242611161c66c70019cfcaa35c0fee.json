{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\n/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nvar SymbolIterator = getSymbol(\"iterator\");\nvar SymbolObservable = getSymbol(\"observable\");\nvar SymbolSpecies = getSymbol(\"species\"); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null) {\n    return undefined;\n  }\n\n  if (typeof value !== \"function\") {\n    throw new TypeError(value + \" is not a function\");\n  }\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(error) {\n  if (hostReportError.log) {\n    hostReportError.log(error);\n  } else {\n    setTimeout(function () {\n      throw error;\n    }, 0);\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n\n  if (cleanup === undefined) {\n    return;\n  }\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === \"function\") {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, \"unsubscribe\");\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = \"closed\";\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = \"ready\";\n\n  var _iterator = _createForOfIteratorHelper(queue),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      notifySubscription(subscription, item.type, item.value);\n\n      if (subscription._state === \"closed\") {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = \"running\";\n  var observer = subscription._observer;\n\n  try {\n    var m = observer ? getMethod(observer, type) : undefined;\n\n    switch (type) {\n      case \"next\":\n        if (m) m.call(observer, value);\n        break;\n\n      case \"error\":\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case \"complete\":\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === \"closed\") {\n    cleanupSubscription(subscription);\n  } else if (subscription._state === \"running\") {\n    subscription._state = \"ready\";\n  }\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === \"closed\") {\n    return;\n  }\n\n  if (subscription._state === \"buffering\") {\n    subscription._queue = subscription._queue || [];\n\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== \"ready\") {\n    subscription._state = \"buffering\";\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nexport var Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = \"initializing\";\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === \"initializing\") {\n      this._state = \"ready\";\n    }\n  }\n\n  _createClass(Subscription, [{\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (this._state !== \"closed\") {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._state === \"closed\";\n    }\n  }]);\n\n  return Subscription;\n}();\nexport var SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: \"next\",\n    value: function next(value) {\n      onNotify(this._subscription, \"next\", value);\n    }\n  }, {\n    key: \"error\",\n    value: function error(value) {\n      onNotify(this._subscription, \"error\", value);\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      onNotify(this._subscription, \"complete\");\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._subscription._state === \"closed\";\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\n\nexport var Observable = /*#__PURE__*/function () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) {\n      throw new TypeError(\"Observable cannot be called as a function\");\n    }\n\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Observable initializer must be a function\");\n    }\n\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(nextOrObserver, onError, onComplete) {\n      if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n        nextOrObserver = {\n          next: nextOrObserver,\n          error: onError,\n          complete: onComplete\n        };\n      }\n\n      return new Subscription(nextOrObserver, this._subscriber);\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(first) {\n      // tslint:disable-next-line no-this-assignment\n      var intermediate = this;\n\n      for (var _len = arguments.length, mappers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        mappers[_key - 1] = arguments[_key];\n      }\n\n      for (var _i = 0, _arr = [first].concat(mappers); _i < _arr.length; _i++) {\n        var mapper = _arr[_i];\n        intermediate = mapper(intermediate);\n      }\n\n      return intermediate;\n    }\n  }, {\n    key: \"tap\",\n    value: function tap(nextOrObserver, onError, onComplete) {\n      var _this = this;\n\n      var tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null ? {\n        next: nextOrObserver,\n        error: onError,\n        complete: onComplete\n      } : nextOrObserver;\n      return new Observable(function (observer) {\n        return _this.subscribe({\n          next: function next(value) {\n            tapObserver.next && tapObserver.next(value);\n            observer.next(value);\n          },\n          error: function error(_error) {\n            tapObserver.error && tapObserver.error(_error);\n            observer.error(_error);\n          },\n          complete: function complete() {\n            tapObserver.complete && tapObserver.complete();\n            observer.complete();\n          },\n          start: function start(subscription) {\n            tapObserver.start && tapObserver.start(subscription);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== \"function\") {\n          reject(new TypeError(fn + \" is not a function\"));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve(undefined);\n        }\n\n        var subscription = _this2.subscribe({\n          next: function next(value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n          error: function error(_error2) {\n            reject(_error2);\n          },\n          complete: function complete() {\n            resolve(undefined);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function next(value) {\n            var propagatedValue = value;\n\n            try {\n              propagatedValue = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(propagatedValue);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function next(value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn, seed) {\n      var _this5 = this;\n\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var acc = seed;\n      return new C(function (observer) {\n        return _this5.subscribe({\n          next: function next(value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            if (!hasValue && !hasSeed) {\n              return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n            }\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this6 = this;\n\n      for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        sources[_key2] = arguments[_key2];\n      }\n\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscription;\n        var index = 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function next(v) {\n              observer.next(v);\n            },\n            error: function error(e) {\n              observer.error(e);\n            },\n            complete: function complete() {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n\n        startNext(_this6);\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(fn) {\n      var _this7 = this;\n\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this7.subscribe({\n          next: function next(value) {\n            var normalizedValue;\n\n            if (fn) {\n              try {\n                normalizedValue = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              normalizedValue = value;\n            }\n\n            var inner = C.from(normalizedValue).subscribe({\n              next: function next(innerValue) {\n                observer.next(innerValue);\n              },\n              error: function error(e) {\n                observer.error(e);\n              },\n              complete: function complete() {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n            subscriptions.push(inner);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) {\n            observer.complete();\n          }\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: (Symbol.observable, SymbolObservable),\n    value: function value() {\n      return this;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(x) {\n      var C = typeof this === \"function\" ? this : Observable;\n\n      if (x == null) {\n        throw new TypeError(x + \" is not an object\");\n      }\n\n      var observableMethod = getMethod(x, SymbolObservable);\n\n      if (observableMethod) {\n        var observable = observableMethod.call(x);\n\n        if (Object(observable) !== observable) {\n          throw new TypeError(observable + \" is not an object\");\n        }\n\n        if (isObservable(observable) && observable.constructor === C) {\n          return observable;\n        }\n\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol(\"iterator\")) {\n        var iteratorMethod = getMethod(x, SymbolIterator);\n\n        if (iteratorMethod) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n\n              var _iterator2 = _createForOfIteratorHelper(iteratorMethod.call(x)),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var item = _step2.value;\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            var _iterator3 = _createForOfIteratorHelper(x),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var item = _step3.value;\n                observer.next(item);\n                if (observer.closed) return;\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + \" is not observable\");\n    }\n  }, {\n    key: \"of\",\n    value: function of() {\n      for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        items[_key3] = arguments[_key3];\n      }\n\n      var C = typeof this === \"function\" ? this : Observable;\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          var _iterator4 = _createForOfIteratorHelper(items),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var item = _step4.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol(\"extensions\"), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport default Observable;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/observable-fns/dist.esm/observable.js"],"names":["getSymbol","hasSymbol","hasSymbols","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","obj","key","value","undefined","TypeError","getSpecies","ctor","constructor","Observable","isObservable","x","hostReportError","error","log","setTimeout","enqueue","fn","Promise","resolve","then","e","cleanupSubscription","subscription","cleanup","_cleanup","unsubscribe","call","closeSubscription","_observer","_queue","_state","flushSubscription","queue","item","notifySubscription","type","observer","m","onNotify","push","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscription","_subscriber","nextOrObserver","onError","onComplete","next","complete","first","intermediate","mappers","mapper","tapObserver","subscribe","start","reject","done","C","propagatedValue","seed","hasSeed","arguments","length","hasValue","acc","sources","index","startNext","v","from","subscriptions","outer","normalizedValue","inner","innerValue","i","indexOf","splice","completeIfDone","closed","forEach","s","Symbol","observable","observableMethod","Object","iteratorMethod","Array","isArray","items","defineProperty","symbol","configurable"],"mappings":";;;;AAAA;;;;AAIA,OAAO,WAAP;AACA,SAASA,SAAT,EAAoBC,SAApB,EAA+BC,UAA/B,QAAiD,YAAjD;AACA,IAAMC,cAAc,GAAGH,SAAS,CAAC,UAAD,CAAhC;AACA,IAAMI,gBAAgB,GAAGJ,SAAS,CAAC,YAAD,CAAlC;AACA,IAAMK,aAAa,GAAGL,SAAS,CAAC,SAAD,CAA/B,C,CACA;;AACA,SAASM,SAAT,CAAmBC,GAAnB,EAAwBC,GAAxB,EAA6B;AACzB,MAAMC,KAAK,GAAGF,GAAG,CAACC,GAAD,CAAjB;;AACA,MAAIC,KAAK,IAAI,IAAb,EAAmB;AACf,WAAOC,SAAP;AACH;;AACD,MAAI,OAAOD,KAAP,KAAiB,UAArB,EAAiC;AAC7B,UAAM,IAAIE,SAAJ,CAAcF,KAAK,GAAG,oBAAtB,CAAN;AACH;;AACD,SAAOA,KAAP;AACH;;AACD,SAASG,UAAT,CAAoBL,GAApB,EAAyB;AACrB,MAAIM,IAAI,GAAGN,GAAG,CAACO,WAAf;;AACA,MAAID,IAAI,KAAKH,SAAb,EAAwB;AACpBG,IAAAA,IAAI,GAAGA,IAAI,CAACR,aAAD,CAAX;;AACA,QAAIQ,IAAI,KAAK,IAAb,EAAmB;AACfA,MAAAA,IAAI,GAAGH,SAAP;AACH;AACJ;;AACD,SAAOG,IAAI,KAAKH,SAAT,GAAqBG,IAArB,GAA4BE,UAAnC;AACH;;AACD,SAASC,YAAT,CAAsBC,CAAtB,EAAyB;AACrB,SAAOA,CAAC,YAAYF,UAApB,CADqB,CACW;AACnC;;AACD,SAASG,eAAT,CAAyBC,KAAzB,EAAgC;AAC5B,MAAID,eAAe,CAACE,GAApB,EAAyB;AACrBF,IAAAA,eAAe,CAACE,GAAhB,CAAoBD,KAApB;AACH,GAFD,MAGK;AACDE,IAAAA,UAAU,CAAC,YAAM;AAAE,YAAMF,KAAN;AAAc,KAAvB,EAAyB,CAAzB,CAAV;AACH;AACJ;;AACD,SAASG,OAAT,CAAiBC,EAAjB,EAAqB;AACjBC,EAAAA,OAAO,CAACC,OAAR,GAAkBC,IAAlB,CAAuB,YAAM;AACzB,QAAI;AACAH,MAAAA,EAAE;AACL,KAFD,CAGA,OAAOI,CAAP,EAAU;AACNT,MAAAA,eAAe,CAACS,CAAD,CAAf;AACH;AACJ,GAPD;AAQH;;AACD,SAASC,mBAAT,CAA6BC,YAA7B,EAA2C;AACvC,MAAMC,OAAO,GAAGD,YAAY,CAACE,QAA7B;;AACA,MAAID,OAAO,KAAKpB,SAAhB,EAA2B;AACvB;AACH;;AACDmB,EAAAA,YAAY,CAACE,QAAb,GAAwBrB,SAAxB;;AACA,MAAI,CAACoB,OAAL,EAAc;AACV;AACH;;AACD,MAAI;AACA,QAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;AAC/BA,MAAAA,OAAO;AACV,KAFD,MAGK;AACD,UAAME,WAAW,GAAG1B,SAAS,CAACwB,OAAD,EAAU,aAAV,CAA7B;;AACA,UAAIE,WAAJ,EAAiB;AACbA,QAAAA,WAAW,CAACC,IAAZ,CAAiBH,OAAjB;AACH;AACJ;AACJ,GAVD,CAWA,OAAOH,CAAP,EAAU;AACNT,IAAAA,eAAe,CAACS,CAAD,CAAf;AACH;AACJ;;AACD,SAASO,iBAAT,CAA2BL,YAA3B,EAAyC;AACrCA,EAAAA,YAAY,CAACM,SAAb,GAAyBzB,SAAzB;AACAmB,EAAAA,YAAY,CAACO,MAAb,GAAsB1B,SAAtB;AACAmB,EAAAA,YAAY,CAACQ,MAAb,GAAsB,QAAtB;AACH;;AACD,SAASC,iBAAT,CAA2BT,YAA3B,EAAyC;AACrC,MAAMU,KAAK,GAAGV,YAAY,CAACO,MAA3B;;AACA,MAAI,CAACG,KAAL,EAAY;AACR;AACH;;AACDV,EAAAA,YAAY,CAACO,MAAb,GAAsB1B,SAAtB;AACAmB,EAAAA,YAAY,CAACQ,MAAb,GAAsB,OAAtB;;AANqC,6CAOlBE,KAPkB;AAAA;;AAAA;AAOrC,wDAA0B;AAAA,UAAfC,IAAe;AACtBC,MAAAA,kBAAkB,CAACZ,YAAD,EAAeW,IAAI,CAACE,IAApB,EAA0BF,IAAI,CAAC/B,KAA/B,CAAlB;;AACA,UAAIoB,YAAY,CAACQ,MAAb,KAAwB,QAA5B,EAAsC;AAClC;AACH;AACJ;AAZoC;AAAA;AAAA;AAAA;AAAA;AAaxC;;AACD,SAASI,kBAAT,CAA4BZ,YAA5B,EAA0Ca,IAA1C,EAAgDjC,KAAhD,EAAuD;AACnDoB,EAAAA,YAAY,CAACQ,MAAb,GAAsB,SAAtB;AACA,MAAMM,QAAQ,GAAGd,YAAY,CAACM,SAA9B;;AACA,MAAI;AACA,QAAMS,CAAC,GAAGD,QAAQ,GAAGrC,SAAS,CAACqC,QAAD,EAAWD,IAAX,CAAZ,GAA+BhC,SAAjD;;AACA,YAAQgC,IAAR;AACI,WAAK,MAAL;AACI,YAAIE,CAAJ,EACIA,CAAC,CAACX,IAAF,CAAOU,QAAP,EAAiBlC,KAAjB;AACJ;;AACJ,WAAK,OAAL;AACIyB,QAAAA,iBAAiB,CAACL,YAAD,CAAjB;AACA,YAAIe,CAAJ,EACIA,CAAC,CAACX,IAAF,CAAOU,QAAP,EAAiBlC,KAAjB,EADJ,KAGI,MAAMA,KAAN;AACJ;;AACJ,WAAK,UAAL;AACIyB,QAAAA,iBAAiB,CAACL,YAAD,CAAjB;AACA,YAAIe,CAAJ,EACIA,CAAC,CAACX,IAAF,CAAOU,QAAP;AACJ;AAhBR;AAkBH,GApBD,CAqBA,OAAOhB,CAAP,EAAU;AACNT,IAAAA,eAAe,CAACS,CAAD,CAAf;AACH;;AACD,MAAIE,YAAY,CAACQ,MAAb,KAAwB,QAA5B,EAAsC;AAClCT,IAAAA,mBAAmB,CAACC,YAAD,CAAnB;AACH,GAFD,MAGK,IAAIA,YAAY,CAACQ,MAAb,KAAwB,SAA5B,EAAuC;AACxCR,IAAAA,YAAY,CAACQ,MAAb,GAAsB,OAAtB;AACH;AACJ;;AACD,SAASQ,QAAT,CAAkBhB,YAAlB,EAAgCa,IAAhC,EAAsCjC,KAAtC,EAA6C;AACzC,MAAIoB,YAAY,CAACQ,MAAb,KAAwB,QAA5B,EAAsC;AAClC;AACH;;AACD,MAAIR,YAAY,CAACQ,MAAb,KAAwB,WAA5B,EAAyC;AACrCR,IAAAA,YAAY,CAACO,MAAb,GAAsBP,YAAY,CAACO,MAAb,IAAuB,EAA7C;;AACAP,IAAAA,YAAY,CAACO,MAAb,CAAoBU,IAApB,CAAyB;AAAEJ,MAAAA,IAAI,EAAJA,IAAF;AAAQjC,MAAAA,KAAK,EAALA;AAAR,KAAzB;;AACA;AACH;;AACD,MAAIoB,YAAY,CAACQ,MAAb,KAAwB,OAA5B,EAAqC;AACjCR,IAAAA,YAAY,CAACQ,MAAb,GAAsB,WAAtB;AACAR,IAAAA,YAAY,CAACO,MAAb,GAAsB,CAAC;AAAEM,MAAAA,IAAI,EAAJA,IAAF;AAAQjC,MAAAA,KAAK,EAALA;AAAR,KAAD,CAAtB;AACAa,IAAAA,OAAO,CAAC;AAAA,aAAMgB,iBAAiB,CAACT,YAAD,CAAvB;AAAA,KAAD,CAAP;AACA;AACH;;AACDY,EAAAA,kBAAkB,CAACZ,YAAD,EAAea,IAAf,EAAqBjC,KAArB,CAAlB;AACH;;AACD,WAAasC,YAAb;AACI,wBAAYJ,QAAZ,EAAsBK,UAAtB,EAAkC;AAAA;;AAC9B;AACA;AACA,SAAKjB,QAAL,GAAgBrB,SAAhB;AACA,SAAKyB,SAAL,GAAiBQ,QAAjB;AACA,SAAKP,MAAL,GAAc1B,SAAd;AACA,SAAK2B,MAAL,GAAc,cAAd;AACA,QAAMY,oBAAoB,GAAG,IAAIC,oBAAJ,CAAyB,IAAzB,CAA7B;;AACA,QAAI;AACA,WAAKnB,QAAL,GAAgBiB,UAAU,CAACf,IAAX,CAAgBvB,SAAhB,EAA2BuC,oBAA3B,CAAhB;AACH,KAFD,CAGA,OAAOtB,CAAP,EAAU;AACNsB,MAAAA,oBAAoB,CAAC9B,KAArB,CAA2BQ,CAA3B;AACH;;AACD,QAAI,KAAKU,MAAL,KAAgB,cAApB,EAAoC;AAChC,WAAKA,MAAL,GAAc,OAAd;AACH;AACJ;;AAlBL;AAAA;AAAA,kCAsBkB;AACV,UAAI,KAAKA,MAAL,KAAgB,QAApB,EAA8B;AAC1BH,QAAAA,iBAAiB,CAAC,IAAD,CAAjB;AACAN,QAAAA,mBAAmB,CAAC,IAAD,CAAnB;AACH;AACJ;AA3BL;AAAA;AAAA,wBAmBiB;AACT,aAAO,KAAKS,MAAL,KAAgB,QAAvB;AACH;AArBL;;AAAA;AAAA;AA6BA,WAAaa,oBAAb;AACI,gCAAYrB,YAAZ,EAA0B;AAAA;;AAAE,SAAKsB,aAAL,GAAqBtB,YAArB;AAAoC;;AADpE;AAAA;AAAA,yBAGSpB,KAHT,EAGgB;AAAEoC,MAAAA,QAAQ,CAAC,KAAKM,aAAN,EAAqB,MAArB,EAA6B1C,KAA7B,CAAR;AAA8C;AAHhE;AAAA;AAAA,0BAIUA,KAJV,EAIiB;AAAEoC,MAAAA,QAAQ,CAAC,KAAKM,aAAN,EAAqB,OAArB,EAA8B1C,KAA9B,CAAR;AAA+C;AAJlE;AAAA;AAAA,+BAKe;AAAEoC,MAAAA,QAAQ,CAAC,KAAKM,aAAN,EAAqB,UAArB,CAAR;AAA2C;AAL5D;AAAA;AAAA,wBAEiB;AAAE,aAAO,KAAKA,aAAL,CAAmBd,MAAnB,KAA8B,QAArC;AAAgD;AAFnE;;AAAA;AAAA;AAOA;;;;;;AAKA,WAAatB,UAAb;AACI,sBAAYiC,UAAZ,EAAwB;AAAA;;AACpB,QAAI,EAAE,gBAAgBjC,UAAlB,CAAJ,EAAmC;AAC/B,YAAM,IAAIJ,SAAJ,CAAc,2CAAd,CAAN;AACH;;AACD,QAAI,OAAOqC,UAAP,KAAsB,UAA1B,EAAsC;AAClC,YAAM,IAAIrC,SAAJ,CAAc,2CAAd,CAAN;AACH;;AACD,SAAKyC,WAAL,GAAmBJ,UAAnB;AACH;;AATL;AAAA;AAAA,8BAUcK,cAVd,EAU8BC,OAV9B,EAUuCC,UAVvC,EAUmD;AAC3C,UAAI,OAAOF,cAAP,KAA0B,QAA1B,IAAsCA,cAAc,KAAK,IAA7D,EAAmE;AAC/DA,QAAAA,cAAc,GAAG;AACbG,UAAAA,IAAI,EAAEH,cADO;AAEblC,UAAAA,KAAK,EAAEmC,OAFM;AAGbG,UAAAA,QAAQ,EAAEF;AAHG,SAAjB;AAKH;;AACD,aAAO,IAAIR,YAAJ,CAAiBM,cAAjB,EAAiC,KAAKD,WAAtC,CAAP;AACH;AAnBL;AAAA;AAAA,yBAoBSM,KApBT,EAoB4B;AACpB;AACA,UAAIC,YAAY,GAAG,IAAnB;;AAFoB,wCAATC,OAAS;AAATA,QAAAA,OAAS;AAAA;;AAGpB,+BAAsBF,KAAtB,SAAgCE,OAAhC,2BAA0C;AAArC,YAAMC,MAAM,WAAZ;AACDF,QAAAA,YAAY,GAAGE,MAAM,CAACF,YAAD,CAArB;AACH;;AACD,aAAOA,YAAP;AACH;AA3BL;AAAA;AAAA,wBA4BQN,cA5BR,EA4BwBC,OA5BxB,EA4BiCC,UA5BjC,EA4B6C;AAAA;;AACrC,UAAMO,WAAW,GAAG,OAAOT,cAAP,KAA0B,QAA1B,IAAsCA,cAAc,KAAK,IAAzD,GACd;AACEG,QAAAA,IAAI,EAAEH,cADR;AAEElC,QAAAA,KAAK,EAAEmC,OAFT;AAGEG,QAAAA,QAAQ,EAAEF;AAHZ,OADc,GAMdF,cANN;AAOA,aAAO,IAAItC,UAAJ,CAAe,UAAA4B,QAAQ,EAAI;AAC9B,eAAO,KAAI,CAACoB,SAAL,CAAe;AAClBP,UAAAA,IADkB,gBACb/C,KADa,EACN;AACRqD,YAAAA,WAAW,CAACN,IAAZ,IAAoBM,WAAW,CAACN,IAAZ,CAAiB/C,KAAjB,CAApB;AACAkC,YAAAA,QAAQ,CAACa,IAAT,CAAc/C,KAAd;AACH,WAJiB;AAKlBU,UAAAA,KALkB,iBAKZA,MALY,EAKL;AACT2C,YAAAA,WAAW,CAAC3C,KAAZ,IAAqB2C,WAAW,CAAC3C,KAAZ,CAAkBA,MAAlB,CAArB;AACAwB,YAAAA,QAAQ,CAACxB,KAAT,CAAeA,MAAf;AACH,WARiB;AASlBsC,UAAAA,QATkB,sBASP;AACPK,YAAAA,WAAW,CAACL,QAAZ,IAAwBK,WAAW,CAACL,QAAZ,EAAxB;AACAd,YAAAA,QAAQ,CAACc,QAAT;AACH,WAZiB;AAalBO,UAAAA,KAbkB,iBAaZnC,YAbY,EAaE;AAChBiC,YAAAA,WAAW,CAACE,KAAZ,IAAqBF,WAAW,CAACE,KAAZ,CAAkBnC,YAAlB,CAArB;AACH;AAfiB,SAAf,CAAP;AAiBH,OAlBM,CAAP;AAmBH;AAvDL;AAAA;AAAA,4BAwDYN,EAxDZ,EAwDgB;AAAA;;AACR,aAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUwC,MAAV,EAAqB;AACpC,YAAI,OAAO1C,EAAP,KAAc,UAAlB,EAA8B;AAC1B0C,UAAAA,MAAM,CAAC,IAAItD,SAAJ,CAAcY,EAAE,GAAG,oBAAnB,CAAD,CAAN;AACA;AACH;;AACD,iBAAS2C,IAAT,GAAgB;AACZrC,UAAAA,YAAY,CAACG,WAAb;AACAP,UAAAA,OAAO,CAACf,SAAD,CAAP;AACH;;AACD,YAAMmB,YAAY,GAAG,MAAI,CAACkC,SAAL,CAAe;AAChCP,UAAAA,IADgC,gBAC3B/C,KAD2B,EACpB;AACR,gBAAI;AACAc,cAAAA,EAAE,CAACd,KAAD,EAAQyD,IAAR,CAAF;AACH,aAFD,CAGA,OAAOvC,CAAP,EAAU;AACNsC,cAAAA,MAAM,CAACtC,CAAD,CAAN;AACAE,cAAAA,YAAY,CAACG,WAAb;AACH;AACJ,WAT+B;AAUhCb,UAAAA,KAVgC,iBAU1BA,OAV0B,EAUnB;AACT8C,YAAAA,MAAM,CAAC9C,OAAD,CAAN;AACH,WAZ+B;AAahCsC,UAAAA,QAbgC,sBAarB;AACPhC,YAAAA,OAAO,CAACf,SAAD,CAAP;AACH;AAf+B,SAAf,CAArB;AAiBH,OA1BM,CAAP;AA2BH;AApFL;AAAA;AAAA,wBAqFQa,EArFR,EAqFY;AAAA;;AACJ,UAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAC1B,cAAM,IAAIZ,SAAJ,CAAcY,EAAE,GAAG,oBAAnB,CAAN;AACH;;AACD,UAAM4C,CAAC,GAAGvD,UAAU,CAAC,IAAD,CAApB;AACA,aAAO,IAAIuD,CAAJ,CAAM,UAAAxB,QAAQ;AAAA,eAAI,MAAI,CAACoB,SAAL,CAAe;AACpCP,UAAAA,IADoC,gBAC/B/C,KAD+B,EACxB;AACR,gBAAI2D,eAAe,GAAG3D,KAAtB;;AACA,gBAAI;AACA2D,cAAAA,eAAe,GAAG7C,EAAE,CAACd,KAAD,CAApB;AACH,aAFD,CAGA,OAAOkB,CAAP,EAAU;AACN,qBAAOgB,QAAQ,CAACxB,KAAT,CAAeQ,CAAf,CAAP;AACH;;AACDgB,YAAAA,QAAQ,CAACa,IAAT,CAAcY,eAAd;AACH,WAVmC;AAWpCjD,UAAAA,KAXoC,iBAW9BQ,CAX8B,EAW3B;AAAEgB,YAAAA,QAAQ,CAACxB,KAAT,CAAeQ,CAAf;AAAoB,WAXK;AAYpC8B,UAAAA,QAZoC,sBAYzB;AAAEd,YAAAA,QAAQ,CAACc,QAAT;AAAsB;AAZC,SAAf,CAAJ;AAAA,OAAd,CAAP;AAcH;AAxGL;AAAA;AAAA,2BAyGWlC,EAzGX,EAyGe;AAAA;;AACP,UAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAC1B,cAAM,IAAIZ,SAAJ,CAAcY,EAAE,GAAG,oBAAnB,CAAN;AACH;;AACD,UAAM4C,CAAC,GAAGvD,UAAU,CAAC,IAAD,CAApB;AACA,aAAO,IAAIuD,CAAJ,CAAM,UAAAxB,QAAQ;AAAA,eAAI,MAAI,CAACoB,SAAL,CAAe;AACpCP,UAAAA,IADoC,gBAC/B/C,KAD+B,EACxB;AACR,gBAAI;AACA,kBAAI,CAACc,EAAE,CAACd,KAAD,CAAP,EACI;AACP,aAHD,CAIA,OAAOkB,CAAP,EAAU;AACN,qBAAOgB,QAAQ,CAACxB,KAAT,CAAeQ,CAAf,CAAP;AACH;;AACDgB,YAAAA,QAAQ,CAACa,IAAT,CAAc/C,KAAd;AACH,WAVmC;AAWpCU,UAAAA,KAXoC,iBAW9BQ,CAX8B,EAW3B;AAAEgB,YAAAA,QAAQ,CAACxB,KAAT,CAAeQ,CAAf;AAAoB,WAXK;AAYpC8B,UAAAA,QAZoC,sBAYzB;AAAEd,YAAAA,QAAQ,CAACc,QAAT;AAAsB;AAZC,SAAf,CAAJ;AAAA,OAAd,CAAP;AAcH;AA5HL;AAAA;AAAA,2BA6HWlC,EA7HX,EA6He8C,IA7Hf,EA6HqB;AAAA;;AACb,UAAI,OAAO9C,EAAP,KAAc,UAAlB,EAA8B;AAC1B,cAAM,IAAIZ,SAAJ,CAAcY,EAAE,GAAG,oBAAnB,CAAN;AACH;;AACD,UAAM4C,CAAC,GAAGvD,UAAU,CAAC,IAAD,CAApB;AACA,UAAM0D,OAAO,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnC;AACA,UAAIC,QAAQ,GAAG,KAAf;AACA,UAAIC,GAAG,GAAGL,IAAV;AACA,aAAO,IAAIF,CAAJ,CAAM,UAAAxB,QAAQ;AAAA,eAAI,MAAI,CAACoB,SAAL,CAAe;AACpCP,UAAAA,IADoC,gBAC/B/C,KAD+B,EACxB;AACR,gBAAMiD,KAAK,GAAG,CAACe,QAAf;AACAA,YAAAA,QAAQ,GAAG,IAAX;;AACA,gBAAI,CAACf,KAAD,IAAUY,OAAd,EAAuB;AACnB,kBAAI;AACAI,gBAAAA,GAAG,GAAGnD,EAAE,CAACmD,GAAD,EAAMjE,KAAN,CAAR;AACH,eAFD,CAGA,OAAOkB,CAAP,EAAU;AACN,uBAAOgB,QAAQ,CAACxB,KAAT,CAAeQ,CAAf,CAAP;AACH;AACJ,aAPD,MAQK;AACD+C,cAAAA,GAAG,GAAGjE,KAAN;AACH;AACJ,WAfmC;AAgBpCU,UAAAA,KAhBoC,iBAgB9BQ,CAhB8B,EAgB3B;AAAEgB,YAAAA,QAAQ,CAACxB,KAAT,CAAeQ,CAAf;AAAoB,WAhBK;AAiBpC8B,UAAAA,QAjBoC,sBAiBzB;AACP,gBAAI,CAACgB,QAAD,IAAa,CAACH,OAAlB,EAA2B;AACvB,qBAAO3B,QAAQ,CAACxB,KAAT,CAAe,IAAIR,SAAJ,CAAc,iCAAd,CAAf,CAAP;AACH;;AACDgC,YAAAA,QAAQ,CAACa,IAAT,CAAckB,GAAd;AACA/B,YAAAA,QAAQ,CAACc,QAAT;AACH;AAvBmC,SAAf,CAAJ;AAAA,OAAd,CAAP;AAyBH;AA9JL;AAAA;AAAA,6BA+JuB;AAAA;;AAAA,yCAATkB,OAAS;AAATA,QAAAA,OAAS;AAAA;;AACf,UAAMR,CAAC,GAAGvD,UAAU,CAAC,IAAD,CAApB;AACA,aAAO,IAAIuD,CAAJ,CAAM,UAAAxB,QAAQ,EAAI;AACrB,YAAId,YAAJ;AACA,YAAI+C,KAAK,GAAG,CAAZ;;AACA,iBAASC,SAAT,CAAmBrB,IAAnB,EAAyB;AACrB3B,UAAAA,YAAY,GAAG2B,IAAI,CAACO,SAAL,CAAe;AAC1BP,YAAAA,IAD0B,gBACrBsB,CADqB,EAClB;AAAEnC,cAAAA,QAAQ,CAACa,IAAT,CAAcsB,CAAd;AAAmB,aADH;AAE1B3D,YAAAA,KAF0B,iBAEpBQ,CAFoB,EAEjB;AAAEgB,cAAAA,QAAQ,CAACxB,KAAT,CAAeQ,CAAf;AAAoB,aAFL;AAG1B8B,YAAAA,QAH0B,sBAGf;AACP,kBAAImB,KAAK,KAAKD,OAAO,CAACH,MAAtB,EAA8B;AAC1B3C,gBAAAA,YAAY,GAAGnB,SAAf;AACAiC,gBAAAA,QAAQ,CAACc,QAAT;AACH,eAHD,MAIK;AACDoB,gBAAAA,SAAS,CAACV,CAAC,CAACY,IAAF,CAAOJ,OAAO,CAACC,KAAK,EAAN,CAAd,CAAD,CAAT;AACH;AACJ;AAXyB,WAAf,CAAf;AAaH;;AACDC,QAAAA,SAAS,CAAC,MAAD,CAAT;AACA,eAAO,YAAM;AACT,cAAIhD,YAAJ,EAAkB;AACdA,YAAAA,YAAY,CAACG,WAAb;AACAH,YAAAA,YAAY,GAAGnB,SAAf;AACH;AACJ,SALD;AAMH,OAzBM,CAAP;AA0BH;AA3LL;AAAA;AAAA,4BA4LYa,EA5LZ,EA4LgB;AAAA;;AACR,UAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAC1B,cAAM,IAAIZ,SAAJ,CAAcY,EAAE,GAAG,oBAAnB,CAAN;AACH;;AACD,UAAM4C,CAAC,GAAGvD,UAAU,CAAC,IAAD,CAApB;AACA,aAAO,IAAIuD,CAAJ,CAAM,UAAAxB,QAAQ,EAAI;AACrB,YAAMqC,aAAa,GAAG,EAAtB;;AACA,YAAMC,KAAK,GAAG,MAAI,CAAClB,SAAL,CAAe;AACzBP,UAAAA,IADyB,gBACpB/C,KADoB,EACb;AACR,gBAAIyE,eAAJ;;AACA,gBAAI3D,EAAJ,EAAQ;AACJ,kBAAI;AACA2D,gBAAAA,eAAe,GAAG3D,EAAE,CAACd,KAAD,CAApB;AACH,eAFD,CAGA,OAAOkB,CAAP,EAAU;AACN,uBAAOgB,QAAQ,CAACxB,KAAT,CAAeQ,CAAf,CAAP;AACH;AACJ,aAPD,MAQK;AACDuD,cAAAA,eAAe,GAAGzE,KAAlB;AACH;;AACD,gBAAM0E,KAAK,GAAGhB,CAAC,CAACY,IAAF,CAAOG,eAAP,EAAwBnB,SAAxB,CAAkC;AAC5CP,cAAAA,IAD4C,gBACvC4B,UADuC,EAC3B;AAAEzC,gBAAAA,QAAQ,CAACa,IAAT,CAAc4B,UAAd;AAA4B,eADH;AAE5CjE,cAAAA,KAF4C,iBAEtCQ,CAFsC,EAEnC;AAAEgB,gBAAAA,QAAQ,CAACxB,KAAT,CAAeQ,CAAf;AAAoB,eAFa;AAG5C8B,cAAAA,QAH4C,sBAGjC;AACP,oBAAM4B,CAAC,GAAGL,aAAa,CAACM,OAAd,CAAsBH,KAAtB,CAAV;AACA,oBAAIE,CAAC,IAAI,CAAT,EACIL,aAAa,CAACO,MAAd,CAAqBF,CAArB,EAAwB,CAAxB;AACJG,gBAAAA,cAAc;AACjB;AAR2C,aAAlC,CAAd;AAUAR,YAAAA,aAAa,CAAClC,IAAd,CAAmBqC,KAAnB;AACH,WAzBwB;AA0BzBhE,UAAAA,KA1ByB,iBA0BnBQ,CA1BmB,EA0BhB;AAAEgB,YAAAA,QAAQ,CAACxB,KAAT,CAAeQ,CAAf;AAAoB,WA1BN;AA2BzB8B,UAAAA,QA3ByB,sBA2Bd;AAAE+B,YAAAA,cAAc;AAAK;AA3BP,SAAf,CAAd;;AA6BA,iBAASA,cAAT,GAA0B;AACtB,cAAIP,KAAK,CAACQ,MAAN,IAAgBT,aAAa,CAACR,MAAd,KAAyB,CAA7C,EAAgD;AAC5C7B,YAAAA,QAAQ,CAACc,QAAT;AACH;AACJ;;AACD,eAAO,YAAM;AACTuB,UAAAA,aAAa,CAACU,OAAd,CAAsB,UAAAC,CAAC;AAAA,mBAAIA,CAAC,CAAC3D,WAAF,EAAJ;AAAA,WAAvB;AACAiD,UAAAA,KAAK,CAACjD,WAAN;AACH,SAHD;AAIH,OAxCM,CAAP;AAyCH;AA1OL;AAAA,UA2OM4D,MAAM,CAACC,UAAP,EAAmBzF,gBA3OzB;AAAA,4BA2O8C;AAAE,aAAO,IAAP;AAAc;AA3O9D;AAAA;AAAA,yBA4OgBa,CA5OhB,EA4OmB;AACX,UAAMkD,CAAC,GAAI,OAAO,IAAP,KAAgB,UAAhB,GAA6B,IAA7B,GAAoCpD,UAA/C;;AACA,UAAIE,CAAC,IAAI,IAAT,EAAe;AACX,cAAM,IAAIN,SAAJ,CAAcM,CAAC,GAAG,mBAAlB,CAAN;AACH;;AACD,UAAM6E,gBAAgB,GAAGxF,SAAS,CAACW,CAAD,EAAIb,gBAAJ,CAAlC;;AACA,UAAI0F,gBAAJ,EAAsB;AAClB,YAAMD,UAAU,GAAGC,gBAAgB,CAAC7D,IAAjB,CAAsBhB,CAAtB,CAAnB;;AACA,YAAI8E,MAAM,CAACF,UAAD,CAAN,KAAuBA,UAA3B,EAAuC;AACnC,gBAAM,IAAIlF,SAAJ,CAAckF,UAAU,GAAG,mBAA3B,CAAN;AACH;;AACD,YAAI7E,YAAY,CAAC6E,UAAD,CAAZ,IAA4BA,UAAU,CAAC/E,WAAX,KAA2BqD,CAA3D,EAA8D;AAC1D,iBAAO0B,UAAP;AACH;;AACD,eAAO,IAAI1B,CAAJ,CAAM,UAAAxB,QAAQ;AAAA,iBAAIkD,UAAU,CAAC9B,SAAX,CAAqBpB,QAArB,CAAJ;AAAA,SAAd,CAAP;AACH;;AACD,UAAI1C,SAAS,CAAC,UAAD,CAAb,EAA2B;AACvB,YAAM+F,cAAc,GAAG1F,SAAS,CAACW,CAAD,EAAId,cAAJ,CAAhC;;AACA,YAAI6F,cAAJ,EAAoB;AAChB,iBAAO,IAAI7B,CAAJ,CAAM,UAAAxB,QAAQ,EAAI;AACrBrB,YAAAA,OAAO,CAAC,YAAM;AACV,kBAAIqB,QAAQ,CAAC8C,MAAb,EACI;;AAFM,0DAGSO,cAAc,CAAC/D,IAAf,CAAoBhB,CAApB,CAHT;AAAA;;AAAA;AAGV,uEAA2C;AAAA,sBAAhCuB,IAAgC;AACvCG,kBAAAA,QAAQ,CAACa,IAAT,CAAchB,IAAd;AACA,sBAAIG,QAAQ,CAAC8C,MAAb,EACI;AACP;AAPS;AAAA;AAAA;AAAA;AAAA;;AAQV9C,cAAAA,QAAQ,CAACc,QAAT;AACH,aATM,CAAP;AAUH,WAXM,CAAP;AAYH;AACJ;;AACD,UAAIwC,KAAK,CAACC,OAAN,CAAcjF,CAAd,CAAJ,EAAsB;AAClB,eAAO,IAAIkD,CAAJ,CAAM,UAAAxB,QAAQ,EAAI;AACrBrB,UAAAA,OAAO,CAAC,YAAM;AACV,gBAAIqB,QAAQ,CAAC8C,MAAb,EACI;;AAFM,wDAGSxE,CAHT;AAAA;;AAAA;AAGV,qEAAsB;AAAA,oBAAXuB,IAAW;AAClBG,gBAAAA,QAAQ,CAACa,IAAT,CAAchB,IAAd;AACA,oBAAIG,QAAQ,CAAC8C,MAAb,EACI;AACP;AAPS;AAAA;AAAA;AAAA;AAAA;;AAQV9C,YAAAA,QAAQ,CAACc,QAAT;AACH,WATM,CAAP;AAUH,SAXM,CAAP;AAYH;;AACD,YAAM,IAAI9C,SAAJ,CAAcM,CAAC,GAAG,oBAAlB,CAAN;AACH;AA5RL;AAAA;AAAA,yBA6RwB;AAAA,yCAAPkF,KAAO;AAAPA,QAAAA,KAAO;AAAA;;AAChB,UAAMhC,CAAC,GAAI,OAAO,IAAP,KAAgB,UAAhB,GAA6B,IAA7B,GAAoCpD,UAA/C;AACA,aAAO,IAAIoD,CAAJ,CAAM,UAAAxB,QAAQ,EAAI;AACrBrB,QAAAA,OAAO,CAAC,YAAM;AACV,cAAIqB,QAAQ,CAAC8C,MAAb,EACI;;AAFM,sDAGSU,KAHT;AAAA;;AAAA;AAGV,mEAA0B;AAAA,kBAAf3D,IAAe;AACtBG,cAAAA,QAAQ,CAACa,IAAT,CAAchB,IAAd;AACA,kBAAIG,QAAQ,CAAC8C,MAAb,EACI;AACP;AAPS;AAAA;AAAA;AAAA;AAAA;;AAQV9C,UAAAA,QAAQ,CAACc,QAAT;AACH,SATM,CAAP;AAUH,OAXM,CAAP;AAYH;AA3SL;AAAA,SA4SgBpD,aA5ShB;AAAA,wBA4SiC;AAAE,aAAO,IAAP;AAAc;AA5SjD;;AAAA;AAAA;;AA8SA,IAAIH,UAAU,EAAd,EAAkB;AACd6F,EAAAA,MAAM,CAACK,cAAP,CAAsBrF,UAAtB,EAAkC6E,MAAM,CAAC,YAAD,CAAxC,EAAwD;AACpDnF,IAAAA,KAAK,EAAE;AACH4F,MAAAA,MAAM,EAAEjG,gBADL;AAEHc,MAAAA,eAAe,EAAfA;AAFG,KAD6C;AAKpDoF,IAAAA,YAAY,EAAE;AALsC,GAAxD;AAOH;;AACD,eAAevF,UAAf","sourcesContent":["/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n    const value = obj[key];\n    if (value == null) {\n        return undefined;\n    }\n    if (typeof value !== \"function\") {\n        throw new TypeError(value + \" is not a function\");\n    }\n    return value;\n}\nfunction getSpecies(obj) {\n    let ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(error) {\n    if (hostReportError.log) {\n        hostReportError.log(error);\n    }\n    else {\n        setTimeout(() => { throw error; }, 0);\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(() => {\n        try {\n            fn();\n        }\n        catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    const cleanup = subscription._cleanup;\n    if (cleanup === undefined) {\n        return;\n    }\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        }\n        else {\n            const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    const queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for (const item of queue) {\n        notifySubscription(subscription, item.type, item.value);\n        if (subscription._state === \"closed\") {\n            break;\n        }\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    const observer = subscription._observer;\n    try {\n        const m = observer ? getMethod(observer, type) : undefined;\n        switch (type) {\n            case \"next\":\n                if (m)\n                    m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer, value);\n                else\n                    throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer);\n                break;\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") {\n        cleanupSubscription(subscription);\n    }\n    else if (subscription._state === \"running\") {\n        subscription._state = \"ready\";\n    }\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") {\n        return;\n    }\n    if (subscription._state === \"buffering\") {\n        subscription._queue = subscription._queue || [];\n        subscription._queue.push({ type, value });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [{ type, value }];\n        enqueue(() => flushSubscription(subscription));\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nexport class Subscription {\n    constructor(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        const subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        }\n        catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") {\n            this._state = \"ready\";\n        }\n    }\n    get closed() {\n        return this._state === \"closed\";\n    }\n    unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    }\n}\nexport class SubscriptionObserver {\n    constructor(subscription) { this._subscription = subscription; }\n    get closed() { return this._subscription._state === \"closed\"; }\n    next(value) { onNotify(this._subscription, \"next\", value); }\n    error(value) { onNotify(this._subscription, \"error\", value); }\n    complete() { onNotify(this._subscription, \"complete\"); }\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nexport class Observable {\n    constructor(subscriber) {\n        if (!(this instanceof Observable)) {\n            throw new TypeError(\"Observable cannot be called as a function\");\n        }\n        if (typeof subscriber !== \"function\") {\n            throw new TypeError(\"Observable initializer must be a function\");\n        }\n        this._subscriber = subscriber;\n    }\n    subscribe(nextOrObserver, onError, onComplete) {\n        if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n            nextOrObserver = {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            };\n        }\n        return new Subscription(nextOrObserver, this._subscriber);\n    }\n    pipe(first, ...mappers) {\n        // tslint:disable-next-line no-this-assignment\n        let intermediate = this;\n        for (const mapper of [first, ...mappers]) {\n            intermediate = mapper(intermediate);\n        }\n        return intermediate;\n    }\n    tap(nextOrObserver, onError, onComplete) {\n        const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null\n            ? {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            }\n            : nextOrObserver;\n        return new Observable(observer => {\n            return this.subscribe({\n                next(value) {\n                    tapObserver.next && tapObserver.next(value);\n                    observer.next(value);\n                },\n                error(error) {\n                    tapObserver.error && tapObserver.error(error);\n                    observer.error(error);\n                },\n                complete() {\n                    tapObserver.complete && tapObserver.complete();\n                    observer.complete();\n                },\n                start(subscription) {\n                    tapObserver.start && tapObserver.start(subscription);\n                }\n            });\n        });\n    }\n    forEach(fn) {\n        return new Promise((resolve, reject) => {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve(undefined);\n            }\n            const subscription = this.subscribe({\n                next(value) {\n                    try {\n                        fn(value, done);\n                    }\n                    catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error(error) {\n                    reject(error);\n                },\n                complete() {\n                    resolve(undefined);\n                }\n            });\n        });\n    }\n    map(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                let propagatedValue = value;\n                try {\n                    propagatedValue = fn(value);\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(propagatedValue);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    filter(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                try {\n                    if (!fn(value))\n                        return;\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(value);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    reduce(fn, seed) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        const hasSeed = arguments.length > 1;\n        let hasValue = false;\n        let acc = seed;\n        return new C(observer => this.subscribe({\n            next(value) {\n                const first = !hasValue;\n                hasValue = true;\n                if (!first || hasSeed) {\n                    try {\n                        acc = fn(acc, value);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                }\n                else {\n                    acc = value;\n                }\n            },\n            error(e) { observer.error(e); },\n            complete() {\n                if (!hasValue && !hasSeed) {\n                    return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                }\n                observer.next(acc);\n                observer.complete();\n            },\n        }));\n    }\n    concat(...sources) {\n        const C = getSpecies(this);\n        return new C(observer => {\n            let subscription;\n            let index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next(v) { observer.next(v); },\n                    error(e) { observer.error(e); },\n                    complete() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        }\n                        else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    },\n                });\n            }\n            startNext(this);\n            return () => {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    }\n    flatMap(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => {\n            const subscriptions = [];\n            const outer = this.subscribe({\n                next(value) {\n                    let normalizedValue;\n                    if (fn) {\n                        try {\n                            normalizedValue = fn(value);\n                        }\n                        catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    else {\n                        normalizedValue = value;\n                    }\n                    const inner = C.from(normalizedValue).subscribe({\n                        next(innerValue) { observer.next(innerValue); },\n                        error(e) { observer.error(e); },\n                        complete() {\n                            const i = subscriptions.indexOf(inner);\n                            if (i >= 0)\n                                subscriptions.splice(i, 1);\n                            completeIfDone();\n                        },\n                    });\n                    subscriptions.push(inner);\n                },\n                error(e) { observer.error(e); },\n                complete() { completeIfDone(); },\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) {\n                    observer.complete();\n                }\n            }\n            return () => {\n                subscriptions.forEach(s => s.unsubscribe());\n                outer.unsubscribe();\n            };\n        });\n    }\n    [(Symbol.observable, SymbolObservable)]() { return this; }\n    static from(x) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        if (x == null) {\n            throw new TypeError(x + \" is not an object\");\n        }\n        const observableMethod = getMethod(x, SymbolObservable);\n        if (observableMethod) {\n            const observable = observableMethod.call(x);\n            if (Object(observable) !== observable) {\n                throw new TypeError(observable + \" is not an object\");\n            }\n            if (isObservable(observable) && observable.constructor === C) {\n                return observable;\n            }\n            return new C(observer => observable.subscribe(observer));\n        }\n        if (hasSymbol(\"iterator\")) {\n            const iteratorMethod = getMethod(x, SymbolIterator);\n            if (iteratorMethod) {\n                return new C(observer => {\n                    enqueue(() => {\n                        if (observer.closed)\n                            return;\n                        for (const item of iteratorMethod.call(x)) {\n                            observer.next(item);\n                            if (observer.closed)\n                                return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(observer => {\n                enqueue(() => {\n                    if (observer.closed)\n                        return;\n                    for (const item of x) {\n                        observer.next(item);\n                        if (observer.closed)\n                            return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    }\n    static of(...items) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        return new C(observer => {\n            enqueue(() => {\n                if (observer.closed)\n                    return;\n                for (const item of items) {\n                    observer.next(item);\n                    if (observer.closed)\n                        return;\n                }\n                observer.complete();\n            });\n        });\n    }\n    static get [SymbolSpecies]() { return this; }\n}\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError,\n        },\n        configurable: true,\n    });\n}\nexport default Observable;\n"]},"metadata":{},"sourceType":"module"}