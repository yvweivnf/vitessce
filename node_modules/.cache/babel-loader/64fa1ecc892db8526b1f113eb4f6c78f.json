{"ast":null,"code":"import * as log from '../../../log';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nexport function color(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    filled: undefined\n  };\n\n  var _a, _b, _c, _d;\n\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config;\n  var markType = markDef.type; // Allow filled to be overridden (for trail's \"filled\")\n\n  var filled = (_a = opt.filled) !== null && _a !== void 0 ? _a : getMarkPropOrConfig('filled', markDef, config);\n  var transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType) ? 'transparent' : undefined;\n  var defaultFill = (_c = (_b = getMarkPropOrConfig(filled === true ? 'color' : undefined, markDef, config, {\n    vgChannel: 'fill'\n  })) !== null && _b !== void 0 ? _b : // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n  config.mark[filled === true && 'color']) !== null && _c !== void 0 ? _c : // If there is no fill, always fill symbols, bar, geoshape\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  transparentIfNeeded;\n  var defaultStroke = (_d = getMarkPropOrConfig(filled === false ? 'color' : undefined, markDef, config, {\n    vgChannel: 'stroke'\n  })) !== null && _d !== void 0 ? _d : // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n  config.mark[filled === false && 'color'];\n  var colorVgChannel = filled ? 'fill' : 'stroke';\n  var fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? {\n    fill: signalOrValueRef(defaultFill)\n  } : {}), defaultStroke ? {\n    stroke: signalOrValueRef(defaultStroke)\n  } : {});\n\n  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {\n    log.warn(log.message.droppingColor('property', {\n      fill: 'fill' in markDef,\n      stroke: 'stroke' in markDef\n    }));\n  }\n\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition('color', model, {\n    vgChannel: colorVgChannel,\n    defaultValue: filled ? defaultFill : defaultStroke\n  })), nonPosition('fill', model, {\n    // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding\n    defaultValue: encoding.fill ? defaultFill : undefined\n  })), nonPosition('stroke', model, {\n    // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding\n    defaultValue: encoding.stroke ? defaultStroke : undefined\n  }));\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/color.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../../../log';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nexport function color(model, opt = { filled: undefined }) {\n    var _a, _b, _c, _d;\n    const { markDef, encoding, config } = model;\n    const { type: markType } = markDef;\n    // Allow filled to be overridden (for trail's \"filled\")\n    const filled = (_a = opt.filled) !== null && _a !== void 0 ? _a : getMarkPropOrConfig('filled', markDef, config);\n    const transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType)\n        ? 'transparent'\n        : undefined;\n    const defaultFill = (_c = (_b = getMarkPropOrConfig(filled === true ? 'color' : undefined, markDef, config, { vgChannel: 'fill' })) !== null && _b !== void 0 ? _b : \n    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n    config.mark[filled === true && 'color']) !== null && _c !== void 0 ? _c : \n    // If there is no fill, always fill symbols, bar, geoshape\n    // with transparent fills https://github.com/vega/vega-lite/issues/1316\n    transparentIfNeeded;\n    const defaultStroke = (_d = getMarkPropOrConfig(filled === false ? 'color' : undefined, markDef, config, { vgChannel: 'stroke' })) !== null && _d !== void 0 ? _d : \n    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n    config.mark[filled === false && 'color'];\n    const colorVgChannel = filled ? 'fill' : 'stroke';\n    const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, (defaultFill ? { fill: signalOrValueRef(defaultFill) } : {})), (defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {}));\n    if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {\n        log.warn(log.message.droppingColor('property', { fill: 'fill' in markDef, stroke: 'stroke' in markDef }));\n    }\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition('color', model, {\n        vgChannel: colorVgChannel,\n        defaultValue: filled ? defaultFill : defaultStroke\n    })), nonPosition('fill', model, {\n        // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding\n        defaultValue: encoding.fill ? defaultFill : undefined\n    })), nonPosition('stroke', model, {\n        // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding\n        defaultValue: encoding.stroke ? defaultStroke : undefined\n    }));\n}\n//# sourceMappingURL=color.js.map"]},"metadata":{},"sourceType":"module"}