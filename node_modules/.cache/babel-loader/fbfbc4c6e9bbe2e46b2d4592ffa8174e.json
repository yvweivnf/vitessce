{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport DebugLogger from \"debug\";\nimport { Observable } from \"observable-fns\";\nimport { deserialize } from \"../common\";\nimport { createPromiseWithResolver } from \"../promise\";\nimport { $errors, $events, $terminate, $worker } from \"../symbols\";\nimport { WorkerEventType } from \"../types/master\";\nimport { createProxyFunction, createProxyModule } from \"./invocation-proxy\";\nconst debugMessages = DebugLogger(\"threads:master:messages\");\nconst debugSpawn = DebugLogger(\"threads:master:spawn\");\nconst debugThreadUtils = DebugLogger(\"threads:master:thread-utils\");\n\nconst isInitMessage = data => data && data.type === \"init\";\n\nconst isUncaughtErrorMessage = data => data && data.type === \"uncaughtError\";\n\nconst initMessageTimeout = typeof process !== \"undefined\" && process.env.THREADS_WORKER_INIT_TIMEOUT ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10) : 10000;\n\nfunction withTimeout(promise, timeoutInMs, errorMessage) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let timeoutHandle;\n    const timeout = new Promise((resolve, reject) => {\n      timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);\n    });\n    const result = yield Promise.race([promise, timeout]);\n    clearTimeout(timeoutHandle);\n    return result;\n  });\n}\n\nfunction receiveInitMessage(worker) {\n  return new Promise((resolve, reject) => {\n    const messageHandler = event => {\n      debugMessages(\"Message from worker before finishing initialization:\", event.data);\n\n      if (isInitMessage(event.data)) {\n        worker.removeEventListener(\"message\", messageHandler);\n        resolve(event.data);\n      } else if (isUncaughtErrorMessage(event.data)) {\n        worker.removeEventListener(\"message\", messageHandler);\n        reject(deserialize(event.data.error));\n      }\n    };\n\n    worker.addEventListener(\"message\", messageHandler);\n  });\n}\n\nfunction createEventObservable(worker, workerTermination) {\n  return new Observable(observer => {\n    const messageHandler = messageEvent => {\n      const workerEvent = {\n        type: WorkerEventType.message,\n        data: messageEvent.data\n      };\n      observer.next(workerEvent);\n    };\n\n    const rejectionHandler = errorEvent => {\n      debugThreadUtils(\"Unhandled promise rejection event in thread:\", errorEvent);\n      const workerEvent = {\n        type: WorkerEventType.internalError,\n        error: Error(errorEvent.reason)\n      };\n      observer.next(workerEvent);\n    };\n\n    worker.addEventListener(\"message\", messageHandler);\n    worker.addEventListener(\"unhandledrejection\", rejectionHandler);\n    workerTermination.then(() => {\n      const terminationEvent = {\n        type: WorkerEventType.termination\n      };\n      worker.removeEventListener(\"message\", messageHandler);\n      worker.removeEventListener(\"unhandledrejection\", rejectionHandler);\n      observer.next(terminationEvent);\n      observer.complete();\n    });\n  });\n}\n\nfunction createTerminator(worker) {\n  const [termination, resolver] = createPromiseWithResolver();\n\n  const terminate = () => __awaiter(this, void 0, void 0, function* () {\n    debugThreadUtils(\"Terminating worker\"); // Newer versions of worker_threads workers return a promise\n\n    yield worker.terminate();\n    resolver();\n  });\n\n  return {\n    terminate,\n    termination\n  };\n}\n\nfunction setPrivateThreadProps(raw, worker, workerEvents, terminate) {\n  const workerErrors = workerEvents.filter(event => event.type === WorkerEventType.internalError).map(errorEvent => errorEvent.error); // tslint:disable-next-line prefer-object-spread\n\n  return Object.assign(raw, {\n    [$errors]: workerErrors,\n    [$events]: workerEvents,\n    [$terminate]: terminate,\n    [$worker]: worker\n  });\n}\n/**\n * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin\n * abstraction layer to provide the transparent API and verifies that\n * the worker has initialized successfully.\n *\n * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.\n * @param [options]\n * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.\n */\n\n\nexport function spawn(worker, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    debugSpawn(\"Initializing new thread\");\n    const timeout = options && options.timeout ? options.timeout : initMessageTimeout;\n    const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);\n    const exposed = initMessage.exposed;\n    const {\n      termination,\n      terminate\n    } = createTerminator(worker);\n    const events = createEventObservable(worker, termination);\n\n    if (exposed.type === \"function\") {\n      const proxy = createProxyFunction(worker);\n      return setPrivateThreadProps(proxy, worker, events, terminate);\n    } else if (exposed.type === \"module\") {\n      const proxy = createProxyModule(worker, exposed.methods);\n      return setPrivateThreadProps(proxy, worker, events, terminate);\n    } else {\n      const type = exposed.type;\n      throw Error(`Worker init message states unexpected type of expose(): ${type}`);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/master/spawn.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","DebugLogger","Observable","deserialize","createPromiseWithResolver","$errors","$events","$terminate","$worker","WorkerEventType","createProxyFunction","createProxyModule","debugMessages","debugSpawn","debugThreadUtils","isInitMessage","data","type","isUncaughtErrorMessage","initMessageTimeout","process","env","THREADS_WORKER_INIT_TIMEOUT","Number","parseInt","withTimeout","promise","timeoutInMs","errorMessage","timeoutHandle","timeout","setTimeout","Error","race","clearTimeout","receiveInitMessage","worker","messageHandler","event","removeEventListener","error","addEventListener","createEventObservable","workerTermination","observer","messageEvent","workerEvent","message","rejectionHandler","errorEvent","internalError","reason","terminationEvent","termination","complete","createTerminator","resolver","terminate","setPrivateThreadProps","raw","workerEvents","workerErrors","filter","map","Object","assign","spawn","options","initMessage","exposed","events","proxy","methods"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DebugLogger from \"debug\";\nimport { Observable } from \"observable-fns\";\nimport { deserialize } from \"../common\";\nimport { createPromiseWithResolver } from \"../promise\";\nimport { $errors, $events, $terminate, $worker } from \"../symbols\";\nimport { WorkerEventType } from \"../types/master\";\nimport { createProxyFunction, createProxyModule } from \"./invocation-proxy\";\nconst debugMessages = DebugLogger(\"threads:master:messages\");\nconst debugSpawn = DebugLogger(\"threads:master:spawn\");\nconst debugThreadUtils = DebugLogger(\"threads:master:thread-utils\");\nconst isInitMessage = (data) => data && data.type === \"init\";\nconst isUncaughtErrorMessage = (data) => data && data.type === \"uncaughtError\";\nconst initMessageTimeout = typeof process !== \"undefined\" && process.env.THREADS_WORKER_INIT_TIMEOUT\n    ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10)\n    : 10000;\nfunction withTimeout(promise, timeoutInMs, errorMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let timeoutHandle;\n        const timeout = new Promise((resolve, reject) => {\n            timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);\n        });\n        const result = yield Promise.race([\n            promise,\n            timeout\n        ]);\n        clearTimeout(timeoutHandle);\n        return result;\n    });\n}\nfunction receiveInitMessage(worker) {\n    return new Promise((resolve, reject) => {\n        const messageHandler = ((event) => {\n            debugMessages(\"Message from worker before finishing initialization:\", event.data);\n            if (isInitMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                resolve(event.data);\n            }\n            else if (isUncaughtErrorMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                reject(deserialize(event.data.error));\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n    });\n}\nfunction createEventObservable(worker, workerTermination) {\n    return new Observable(observer => {\n        const messageHandler = ((messageEvent) => {\n            const workerEvent = {\n                type: WorkerEventType.message,\n                data: messageEvent.data\n            };\n            observer.next(workerEvent);\n        });\n        const rejectionHandler = ((errorEvent) => {\n            debugThreadUtils(\"Unhandled promise rejection event in thread:\", errorEvent);\n            const workerEvent = {\n                type: WorkerEventType.internalError,\n                error: Error(errorEvent.reason)\n            };\n            observer.next(workerEvent);\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        worker.addEventListener(\"unhandledrejection\", rejectionHandler);\n        workerTermination.then(() => {\n            const terminationEvent = {\n                type: WorkerEventType.termination\n            };\n            worker.removeEventListener(\"message\", messageHandler);\n            worker.removeEventListener(\"unhandledrejection\", rejectionHandler);\n            observer.next(terminationEvent);\n            observer.complete();\n        });\n    });\n}\nfunction createTerminator(worker) {\n    const [termination, resolver] = createPromiseWithResolver();\n    const terminate = () => __awaiter(this, void 0, void 0, function* () {\n        debugThreadUtils(\"Terminating worker\");\n        // Newer versions of worker_threads workers return a promise\n        yield worker.terminate();\n        resolver();\n    });\n    return { terminate, termination };\n}\nfunction setPrivateThreadProps(raw, worker, workerEvents, terminate) {\n    const workerErrors = workerEvents\n        .filter(event => event.type === WorkerEventType.internalError)\n        .map(errorEvent => errorEvent.error);\n    // tslint:disable-next-line prefer-object-spread\n    return Object.assign(raw, {\n        [$errors]: workerErrors,\n        [$events]: workerEvents,\n        [$terminate]: terminate,\n        [$worker]: worker\n    });\n}\n/**\n * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin\n * abstraction layer to provide the transparent API and verifies that\n * the worker has initialized successfully.\n *\n * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.\n * @param [options]\n * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.\n */\nexport function spawn(worker, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        debugSpawn(\"Initializing new thread\");\n        const timeout = options && options.timeout ? options.timeout : initMessageTimeout;\n        const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);\n        const exposed = initMessage.exposed;\n        const { termination, terminate } = createTerminator(worker);\n        const events = createEventObservable(worker, termination);\n        if (exposed.type === \"function\") {\n            const proxy = createProxyFunction(worker);\n            return setPrivateThreadProps(proxy, worker, events, terminate);\n        }\n        else if (exposed.type === \"module\") {\n            const proxy = createProxyModule(worker, exposed.methods);\n            return setPrivateThreadProps(proxy, worker, events, terminate);\n        }\n        else {\n            const type = exposed.type;\n            throw Error(`Worker init message states unexpected type of expose(): ${type}`);\n        }\n    });\n}\n"]},"metadata":{},"sourceType":"module"}