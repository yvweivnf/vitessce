{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { array, isString } from 'vega-util';\nimport * as log from '../../log';\nimport { isLookupData, isLookupSelection } from '../../transform';\nimport { duplicate, hash as _hash, varName } from '../../util';\nimport { DataFlowNode, OutputNode } from './dataflow';\nimport { findSource } from './parse';\nimport { SourceNode } from './source';\nimport { DataSourceType } from '../../data';\nexport var LookupNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(LookupNode, _DataFlowNode);\n\n  var _super = _createSuper(LookupNode);\n\n  function LookupNode(parent, transform, secondary) {\n    var _this;\n\n    _classCallCheck(this, LookupNode);\n\n    _this = _super.call(this, parent);\n    _this.transform = transform;\n    _this.secondary = secondary;\n    return _this;\n  }\n\n  _createClass(LookupNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new LookupNode(null, duplicate(this.transform), this.secondary);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set([this.transform.lookup]);\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Lookup \".concat(_hash({\n        transform: this.transform,\n        secondary: this.secondary\n      }));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var foreign;\n\n      if (this.transform.from.fields) {\n        // lookup a few fields and add create a flat output\n        foreign = Object.assign({\n          values: this.transform.from.fields\n        }, this.transform.as ? {\n          as: array(this.transform.as)\n        } : {});\n      } else {\n        // lookup full record and nest it\n        var asName = this.transform.as;\n\n        if (!isString(asName)) {\n          log.warn(log.message.NO_FIELDS_NEEDS_AS);\n          asName = '_lookup';\n        }\n\n        foreign = {\n          as: [asName]\n        };\n      }\n\n      return Object.assign(Object.assign({\n        type: 'lookup',\n        from: this.secondary,\n        key: this.transform.from.key,\n        fields: [this.transform.lookup]\n      }, foreign), this.transform.default ? {\n        default: this.transform.default\n      } : {});\n    }\n  }], [{\n    key: \"make\",\n    value: function make(parent, model, transform, counter) {\n      var sources = model.component.data.sources;\n      var _transform = transform,\n          from = _transform.from;\n      var fromOutputNode = null;\n\n      if (isLookupData(from)) {\n        var fromSource = findSource(from.data, sources);\n\n        if (!fromSource) {\n          fromSource = new SourceNode(from.data);\n          sources.push(fromSource);\n        }\n\n        var fromOutputName = model.getName(\"lookup_\".concat(counter));\n        fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n        model.component.data.outputNodes[fromOutputName] = fromOutputNode;\n      } else if (isLookupSelection(from)) {\n        var selName = from.param;\n        transform = Object.assign({\n          as: selName\n        }, transform);\n        var selCmpt;\n\n        try {\n          selCmpt = model.getSelectionComponent(varName(selName), selName);\n        } catch (e) {\n          throw new Error(log.message.cannotLookupVariableParameter(selName));\n        }\n\n        fromOutputNode = selCmpt.materialized;\n\n        if (!fromOutputNode) {\n          throw new Error(log.message.noSameUnitLookup(selName));\n        }\n      }\n\n      return new LookupNode(parent, transform, fromOutputNode.getSource());\n    }\n  }]);\n\n  return LookupNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/lookup.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isString } from 'vega-util';\nimport * as log from '../../log';\nimport { isLookupData, isLookupSelection } from '../../transform';\nimport { duplicate, hash, varName } from '../../util';\nimport { DataFlowNode, OutputNode } from './dataflow';\nimport { findSource } from './parse';\nimport { SourceNode } from './source';\nimport { DataSourceType } from '../../data';\nexport class LookupNode extends DataFlowNode {\n    constructor(parent, transform, secondary) {\n        super(parent);\n        this.transform = transform;\n        this.secondary = secondary;\n    }\n    clone() {\n        return new LookupNode(null, duplicate(this.transform), this.secondary);\n    }\n    static make(parent, model, transform, counter) {\n        const sources = model.component.data.sources;\n        const { from } = transform;\n        let fromOutputNode = null;\n        if (isLookupData(from)) {\n            let fromSource = findSource(from.data, sources);\n            if (!fromSource) {\n                fromSource = new SourceNode(from.data);\n                sources.push(fromSource);\n            }\n            const fromOutputName = model.getName(`lookup_${counter}`);\n            fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n            model.component.data.outputNodes[fromOutputName] = fromOutputNode;\n        }\n        else if (isLookupSelection(from)) {\n            const selName = from.param;\n            transform = Object.assign({ as: selName }, transform);\n            let selCmpt;\n            try {\n                selCmpt = model.getSelectionComponent(varName(selName), selName);\n            }\n            catch (e) {\n                throw new Error(log.message.cannotLookupVariableParameter(selName));\n            }\n            fromOutputNode = selCmpt.materialized;\n            if (!fromOutputNode) {\n                throw new Error(log.message.noSameUnitLookup(selName));\n            }\n        }\n        return new LookupNode(parent, transform, fromOutputNode.getSource());\n    }\n    dependentFields() {\n        return new Set([this.transform.lookup]);\n    }\n    producedFields() {\n        return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);\n    }\n    hash() {\n        return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;\n    }\n    assemble() {\n        let foreign;\n        if (this.transform.from.fields) {\n            // lookup a few fields and add create a flat output\n            foreign = Object.assign({ values: this.transform.from.fields }, (this.transform.as ? { as: array(this.transform.as) } : {}));\n        }\n        else {\n            // lookup full record and nest it\n            let asName = this.transform.as;\n            if (!isString(asName)) {\n                log.warn(log.message.NO_FIELDS_NEEDS_AS);\n                asName = '_lookup';\n            }\n            foreign = {\n                as: [asName]\n            };\n        }\n        return Object.assign(Object.assign({ type: 'lookup', from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] }, foreign), (this.transform.default ? { default: this.transform.default } : {}));\n    }\n}\n//# sourceMappingURL=lookup.js.map"]},"metadata":{},"sourceType":"module"}