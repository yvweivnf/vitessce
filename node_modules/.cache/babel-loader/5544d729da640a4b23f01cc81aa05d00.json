{"ast":null,"code":"import Ajv from 'ajv';\nimport isNil from 'lodash/isNil';\nimport { dsvFormat } from 'd3-dsv';\nimport { parse as json2csv } from 'json2csv';\nimport { colorArrayToString, colorStringToArray } from './utils';\nimport { nodeTransform } from './cell-set-utils';\nimport { getDefaultColor } from '../utils';\nimport { HIERARCHICAL_SCHEMAS, TABULAR_SCHEMAS, MIME_TYPE_JSON, MIME_TYPE_TABULAR, SEPARATOR_TABULAR, NA_VALUE_TABULAR } from './constants';\n/**\n * Check if an imported tree has an old schema version that we know how to\n * \"upgrade\" to the latest schema version.  Validate against the schema.\n * @param {object} currTree A hierarchical tree object with a .version property,\n * which has already passed schema validation, but may not have the latest schema version.\n * @param {string} datatype The data type of the items in the schema.\n */\n\nexport function tryUpgradeTreeToLatestSchema(currTree, datatype) {\n  const validate = new Ajv().compile(HIERARCHICAL_SCHEMAS[datatype].schema);\n  const valid = validate(currTree);\n\n  if (!valid) {\n    const failureReason = JSON.stringify(validate.errors, null, 2);\n    throw new Error(`Tree validation failed: ${failureReason}`);\n  } else if (currTree.datatype !== datatype) {\n    throw new Error(`The data type does not match the expected data type of '${datatype}'.`);\n  }\n\n  if (currTree.version === '0.1.2') {\n    // To upgrade from cell-sets schema 0.1.2 to 0.1.3,\n    // add a confidence value of null for each cell ID.\n    return { ...currTree,\n      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n      tree: currTree.tree.map(levelZeroNode => nodeTransform(levelZeroNode, n => !n.children && Array.isArray(n.set), n => ({ ...n,\n        set: n.set.map(itemId => [itemId, null])\n      }), []))\n    };\n  }\n\n  return currTree;\n}\n/**\n * Handler for JSON imports. Validates and upgrades against the hierarchical sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */\n// eslint-disable-next-line no-unused-vars\n\nexport function handleImportJSON(result, datatype, theme) {\n  let importData = JSON.parse(result); // Validate the imported file.\n\n  importData = tryUpgradeTreeToLatestSchema(importData, datatype);\n  return importData;\n}\n/**\n * Handler for tabular imports. Validates against the tabular sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */\n\nexport function handleImportTabular(result, datatype, theme) {\n  const dsvParser = dsvFormat(SEPARATOR_TABULAR);\n  const importData = dsvParser.parse(result, row => ({\n    groupName: row.groupName,\n    setName: row.setName,\n    setColor: row.setColor ? colorStringToArray(row.setColor) : getDefaultColor(theme),\n    obsId: row.obsId,\n    predictionScore: isNil(row.predictionScore) || row.predictionScore === NA_VALUE_TABULAR ? null : +row.predictionScore\n  })); // Validate the imported file.\n\n  const validate = new Ajv().compile(TABULAR_SCHEMAS[datatype].schema);\n  const valid = validate(importData);\n\n  if (!valid) {\n    const failureReason = JSON.stringify(validate.errors, null, 2);\n    throw new Error(`Import validation failed: ${failureReason}`);\n  } else {\n    // Convert the validated array to a tree representation.\n    const treeToImport = {\n      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n      datatype,\n      tree: []\n    };\n    const uniqueGroupNames = Array.from(new Set(importData.map(d => d.groupName)));\n    uniqueGroupNames.forEach(groupName => {\n      const levelZeroNode = {\n        name: groupName,\n        children: []\n      };\n      const groupRows = importData.filter(d => d.groupName === groupName);\n      const uniqueSetNames = Array.from(new Set(groupRows.map(d => d.setName)));\n      uniqueSetNames.forEach(setName => {\n        const setRows = groupRows.filter(d => d.setName === setName);\n        const {\n          setColor\n        } = setRows[0];\n        const levelOneNode = {\n          name: setName,\n          color: setColor,\n          set: setRows.map(d => [d.obsId, d.predictionScore])\n        };\n        levelZeroNode.children.push(levelOneNode);\n      });\n      treeToImport.tree.push(levelZeroNode);\n    });\n    return treeToImport;\n  }\n}\n/**\n * Convert a tree object to a JSON representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */\n\nexport function handleExportJSON(result) {\n  const jsonString = JSON.stringify(result);\n  const dataString = `data:${MIME_TYPE_JSON};charset=utf-8,${encodeURIComponent(jsonString)}`;\n  return dataString;\n}\n/**\n * Convert a tree object with one level (height === 1) to a tabular representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */\n\nexport function handleExportTabular(result) {\n  // Convert a tree object to an array of JSON objects.\n  const exportData = [];\n  result.tree.forEach(levelZeroNode => {\n    levelZeroNode.children.forEach(levelOneNode => {\n      if (levelOneNode.set) {\n        levelOneNode.set.forEach(([obsId, prob]) => {\n          exportData.push({\n            groupName: levelZeroNode.name,\n            setName: levelOneNode.name,\n            setColor: colorArrayToString(levelOneNode.color),\n            obsId,\n            predictionScore: isNil(prob) ? NA_VALUE_TABULAR : prob\n          });\n        });\n      }\n    });\n  });\n  const csvString = json2csv(exportData, {\n    fields: ['groupName', 'setName', 'setColor', 'obsId', 'predictionScore'],\n    delimiter: SEPARATOR_TABULAR\n  });\n  const dataString = `data:${MIME_TYPE_TABULAR};charset=utf-8,${encodeURIComponent(csvString)}`;\n  return dataString;\n}\n/**\n * Download a file. Appends and removes an anchor node in the DOM.\n * @param {string} dataString The function that converts the data to a string.\n * @param {string} fileName The name of the file to be downloaded.\n */\n\nexport function downloadForUser(dataString, fileName) {\n  const downloadAnchorNode = document.createElement('a');\n  downloadAnchorNode.setAttribute('href', dataString);\n  downloadAnchorNode.setAttribute('download', fileName);\n  document.body.appendChild(downloadAnchorNode); // required for firefox\n\n  downloadAnchorNode.click();\n  downloadAnchorNode.remove();\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/io.js"],"names":["Ajv","isNil","dsvFormat","parse","json2csv","colorArrayToString","colorStringToArray","nodeTransform","getDefaultColor","HIERARCHICAL_SCHEMAS","TABULAR_SCHEMAS","MIME_TYPE_JSON","MIME_TYPE_TABULAR","SEPARATOR_TABULAR","NA_VALUE_TABULAR","tryUpgradeTreeToLatestSchema","currTree","datatype","validate","compile","schema","valid","failureReason","JSON","stringify","errors","Error","version","latestVersion","tree","map","levelZeroNode","n","children","Array","isArray","set","itemId","handleImportJSON","result","theme","importData","handleImportTabular","dsvParser","row","groupName","setName","setColor","obsId","predictionScore","treeToImport","uniqueGroupNames","from","Set","d","forEach","name","groupRows","filter","uniqueSetNames","setRows","levelOneNode","color","push","handleExportJSON","jsonString","dataString","encodeURIComponent","handleExportTabular","exportData","prob","csvString","fields","delimiter","downloadForUser","fileName","downloadAnchorNode","document","createElement","setAttribute","body","appendChild","click","remove"],"mappings":"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","sourcesContent":["import Ajv from 'ajv';\nimport isNil from 'lodash/isNil';\nimport { dsvFormat } from 'd3-dsv';\nimport { parse as json2csv } from 'json2csv';\nimport { colorArrayToString, colorStringToArray } from './utils';\nimport { nodeTransform } from './cell-set-utils';\nimport { getDefaultColor } from '../utils';\nimport {\n  HIERARCHICAL_SCHEMAS, TABULAR_SCHEMAS,\n  MIME_TYPE_JSON, MIME_TYPE_TABULAR,\n  SEPARATOR_TABULAR, NA_VALUE_TABULAR,\n} from './constants';\n\n/**\n * Check if an imported tree has an old schema version that we know how to\n * \"upgrade\" to the latest schema version.  Validate against the schema.\n * @param {object} currTree A hierarchical tree object with a .version property,\n * which has already passed schema validation, but may not have the latest schema version.\n * @param {string} datatype The data type of the items in the schema.\n */\nexport function tryUpgradeTreeToLatestSchema(currTree, datatype) {\n  const validate = new Ajv().compile(HIERARCHICAL_SCHEMAS[datatype].schema);\n  const valid = validate(currTree);\n  if (!valid) {\n    const failureReason = JSON.stringify(validate.errors, null, 2);\n    throw new Error(`Tree validation failed: ${failureReason}`);\n  } else if (currTree.datatype !== datatype) {\n    throw new Error(\n      `The data type does not match the expected data type of '${datatype}'.`,\n    );\n  }\n  if (currTree.version === '0.1.2') {\n    // To upgrade from cell-sets schema 0.1.2 to 0.1.3,\n    // add a confidence value of null for each cell ID.\n    return {\n      ...currTree,\n      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n      tree: currTree.tree.map(levelZeroNode => nodeTransform(\n        levelZeroNode,\n        n => !n.children && Array.isArray(n.set),\n        n => ({ ...n, set: n.set.map(itemId => ([itemId, null])) }), [],\n      )),\n    };\n  }\n  return currTree;\n}\n\n/**\n * Handler for JSON imports. Validates and upgrades against the hierarchical sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */\n// eslint-disable-next-line no-unused-vars\nexport function handleImportJSON(result, datatype, theme) {\n  let importData = JSON.parse(result);\n  // Validate the imported file.\n  importData = tryUpgradeTreeToLatestSchema(importData, datatype);\n  return importData;\n}\n\n/**\n * Handler for tabular imports. Validates against the tabular sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */\nexport function handleImportTabular(result, datatype, theme) {\n  const dsvParser = dsvFormat(SEPARATOR_TABULAR);\n  const importData = dsvParser.parse(result, row => ({\n    groupName: row.groupName,\n    setName: row.setName,\n    setColor: (row.setColor ? colorStringToArray(row.setColor) : getDefaultColor(theme)),\n    obsId: row.obsId,\n    predictionScore: (\n      (\n        isNil(row.predictionScore)\n        || row.predictionScore === NA_VALUE_TABULAR\n      )\n        ? null\n        : +row.predictionScore\n    ),\n  }));\n  // Validate the imported file.\n  const validate = new Ajv().compile(TABULAR_SCHEMAS[datatype].schema);\n  const valid = validate(importData);\n  if (!valid) {\n    const failureReason = JSON.stringify(validate.errors, null, 2);\n    throw new Error(`Import validation failed: ${failureReason}`);\n  } else {\n    // Convert the validated array to a tree representation.\n    const treeToImport = {\n      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n      datatype,\n      tree: [],\n    };\n    const uniqueGroupNames = Array.from(new Set(importData.map(d => d.groupName)));\n    uniqueGroupNames.forEach((groupName) => {\n      const levelZeroNode = {\n        name: groupName,\n        children: [],\n      };\n      const groupRows = importData.filter(d => d.groupName === groupName);\n      const uniqueSetNames = Array.from(new Set(groupRows.map(d => d.setName)));\n      uniqueSetNames.forEach((setName) => {\n        const setRows = groupRows.filter(d => d.setName === setName);\n        const { setColor } = setRows[0];\n        const levelOneNode = {\n          name: setName,\n          color: setColor,\n          set: setRows.map(d => ([d.obsId, d.predictionScore])),\n        };\n        levelZeroNode.children.push(levelOneNode);\n      });\n      treeToImport.tree.push(levelZeroNode);\n    });\n    return treeToImport;\n  }\n}\n\n/**\n * Convert a tree object to a JSON representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */\nexport function handleExportJSON(result) {\n  const jsonString = JSON.stringify(result);\n  const dataString = `data:${MIME_TYPE_JSON};charset=utf-8,${encodeURIComponent(jsonString)}`;\n  return dataString;\n}\n\n/**\n * Convert a tree object with one level (height === 1) to a tabular representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */\nexport function handleExportTabular(result) {\n  // Convert a tree object to an array of JSON objects.\n  const exportData = [];\n  result.tree.forEach((levelZeroNode) => {\n    levelZeroNode.children.forEach((levelOneNode) => {\n      if (levelOneNode.set) {\n        levelOneNode.set.forEach(([obsId, prob]) => {\n          exportData.push({\n            groupName: levelZeroNode.name,\n            setName: levelOneNode.name,\n            setColor: colorArrayToString(levelOneNode.color),\n            obsId,\n            predictionScore: isNil(prob) ? NA_VALUE_TABULAR : prob,\n          });\n        });\n      }\n    });\n  });\n  const csvString = json2csv(exportData, {\n    fields: ['groupName', 'setName', 'setColor', 'obsId', 'predictionScore'],\n    delimiter: SEPARATOR_TABULAR,\n  });\n  const dataString = `data:${MIME_TYPE_TABULAR};charset=utf-8,${encodeURIComponent(csvString)}`;\n  return dataString;\n}\n\n/**\n * Download a file. Appends and removes an anchor node in the DOM.\n * @param {string} dataString The function that converts the data to a string.\n * @param {string} fileName The name of the file to be downloaded.\n */\nexport function downloadForUser(dataString, fileName) {\n  const downloadAnchorNode = document.createElement('a');\n  downloadAnchorNode.setAttribute('href', dataString);\n  downloadAnchorNode.setAttribute('download', fileName);\n  document.body.appendChild(downloadAnchorNode); // required for firefox\n  downloadAnchorNode.click();\n  downloadAnchorNode.remove();\n}\n"]},"metadata":{},"sourceType":"module"}