{"ast":null,"code":"/* eslint-disable no-plusplus */\n\n/* eslint-disable no-param-reassign */\nimport { quadtree } from 'd3-quadtree';\n/**\n * Returns a closure that returns a constant value.\n */\n\nfunction constant(v) {\n  return () => v;\n}\n/**\n * Adds a tiny bit of randomness to a number.\n */\n\n\nfunction jiggle(v) {\n  return v + (Math.random() - 0.5) * 1e-6;\n}\n/**\n * A force function to be used with d3.forceSimulation.\n * This has been adapted for use here, with comments explaining each part.\n * Reference: https://bl.ocks.org/cmgiven/547658968d365bcc324f3e62e175709b\n */\n\n\nexport function forceCollideRects() {\n  // D3 implements things with function prototypes rather than classes.\n  // Pretend these variables are the \"instance members\" of a class.\n  // Note that this function actually returns the internal force() function,\n  // but that the force() function is a closure with access to these instance members.\n  let nodes;\n  let masses;\n  let strength = 1;\n  let iterations = 1;\n  let sizes;\n  let size = constant([0, 0]); // Given a node, return the center point along the x-axis.\n\n  function xCenter(d) {\n    return d.x + d.vx + sizes[d.index][0] / 2;\n  } // Given a node, return the center point along the y-axis.\n\n\n  function yCenter(d) {\n    return d.y + d.vy + sizes[d.index][1] / 2;\n  } // Given a quadtree node, initialize its .size property.\n\n\n  function prepare(quad) {\n    if (quad.data) {\n      // This is a leaf node, so we set quad.size to the node's size.\n      // (No need to compute the max of internal nodes,\n      // since leaf nodes do not have any internal nodes).\n      quad.size = sizes[quad.data.index];\n    } else {\n      quad.size = [0, 0]; // Internal nodes of the quadtree are represented\n      // as four-element arrays in left-to-right, top-to-bottom order.\n      // Here, we are setting quad.size to [maxWidth, maxHeight]\n      // among the internal nodes of this current `quad` node.\n\n      for (let i = 0; i < 4; i++) {\n        if (quad[i] && quad[i].size) {\n          quad.size[0] = Math.max(quad.size[0], quad[i].size[0]);\n          quad.size[1] = Math.max(quad.size[1], quad[i].size[1]);\n        }\n      }\n    }\n  }\n\n  function force() {\n    let node;\n    let nodeSize;\n    let nodeMass;\n    let xi;\n    let yi; // Create a quadtree based on node center points.\n    // Initialize each quadtree node's .size property by calling\n    // the prepare() function on each quadtree node.\n\n    const tree = quadtree(nodes, xCenter, yCenter).visitAfter(prepare); // Update the .vx and .vy properties of both `node` and `data`\n    // (the current node pair).\n\n    function apply(quad, x0, y0, x1, y1) {\n      // `quad` is a quadtree node.\n      const {\n        data\n      } = quad;\n      const xSize = (nodeSize[0] + quad.size[0]) / 2;\n      const ySize = (nodeSize[1] + quad.size[1]) / 2;\n\n      if (data && data.index > node.index) {\n        // This is a leaf node because `data` is defined.\n        // `x` is the difference in x centers between `node` and `data`.\n        // `y` is the difference in y centers between `node` and `data`.\n        let x = jiggle(xi - xCenter(data));\n        let y = jiggle(yi - yCenter(data));\n        const xd = Math.abs(x) - xSize;\n        const yd = Math.abs(y) - ySize; // If `xd` and `yd` is less than zero,\n        // then there is an overlap between the two nodes.\n\n        if (xd < 0 && yd < 0) {\n          const l = Math.sqrt(x * x + y * y);\n          const m = masses[data.index] / (nodeMass + masses[data.index]); // We move the nodes either in the x or y direction.\n          // Nodes are moved proportionally to:\n          // their distance apart (`l`), their amount of overlap (`xd` or `yd`), their masses (`m`),\n          // and the strength parameter (`strength`).\n\n          if (Math.abs(xd) < Math.abs(yd)) {\n            node.vx -= (x *= xd / l * strength) * m;\n            data.vx += x * (1 - m);\n          } else {\n            node.vy -= (y *= yd / l * strength) * m;\n            data.vy += y * (1 - m);\n          }\n        } // When the quadtree.visit callback returns _true_ for a node,\n        // then the node's children will _not_ be visited.\n\n\n        return x0 > xi + xSize || x1 < xi - xSize || y0 > yi + ySize || y1 < yi - ySize;\n      }\n\n      return false;\n    }\n\n    function iterate() {\n      // On every iteration, use the `apply` function to visit every node\n      // which has an index greater than the current node's index,\n      // (visiting every node pair).\n      for (let j = 0; j < nodes.length; j++) {\n        node = nodes[j];\n        nodeSize = sizes[j];\n        nodeMass = masses[j];\n        xi = xCenter(node);\n        yi = yCenter(node);\n        tree.visit(apply);\n      }\n    } // Do the specified number of iterations.\n\n\n    for (let i = 0; i < iterations; i++) {\n      iterate();\n    }\n  } // The \"constructor\".\n  // Takes a list of nodes as input.\n\n\n  force.initialize = v => {\n    nodes = v; // Get the size [w, h] of each node using the size getter function.\n\n    sizes = nodes.map(size); // Get the mass of each node,\n    // which is the sum of its horizontal and vertical edge lengths.\n\n    masses = sizes.map(d => d[0] + d[1]);\n  }; // Set the number of iterations.\n  // If no value is provided as a parameter, this acts as a getter function.\n\n\n  force.iterations = (...v) => {\n    if (v.length) {\n      iterations = +v[0];\n      return force;\n    }\n\n    return iterations;\n  }; // Set the strength value.\n  // If no value is provided as a parameter, this acts as a getter function.\n\n\n  force.strength = (...v) => {\n    if (v.length) {\n      strength = +v[0];\n      return force;\n    }\n\n    return strength;\n  }; // Set the size function.\n  // The size function takes a node as a parameter and returns its size.\n  // If no size function is provided as a parameter, this acts as a getter function.\n\n\n  force.size = (...v) => {\n    if (v.length) {\n      size = typeof v[0] === 'function' ? v[0] : constant(v[0]);\n      return force;\n    }\n\n    return size;\n  }; // Returns the force closure.\n\n\n  return force;\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/shared-spatial-scatterplot/force-collide-rects.js"],"names":["quadtree","constant","v","jiggle","Math","random","forceCollideRects","nodes","masses","strength","iterations","sizes","size","xCenter","d","x","vx","index","yCenter","y","vy","prepare","quad","data","i","max","force","node","nodeSize","nodeMass","xi","yi","tree","visitAfter","apply","x0","y0","x1","y1","xSize","ySize","xd","abs","yd","l","sqrt","m","iterate","j","length","visit","initialize","map"],"mappings":"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","sourcesContent":["/* eslint-disable no-plusplus */\n/* eslint-disable no-param-reassign */\nimport { quadtree } from 'd3-quadtree';\n\n/**\n * Returns a closure that returns a constant value.\n */\nfunction constant(v) {\n  return (() => v);\n}\n\n/**\n * Adds a tiny bit of randomness to a number.\n */\nfunction jiggle(v) {\n  return v + (Math.random() - 0.5) * 1e-6;\n}\n\n/**\n * A force function to be used with d3.forceSimulation.\n * This has been adapted for use here, with comments explaining each part.\n * Reference: https://bl.ocks.org/cmgiven/547658968d365bcc324f3e62e175709b\n */\nexport function forceCollideRects() {\n  // D3 implements things with function prototypes rather than classes.\n  // Pretend these variables are the \"instance members\" of a class.\n  // Note that this function actually returns the internal force() function,\n  // but that the force() function is a closure with access to these instance members.\n\n  let nodes;\n  let masses;\n  let strength = 1;\n  let iterations = 1;\n\n  let sizes;\n  let size = constant([0, 0]);\n\n  // Given a node, return the center point along the x-axis.\n  function xCenter(d) {\n    return d.x + d.vx + sizes[d.index][0] / 2;\n  }\n\n  // Given a node, return the center point along the y-axis.\n  function yCenter(d) {\n    return d.y + d.vy + sizes[d.index][1] / 2;\n  }\n\n  // Given a quadtree node, initialize its .size property.\n  function prepare(quad) {\n    if (quad.data) {\n      // This is a leaf node, so we set quad.size to the node's size.\n      // (No need to compute the max of internal nodes,\n      // since leaf nodes do not have any internal nodes).\n      quad.size = sizes[quad.data.index];\n    } else {\n      quad.size = [0, 0];\n      // Internal nodes of the quadtree are represented\n      // as four-element arrays in left-to-right, top-to-bottom order.\n      // Here, we are setting quad.size to [maxWidth, maxHeight]\n      // among the internal nodes of this current `quad` node.\n      for (let i = 0; i < 4; i++) {\n        if (quad[i] && quad[i].size) {\n          quad.size[0] = Math.max(quad.size[0], quad[i].size[0]);\n          quad.size[1] = Math.max(quad.size[1], quad[i].size[1]);\n        }\n      }\n    }\n  }\n\n  function force() {\n    let node;\n    let nodeSize;\n    let nodeMass;\n    let xi;\n    let yi;\n\n    // Create a quadtree based on node center points.\n    // Initialize each quadtree node's .size property by calling\n    // the prepare() function on each quadtree node.\n    const tree = quadtree(nodes, xCenter, yCenter).visitAfter(prepare);\n\n    // Update the .vx and .vy properties of both `node` and `data`\n    // (the current node pair).\n    function apply(quad, x0, y0, x1, y1) {\n      // `quad` is a quadtree node.\n      const { data } = quad;\n      const xSize = (nodeSize[0] + quad.size[0]) / 2;\n      const ySize = (nodeSize[1] + quad.size[1]) / 2;\n\n      if (data && data.index > node.index) {\n        // This is a leaf node because `data` is defined.\n        // `x` is the difference in x centers between `node` and `data`.\n        // `y` is the difference in y centers between `node` and `data`.\n        let x = jiggle(xi - xCenter(data));\n        let y = jiggle(yi - yCenter(data));\n        const xd = Math.abs(x) - xSize;\n        const yd = Math.abs(y) - ySize;\n\n        // If `xd` and `yd` is less than zero,\n        // then there is an overlap between the two nodes.\n        if (xd < 0 && yd < 0) {\n          const l = Math.sqrt(x * x + y * y);\n          const m = masses[data.index] / (nodeMass + masses[data.index]);\n\n          // We move the nodes either in the x or y direction.\n          // Nodes are moved proportionally to:\n          // their distance apart (`l`), their amount of overlap (`xd` or `yd`), their masses (`m`),\n          // and the strength parameter (`strength`).\n          if (Math.abs(xd) < Math.abs(yd)) {\n            node.vx -= (x *= xd / l * strength) * m;\n            data.vx += x * (1 - m);\n          } else {\n            node.vy -= (y *= yd / l * strength) * m;\n            data.vy += y * (1 - m);\n          }\n        }\n        // When the quadtree.visit callback returns _true_ for a node,\n        // then the node's children will _not_ be visited.\n        return x0 > xi + xSize || x1 < xi - xSize || y0 > yi + ySize || y1 < yi - ySize;\n      }\n      return false;\n    }\n\n    function iterate() {\n      // On every iteration, use the `apply` function to visit every node\n      // which has an index greater than the current node's index,\n      // (visiting every node pair).\n      for (let j = 0; j < nodes.length; j++) {\n        node = nodes[j];\n        nodeSize = sizes[j];\n        nodeMass = masses[j];\n        xi = xCenter(node);\n        yi = yCenter(node);\n\n        tree.visit(apply);\n      }\n    }\n\n    // Do the specified number of iterations.\n    for (let i = 0; i < iterations; i++) {\n      iterate();\n    }\n  }\n\n  // The \"constructor\".\n  // Takes a list of nodes as input.\n  force.initialize = (v) => {\n    nodes = v;\n    // Get the size [w, h] of each node using the size getter function.\n    sizes = nodes.map(size);\n    // Get the mass of each node,\n    // which is the sum of its horizontal and vertical edge lengths.\n    masses = sizes.map(d => d[0] + d[1]);\n  };\n\n  // Set the number of iterations.\n  // If no value is provided as a parameter, this acts as a getter function.\n  force.iterations = (...v) => {\n    if (v.length) {\n      iterations = +v[0];\n      return force;\n    }\n    return iterations;\n  };\n\n  // Set the strength value.\n  // If no value is provided as a parameter, this acts as a getter function.\n  force.strength = (...v) => {\n    if (v.length) {\n      strength = +v[0];\n      return force;\n    }\n    return strength;\n  };\n\n  // Set the size function.\n  // The size function takes a node as a parameter and returns its size.\n  // If no size function is provided as a parameter, this acts as a getter function.\n  force.size = (...v) => {\n    if (v.length) {\n      size = (typeof v[0] === 'function' ? v[0] : constant(v[0]));\n      return force;\n    }\n    return size;\n  };\n\n  // Returns the force closure.\n  return force;\n}\n"]},"metadata":{},"sourceType":"module"}