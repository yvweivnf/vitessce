{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Buffer, Transform } from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport { padBuffer, getAttributeTypeFromSize, getSourceBufferAttribute, getAttributeBufferLength, cycleBuffers } from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\n\nvar GPUInterpolationTransition = /*#__PURE__*/function () {\n  function GPUInterpolationTransition(_ref) {\n    _classCallCheck(this, GPUInterpolationTransition);\n\n    var gl = _ref.gl,\n        attribute = _ref.attribute,\n        timeline = _ref.timeline;\n    this.gl = gl;\n    this.type = 'interpolation';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    var bufferOpts = {\n      byteLength: 0,\n      usage: 35050\n    };\n    this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];\n  }\n\n  _createClass(GPUInterpolationTransition, [{\n    key: \"start\",\n    value: function start(transitionSettings, numInstances) {\n      if (transitionSettings.duration <= 0) {\n        this.transition.cancel();\n        return;\n      }\n\n      var gl = this.gl,\n          buffers = this.buffers,\n          attribute = this.attribute;\n      cycleBuffers(buffers);\n      var padBufferOpts = {\n        numInstances: numInstances,\n        attribute: attribute,\n        fromLength: this.currentLength,\n        fromStartIndices: this.currentStartIndices,\n        getData: transitionSettings.enter\n      };\n\n      var _iterator = _createForOfIteratorHelper(buffers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var buffer = _step.value;\n          padBuffer(_objectSpread({\n            buffer: buffer\n          }, padBufferOpts));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.currentStartIndices = attribute.startIndices;\n      this.currentLength = getAttributeBufferLength(attribute, numInstances);\n      this.attributeInTransition.update({\n        buffer: buffers[1],\n        value: attribute.value\n      });\n      this.transition.start(transitionSettings);\n      this.transform.update({\n        elementCount: Math.floor(this.currentLength / attribute.size),\n        sourceBuffers: {\n          aFrom: buffers[0],\n          aTo: getSourceBufferAttribute(gl, attribute)\n        },\n        feedbackBuffers: {\n          vCurrent: buffers[1]\n        }\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var updated = this.transition.update();\n\n      if (updated) {\n        var _this$transition = this.transition,\n            time = _this$transition.time,\n            _this$transition$sett = _this$transition.settings,\n            duration = _this$transition$sett.duration,\n            easing = _this$transition$sett.easing;\n        var t = easing(time / duration);\n        this.transform.run({\n          uniforms: {\n            time: t\n          }\n        });\n      }\n\n      return updated;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.transition.cancel();\n      this.transform.delete();\n\n      while (this.buffers.length) {\n        this.buffers.pop().delete();\n      }\n    }\n  }, {\n    key: \"inProgress\",\n    get: function get() {\n      return this.transition.inProgress;\n    }\n  }]);\n\n  return GPUInterpolationTransition;\n}();\n\nexport { GPUInterpolationTransition as default };\nvar vs = \"\\n#define SHADER_NAME interpolation-transition-vertex-shader\\n\\nuniform float time;\\nattribute ATTRIBUTE_TYPE aFrom;\\nattribute ATTRIBUTE_TYPE aTo;\\nvarying ATTRIBUTE_TYPE vCurrent;\\n\\nvoid main(void) {\\n  vCurrent = mix(aFrom, aTo, time);\\n  gl_Position = vec4(0.0);\\n}\\n\";\n\nfunction getTransform(gl, attribute) {\n  var attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs: vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}","map":{"version":3,"sources":["../../../src/transitions/gpu-interpolation-transition.js"],"names":["constructor","timeline","attribute","getTransform","bufferOpts","byteLength","usage","transitionSettings","cycleBuffers","padBufferOpts","numInstances","fromLength","fromStartIndices","getData","enter","padBuffer","buffer","getAttributeBufferLength","buffers","value","elementCount","Math","sourceBuffers","aFrom","aTo","getSourceBufferAttribute","feedbackBuffers","vCurrent","updated","settings","easing","t","time","uniforms","vs","attributeType","getAttributeTypeFromSize","defines","ATTRIBUTE_TYPE","varyings"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers\n} from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\n\nexport default class GPUInterpolationTransition {\n  constructor({gl, attribute, timeline}) {\n    this.gl = gl;\n    this.type = 'interpolation';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // from\n      new Buffer(gl, bufferOpts) // current\n    ];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings, numInstances) {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n\n    const {gl, buffers, attribute} = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value\n    });\n\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update() {\n    const updated = this.transition.update();\n    if (updated) {\n      const {\n        time,\n        settings: {duration, easing}\n      } = this.transition;\n      const t = easing(time / duration);\n      this.transform.run({\n        uniforms: {time: t}\n      });\n    }\n    return updated;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n    while (this.buffers.length) {\n      this.buffers.pop().delete();\n    }\n  }\n}\n\nconst vs = `\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n`;\n\nfunction getTransform(gl, attribute) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}\n"]},"metadata":{},"sourceType":"module"}