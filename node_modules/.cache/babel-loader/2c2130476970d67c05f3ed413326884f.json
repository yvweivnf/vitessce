{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { Tile3DSubtreeLoader } from '../../tile-3d-subtree-loader';\nimport { load } from '@loaders.gl/core';\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nimport { parseImplicitTiles, replaceContentUrlTemplate } from './helpers/parse-3d-implicit-tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  var contentUrl = tile.contentUrl;\n  var fileExtension = contentUrl.split('.').pop();\n\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n\n    default:\n      return refine;\n  }\n}\n\nexport function normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n\n  if (tile.content) {\n    var contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = \"\".concat(options.basePath, \"/\").concat(contentUri);\n  }\n\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n  return tile;\n}\nexport function normalizeTileHeaders(tileset) {\n  var basePath = tileset.basePath;\n  var root = normalizeTileData(tileset.root, tileset);\n  var stack = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    var tile = stack.pop() || {};\n    var children = tile.children || [];\n\n    var _iterator = _createForOfIteratorHelper(children),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var childHeader = _step.value;\n        normalizeTileData(childHeader, {\n          basePath: basePath\n        });\n        stack.push(childHeader);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return root;\n}\nexport function normalizeImplicitTileHeaders(_x) {\n  return _normalizeImplicitTileHeaders.apply(this, arguments);\n}\n\nfunction _normalizeImplicitTileHeaders() {\n  _normalizeImplicitTileHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tileset) {\n    var basePath, implicitTilingExtension, subdivisionScheme, maximumLevel, subtreeLevels, subtreesUriTemplate, subtreeUrl, rootSubtreeUrl, rootSubtree, contentUrlTemplate, refine, rootLodMetricValue, rootBoundingVolume, options;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (tileset.root) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 2:\n            basePath = tileset.basePath;\n            implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];\n            subdivisionScheme = implicitTilingExtension.subdivisionScheme, maximumLevel = implicitTilingExtension.maximumLevel, subtreeLevels = implicitTilingExtension.subtreeLevels, subtreesUriTemplate = implicitTilingExtension.subtrees.uri;\n            subtreeUrl = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n            rootSubtreeUrl = \"\".concat(basePath, \"/\").concat(subtreeUrl);\n            _context.next = 9;\n            return load(rootSubtreeUrl, Tile3DSubtreeLoader);\n\n          case 9:\n            rootSubtree = _context.sent;\n            contentUrlTemplate = \"\".concat(basePath, \"/\").concat(tileset.root.content.uri);\n            refine = tileset.root.refine;\n            rootLodMetricValue = tileset.root.geometricError;\n            rootBoundingVolume = tileset.root.boundingVolume;\n            options = {\n              contentUrlTemplate: contentUrlTemplate,\n              subtreesUriTemplate: subtreesUriTemplate,\n              subdivisionScheme: subdivisionScheme,\n              subtreeLevels: subtreeLevels,\n              maximumLevel: maximumLevel,\n              refine: refine,\n              basePath: basePath,\n              lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n              rootLodMetricValue: rootLodMetricValue,\n              rootBoundingVolume: rootBoundingVolume,\n              getTileType: getTileType,\n              getRefine: getRefine\n            };\n            _context.next = 17;\n            return normalizeImplicitTileData(tileset.root, rootSubtree, options);\n\n          case 17:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _normalizeImplicitTileHeaders.apply(this, arguments);\n}\n\nexport function normalizeImplicitTileData(_x2, _x3, _x4) {\n  return _normalizeImplicitTileData.apply(this, arguments);\n}\n\nfunction _normalizeImplicitTileData() {\n  _normalizeImplicitTileData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tile, rootSubtree, options) {\n    var _yield$parseImplicitT, children, contentUrl;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (tile) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 2:\n            tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n            tile.lodMetricValue = tile.geometricError;\n            tile.transformMatrix = tile.transform;\n            _context2.next = 7;\n            return parseImplicitTiles(rootSubtree, options);\n\n          case 7:\n            _yield$parseImplicitT = _context2.sent;\n            children = _yield$parseImplicitT.children;\n            contentUrl = _yield$parseImplicitT.contentUrl;\n\n            if (contentUrl) {\n              tile.contentUrl = contentUrl;\n              tile.content = {\n                uri: contentUrl.replace(\"\".concat(options.basePath, \"/\"), '')\n              };\n            }\n\n            tile.refine = getRefine(tile.refine);\n            tile.type = getTileType(tile);\n            tile.children = children;\n            tile.id = tile.contentUrl;\n            return _context2.abrupt(\"return\", tile);\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _normalizeImplicitTileData.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-3d-tile-header.ts"],"names":["tile","TILE_TYPE","contentUrl","fileExtension","TILE_REFINEMENT","contentUri","options","LOD_METRIC_TYPE","getTileType","getRefine","basePath","tileset","root","normalizeTileData","stack","children","implicitTilingExtension","subtrees","uri","subtreesUriTemplate","subtreeUrl","replaceContentUrlTemplate","rootSubtreeUrl","rootSubtree","load","contentUrlTemplate","refine","rootLodMetricValue","rootBoundingVolume","subdivisionScheme","subtreeLevels","maximumLevel","lodMetricType","normalizeImplicitTileData","parseImplicitTiles"],"mappings":"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","sourcesContent":["import {Tile3DSubtreeLoader} from '../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Subtree} from '../../types';\nimport {parseImplicitTiles, replaceContentUrlTemplate} from './helpers/parse-3d-implicit-tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  const contentUrl = tile.contentUrl;\n  const fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\n\nexport function normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = `${options.basePath}/${contentUri}`;\n  }\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n\n  return tile;\n}\n\n// normalize tile headers\nexport function normalizeTileHeaders(tileset) {\n  const basePath = tileset.basePath;\n  const root = normalizeTileData(tileset.root, tileset);\n\n  const stack: any[] = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n    for (const childHeader of children) {\n      normalizeTileData(childHeader, {basePath});\n      stack.push(childHeader);\n    }\n  }\n\n  return root;\n}\n\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(tileset: Tileset3D) {\n  if (!tileset.root) {\n    return null;\n  }\n\n  const basePath = tileset.basePath;\n  const implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    subtreeLevels,\n    subtrees: {uri: subtreesUriTemplate}\n  } = implicitTilingExtension;\n  const subtreeUrl = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const rootSubtreeUrl = `${basePath}/${subtreeUrl}`;\n  const rootSubtree = await load(rootSubtreeUrl, Tile3DSubtreeLoader);\n  const contentUrlTemplate = `${basePath}/${tileset.root.content.uri}`;\n  const refine = tileset.root.refine;\n  // @ts-ignore\n  const rootLodMetricValue = tileset.root.geometricError;\n  const rootBoundingVolume = tileset.root.boundingVolume;\n\n  const options = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n\n  return await normalizeImplicitTileData(tileset.root, rootSubtree, options);\n}\n\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, rootSubtree: Subtree, options: any) {\n  if (!tile) {\n    return null;\n  }\n\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n\n  const {children, contentUrl} = await parseImplicitTiles(rootSubtree, options);\n\n  if (contentUrl) {\n    tile.contentUrl = contentUrl;\n    tile.content = {uri: contentUrl.replace(`${options.basePath}/`, '')};\n  }\n\n  tile.refine = getRefine(tile.refine);\n  tile.type = getTileType(tile);\n  tile.children = children;\n  tile.id = tile.contentUrl;\n\n  return tile;\n}\n"]},"metadata":{},"sourceType":"module"}