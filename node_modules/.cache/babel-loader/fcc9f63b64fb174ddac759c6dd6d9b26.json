{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RotateMode = void 0;\n\nvar _bbox = _interopRequireDefault(require(\"@turf/bbox\"));\n\nvar _centroid = _interopRequireDefault(require(\"@turf/centroid\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _bboxPolygon = _interopRequireDefault(require(\"@turf/bbox-polygon\"));\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _meta = require(\"@turf/meta\");\n\nvar _invariant = require(\"@turf/invariant\");\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _transformRotate = _interopRequireDefault(require(\"@turf/transform-rotate\"));\n\nvar _polygonToLine = _interopRequireDefault(require(\"@turf/polygon-to-line\"));\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar RotateMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(RotateMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(RotateMode);\n\n  function RotateMode() {\n    var _this;\n\n    _classCallCheck(this, RotateMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_selectedEditHandle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_geometryBeingRotated\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isRotating\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isSinglePointGeometrySelected\", function (geometry) {\n      var _ref = geometry || {},\n          features = _ref.features;\n\n      if (Array.isArray(features) && features.length === 1) {\n        // @ts-ignore\n        var _getGeom = (0, _invariant.getGeom)(features[0]),\n            type = _getGeom.type;\n\n        return type === 'Point';\n      }\n\n      return false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getIsRotating\", function () {\n      return _this._isRotating;\n    });\n\n    return _this;\n  }\n\n  _createClass(RotateMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var selectedGeometry = this._geometryBeingRotated || this.getSelectedFeaturesAsFeatureCollection(props);\n\n      if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n        return {\n          type: 'FeatureCollection',\n          features: []\n        };\n      }\n\n      if (this._isRotating) {\n        // Display rotate pivot\n        return (0, _helpers.featureCollection)([(0, _centroid[\"default\"])(selectedGeometry)]);\n      }\n\n      var boundingBox = (0, _bboxPolygon[\"default\"])((0, _bbox[\"default\"])(selectedGeometry));\n      var previousCoord = null;\n      var topEdgeMidpointCoords = null;\n      var longestEdgeLength = 0;\n      (0, _meta.coordEach)(boundingBox, function (coord) {\n        if (previousCoord) {\n          // @ts-ignore\n          var edgeMidpoint = (0, _geojsonEditMode.getIntermediatePosition)(coord, previousCoord);\n\n          if (!topEdgeMidpointCoords || edgeMidpoint[1] > topEdgeMidpointCoords[1]) {\n            // Get the top edge midpoint of the enveloping box\n            topEdgeMidpointCoords = edgeMidpoint;\n          } // Get the length of the longest edge of the enveloping box\n\n\n          var edgeDistance = (0, _distance[\"default\"])(coord, previousCoord);\n          longestEdgeLength = Math.max(longestEdgeLength, edgeDistance);\n        }\n\n        previousCoord = coord;\n      }); // Scale the length of the line between the rotate handler and the enveloping box\n      // relative to the length of the longest edge of the enveloping box\n\n      var rotateHandleCoords = topEdgeMidpointCoords && [topEdgeMidpointCoords[0], topEdgeMidpointCoords[1] + longestEdgeLength / 1000];\n      var lineFromEnvelopeToRotateHandle = (0, _helpers.lineString)([topEdgeMidpointCoords, rotateHandleCoords]);\n      var rotateHandle = (0, _helpers.point)(rotateHandleCoords, {\n        guideType: 'editHandle',\n        editHandleType: 'rotate'\n      }); // @ts-ignore\n\n      return (0, _helpers.featureCollection)([// @ts-ignore\n      (0, _polygonToLine[\"default\"])(boundingBox), // @ts-ignore\n      rotateHandle, // @ts-ignore\n      lineFromEnvelopeToRotateHandle]);\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      if (!this._isRotating) {\n        return;\n      }\n\n      var rotateAction = this.getRotateAction(event.pointerDownMapCoords, event.mapCoords, 'rotating', props);\n\n      if (rotateAction) {\n        props.onEdit(rotateAction);\n      }\n\n      event.cancelPan();\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      if (!this._isRotating) {\n        var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);\n        this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === 'rotate' ? selectedEditHandle : null;\n      }\n\n      this.updateCursor(props);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      if (this._selectedEditHandle) {\n        this._isRotating = true;\n        this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection(props);\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      if (this._isRotating) {\n        // Rotate the geometry\n        var rotateAction = this.getRotateAction(event.pointerDownMapCoords, event.mapCoords, 'rotated', props);\n\n        if (rotateAction) {\n          props.onEdit(rotateAction);\n        }\n\n        this._geometryBeingRotated = null;\n        this._selectedEditHandle = null;\n        this._isRotating = false;\n      }\n    }\n  }, {\n    key: \"updateCursor\",\n    value: function updateCursor(props) {\n      if (this._selectedEditHandle) {\n        // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n        props.onUpdateCursor('crosshair');\n      } else {\n        props.onUpdateCursor(null);\n      }\n    }\n  }, {\n    key: \"getRotateAction\",\n    value: function getRotateAction(startDragPoint, currentPoint, editType, props) {\n      if (!this._geometryBeingRotated) {\n        return null;\n      }\n\n      var centroid = (0, _centroid[\"default\"])(this._geometryBeingRotated);\n      var angle = getRotationAngle(centroid, startDragPoint, currentPoint); // @ts-ignore\n\n      var rotatedFeatures = (0, _transformRotate[\"default\"])( // @ts-ignore\n      this._geometryBeingRotated, angle, {\n        pivot: centroid\n      });\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n      var selectedIndexes = props.selectedIndexes;\n\n      for (var i = 0; i < selectedIndexes.length; i++) {\n        var selectedIndex = selectedIndexes[i];\n        var movedFeature = rotatedFeatures.features[i];\n        updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n      }\n\n      return {\n        updatedData: updatedData.getObject(),\n        editType: editType,\n        editContext: {\n          featureIndexes: selectedIndexes\n        }\n      };\n    }\n  }]);\n\n  return RotateMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.RotateMode = RotateMode;\n\nfunction getRotationAngle(centroid, startDragPoint, currentPoint) {\n  var bearing1 = (0, _bearing[\"default\"])(centroid, startDragPoint);\n  var bearing2 = (0, _bearing[\"default\"])(centroid, currentPoint);\n  return bearing2 - bearing1;\n}","map":{"version":3,"sources":["../../src/lib/rotate-mode.ts"],"names":["RotateMode","GeoJsonEditMode","features","geometry","Array","type","props","selectedGeometry","boundingBox","previousCoord","topEdgeMidpointCoords","longestEdgeLength","edgeMidpoint","edgeDistance","Math","rotateHandleCoords","lineFromEnvelopeToRotateHandle","rotateHandle","guideType","editHandleType","event","rotateAction","selectedEditHandle","startDragPoint","currentPoint","editType","centroid","angle","getRotationAngle","rotatedFeatures","pivot","updatedData","ImmutableFeatureCollection","selectedIndexes","i","selectedIndex","movedFeature","editContext","featureIndexes","bearing1","bearing2"],"mappings":"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","sourcesContent":["/* eslint-disable prettier/prettier */\nimport bbox from '@turf/bbox';\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport turfDistance from '@turf/distance';\nimport { coordEach } from '@turf/meta';\nimport { getGeom } from '@turf/invariant';\nimport { point, featureCollection, lineString } from '@turf/helpers';\nimport turfTransformRotate from '@turf/transform-rotate';\nimport polygonToLine from '@turf/polygon-to-line';\nimport {\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  ModeProps,\n  EditHandleFeature,\n  GuideFeatureCollection,\n} from '../types';\nimport { getPickedEditHandle } from '../utils';\nimport { FeatureCollection, Position } from '../geojson-types';\nimport { GeoJsonEditMode, GeoJsonEditAction, getIntermediatePosition } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class RotateMode extends GeoJsonEditMode {\n  _selectedEditHandle: EditHandleFeature | null | undefined;\n  _geometryBeingRotated: FeatureCollection | null | undefined;\n  _isRotating = false;\n\n  _isSinglePointGeometrySelected = (geometry: FeatureCollection | null | undefined): boolean => {\n    const { features } = geometry || {};\n    if (Array.isArray(features) && features.length === 1) {\n      // @ts-ignore\n      const { type } = getGeom(features[0]);\n      return type === 'Point';\n    }\n    return false;\n  };\n\n  getIsRotating = () => this._isRotating;\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    const selectedGeometry =\n      this._geometryBeingRotated || this.getSelectedFeaturesAsFeatureCollection(props);\n\n    if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n      return { type: 'FeatureCollection', features: [] };\n    }\n\n    if (this._isRotating) {\n      // Display rotate pivot\n      return featureCollection([turfCentroid(selectedGeometry)]) as GuideFeatureCollection;\n    }\n\n    const boundingBox = bboxPolygon(bbox(selectedGeometry));\n\n    let previousCoord = null;\n    let topEdgeMidpointCoords = null;\n    let longestEdgeLength = 0;\n\n    coordEach(boundingBox, (coord) => {\n      if (previousCoord) {\n        // @ts-ignore\n        const edgeMidpoint = getIntermediatePosition(coord, previousCoord);\n        if (!topEdgeMidpointCoords || edgeMidpoint[1] > topEdgeMidpointCoords[1]) {\n          // Get the top edge midpoint of the enveloping box\n          topEdgeMidpointCoords = edgeMidpoint;\n        }\n        // Get the length of the longest edge of the enveloping box\n        const edgeDistance = turfDistance(coord, previousCoord);\n        longestEdgeLength = Math.max(longestEdgeLength, edgeDistance);\n      }\n      previousCoord = coord;\n    });\n\n    // Scale the length of the line between the rotate handler and the enveloping box\n    // relative to the length of the longest edge of the enveloping box\n    const rotateHandleCoords = topEdgeMidpointCoords && [\n      topEdgeMidpointCoords[0],\n      topEdgeMidpointCoords[1] + longestEdgeLength / 1000,\n    ];\n\n    const lineFromEnvelopeToRotateHandle = lineString([topEdgeMidpointCoords, rotateHandleCoords]);\n    const rotateHandle = point(rotateHandleCoords, {\n      guideType: 'editHandle',\n      editHandleType: 'rotate',\n    });\n    // @ts-ignore\n    return featureCollection([\n      // @ts-ignore\n      polygonToLine(boundingBox),\n      // @ts-ignore\n      rotateHandle,\n      // @ts-ignore\n      lineFromEnvelopeToRotateHandle,\n    ]);\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isRotating) {\n      return;\n    }\n\n    const rotateAction = this.getRotateAction(\n      event.pointerDownMapCoords,\n      event.mapCoords,\n      'rotating',\n      props\n    );\n    if (rotateAction) {\n      props.onEdit(rotateAction);\n    }\n\n    event.cancelPan();\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isRotating) {\n      const selectedEditHandle = getPickedEditHandle(event.picks);\n      this._selectedEditHandle =\n        selectedEditHandle && selectedEditHandle.properties.editHandleType === 'rotate'\n          ? selectedEditHandle\n          : null;\n    }\n\n    this.updateCursor(props);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      this._isRotating = true;\n      this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection(props);\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._isRotating) {\n      // Rotate the geometry\n      const rotateAction = this.getRotateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'rotated',\n        props\n      );\n\n      if (rotateAction) {\n        props.onEdit(rotateAction);\n      }\n\n      this._geometryBeingRotated = null;\n      this._selectedEditHandle = null;\n      this._isRotating = false;\n    }\n  }\n\n  updateCursor(props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n      props.onUpdateCursor('crosshair');\n    } else {\n      props.onUpdateCursor(null);\n    }\n  }\n\n  getRotateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ): GeoJsonEditAction | null | undefined {\n    if (!this._geometryBeingRotated) {\n      return null;\n    }\n\n    const centroid = turfCentroid(this._geometryBeingRotated);\n    const angle = getRotationAngle(centroid, startDragPoint, currentPoint);\n    // @ts-ignore\n    const rotatedFeatures: FeatureCollection = turfTransformRotate(\n      // @ts-ignore\n      this._geometryBeingRotated,\n      angle,\n      {\n        pivot: centroid,\n      }\n    );\n\n    let updatedData = new ImmutableFeatureCollection(props.data);\n\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = rotatedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      editContext: {\n        featureIndexes: selectedIndexes,\n      },\n    };\n  }\n}\n\nfunction getRotationAngle(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const bearing1 = turfBearing(centroid, startDragPoint);\n  const bearing2 = turfBearing(centroid, currentPoint);\n  return bearing2 - bearing1;\n}\n"]},"metadata":{},"sourceType":"script"}