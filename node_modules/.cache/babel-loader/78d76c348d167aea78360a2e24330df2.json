{"ast":null,"code":"import { getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates, getTextureParams } from './heatmap-layer-utils';\nimport { Buffer, Texture2D, Transform, getParameters, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { AttributeManager, COORDINATE_SYSTEM, log } from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer from '../aggregation-layer';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport weights_vs from './weights-vs.glsl';\nimport weights_fs from './weights-fs.glsl';\nimport vs_max from './max-vs.glsl';\nimport fs_max from './max-fs.glsl';\nconst RESOLUTION = 2;\nconst TEXTURE_OPTIONS = {\n  mipmaps: false,\n  parameters: {\n    [10240]: 9729,\n    [10241]: 9729,\n    [10242]: 33071,\n    [10243]: 33071\n  },\n  dataFormat: 6408\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\nconst defaultProps = {\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  intensity: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusPixels: {\n    type: 'number',\n    min: 1,\n    max: 100,\n    value: 50\n  },\n  colorRange: defaultColorRange,\n  threshold: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0.05\n  },\n  colorDomain: {\n    type: 'array',\n    value: null,\n    optional: true\n  },\n  aggregation: 'SUM',\n  weightsTextureSize: {\n    type: 'number',\n    min: 128,\n    max: 2048,\n    value: 2048\n  },\n  debounceTimeout: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 500\n  }\n};\nconst REQUIRED_FEATURES = [FEATURES.BLEND_EQUATION_MINMAX, FEATURES.TEXTURE_FLOAT];\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\nexport default class HeatmapLayer extends AggregationLayer {\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n\n    if (!hasFeatures(gl, REQUIRED_FEATURES)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"HeatmapLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n\n    super.initializeState(DIMENSIONS);\n    this.setState({\n      supported: true,\n      colorDomain: DEFAULT_COLOR_DOMAIN\n    });\n\n    this._setupTextureParams();\n\n    this._setupAttributes();\n\n    this._setupResources();\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    if (!this.state.supported) {\n      return;\n    }\n\n    super.updateState(opts);\n\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      clearTimeout(this.state.updateTimer);\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else if (changeFlags.viewportZoomChanged) {\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({\n      zoom: opts.context.viewport.zoom\n    });\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {\n      updateTriggers,\n      intensity,\n      threshold,\n      aggregation\n    } = this.props;\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n    return new TriangleLayerClass(this.getSubLayerProps({\n      id: 'triangle-layer',\n      updateTriggers\n    }), {\n      coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n      data: {\n        attributes: {\n          positions: triPositionBuffer,\n          texCoords: triTexCoordBuffer\n        }\n      },\n      vertexCount: 4,\n      maxTexture: maxWeightsTexture,\n      colorTexture,\n      aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n      texture: weightsTexture,\n      intensity,\n      threshold,\n      colorDomain\n    });\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform === null || weightsTransform === void 0 ? void 0 : weightsTransform.delete();\n    weightsTexture === null || weightsTexture === void 0 ? void 0 : weightsTexture.delete();\n    maxWeightTransform === null || maxWeightTransform === void 0 ? void 0 : maxWeightTransform.delete();\n    maxWeightsTexture === null || maxWeightsTexture === void 0 ? void 0 : maxWeightsTexture.delete();\n    triPositionBuffer === null || triPositionBuffer === void 0 ? void 0 : triPositionBuffer.delete();\n    triTexCoordBuffer === null || triTexCoordBuffer === void 0 ? void 0 : triTexCoordBuffer.delete();\n    colorTexture === null || colorTexture === void 0 ? void 0 : colorTexture.delete();\n    updateTimer && clearTimeout(updateTimer);\n  }\n\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts) {\n    const changeFlags = {};\n    const {\n      dimensions\n    } = this.state;\n    changeFlags.dataChanged = this.isAttributeChanged() || this.isAggregationDirty(opts, {\n      compareAll: true,\n      dimension: dimensions.data\n    });\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n    const {\n      zoom\n    } = this.state;\n\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {\n      gl\n    } = this.context;\n    const {\n      textureSize,\n      format,\n      type\n    } = this.state;\n    this.setState({\n      weightsTexture: new Texture2D(gl, {\n        width: textureSize,\n        height: textureSize,\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      }),\n      maxWeightsTexture: new Texture2D(gl, {\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      })\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        type: 5130,\n        accessor: 'getPosition'\n      },\n      weights: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n    this.setState({\n      positionAttributeName: 'positions'\n    });\n  }\n\n  _setupTextureParams() {\n    const {\n      gl\n    } = this.context;\n    const {\n      weightsTextureSize\n    } = this.props;\n    const textureSize = Math.min(weightsTextureSize, getParameters(gl, 3379));\n    const floatTargetSupport = hasFeatures(gl, FEATURES.COLOR_ATTACHMENT_RGBA32F);\n    const {\n      format,\n      type\n    } = getTextureParams({\n      gl,\n      floatTargetSupport\n    });\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({\n      textureSize,\n      format,\n      type,\n      weightsScale\n    });\n\n    if (!floatTargetSupport) {\n      log.warn(\"HeatmapLayer: \".concat(this.id, \" rendering to float texture not supported, fallingback to low precession format\"))();\n    }\n  }\n\n  getShaders(type) {\n    return super.getShaders(type === 'max-weights-transform' ? {\n      vs: vs_max,\n      _fs: fs_max\n    } : {\n      vs: weights_vs,\n      _fs: weights_fs\n    });\n  }\n\n  _createWeightsTransform() {\n    var _weightsTransform;\n\n    let shaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      gl\n    } = this.context;\n    let {\n      weightsTransform\n    } = this.state;\n    const {\n      weightsTexture\n    } = this.state;\n    (_weightsTransform = weightsTransform) === null || _weightsTransform === void 0 ? void 0 : _weightsTransform.delete();\n    weightsTransform = new Transform(gl, {\n      id: \"\".concat(this.id, \"-weights-transform\"),\n      elementCount: 1,\n      _targetTexture: weightsTexture,\n      _targetTextureVarying: 'weightsTexture',\n      ...shaders\n    });\n    this.setState({\n      weightsTransform\n    });\n  }\n\n  _setupResources() {\n    const {\n      gl\n    } = this.context;\n\n    this._createTextures();\n\n    const {\n      textureSize,\n      weightsTexture,\n      maxWeightsTexture\n    } = this.state;\n    const weightsTransformShaders = this.getShaders('weights-transform');\n\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders('max-weights-transform');\n    const maxWeightTransform = new Transform(gl, {\n      id: \"\".concat(this.id, \"-max-weights-transform\"),\n      _sourceTextures: {\n        inTexture: weightsTexture\n      },\n      _targetTexture: maxWeightsTexture,\n      _targetTextureVarying: 'outTexture',\n      ...maxWeightsTransformShaders,\n      elementCount: textureSize * textureSize\n    });\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {\n          size: 3\n        }\n      }),\n      triTexCoordBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {\n          size: 2\n        }\n      })\n    });\n  }\n\n  updateShaders(shaderOptions) {\n    this._createWeightsTransform(shaderOptions);\n  }\n\n  _updateMaxWeightValue() {\n    const {\n      maxWeightTransform\n    } = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1],\n        blendEquation: 32776\n      }\n    });\n  }\n\n  _updateBounds() {\n    let forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      viewport\n    } = this.context;\n    const viewportCorners = [viewport.unproject([0, 0]), viewport.unproject([viewport.width, 0]), viewport.unproject([viewport.width, viewport.height]), viewport.unproject([0, viewport.height])].map(p => p.map(Math.fround));\n    const visibleWorldBounds = getBounds(viewportCorners);\n    const newState = {\n      visibleWorldBounds,\n      viewportCorners\n    };\n    let boundsChanged = false;\n\n    if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n      boundsChanged = true;\n    }\n\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    const {\n      triPositionBuffer,\n      triTexCoordBuffer,\n      normalizedCommonBounds,\n      viewportCorners\n    } = this.state;\n    const {\n      viewport\n    } = this.context;\n    triPositionBuffer.subData(packVertices(viewportCorners, 3));\n    const textureBounds = viewportCorners.map(p => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds));\n    triTexCoordBuffer.subData(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {\n      colorRange\n    } = opts.props;\n    let {\n      colorTexture\n    } = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n\n    if (colorTexture) {\n      colorTexture.setImageData({\n        data: colors,\n        width: colorRange.length\n      });\n    } else {\n      colorTexture = new Texture2D(this.context.gl, {\n        data: colors,\n        width: colorRange.length,\n        height: 1,\n        ...TEXTURE_OPTIONS\n      });\n    }\n\n    this.setState({\n      colorTexture\n    });\n  }\n\n  _updateWeightmap() {\n    const {\n      radiusPixels,\n      colorDomain,\n      aggregation\n    } = this.props;\n    const {\n      weightsTransform,\n      worldBounds,\n      textureSize,\n      weightsTexture,\n      weightsScale\n    } = this.state;\n    this.state.isWeightMapDirty = false;\n\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      const {\n        viewport\n      } = this.context;\n      const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const uniforms = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale\n    };\n    weightsTransform.update({\n      elementCount: this.getNumInstances()\n    });\n    weightsTransform.run({\n      uniforms,\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1],\n        blendEquation: 32774\n      },\n      clearRenderTarget: true,\n      attributes: this.getAttributes(),\n      moduleSettings: this.getModuleSettings()\n    });\n\n    this._updateMaxWeightValue();\n\n    weightsTexture.setParameters({\n      [10240]: 9729,\n      [10241]: 9729\n    });\n  }\n\n  _debouncedUpdateWeightmap() {\n    let fromTimer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let {\n      updateTimer\n    } = this.state;\n    const {\n      debounceTimeout\n    } = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n\n      this._updateBounds(true);\n\n      this._updateTextureRenderingBounds();\n\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else {\n      this.setState({\n        isWeightMapDirty: false\n      });\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({\n      updateTimer\n    });\n  }\n\n  _worldToCommonBounds(worldBounds) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      useLayerCoordinateSystem = false\n    } = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {\n      viewport\n    } = this.context;\n    const {\n      textureSize\n    } = this.state;\n    const {\n      coordinateSystem\n    } = this.props;\n    const offsetMode = useLayerCoordinateSystem && (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];\n    const size = textureSize * RESOLUTION / viewport.scale;\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n\n    return scaleToAspectRatio([bottomLeftCommon[0] - offsetOriginCommon[0], bottomLeftCommon[1] - offsetOriginCommon[1], topRightCommon[0] - offsetOriginCommon[0], topRightCommon[1] - offsetOriginCommon[1]], size, size);\n  }\n\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {\n      viewport\n    } = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n\n}\nHeatmapLayer.layerName = 'HeatmapLayer';\nHeatmapLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/heatmap-layer/heatmap-layer.js"],"names":["RESOLUTION","TEXTURE_OPTIONS","mipmaps","parameters","dataFormat","DEFAULT_COLOR_DOMAIN","AGGREGATION_MODE","SUM","MEAN","defaultProps","getPosition","type","value","x","position","getWeight","intensity","min","radiusPixels","max","colorRange","threshold","colorDomain","optional","aggregation","weightsTextureSize","debounceTimeout","REQUIRED_FEATURES","FEATURES","DIMENSIONS","data","props","initializeState","gl","hasFeatures","supported","log","shouldUpdateState","changeFlags","updateState","_updateHeatmapState","oldProps","clearTimeout","isWeightMapDirty","zoom","opts","renderLayers","TriangleLayerClass","id","updateTriggers","coordinateSystem","COORDINATE_SYSTEM","attributes","positions","texCoords","triTexCoordBuffer","vertexCount","maxTexture","aggregationMode","texture","finalizeState","updateTimer","weightsTransform","weightsTexture","maxWeightTransform","maxWeightsTexture","triPositionBuffer","colorTexture","_getAttributeManager","stats","_getChangeFlags","dimensions","compareAll","dimension","_createTextures","width","height","_setupAttributes","attributeManager","size","accessor","weights","positionAttributeName","_setupTextureParams","textureSize","Math","getParameters","floatTargetSupport","getTextureParams","weightsScale","getShaders","vs","_fs","fs_max","weights_fs","_createWeightsTransform","shaders","elementCount","_targetTexture","_targetTextureVarying","_setupResources","weightsTransformShaders","maxWeightsTransformShaders","_sourceTextures","inTexture","byteLength","updateShaders","_updateMaxWeightValue","blend","depthTest","blendFunc","blendEquation","_updateBounds","forceUpdate","viewport","viewportCorners","p","visibleWorldBounds","getBounds","newState","boundsChanged","boundsContain","scaledCommonBounds","worldBounds","normalizedCommonBounds","_updateTextureRenderingBounds","packVertices","textureBounds","getTextureCoordinates","_updateColorTexture","colors","colorRangeToFlatArray","length","_updateWeightmap","commonBounds","useLayerCoordinateSystem","metersPerPixel","uniforms","textureWidth","clearRenderTarget","moduleSettings","_debouncedUpdateWeightmap","fromTimer","setTimeout","_worldToCommonBounds","offsetMode","offsetOriginCommon","bottomLeftCommon","topRightCommon","scaleToAspectRatio","_commonToWorldBounds","bottomLeftWorld","topRightWorld","HeatmapLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global setTimeout clearTimeout */\nimport GL from '@luma.gl/constants';\nimport {\n  getBounds,\n  boundsContain,\n  packVertices,\n  scaleToAspectRatio,\n  getTextureCoordinates,\n  getTextureParams\n} from './heatmap-layer-utils';\nimport {Buffer, Texture2D, Transform, getParameters, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {AttributeManager, COORDINATE_SYSTEM, log} from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer from '../aggregation-layer';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport weights_vs from './weights-vs.glsl';\nimport weights_fs from './weights-fs.glsl';\nimport vs_max from './max-vs.glsl';\nimport fs_max from './max-fs.glsl';\n\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_OPTIONS = {\n  mipmaps: false,\n  parameters: {\n    [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n    [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n  },\n  dataFormat: GL.RGBA\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\n\nconst defaultProps = {\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  intensity: {type: 'number', min: 0, value: 1},\n  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},\n  colorRange: defaultColorRange,\n  threshold: {type: 'number', min: 0, max: 1, value: 0.05},\n  colorDomain: {type: 'array', value: null, optional: true},\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {type: 'number', min: 128, max: 2048, value: 2048},\n  debounceTimeout: {type: 'number', min: 0, max: 1000, value: 500}\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.BLEND_EQUATION_MINMAX, // max weight calculation\n  FEATURES.TEXTURE_FLOAT // weight-map as texture\n  // FEATURES.FLOAT_BLEND, // implictly supported when TEXTURE_FLOAT is supported\n];\n\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n\nexport default class HeatmapLayer extends AggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    if (!hasFeatures(gl, REQUIRED_FEATURES)) {\n      this.setState({supported: false});\n      log.error(`HeatmapLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeState(DIMENSIONS);\n    this.setState({supported: true, colorDomain: DEFAULT_COLOR_DOMAIN});\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n\n  /* eslint-disable max-statements,complexity */\n  updateState(opts) {\n    if (!this.state.supported) {\n      return;\n    }\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts) {\n    const {props, oldProps} = opts;\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({isWeightMapDirty: true});\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({zoom: opts.context.viewport.zoom});\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {updateTriggers, intensity, threshold, aggregation} = this.props;\n\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n\n    return new TriangleLayerClass(\n      this.getSubLayerProps({\n        id: 'triangle-layer',\n        updateTriggers\n      }),\n      {\n        // position buffer is filled with world coordinates generated from viewport.unproject\n        // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n        data: {\n          attributes: {\n            positions: triPositionBuffer,\n            texCoords: triTexCoordBuffer\n          }\n        },\n        vertexCount: 4,\n        maxTexture: maxWeightsTexture,\n        colorTexture,\n        aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n        texture: weightsTexture,\n        intensity,\n        threshold,\n        colorDomain\n      }\n    );\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.delete();\n    weightsTexture?.delete();\n    maxWeightTransform?.delete();\n    maxWeightsTexture?.delete();\n    triPositionBuffer?.delete();\n    triTexCoordBuffer?.delete();\n    colorTexture?.delete();\n    updateTimer && clearTimeout(updateTimer);\n  }\n\n  // PRIVATE\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts) {\n    const changeFlags = {};\n    const {dimensions} = this.state;\n    changeFlags.dataChanged =\n      this.isAttributeChanged() || // if any attribute is changed\n      this.isAggregationDirty(opts, {\n        compareAll: true,\n        dimension: dimensions.data\n      });\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n\n    const {zoom} = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {gl} = this.context;\n    const {textureSize, format, type} = this.state;\n\n    this.setState({\n      weightsTexture: new Texture2D(gl, {\n        width: textureSize,\n        height: textureSize,\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      }),\n      maxWeightsTexture: new Texture2D(gl, {format, type, ...TEXTURE_OPTIONS}) // 1 X 1 texture,\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'},\n      weights: {size: 1, accessor: 'getWeight'}\n    });\n    this.setState({positionAttributeName: 'positions'});\n  }\n\n  _setupTextureParams() {\n    const {gl} = this.context;\n    const {weightsTextureSize} = this.props;\n\n    const textureSize = Math.min(weightsTextureSize, getParameters(gl, gl.MAX_TEXTURE_SIZE));\n    const floatTargetSupport = hasFeatures(gl, FEATURES.COLOR_ATTACHMENT_RGBA32F);\n    const {format, type} = getTextureParams({gl, floatTargetSupport});\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({textureSize, format, type, weightsScale});\n    if (!floatTargetSupport) {\n      log.warn(\n        `HeatmapLayer: ${\n          this.id\n        } rendering to float texture not supported, fallingback to low precession format`\n      )();\n    }\n  }\n\n  getShaders(type) {\n    return super.getShaders(\n      type === 'max-weights-transform'\n        ? {\n            vs: vs_max,\n            _fs: fs_max\n          }\n        : {\n            vs: weights_vs,\n            _fs: weights_fs\n          }\n    );\n  }\n\n  _createWeightsTransform(shaders = {}) {\n    const {gl} = this.context;\n    let {weightsTransform} = this.state;\n    const {weightsTexture} = this.state;\n    weightsTransform?.delete();\n\n    weightsTransform = new Transform(gl, {\n      id: `${this.id}-weights-transform`,\n      elementCount: 1,\n      _targetTexture: weightsTexture,\n      _targetTextureVarying: 'weightsTexture',\n      ...shaders\n    });\n    this.setState({weightsTransform});\n  }\n\n  _setupResources() {\n    const {gl} = this.context;\n    this._createTextures();\n    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;\n\n    const weightsTransformShaders = this.getShaders('weights-transform');\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders('max-weights-transform');\n    const maxWeightTransform = new Transform(gl, {\n      id: `${this.id}-max-weights-transform`,\n      _sourceTextures: {\n        inTexture: weightsTexture\n      },\n      _targetTexture: maxWeightsTexture,\n      _targetTextureVarying: 'outTexture',\n      ...maxWeightsTransformShaders,\n      elementCount: textureSize * textureSize\n    });\n\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 3}\n      }),\n      triTexCoordBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 2}\n      })\n    });\n  }\n\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // sahder params (modules, injects) changed, update model object\n    this._createWeightsTransform(shaderOptions);\n  }\n\n  _updateMaxWeightValue() {\n    const {maxWeightTransform} = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: GL.MAX\n      }\n    });\n  }\n\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds(forceUpdate = false) {\n    const {viewport} = this.context;\n\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [\n      viewport.unproject([0, 0]),\n      viewport.unproject([viewport.width, 0]),\n      viewport.unproject([viewport.width, viewport.height]),\n      viewport.unproject([0, viewport.height])\n    ].map(p => p.map(Math.fround));\n\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n\n    const newState = {visibleWorldBounds, viewportCorners};\n    let boundsChanged = false;\n\n    if (\n      forceUpdate ||\n      !this.state.worldBounds ||\n      !boundsContain(this.state.worldBounds, visibleWorldBounds)\n    ) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {\n      triPositionBuffer,\n      triTexCoordBuffer,\n      normalizedCommonBounds,\n      viewportCorners\n    } = this.state;\n\n    const {viewport} = this.context;\n\n    triPositionBuffer.subData(packVertices(viewportCorners, 3));\n\n    const textureBounds = viewportCorners.map(p =>\n      getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds)\n    );\n    triTexCoordBuffer.subData(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n\n    if (colorTexture) {\n      colorTexture.setImageData({\n        data: colors,\n        width: colorRange.length\n      });\n    } else {\n      colorTexture = new Texture2D(this.context.gl, {\n        data: colors,\n        width: colorRange.length,\n        height: 1,\n        ...TEXTURE_OPTIONS\n      });\n    }\n    this.setState({colorTexture});\n  }\n\n  _updateWeightmap() {\n    const {radiusPixels, colorDomain, aggregation} = this.props;\n    const {weightsTransform, worldBounds, textureSize, weightsTexture, weightsScale} = this.state;\n    this.state.isWeightMapDirty = false;\n\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {viewport} = this.context;\n      const metersPerPixel =\n        (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n        textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const uniforms = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale\n    };\n    // Attribute manager sets data array count as instaceCount on model\n    // we need to set that as elementCount on 'weightsTransform'\n    weightsTransform.update({\n      elementCount: this.getNumInstances()\n    });\n    weightsTransform.run({\n      uniforms,\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: GL.FUNC_ADD\n      },\n      clearRenderTarget: true,\n      attributes: this.getAttributes(),\n      moduleSettings: this.getModuleSettings()\n    });\n    this._updateMaxWeightValue();\n\n    // reset filtering parameters (TODO: remove once luma issue#1193 is fixed)\n    weightsTexture.setParameters({\n      [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n      [GL.TEXTURE_MIN_FILTER]: GL.LINEAR\n    });\n  }\n\n  _debouncedUpdateWeightmap(fromTimer = false) {\n    let {updateTimer} = this.state;\n    const {debounceTimeout} = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({isWeightMapDirty: true});\n    } else {\n      this.setState({isWeightMapDirty: false});\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({updateTimer});\n  }\n\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(worldBounds, opts = {}) {\n    const {useLayerCoordinateSystem = false} = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {viewport} = this.context;\n    const {textureSize} = this.state;\n    const {coordinateSystem} = this.props;\n\n    const offsetMode =\n      useLayerCoordinateSystem &&\n      (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode\n      ? viewport.projectPosition(this.props.coordinateOrigin)\n      : [0, 0];\n    const size = (textureSize * RESOLUTION) / viewport.scale;\n\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio(\n      [\n        bottomLeftCommon[0] - offsetOriginCommon[0],\n        bottomLeftCommon[1] - offsetOriginCommon[1],\n        topRightCommon[0] - offsetOriginCommon[0],\n        topRightCommon[1] - offsetOriginCommon[1]\n      ],\n      size,\n      size\n    );\n  }\n\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {viewport} = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\n\nHeatmapLayer.layerName = 'HeatmapLayer';\nHeatmapLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}