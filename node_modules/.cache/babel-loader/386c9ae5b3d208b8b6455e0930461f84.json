{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { WorkerFarm, getWorkerURL } from '@loaders.gl/worker-utils';\nexport function canParseWithWorker(loader, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);\n}\nexport function parseWithWorker(_x, _x2, _x3, _x4, _x5) {\n  return _parseWithWorker.apply(this, arguments);\n}\n\nfunction _parseWithWorker() {\n  _parseWithWorker = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(loader, data, options, context, parseOnMainThread) {\n    var name, url, workerFarm, workerPool, job, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            name = loader.id;\n            url = getWorkerURL(loader, options);\n            workerFarm = WorkerFarm.getWorkerFarm(options);\n            workerPool = workerFarm.getWorkerPool({\n              name: name,\n              url: url\n            });\n            options = JSON.parse(JSON.stringify(options));\n            _context.next = 7;\n            return workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));\n\n          case 7:\n            job = _context.sent;\n            job.postMessage('process', {\n              input: data,\n              options: options\n            });\n            _context.next = 11;\n            return job.result;\n\n          case 11:\n            result = _context.sent;\n            _context.next = 14;\n            return result.result;\n\n          case 14:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseWithWorker.apply(this, arguments);\n}\n\nfunction onMessage(_x6, _x7, _x8, _x9) {\n  return _onMessage.apply(this, arguments);\n}\n\nfunction _onMessage() {\n  _onMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(parseOnMainThread, job, type, payload) {\n    var id, input, options, result, message;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = type;\n            _context2.next = _context2.t0 === 'done' ? 3 : _context2.t0 === 'error' ? 5 : _context2.t0 === 'process' ? 7 : 20;\n            break;\n\n          case 3:\n            job.done(payload);\n            return _context2.abrupt(\"break\", 21);\n\n          case 5:\n            job.error(new Error(payload.error));\n            return _context2.abrupt(\"break\", 21);\n\n          case 7:\n            id = payload.id, input = payload.input, options = payload.options;\n            _context2.prev = 8;\n            _context2.next = 11;\n            return parseOnMainThread(input, options);\n\n          case 11:\n            result = _context2.sent;\n            job.postMessage('done', {\n              id: id,\n              result: result\n            });\n            _context2.next = 19;\n            break;\n\n          case 15:\n            _context2.prev = 15;\n            _context2.t1 = _context2[\"catch\"](8);\n            message = _context2.t1 instanceof Error ? _context2.t1.message : 'unknown error';\n            job.postMessage('error', {\n              id: id,\n              error: message\n            });\n\n          case 19:\n            return _context2.abrupt(\"break\", 21);\n\n          case 20:\n            console.warn(\"parse-with-worker unknown message \".concat(type));\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[8, 15]]);\n  }));\n  return _onMessage.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/worker-loader-utils/parse-with-worker.ts"],"names":["WorkerFarm","loader","options","name","url","getWorkerURL","workerFarm","workerPool","JSON","job","onMessage","input","result","payload","parseOnMainThread","id","message","error","console"],"mappings":"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","sourcesContent":["import type {WorkerJob, WorkerMessageType, WorkerMessagePayload} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data: any,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // @ts-expect-error\n    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options\n  });\n\n  const result = await job.result;\n  // TODO - what is going on here?\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread: (arrayBuffer: ArrayBuffer, options?: {[key: string]: any}) => Promise<void>,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}