{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport Effect from '../lib/effect';\nimport ScreenPass from '../passes/screen-pass';\nimport { normalizeShaderModule } from '@luma.gl/core';\n\nvar PostProcessEffect = /*#__PURE__*/function (_Effect) {\n  _inherits(PostProcessEffect, _Effect);\n\n  var _super = _createSuper(PostProcessEffect);\n\n  function PostProcessEffect(module) {\n    var _this;\n\n    _classCallCheck(this, PostProcessEffect);\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _this = _super.call(this, props);\n    _this.id = \"\".concat(module.name, \"-pass\");\n    normalizeShaderModule(module);\n    _this.module = module;\n    return _this;\n  }\n\n  _createClass(PostProcessEffect, [{\n    key: \"postRender\",\n    value: function postRender(gl, params) {\n      if (!this.passes) {\n        this.passes = createPasses(gl, this.module, this.id, this.props);\n      }\n\n      var target = params.target;\n      var inputBuffer = params.inputBuffer;\n      var outputBuffer = params.swapBuffer;\n\n      for (var index = 0; index < this.passes.length; index++) {\n        if (target && index === this.passes.length - 1) {\n          outputBuffer = target;\n        }\n\n        this.passes[index].render({\n          inputBuffer: inputBuffer,\n          outputBuffer: outputBuffer\n        });\n        var switchBuffer = outputBuffer;\n        outputBuffer = inputBuffer;\n        inputBuffer = switchBuffer;\n      }\n\n      return inputBuffer;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.passes) {\n        var _iterator = _createForOfIteratorHelper(this.passes),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var pass = _step.value;\n            pass.delete();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.passes = null;\n      }\n    }\n  }]);\n\n  return PostProcessEffect;\n}(Effect);\n\nexport { PostProcessEffect as default };\n\nfunction createPasses(gl, module, id, moduleSettings) {\n  if (module.filter || module.sampler) {\n    var fs = getFragmentShaderForRenderPass(module);\n    var pass = new ScreenPass(gl, {\n      id: id,\n      module: module,\n      fs: fs,\n      moduleSettings: moduleSettings\n    });\n    return [pass];\n  }\n\n  var passes = module.passes || [];\n  return passes.map(function (pass, index) {\n    var fs = getFragmentShaderForRenderPass(module, pass);\n    var idn = \"\".concat(id, \"-\").concat(index);\n    return new ScreenPass(gl, {\n      id: idn,\n      module: module,\n      fs: fs,\n      moduleSettings: moduleSettings\n    });\n  });\n}\n\nvar FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = texture2D(texture, texCoord);\\n  gl_FragColor = \".concat(func, \"(gl_FragColor, texSize, texCoord);\\n}\\n\");\n};\n\nvar SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = \".concat(func, \"(texture, texSize, texCoord);\\n}\\n\");\n};\n\nfunction getFragmentShaderForRenderPass(module) {\n  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;\n\n  if (pass.filter) {\n    var func = typeof pass.filter === 'string' ? pass.filter : \"\".concat(module.name, \"_filterColor\");\n    return FILTER_FS_TEMPLATE(func);\n  }\n\n  if (pass.sampler) {\n    var _func = typeof pass.sampler === 'string' ? pass.sampler : \"\".concat(module.name, \"_sampleColor\");\n\n    return SAMPLER_FS_TEMPLATE(_func);\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../../src/effects/post-process-effect.js"],"names":["constructor","props","module","normalizeShaderModule","createPasses","target","inputBuffer","params","outputBuffer","index","switchBuffer","pass","fs","getFragmentShaderForRenderPass","id","moduleSettings","passes","idn","FILTER_FS_TEMPLATE","func","SAMPLER_FS_TEMPLATE"],"mappings":"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","sourcesContent":["import Effect from '../lib/effect';\nimport ScreenPass from '../passes/screen-pass';\nimport {normalizeShaderModule} from '@luma.gl/core';\n\nexport default class PostProcessEffect extends Effect {\n  constructor(module, props = {}) {\n    super(props);\n    this.id = `${module.name}-pass`;\n    normalizeShaderModule(module);\n    this.module = module;\n  }\n\n  postRender(gl, params) {\n    if (!this.passes) {\n      this.passes = createPasses(gl, this.module, this.id, this.props);\n    }\n\n    const {target} = params;\n    let inputBuffer = params.inputBuffer;\n    let outputBuffer = params.swapBuffer;\n\n    for (let index = 0; index < this.passes.length; index++) {\n      if (target && index === this.passes.length - 1) {\n        outputBuffer = target;\n      }\n      this.passes[index].render({inputBuffer, outputBuffer});\n      const switchBuffer = outputBuffer;\n      outputBuffer = inputBuffer;\n      inputBuffer = switchBuffer;\n    }\n    return inputBuffer;\n  }\n\n  cleanup() {\n    if (this.passes) {\n      for (const pass of this.passes) {\n        pass.delete();\n      }\n      this.passes = null;\n    }\n  }\n}\n\nfunction createPasses(gl, module, id, moduleSettings) {\n  if (module.filter || module.sampler) {\n    const fs = getFragmentShaderForRenderPass(module);\n    const pass = new ScreenPass(gl, {\n      id,\n      module,\n      fs,\n      moduleSettings\n    });\n    return [pass];\n  }\n\n  const passes = module.passes || [];\n  return passes.map((pass, index) => {\n    const fs = getFragmentShaderForRenderPass(module, pass);\n    const idn = `${id}-${index}`;\n\n    return new ScreenPass(gl, {\n      id: idn,\n      module,\n      fs,\n      moduleSettings\n    });\n  });\n}\n\nconst FILTER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ${func}(gl_FragColor, texSize, texCoord);\n}\n`;\n\nconst SAMPLER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ${func}(texture, texSize, texCoord);\n}\n`;\n\nfunction getFragmentShaderForRenderPass(module, pass = module) {\n  if (pass.filter) {\n    const func = typeof pass.filter === 'string' ? pass.filter : `${module.name}_filterColor`;\n    return FILTER_FS_TEMPLATE(func);\n  }\n\n  if (pass.sampler) {\n    const func = typeof pass.sampler === 'string' ? pass.sampler : `${module.name}_sampleColor`;\n    return SAMPLER_FS_TEMPLATE(func);\n  }\n\n  // console.error(`${module.name} no fragment shader generated`);\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}