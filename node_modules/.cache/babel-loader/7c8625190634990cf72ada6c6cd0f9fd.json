{"ast":null,"code":"import { useRef, useState, useEffect, useCallback, useMemo } from 'react';\nimport debounce from 'lodash/debounce';\nimport { useGridResize, useEmitGridResize } from '../app/state/hooks';\nimport { VITESSCE_CONTAINER } from './classNames';\n\nfunction getWindowDimensions() {\n  const {\n    innerWidth: width,\n    innerHeight: height\n  } = window;\n  return {\n    width,\n    height\n  };\n}\n\nexport function useVitessceContainer(ref) {\n  return useCallback(() => {\n    if (ref.current) {\n      return ref.current.closest(`.${VITESSCE_CONTAINER}`);\n    }\n\n    return null;\n  }, [ref]);\n}\n/**\n * Custom hook, gets the full window dimensions.\n * @returns {array} `[width, height]` where width and height\n * are numbers.\n */\n\nexport function useWindowDimensions() {\n  const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    const onResizeDebounced = debounce(handleResize, 100, {\n      trailing: true\n    });\n    window.addEventListener('resize', onResizeDebounced);\n    return () => window.removeEventListener('resize', onResizeDebounced);\n  }, []);\n  return windowDimensions;\n}\n/**\n * Custom hook, subscribes to GRID_RESIZE and window resize events.\n * @returns {array} `[width, height, containerRef]` where width and height\n * are numbers and containerRef is a React ref.\n */\n\nexport function useGridItemSize() {\n  const containerRef = useRef();\n  const [height, setHeight] = useState();\n  const [width, setWidth] = useState();\n  const resizeCount = useGridResize();\n  const incrementResizeCount = useEmitGridResize(); // On window resize events, increment the grid resize count.\n\n  useEffect(() => {\n    function onWindowResize() {\n      incrementResizeCount();\n    }\n\n    const onResizeDebounced = debounce(onWindowResize, 100, {\n      trailing: true\n    });\n    window.addEventListener('resize', onResizeDebounced);\n    onWindowResize();\n    return () => {\n      window.removeEventListener('resize', onResizeDebounced);\n    };\n  }, [incrementResizeCount]); // On new grid resize counts, re-compute the component\n  // width/height.\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const container = containerRef.current;\n    const containerRect = container.getBoundingClientRect();\n    setHeight(containerRect.height);\n    setWidth(containerRect.width);\n  }, [resizeCount]);\n  return [width, height, containerRef];\n}\n/**\n * Custom hook, subscribes to GRID_RESIZE and window resize events.\n * @returns {array} `[width, height, deckRef]` where width and height\n * are numbers and deckRef is a React ref to be used with\n * a <DeckGL/> element (or a forwardRef to one).\n */\n\nexport function useDeckCanvasSize() {\n  const deckRef = useRef();\n  const [height, setHeight] = useState();\n  const [width, setWidth] = useState();\n  const resizeCount = useGridResize();\n  const incrementResizeCount = useEmitGridResize(); // On window resize events, increment the grid resize count.\n\n  useEffect(() => {\n    function onWindowResize() {\n      incrementResizeCount();\n    }\n\n    const onResizeDebounced = debounce(onWindowResize, 100, {\n      trailing: true\n    });\n    window.addEventListener('resize', onResizeDebounced);\n    onWindowResize();\n    return () => {\n      window.removeEventListener('resize', onResizeDebounced);\n    };\n  }, [incrementResizeCount]); // On new grid resize counts, re-compute the DeckGL canvas\n  // width/height.\n\n  useEffect(() => {\n    if (!deckRef.current) return;\n    const {\n      canvas\n    } = deckRef.current.deck;\n    const canvasRect = canvas.getBoundingClientRect();\n    setHeight(canvasRect.height);\n    setWidth(canvasRect.width);\n  }, [resizeCount]);\n  return [width, height, deckRef];\n}\n/**\n * This hook handles a boolean isReady value,\n * which only returns true once every item in the\n * input list has been marked as \"ready\".\n * @param {string[]} items The items to wait on.\n * Should be defined as a constant\n * (outside a function component / render function),\n * otherwise strange bugs may occur.\n * @returns {array} An array\n * [isReady, setItemIsReady, setItemIsNotReady, resetReadyItems]\n * where isReady is the boolean value,\n * setItemIsReady marks one item as ready,\n * setItemIsNotReady marks one item as not ready,\n * and resetReadyItem marks all items as waiting.\n */\n\nexport function useReady(supportedItems) {\n  const items = supportedItems;\n  const [waiting, setWaiting] = useState(items);\n  const setItemIsReady = useCallback(readyItem => {\n    setWaiting(waitingItems => {\n      const nextWaitingItems = waitingItems.filter(item => item !== readyItem); // eslint-disable-next-line no-console\n\n      console.log(`cleared ${readyItem}; waiting on ${nextWaitingItems.length}: ${JSON.stringify(nextWaitingItems)}`);\n      return nextWaitingItems;\n    });\n  }, [setWaiting]);\n  const setItemIsNotReady = useCallback(notReadyItem => {\n    setWaiting(waitingItems => {\n      const nextWaitingItems = [...waitingItems, notReadyItem]; // eslint-disable-next-line no-console\n\n      console.log(`waiting on ${nextWaitingItems.length}: ${JSON.stringify(nextWaitingItems)}`);\n      return nextWaitingItems;\n    });\n  }, [setWaiting]);\n  const resetReadyItems = useCallback(() => {\n    setWaiting(items); // eslint-disable-next-line no-console\n\n    console.log(`waiting on ${items.length}: ${JSON.stringify(items)}`);\n  }, [setWaiting, items]);\n  const isReady = waiting.length === 0;\n  return [isReady, setItemIsReady, setItemIsNotReady, resetReadyItems];\n}\n/**\n * This hook manages a list of URLs,\n * with adding and resetting helpers.\n * @returns {array} An array\n * [urls, addUrl, resetUrls]\n * where urls is the array of URL objects,\n * addUrl is a function for adding a URL to the array,\n * resetUrls is a function that clears the array.\n */\n\nexport function useUrls() {\n  const [urls, setUrls] = useState([]);\n  const addUrl = useCallback((url, name) => {\n    if (url) {\n      setUrls(prev => [...prev, {\n        url,\n        name\n      }]);\n    }\n  }, [setUrls]);\n  const resetUrls = useCallback(() => {\n    setUrls([]);\n  }, [setUrls]);\n  return [urls, addUrl, resetUrls];\n}\n/**\n * Custom hook, subscribes to the width and height of the closest .vitessce-container\n * element and updates upon window resize events.\n * @param {Ref} ref A React ref object within the `.vitessce-container`.\n * @returns {array} `[width, height]` where width and height\n * are numbers.\n */\n\nexport function useClosestVitessceContainerSize(ref) {\n  const [height, setHeight] = useState();\n  const [width, setWidth] = useState();\n  useEffect(() => {\n    function onWindowResize() {\n      if (ref.current) {\n        const {\n          clientHeight: componentHeight,\n          clientWidth: componentWidth\n        } = ref.current.closest('.vitessce-container');\n        setWidth(componentWidth);\n        setHeight(componentHeight);\n      }\n    }\n\n    const onResizeDebounced = debounce(onWindowResize, 100, {\n      trailing: true\n    });\n    window.addEventListener('resize', onResizeDebounced);\n    onWindowResize();\n    return () => {\n      window.removeEventListener('resize', onResizeDebounced);\n    };\n  }, [ref]);\n  return [width, height];\n}\nexport function useExpressionValueGetter({\n  attrs,\n  expressionData\n}) {\n  // Get a mapping from cell ID to row index in the gene expression matrix.\n  const cellIdMap = useMemo(() => {\n    const result = {};\n\n    if (attrs && attrs.rows) {\n      // eslint-disable-next-line no-plusplus\n      for (let i = 0; i < attrs.rows.length; i++) {\n        result[attrs.rows[i]] = i;\n      }\n    }\n\n    return result;\n  }, [attrs]); // Set up a getter function for gene expression values, to be used\n  // by the DeckGL layer to obtain values for instanced attributes.\n\n  const getExpressionValue = useCallback(entry => {\n    const cellId = entry[0];\n\n    if (cellIdMap && expressionData && expressionData[0]) {\n      const cellIndex = cellIdMap[cellId];\n      const val = expressionData[0][cellIndex];\n      return val;\n    }\n\n    return 0;\n  }, [cellIdMap, expressionData]);\n  return getExpressionValue;\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/hooks.js"],"names":["useRef","useState","useEffect","useCallback","useMemo","debounce","useGridResize","useEmitGridResize","VITESSCE_CONTAINER","getWindowDimensions","innerWidth","width","innerHeight","height","window","useVitessceContainer","ref","current","closest","useWindowDimensions","windowDimensions","setWindowDimensions","handleResize","onResizeDebounced","trailing","addEventListener","removeEventListener","useGridItemSize","containerRef","setHeight","setWidth","resizeCount","incrementResizeCount","onWindowResize","container","containerRect","getBoundingClientRect","useDeckCanvasSize","deckRef","canvas","deck","canvasRect","useReady","supportedItems","items","waiting","setWaiting","setItemIsReady","readyItem","waitingItems","nextWaitingItems","filter","item","console","log","length","JSON","stringify","setItemIsNotReady","notReadyItem","resetReadyItems","isReady","useUrls","urls","setUrls","addUrl","url","name","prev","resetUrls","useClosestVitessceContainerSize","clientHeight","componentHeight","clientWidth","componentWidth","useExpressionValueGetter","attrs","expressionData","cellIdMap","result","rows","i","getExpressionValue","entry","cellId","cellIndex","val"],"mappings":"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","sourcesContent":["import {\n  useRef, useState, useEffect, useCallback, useMemo,\n} from 'react';\nimport debounce from 'lodash/debounce';\nimport { useGridResize, useEmitGridResize } from '../app/state/hooks';\nimport { VITESSCE_CONTAINER } from './classNames';\n\nfunction getWindowDimensions() {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n}\n\nexport function useVitessceContainer(ref) {\n  return useCallback(() => {\n    if (ref.current) {\n      return ref.current.closest(`.${VITESSCE_CONTAINER}`);\n    }\n    return null;\n  }, [ref]);\n}\n\n/**\n * Custom hook, gets the full window dimensions.\n * @returns {array} `[width, height]` where width and height\n * are numbers.\n */\nexport function useWindowDimensions() {\n  const [windowDimensions, setWindowDimensions] = useState(\n    getWindowDimensions(),\n  );\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n    const onResizeDebounced = debounce(handleResize, 100, { trailing: true });\n\n    window.addEventListener('resize', onResizeDebounced);\n    return () => window.removeEventListener('resize', onResizeDebounced);\n  }, []);\n\n  return windowDimensions;\n}\n\n/**\n * Custom hook, subscribes to GRID_RESIZE and window resize events.\n * @returns {array} `[width, height, containerRef]` where width and height\n * are numbers and containerRef is a React ref.\n */\nexport function useGridItemSize() {\n  const containerRef = useRef();\n\n  const [height, setHeight] = useState();\n  const [width, setWidth] = useState();\n\n  const resizeCount = useGridResize();\n  const incrementResizeCount = useEmitGridResize();\n\n  // On window resize events, increment the grid resize count.\n  useEffect(() => {\n    function onWindowResize() {\n      incrementResizeCount();\n    }\n    const onResizeDebounced = debounce(onWindowResize, 100, { trailing: true });\n    window.addEventListener('resize', onResizeDebounced);\n    onWindowResize();\n    return () => {\n      window.removeEventListener('resize', onResizeDebounced);\n    };\n  }, [incrementResizeCount]);\n\n  // On new grid resize counts, re-compute the component\n  // width/height.\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const container = containerRef.current;\n    const containerRect = container.getBoundingClientRect();\n    setHeight(containerRect.height);\n    setWidth(containerRect.width);\n  }, [resizeCount]);\n\n  return [width, height, containerRef];\n}\n\n/**\n * Custom hook, subscribes to GRID_RESIZE and window resize events.\n * @returns {array} `[width, height, deckRef]` where width and height\n * are numbers and deckRef is a React ref to be used with\n * a <DeckGL/> element (or a forwardRef to one).\n */\nexport function useDeckCanvasSize() {\n  const deckRef = useRef();\n\n  const [height, setHeight] = useState();\n  const [width, setWidth] = useState();\n\n  const resizeCount = useGridResize();\n  const incrementResizeCount = useEmitGridResize();\n\n  // On window resize events, increment the grid resize count.\n  useEffect(() => {\n    function onWindowResize() {\n      incrementResizeCount();\n    }\n    const onResizeDebounced = debounce(onWindowResize, 100, { trailing: true });\n    window.addEventListener('resize', onResizeDebounced);\n    onWindowResize();\n    return () => {\n      window.removeEventListener('resize', onResizeDebounced);\n    };\n  }, [incrementResizeCount]);\n\n  // On new grid resize counts, re-compute the DeckGL canvas\n  // width/height.\n  useEffect(() => {\n    if (!deckRef.current) return;\n    const { canvas } = deckRef.current.deck;\n    const canvasRect = canvas.getBoundingClientRect();\n    setHeight(canvasRect.height);\n    setWidth(canvasRect.width);\n  }, [resizeCount]);\n\n  return [width, height, deckRef];\n}\n\n/**\n * This hook handles a boolean isReady value,\n * which only returns true once every item in the\n * input list has been marked as \"ready\".\n * @param {string[]} items The items to wait on.\n * Should be defined as a constant\n * (outside a function component / render function),\n * otherwise strange bugs may occur.\n * @returns {array} An array\n * [isReady, setItemIsReady, setItemIsNotReady, resetReadyItems]\n * where isReady is the boolean value,\n * setItemIsReady marks one item as ready,\n * setItemIsNotReady marks one item as not ready,\n * and resetReadyItem marks all items as waiting.\n */\nexport function useReady(supportedItems) {\n  const items = supportedItems;\n  const [waiting, setWaiting] = useState(items);\n\n  const setItemIsReady = useCallback((readyItem) => {\n    setWaiting((waitingItems) => {\n      const nextWaitingItems = waitingItems.filter(item => item !== readyItem);\n      // eslint-disable-next-line no-console\n      console.log(`cleared ${readyItem}; waiting on ${nextWaitingItems.length}: ${JSON.stringify(nextWaitingItems)}`);\n      return nextWaitingItems;\n    });\n  }, [setWaiting]);\n\n  const setItemIsNotReady = useCallback((notReadyItem) => {\n    setWaiting((waitingItems) => {\n      const nextWaitingItems = [...waitingItems, notReadyItem];\n      // eslint-disable-next-line no-console\n      console.log(`waiting on ${nextWaitingItems.length}: ${JSON.stringify(nextWaitingItems)}`);\n      return nextWaitingItems;\n    });\n  }, [setWaiting]);\n\n  const resetReadyItems = useCallback(() => {\n    setWaiting(items);\n    // eslint-disable-next-line no-console\n    console.log(`waiting on ${items.length}: ${JSON.stringify(items)}`);\n  }, [setWaiting, items]);\n\n  const isReady = waiting.length === 0;\n\n  return [isReady, setItemIsReady, setItemIsNotReady, resetReadyItems];\n}\n\n/**\n * This hook manages a list of URLs,\n * with adding and resetting helpers.\n * @returns {array} An array\n * [urls, addUrl, resetUrls]\n * where urls is the array of URL objects,\n * addUrl is a function for adding a URL to the array,\n * resetUrls is a function that clears the array.\n */\nexport function useUrls() {\n  const [urls, setUrls] = useState([]);\n\n  const addUrl = useCallback((url, name) => {\n    if (url) {\n      setUrls(prev => ([...prev, { url, name }]));\n    }\n  }, [setUrls]);\n\n  const resetUrls = useCallback(() => {\n    setUrls([]);\n  }, [setUrls]);\n\n  return [urls, addUrl, resetUrls];\n}\n\n/**\n * Custom hook, subscribes to the width and height of the closest .vitessce-container\n * element and updates upon window resize events.\n * @param {Ref} ref A React ref object within the `.vitessce-container`.\n * @returns {array} `[width, height]` where width and height\n * are numbers.\n */\nexport function useClosestVitessceContainerSize(ref) {\n  const [height, setHeight] = useState();\n  const [width, setWidth] = useState();\n\n  useEffect(() => {\n    function onWindowResize() {\n      if (ref.current) {\n        const {\n          clientHeight: componentHeight, clientWidth: componentWidth,\n        } = ref.current.closest('.vitessce-container');\n        setWidth(componentWidth);\n        setHeight(componentHeight);\n      }\n    }\n    const onResizeDebounced = debounce(onWindowResize, 100, { trailing: true });\n    window.addEventListener('resize', onResizeDebounced);\n    onWindowResize();\n    return () => {\n      window.removeEventListener('resize', onResizeDebounced);\n    };\n  }, [ref]);\n\n  return [width, height];\n}\n\nexport function useExpressionValueGetter({ attrs, expressionData }) {\n  // Get a mapping from cell ID to row index in the gene expression matrix.\n  const cellIdMap = useMemo(() => {\n    const result = {};\n    if (attrs && attrs.rows) {\n      // eslint-disable-next-line no-plusplus\n      for (let i = 0; i < attrs.rows.length; i++) {\n        result[attrs.rows[i]] = i;\n      }\n    }\n    return result;\n  }, [attrs]);\n\n  // Set up a getter function for gene expression values, to be used\n  // by the DeckGL layer to obtain values for instanced attributes.\n  const getExpressionValue = useCallback((entry) => {\n    const cellId = entry[0];\n    if (cellIdMap && expressionData && expressionData[0]) {\n      const cellIndex = cellIdMap[cellId];\n      const val = expressionData[0][cellIndex];\n      return val;\n    }\n    return 0;\n  }, [cellIdMap, expressionData]);\n  return getExpressionValue;\n}\n"]},"metadata":{},"sourceType":"module"}