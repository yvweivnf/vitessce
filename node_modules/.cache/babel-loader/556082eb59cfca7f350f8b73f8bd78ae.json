{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport * as EXT_meshopt_compression from '../extensions/EXT_meshopt_compression';\nimport * as EXT_texture_webp from '../extensions/EXT_texture_webp';\nimport * as KHR_texture_basisu from '../extensions/KHR_texture_basisu';\nimport * as KHR_draco_mesh_compression from '../extensions/KHR_draco_mesh_compression';\nimport * as KHR_lights_punctual from '../extensions/deprecated/KHR_lights_punctual';\nimport * as KHR_materials_unlit from '../extensions/deprecated/KHR_materials_unlit';\nimport * as KHR_techniques_webgl from '../extensions/deprecated/KHR_techniques_webgl';\nexport var EXTENSIONS = [EXT_meshopt_compression, EXT_texture_webp, KHR_texture_basisu, KHR_draco_mesh_compression, KHR_lights_punctual, KHR_materials_unlit, KHR_techniques_webgl];\nexport function preprocessExtensions(gltf) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var context = arguments.length > 2 ? arguments[2] : undefined;\n  var extensions = EXTENSIONS.filter(function (extension) {\n    return useExtension(extension.name, options);\n  });\n\n  var _iterator = _createForOfIteratorHelper(extensions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var extension = _step.value;\n\n      var _extension$preprocess;\n\n      (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport function decodeExtensions(_x) {\n  return _decodeExtensions.apply(this, arguments);\n}\n\nfunction _decodeExtensions() {\n  _decodeExtensions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltf) {\n    var options,\n        context,\n        extensions,\n        _iterator2,\n        _step2,\n        extension,\n        _extension$decode,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            context = _args.length > 2 ? _args[2] : undefined;\n            extensions = EXTENSIONS.filter(function (extension) {\n              return useExtension(extension.name, options);\n            });\n            _iterator2 = _createForOfIteratorHelper(extensions);\n            _context.prev = 4;\n\n            _iterator2.s();\n\n          case 6:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 12;\n              break;\n            }\n\n            extension = _step2.value;\n            _context.next = 10;\n            return (_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context);\n\n          case 10:\n            _context.next = 6;\n            break;\n\n          case 12:\n            _context.next = 17;\n            break;\n\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](4);\n\n            _iterator2.e(_context.t0);\n\n          case 17:\n            _context.prev = 17;\n\n            _iterator2.f();\n\n            return _context.finish(17);\n\n          case 20:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 14, 17, 20]]);\n  }));\n  return _decodeExtensions.apply(this, arguments);\n}\n\nfunction useExtension(extensionName, options) {\n  var _options$gltf;\n\n  var excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};\n  var exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}","map":{"version":3,"sources":["../../../../src/lib/api/gltf-extensions.ts"],"names":["EXTENSIONS","options","extensions","extension","useExtension","excludes","exclude","extensionName"],"mappings":";;;AAQA,OAAO,KAAP,uBAAA,MAAA,uCAAA;AACA,OAAO,KAAP,gBAAA,MAAA,gCAAA;AACA,OAAO,KAAP,kBAAA,MAAA,kCAAA;AACA,OAAO,KAAP,0BAAA,MAAA,0CAAA;AAGA,OAAO,KAAP,mBAAA,MAAA,8CAAA;AACA,OAAO,KAAP,mBAAA,MAAA,8CAAA;AACA,OAAO,KAAP,oBAAA,MAAA,+CAAA;AAgBA,OAAO,IAAMA,UAAiC,GAAG,CAAA,uBAAA,EAAA,gBAAA,EAAA,kBAAA,EAAA,0BAAA,EAAA,mBAAA,EAAA,mBAAA,EAA1C,oBAA0C,CAA1C;AAiBP,OAAO,SAAA,oBAAA,CAAA,IAAA,EAA+E;AAAA,MAA3CC,OAA2C,uEAA/E,EAA+E;AAAA,MAA/E,OAA+E;AACpF,MAAMC,UAAU,GAAGF,UAAU,CAAVA,MAAAA,CAAmBG,UAAAA,SAAD;AAAA,WAAeC,YAAY,CAACD,SAAS,CAAV,IAAA,EAAhE,OAAgE,CAA3B;AAAA,GAAlBH,CAAnB;;AADoF,6CAEpF,UAFoF;AAAA;;AAAA;AAEpF,wDAAoC;AAAA,UAApC,SAAoC;;AAAA,UAAA,qBAAA;;AAClC,OAAA,qBAAA,GAAA,SAAS,CAAT,UAAA,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,qBAAA,CAAA,IAAA,CAAA,SAAA,EAAS,IAAT,EAAS,OAAT,EAAA,OAAA,CAAA;AACD;AAJmF;AAAA;AAAA;AAAA;AAAA;AAKrF;AAGD,gBAAO,gBAAP;AAAA;AAAA;;;+EAAO,iBAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAsCC,YAAAA,OAAtC,2DAAA,EAAA;AAAA,YAAA,OAAA;AACCC,YAAAA,UADD,GACcF,UAAU,CAAVA,MAAAA,CAAmBG,UAAAA,SAAD;AAAA,qBAAeC,YAAY,CAACD,SAAS,CAAV,IAAA,EAAhE,OAAgE,CAA3B;AAAA,aAAlBH,CADd;AAAA,oDAEL,UAFK;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEL,YAAA,SAFK;AAAA;AAAA,mBAKH,CAAA,iBAAA,GAAMG,SAAS,CAAf,MAAA,MAAA,IAAA,IAAA,iBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAMA,iBAAAA,CAAAA,IAAAA,CAAAA,SAAAA,EAAS,IAATA,EAAS,OAATA,EAAN,OAAMA,CALH;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AASP,SAAA,YAAA,CAAA,aAAA,EAAA,OAAA,EAAyE;AAAA,MAAA,aAAA;;AACvE,MAAME,QAAQ,GAAG,CAAA,OAAO,KAAP,IAAA,IAAA,OAAO,KAAA,KAAP,CAAA,GAAA,KAAA,CAAA,GAAA,CAAA,aAAA,GAAA,OAAO,CAAP,IAAA,MAAA,IAAA,IAAA,aAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,aAAA,CAAA,iBAAA,KAAjB,EAAA;AACA,MAAMC,OAAO,GAAGC,aAAa,IAAbA,QAAAA,IAA6B,CAACF,QAAQ,CAAtD,aAAsD,CAAtD;AACA,SAAO,CAAP,OAAA;AACD","sourcesContent":["/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (decode only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 Khronos extensions (decode/encode)\nimport * as EXT_meshopt_compression from '../extensions/EXT_meshopt_compression';\nimport * as EXT_texture_webp from '../extensions/EXT_texture_webp';\nimport * as KHR_texture_basisu from '../extensions/KHR_texture_basisu';\nimport * as KHR_draco_mesh_compression from '../extensions/KHR_draco_mesh_compression';\n\n// Deprecated. These should be handled by rendering library (e.g. luma.gl), not the loader.\nimport * as KHR_lights_punctual from '../extensions/deprecated/KHR_lights_punctual';\nimport * as KHR_materials_unlit from '../extensions/deprecated/KHR_materials_unlit';\nimport * as KHR_techniques_webgl from '../extensions/deprecated/KHR_techniques_webgl';\n\n// Vendor extensions\n\ntype GLTFExtensionPlugin = {\n  name: string;\n  preprocess?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => void;\n  decode?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => Promise<void>;\n  encode?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: GLTFExtensionPlugin[] = [\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  EXT_meshopt_compression,\n  EXT_texture_webp,\n  // Basisu should come after webp, we want basisu to be preferred if both are provided\n  KHR_texture_basisu,\n  KHR_draco_mesh_compression,\n  KHR_lights_punctual,\n  KHR_materials_unlit,\n  KHR_techniques_webgl\n];\n\n/** Call before any resource loading starts */\nexport function preprocessExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    extension.preprocess?.(gltf, options, context);\n  }\n}\n\n/** Call after resource loading */\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    // Note: We decode async extensions sequentially, this might not be necessary\n    // Currently we only have Draco, but when we add Basis we may revisit\n    await extension.decode?.(gltf, options, context);\n  }\n}\n\nfunction useExtension(extensionName: string, options: GLTFLoaderOptions) {\n  const excludes = options?.gltf?.excludeExtensions || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}\n"]},"metadata":{},"sourceType":"module"}