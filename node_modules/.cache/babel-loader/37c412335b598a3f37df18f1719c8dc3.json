{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { WorkerBody } from '@loaders.gl/worker-utils';\nvar requestId = 0;\nexport function createLoaderWorker(loader) {\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, payload) {\n      var input, _payload$options, options, result, message;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = type;\n              _context.next = _context.t0 === 'process' ? 3 : 16;\n              break;\n\n            case 3:\n              _context.prev = 3;\n              input = payload.input, _payload$options = payload.options, options = _payload$options === void 0 ? {} : _payload$options;\n              _context.next = 7;\n              return parseData({\n                loader: loader,\n                arrayBuffer: input,\n                options: options,\n                context: {\n                  parse: parseOnMainThread\n                }\n              });\n\n            case 7:\n              result = _context.sent;\n              WorkerBody.postMessage('done', {\n                result: result\n              });\n              _context.next = 15;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t1 = _context[\"catch\"](3);\n              message = _context.t1 instanceof Error ? _context.t1.message : '';\n              WorkerBody.postMessage('error', {\n                error: message\n              });\n\n            case 15:\n              return _context.abrupt(\"break\", 16);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[3, 11]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction parseOnMainThread(arrayBuffer, options) {\n  return new Promise(function (resolve, reject) {\n    var id = requestId++;\n\n    var onMessage = function onMessage(type, payload) {\n      if (payload.id !== id) {\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n    var payload = {\n      id: id,\n      input: arrayBuffer,\n      options: options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\nfunction parseData(_x3) {\n  return _parseData.apply(this, arguments);\n}\n\nfunction _parseData() {\n  _parseData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var loader, arrayBuffer, options, context, data, parser, textDecoder;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            loader = _ref2.loader, arrayBuffer = _ref2.arrayBuffer, options = _ref2.options, context = _ref2.context;\n\n            if (!(loader.parseSync || loader.parse)) {\n              _context2.next = 6;\n              break;\n            }\n\n            data = arrayBuffer;\n            parser = loader.parseSync || loader.parse;\n            _context2.next = 13;\n            break;\n\n          case 6:\n            if (!loader.parseTextSync) {\n              _context2.next = 12;\n              break;\n            }\n\n            textDecoder = new TextDecoder();\n            data = textDecoder.decode(arrayBuffer);\n            parser = loader.parseTextSync;\n            _context2.next = 13;\n            break;\n\n          case 12:\n            throw new Error(\"Could not load data with \".concat(loader.name, \" loader\"));\n\n          case 13:\n            options = _objectSpread({}, options, {\n              modules: loader && loader.options && loader.options.modules || {},\n              worker: false\n            });\n            _context2.next = 16;\n            return parser(data, _objectSpread({}, options), context, loader);\n\n          case 16:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parseData.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/worker-loader-utils/create-loader-worker.ts"],"names":["requestId","WorkerBody","options","result","parseData","loader","arrayBuffer","context","parse","parseOnMainThread","message","error","id","onMessage","payload","resolve","reject","input","data","parser","textDecoder","modules","worker"],"mappings":"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","sourcesContent":["/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n"]},"metadata":{},"sourceType":"module"}