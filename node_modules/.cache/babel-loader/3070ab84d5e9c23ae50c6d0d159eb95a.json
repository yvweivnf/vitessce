{"ast":null,"code":"import { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\n\nexport function nonPosition(channel, model, opt = {}) {\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const {\n    vgChannel\n  } = opt;\n  let {\n    defaultRef,\n    defaultValue\n  } = opt;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue !== null && defaultValue !== void 0 ? defaultValue : defaultValue = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel,\n      ignoreVgConfig: true\n    });\n\n    if (defaultValue !== undefined) {\n      defaultRef = signalOrValueRef(defaultValue);\n    }\n  }\n\n  const channelDef = encoding[channel];\n  return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, cDef => {\n    return ref.midPoint({\n      channel,\n      channelDef: cDef,\n      markDef,\n      config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null,\n      defaultRef\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/nonposition.ts"],"names":[],"mappings":"AAIA,SAAQ,mBAAR,EAA6B,gBAA7B,QAAoD,cAApD;AAEA,SAAQ,aAAR,QAA4B,eAA5B;AACA,OAAO,KAAK,GAAZ,MAAqB,YAArB;AAEA;;;;AAGA,OAAM,SAAU,WAAV,CACJ,OADI,EAEJ,KAFI,EAGJ,GAAA,GAII,EAPA,EAOE;AAEN,QAAM;AAAC,IAAA,OAAD;AAAU,IAAA,QAAV;AAAoB,IAAA;AAApB,MAA8B,KAApC;AACA,QAAM;AAAC,IAAA;AAAD,MAAc,GAApB;AACA,MAAI;AAAC,IAAA,UAAD;AAAa,IAAA;AAAb,MAA6B,GAAjC;;AAEA,MAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B;AACA,IAAA,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAA,YAAA,GAAA,YAAY,GAAK,mBAAmB,CAAC,OAAD,EAAU,OAAV,EAAmB,MAAnB,EAA2B;AAAC,MAAA,SAAD;AAAY,MAAA,cAAc,EAAE;AAA5B,KAA3B,CAApC;;AAEA,QAAI,YAAY,KAAK,SAArB,EAAgC;AAC9B,MAAA,UAAU,GAAG,gBAAgB,CAAC,YAAD,CAA7B;AACD;AACF;;AAED,QAAM,UAAU,GAAG,QAAQ,CAAC,OAAD,CAA3B;AAEA,SAAO,aAAa,CAAC,KAAD,EAAQ,UAAR,EAAoB,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAA,SAAA,GAAa,OAAjC,EAA0C,IAAI,IAAG;AACnE,WAAO,GAAG,CAAC,QAAJ,CAAa;AAClB,MAAA,OADkB;AAElB,MAAA,UAAU,EAAE,IAFM;AAGlB,MAAA,OAHkB;AAIlB,MAAA,MAJkB;AAKlB,MAAA,SAAS,EAAE,KAAK,CAAC,SAAN,CAAgB,OAAhB,CALO;AAMlB,MAAA,KAAK,EAAE,KAAK,CAAC,iBAAN,CAAwB,OAAxB,CANW;AAOlB,MAAA,KAAK,EAAE,IAPW;AAQlB,MAAA;AARkB,KAAb,CAAP;AAUD,GAXmB,CAApB;AAYD","sourceRoot":"","sourcesContent":["import { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(channel, model, opt = {}) {\n    const { markDef, encoding, config } = model;\n    const { vgChannel } = opt;\n    let { defaultRef, defaultValue } = opt;\n    if (defaultRef === undefined) {\n        // prettier-ignore\n        defaultValue !== null && defaultValue !== void 0 ? defaultValue : (defaultValue = getMarkPropOrConfig(channel, markDef, config, { vgChannel, ignoreVgConfig: true }));\n        if (defaultValue !== undefined) {\n            defaultRef = signalOrValueRef(defaultValue);\n        }\n    }\n    const channelDef = encoding[channel];\n    return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, cDef => {\n        return ref.midPoint({\n            channel,\n            channelDef: cDef,\n            markDef,\n            config,\n            scaleName: model.scaleName(channel),\n            scale: model.getScaleComponent(channel),\n            stack: null,\n            defaultRef\n        });\n    });\n}\n//# sourceMappingURL=nonposition.js.map"]},"metadata":{},"sourceType":"module"}