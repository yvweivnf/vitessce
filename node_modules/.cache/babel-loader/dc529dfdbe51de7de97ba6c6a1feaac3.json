{"ast":null,"code":"import{useEffect}from'react';import{SCHEMA_HANDLERS,LATEST_VERSION}from'./view-config-versions';import{useViewConfigStoreApi,useLoaders,useWarning}from'./state/hooks';function validateViewConfig(viewConfig){// Need the try-catch here since Zustand will actually\n// just catch and ignore errors in its subscription callbacks.\ntry{var validate=SCHEMA_HANDLERS[LATEST_VERSION][0];var valid=validate(viewConfig);if(!valid){var failureReason=JSON.stringify(validate.errors,null,2);throw new Error(\"Config validation failed: \".concat(failureReason));}}catch(e){console.error(e);}// Do nothing if successful.\n}/**\n * This is a dummy component which handles\n * publishing new view configs and loaders to\n * the provided callbacks on changes.\n * @param {object} props\n * @param {function} props.onConfigChange A callback function\n * to execute on each change of the Vitessce view config.\n * @param {function} props.onLoaderChange A callback function\n * to execute on each change of the loaders object.\n * @param {boolean} props.validateOnConfigChange Whether to validate\n * against the view config schema when publishing changes.\n */export default function CallbackPublisher(props){var onWarn=props.onWarn,onConfigChange=props.onConfigChange,onLoaderChange=props.onLoaderChange,validateOnConfigChange=props.validateOnConfigChange;var warning=useWarning();var loaders=useLoaders();var viewConfigStoreApi=useViewConfigStoreApi();// View config updates are often-occurring, so\n// we want to use the \"transient update\" approach\n// to subscribe to view config changes.\n// Reference: https://github.com/react-spring/zustand#transient-updates-for-often-occuring-state-changes\nuseEffect(function(){return viewConfigStoreApi.subscribe(// The function to run on each publish.\nfunction(viewConfig){if(validateOnConfigChange&&viewConfig){validateViewConfig(viewConfig);}if(onConfigChange&&viewConfig){onConfigChange(viewConfig);}},// The function to specify which part of the store\n// we want to subscribe to.\nfunction(state){return state.viewConfig;});},[onConfigChange,validateOnConfigChange,viewConfigStoreApi]);// Emit updates to the warning message.\nuseEffect(function(){if(onWarn&&warning){onWarn(warning);}},[warning,onWarn]);// Emit updates to the loaders.\nuseEffect(function(){if(onLoaderChange&&loaders){onLoaderChange(loaders);}},[loaders,onLoaderChange]);// Render nothing.\nreturn null;}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/app/CallbackPublisher.js"],"names":["useEffect","SCHEMA_HANDLERS","LATEST_VERSION","useViewConfigStoreApi","useLoaders","useWarning","validateViewConfig","viewConfig","validate","valid","failureReason","JSON","stringify","errors","Error","e","console","error","CallbackPublisher","props","onWarn","onConfigChange","onLoaderChange","validateOnConfigChange","warning","loaders","viewConfigStoreApi","subscribe","state"],"mappings":"AAAA,OAASA,SAAT,KAA0B,OAA1B,CACA,OAASC,eAAT,CAA0BC,cAA1B,KAAgD,wBAAhD,CACA,OAASC,qBAAT,CAAgCC,UAAhC,CAA4CC,UAA5C,KAA8D,eAA9D,CAEA,QAASC,CAAAA,kBAAT,CAA4BC,UAA5B,CAAwC,CACtC;AACA;AACA,GAAI,CACF,GAAMC,CAAAA,QAAQ,CAAGP,eAAe,CAACC,cAAD,CAAf,CAAgC,CAAhC,CAAjB,CACA,GAAMO,CAAAA,KAAK,CAAGD,QAAQ,CAACD,UAAD,CAAtB,CACA,GAAI,CAACE,KAAL,CAAY,CACV,GAAMC,CAAAA,aAAa,CAAGC,IAAI,CAACC,SAAL,CAAeJ,QAAQ,CAACK,MAAxB,CAAgC,IAAhC,CAAsC,CAAtC,CAAtB,CACA,KAAM,IAAIC,CAAAA,KAAJ,qCAAuCJ,aAAvC,EAAN,CACD,CACF,CAAC,MAAOK,CAAP,CAAU,CACVC,OAAO,CAACC,KAAR,CAAcF,CAAd,EACD,CACD;AACD,CAED;;;;;;;;;;;GAYA,cAAe,SAASG,CAAAA,iBAAT,CAA2BC,KAA3B,CAAkC,IAE7CC,CAAAA,MAF6C,CAM3CD,KAN2C,CAE7CC,MAF6C,CAG7CC,cAH6C,CAM3CF,KAN2C,CAG7CE,cAH6C,CAI7CC,cAJ6C,CAM3CH,KAN2C,CAI7CG,cAJ6C,CAK7CC,sBAL6C,CAM3CJ,KAN2C,CAK7CI,sBAL6C,CAQ/C,GAAMC,CAAAA,OAAO,CAAGnB,UAAU,EAA1B,CACA,GAAMoB,CAAAA,OAAO,CAAGrB,UAAU,EAA1B,CAEA,GAAMsB,CAAAA,kBAAkB,CAAGvB,qBAAqB,EAAhD,CAEA;AACA;AACA;AACA;AACAH,SAAS,CAAC,iBAAM0B,CAAAA,kBAAkB,CAACC,SAAnB,CACd;AACA,SAACpB,UAAD,CAAgB,CACd,GAAIgB,sBAAsB,EAAIhB,UAA9B,CAA0C,CACxCD,kBAAkB,CAACC,UAAD,CAAlB,CACD,CACD,GAAIc,cAAc,EAAId,UAAtB,CAAkC,CAChCc,cAAc,CAACd,UAAD,CAAd,CACD,CACF,CATa,CAUd;AACA;AACA,SAAAqB,KAAK,QAAIA,CAAAA,KAAK,CAACrB,UAAV,EAZS,CAAN,EAAD,CAaN,CAACc,cAAD,CAAiBE,sBAAjB,CAAyCG,kBAAzC,CAbM,CAAT,CAeA;AACA1B,SAAS,CAAC,UAAM,CACd,GAAIoB,MAAM,EAAII,OAAd,CAAuB,CACrBJ,MAAM,CAACI,OAAD,CAAN,CACD,CACF,CAJQ,CAIN,CAACA,OAAD,CAAUJ,MAAV,CAJM,CAAT,CAMA;AACApB,SAAS,CAAC,UAAM,CACd,GAAIsB,cAAc,EAAIG,OAAtB,CAA+B,CAC7BH,cAAc,CAACG,OAAD,CAAd,CACD,CACF,CAJQ,CAIN,CAACA,OAAD,CAAUH,cAAV,CAJM,CAAT,CAMA;AACA,MAAO,KAAP,CACD","sourcesContent":["import { useEffect } from 'react';\nimport { SCHEMA_HANDLERS, LATEST_VERSION } from './view-config-versions';\nimport { useViewConfigStoreApi, useLoaders, useWarning } from './state/hooks';\n\nfunction validateViewConfig(viewConfig) {\n  // Need the try-catch here since Zustand will actually\n  // just catch and ignore errors in its subscription callbacks.\n  try {\n    const validate = SCHEMA_HANDLERS[LATEST_VERSION][0];\n    const valid = validate(viewConfig);\n    if (!valid) {\n      const failureReason = JSON.stringify(validate.errors, null, 2);\n      throw new Error(`Config validation failed: ${failureReason}`);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  // Do nothing if successful.\n}\n\n/**\n * This is a dummy component which handles\n * publishing new view configs and loaders to\n * the provided callbacks on changes.\n * @param {object} props\n * @param {function} props.onConfigChange A callback function\n * to execute on each change of the Vitessce view config.\n * @param {function} props.onLoaderChange A callback function\n * to execute on each change of the loaders object.\n * @param {boolean} props.validateOnConfigChange Whether to validate\n * against the view config schema when publishing changes.\n */\nexport default function CallbackPublisher(props) {\n  const {\n    onWarn,\n    onConfigChange,\n    onLoaderChange,\n    validateOnConfigChange,\n  } = props;\n\n  const warning = useWarning();\n  const loaders = useLoaders();\n\n  const viewConfigStoreApi = useViewConfigStoreApi();\n\n  // View config updates are often-occurring, so\n  // we want to use the \"transient update\" approach\n  // to subscribe to view config changes.\n  // Reference: https://github.com/react-spring/zustand#transient-updates-for-often-occuring-state-changes\n  useEffect(() => viewConfigStoreApi.subscribe(\n    // The function to run on each publish.\n    (viewConfig) => {\n      if (validateOnConfigChange && viewConfig) {\n        validateViewConfig(viewConfig);\n      }\n      if (onConfigChange && viewConfig) {\n        onConfigChange(viewConfig);\n      }\n    },\n    // The function to specify which part of the store\n    // we want to subscribe to.\n    state => state.viewConfig,\n  ), [onConfigChange, validateOnConfigChange, viewConfigStoreApi]);\n\n  // Emit updates to the warning message.\n  useEffect(() => {\n    if (onWarn && warning) {\n      onWarn(warning);\n    }\n  }, [warning, onWarn]);\n\n  // Emit updates to the loaders.\n  useEffect(() => {\n    if (onLoaderChange && loaders) {\n      onLoaderChange(loaders);\n    }\n  }, [loaders, onLoaderChange]);\n\n  // Render nothing.\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}