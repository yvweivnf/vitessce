{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { field, isDate, toNumber, isArray, inrange, extend, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\n\nfunction ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nfunction bisector(f) {\n  var delta = f;\n  var compare = f;\n\n  if (f.length === 1) {\n    delta = function delta(d, x) {\n      return f(d) - x;\n    };\n\n    compare = ascendingComparator(f);\n  }\n\n  function left(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;\n    }\n\n    return lo;\n  }\n\n  function right(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;\n    }\n\n    return lo;\n  }\n\n  function center(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    var i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {\n    left: left,\n    center: center,\n    right: right\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function (d, x) {\n    return ascending(f(d), x);\n  };\n}\n\nvar Intersect = 'intersect';\nvar Union = 'union';\nvar VlMulti = 'vlMulti';\nvar VlPoint = 'vlPoint';\nvar Or = 'or';\nvar And = 'and';\nvar SELECTION_ID = '_vgsid_',\n    TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0,\n      dval,\n      f;\n\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry,\n      miss,\n      count,\n      unit,\n      b;\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n\n  return n && intersect;\n}\n\nvar selectionId = field(SELECTION_ID),\n    bisect = bisector(selectionId),\n    bisectLeft = bisect.left,\n    bisectRight = bisect.right;\n\nfunction selectionIdTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      value = selectionId(datum),\n      index = bisectLeft(entries, value);\n  if (index === entries.length) return false;\n  if (selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} unit  - The name of the unit view.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\n\n\nfunction selectionTuples(array, base) {\n  return array.map(function (x) {\n    return extend({\n      values: base.fields.map(function (f) {\n        return (f.getter || (f.getter = field(f.field)))(x.datum);\n      })\n    }, base);\n  });\n}\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\n\n\nfunction selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    } // If the same multi-selection is repeated over views and projected over\n    // an encoding, it may operate over different fields making it especially\n    // tricky to reliably resolve it. At best, we can de-dupe identical entries\n    // but doing so may be more computationally expensive than it is worth.\n    // Instead, for now, we simply transform our store representation into\n    // a more human-friendly one.\n\n\n    if (isMulti) {\n      resUnit = multiRes[unit] || (multiRes[unit] = []);\n      resUnit.push(array(values).reduce(function (obj, curr, j) {\n        return obj[fields[j].field] = curr, obj;\n      }, {}));\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n  Object.keys(resolved).forEach(function (field) {\n    resolved[field] = Object.keys(resolved[field]).map(function (unit) {\n      return resolved[field][unit];\n    }).reduce(function (acc, curr) {\n      return acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr);\n    });\n  });\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    var key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union ? _defineProperty({}, Or, entries.reduce(function (acc, k) {\n      return acc.push.apply(acc, _toConsumableArray(multiRes[k])), acc;\n    }, [])) : _defineProperty({}, And, entries.map(function (k) {\n      return _defineProperty({}, Or, multiRes[k]);\n    }));\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  E_union: function E_union(base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) {\n      if (base.indexOf(value[i]) < 0) base.push(value[i]);\n    }\n\n    return base;\n  },\n  E_intersect: function E_intersect(base, value) {\n    return !base.length ? value : base.filter(function (v) {\n      return value.indexOf(v) >= 0;\n    });\n  },\n  R_union: function R_union(base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function R_intersect(base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};\nvar DataPrefix = ':',\n    IndexPrefix = '@';\n\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  var data = args[0].value,\n      op = args.length >= 2 && peek(args).value,\n      field = 'unit',\n      indexName = IndexPrefix + field,\n      dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport { selectionIdTest, selectionResolve, selectionTest, selectionTuples, selectionVisitor };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-selections/build/vega-selection.module.js"],"names":["field","isDate","toNumber","isArray","inrange","extend","array","error","peek","hasOwnProperty","Literal","ascending","a","b","NaN","bisector","f","delta","compare","length","d","x","ascendingComparator","left","lo","hi","mid","right","center","i","Intersect","Union","VlMulti","VlPoint","Or","And","SELECTION_ID","TYPE_ENUM","TYPE_RANGE_INC","TYPE_RANGE_EXC","TYPE_RANGE_LE","TYPE_RANGE_RE","UNIT_INDEX","testPoint","datum","entry","fields","values","n","dval","getter","map","type","indexOf","selectionTest","name","op","data","context","entries","value","unitIdx","undefined","intersect","miss","count","unit","size","get","selectionId","bisect","bisectLeft","bisectRight","selectionIdTest","index","selectionTuples","base","selectionResolve","isMulti","vl5","resolved","multiRes","types","res","resUnit","union","j","m","charAt","ops","push","reduce","obj","curr","Object","keys","forEach","acc","key","k","E_union","E_intersect","filter","v","R_union","R_intersect","DataPrefix","IndexPrefix","selectionVisitor","args","scope","params","indexName","dataName","getData","indataRef","tuplesRef"],"mappings":"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","sourcesContent":["import { field, isDate, toNumber, isArray, inrange, extend, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\n\nfunction ascending (a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nfunction bisector (f) {\n  let delta = f;\n  let compare = f;\n\n  if (f.length === 1) {\n    delta = (d, x) => f(d) - x;\n\n    compare = ascendingComparator(f);\n  }\n\n  function left(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n\n    while (lo < hi) {\n      const mid = lo + hi >>> 1;\n      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;\n    }\n\n    return lo;\n  }\n\n  function right(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n\n    while (lo < hi) {\n      const mid = lo + hi >>> 1;\n      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;\n    }\n\n    return lo;\n  }\n\n  function center(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {\n    left,\n    center,\n    right\n  };\n}\n\nfunction ascendingComparator(f) {\n  return (d, x) => ascending(f(d), x);\n}\n\nconst Intersect = 'intersect';\nconst Union = 'union';\nconst VlMulti = 'vlMulti';\nconst VlPoint = 'vlPoint';\nconst Or = 'or';\nconst And = 'and';\n\nconst SELECTION_ID = '_vgsid_',\n      TYPE_ENUM = 'E',\n      TYPE_RANGE_INC = 'R',\n      TYPE_RANGE_EXC = 'R-E',\n      TYPE_RANGE_LE = 'R-LE',\n      TYPE_RANGE_RE = 'R-RE',\n      UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0,\n      dval,\n      f;\n\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry,\n      miss,\n      count,\n      unit,\n      b;\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n\n  return n && intersect;\n}\nconst selectionId = field(SELECTION_ID),\n      bisect = bisector(selectionId),\n      bisectLeft = bisect.left,\n      bisectRight = bisect.right;\nfunction selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n        entries = data ? data.values.value : [],\n        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n        intersect = op === Intersect,\n        value = selectionId(datum),\n        index = bisectLeft(entries, value);\n  if (index === entries.length) return false;\n  if (selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} unit  - The name of the unit view.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\n\nfunction selectionTuples(array, base) {\n  return array.map(x => extend({\n    values: base.fields.map(f => (f.getter || (f.getter = field(f.field)))(x.datum))\n  }, base));\n}\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\n\nfunction selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    } // If the same multi-selection is repeated over views and projected over\n    // an encoding, it may operate over different fields making it especially\n    // tricky to reliably resolve it. At best, we can de-dupe identical entries\n    // but doing so may be more computationally expensive than it is worth.\n    // Instead, for now, we simply transform our store representation into\n    // a more human-friendly one.\n\n\n    if (isMulti) {\n      resUnit = multiRes[unit] || (multiRes[unit] = []);\n      resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n  Object.keys(resolved).forEach(field => {\n    resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));\n  });\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union ? {\n      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])\n    } : {\n      [And]: entries.map(k => ({\n        [Or]: multiRes[k]\n      }))\n    };\n  }\n\n  return resolved;\n}\nvar ops = {\n  E_union: function (base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n\n    return base;\n  },\n  E_intersect: function (base, value) {\n    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);\n  },\n  R_union: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport { selectionIdTest, selectionResolve, selectionTest, selectionTuples, selectionVisitor };\n"]},"metadata":{},"sourceType":"module"}