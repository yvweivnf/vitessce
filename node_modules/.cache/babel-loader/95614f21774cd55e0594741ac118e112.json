{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n/**\n * Parse a serialized dataflow specification.\n */\n\nfunction parse(spec) {\n  var ctx = this,\n      operators = spec.operators || []; // parse background\n\n  if (spec.background) {\n    ctx.background = spec.background;\n  } // parse event configuration\n\n\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  } // parse locale configuration\n\n\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  } // parse operators\n\n\n  operators.forEach(function (entry) {\n    return ctx.parseOperator(entry);\n  }); // parse operator parameters\n\n  operators.forEach(function (entry) {\n    return ctx.parseOperatorParameters(entry);\n  }); // parse streams\n\n  (spec.streams || []).forEach(function (entry) {\n    return ctx.parseStream(entry);\n  }); // parse updates\n\n  (spec.updates || []).forEach(function (entry) {\n    return ctx.parseUpdate(entry);\n  });\n  return ctx.resolve();\n}\n\nvar Skip = toSet(['rule']),\n    Swap = toSet(['group', 'image', 'rect']);\n\nfunction adjustSpatial(encode, marktype) {\n  var code = '';\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\n\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\n\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\n\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length - 1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n\n  var fn = Function.apply(void 0, _toConsumableArray(args.concat(code)));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n} // generate code for comparing a single field\n\n\nfunction _compare(u, v, lt, gt) {\n  return \"((u = \".concat(u, \") < (v = \").concat(v, \") || u == null) && v != null ? \").concat(lt, \"\\n  : (u > v || v == null) && u != null ? \").concat(gt, \"\\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? \").concat(lt, \"\\n  : v !== v && u === u ? \").concat(gt, \" : \");\n}\n\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: function operator(ctx, expr) {\n    return expression(ctx, ['_'], expr.code);\n  },\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: function parameter(ctx, expr) {\n    return expression(ctx, ['datum', '_'], expr.code);\n  },\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: function event(ctx, expr) {\n    return expression(ctx, ['event'], expr.code);\n  },\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: function handler(ctx, expr) {\n    var code = \"var datum=event.item&&event.item.datum;return \".concat(expr.code, \";\");\n    return expression(ctx, ['_', 'event'], code);\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: function encode(ctx, _encode) {\n    var marktype = _encode.marktype,\n        channels = _encode.channels;\n    var code = 'var o=item,datum=o.datum,m=0,$;';\n\n    for (var name in channels) {\n      var o = 'o[' + stringValue(name) + ']';\n      code += \"$=\".concat(channels[name].code, \";if(\").concat(o, \"!==$)\").concat(o, \"=$,m=1;\");\n    }\n\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get: function get(path) {\n      var ref = \"[\".concat(path.map(stringValue).join(']['), \"]\");\n      var get = Function('_', \"return _\".concat(ref, \";\"));\n      get.path = ref;\n      return get;\n    },\n    comparator: function comparator(fields, orders) {\n      var t;\n\n      var map = function map(f, i) {\n        var o = orders[i];\n        var u, v;\n\n        if (f.path) {\n          u = \"a\".concat(f.path);\n          v = \"b\".concat(f.path);\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = \"this.f\".concat(i, \"(a)\");\n          v = \"this.f\".concat(i, \"(b)\");\n        }\n\n        return _compare(u, v, -o, o);\n      };\n\n      var fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n  }\n};\n/**\n * Parse a dataflow operator.\n */\n\nfunction parseOperator(spec) {\n  var ctx = this;\n\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n/**\n * Parse and assign operator parameters.\n */\n\n\nfunction parseOperatorParameters(spec) {\n  var ctx = this;\n\n  if (spec.params) {\n    var op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n/**\n * Parse a set of operator parameters.\n */\n\n\nfunction parseParameters(spec, params) {\n  params = params || {};\n  var ctx = this;\n\n  for (var _key in spec) {\n    var value = spec[_key];\n    params[_key] = isArray(value) ? value.map(function (v) {\n      return parseParameter(v, ctx, params);\n    }) : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n/**\n * Parse a single parameter.\n */\n\n\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (var i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n/** Reference parsers. */\n\n\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n/**\n * Resolve an operator reference.\n */\n\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n/**\n * Resolve an expression reference.\n */\n\n\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n\n  var k = 'e:' + _.$expr.code + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));\n}\n/**\n * Resolve a key accessor reference.\n */\n\n\nfunction getKey(_, ctx) {\n  var k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n/**\n * Resolve a field accessor reference.\n */\n\n\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  var k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n/**\n * Resolve a comparator function reference.\n */\n\n\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  var k = 'c:' + _.$compare + '_' + _.$order,\n      c = array(_.$compare).map(function (_) {\n    return _ && _.$tupleid ? tupleid : _;\n  });\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n/**\n * Resolve an encode operator reference.\n */\n\n\nfunction getEncode(_, ctx) {\n  var spec = _.$encode,\n      encode = {};\n\n  for (var name in spec) {\n    var enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n\n  return encode;\n}\n/**\n * Resolve a context reference.\n */\n\n\nfunction getContext(_, ctx) {\n  return ctx;\n}\n/**\n * Resolve a recursive subflow specification.\n */\n\n\nfunction getSubflow(_, ctx) {\n  var spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    var subctx = ctx.fork().parse(spec),\n        op = subctx.get(spec.operators[0].id),\n        p = subctx.signals.parent;\n    if (p) p.set(parent);\n\n    op.detachSubflow = function () {\n      return ctx.detach(subctx);\n    };\n\n    return op;\n  };\n}\n/**\n * Resolve a tuple id reference.\n */\n\n\nfunction getTupleId() {\n  return tupleid;\n}\n/**\n * Parse an event stream specification.\n */\n\n\nfunction parseStream(spec) {\n  var ctx = this,\n      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(function (_) {\n      return ctx.get(_);\n    });\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(function (_) {\n      return ctx.get(_);\n    });\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n/**\n * Parse an event-driven operator update.\n */\n\n\nfunction parseUpdate(spec) {\n  var ctx = this,\n      srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n\n    update = ctx.handlerExpression(update.$expr);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n\nvar SKIP = {\n  skip: true\n};\n\nfunction getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(function (key) {\n      var op = ctx.signals[key];\n\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(function (key) {\n      var dataset = ctx.data[key];\n\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(function (ctx) {\n      return ctx.getState(options);\n    });\n  }\n\n  return state;\n}\n\nfunction setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n  Object.keys(signals || {}).forEach(function (key) {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(function (key) {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach(function (substate, i) {\n    var subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\n\nfunction context(df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\n\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = Subcontext.prototype = {\n  fork: function fork() {\n    var ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  detach: function detach(ctx) {\n    this.subcontext = this.subcontext.filter(function (c) {\n      return c !== ctx;\n    }); // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n\n    var keys = Object.keys(ctx.nodes);\n\n    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n      var _key2 = _keys[_i];\n      ctx.nodes[_key2]._targets = null;\n    }\n\n    for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {\n      var _key3 = _keys2[_i2];\n\n      ctx.nodes[_key3].detach();\n    }\n\n    ctx.nodes = null;\n  },\n  get: function get(id) {\n    return this.nodes[id];\n  },\n  set: function set(id, node) {\n    return this.nodes[id] = node;\n  },\n  add: function add(spec, op) {\n    var ctx = this,\n        df = ctx.dataflow,\n        data = spec.value;\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      var p = ctx.get(spec.parent.$ref);\n\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(function () {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      var _loop = function _loop(name) {\n        var data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(function (role) {\n          return data[role] = op;\n        });\n      };\n\n      for (var name in spec.data) {\n        _loop(name);\n      }\n    }\n  },\n  resolve: function resolve() {\n    (this.unresolved || []).forEach(function (fn) {\n      return fn();\n    });\n    delete this.unresolved;\n    return this;\n  },\n  operator: function operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform: function transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream: function stream(spec, _stream) {\n    this.set(spec.id, _stream);\n  },\n  update: function update(spec, stream, target, _update, params) {\n    this.dataflow.on(stream, target, _update, params, spec.options);\n  },\n  // expression parsing\n  operatorExpression: function operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n  parameterExpression: function parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n  eventExpression: function eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n  handlerExpression: function handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n  encodeExpression: function encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n  // parse methods\n  parse: parse,\n  parseOperator: parseOperator,\n  parseOperatorParameters: parseOperatorParameters,\n  parseParameters: parseParameters,\n  parseStream: parseStream,\n  parseUpdate: parseUpdate,\n  // state methods\n  getState: getState,\n  setState: setState\n};\nexport { context };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-runtime/build/vega-runtime.module.js"],"names":["toSet","stringValue","error","isArray","isObject","hasOwnProperty","accessor","key","field","array","compare","truthy","tupleid","parse","spec","ctx","operators","background","eventConfig","locale","forEach","entry","parseOperator","parseOperatorParameters","streams","parseStream","updates","parseUpdate","resolve","Skip","Swap","adjustSpatial","encode","marktype","code","x2","x","xc","y2","y","yc","canonicalType","type","toLowerCase","isOperator","isCollect","expression","args","length","fn","Function","concat","functions","bind","_compare","u","v","lt","gt","expressionCodegen","operator","expr","parameter","event","handler","channels","name","o","codegen","get","path","ref","map","join","comparator","fields","orders","t","f","i","update","operatorExpression","transform","params","op","id","dataflow","connect","parameters","parseParameters","react","initonly","value","parseParameter","n","PARSERS","p","getOperator","getKey","getExpression","getField","getEncode","getCompare","getContext","getSubflow","getTupleId","_","$ref","$params","k","$expr","$name","parameterExpression","$fields","$key","$flat","$field","$compare","$order","c","$tupleid","$encode","enc","encodeExpression","output","$output","$subflow","parent","subctx","fork","signals","set","detachSubflow","detach","filter","eventExpression","undefined","stream","source","events","merge","apply","slice","between","throttle","debounce","JSON","stringify","consume","srcid","target","handlerExpression","SKIP","skip","getState","options","state","Object","keys","data","dataset","input","subcontext","recurse","setState","df","pulse","changeset","remove","insert","substate","context","transforms","Context","scales","nodes","create","Subcontext","prototype","push","_targets","node","add","$ingest","ingest","$format","$request","preload","root","targets","unresolved","signal","scale","role","on"],"mappings":"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","sourcesContent":["import { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n\n/**\n * Parse a serialized dataflow specification.\n */\nfunction parse (spec) {\n  const ctx = this,\n        operators = spec.operators || []; // parse background\n\n  if (spec.background) {\n    ctx.background = spec.background;\n  } // parse event configuration\n\n\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  } // parse locale configuration\n\n\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  } // parse operators\n\n\n  operators.forEach(entry => ctx.parseOperator(entry)); // parse operator parameters\n\n  operators.forEach(entry => ctx.parseOperatorParameters(entry)); // parse streams\n\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry)); // parse updates\n\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n  return ctx.resolve();\n}\n\nconst Skip = toSet(['rule']),\n      Swap = toSet(['group', 'image', 'rect']);\nfunction adjustSpatial(encode, marktype) {\n  let code = '';\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length - 1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n} // generate code for comparing a single field\n\n\nfunction _compare(u, v, lt, gt) {\n  return \"((u = \".concat(u, \") < (v = \").concat(v, \") || u == null) && v != null ? \").concat(lt, \"\\n  : (u > v || v == null) && u != null ? \").concat(gt, \"\\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? \").concat(lt, \"\\n  : v !== v && u === u ? \").concat(gt, \" : \");\n}\n\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = \"var datum=event.item&&event.item.datum;return \".concat(expr.code, \";\");\n    return expression(ctx, ['_', 'event'], code);\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {\n      marktype,\n      channels\n    } = encode;\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n\n    for (const name in channels) {\n      const o = 'o[' + stringValue(name) + ']';\n      code += \"$=\".concat(channels[name].code, \";if(\").concat(o, \"!==$)\").concat(o, \"=$,m=1;\");\n    }\n\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = \"[\".concat(path.map(stringValue).join(']['), \"]\");\n      const get = Function('_', \"return _\".concat(ref, \";\"));\n      get.path = ref;\n      return get;\n    },\n\n    comparator(fields, orders) {\n      let t;\n\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n\n        if (f.path) {\n          u = \"a\".concat(f.path);\n          v = \"b\".concat(f.path);\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = \"this.f\".concat(i, \"(a)\");\n          v = \"this.f\".concat(i, \"(b)\");\n        }\n\n        return _compare(u, v, -o, o);\n      };\n\n      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n\n  }\n};\n\n/**\n * Parse a dataflow operator.\n */\n\nfunction parseOperator(spec) {\n  const ctx = this;\n\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n/**\n * Parse and assign operator parameters.\n */\n\nfunction parseOperatorParameters(spec) {\n  const ctx = this;\n\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n\n/**\n * Parse a set of operator parameters.\n */\n\nfunction parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n/**\n * Parse a single parameter.\n */\n\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n/** Reference parsers. */\n\n\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n/**\n * Resolve an operator reference.\n */\n\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n/**\n * Resolve an expression reference.\n */\n\n\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n\n  const k = 'e:' + _.$expr.code + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));\n}\n/**\n * Resolve a key accessor reference.\n */\n\n\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n/**\n * Resolve a field accessor reference.\n */\n\n\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n/**\n * Resolve a comparator function reference.\n */\n\n\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n        c = array(_.$compare).map(_ => _ && _.$tupleid ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n/**\n * Resolve an encode operator reference.\n */\n\n\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n        encode = {};\n\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n\n  return encode;\n}\n/**\n * Resolve a context reference.\n */\n\n\nfunction getContext(_, ctx) {\n  return ctx;\n}\n/**\n * Resolve a recursive subflow specification.\n */\n\n\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n          op = subctx.get(spec.operators[0].id),\n          p = subctx.signals.parent;\n    if (p) p.set(parent);\n\n    op.detachSubflow = () => ctx.detach(subctx);\n\n    return op;\n  };\n}\n/**\n * Resolve a tuple id reference.\n */\n\n\nfunction getTupleId() {\n  return tupleid;\n}\n\n/**\n * Parse an event stream specification.\n */\n\nfunction parseStream (spec) {\n  var ctx = this,\n      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n\n/**\n * Parse an event-driven operator update.\n */\n\nfunction parseUpdate (spec) {\n  var ctx = this,\n      srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n\n    update = ctx.handlerExpression(update.$expr);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n\nconst SKIP = {\n  skip: true\n};\nfunction getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n\n  return state;\n}\nfunction setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\nfunction context (df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\n\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx); // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n\n    const keys = Object.keys(ctx.nodes);\n\n    for (const key of keys) ctx.nodes[key]._targets = null;\n\n    for (const key of keys) ctx.nodes[key].detach();\n\n    ctx.nodes = null;\n  },\n\n  get(id) {\n    return this.nodes[id];\n  },\n\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n\n  add(spec, op) {\n    const ctx = this,\n          df = ctx.dataflow,\n          data = spec.value;\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n  // state methods\n  getState,\n  setState\n};\n\nexport { context };\n"]},"metadata":{},"sourceType":"module"}