{"ast":null,"code":"import AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\nexport default class GridAggregationLayer extends AggregationLayer {\n  initializeState(_ref) {\n    let {\n      dimensions\n    } = _ref;\n    const {\n      gl\n    } = this.context;\n    super.initializeState(dimensions);\n    this.setState({\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {\n        id: \"\".concat(this.id, \"-gpu-aggregator\")\n      }),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    this.updateAggregationState(opts);\n    const {\n      aggregationDataDirty,\n      aggregationWeightsDirty,\n      gpuAggregation\n    } = this.state;\n\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n\n    let aggregationDirty = false;\n\n    if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n      this._updateAggregation(opts);\n\n      aggregationDirty = true;\n    }\n\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n\n      this._uploadAggregationResults();\n\n      aggregationDirty = true;\n    }\n\n    this.setState({\n      aggregationDirty\n    });\n  }\n\n  finalizeState() {\n    var _this$state$gpuGridAg;\n\n    const {\n      count\n    } = this.state.weights;\n\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n\n    (_this$state$gpuGridAg = this.state.gpuGridAggregator) === null || _this$state$gpuGridAg === void 0 ? void 0 : _this$state$gpuGridAg.delete();\n    super.finalizeState();\n  }\n\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  updateAggregationState(opts) {\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {\n        weights\n      } = this.state;\n\n      for (const name in weights) {\n        const weight = weights[name];\n\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: 5126,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults(_ref2) {\n    let {\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    } = _ref2;\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      props\n    } = opts;\n    const {\n      viewport\n    } = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {\n        weights\n      } = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {\n      getValue\n    } = this.state;\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue\n    });\n    this.setState({\n      sortedBins\n    });\n  }\n\n  _uploadAggregationResults() {\n    const {\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      data\n    } = this.state.layerData;\n    const {\n      aggregatedBins,\n      minValue,\n      maxValue,\n      totalCount\n    } = this.state.sortedBins;\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n\n    for (const bin of aggregatedBins) {\n      const {\n        lonIdx,\n        latIdx\n      } = data[bin.i];\n      const {\n        value,\n        counts\n      } = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    });\n  }\n\n}\nGridAggregationLayer.layerName = 'GridAggregationLayer';","map":{"version":3,"sources":["../../src/grid-aggregation-layer.js"],"names":["initializeState","dimensions","gl","layerData","gpuGridAggregator","id","cpuGridAggregator","pointToDensityGridDataCPU","updateState","gpuAggregation","aggregationDirty","aggregationDataDirty","finalizeState","count","updateShaders","updateAggregationState","log","allocateResources","dataBytes","numCol","weights","weight","byteLength","accessor","size","type","divisor","updateResults","minData","_updateAggregation","translation","scaling","numRow","props","viewport","attributes","vertexCount","result","boundingBox","cellSize","gridOffset","moduleSettings","_updateWeightBins","getValue","sortedBins","_uploadAggregationResults","data","totalCount","ELEMENTCOUNT","aggregationSize","aggregationData","latIdx","bin","counts","cellIndex","lonIdx","maxMinData","maxData","GridAggregationLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport default class GridAggregationLayer extends AggregationLayer {\n  initializeState({dimensions}) {\n    const {gl} = this.context;\n    super.initializeState(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState() {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState();\n  }\n\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults() {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n\nGridAggregationLayer.layerName = 'GridAggregationLayer';\n"]},"metadata":{},"sourceType":"module"}