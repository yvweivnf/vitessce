{"ast":null,"code":"import { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nconst ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n  const {\n    fill = undefined,\n    stroke = undefined\n  } = ignore.color === 'include' ? color(model) : {};\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), nonPosition('strokeDash', model)), zindex(model)), tooltip(model)), text(model, 'href')), aria(model));\n} // TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\n\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  const {\n    config,\n    mark,\n    markDef\n  } = model;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n\n    if (test) {\n      return {\n        [channel]: [// prepend the invalid case\n        // TODO: support custom value\n        {\n          test,\n          value: null\n        }, ...array(valueRef)]\n      };\n    }\n  }\n\n  return valueRef ? {\n    [channel]: valueRef\n  } : {};\n}\n\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = signalOrValueRef(mark[prop]);\n    }\n\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(model, {\n  invalid = false,\n  channels\n}) {\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nconst ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n    const { fill = undefined, stroke = undefined } = ignore.color === 'include' ? color(model) : {};\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), nonPosition('strokeDash', model)), zindex(model)), tooltip(model)), text(model, 'href')), aria(model));\n}\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n    const { config, mark, markDef } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n        // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n        // For path marks, we will use \"defined\" property and skip these values instead.\n        const test = allFieldsInvalidPredicate(model, { invalid: true, channels: SCALE_CHANNELS });\n        if (test) {\n            return {\n                [channel]: [\n                    // prepend the invalid case\n                    // TODO: support custom value\n                    { test, value: null },\n                    ...array(valueRef)\n                ]\n            };\n        }\n    }\n    return valueRef ? { [channel]: valueRef } : {};\n}\nfunction markDefProperties(mark, ignore) {\n    return VG_MARK_CONFIGS.reduce((m, prop) => {\n        if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n            m[prop] = signalOrValueRef(mark[prop]);\n        }\n        return m;\n    }, {});\n}\nfunction allFieldsInvalidPredicate(model, { invalid = false, channels }) {\n    const filterIndex = channels.reduce((aggregator, channel) => {\n        const scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n            const scaleType = scaleComponent.get('type');\n            const field = model.vgField(channel, { expr: 'datum' });\n            // While discrete domain scales can handle invalid values, continuous scales can't.\n            if (field && hasContinuousDomain(scaleType)) {\n                aggregator[field] = true;\n            }\n        }\n        return aggregator;\n    }, {});\n    const fields = keys(filterIndex);\n    if (fields.length > 0) {\n        const op = invalid ? '||' : '&&';\n        return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n    }\n    return undefined;\n}\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}