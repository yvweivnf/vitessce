{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { isBinned, isBinning } from '../../bin';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isNumericDataDef } from '../../channeldef';\nimport { isAggregate } from '../../encoding';\nimport { replaceExprRef } from '../../expr';\nimport * as log from '../../log';\nimport { AREA, BAR, BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX, CIRCLE, IMAGE, LINE, POINT, RECT, RULE, SQUARE, TEXT, TICK } from '../../mark';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { getMarkConfig, getMarkPropOrConfig } from '../common';\nexport function initMarkdef(originalMarkDef, encoding, config) {\n  // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n  var markDef = replaceExprRef(originalMarkDef); // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n\n  var specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n\n  if (markDef.type === 'bar' && markDef.orient) {\n    var cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n\n    if (cornerRadiusEnd !== undefined) {\n      var newProps = markDef.orient === 'horizontal' && encoding.x2 || markDef.orient === 'vertical' && encoding.y2 ? ['cornerRadius'] : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n\n      var _iterator = _createForOfIteratorHelper(newProps),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var newProp = _step.value;\n          markDef[newProp] = cornerRadiusEnd;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (markDef.cornerRadiusEnd !== undefined) {\n        delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n      }\n    }\n  } // set opacity and filled if not specified in mark config\n\n\n  var specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  } // set cursor, which should be pointer if href channel is present unless otherwise specified\n\n\n  var specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef, encoding, config) {\n  if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n\n  return markDef.cursor;\n}\n\nfunction opacity(mark, encoding) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n\n  return undefined;\n}\n\nexport function defaultFilled(markDef, config, _ref) {\n  var graticule = _ref.graticule;\n\n  if (graticule) {\n    return false;\n  }\n\n  var filledConfig = getMarkConfig('filled', markDef, config);\n  var mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark, encoding, specifiedOrient) {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  var x = encoding.x,\n      y = encoding.y,\n      x2 = encoding.x2,\n      y2 = encoding.y2;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || isFieldDef(y) && y.aggregate && !x.aggregate)) {\n        return 'vertical';\n      }\n\n      if (isFieldDef(y) && (isBinned(y.bin) || isFieldDef(x) && x.aggregate && !y.aggregate)) {\n        return 'horizontal';\n      }\n\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        } // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n\n\n        if (!x2) {\n          if (isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin) || isNumericDataDef(x)) {\n            return 'horizontal';\n          }\n        } // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n\n\n        if (!y2) {\n          if (isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin) || isNumericDataDef(y)) {\n            return 'vertical';\n          }\n        }\n      }\n\n    // falls through\n\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      // we have to ignore the case that the data are already binned\n      if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n        return undefined;\n      }\n\n    // falls through\n\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n\n    // falls through\n\n    case LINE:\n    case TICK:\n      {\n        // Tick is opposite to bar, line, area and never have ranged mark.\n        var xIsContinuous = isContinuousFieldOrDatumDef(x);\n        var yIsContinuous = isContinuousFieldOrDatumDef(y);\n\n        if (specifiedOrient) {\n          return specifiedOrient;\n        } else if (xIsContinuous && !yIsContinuous) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        } else if (!xIsContinuous && yIsContinuous) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xIsContinuous && yIsContinuous) {\n          var xDef = x; // we can cast here since they are surely fieldDef\n\n          var yDef = y;\n          var xIsTemporal = xDef.type === TEMPORAL;\n          var yIsTemporal = yDef.type === TEMPORAL; // temporal without timeUnit is considered continuous, but better serves as dimension\n\n          if (xIsTemporal && !yIsTemporal) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (!xIsTemporal && yIsTemporal) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n\n          if (!xDef.aggregate && yDef.aggregate) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (xDef.aggregate && !yDef.aggregate) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n\n          return 'vertical';\n        } else {\n          return undefined;\n        }\n      }\n  }\n\n  return 'vertical';\n}","map":{"version":3,"sources":["../../../../src/compile/mark/init.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isBinned, isBinning } from '../../bin';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isNumericDataDef } from '../../channeldef';\nimport { isAggregate } from '../../encoding';\nimport { replaceExprRef } from '../../expr';\nimport * as log from '../../log';\nimport { AREA, BAR, BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX, CIRCLE, IMAGE, LINE, POINT, RECT, RULE, SQUARE, TEXT, TICK } from '../../mark';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { getMarkConfig, getMarkPropOrConfig } from '../common';\nexport function initMarkdef(originalMarkDef, encoding, config) {\n    // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n    const markDef = replaceExprRef(originalMarkDef);\n    // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n    const specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n    markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n    if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n        log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n    }\n    if (markDef.type === 'bar' && markDef.orient) {\n        const cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n        if (cornerRadiusEnd !== undefined) {\n            const newProps = (markDef.orient === 'horizontal' && encoding.x2) || (markDef.orient === 'vertical' && encoding.y2)\n                ? ['cornerRadius']\n                : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n            for (const newProp of newProps) {\n                markDef[newProp] = cornerRadiusEnd;\n            }\n            if (markDef.cornerRadiusEnd !== undefined) {\n                delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n            }\n        }\n    }\n    // set opacity and filled if not specified in mark config\n    const specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n    if (specifiedOpacity === undefined) {\n        markDef.opacity = opacity(markDef.type, encoding);\n    }\n    // set cursor, which should be pointer if href channel is present unless otherwise specified\n    const specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n    if (specifiedCursor === undefined) {\n        markDef.cursor = cursor(markDef, encoding, config);\n    }\n    return markDef;\n}\nfunction cursor(markDef, encoding, config) {\n    if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n        return 'pointer';\n    }\n    return markDef.cursor;\n}\nfunction opacity(mark, encoding) {\n    if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n        // point-based marks\n        if (!isAggregate(encoding)) {\n            return 0.7;\n        }\n    }\n    return undefined;\n}\nexport function defaultFilled(markDef, config, { graticule }) {\n    if (graticule) {\n        return false;\n    }\n    const filledConfig = getMarkConfig('filled', markDef, config);\n    const mark = markDef.type;\n    return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\nfunction orient(mark, encoding, specifiedOrient) {\n    switch (mark) {\n        case POINT:\n        case CIRCLE:\n        case SQUARE:\n        case TEXT:\n        case RECT:\n        case IMAGE:\n            // orient is meaningless for these marks.\n            return undefined;\n    }\n    const { x, y, x2, y2 } = encoding;\n    switch (mark) {\n        case BAR:\n            if (isFieldDef(x) && (isBinned(x.bin) || (isFieldDef(y) && y.aggregate && !x.aggregate))) {\n                return 'vertical';\n            }\n            if (isFieldDef(y) && (isBinned(y.bin) || (isFieldDef(x) && x.aggregate && !y.aggregate))) {\n                return 'horizontal';\n            }\n            if (y2 || x2) {\n                // Ranged bar does not always have clear orientation, so we allow overriding\n                if (specifiedOrient) {\n                    return specifiedOrient;\n                }\n                // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n                if (!x2) {\n                    if ((isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) || isNumericDataDef(x)) {\n                        return 'horizontal';\n                    }\n                }\n                // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n                if (!y2) {\n                    if ((isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) || isNumericDataDef(y)) {\n                        return 'vertical';\n                    }\n                }\n            }\n        // falls through\n        case RULE:\n            // return undefined for line segment rule and bar with both axis ranged\n            // we have to ignore the case that the data are already binned\n            if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n                return undefined;\n            }\n        // falls through\n        case AREA:\n            // If there are range for both x and y, y (vertical) has higher precedence.\n            if (y2) {\n                if (isFieldDef(y) && isBinned(y.bin)) {\n                    return 'horizontal';\n                }\n                else {\n                    return 'vertical';\n                }\n            }\n            else if (x2) {\n                if (isFieldDef(x) && isBinned(x.bin)) {\n                    return 'vertical';\n                }\n                else {\n                    return 'horizontal';\n                }\n            }\n            else if (mark === RULE) {\n                if (x && !y) {\n                    return 'vertical';\n                }\n                else if (y && !x) {\n                    return 'horizontal';\n                }\n            }\n        // falls through\n        case LINE:\n        case TICK: {\n            // Tick is opposite to bar, line, area and never have ranged mark.\n            const xIsContinuous = isContinuousFieldOrDatumDef(x);\n            const yIsContinuous = isContinuousFieldOrDatumDef(y);\n            if (specifiedOrient) {\n                return specifiedOrient;\n            }\n            else if (xIsContinuous && !yIsContinuous) {\n                return mark !== 'tick' ? 'horizontal' : 'vertical';\n            }\n            else if (!xIsContinuous && yIsContinuous) {\n                return mark !== 'tick' ? 'vertical' : 'horizontal';\n            }\n            else if (xIsContinuous && yIsContinuous) {\n                const xDef = x; // we can cast here since they are surely fieldDef\n                const yDef = y;\n                const xIsTemporal = xDef.type === TEMPORAL;\n                const yIsTemporal = yDef.type === TEMPORAL;\n                // temporal without timeUnit is considered continuous, but better serves as dimension\n                if (xIsTemporal && !yIsTemporal) {\n                    return mark !== 'tick' ? 'vertical' : 'horizontal';\n                }\n                else if (!xIsTemporal && yIsTemporal) {\n                    return mark !== 'tick' ? 'horizontal' : 'vertical';\n                }\n                if (!xDef.aggregate && yDef.aggregate) {\n                    return mark !== 'tick' ? 'vertical' : 'horizontal';\n                }\n                else if (xDef.aggregate && !yDef.aggregate) {\n                    return mark !== 'tick' ? 'horizontal' : 'vertical';\n                }\n                return 'vertical';\n            }\n            else {\n                return undefined;\n            }\n        }\n    }\n    return 'vertical';\n}\n//# sourceMappingURL=init.js.map"]},"metadata":{},"sourceType":"module"}