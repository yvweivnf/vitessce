{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\n\nfunction dropLineAndPoint(markDef) {\n  const {\n    point: _point,\n    line: _line\n  } = markDef,\n        mark = __rest(markDef, [\"point\", \"line\"]);\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config) {\n  for (const mark of ['line', 'area', 'rule', 'trail']) {\n    if (config[mark]) {\n      config = Object.assign(Object.assign({}, config), {\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'])\n      });\n    }\n  }\n\n  return config;\n}\n\nfunction getPointOverlay(markDef, markConfig = {}, encoding) {\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(markDef, markConfig = {}) {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nexport class PathOverlayNormalizer {\n  constructor() {\n    this.name = 'path-overlay';\n  }\n\n  hasMatchingType(spec, config) {\n    if (isUnitSpec(spec)) {\n      const {\n        mark,\n        encoding\n      } = spec;\n      const markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n\n        case 'area':\n          return (// false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n\n    return false;\n  }\n\n  run(spec, normParams, normalize) {\n    const {\n      config\n    } = normParams;\n\n    const {\n      params,\n      projection,\n      mark,\n      encoding: e\n    } = spec,\n          outerSpec = __rest(spec, [\"params\", \"projection\", \"mark\", \"encoding\"]); // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n\n\n    const encoding = normalizeEncoding(e, config);\n    const markDef = isMarkDef(mark) ? mark : {\n      type: mark\n    };\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n    const layer = [Object.assign(Object.assign({}, params ? {\n      params\n    } : {}), {\n      mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined ? {\n        opacity: 0.7\n      } : {}), markDef)),\n      // drop shape from encoding as this might be used to trigger point overlay\n      encoding: omit(encoding, ['shape'])\n    })]; // FIXME: determine rules for applying selections.\n    // Need to copy stack config to overlayed layer\n\n    const stackProps = stack(markDef, encoding);\n    let overlayEncoding = encoding;\n\n    if (stackProps) {\n      const {\n        fieldChannel: stackFieldChannel,\n        offset\n      } = stackProps;\n      overlayEncoding = Object.assign(Object.assign({}, encoding), {\n        [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset ? {\n          stack: offset\n        } : {})\n      });\n    }\n\n    if (lineOverlay) {\n      layer.push(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark: Object.assign(Object.assign({\n          type: 'line'\n        }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay),\n        encoding: overlayEncoding\n      }));\n    }\n\n    if (pointOverlay) {\n      layer.push(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark: Object.assign(Object.assign({\n          type: 'point',\n          opacity: 1,\n          filled: true\n        }, pick(markDef, ['clip', 'tooltip'])), pointOverlay),\n        encoding: overlayEncoding\n      }));\n    }\n\n    return normalize(Object.assign(Object.assign({}, outerSpec), {\n      layer\n    }), Object.assign(Object.assign({}, normParams), {\n      config: dropLineAndPointFromConfig(config)\n    }));\n  }\n\n}","map":{"version":3,"sources":["../../../src/normalize/pathoverlay.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\nfunction dropLineAndPoint(markDef) {\n    const { point: _point, line: _line } = markDef, mark = __rest(markDef, [\"point\", \"line\"]);\n    return keys(mark).length > 1 ? mark : mark.type;\n}\nfunction dropLineAndPointFromConfig(config) {\n    for (const mark of ['line', 'area', 'rule', 'trail']) {\n        if (config[mark]) {\n            config = Object.assign(Object.assign({}, config), { \n                // TODO: remove as any\n                [mark]: omit(config[mark], ['point', 'line']) });\n        }\n    }\n    return config;\n}\nfunction getPointOverlay(markDef, markConfig = {}, encoding) {\n    if (markDef.point === 'transparent') {\n        return { opacity: 0 };\n    }\n    else if (markDef.point) {\n        // truthy : true or object\n        return isObject(markDef.point) ? markDef.point : {};\n    }\n    else if (markDef.point !== undefined) {\n        // false or null\n        return null;\n    }\n    else {\n        // undefined (not disabled)\n        if (markConfig.point || encoding.shape) {\n            // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n            return isObject(markConfig.point) ? markConfig.point : {};\n        }\n        // markDef.point is defined as falsy\n        return undefined;\n    }\n}\nfunction getLineOverlay(markDef, markConfig = {}) {\n    if (markDef.line) {\n        // true or object\n        return markDef.line === true ? {} : markDef.line;\n    }\n    else if (markDef.line !== undefined) {\n        // false or null\n        return null;\n    }\n    else {\n        // undefined (not disabled)\n        if (markConfig.line) {\n            // enable line overlay if config[mark].line is truthy\n            return markConfig.line === true ? {} : markConfig.line;\n        }\n        // markDef.point is defined as falsy\n        return undefined;\n    }\n}\nexport class PathOverlayNormalizer {\n    constructor() {\n        this.name = 'path-overlay';\n    }\n    hasMatchingType(spec, config) {\n        if (isUnitSpec(spec)) {\n            const { mark, encoding } = spec;\n            const markDef = isMarkDef(mark) ? mark : { type: mark };\n            switch (markDef.type) {\n                case 'line':\n                case 'rule':\n                case 'trail':\n                    return !!getPointOverlay(markDef, config[markDef.type], encoding);\n                case 'area':\n                    return (\n                    // false / null are also included as we want to remove the properties\n                    !!getPointOverlay(markDef, config[markDef.type], encoding) ||\n                        !!getLineOverlay(markDef, config[markDef.type]));\n            }\n        }\n        return false;\n    }\n    run(spec, normParams, normalize) {\n        const { config } = normParams;\n        const { params, projection, mark, encoding: e } = spec, outerSpec = __rest(spec, [\"params\", \"projection\", \"mark\", \"encoding\"]);\n        // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n        const encoding = normalizeEncoding(e, config);\n        const markDef = isMarkDef(mark) ? mark : { type: mark };\n        const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n        const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n        const layer = [\n            Object.assign(Object.assign({}, (params ? { params } : {})), { mark: dropLineAndPoint(Object.assign(Object.assign({}, (markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined\n                    ? { opacity: 0.7 }\n                    : {})), markDef)), \n                // drop shape from encoding as this might be used to trigger point overlay\n                encoding: omit(encoding, ['shape']) })\n        ];\n        // FIXME: determine rules for applying selections.\n        // Need to copy stack config to overlayed layer\n        const stackProps = stack(markDef, encoding);\n        let overlayEncoding = encoding;\n        if (stackProps) {\n            const { fieldChannel: stackFieldChannel, offset } = stackProps;\n            overlayEncoding = Object.assign(Object.assign({}, encoding), { [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), (offset ? { stack: offset } : {})) });\n        }\n        if (lineOverlay) {\n            layer.push(Object.assign(Object.assign({}, (projection ? { projection } : {})), { mark: Object.assign(Object.assign({ type: 'line' }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay), encoding: overlayEncoding }));\n        }\n        if (pointOverlay) {\n            layer.push(Object.assign(Object.assign({}, (projection ? { projection } : {})), { mark: Object.assign(Object.assign({ type: 'point', opacity: 1, filled: true }, pick(markDef, ['clip', 'tooltip'])), pointOverlay), encoding: overlayEncoding }));\n        }\n        return normalize(Object.assign(Object.assign({}, outerSpec), { layer }), Object.assign(Object.assign({}, normParams), { config: dropLineAndPointFromConfig(config) }));\n    }\n}\n//# sourceMappingURL=pathoverlay.js.map"]},"metadata":{},"sourceType":"module"}