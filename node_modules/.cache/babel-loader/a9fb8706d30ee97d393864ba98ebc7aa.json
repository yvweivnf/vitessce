{"ast":null,"code":"import { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\n\nfunction makeWalkTree(data) {\n  // to name datasources\n  let datasetIndex = 0;\n  /**\n   * Recursively walk down the tree.\n   */\n\n  function walkTree(node, dataSource) {\n    var _a;\n\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format) !== null && _a !== void 0 ? _a : {}), {\n          parse: node.assembleFormatParse()\n        }); // add calculates for all nested fields\n\n        dataSource.transform.push(...node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform.push(...node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      data.push(...node.assemble()); // break here because the rest of the tree has to be taken care of by the facet.\n\n      return;\n    }\n\n    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {\n      dataSource.transform.push(...node.assemble());\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        } // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n\n\n        node.setSource(dataSource.name); // if this node has more than one child, we will add a datasource automatically\n\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n\n        break;\n\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n\n      default:\n        {\n          if (!dataSource.name) {\n            dataSource.name = `data_${datasetIndex++}`;\n          }\n\n          let source = dataSource.name;\n\n          if (!dataSource.source || dataSource.transform.length > 0) {\n            data.push(dataSource);\n          } else {\n            source = dataSource.source;\n          }\n\n          for (const child of node.children) {\n            const newData = {\n              name: null,\n              source: source,\n              transform: []\n            };\n            walkTree(child, newData);\n          }\n\n          break;\n        }\n    }\n  }\n\n  return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\n\n\nexport function assembleFacetData(root) {\n  const data = [];\n  const walkTree = makeWalkTree(data);\n\n  for (const child of root.children) {\n    walkTree(child, {\n      source: root.name,\n      name: null,\n      transform: []\n    });\n  }\n\n  return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\n\nexport function assembleRootData(dataComponent, datasets) {\n  var _a, _b;\n\n  const data = []; // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n\n  const walkTree = makeWalkTree(data);\n  let sourceIndex = 0;\n\n  for (const root of dataComponent.sources) {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData = root.assemble();\n    walkTree(root, newData);\n  } // remove empty transform arrays for cleaner output\n\n\n  for (const d of data) {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  } // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n\n\n  let whereTo = 0;\n\n  for (const [i, d] of data.entries()) {\n    if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  } // now fix the from references in lookup transforms\n\n\n  for (const d of data) {\n    for (const t of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  } // inline values for datasets that are in the datastore\n\n\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n\n  return data;\n}","map":{"version":3,"sources":["../../../../src/compile/data/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nfunction makeWalkTree(data) {\n    // to name datasources\n    let datasetIndex = 0;\n    /**\n     * Recursively walk down the tree.\n     */\n    function walkTree(node, dataSource) {\n        var _a;\n        if (node instanceof SourceNode) {\n            // If the source is a named data source or a data source with values, we need\n            // to put it in a different data source. Otherwise, Vega may override the data.\n            if (!node.isGenerator && !isUrlData(node.data)) {\n                data.push(dataSource);\n                const newData = {\n                    name: null,\n                    source: dataSource.name,\n                    transform: []\n                };\n                dataSource = newData;\n            }\n        }\n        if (node instanceof ParseNode) {\n            if (node.parent instanceof SourceNode && !dataSource.source) {\n                // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n                dataSource.format = Object.assign(Object.assign({}, ((_a = dataSource.format) !== null && _a !== void 0 ? _a : {})), { parse: node.assembleFormatParse() });\n                // add calculates for all nested fields\n                dataSource.transform.push(...node.assembleTransforms(true));\n            }\n            else {\n                // Otherwise use Vega expression to parse\n                dataSource.transform.push(...node.assembleTransforms());\n            }\n        }\n        if (node instanceof FacetNode) {\n            if (!dataSource.name) {\n                dataSource.name = `data_${datasetIndex++}`;\n            }\n            if (!dataSource.source || dataSource.transform.length > 0) {\n                data.push(dataSource);\n                node.data = dataSource.name;\n            }\n            else {\n                node.data = dataSource.source;\n            }\n            data.push(...node.assemble());\n            // break here because the rest of the tree has to be taken care of by the facet.\n            return;\n        }\n        if (node instanceof GraticuleNode ||\n            node instanceof SequenceNode ||\n            node instanceof FilterInvalidNode ||\n            node instanceof FilterNode ||\n            node instanceof CalculateNode ||\n            node instanceof GeoPointNode ||\n            node instanceof AggregateNode ||\n            node instanceof LookupNode ||\n            node instanceof WindowTransformNode ||\n            node instanceof JoinAggregateTransformNode ||\n            node instanceof FoldTransformNode ||\n            node instanceof FlattenTransformNode ||\n            node instanceof DensityTransformNode ||\n            node instanceof LoessTransformNode ||\n            node instanceof QuantileTransformNode ||\n            node instanceof RegressionTransformNode ||\n            node instanceof IdentifierNode ||\n            node instanceof SampleTransformNode ||\n            node instanceof PivotTransformNode) {\n            dataSource.transform.push(node.assemble());\n        }\n        if (node instanceof BinNode ||\n            node instanceof TimeUnitNode ||\n            node instanceof ImputeNode ||\n            node instanceof StackNode ||\n            node instanceof GeoJSONNode) {\n            dataSource.transform.push(...node.assemble());\n        }\n        if (node instanceof OutputNode) {\n            if (dataSource.source && dataSource.transform.length === 0) {\n                node.setSource(dataSource.source);\n            }\n            else if (node.parent instanceof OutputNode) {\n                // Note that an output node may be required but we still do not assemble a\n                // separate data source for it.\n                node.setSource(dataSource.name);\n            }\n            else {\n                if (!dataSource.name) {\n                    dataSource.name = `data_${datasetIndex++}`;\n                }\n                // Here we set the name of the datasource we generated. From now on\n                // other assemblers can use it.\n                node.setSource(dataSource.name);\n                // if this node has more than one child, we will add a datasource automatically\n                if (node.numChildren() === 1) {\n                    data.push(dataSource);\n                    const newData = {\n                        name: null,\n                        source: dataSource.name,\n                        transform: []\n                    };\n                    dataSource = newData;\n                }\n            }\n        }\n        switch (node.numChildren()) {\n            case 0:\n                // done\n                if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n                    // do not push empty datasources that are simply references\n                    data.push(dataSource);\n                }\n                break;\n            case 1:\n                walkTree(node.children[0], dataSource);\n                break;\n            default: {\n                if (!dataSource.name) {\n                    dataSource.name = `data_${datasetIndex++}`;\n                }\n                let source = dataSource.name;\n                if (!dataSource.source || dataSource.transform.length > 0) {\n                    data.push(dataSource);\n                }\n                else {\n                    source = dataSource.source;\n                }\n                for (const child of node.children) {\n                    const newData = {\n                        name: null,\n                        source: source,\n                        transform: []\n                    };\n                    walkTree(child, newData);\n                }\n                break;\n            }\n        }\n    }\n    return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root) {\n    const data = [];\n    const walkTree = makeWalkTree(data);\n    for (const child of root.children) {\n        walkTree(child, {\n            source: root.name,\n            name: null,\n            transform: []\n        });\n    }\n    return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent, datasets) {\n    var _a, _b;\n    const data = [];\n    // dataComponent.sources.forEach(debug);\n    // draw(dataComponent.sources);\n    const walkTree = makeWalkTree(data);\n    let sourceIndex = 0;\n    for (const root of dataComponent.sources) {\n        // assign a name if the source does not have a name yet\n        if (!root.hasName()) {\n            root.dataName = `source_${sourceIndex++}`;\n        }\n        const newData = root.assemble();\n        walkTree(root, newData);\n    }\n    // remove empty transform arrays for cleaner output\n    for (const d of data) {\n        if (d.transform.length === 0) {\n            delete d.transform;\n        }\n    }\n    // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n    let whereTo = 0;\n    for (const [i, d] of data.entries()) {\n        if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {\n            data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n        }\n    }\n    // now fix the from references in lookup transforms\n    for (const d of data) {\n        for (const t of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {\n            if (t.type === 'lookup') {\n                t.from = dataComponent.outputNodes[t.from].getSource();\n            }\n        }\n    }\n    // inline values for datasets that are in the datastore\n    for (const d of data) {\n        if (d.name in datasets) {\n            d.values = datasets[d.name];\n        }\n    }\n    return data;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}