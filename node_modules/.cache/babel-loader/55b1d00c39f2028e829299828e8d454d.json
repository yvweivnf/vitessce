{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nexport function getLodStatus(tile, frameState) {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n\n  var screenSize = 2 * getProjectedRadius(tile, frameState);\n\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\nexport function getProjectedRadius(tile, frameState) {\n  var originalViewport = frameState.viewport;\n  var ViewportClass = originalViewport.constructor;\n  var longitude = originalViewport.longitude,\n      latitude = originalViewport.latitude,\n      height = originalViewport.height,\n      width = originalViewport.width,\n      bearing = originalViewport.bearing,\n      zoom = originalViewport.zoom;\n  var viewport = new ViewportClass({\n    longitude: longitude,\n    latitude: latitude,\n    height: height,\n    width: width,\n    bearing: bearing,\n    zoom: zoom,\n    pitch: 0\n  });\n  var mbsLat = tile.header.mbs[1];\n  var mbsLon = tile.header.mbs[0];\n  var mbsZ = tile.header.mbs[2];\n  var mbsR = tile.header.mbs[3];\n\n  var mbsCenterCartesian = _toConsumableArray(tile.boundingVolume.center);\n\n  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  var cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  var toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  var enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  var cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  var cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  var projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n  var extraZ = projection * projection / cameraPositionEnu[2];\n  var extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  var extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  var extraVectorCartesian = new Vector3(extraVertexCartesian).subtract(mbsCenterCartesian).normalize();\n  var radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  var sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  var sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n  var projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  var projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  var projectedRadius = new Vector3(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();\n  return projectedRadius;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["tile","isNaN","screenSize","getProjectedRadius","originalViewport","frameState","ViewportClass","zoom","viewport","longitude","latitude","height","width","bearing","pitch","mbsLat","mbsLon","mbsZ","mbsR","mbsCenterCartesian","cameraPositionCartographic","cameraPositionCartesian","Ellipsoid","toEye","enuToCartesianMatrix","cartesianToEnuMatrix","cameraPositionEnu","projection","Math","extraZ","extraVertexEnu","extraVertexCartesian","extraVectorCartesian","radiusVector","sphereMbsBorderVertexCartesian","sphereMbsBorderVertexCartographic","projectedOrigin","projectedMbsBorderVertex","projectedRadius"],"mappings":"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","sourcesContent":["import {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport Tile3D from '../tile-3d';\nimport {FrameState} from './frame-state';\n\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile \n * @param frameState \n * @returns \n */\nexport function getLodStatus(tile: Tile3D, frameState: FrameState): 'DIG' | 'OUT' | 'DRAW' {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile: Tile3D, frameState: FrameState): number {\n  const originalViewport = frameState.viewport;\n  const ViewportClass = originalViewport.constructor;\n  const {longitude, latitude, height, width, bearing, zoom} = originalViewport;\n  // @ts-ignore\n  const viewport = new ViewportClass({longitude, latitude, height, width, bearing, zoom, pitch: 0});\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  const toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  const enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  const cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  const cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(\n    cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]\n  );\n  const extraZ = (projection * projection) / cameraPositionEnu[2];\n  const extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = new Vector3(extraVertexCartesian)\n    .subtract(mbsCenterCartesian)\n    .normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(\n    sphereMbsBorderVertexCartesian\n  );\n  // ---------------------------\n\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = new Vector3(projectedOrigin)\n    .subtract(projectedMbsBorderVertex)\n    .magnitude();\n  return projectedRadius;\n}\n"]},"metadata":{},"sourceType":"module"}