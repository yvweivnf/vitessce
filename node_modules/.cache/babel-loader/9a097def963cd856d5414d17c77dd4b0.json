{"ast":null,"code":"import LoaderResult from '../LoaderResult';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\n/**\n * Loader for converting zarr into the cell json schema.\n */\n\nexport default class CellsZarrLoader extends AbstractTwoStepLoader {\n  /**\n   * Class method for loading spatial cell centroids.\n   * @returns {Promise} A promise for an array of tuples/triples for cell centroids.\n   */\n  loadXy() {\n    const {\n      xy\n    } = this.options || {};\n\n    if (this.xy) {\n      return this.xy;\n    }\n\n    if (!this.xy && xy) {\n      this.xy = this.dataSource.loadNumeric(xy);\n      return this.xy;\n    }\n\n    this.xy = Promise.resolve(null);\n    return this.xy;\n  }\n  /**\n   * Class method for loading spatial cell polygons.\n   * @returns {Promise} A promise for an array of arrays for cell polygons.\n   */\n\n\n  loadPoly() {\n    const {\n      poly\n    } = this.options || {};\n\n    if (this.poly) {\n      return this.poly;\n    }\n\n    if (!this.poly && poly) {\n      this.poly = this.dataSource.loadNumeric(poly);\n      return this.poly;\n    }\n\n    this.poly = Promise.resolve(null);\n    return this.poly;\n  }\n  /**\n   * Class method for loading various mappings, like UMAP or tSNE cooridnates.\n   * @returns {Promise} A promise for an array of tuples of coordinates.\n   */\n\n\n  loadMappings() {\n    const {\n      mappings\n    } = this.options || {};\n\n    if (this.mappings) {\n      return this.mappings;\n    }\n\n    if (!this.mappings && mappings) {\n      this.mappings = Promise.all(Object.keys(mappings).map(async coordinationName => {\n        const {\n          key\n        } = mappings[coordinationName];\n        return {\n          coordinationName,\n          arr: await this.dataSource.loadNumeric(key)\n        };\n      }));\n      return this.mappings;\n    }\n\n    this.mappings = Promise.resolve(null);\n    return this.mappings;\n  }\n  /**\n   * Class method for loading factors, which are cell set ids.\n   * @returns {Promise} A promise for an array of an array of strings of ids,\n   * where subarray is a clustering/factor.\n   */\n\n\n  loadFactors() {\n    const {\n      factors\n    } = this.options || {};\n\n    if (factors) {\n      return this.dataSource.loadObsColumns(factors);\n    }\n\n    return Promise.resolve(null);\n  }\n\n  async load() {\n    if (!this.cells) {\n      this.cells = Promise.all([this.loadMappings(), this.loadXy(), this.loadPoly(), this.dataSource.loadObsIndex(), this.loadFactors()]).then(([mappings, xy, poly, cellNames, factors]) => {\n        const cells = {};\n        cellNames.forEach((name, i) => {\n          cells[name] = {};\n\n          if (mappings) {\n            mappings.forEach(({\n              coordinationName,\n              arr\n            }) => {\n              if (!cells[name].mappings) {\n                cells[name].mappings = {};\n              }\n\n              const {\n                dims\n              } = this.options.mappings[coordinationName];\n              cells[name].mappings[coordinationName] = dims.map(dim => arr.data[i][dim]);\n            });\n          }\n\n          if (xy) {\n            cells[name].xy = xy.data[i];\n          }\n\n          if (poly) {\n            cells[name].poly = poly.data[i];\n          }\n\n          if (factors) {\n            const factorsObj = {};\n            factors.forEach( // eslint-disable-next-line no-return-assign\n            (factor, j) => factorsObj[this.options.factors[j].split('/').slice(-1)] = factor[i]);\n            cells[name].factors = factorsObj;\n          }\n        });\n        return cells;\n      });\n    }\n\n    return Promise.resolve(new LoaderResult((await this.cells), null));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/anndata-loaders/CellsZarrLoader.js"],"names":["LoaderResult","AbstractTwoStepLoader","CellsZarrLoader","loadXy","xy","options","dataSource","loadNumeric","Promise","resolve","loadPoly","poly","loadMappings","mappings","all","Object","keys","map","coordinationName","key","arr","loadFactors","factors","loadObsColumns","load","cells","loadObsIndex","then","cellNames","forEach","name","i","dims","dim","data","factorsObj","factor","j","split","slice"],"mappings":"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","sourcesContent":["import LoaderResult from '../LoaderResult';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\n\n/**\n * Loader for converting zarr into the cell json schema.\n */\nexport default class CellsZarrLoader extends AbstractTwoStepLoader {\n  /**\n   * Class method for loading spatial cell centroids.\n   * @returns {Promise} A promise for an array of tuples/triples for cell centroids.\n   */\n  loadXy() {\n    const { xy } = (this.options || {});\n    if (this.xy) {\n      return this.xy;\n    }\n    if (!this.xy && xy) {\n      this.xy = this.dataSource.loadNumeric(xy);\n      return this.xy;\n    }\n    this.xy = Promise.resolve(null);\n    return this.xy;\n  }\n\n  /**\n   * Class method for loading spatial cell polygons.\n   * @returns {Promise} A promise for an array of arrays for cell polygons.\n   */\n  loadPoly() {\n    const { poly } = (this.options || {});\n    if (this.poly) {\n      return this.poly;\n    }\n    if (!this.poly && poly) {\n      this.poly = this.dataSource.loadNumeric(poly);\n      return this.poly;\n    }\n    this.poly = Promise.resolve(null);\n    return this.poly;\n  }\n\n  /**\n   * Class method for loading various mappings, like UMAP or tSNE cooridnates.\n   * @returns {Promise} A promise for an array of tuples of coordinates.\n   */\n  loadMappings() {\n    const { mappings } = (this.options || {});\n    if (this.mappings) {\n      return this.mappings;\n    }\n    if (!this.mappings && mappings) {\n      this.mappings = Promise.all(\n        Object.keys(mappings).map(async (coordinationName) => {\n          const { key } = mappings[coordinationName];\n          return { coordinationName, arr: await this.dataSource.loadNumeric(key) };\n        }),\n      );\n      return this.mappings;\n    }\n    this.mappings = Promise.resolve(null);\n    return this.mappings;\n  }\n\n  /**\n   * Class method for loading factors, which are cell set ids.\n   * @returns {Promise} A promise for an array of an array of strings of ids,\n   * where subarray is a clustering/factor.\n   */\n  loadFactors() {\n    const { factors } = (this.options || {});\n    if (factors) {\n      return this.dataSource.loadObsColumns(factors);\n    }\n    return Promise.resolve(null);\n  }\n\n  async load() {\n    if (!this.cells) {\n      this.cells = Promise.all([\n        this.loadMappings(),\n        this.loadXy(),\n        this.loadPoly(),\n        this.dataSource.loadObsIndex(),\n        this.loadFactors(),\n      ]).then(([mappings, xy, poly, cellNames, factors]) => {\n        const cells = {};\n        cellNames.forEach((name, i) => {\n          cells[name] = {};\n          if (mappings) {\n            mappings.forEach(({ coordinationName, arr }) => {\n              if (!cells[name].mappings) {\n                cells[name].mappings = {};\n              }\n              const { dims } = this.options.mappings[coordinationName];\n              cells[name].mappings[coordinationName] = dims.map(\n                dim => arr.data[i][dim],\n              );\n            });\n          }\n          if (xy) {\n            cells[name].xy = xy.data[i];\n          }\n          if (poly) {\n            cells[name].poly = poly.data[i];\n          }\n          if (factors) {\n            const factorsObj = {};\n            factors.forEach(\n              // eslint-disable-next-line no-return-assign\n              (factor, j) => (factorsObj[this.options.factors[j].split('/').slice(-1)] = factor[i]),\n            );\n            cells[name].factors = factorsObj;\n          }\n        });\n        return cells;\n      });\n    }\n    return Promise.resolve(new LoaderResult(await this.cells, null));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}