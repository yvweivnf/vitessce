{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\src\\\\components\\\\sets\\\\CellSetsManagerSubscriber.js\";\nimport React, { useEffect, useState, useMemo } from 'react';\nimport isEqual from 'lodash/isEqual';\nimport packageJson from '../../../package.json';\nimport { useCoordination, useLoaders, useSetWarning } from '../../app/state/hooks';\nimport { COMPONENT_COORDINATION_TYPES } from '../../app/state/coordination';\nimport SetsManager from './SetsManager';\nimport TitleInfo from '../TitleInfo';\nimport { treeExportLevelZeroNode, treeExportSet, treeToExpectedCheckedLevel, nodeToLevelDescendantNamePaths, treeToIntersection, treeToUnion, treeToComplement, treeFindNodeByNamePath, treesConflict, nodeTransform, nodeAppendChild, nodePrependChild, nodeInsertChild, filterNode, treeInitialize, initializeCellSetColor } from './cell-set-utils';\nimport { isEqualOrPrefix, tryRenamePath, PATH_SEP } from './utils';\nimport { downloadForUser, handleExportJSON, handleExportTabular, tryUpgradeTreeToLatestSchema } from './io';\nimport { FILE_EXTENSION_JSON, FILE_EXTENSION_TABULAR, SETS_DATATYPE_CELL } from './constants';\nimport { useUrls, useReady } from '../hooks';\nimport { setCellSelection, mergeCellSets, getNextNumberedNodeName } from '../utils';\nimport { useCellsData, useCellSetsData } from '../data-hooks';\nconst CELL_SETS_DATA_TYPES = ['cells', 'cell-sets'];\n/**\n * A subscriber wrapper around the SetsManager component\n * for the 'cell' datatype.\n * @param {object} props\n * @param {string} props.theme The current theme name.\n * @param {object} props.coordinationScopes The mapping from coordination types to coordination\n * scopes.\n * @param {function} props.removeGridComponent The callback function to pass to TitleInfo,\n * to call when the component has been removed from the grid.\n * @param {string} props.title The component title.\n */\n\nexport default function CellSetsManagerSubscriber(props) {\n  const {\n    coordinationScopes,\n    removeGridComponent,\n    theme,\n    title = 'Cell Sets'\n  } = props;\n  const loaders = useLoaders();\n  const setWarning = useSetWarning(); // Get \"props\" from the coordination space.\n\n  const [{\n    dataset,\n    obsSetSelection: cellSetSelection,\n    obsSetColor: cellSetColor,\n    additionalObsSets: additionalCellSets,\n    obsColorEncoding: cellColorEncoding\n  }, {\n    setObsSetSelection: setCellSetSelection,\n    setObsColorEncoding: setCellColorEncoding,\n    setObsSetColor: setCellSetColor,\n    setAdditionalObsSets: setAdditionalCellSets\n  }] = useCoordination(COMPONENT_COORDINATION_TYPES.cellSets, coordinationScopes);\n  const [urls, addUrl, resetUrls] = useUrls();\n  const [isReady, setItemIsReady, setItemIsNotReady, // eslint-disable-line no-unused-vars\n  resetReadyItems] = useReady(CELL_SETS_DATA_TYPES);\n  const [cellSetExpansion, setCellSetExpansion] = useState([]); // Reset file URLs and loader progress when the dataset has changed.\n\n  useEffect(() => {\n    resetUrls();\n    resetReadyItems();\n    setCellSetExpansion([]); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [loaders, dataset]); // Get data from loaders using the data hooks.\n\n  const [cells] = useCellsData(loaders, dataset, setItemIsReady, addUrl, true);\n  const [cellSets] = useCellSetsData(loaders, dataset, setItemIsReady, addUrl, false, {\n    setObsSetSelection: setCellSetSelection,\n    setObsSetColor: setCellSetColor\n  }, {\n    obsSetSelection: cellSetSelection,\n    obsSetColor: cellSetColor\n  }); // Validate and upgrade the additionalCellSets.\n\n  useEffect(() => {\n    if (additionalCellSets) {\n      let upgradedCellSets;\n\n      try {\n        upgradedCellSets = tryUpgradeTreeToLatestSchema(additionalCellSets, SETS_DATATYPE_CELL);\n      } catch (e) {\n        setWarning(e.message);\n        return;\n      }\n\n      setAdditionalCellSets(upgradedCellSets);\n    }\n  }, [additionalCellSets, setAdditionalCellSets, setWarning]); // Get an array of all cell IDs to use for set complement operations.\n\n  const allCellIds = useMemo(() => cells ? Object.keys(cells) : [], [cells]); // A helper function for updating the encoding for cell colors,\n  // which may have previously been set to 'geneSelection'.\n\n  function setCellSetColorEncoding() {\n    setCellColorEncoding('cellSetSelection');\n  } // Merged cell sets are only to be used for convenience when reading\n  // (if writing: update either `cellSets` _or_ `additionalCellSets`).\n\n\n  const mergedCellSets = useMemo(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]); // Infer the state of the \"checked level\" radio button based on the selected cell sets.\n\n  const checkedLevel = useMemo(() => {\n    if (cellSetSelection && cellSetSelection.length > 0 && mergedCellSets && mergedCellSets.tree.length > 0) {\n      return treeToExpectedCheckedLevel(mergedCellSets, cellSetSelection);\n    }\n\n    return null;\n  }, [cellSetSelection, mergedCellSets]); // Callback functions\n  // The user wants to select all nodes at a particular hierarchy level.\n\n  function onCheckLevel(levelZeroName, levelIndex) {\n    const lzn = mergedCellSets.tree.find(n => n.name === levelZeroName);\n\n    if (lzn) {\n      const newCellSetSelection = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);\n      setCellSetSelection(newCellSetSelection);\n      setCellSetColorEncoding();\n    }\n  } // The user wants to check or uncheck a cell set node.\n\n\n  function onCheckNode(targetKey, checked) {\n    const targetPath = Array.isArray(targetKey) ? targetKey : targetKey.split(PATH_SEP);\n\n    if (!targetKey) {\n      return;\n    }\n\n    if (checked) {\n      setCellSetSelection([...cellSetSelection, targetPath]);\n    } else {\n      setCellSetSelection(cellSetSelection.filter(d => !isEqual(d, targetPath)));\n    }\n\n    setCellSetColorEncoding();\n  } // The user wants to expand or collapse a node in the tree.\n\n\n  function onExpandNode(expandedKeys, targetKey, expanded) {\n    if (expanded) {\n      setCellSetExpansion(prev => [...prev, targetKey.split(PATH_SEP)]);\n    } else {\n      setCellSetExpansion(prev => prev.filter(d => !isEqual(d, targetKey.split(PATH_SEP))));\n    }\n  } // The user dragged a tree node and dropped it somewhere else in the tree\n  // to re-arrange or re-order the nodes.\n  // We need to verify that their drop target is valid, and if so, complete\n  // the tree re-arrangement.\n\n\n  function onDropNode(dropKey, dragKey, dropPosition, dropToGap) {\n    const dropPath = dropKey.split(PATH_SEP);\n    const dropNode = treeFindNodeByNamePath(additionalCellSets, dropPath);\n\n    if (!dropNode.children && !dropToGap) {\n      // Do not allow a node with a set (i.e. leaf) to become a child of another node with a set,\n      // as this will result in an internal node having a set, which we do not allow.\n      return;\n    }\n\n    const dropNodeLevel = dropPath.length - 1;\n    const dropNodeIsLevelZero = dropNodeLevel === 0; // Get drag node.\n\n    const dragPath = dragKey.split(PATH_SEP);\n    const dragNode = treeFindNodeByNamePath(additionalCellSets, dragPath);\n\n    if (dropNodeIsLevelZero && dropToGap && !dragNode.children) {\n      // Do not allow a leaf node to become a level zero node.\n      return;\n    }\n\n    let dropParentNode;\n    let dropParentPath;\n    let dropNodeCurrIndex;\n\n    if (!dropNodeIsLevelZero) {\n      dropParentPath = dropPath.slice(0, -1);\n      dropParentNode = treeFindNodeByNamePath(additionalCellSets, dropParentPath);\n      dropNodeCurrIndex = dropParentNode.children.findIndex(c => c.name === dropNode.name);\n    } else {\n      dropNodeCurrIndex = additionalCellSets.tree.findIndex(lzn => lzn.name === dropNode.name);\n    } // Further, only allow dragging if the dragged node will have a unique\n    // name among its new siblings.\n\n\n    let hasSiblingNameConflict;\n    const dragNodeName = dragNode.name;\n\n    if (!dropNodeIsLevelZero && dropToGap) {\n      hasSiblingNameConflict = dropParentNode.children.find(c => c !== dragNode && c.name === dragNodeName);\n    } else if (!dropToGap) {\n      hasSiblingNameConflict = dropNode.children.find(c => c !== dragNode && c.name === dragNodeName);\n    } else {\n      hasSiblingNameConflict = additionalCellSets.tree.find(lzn => lzn !== dragNode && lzn.name === dragNodeName);\n    }\n\n    if (hasSiblingNameConflict) {\n      return;\n    } // Remove the dragged object from its current position.\n    // Recursively check whether each node path\n    // matches the path of the node to delete.\n    // If so, return null, and then always use\n    // .filter(Boolean) to eliminate any null array elements.\n\n\n    const nextAdditionalCellSets = { ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => filterNode(lzn, [], dragPath)).filter(Boolean)\n    }; // Update index values after temporarily removing the dragged node.\n    // Names are unique as children of their parents.\n\n    if (!dropNodeIsLevelZero) {\n      dropNodeCurrIndex = dropParentNode.children.findIndex(c => c.name === dropNode.name);\n    } else {\n      dropNodeCurrIndex = nextAdditionalCellSets.tree.findIndex(lzn => lzn.name === dropNode.name);\n    }\n\n    let newDragPath = [];\n\n    if (!dropToGap || !dropNodeIsLevelZero) {\n      let addChildFunction;\n      let checkPathFunction;\n      const newPath = [];\n\n      if (!dropToGap) {\n        // Append the dragNode to dropNode's children if dropping _onto_ the dropNode.\n        // Set dragNode as the last child of dropNode.\n        addChildFunction = n => nodeAppendChild(n, dragNode);\n\n        checkPathFunction = path => isEqual(path, dropPath);\n      } else if (!dropNodeIsLevelZero) {\n        // Prepend or insert the dragNode if dropping _between_ (above or below dropNode).\n        // The dropNode is at a level greater than zero,\n        // so it has a parent.\n        checkPathFunction = path => isEqual(path, dropParentPath);\n\n        if (dropPosition === -1) {\n          // Set dragNode as first child of dropParentNode.\n          addChildFunction = n => nodePrependChild(n, dragNode);\n        } else {\n          // Set dragNode before or after dropNode.\n          const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);\n\n          addChildFunction = n => nodeInsertChild(n, dragNode, insertIndex);\n        }\n      }\n\n      nextAdditionalCellSets.tree = nextAdditionalCellSets.tree.map(node => nodeTransform(node, (n, path) => checkPathFunction(path), n => {\n        const newNode = addChildFunction(n);\n        return newNode;\n      }, newPath)); // Done\n\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [...newPath[0], dragNode.name];\n      setCellSetSelection([newDragPath]);\n    } else if (dropPosition === -1) {\n      // We need to drop the dragNode to level zero,\n      // and level zero nodes do not have parents.\n      // Set dragNode as first level zero node of the tree.\n      nextAdditionalCellSets.tree.unshift(dragNode);\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [dragNode.name];\n      setCellSetSelection([newDragPath]);\n    } else {\n      // Set dragNode before or after dropNode in level zero.\n      const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);\n      const newLevelZero = Array.from(nextAdditionalCellSets.tree);\n      newLevelZero.splice(insertIndex, 0, dragNode);\n      nextAdditionalCellSets.tree = newLevelZero;\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [dragNode.name];\n      setCellSetSelection([newDragPath]);\n    }\n\n    const oldColors = cellSetColor.filter(i => isEqualOrPrefix(dragPath, i.path));\n    const newColors = oldColors.map(i => ({ ...i,\n      path: !isEqual(i.path, dragPath) ? newDragPath.concat(i.path.slice(dragPath.length)) : newDragPath\n    }));\n    const newCellSetColor = cellSetColor.filter(i => !isEqualOrPrefix(dragPath, i.path));\n    newCellSetColor.push(...newColors);\n    setCellSetColor(newCellSetColor);\n  } // The user wants to change the color of a cell set node.\n\n\n  function onNodeSetColor(targetPath, color) {\n    // Replace the color if an array element for this path already exists.\n    const prevNodeColor = cellSetColor === null || cellSetColor === void 0 ? void 0 : cellSetColor.find(d => isEqual(d.path, targetPath));\n\n    if (!prevNodeColor) {\n      setCellSetColor([...(cellSetColor || []), {\n        path: targetPath,\n        color\n      }]);\n    } else {\n      setCellSetColor([...cellSetColor.filter(d => !isEqual(d.path, targetPath)), {\n        path: targetPath,\n        color\n      }]);\n    }\n  } // The user wants to change the name of a cell set node.\n\n\n  function onNodeSetName(targetPath, name) {\n    const nextNamePath = [...targetPath];\n    nextNamePath.pop();\n    nextNamePath.push(name); // Recursively check whether each node path\n    // matches the path or a prefix of the path of the node to rename.\n    // If so, rename the node using the new path.\n\n    function renameNode(node, prevPath) {\n      if (isEqual([...prevPath, node.name], targetPath)) {\n        return { ...node,\n          name\n        };\n      }\n\n      if (!node.children) {\n        return node;\n      }\n\n      return { ...node,\n        children: node.children.map(c => renameNode(c, [...prevPath, node.name]))\n      };\n    }\n\n    const nextAdditionalCellSets = { ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => renameNode(lzn, []))\n    }; // Change all paths that have this node as a prefix (i.e. descendants).\n\n    const nextCellSetColor = cellSetColor.map(d => ({\n      path: tryRenamePath(targetPath, d.path, nextNamePath),\n      color: d.color\n    }));\n    const nextCellSetSelection = cellSetSelection.map(d => tryRenamePath(targetPath, d, nextNamePath));\n    const nextCellSetExpansion = cellSetExpansion.map(d => tryRenamePath(targetPath, d, nextNamePath)); // Need to update the node path everywhere it may be present.\n\n    setAdditionalCellSets(nextAdditionalCellSets);\n    setCellSetColor(nextCellSetColor);\n    setCellSetSelection(nextCellSetSelection);\n    setCellSetExpansion(nextCellSetExpansion);\n  } // Each time the user types while renaming a cell set node,\n  // we need to check whether the potential new name conflicts\n  // with any existing cell set node names.\n  // If there are conflicts, we want to disable the \"Save\" button.\n\n\n  function onNodeCheckNewName(targetPath, name) {\n    const nextNamePath = [...targetPath];\n    nextNamePath.pop();\n    nextNamePath.push(name);\n    const hasConflicts = !isEqual(targetPath, nextNamePath) && treeFindNodeByNamePath(additionalCellSets, nextNamePath);\n    return hasConflicts;\n  } // The user wants to delete a cell set node, and has confirmed their choice.\n\n\n  function onNodeRemove(targetPath) {\n    // Recursively check whether each node path\n    // matches the path of the node to delete.\n    // If so, return null, and then always use\n    // .filter(Boolean) to eliminate any null array elements.\n    const nextAdditionalCellSets = { ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => filterNode(lzn, [], targetPath)).filter(Boolean)\n    }; // Delete state for all paths that have this node\n    // path as a prefix (i.e. delete all descendents).\n\n    const nextCellSetColor = cellSetColor.filter(d => !isEqualOrPrefix(targetPath, d.path));\n    const nextCellSetSelection = cellSetSelection.filter(d => !isEqualOrPrefix(targetPath, d));\n    const nextCellSetExpansion = cellSetExpansion.filter(d => !isEqualOrPrefix(targetPath, d));\n    setAdditionalCellSets(nextAdditionalCellSets);\n    setCellSetColor(nextCellSetColor);\n    setCellSetSelection(nextCellSetSelection);\n    setCellSetExpansion(nextCellSetExpansion);\n  } // The user wants to view (i.e. select) a particular node,\n  // or its expanded descendents.\n\n\n  function onNodeView(targetPath) {\n    // If parent node is clicked, and if it is expanded,\n    // then select the expanded descendent nodes.\n    const setsToView = []; // Recursively determine which descendent nodes are currently expanded.\n\n    function viewNode(node, nodePath) {\n      if (cellSetExpansion.find(expandedPath => isEqual(nodePath, expandedPath))) {\n        if (node.children) {\n          node.children.forEach(c => {\n            viewNode(c, [...nodePath, c.name]);\n          });\n        } else {\n          setsToView.push(nodePath);\n        }\n      } else {\n        setsToView.push(nodePath);\n      }\n    }\n\n    const targetNode = treeFindNodeByNamePath(mergedCellSets, targetPath);\n    viewNode(targetNode, targetPath);\n    setCellSetSelection(setsToView);\n    setCellSetColorEncoding();\n  } // The user wants to create a new level zero node.\n\n\n  function onCreateLevelZeroNode() {\n    const nextName = getNextNumberedNodeName(additionalCellSets === null || additionalCellSets === void 0 ? void 0 : additionalCellSets.tree, 'My hierarchy ');\n    setAdditionalCellSets({ ...(additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)),\n      tree: [...(additionalCellSets ? additionalCellSets.tree : []), {\n        name: nextName,\n        children: []\n      }]\n    });\n  } // The user wants to create a new node corresponding to\n  // the union of the selected sets.\n\n\n  function onUnion() {\n    const newSet = treeToUnion(mergedCellSets, cellSetSelection);\n    setCellSelection(newSet, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding, 'Union ');\n  } // The user wants to create a new node corresponding to\n  // the intersection of the selected sets.\n\n\n  function onIntersection() {\n    const newSet = treeToIntersection(mergedCellSets, cellSetSelection);\n    setCellSelection(newSet, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding, 'Intersection ');\n  } // The user wants to create a new node corresponding to\n  // the complement of the selected sets.\n\n\n  function onComplement() {\n    const newSet = treeToComplement(mergedCellSets, cellSetSelection, allCellIds);\n    setCellSelection(newSet, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding, 'Complement ');\n  } // The user wants to import a cell set hierarchy,\n  // probably from a CSV or JSON file.\n\n\n  function onImportTree(treeToImport) {\n    // Check for any naming conflicts with the current sets\n    // (both user-defined and dataset-defined) before importing.\n    const hasConflict = treesConflict(mergedCellSets, treeToImport);\n\n    if (!hasConflict) {\n      setAdditionalCellSets({ ...(additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)),\n        tree: [...(additionalCellSets ? additionalCellSets.tree : []), ...treeToImport.tree]\n      }); // Automatically initialize set colors for the imported sets.\n\n      const importAutoSetColors = initializeCellSetColor(treeToImport, cellSetColor);\n      setCellSetColor([...cellSetColor, ...importAutoSetColors]);\n    }\n  } // The user wants to download a particular hierarchy to a JSON file.\n\n\n  function onExportLevelZeroNodeJSON(nodePath) {\n    const {\n      treeToExport,\n      nodeName\n    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);\n    downloadForUser(handleExportJSON(treeToExport), `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_JSON}`);\n  } // The user wants to download a particular hierarchy to a CSV file.\n\n\n  function onExportLevelZeroNodeTabular(nodePath) {\n    const {\n      treeToExport,\n      nodeName\n    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);\n    downloadForUser(handleExportTabular(treeToExport), `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_TABULAR}`);\n  } // The user wants to download a particular set to a JSON file.\n\n\n  function onExportSetJSON(nodePath) {\n    const {\n      setToExport,\n      nodeName\n    } = treeExportSet(mergedCellSets, nodePath);\n    downloadForUser(handleExportJSON(setToExport), `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-set.${FILE_EXTENSION_JSON}`, FILE_EXTENSION_JSON);\n  }\n\n  return /*#__PURE__*/React.createElement(TitleInfo, {\n    title: title,\n    isScroll: true,\n    removeGridComponent: removeGridComponent,\n    urls: urls,\n    theme: theme,\n    isReady: isReady,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 586,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(SetsManager, {\n    setColor: cellSetColor,\n    sets: cellSets,\n    additionalSets: additionalCellSets,\n    levelSelection: checkedLevel,\n    setSelection: cellSetSelection,\n    setExpansion: cellSetExpansion,\n    hasColorEncoding: cellColorEncoding === 'cellSetSelection',\n    draggable: true,\n    datatype: SETS_DATATYPE_CELL,\n    onError: setWarning,\n    onCheckNode: onCheckNode,\n    onExpandNode: onExpandNode,\n    onDropNode: onDropNode,\n    onCheckLevel: onCheckLevel,\n    onNodeSetColor: onNodeSetColor,\n    onNodeSetName: onNodeSetName,\n    onNodeCheckNewName: onNodeCheckNewName,\n    onNodeRemove: onNodeRemove,\n    onNodeView: onNodeView,\n    onImportTree: onImportTree,\n    onCreateLevelZeroNode: onCreateLevelZeroNode,\n    onExportLevelZeroNodeJSON: onExportLevelZeroNodeJSON,\n    onExportLevelZeroNodeTabular: onExportLevelZeroNodeTabular,\n    onExportSetJSON: onExportSetJSON,\n    onUnion: onUnion,\n    onIntersection: onIntersection,\n    onComplement: onComplement,\n    hasCheckedSetsToUnion: (cellSetSelection === null || cellSetSelection === void 0 ? void 0 : cellSetSelection.length) > 1,\n    hasCheckedSetsToIntersect: (cellSetSelection === null || cellSetSelection === void 0 ? void 0 : cellSetSelection.length) > 1,\n    hasCheckedSetsToComplement: (cellSetSelection === null || cellSetSelection === void 0 ? void 0 : cellSetSelection.length) > 0,\n    theme: theme,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 594,\n      columnNumber: 7\n    }\n  }));\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/CellSetsManagerSubscriber.js"],"names":["React","useEffect","useState","useMemo","isEqual","packageJson","useCoordination","useLoaders","useSetWarning","COMPONENT_COORDINATION_TYPES","SetsManager","TitleInfo","treeExportLevelZeroNode","treeExportSet","treeToExpectedCheckedLevel","nodeToLevelDescendantNamePaths","treeToIntersection","treeToUnion","treeToComplement","treeFindNodeByNamePath","treesConflict","nodeTransform","nodeAppendChild","nodePrependChild","nodeInsertChild","filterNode","treeInitialize","initializeCellSetColor","isEqualOrPrefix","tryRenamePath","PATH_SEP","downloadForUser","handleExportJSON","handleExportTabular","tryUpgradeTreeToLatestSchema","FILE_EXTENSION_JSON","FILE_EXTENSION_TABULAR","SETS_DATATYPE_CELL","useUrls","useReady","setCellSelection","mergeCellSets","getNextNumberedNodeName","useCellsData","useCellSetsData","CELL_SETS_DATA_TYPES","CellSetsManagerSubscriber","props","coordinationScopes","removeGridComponent","theme","title","loaders","setWarning","dataset","obsSetSelection","cellSetSelection","obsSetColor","cellSetColor","additionalObsSets","additionalCellSets","obsColorEncoding","cellColorEncoding","setObsSetSelection","setCellSetSelection","setObsColorEncoding","setCellColorEncoding","setObsSetColor","setCellSetColor","setAdditionalObsSets","setAdditionalCellSets","cellSets","urls","addUrl","resetUrls","isReady","setItemIsReady","setItemIsNotReady","resetReadyItems","cellSetExpansion","setCellSetExpansion","cells","upgradedCellSets","e","message","allCellIds","Object","keys","setCellSetColorEncoding","mergedCellSets","checkedLevel","length","tree","onCheckLevel","levelZeroName","levelIndex","lzn","find","n","name","newCellSetSelection","onCheckNode","targetKey","checked","targetPath","Array","isArray","split","filter","d","onExpandNode","expandedKeys","expanded","prev","onDropNode","dropKey","dragKey","dropPosition","dropToGap","dropPath","dropNode","children","dropNodeLevel","dropNodeIsLevelZero","dragPath","dragNode","dropParentNode","dropParentPath","dropNodeCurrIndex","slice","findIndex","c","hasSiblingNameConflict","dragNodeName","nextAdditionalCellSets","map","Boolean","newDragPath","addChildFunction","checkPathFunction","newPath","path","insertIndex","node","newNode","unshift","newLevelZero","from","splice","oldColors","i","newColors","concat","newCellSetColor","push","onNodeSetColor","color","prevNodeColor","onNodeSetName","nextNamePath","pop","renameNode","prevPath","nextCellSetColor","nextCellSetSelection","nextCellSetExpansion","onNodeCheckNewName","hasConflicts","onNodeRemove","onNodeView","setsToView","viewNode","nodePath","expandedPath","forEach","targetNode","onCreateLevelZeroNode","nextName","onUnion","newSet","onIntersection","onComplement","onImportTree","treeToImport","hasConflict","importAutoSetColors","onExportLevelZeroNodeJSON","treeToExport","nodeName","onExportLevelZeroNodeTabular","onExportSetJSON","setToExport"],"mappings":"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","sourcesContent":["import React, {\n  useEffect,\n  useState,\n  useMemo,\n} from 'react';\nimport isEqual from 'lodash/isEqual';\nimport packageJson from '../../../package.json';\nimport {\n  useCoordination,\n  useLoaders,\n  useSetWarning,\n} from '../../app/state/hooks';\nimport { COMPONENT_COORDINATION_TYPES } from '../../app/state/coordination';\nimport SetsManager from './SetsManager';\nimport TitleInfo from '../TitleInfo';\nimport {\n  treeExportLevelZeroNode,\n  treeExportSet,\n  treeToExpectedCheckedLevel,\n  nodeToLevelDescendantNamePaths,\n  treeToIntersection,\n  treeToUnion,\n  treeToComplement,\n  treeFindNodeByNamePath,\n  treesConflict,\n  nodeTransform,\n  nodeAppendChild,\n  nodePrependChild,\n  nodeInsertChild,\n  filterNode,\n  treeInitialize,\n  initializeCellSetColor,\n} from './cell-set-utils';\nimport {\n  isEqualOrPrefix,\n  tryRenamePath,\n  PATH_SEP,\n} from './utils';\nimport {\n  downloadForUser,\n  handleExportJSON,\n  handleExportTabular,\n  tryUpgradeTreeToLatestSchema,\n} from './io';\nimport {\n  FILE_EXTENSION_JSON,\n  FILE_EXTENSION_TABULAR,\n  SETS_DATATYPE_CELL,\n} from './constants';\nimport { useUrls, useReady } from '../hooks';\nimport {\n  setCellSelection,\n  mergeCellSets,\n  getNextNumberedNodeName,\n} from '../utils';\nimport { useCellsData, useCellSetsData } from '../data-hooks';\n\nconst CELL_SETS_DATA_TYPES = ['cells', 'cell-sets'];\n\n/**\n * A subscriber wrapper around the SetsManager component\n * for the 'cell' datatype.\n * @param {object} props\n * @param {string} props.theme The current theme name.\n * @param {object} props.coordinationScopes The mapping from coordination types to coordination\n * scopes.\n * @param {function} props.removeGridComponent The callback function to pass to TitleInfo,\n * to call when the component has been removed from the grid.\n * @param {string} props.title The component title.\n */\nexport default function CellSetsManagerSubscriber(props) {\n  const {\n    coordinationScopes,\n    removeGridComponent,\n    theme,\n    title = 'Cell Sets',\n  } = props;\n\n  const loaders = useLoaders();\n  const setWarning = useSetWarning();\n\n  // Get \"props\" from the coordination space.\n  const [{\n    dataset,\n    obsSetSelection: cellSetSelection,\n    obsSetColor: cellSetColor,\n    additionalObsSets: additionalCellSets,\n    obsColorEncoding: cellColorEncoding,\n  }, {\n    setObsSetSelection: setCellSetSelection,\n    setObsColorEncoding: setCellColorEncoding,\n    setObsSetColor: setCellSetColor,\n    setAdditionalObsSets: setAdditionalCellSets,\n  }] = useCoordination(COMPONENT_COORDINATION_TYPES.cellSets, coordinationScopes);\n\n  const [urls, addUrl, resetUrls] = useUrls();\n  const [\n    isReady,\n    setItemIsReady,\n    setItemIsNotReady, // eslint-disable-line no-unused-vars\n    resetReadyItems,\n  ] = useReady(\n    CELL_SETS_DATA_TYPES,\n  );\n\n  const [cellSetExpansion, setCellSetExpansion] = useState([]);\n\n  // Reset file URLs and loader progress when the dataset has changed.\n  useEffect(() => {\n    resetUrls();\n    resetReadyItems();\n    setCellSetExpansion([]);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [loaders, dataset]);\n\n  // Get data from loaders using the data hooks.\n  const [cells] = useCellsData(loaders, dataset, setItemIsReady, addUrl, true);\n  const [cellSets] = useCellSetsData(\n    loaders, dataset, setItemIsReady, addUrl, false,\n    { setObsSetSelection: setCellSetSelection, setObsSetColor: setCellSetColor },\n    { obsSetSelection: cellSetSelection, obsSetColor: cellSetColor },\n  );\n\n  // Validate and upgrade the additionalCellSets.\n  useEffect(() => {\n    if (additionalCellSets) {\n      let upgradedCellSets;\n      try {\n        upgradedCellSets = tryUpgradeTreeToLatestSchema(additionalCellSets, SETS_DATATYPE_CELL);\n      } catch (e) {\n        setWarning(e.message);\n        return;\n      }\n      setAdditionalCellSets(upgradedCellSets);\n    }\n  }, [additionalCellSets, setAdditionalCellSets, setWarning]);\n\n  // Get an array of all cell IDs to use for set complement operations.\n  const allCellIds = useMemo(() => (cells ? Object.keys(cells) : []), [cells]);\n\n  // A helper function for updating the encoding for cell colors,\n  // which may have previously been set to 'geneSelection'.\n  function setCellSetColorEncoding() {\n    setCellColorEncoding('cellSetSelection');\n  }\n\n  // Merged cell sets are only to be used for convenience when reading\n  // (if writing: update either `cellSets` _or_ `additionalCellSets`).\n  const mergedCellSets = useMemo(\n    () => mergeCellSets(cellSets, additionalCellSets),\n    [cellSets, additionalCellSets],\n  );\n\n  // Infer the state of the \"checked level\" radio button based on the selected cell sets.\n  const checkedLevel = useMemo(() => {\n    if (cellSetSelection && cellSetSelection.length > 0\n    && mergedCellSets && mergedCellSets.tree.length > 0) {\n      return treeToExpectedCheckedLevel(mergedCellSets, cellSetSelection);\n    }\n    return null;\n  }, [cellSetSelection, mergedCellSets]);\n\n  // Callback functions\n\n  // The user wants to select all nodes at a particular hierarchy level.\n  function onCheckLevel(levelZeroName, levelIndex) {\n    const lzn = mergedCellSets.tree.find(n => n.name === levelZeroName);\n    if (lzn) {\n      const newCellSetSelection = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);\n      setCellSetSelection(newCellSetSelection);\n      setCellSetColorEncoding();\n    }\n  }\n\n  // The user wants to check or uncheck a cell set node.\n  function onCheckNode(targetKey, checked) {\n    const targetPath = (Array.isArray(targetKey) ? targetKey : targetKey.split(PATH_SEP));\n    if (!targetKey) {\n      return;\n    }\n    if (checked) {\n      setCellSetSelection([...cellSetSelection, targetPath]);\n    } else {\n      setCellSetSelection(cellSetSelection.filter(d => !isEqual(d, targetPath)));\n    }\n    setCellSetColorEncoding();\n  }\n\n  // The user wants to expand or collapse a node in the tree.\n  function onExpandNode(expandedKeys, targetKey, expanded) {\n    if (expanded) {\n      setCellSetExpansion(prev => ([...prev, targetKey.split(PATH_SEP)]));\n    } else {\n      setCellSetExpansion(prev => prev.filter(d => !isEqual(d, targetKey.split(PATH_SEP))));\n    }\n  }\n\n  // The user dragged a tree node and dropped it somewhere else in the tree\n  // to re-arrange or re-order the nodes.\n  // We need to verify that their drop target is valid, and if so, complete\n  // the tree re-arrangement.\n  function onDropNode(dropKey, dragKey, dropPosition, dropToGap) {\n    const dropPath = dropKey.split(PATH_SEP);\n    const dropNode = treeFindNodeByNamePath(additionalCellSets, dropPath);\n    if (!dropNode.children && !dropToGap) {\n      // Do not allow a node with a set (i.e. leaf) to become a child of another node with a set,\n      // as this will result in an internal node having a set, which we do not allow.\n      return;\n    }\n    const dropNodeLevel = dropPath.length - 1;\n    const dropNodeIsLevelZero = dropNodeLevel === 0;\n\n    // Get drag node.\n    const dragPath = dragKey.split(PATH_SEP);\n    const dragNode = treeFindNodeByNamePath(additionalCellSets, dragPath);\n\n    if (dropNodeIsLevelZero && dropToGap && !dragNode.children) {\n      // Do not allow a leaf node to become a level zero node.\n      return;\n    }\n\n    let dropParentNode;\n    let dropParentPath;\n    let dropNodeCurrIndex;\n    if (!dropNodeIsLevelZero) {\n      dropParentPath = dropPath.slice(0, -1);\n      dropParentNode = treeFindNodeByNamePath(additionalCellSets, dropParentPath);\n      dropNodeCurrIndex = dropParentNode.children.findIndex(c => c.name === dropNode.name);\n    } else {\n      dropNodeCurrIndex = additionalCellSets.tree.findIndex(\n        lzn => lzn.name === dropNode.name,\n      );\n    }\n    // Further, only allow dragging if the dragged node will have a unique\n    // name among its new siblings.\n    let hasSiblingNameConflict;\n    const dragNodeName = dragNode.name;\n    if (!dropNodeIsLevelZero && dropToGap) {\n      hasSiblingNameConflict = dropParentNode.children\n        .find(c => c !== dragNode && c.name === dragNodeName);\n    } else if (!dropToGap) {\n      hasSiblingNameConflict = dropNode.children\n        .find(c => c !== dragNode && c.name === dragNodeName);\n    } else {\n      hasSiblingNameConflict = additionalCellSets.tree\n        .find(lzn => lzn !== dragNode && lzn.name === dragNodeName);\n    }\n\n    if (hasSiblingNameConflict) {\n      return;\n    }\n\n    // Remove the dragged object from its current position.\n    // Recursively check whether each node path\n    // matches the path of the node to delete.\n    // If so, return null, and then always use\n    // .filter(Boolean) to eliminate any null array elements.\n    const nextAdditionalCellSets = {\n      ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => filterNode(lzn, [], dragPath)).filter(Boolean),\n    };\n\n    // Update index values after temporarily removing the dragged node.\n    // Names are unique as children of their parents.\n    if (!dropNodeIsLevelZero) {\n      dropNodeCurrIndex = dropParentNode.children.findIndex(c => c.name === dropNode.name);\n    } else {\n      dropNodeCurrIndex = nextAdditionalCellSets.tree.findIndex(\n        lzn => lzn.name === dropNode.name,\n      );\n    }\n    let newDragPath = [];\n    if (!dropToGap || !dropNodeIsLevelZero) {\n      let addChildFunction;\n      let checkPathFunction;\n      const newPath = [];\n      if (!dropToGap) {\n        // Append the dragNode to dropNode's children if dropping _onto_ the dropNode.\n        // Set dragNode as the last child of dropNode.\n        addChildFunction = n => nodeAppendChild(n, dragNode);\n        checkPathFunction = path => isEqual(path, dropPath);\n      } else if (!dropNodeIsLevelZero) {\n        // Prepend or insert the dragNode if dropping _between_ (above or below dropNode).\n        // The dropNode is at a level greater than zero,\n        // so it has a parent.\n        checkPathFunction = path => isEqual(path, dropParentPath);\n        if (dropPosition === -1) {\n          // Set dragNode as first child of dropParentNode.\n          addChildFunction = n => nodePrependChild(n, dragNode);\n        } else {\n          // Set dragNode before or after dropNode.\n          const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);\n          addChildFunction = n => nodeInsertChild(n, dragNode, insertIndex);\n        }\n      }\n      nextAdditionalCellSets.tree = nextAdditionalCellSets.tree.map(\n        node => nodeTransform(\n          node,\n          (n, path) => checkPathFunction(path),\n          (n) => {\n            const newNode = addChildFunction(n);\n            return newNode;\n          },\n          newPath,\n        ),\n      );\n      // Done\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [...newPath[0], dragNode.name];\n      setCellSetSelection([newDragPath]);\n    } else if (dropPosition === -1) {\n      // We need to drop the dragNode to level zero,\n      // and level zero nodes do not have parents.\n      // Set dragNode as first level zero node of the tree.\n      nextAdditionalCellSets.tree.unshift(dragNode);\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [dragNode.name];\n      setCellSetSelection([newDragPath]);\n    } else {\n      // Set dragNode before or after dropNode in level zero.\n      const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);\n      const newLevelZero = Array.from(nextAdditionalCellSets.tree);\n      newLevelZero.splice(insertIndex, 0, dragNode);\n      nextAdditionalCellSets.tree = newLevelZero;\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [dragNode.name];\n      setCellSetSelection([newDragPath]);\n    }\n    const oldColors = cellSetColor.filter(\n      i => isEqualOrPrefix(dragPath, i.path),\n    );\n    const newColors = oldColors.map(\n      i => (\n        {\n          ...i,\n          path: !isEqual(i.path, dragPath)\n            ? newDragPath.concat(i.path.slice(dragPath.length))\n            : newDragPath,\n        }\n      ),\n    );\n    const newCellSetColor = cellSetColor.filter(\n      i => !isEqualOrPrefix(dragPath, i.path),\n    );\n    newCellSetColor.push(...newColors);\n    setCellSetColor(newCellSetColor);\n  }\n\n  // The user wants to change the color of a cell set node.\n  function onNodeSetColor(targetPath, color) {\n    // Replace the color if an array element for this path already exists.\n    const prevNodeColor = cellSetColor?.find(d => isEqual(d.path, targetPath));\n    if (!prevNodeColor) {\n      setCellSetColor([\n        ...(cellSetColor || []),\n        {\n          path: targetPath,\n          color,\n        },\n      ]);\n    } else {\n      setCellSetColor([\n        ...cellSetColor.filter(d => !isEqual(d.path, targetPath)),\n        {\n          path: targetPath,\n          color,\n        },\n      ]);\n    }\n  }\n\n  // The user wants to change the name of a cell set node.\n  function onNodeSetName(targetPath, name) {\n    const nextNamePath = [...targetPath];\n    nextNamePath.pop();\n    nextNamePath.push(name);\n\n    // Recursively check whether each node path\n    // matches the path or a prefix of the path of the node to rename.\n    // If so, rename the node using the new path.\n    function renameNode(node, prevPath) {\n      if (isEqual([...prevPath, node.name], targetPath)) {\n        return {\n          ...node,\n          name,\n        };\n      }\n      if (!node.children) {\n        return node;\n      }\n      return {\n        ...node,\n        children: node.children.map(c => renameNode(c, [...prevPath, node.name])),\n      };\n    }\n    const nextAdditionalCellSets = {\n      ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => renameNode(lzn, [])),\n    };\n    // Change all paths that have this node as a prefix (i.e. descendants).\n    const nextCellSetColor = cellSetColor.map(d => ({\n      path: tryRenamePath(targetPath, d.path, nextNamePath),\n      color: d.color,\n    }));\n    const nextCellSetSelection = cellSetSelection.map(d => (\n      tryRenamePath(targetPath, d, nextNamePath)\n    ));\n    const nextCellSetExpansion = cellSetExpansion.map(d => (\n      tryRenamePath(targetPath, d, nextNamePath)\n    ));\n    // Need to update the node path everywhere it may be present.\n    setAdditionalCellSets(nextAdditionalCellSets);\n    setCellSetColor(nextCellSetColor);\n    setCellSetSelection(nextCellSetSelection);\n    setCellSetExpansion(nextCellSetExpansion);\n  }\n\n  // Each time the user types while renaming a cell set node,\n  // we need to check whether the potential new name conflicts\n  // with any existing cell set node names.\n  // If there are conflicts, we want to disable the \"Save\" button.\n  function onNodeCheckNewName(targetPath, name) {\n    const nextNamePath = [...targetPath];\n    nextNamePath.pop();\n    nextNamePath.push(name);\n    const hasConflicts = (\n      !isEqual(targetPath, nextNamePath)\n      && treeFindNodeByNamePath(additionalCellSets, nextNamePath)\n    );\n    return hasConflicts;\n  }\n\n  // The user wants to delete a cell set node, and has confirmed their choice.\n  function onNodeRemove(targetPath) {\n    // Recursively check whether each node path\n    // matches the path of the node to delete.\n    // If so, return null, and then always use\n    // .filter(Boolean) to eliminate any null array elements.\n    const nextAdditionalCellSets = {\n      ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => filterNode(lzn, [], targetPath)).filter(Boolean),\n    };\n    // Delete state for all paths that have this node\n    // path as a prefix (i.e. delete all descendents).\n    const nextCellSetColor = cellSetColor.filter(d => !isEqualOrPrefix(targetPath, d.path));\n    const nextCellSetSelection = cellSetSelection.filter(d => !isEqualOrPrefix(targetPath, d));\n    const nextCellSetExpansion = cellSetExpansion.filter(d => !isEqualOrPrefix(targetPath, d));\n    setAdditionalCellSets(nextAdditionalCellSets);\n    setCellSetColor(nextCellSetColor);\n    setCellSetSelection(nextCellSetSelection);\n    setCellSetExpansion(nextCellSetExpansion);\n  }\n\n  // The user wants to view (i.e. select) a particular node,\n  // or its expanded descendents.\n  function onNodeView(targetPath) {\n    // If parent node is clicked, and if it is expanded,\n    // then select the expanded descendent nodes.\n    const setsToView = [];\n    // Recursively determine which descendent nodes are currently expanded.\n    function viewNode(node, nodePath) {\n      if (cellSetExpansion.find(expandedPath => isEqual(nodePath, expandedPath))) {\n        if (node.children) {\n          node.children.forEach((c) => {\n            viewNode(c, [...nodePath, c.name]);\n          });\n        } else {\n          setsToView.push(nodePath);\n        }\n      } else {\n        setsToView.push(nodePath);\n      }\n    }\n    const targetNode = treeFindNodeByNamePath(mergedCellSets, targetPath);\n    viewNode(targetNode, targetPath);\n    setCellSetSelection(setsToView);\n    setCellSetColorEncoding();\n  }\n\n  // The user wants to create a new level zero node.\n  function onCreateLevelZeroNode() {\n    const nextName = getNextNumberedNodeName(additionalCellSets?.tree, 'My hierarchy ');\n    setAdditionalCellSets({\n      ...(additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)),\n      tree: [\n        ...(additionalCellSets ? additionalCellSets.tree : []),\n        {\n          name: nextName,\n          children: [],\n        },\n      ],\n    });\n  }\n\n  // The user wants to create a new node corresponding to\n  // the union of the selected sets.\n  function onUnion() {\n    const newSet = treeToUnion(mergedCellSets, cellSetSelection);\n    setCellSelection(\n      newSet, additionalCellSets, cellSetColor,\n      setCellSetSelection, setAdditionalCellSets, setCellSetColor,\n      setCellColorEncoding,\n      'Union ',\n    );\n  }\n\n  // The user wants to create a new node corresponding to\n  // the intersection of the selected sets.\n  function onIntersection() {\n    const newSet = treeToIntersection(mergedCellSets, cellSetSelection);\n    setCellSelection(\n      newSet, additionalCellSets, cellSetColor,\n      setCellSetSelection, setAdditionalCellSets, setCellSetColor,\n      setCellColorEncoding,\n      'Intersection ',\n    );\n  }\n\n  // The user wants to create a new node corresponding to\n  // the complement of the selected sets.\n  function onComplement() {\n    const newSet = treeToComplement(mergedCellSets, cellSetSelection, allCellIds);\n    setCellSelection(\n      newSet, additionalCellSets, cellSetColor,\n      setCellSetSelection, setAdditionalCellSets, setCellSetColor,\n      setCellColorEncoding,\n      'Complement ',\n    );\n  }\n\n  // The user wants to import a cell set hierarchy,\n  // probably from a CSV or JSON file.\n  function onImportTree(treeToImport) {\n    // Check for any naming conflicts with the current sets\n    // (both user-defined and dataset-defined) before importing.\n    const hasConflict = treesConflict(mergedCellSets, treeToImport);\n    if (!hasConflict) {\n      setAdditionalCellSets({\n        ...(additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)),\n        tree: [\n          ...(additionalCellSets ? additionalCellSets.tree : []),\n          ...treeToImport.tree,\n        ],\n      });\n      // Automatically initialize set colors for the imported sets.\n      const importAutoSetColors = initializeCellSetColor(treeToImport, cellSetColor);\n      setCellSetColor([\n        ...cellSetColor,\n        ...importAutoSetColors,\n      ]);\n    }\n  }\n\n  // The user wants to download a particular hierarchy to a JSON file.\n  function onExportLevelZeroNodeJSON(nodePath) {\n    const {\n      treeToExport, nodeName,\n    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);\n    downloadForUser(\n      handleExportJSON(treeToExport),\n      `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_JSON}`,\n    );\n  }\n\n  // The user wants to download a particular hierarchy to a CSV file.\n  function onExportLevelZeroNodeTabular(nodePath) {\n    const {\n      treeToExport, nodeName,\n    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);\n    downloadForUser(\n      handleExportTabular(treeToExport),\n      `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_TABULAR}`,\n    );\n  }\n\n  // The user wants to download a particular set to a JSON file.\n  function onExportSetJSON(nodePath) {\n    const { setToExport, nodeName } = treeExportSet(mergedCellSets, nodePath);\n    downloadForUser(\n      handleExportJSON(setToExport),\n      `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-set.${FILE_EXTENSION_JSON}`,\n      FILE_EXTENSION_JSON,\n    );\n  }\n  return (\n    <TitleInfo\n      title={title}\n      isScroll\n      removeGridComponent={removeGridComponent}\n      urls={urls}\n      theme={theme}\n      isReady={isReady}\n    >\n      <SetsManager\n        setColor={cellSetColor}\n        sets={cellSets}\n        additionalSets={additionalCellSets}\n        levelSelection={checkedLevel}\n        setSelection={cellSetSelection}\n        setExpansion={cellSetExpansion}\n        hasColorEncoding={cellColorEncoding === 'cellSetSelection'}\n        draggable\n        datatype={SETS_DATATYPE_CELL}\n        onError={setWarning}\n        onCheckNode={onCheckNode}\n        onExpandNode={onExpandNode}\n        onDropNode={onDropNode}\n        onCheckLevel={onCheckLevel}\n        onNodeSetColor={onNodeSetColor}\n        onNodeSetName={onNodeSetName}\n        onNodeCheckNewName={onNodeCheckNewName}\n        onNodeRemove={onNodeRemove}\n        onNodeView={onNodeView}\n        onImportTree={onImportTree}\n        onCreateLevelZeroNode={onCreateLevelZeroNode}\n        onExportLevelZeroNodeJSON={onExportLevelZeroNodeJSON}\n        onExportLevelZeroNodeTabular={onExportLevelZeroNodeTabular}\n        onExportSetJSON={onExportSetJSON}\n        onUnion={onUnion}\n        onIntersection={onIntersection}\n        onComplement={onComplement}\n        hasCheckedSetsToUnion={cellSetSelection?.length > 1}\n        hasCheckedSetsToIntersect={cellSetSelection?.length > 1}\n        hasCheckedSetsToComplement={cellSetSelection?.length > 0}\n        theme={theme}\n      />\n    </TitleInfo>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}