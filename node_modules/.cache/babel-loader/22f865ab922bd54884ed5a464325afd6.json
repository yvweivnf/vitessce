{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX, SHARED_DOMAIN_OP_INDEX } from '../../aggregate';\nimport { isBinning, isBinParams, isParameterExtent } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, getFieldOrDatumDef, hasBandEnd, isDatumDef, isFieldDef, valueExpr, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isDomainUnionWith, isParameterDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model) {\n  var localScaleComponents = model.component.scales;\n\n  var _iterator = _createForOfIteratorHelper(util.keys(localScaleComponents)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      var domains = parseDomainForChannel(model, channel);\n      var localScaleCmpt = localScaleComponents[channel];\n      localScaleCmpt.setWithExplicit('domains', domains);\n      parseSelectionDomain(model, channel);\n\n      if (model.component.data.isFaceted) {\n        // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n        var facetParent = model;\n\n        while (!isFacetModel(facetParent) && facetParent.parent) {\n          facetParent = facetParent.parent;\n        }\n\n        var resolve = facetParent.component.resolve.scale[channel];\n\n        if (resolve === 'shared') {\n          var _iterator2 = _createForOfIteratorHelper(domains.value),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var domain = _step2.value;\n\n              // Replace the scale domain with data output from a cloned subtree after the facet.\n              if (isDataRefDomain(domain)) {\n                // use data from cloned subtree (which is the same as data but with a prefix added once)\n                domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction parseNonUnitScaleDomain(model) {\n  var _iterator3 = _createForOfIteratorHelper(model.children),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var child = _step3.value;\n      parseScaleDomain(child);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var localScaleComponents = model.component.scales;\n\n  var _iterator4 = _createForOfIteratorHelper(util.keys(localScaleComponents)),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var channel = _step4.value;\n      var domains = void 0;\n      var selectionExtent = null;\n\n      var _iterator5 = _createForOfIteratorHelper(model.children),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _child = _step5.value;\n          var childComponent = _child.component.scales[channel];\n\n          if (childComponent) {\n            if (domains === undefined) {\n              domains = childComponent.getWithExplicit('domains');\n            } else {\n              domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n            }\n\n            var se = childComponent.get('selectionExtent');\n\n            if (selectionExtent && se && selectionExtent.param !== se.param) {\n              log.warn(log.message.NEEDS_SAME_SELECTION);\n            }\n\n            selectionExtent = se;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      localScaleComponents[channel].setWithExplicit('domains', domains);\n\n      if (selectionExtent) {\n        localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\n\n\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n  if (domain === 'unaggregated') {\n    var _canUseUnaggregatedDo = canUseUnaggregatedDomain(fieldDef, scaleType),\n        valid = _canUseUnaggregatedDo.valid,\n        reason = _canUseUnaggregatedDo.reason;\n\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    var _canUseUnaggregatedDo2 = canUseUnaggregatedDomain(fieldDef, scaleType),\n        _valid = _canUseUnaggregatedDo2.valid;\n\n    if (_valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model, channel) {\n  var scaleType = model.getScaleComponent(channel).get('type');\n  var encoding = model.encoding;\n  var domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType, model.config.scale);\n\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), {\n      domain: domain\n    });\n  } // If channel is either X or Y then union them with X2 & Y2 if they exist\n\n\n  if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n    if (getFieldOrDatumDef(encoding.x)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n    if (getFieldOrDatumDef(encoding.y)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n  return domain.map(function (v) {\n    var data = valueExpr(v, {\n      timeUnit: timeUnit,\n      type: type\n    });\n    return {\n      signal: \"{data: \".concat(data, \"}\")\n    };\n  });\n}\n\nfunction convertDomainIfItIsDateTime(domain, type, timeUnit) {\n  var _a; // explicit value\n\n\n  var normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n\n  if (type === 'temporal' || normalizedTimeUnit) {\n    return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n  }\n\n  return [domain]; // Date time won't make sense\n}\n\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n  var encoding = model.encoding;\n  var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  var type = fieldOrDatumDef.type;\n  var timeUnit = fieldOrDatumDef['timeUnit'];\n\n  if (isDomainUnionWith(domain)) {\n    var defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n    var unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n    return makeExplicit([].concat(_toConsumableArray(defaultDomain.value), _toConsumableArray(unionWith)));\n  } else if (isSignalRef(domain)) {\n    return makeExplicit([domain]);\n  } else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n    return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n  }\n\n  var stack = model.stack;\n\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    var data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([{\n      data: data,\n      field: model.vgField(channel, {\n        suffix: 'start'\n      })\n    }, {\n      data: data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  }\n\n  var sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (isDatumDef(fieldOrDatumDef)) {\n    var d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n    return makeImplicit(d);\n  }\n\n  var fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n\n  if (domain === 'unaggregated') {\n    var _data = model.requestDataName(DataSourceType.Main);\n\n    var field = fieldOrDatumDef.field;\n    return makeImplicit([{\n      data: _data,\n      field: vgField({\n        field: field,\n        aggregate: 'min'\n      })\n    }, {\n      data: _data,\n      field: vgField({\n        field: field,\n        aggregate: 'max'\n      })\n    }]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      } // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n\n\n      return makeImplicit([{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {\n          binSuffix: 'range'\n        } : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isObject(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n\n        } : sort\n      }]);\n    } else {\n      // continuous scales\n      var bin = fieldDef.bin;\n\n      if (isBinning(bin)) {\n        var binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([new SignalRefWrapper(function () {\n          var signal = model.getSignalName(binSignal);\n          return \"[\".concat(signal, \".start, \").concat(signal, \".stop]\");\n        })]);\n      } else {\n        return makeImplicit([{\n          data: model.requestDataName(DataSourceType.Main),\n          field: model.vgField(channel, {})\n        }]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType) && hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n    var _data2 = model.requestDataName(DataSourceType.Main);\n\n    return makeImplicit([{\n      data: _data2,\n      field: model.vgField(channel)\n    }, {\n      data: _data2,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  } else if (sort) {\n    return makeImplicit([{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n      field: model.vgField(channel),\n      sort: sort\n    }]);\n  } else {\n    return makeImplicit([{\n      data: model.requestDataName(DataSourceType.Main),\n      field: model.vgField(channel)\n    }]);\n  }\n}\n\nfunction normalizeSortField(sort, isStackedMeasure) {\n  var op = sort.op,\n      field = sort.field,\n      order = sort.order;\n  return Object.assign(Object.assign({\n    // Apply default op\n    op: op !== null && op !== void 0 ? op : isStackedMeasure ? 'sum' : DEFAULT_SORT_OP\n  }, field ? {\n    field: util.replacePathInField(field)\n  } : {}), order ? {\n    order: order\n  } : {});\n}\n\nfunction parseSelectionDomain(model, channel) {\n  var _a;\n\n  var scale = model.component.scales[channel];\n  var spec = model.specifiedScales[channel].domain;\n  var bin = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;\n  var domain = isParameterDomain(spec) && spec;\n  var extent = isBinParams(bin) && isParameterExtent(bin.extent) && bin.extent;\n\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain !== null && domain !== void 0 ? domain : extent, true);\n  }\n}\n\nexport function domainSort(model, channel, scaleType) {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  } // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n\n\n  var fieldDef = model.fieldDef(channel);\n  var sort = fieldDef.sort; // if the sort is specified with array, use the derived sort index field\n\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  var stack = model.stack;\n  var stackDimensions = stack ? [].concat(_toConsumableArray(stack.groupbyField ? [stack.groupbyField] : []), _toConsumableArray(stack.stackBy.map(function (s) {\n    return s.fieldDef.field;\n  }))) : undefined; // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n\n  if (isSortField(sort)) {\n    var isStackedMeasure = stack && !util.contains(stackDimensions, sort.field);\n    return normalizeSortField(sort, isStackedMeasure);\n  } else if (isSortByEncoding(sort)) {\n    var encoding = sort.encoding,\n        order = sort.order;\n    var fieldDefToSortBy = model.fieldDef(encoding);\n    var aggregate = fieldDefToSortBy.aggregate,\n        field = fieldDefToSortBy.field;\n\n    var _isStackedMeasure = stack && !util.contains(stackDimensions, field);\n\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField({\n        field: vgField(fieldDefToSortBy),\n        order: order\n      }, _isStackedMeasure);\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField({\n        op: aggregate,\n        field: field,\n        order: order\n      }, _isStackedMeasure);\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined\n  /* default =ascending*/\n  ], sort)) {\n    return true;\n  } // sort == null\n\n\n  return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\n\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n  var aggregate = fieldDef.aggregate,\n      type = fieldDef.type;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\n\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, concat the domains so that we union them later.\n\n\n  return {\n    explicit: v1.explicit,\n    value: [].concat(_toConsumableArray(v1.value), _toConsumableArray(v2.value))\n  };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\n\n\nexport function mergeDomains(domains) {\n  var uniqueDomains = util.unique(domains.map(function (domain) {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      var _s = domain.sort,\n          domainWithoutSort = __rest(domain, [\"sort\"]);\n\n      return domainWithoutSort;\n    }\n\n    return domain;\n  }), util.hash);\n  var sorts = util.unique(domains.map(function (d) {\n    if (isDataRefDomain(d)) {\n      var s = d.sort;\n\n      if (s !== undefined && !util.isBoolean(s)) {\n        if ('op' in s && s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n\n      return s;\n    }\n\n    return undefined;\n  }).filter(function (s) {\n    return s !== undefined;\n  }), util.hash);\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    var domain = domains[0];\n\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      var _sort = sorts[0];\n\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        _sort = true;\n      } else {\n        // Simplify domain sort by removing field and op when the field is the same as the domain field.\n        if (isObject(_sort) && 'field' in _sort) {\n          var sortField = _sort.field;\n\n          if (domain.field === sortField) {\n            _sort = _sort.order ? {\n              order: _sort.order\n            } : true;\n          }\n        }\n      }\n\n      return Object.assign(Object.assign({}, domain), {\n        sort: _sort\n      });\n    }\n\n    return domain;\n  } // only keep sort properties that work with unioned domains\n\n\n  var unionDomainSorts = util.unique(sorts.map(function (s) {\n    if (util.isBoolean(s) || !('op' in s) || isString(s.op) && s.op in UNIONDOMAIN_SORT_OP_INDEX) {\n      return s;\n    }\n\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash);\n  var sort;\n\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  var allData = util.unique(domains.map(function (d) {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n\n    return null;\n  }), function (x) {\n    return x;\n  });\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    var _domain = Object.assign({\n      data: allData[0],\n      fields: uniqueDomains.map(function (d) {\n        return d.field;\n      })\n    }, sort ? {\n      sort: sort\n    } : {});\n\n    return _domain;\n  }\n\n  return Object.assign({\n    fields: uniqueDomains\n  }, sort ? {\n    sort: sort\n  } : {});\n}\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\n\nexport function getFieldFromDomain(domain) {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    var field;\n\n    var _iterator6 = _createForOfIteratorHelper(domain.fields),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var nonUnionDomain = _step6.value;\n\n        if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n          if (!field) {\n            field = nonUnionDomain.field;\n          } else if (field !== nonUnionDomain.field) {\n            log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n            return field;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n    var _field = domain.fields[0];\n    return isString(_field) ? _field : undefined;\n  }\n\n  return undefined;\n}\nexport function assembleDomain(model, channel) {\n  var scaleComponent = model.component.scales[channel];\n  var domains = scaleComponent.get('domains').map(function (domain) {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n\n    return domain;\n  }); // domains is an array that has to be merged into a single vega domain\n\n  return mergeDomains(domains);\n}","map":{"version":3,"sources":["../../../../src/compile/scale/domain.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AACA,SAAQ,QAAR,EAAkB,QAAlB,QAAiC,WAAjC;AACA,SACE,aADF,EAEE,WAFF,EAGE,WAHF,EAIE,yBAAyB,IAAI,yBAJ/B,EAME,sBANF,QAOO,iBAPP;AAQA,SAAQ,SAAR,EAAmB,WAAnB,EAAgC,iBAAhC,QAAwD,WAAxD;AACA,SAAQ,wBAAR,EAAkC,cAAlC,QAAqE,eAArE;AACA,SACE,gBADF,EAEE,kBAFF,EAGE,UAHF,EAIE,UAJF,EAKE,UALF,EASE,SATF,EAUE,OAVF,QAWO,kBAXP;AAYA,SAAQ,cAAR,QAA6B,YAA7B;AAGA,OAAO,KAAK,GAAZ,MAAqB,WAArB;AACA,SAAgB,iBAAhB,EAAmC,iBAAnC,EAAsD,iBAAtD,QAAsG,aAAtG;AAEA,SAAQ,eAAR,EAA4C,WAA5C,EAAyD,gBAAzD,EAA2E,WAA3E,QAA6F,YAA7F;AACA,SAAQ,iBAAR,QAA0D,gBAA1D;AAEA,OAAO,KAAK,IAAZ,MAAsB,YAAtB;AACA,SACE,eADF,EAEE,sBAFF,EAGE,qBAHF,EAIE,WAJF,QAWO,mBAXP;AAYA,SAAQ,gBAAR,QAA+B,aAA/B;AACA,SAAQ,mBAAR,QAAkC,mBAAlC;AACA,SAAQ,kBAAR,QAAiC,kBAAjC;AACA,SAAQ,YAAR,EAAsB,WAAtB,QAA+C,UAA/C;AACA,SAAQ,gBAAR,QAA+B,WAA/B;AACA,SAAkB,YAAlB,EAAgC,YAAhC,EAA8C,uBAA9C,QAA4E,UAA5E;AAIA,OAAM,SAAU,gBAAV,CAA2B,KAA3B,EAAuC;AAC3C,MAAI,WAAW,CAAC,KAAD,CAAf,EAAwB;AACtB,IAAA,oBAAoB,CAAC,KAAD,CAApB;AACD,GAFD,MAEO;AACL,IAAA,uBAAuB,CAAC,KAAD,CAAvB;AACD;AACF;;AAED,SAAS,oBAAT,CAA8B,KAA9B,EAA8C;AAC5C,MAAM,oBAAoB,GAAwB,KAAK,CAAC,SAAN,CAAgB,MAAlE;;AAD4C,6CAGtB,IAAI,CAAC,IAAL,CAAU,oBAAV,CAHsB;AAAA;;AAAA;AAG5C,wDAAuD;AAAA,UAA5C,OAA4C;AACrD,UAAM,OAAO,GAAG,qBAAqB,CAAC,KAAD,EAAQ,OAAR,CAArC;AACA,UAAM,cAAc,GAAG,oBAAoB,CAAC,OAAD,CAA3C;AACA,MAAA,cAAc,CAAC,eAAf,CAA+B,SAA/B,EAA0C,OAA1C;AACA,MAAA,oBAAoB,CAAC,KAAD,EAAQ,OAAR,CAApB;;AAEA,UAAI,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,SAAzB,EAAoC;AAClC;AACA,YAAI,WAAW,GAAU,KAAzB;;AACA,eAAO,CAAC,YAAY,CAAC,WAAD,CAAb,IAA8B,WAAW,CAAC,MAAjD,EAAyD;AACvD,UAAA,WAAW,GAAG,WAAW,CAAC,MAA1B;AACD;;AAED,YAAM,OAAO,GAAG,WAAW,CAAC,SAAZ,CAAsB,OAAtB,CAA8B,KAA9B,CAAoC,OAApC,CAAhB;;AAEA,YAAI,OAAO,KAAK,QAAhB,EAA0B;AAAA,sDACH,OAAO,CAAC,KADL;AAAA;;AAAA;AACxB,mEAAoC;AAAA,kBAAzB,MAAyB;;AAClC;AACA,kBAAI,eAAe,CAAC,MAAD,CAAnB,EAA6B;AAC3B;AACA,gBAAA,MAAM,CAAC,IAAP,GAAc,kBAAkB,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAoB,kBAApB,EAAwC,EAAxC,CAAnC;AACD;AACF;AAPuB;AAAA;AAAA;AAAA;AAAA;AAQzB;AACF;AACF;AA5B2C;AAAA;AAAA;AAAA;AAAA;AA6B7C;;AAED,SAAS,uBAAT,CAAiC,KAAjC,EAA6C;AAAA,8CACvB,KAAK,CAAC,QADiB;AAAA;;AAAA;AAC3C,2DAAoC;AAAA,UAAzB,KAAyB;AAClC,MAAA,gBAAgB,CAAC,KAAD,CAAhB;AACD;AAH0C;AAAA;AAAA;AAAA;AAAA;;AAK3C,MAAM,oBAAoB,GAAwB,KAAK,CAAC,SAAN,CAAgB,MAAlE;;AAL2C,8CAOrB,IAAI,CAAC,IAAL,CAAU,oBAAV,CAPqB;AAAA;;AAAA;AAO3C,2DAAuD;AAAA,UAA5C,OAA4C;AACrD,UAAI,OAAqC,SAAzC;AACA,UAAI,eAAe,GAAoB,IAAvC;;AAFqD,kDAIjC,KAAK,CAAC,QAJ2B;AAAA;;AAAA;AAIrD,+DAAoC;AAAA,cAAzB,MAAyB;AAClC,cAAM,cAAc,GAAG,MAAK,CAAC,SAAN,CAAgB,MAAhB,CAAuB,OAAvB,CAAvB;;AACA,cAAI,cAAJ,EAAoB;AAClB,gBAAI,OAAO,KAAK,SAAhB,EAA2B;AACzB,cAAA,OAAO,GAAG,cAAc,CAAC,eAAf,CAA+B,SAA/B,CAAV;AACD,aAFD,MAEO;AACL,cAAA,OAAO,GAAG,uBAAuB,CAC/B,OAD+B,EAE/B,cAAc,CAAC,eAAf,CAA+B,SAA/B,CAF+B,EAG/B,SAH+B,EAI/B,OAJ+B,EAK/B,iBAL+B,CAAjC;AAOD;;AAED,gBAAM,EAAE,GAAG,cAAc,CAAC,GAAf,CAAmB,iBAAnB,CAAX;;AACA,gBAAI,eAAe,IAAI,EAAnB,IAAyB,eAAe,CAAC,KAAhB,KAA0B,EAAE,CAAC,KAA1D,EAAiE;AAC/D,cAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,oBAArB;AACD;;AACD,YAAA,eAAe,GAAG,EAAlB;AACD;AACF;AAzBoD;AAAA;AAAA;AAAA;AAAA;;AA2BrD,MAAA,oBAAoB,CAAC,OAAD,CAApB,CAA8B,eAA9B,CAA8C,SAA9C,EAAyD,OAAzD;;AAEA,UAAI,eAAJ,EAAqB;AACnB,QAAA,oBAAoB,CAAC,OAAD,CAApB,CAA8B,GAA9B,CAAkC,iBAAlC,EAAqD,eAArD,EAAsE,IAAtE;AACD;AACF;AAvC0C;AAAA;AAAA;AAAA;AAAA;AAwC5C;AAED;;;;;;AAIA,SAAS,2BAAT,CACE,MADF,EAEE,QAFF,EAGE,SAHF,EAIE,WAJF,EAIqC;AAEnC,MAAI,MAAM,KAAK,cAAf,EAA+B;AAAA,gCACL,wBAAwB,CAAC,QAAD,EAAW,SAAX,CADnB;AAAA,QACtB,KADsB,yBACtB,KADsB;AAAA,QACf,MADe,yBACf,MADe;;AAE7B,QAAI,CAAC,KAAL,EAAY;AACV,MAAA,GAAG,CAAC,IAAJ,CAAS,MAAT;AACA,aAAO,SAAP;AACD;AACF,GAND,MAMO,IAAI,MAAM,KAAK,SAAX,IAAwB,WAAW,CAAC,qBAAxC,EAA+D;AACpE;AADoE,iCAEpD,wBAAwB,CAAC,QAAD,EAAW,SAAX,CAF4B;AAAA,QAE7D,MAF6D,0BAE7D,KAF6D;;AAGpE,QAAI,MAAJ,EAAW;AACT,aAAO,cAAP;AACD;AACF;;AAED,SAAO,MAAP;AACD;;AAED,OAAM,SAAU,qBAAV,CAAgC,KAAhC,EAAkD,OAAlD,EAAuE;AAC3E,MAAM,SAAS,GAAG,KAAK,CAAC,iBAAN,CAAwB,OAAxB,EAAiC,GAAjC,CAAqC,MAArC,CAAlB;AAD2E,MAEpE,QAFoE,GAExD,KAFwD,CAEpE,QAFoE;AAI3E,MAAM,MAAM,GAAG,2BAA2B,CACxC,KAAK,CAAC,WAAN,CAAkB,OAAlB,CADwC,EAExC,KAAK,CAAC,aAAN,CAAoB,OAApB,CAFwC,EAGxC,SAHwC,EAIxC,KAAK,CAAC,MAAN,CAAa,KAJ2B,CAA1C;;AAMA,MAAI,MAAM,KAAK,KAAK,CAAC,WAAN,CAAkB,OAAlB,CAAf,EAA2C;AACzC,IAAA,KAAK,CAAC,eAAN,CAAsB,OAAtB,IAA8B,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACzB,KAAK,CAAC,eAAN,CAAsB,OAAtB,CADyB,CAAA,EACK;AACjC,MAAA,MAAM,EAAN;AADiC,KADL,CAA9B;AAID,GAf0E,CAiB3E;;;AACA,MAAI,OAAO,KAAK,GAAZ,IAAmB,kBAAkB,CAAC,QAAQ,CAAC,EAAV,CAAzC,EAAwD;AACtD,QAAI,kBAAkB,CAAC,QAAQ,CAAC,CAAV,CAAtB,EAAoC;AAClC,aAAO,uBAAuB,CAC5B,wBAAwB,CAAC,SAAD,EAAY,MAAZ,EAAoB,KAApB,EAA2B,GAA3B,CADI,EAE5B,wBAAwB,CAAC,SAAD,EAAY,MAAZ,EAAoB,KAApB,EAA2B,IAA3B,CAFI,EAG5B,QAH4B,EAI5B,OAJ4B,EAK5B,iBAL4B,CAA9B;AAOD,KARD,MAQO;AACL,aAAO,wBAAwB,CAAC,SAAD,EAAY,MAAZ,EAAoB,KAApB,EAA2B,IAA3B,CAA/B;AACD;AACF,GAZD,MAYO,IAAI,OAAO,KAAK,GAAZ,IAAmB,kBAAkB,CAAC,QAAQ,CAAC,EAAV,CAAzC,EAAwD;AAC7D,QAAI,kBAAkB,CAAC,QAAQ,CAAC,CAAV,CAAtB,EAAoC;AAClC,aAAO,uBAAuB,CAC5B,wBAAwB,CAAC,SAAD,EAAY,MAAZ,EAAoB,KAApB,EAA2B,GAA3B,CADI,EAE5B,wBAAwB,CAAC,SAAD,EAAY,MAAZ,EAAoB,KAApB,EAA2B,IAA3B,CAFI,EAG5B,QAH4B,EAI5B,OAJ4B,EAK5B,iBAL4B,CAA9B;AAOD,KARD,MAQO;AACL,aAAO,wBAAwB,CAAC,SAAD,EAAY,MAAZ,EAAoB,KAApB,EAA2B,IAA3B,CAA/B;AACD;AACF;;AACD,SAAO,wBAAwB,CAAC,SAAD,EAAY,MAAZ,EAAoB,KAApB,EAA2B,OAA3B,CAA/B;AACD;;AAED,SAAS,qBAAT,CACE,MADF,EAEE,IAFF,EAGE,QAHF,EAGoB;AAElB,SAAO,MAAM,CAAC,GAAP,CAAW,UAAA,CAAC,EAAG;AACpB,QAAM,IAAI,GAAG,SAAS,CAAC,CAAD,EAAI;AAAC,MAAA,QAAQ,EAAR,QAAD;AAAW,MAAA,IAAI,EAAJ;AAAX,KAAJ,CAAtB;AACA,WAAO;AAAC,MAAA,MAAM,mBAAY,IAAZ;AAAP,KAAP;AACD,GAHM,CAAP;AAID;;AAED,SAAS,2BAAT,CACE,MADF,EAEE,IAFF,EAGE,QAHF,EAGqC;SAAA,CAEnC;;;AACA,MAAM,kBAAkB,GAAG,CAAA,EAAA,GAAA,iBAAiB,CAAC,QAAD,CAAjB,MAA2B,IAA3B,IAA2B,EAAA,KAAA,KAAA,CAA3B,GAA2B,KAAA,CAA3B,GAA2B,EAAA,CAAE,IAAxD;;AACA,MAAI,IAAI,KAAK,UAAT,IAAuB,kBAA3B,EAA+C;AAC7C,WAAO,qBAAqB,CAAC,MAAD,EAAS,IAAT,EAAe,kBAAf,CAA5B;AACD;;AAED,SAAO,CAAC,MAAD,CAAP,CARmC,CAQuB;AAC3D;;AAED,SAAS,wBAAT,CACE,SADF,EAEE,MAFF,EAGE,KAHF,EAIE,OAJF,EAIqC;AAAA,MAE5B,QAF4B,GAEhB,KAFgB,CAE5B,QAF4B;AAGnC,MAAM,eAAe,GAAG,kBAAkB,CAAC,QAAQ,CAAC,OAAD,CAAT,CAA1C;AAHmC,MAK5B,IAL4B,GAKpB,eALoB,CAK5B,IAL4B;AAMnC,MAAM,QAAQ,GAAG,eAAe,CAAC,UAAD,CAAhC;;AAEA,MAAI,iBAAiB,CAAC,MAAD,CAArB,EAA+B;AAC7B,QAAM,aAAa,GAAG,wBAAwB,CAAC,SAAD,EAAY,SAAZ,EAAuB,KAAvB,EAA8B,OAA9B,CAA9C;AAEA,QAAM,SAAS,GAAG,2BAA2B,CAAC,MAAM,CAAC,SAAR,EAAmB,IAAnB,EAAyB,QAAzB,CAA7C;AAEA,WAAO,YAAY,8BAAK,aAAa,CAAC,KAAnB,sBAA6B,SAA7B,GAAnB;AACD,GAND,MAMO,IAAI,WAAW,CAAC,MAAD,CAAf,EAAyB;AAC9B,WAAO,YAAY,CAAC,CAAC,MAAD,CAAD,CAAnB;AACD,GAFM,MAEA,IAAI,MAAM,IAAI,MAAM,KAAK,cAArB,IAAuC,CAAC,iBAAiB,CAAC,MAAD,CAA7D,EAAuE;AAC5E,WAAO,YAAY,CAAC,2BAA2B,CAAC,MAAD,EAAS,IAAT,EAAe,QAAf,CAA5B,CAAnB;AACD;;AAED,MAAM,KAAK,GAAG,KAAK,CAAC,KAApB;;AACA,MAAI,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC,YAA/B,EAA6C;AAC3C,QAAI,KAAK,CAAC,MAAN,KAAiB,WAArB,EAAkC;AAChC,aAAO,YAAY,CAAC,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,CAAD,CAAnB;AACD;;AAED,QAAM,IAAI,GAAG,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CAAb;AACA,WAAO,YAAY,CAAC,CAClB;AACE,MAAA,IAAI,EAAJ,IADF;AAEE,MAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAvB;AAFT,KADkB,EAKlB;AACE,MAAA,IAAI,EAAJ,IADF;AAEE,MAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAvB;AAFT,KALkB,CAAD,CAAnB;AAUD;;AAED,MAAM,IAAI,GACR,cAAc,CAAC,OAAD,CAAd,IAA2B,UAAU,CAAC,eAAD,CAArC,GAAyD,UAAU,CAAC,KAAD,EAAQ,OAAR,EAAiB,SAAjB,CAAnE,GAAiG,SADnG;;AAGA,MAAI,UAAU,CAAC,eAAD,CAAd,EAAiC;AAC/B,QAAM,CAAC,GAAG,2BAA2B,CAAC,CAAC,eAAe,CAAC,KAAjB,CAAD,EAA0B,IAA1B,EAAgC,QAAhC,CAArC;AACA,WAAO,YAAY,CAAC,CAAD,CAAnB;AACD;;AAED,MAAM,QAAQ,GAAG,eAAjB,CA/CmC,CA+CD;;AAClC,MAAI,MAAM,KAAK,cAAf,EAA+B;AAC7B,QAAM,KAAI,GAAG,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CAAb;;AAD6B,QAEtB,KAFsB,GAEb,eAFa,CAEtB,KAFsB;AAG7B,WAAO,YAAY,CAAC,CAClB;AACE,MAAA,IAAI,EAAJ,KADF;AAEE,MAAA,KAAK,EAAE,OAAO,CAAC;AAAC,QAAA,KAAK,EAAL,KAAD;AAAQ,QAAA,SAAS,EAAE;AAAnB,OAAD;AAFhB,KADkB,EAKlB;AACE,MAAA,IAAI,EAAJ,KADF;AAEE,MAAA,KAAK,EAAE,OAAO,CAAC;AAAC,QAAA,KAAK,EAAL,KAAD;AAAQ,QAAA,SAAS,EAAE;AAAnB,OAAD;AAFhB,KALkB,CAAD,CAAnB;AAUD,GAbD,MAaO,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAV,CAAb,EAA6B;AAClC,QAAI,iBAAiB,CAAC,SAAD,CAArB,EAAkC;AAChC,UAAI,SAAS,KAAK,aAAlB,EAAiC;AAC/B;AACA,eAAO,YAAY,CAAC,EAAD,CAAnB;AACD,OAJ+B,CAMhC;AACA;;;AACA,aAAO,YAAY,CAAC,CAClB;AACE;AACA;AACA,QAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,IAAf,IACF,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CADE,GAEF,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,GAArC,CALN;AAME;AACA,QAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,gBAAgB,CAAC,QAAD,EAAW,OAAX,CAAhB,GAAsC;AAAC,UAAA,SAAS,EAAE;AAAZ,SAAtC,GAA6D,EAApF,CAPT;AAQE;AACA,QAAA,IAAI,EACF,IAAI,KAAK,IAAT,IAAiB,CAAC,QAAQ,CAAC,IAAD,CAA1B,GACI;AACE,UAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,EAAvB,CADT;AAEE,UAAA,EAAE,EAAE,KAFN,CAEY;;AAFZ,SADJ,GAKI;AAfR,OADkB,CAAD,CAAnB;AAmBD,KA3BD,MA2BO;AACL;AADK,UAEE,GAFF,GAES,QAFT,CAEE,GAFF;;AAGL,UAAI,SAAS,CAAC,GAAD,CAAb,EAAoB;AAClB,YAAM,SAAS,GAAG,gBAAgB,CAAC,KAAD,EAAQ,QAAQ,CAAC,KAAjB,EAAwB,GAAxB,CAAlC;AACA,eAAO,YAAY,CAAC,CAClB,IAAI,gBAAJ,CAAqB,YAAK;AACxB,cAAM,MAAM,GAAG,KAAK,CAAC,aAAN,CAAoB,SAApB,CAAf;AACA,4BAAW,MAAX,qBAA4B,MAA5B;AACD,SAHD,CADkB,CAAD,CAAnB;AAMD,OARD,MAQO;AACL,eAAO,YAAY,CAAC,CAClB;AACE,UAAA,IAAI,EAAE,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CADR;AAEE,UAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,EAAvB;AAFT,SADkB,CAAD,CAAnB;AAMD;AACF;AACF,GAhDM,MAgDA,IACL,QAAQ,CAAC,QAAT,IACA,IAAI,CAAC,QAAL,CAAc,CAAC,MAAD,EAAS,KAAT,CAAd,EAA+B,SAA/B,CADA,IAEA,UAAU,CACR,QADQ,EAER,WAAW,CAAC,KAAD,CAAX,GAAqB,KAAK,CAAC,QAAN,CAAe,wBAAwB,CAAC,OAAD,CAAvC,CAArB,GAAyE,SAFjE,EAGR,KAAK,CAAC,OAHE,EAIR,KAAK,CAAC,MAJE,CAHL,EASL;AACA,QAAM,MAAI,GAAG,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CAAb;;AACA,WAAO,YAAY,CAAC,CAClB;AACE,MAAA,IAAI,EAAJ,MADF;AAEE,MAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd;AAFT,KADkB,EAKlB;AACE,MAAA,IAAI,EAAJ,MADF;AAEE,MAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAvB;AAFT,KALkB,CAAD,CAAnB;AAUD,GArBM,MAqBA,IAAI,IAAJ,EAAU;AACf,WAAO,YAAY,CAAC,CAClB;AACE;AACA;AACA,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,IAAf,IACF,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CADE,GAEF,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,GAArC,CALN;AAME,MAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,CANT;AAOE,MAAA,IAAI,EAAE;AAPR,KADkB,CAAD,CAAnB;AAWD,GAZM,MAYA;AACL,WAAO,YAAY,CAAC,CAClB;AACE,MAAA,IAAI,EAAE,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CADR;AAEE,MAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd;AAFT,KADkB,CAAD,CAAnB;AAMD;AACF;;AAED,SAAS,kBAAT,CAA4B,IAA5B,EAA6D,gBAA7D,EAAsF;AAAA,MAC7E,EAD6E,GACzD,IADyD,CAC7E,EAD6E;AAAA,MACzE,KADyE,GACzD,IADyD,CACzE,KADyE;AAAA,MAClE,KADkE,GACzD,IADyD,CAClE,KADkE;AAEpF,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACE;AACA,IAAA,EAAE,EAAE,EAAE,KAAA,IAAF,IAAA,EAAE,KAAA,KAAA,CAAF,GAAA,EAAA,GAAO,gBAAgB,GAAG,KAAH,GAAW;AAFxC,GAAA,EAIM,KAAK,GAAG;AAAC,IAAA,KAAK,EAAE,IAAI,CAAC,kBAAL,CAAwB,KAAxB;AAAR,GAAH,GAA6C,EAJxD,CAAA,EAMM,KAAK,GAAG;AAAC,IAAA,KAAK,EAAL;AAAD,GAAH,GAAa,EANxB,CAAA;AAQD;;AAED,SAAS,oBAAT,CAA8B,KAA9B,EAAgD,OAAhD,EAAqE;;;AACnE,MAAM,KAAK,GAAG,KAAK,CAAC,SAAN,CAAgB,MAAhB,CAAuB,OAAvB,CAAd;AACA,MAAM,IAAI,GAAG,KAAK,CAAC,eAAN,CAAsB,OAAtB,EAA+B,MAA5C;AACA,MAAM,GAAG,GAAG,CAAA,EAAA,GAAA,KAAK,CAAC,QAAN,CAAe,OAAf,CAAA,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,KAAA,CAAvB,GAAuB,EAAA,CAAE,GAArC;AACA,MAAM,MAAM,GAAG,iBAAiB,CAAC,IAAD,CAAjB,IAA2B,IAA1C;AACA,MAAM,MAAM,GAAG,WAAW,CAAC,GAAD,CAAX,IAAoB,iBAAiB,CAAC,GAAG,CAAC,MAAL,CAArC,IAAqD,GAAG,CAAC,MAAxE;;AAEA,MAAI,MAAM,IAAI,MAAd,EAAsB;AACpB;AACA;AACA;AACA,IAAA,KAAK,CAAC,GAAN,CAAU,iBAAV,EAA6B,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAA,MAAA,GAAU,MAAvC,EAA+C,IAA/C;AACD;AACF;;AAED,OAAM,SAAU,UAAV,CACJ,KADI,EAEJ,OAFI,EAGJ,SAHI,EAGgB;AAEpB,MAAI,CAAC,iBAAiB,CAAC,SAAD,CAAtB,EAAmC;AACjC,WAAO,SAAP;AACD,GAJmB,CAMpB;;;AACA,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAN,CAAe,OAAf,CAAjB;AACA,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAtB,CARoB,CAUpB;;AACA,MAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AACrB,WAAO;AACL,MAAA,EAAE,EAAE,KADC;AAEL,MAAA,KAAK,EAAE,mBAAmB,CAAC,QAAD,EAAW,OAAX,CAFrB;AAGL,MAAA,KAAK,EAAE;AAHF,KAAP;AAKD;;AAjBmB,MAmBb,KAnBa,GAmBJ,KAnBI,CAmBb,KAnBa;AAoBpB,MAAM,eAAe,GAAG,KAAK,gCACpB,KAAK,CAAC,YAAN,GAAqB,CAAC,KAAK,CAAC,YAAP,CAArB,GAA4C,EADxB,sBACgC,KAAK,CAAC,OAAN,CAAc,GAAd,CAAkB,UAAA,CAAC;AAAA,WAAI,CAAC,CAAC,QAAF,CAAW,KAAf;AAAA,GAAnB,CADhC,KAEzB,SAFJ,CApBoB,CAwBpB;;AACA,MAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AACrB,QAAM,gBAAgB,GAAG,KAAK,IAAI,CAAC,IAAI,CAAC,QAAL,CAAc,eAAd,EAA+B,IAAI,CAAC,KAApC,CAAnC;AACA,WAAO,kBAAkB,CAAC,IAAD,EAAO,gBAAP,CAAzB;AACD,GAHD,MAGO,IAAI,gBAAgB,CAAC,IAAD,CAApB,EAA4B;AAAA,QAC1B,QAD0B,GACP,IADO,CAC1B,QAD0B;AAAA,QAChB,KADgB,GACP,IADO,CAChB,KADgB;AAEjC,QAAM,gBAAgB,GAAG,KAAK,CAAC,QAAN,CAAe,QAAf,CAAzB;AAFiC,QAG1B,SAH0B,GAGN,gBAHM,CAG1B,SAH0B;AAAA,QAGf,KAHe,GAGN,gBAHM,CAGf,KAHe;;AAKjC,QAAM,iBAAgB,GAAG,KAAK,IAAI,CAAC,IAAI,CAAC,QAAL,CAAc,eAAd,EAA+B,KAA/B,CAAnC;;AAEA,QAAI,WAAW,CAAC,SAAD,CAAX,IAA0B,WAAW,CAAC,SAAD,CAAzC,EAAsD;AACpD,aAAO,kBAAkB,CACvB;AACE,QAAA,KAAK,EAAE,OAAO,CAAC,gBAAD,CADhB;AAEE,QAAA,KAAK,EAAL;AAFF,OADuB,EAKvB,iBALuB,CAAzB;AAOD,KARD,MAQO,IAAI,aAAa,CAAC,SAAD,CAAb,IAA4B,CAAC,SAAjC,EAA4C;AACjD,aAAO,kBAAkB,CACvB;AACE,QAAA,EAAE,EAAE,SADN;AAEE,QAAA,KAAK,EAAL,KAFF;AAGE,QAAA,KAAK,EAAL;AAHF,OADuB,EAMvB,iBANuB,CAAzB;AAQD;AACF,GAzBM,MAyBA,IAAI,IAAI,KAAK,YAAb,EAA2B;AAChC,WAAO;AACL,MAAA,EAAE,EAAE,KADC;AAEL,MAAA,KAAK,EAAE,KAAK,CAAC,OAAN,CAAc,OAAd,CAFF;AAGL,MAAA,KAAK,EAAE;AAHF,KAAP;AAKD,GANM,MAMA,IAAI,IAAI,CAAC,QAAL,CAAc,CAAC,WAAD,EAAc;AAAU;AAAxB,GAAd,EAAgE,IAAhE,CAAJ,EAA2E;AAChF,WAAO,IAAP;AACD,GA7DmB,CA+DpB;;;AACA,SAAO,SAAP;AACD;AAED;;;;;;;;AAOA,OAAM,SAAU,wBAAV,CACJ,QADI,EAEJ,SAFI,EAEgB;AAAA,MAEb,SAFa,GAEM,QAFN,CAEb,SAFa;AAAA,MAEF,IAFE,GAEM,QAFN,CAEF,IAFE;;AAIpB,MAAI,CAAC,SAAL,EAAgB;AACd,WAAO;AACL,MAAA,KAAK,EAAE,KADF;AAEL,MAAA,MAAM,EAAE,GAAG,CAAC,OAAJ,CAAY,uCAAZ,CAAoD,QAApD;AAFH,KAAP;AAID;;AAED,MAAI,QAAQ,CAAC,SAAD,CAAR,IAAuB,CAAC,sBAAsB,CAAC,SAAD,CAAlD,EAA+D;AAC7D,WAAO;AACL,MAAA,KAAK,EAAE,KADF;AAEL,MAAA,MAAM,EAAE,GAAG,CAAC,OAAJ,CAAY,sCAAZ,CAAmD,SAAnD;AAFH,KAAP;AAID;;AAED,MAAI,IAAI,KAAK,cAAb,EAA6B;AAC3B,QAAI,SAAS,KAAK,KAAlB,EAAyB;AACvB,aAAO;AACL,QAAA,KAAK,EAAE,KADF;AAEL,QAAA,MAAM,EAAE,GAAG,CAAC,OAAJ,CAAY,8BAAZ,CAA2C,QAA3C;AAFH,OAAP;AAID;AACF;;AAED,SAAO;AAAC,IAAA,KAAK,EAAE;AAAR,GAAP;AACD;AAED;;;;AAGA,SAAS,iBAAT,CACE,EADF,EAEE,EAFF,EAGE,QAHF,EAIE,UAJF,EAIqB;AAEnB,MAAI,EAAE,CAAC,QAAH,IAAe,EAAE,CAAC,QAAtB,EAAgC;AAC9B,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,8BAAZ,CAA2C,QAA3C,EAAqD,UAArD,EAAiE,EAAE,CAAC,KAApE,EAA2E,EAAE,CAAC,KAA9E,CAAT;AACD,GAJkB,CAKnB;;;AACA,SAAO;AAAC,IAAA,QAAQ,EAAE,EAAE,CAAC,QAAd;AAAwB,IAAA,KAAK,+BAAM,EAAE,CAAC,KAAT,sBAAmB,EAAE,CAAC,KAAtB;AAA7B,GAAP;AACD;AAED;;;;;AAGA,OAAM,SAAU,YAAV,CAAuB,OAAvB,EAAkD;AACtD,MAAM,aAAa,GAAG,IAAI,CAAC,MAAL,CACpB,OAAO,CAAC,GAAR,CAAY,UAAA,MAAM,EAAG;AACnB;AACA,QAAI,eAAe,CAAC,MAAD,CAAnB,EAA6B;AACrB,UAAO,EAAP,GAAmC,MAAnC,CAAC,IAAD;AAAA,UAAc,iBAAd,GAA+B,MAAA,CAAI,MAAJ,EAA/B,CAAA,MAAA,CAA+B,CAA/B;;AACN,aAAO,iBAAP;AACD;;AACD,WAAO,MAAP;AACD,GAPD,CADoB,EASpB,IAAI,CAAC,IATe,CAAtB;AAYA,MAAM,KAAK,GAAkB,IAAI,CAAC,MAAL,CAC3B,OAAO,CACJ,GADH,CACO,UAAA,CAAC,EAAG;AACP,QAAI,eAAe,CAAC,CAAD,CAAnB,EAAwB;AACtB,UAAM,CAAC,GAAG,CAAC,CAAC,IAAZ;;AACA,UAAI,CAAC,KAAK,SAAN,IAAmB,CAAC,IAAI,CAAC,SAAL,CAAe,CAAf,CAAxB,EAA2C;AACzC,YAAI,QAAQ,CAAR,IAAa,CAAC,CAAC,EAAF,KAAS,OAA1B,EAAmC;AACjC;AACA,iBAAO,CAAC,CAAC,KAAT;AACD;;AACD,YAAI,CAAC,CAAC,KAAF,KAAY,WAAhB,EAA6B;AAC3B;AACA,iBAAO,CAAC,CAAC,KAAT;AACD;AACF;;AACD,aAAO,CAAP;AACD;;AACD,WAAO,SAAP;AACD,GAjBH,EAkBG,MAlBH,CAkBU,UAAA,CAAC;AAAA,WAAI,CAAC,KAAK,SAAV;AAAA,GAlBX,CAD2B,EAoB3B,IAAI,CAAC,IApBsB,CAA7B;;AAuBA,MAAI,aAAa,CAAC,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,WAAO,SAAP;AACD,GAFD,MAEO,IAAI,aAAa,CAAC,MAAd,KAAyB,CAA7B,EAAgC;AACrC,QAAM,MAAM,GAAG,OAAO,CAAC,CAAD,CAAtB;;AACA,QAAI,eAAe,CAAC,MAAD,CAAf,IAA2B,KAAK,CAAC,MAAN,GAAe,CAA9C,EAAiD;AAC/C,UAAI,KAAI,GAAG,KAAK,CAAC,CAAD,CAAhB;;AACA,UAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB,QAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,kBAArB;AACA,QAAA,KAAI,GAAG,IAAP;AACD,OAHD,MAGO;AACL;AACA,YAAI,QAAQ,CAAC,KAAD,CAAR,IAAkB,WAAW,KAAjC,EAAuC;AACrC,cAAM,SAAS,GAAG,KAAI,CAAC,KAAvB;;AACA,cAAI,MAAM,CAAC,KAAP,KAAiB,SAArB,EAAgC;AAC9B,YAAA,KAAI,GAAG,KAAI,CAAC,KAAL,GAAa;AAAC,cAAA,KAAK,EAAE,KAAI,CAAC;AAAb,aAAb,GAAmC,IAA1C;AACD;AACF;AACF;;AACD,aAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,MADL,CAAA,EACW;AACT,QAAA,IAAI,EAAJ;AADS,OADX,CAAA;AAID;;AACD,WAAO,MAAP;AACD,GA5DqD,CA8DtD;;;AACA,MAAM,gBAAgB,GAAG,IAAI,CAAC,MAAL,CACvB,KAAK,CAAC,GAAN,CAAU,UAAA,CAAC,EAAG;AACZ,QAAI,IAAI,CAAC,SAAL,CAAe,CAAf,KAAqB,EAAE,QAAQ,CAAV,CAArB,IAAsC,QAAQ,CAAC,CAAC,CAAC,EAAH,CAAR,IAAkB,CAAC,CAAC,EAAF,IAAQ,yBAApE,EAAgG;AAC9F,aAAO,CAAP;AACD;;AACD,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,iBAAZ,CAA8B,CAA9B,CAAT;AACA,WAAO,IAAP;AACD,GAND,CADuB,EAQvB,IAAI,CAAC,IARkB,CAAzB;AAWA,MAAI,IAAJ;;AAEA,MAAI,gBAAgB,CAAC,MAAjB,KAA4B,CAAhC,EAAmC;AACjC,IAAA,IAAI,GAAG,gBAAgB,CAAC,CAAD,CAAvB;AACD,GAFD,MAEO,IAAI,gBAAgB,CAAC,MAAjB,GAA0B,CAA9B,EAAiC;AACtC,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,kBAArB;AACA,IAAA,IAAI,GAAG,IAAP;AACD;;AAED,MAAM,OAAO,GAAG,IAAI,CAAC,MAAL,CACd,OAAO,CAAC,GAAR,CAAY,UAAA,CAAC,EAAG;AACd,QAAI,eAAe,CAAC,CAAD,CAAnB,EAAwB;AACtB,aAAO,CAAC,CAAC,IAAT;AACD;;AACD,WAAO,IAAP;AACD,GALD,CADc,EAOd,UAAA,CAAC;AAAA,WAAI,CAAJ;AAAA,GAPa,CAAhB;;AAUA,MAAI,OAAO,CAAC,MAAR,KAAmB,CAAnB,IAAwB,OAAO,CAAC,CAAD,CAAP,KAAe,IAA3C,EAAiD;AAC/C;AACA,QAAM,OAAM,GAAA,MAAA,CAAA,MAAA,CAAA;AACV,MAAA,IAAI,EAAE,OAAO,CAAC,CAAD,CADH;AAEV,MAAA,MAAM,EAAE,aAAa,CAAC,GAAd,CAAkB,UAAA,CAAC;AAAA,eAAK,CAA4B,CAAC,KAAlC;AAAA,OAAnB;AAFE,KAAA,EAGN,IAAI,GAAG;AAAC,MAAA,IAAI,EAAJ;AAAD,KAAH,GAAY,EAHV,CAAZ;;AAMA,WAAO,OAAP;AACD;;AAED,SAAA,MAAA,CAAA,MAAA,CAAA;AAAQ,IAAA,MAAM,EAAE;AAAhB,GAAA,EAAmC,IAAI,GAAG;AAAC,IAAA,IAAI,EAAJ;AAAD,GAAH,GAAY,EAAnD,CAAA;AACD;AAED;;;;;AAIA,OAAM,SAAU,kBAAV,CAA6B,MAA7B,EAA6C;AACjD,MAAI,eAAe,CAAC,MAAD,CAAf,IAA2B,QAAQ,CAAC,MAAM,CAAC,KAAR,CAAvC,EAAuD;AACrD,WAAO,MAAM,CAAC,KAAd;AACD,GAFD,MAEO,IAAI,sBAAsB,CAAC,MAAD,CAA1B,EAAoC;AACzC,QAAI,KAAJ;;AADyC,gDAEZ,MAAM,CAAC,MAFK;AAAA;;AAAA;AAEzC,6DAA4C;AAAA,YAAjC,cAAiC;;AAC1C,YAAI,eAAe,CAAC,cAAD,CAAf,IAAmC,QAAQ,CAAC,cAAc,CAAC,KAAhB,CAA/C,EAAuE;AACrE,cAAI,CAAC,KAAL,EAAY;AACV,YAAA,KAAK,GAAG,cAAc,CAAC,KAAvB;AACD,WAFD,MAEO,IAAI,KAAK,KAAK,cAAc,CAAC,KAA7B,EAAoC;AACzC,YAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,qCAArB;AACA,mBAAO,KAAP;AACD;AACF;AACF;AAXwC;AAAA;AAAA;AAAA;AAAA;;AAYzC,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,iDAArB;AACA,WAAO,KAAP;AACD,GAdM,MAcA,IAAI,qBAAqB,CAAC,MAAD,CAAzB,EAAmC;AACxC,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,+BAArB;AACA,QAAM,MAAK,GAAG,MAAM,CAAC,MAAP,CAAc,CAAd,CAAd;AACA,WAAO,QAAQ,CAAC,MAAD,CAAR,GAAkB,MAAlB,GAA0B,SAAjC;AACD;;AAED,SAAO,SAAP;AACD;AAED,OAAM,SAAU,cAAV,CAAyB,KAAzB,EAAuC,OAAvC,EAA4D;AAChE,MAAM,cAAc,GAAmB,KAAK,CAAC,SAAN,CAAgB,MAAhB,CAAuB,OAAvB,CAAvC;AAEA,MAAM,OAAO,GAAG,cAAc,CAAC,GAAf,CAAmB,SAAnB,EAA8B,GAA9B,CAAkC,UAAC,MAAD,EAA6B;AAC7E;AACA;AACA;AACA,QAAI,eAAe,CAAC,MAAD,CAAnB,EAA6B;AAC3B,MAAA,MAAM,CAAC,IAAP,GAAc,KAAK,CAAC,gBAAN,CAAuB,MAAM,CAAC,IAA9B,CAAd;AACD;;AAED,WAAO,MAAP;AACD,GATe,CAAhB,CAHgE,CAchE;;AACA,SAAO,YAAY,CAAC,OAAD,CAAnB;AACD","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX, SHARED_DOMAIN_OP_INDEX } from '../../aggregate';\nimport { isBinning, isBinParams, isParameterExtent } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, getFieldOrDatumDef, hasBandEnd, isDatumDef, isFieldDef, valueExpr, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isDomainUnionWith, isParameterDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n    if (isUnitModel(model)) {\n        parseUnitScaleDomain(model);\n    }\n    else {\n        parseNonUnitScaleDomain(model);\n    }\n}\nfunction parseUnitScaleDomain(model) {\n    const localScaleComponents = model.component.scales;\n    for (const channel of util.keys(localScaleComponents)) {\n        const domains = parseDomainForChannel(model, channel);\n        const localScaleCmpt = localScaleComponents[channel];\n        localScaleCmpt.setWithExplicit('domains', domains);\n        parseSelectionDomain(model, channel);\n        if (model.component.data.isFaceted) {\n            // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n            let facetParent = model;\n            while (!isFacetModel(facetParent) && facetParent.parent) {\n                facetParent = facetParent.parent;\n            }\n            const resolve = facetParent.component.resolve.scale[channel];\n            if (resolve === 'shared') {\n                for (const domain of domains.value) {\n                    // Replace the scale domain with data output from a cloned subtree after the facet.\n                    if (isDataRefDomain(domain)) {\n                        // use data from cloned subtree (which is the same as data but with a prefix added once)\n                        domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n                    }\n                }\n            }\n        }\n    }\n}\nfunction parseNonUnitScaleDomain(model) {\n    for (const child of model.children) {\n        parseScaleDomain(child);\n    }\n    const localScaleComponents = model.component.scales;\n    for (const channel of util.keys(localScaleComponents)) {\n        let domains;\n        let selectionExtent = null;\n        for (const child of model.children) {\n            const childComponent = child.component.scales[channel];\n            if (childComponent) {\n                if (domains === undefined) {\n                    domains = childComponent.getWithExplicit('domains');\n                }\n                else {\n                    domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n                }\n                const se = childComponent.get('selectionExtent');\n                if (selectionExtent && se && selectionExtent.param !== se.param) {\n                    log.warn(log.message.NEEDS_SAME_SELECTION);\n                }\n                selectionExtent = se;\n            }\n        }\n        localScaleComponents[channel].setWithExplicit('domains', domains);\n        if (selectionExtent) {\n            localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n        }\n    }\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n    if (domain === 'unaggregated') {\n        const { valid, reason } = canUseUnaggregatedDomain(fieldDef, scaleType);\n        if (!valid) {\n            log.warn(reason);\n            return undefined;\n        }\n    }\n    else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n        // Apply config if domain is not specified.\n        const { valid } = canUseUnaggregatedDomain(fieldDef, scaleType);\n        if (valid) {\n            return 'unaggregated';\n        }\n    }\n    return domain;\n}\nexport function parseDomainForChannel(model, channel) {\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const { encoding } = model;\n    const domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType, model.config.scale);\n    if (domain !== model.scaleDomain(channel)) {\n        model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), { domain });\n    }\n    // If channel is either X or Y then union them with X2 & Y2 if they exist\n    if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n        if (getFieldOrDatumDef(encoding.x)) {\n            return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n        }\n        else {\n            return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n        }\n    }\n    else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n        if (getFieldOrDatumDef(encoding.y)) {\n            return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n        }\n        else {\n            return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n        }\n    }\n    return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n    return domain.map(v => {\n        const data = valueExpr(v, { timeUnit, type });\n        return { signal: `{data: ${data}}` };\n    });\n}\nfunction convertDomainIfItIsDateTime(domain, type, timeUnit) {\n    var _a;\n    // explicit value\n    const normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n    if (type === 'temporal' || normalizedTimeUnit) {\n        return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n    }\n    return [domain]; // Date time won't make sense\n}\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n    const { encoding } = model;\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const { type } = fieldOrDatumDef;\n    const timeUnit = fieldOrDatumDef['timeUnit'];\n    if (isDomainUnionWith(domain)) {\n        const defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n        const unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n        return makeExplicit([...defaultDomain.value, ...unionWith]);\n    }\n    else if (isSignalRef(domain)) {\n        return makeExplicit([domain]);\n    }\n    else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n        return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n    }\n    const stack = model.stack;\n    if (stack && channel === stack.fieldChannel) {\n        if (stack.offset === 'normalize') {\n            return makeImplicit([[0, 1]]);\n        }\n        const data = model.requestDataName(DataSourceType.Main);\n        return makeImplicit([\n            {\n                data,\n                field: model.vgField(channel, { suffix: 'start' })\n            },\n            {\n                data,\n                field: model.vgField(channel, { suffix: 'end' })\n            }\n        ]);\n    }\n    const sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n    if (isDatumDef(fieldOrDatumDef)) {\n        const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n        return makeImplicit(d);\n    }\n    const fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n    if (domain === 'unaggregated') {\n        const data = model.requestDataName(DataSourceType.Main);\n        const { field } = fieldOrDatumDef;\n        return makeImplicit([\n            {\n                data,\n                field: vgField({ field, aggregate: 'min' })\n            },\n            {\n                data,\n                field: vgField({ field, aggregate: 'max' })\n            }\n        ]);\n    }\n    else if (isBinning(fieldDef.bin)) {\n        if (hasDiscreteDomain(scaleType)) {\n            if (scaleType === 'bin-ordinal') {\n                // we can omit the domain as it is inferred from the `bins` property\n                return makeImplicit([]);\n            }\n            // ordinal bin scale takes domain from bin_range, ordered by bin start\n            // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n            return makeImplicit([\n                {\n                    // If sort by aggregation of a specified sort field, we need to use RAW table,\n                    // so we can aggregate values for the scale independently from the main aggregation.\n                    data: util.isBoolean(sort)\n                        ? model.requestDataName(DataSourceType.Main)\n                        : model.requestDataName(DataSourceType.Raw),\n                    // Use range if we added it and the scale does not support computing a range as a signal.\n                    field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: 'range' } : {}),\n                    // we have to use a sort object if sort = true to make the sort correct by bin start\n                    sort: sort === true || !isObject(sort)\n                        ? {\n                            field: model.vgField(channel, {}),\n                            op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                        }\n                        : sort\n                }\n            ]);\n        }\n        else {\n            // continuous scales\n            const { bin } = fieldDef;\n            if (isBinning(bin)) {\n                const binSignal = getBinSignalName(model, fieldDef.field, bin);\n                return makeImplicit([\n                    new SignalRefWrapper(() => {\n                        const signal = model.getSignalName(binSignal);\n                        return `[${signal}.start, ${signal}.stop]`;\n                    })\n                ]);\n            }\n            else {\n                return makeImplicit([\n                    {\n                        data: model.requestDataName(DataSourceType.Main),\n                        field: model.vgField(channel, {})\n                    }\n                ]);\n            }\n        }\n    }\n    else if (fieldDef.timeUnit &&\n        util.contains(['time', 'utc'], scaleType) &&\n        hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n        const data = model.requestDataName(DataSourceType.Main);\n        return makeImplicit([\n            {\n                data,\n                field: model.vgField(channel)\n            },\n            {\n                data,\n                field: model.vgField(channel, { suffix: 'end' })\n            }\n        ]);\n    }\n    else if (sort) {\n        return makeImplicit([\n            {\n                // If sort by aggregation of a specified sort field, we need to use RAW table,\n                // so we can aggregate values for the scale independently from the main aggregation.\n                data: util.isBoolean(sort)\n                    ? model.requestDataName(DataSourceType.Main)\n                    : model.requestDataName(DataSourceType.Raw),\n                field: model.vgField(channel),\n                sort: sort\n            }\n        ]);\n    }\n    else {\n        return makeImplicit([\n            {\n                data: model.requestDataName(DataSourceType.Main),\n                field: model.vgField(channel)\n            }\n        ]);\n    }\n}\nfunction normalizeSortField(sort, isStackedMeasure) {\n    const { op, field, order } = sort;\n    return Object.assign(Object.assign({ \n        // Apply default op\n        op: op !== null && op !== void 0 ? op : (isStackedMeasure ? 'sum' : DEFAULT_SORT_OP) }, (field ? { field: util.replacePathInField(field) } : {})), (order ? { order } : {}));\n}\nfunction parseSelectionDomain(model, channel) {\n    var _a;\n    const scale = model.component.scales[channel];\n    const spec = model.specifiedScales[channel].domain;\n    const bin = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;\n    const domain = isParameterDomain(spec) && spec;\n    const extent = isBinParams(bin) && isParameterExtent(bin.extent) && bin.extent;\n    if (domain || extent) {\n        // As scale parsing occurs before selection parsing, we cannot set\n        // domainRaw directly. So instead, we store the selectionExtent on\n        // the scale component, and then add domainRaw during scale assembly.\n        scale.set('selectionExtent', domain !== null && domain !== void 0 ? domain : extent, true);\n    }\n}\nexport function domainSort(model, channel, scaleType) {\n    if (!hasDiscreteDomain(scaleType)) {\n        return undefined;\n    }\n    // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n    const fieldDef = model.fieldDef(channel);\n    const sort = fieldDef.sort;\n    // if the sort is specified with array, use the derived sort index field\n    if (isSortArray(sort)) {\n        return {\n            op: 'min',\n            field: sortArrayIndexField(fieldDef, channel),\n            order: 'ascending'\n        };\n    }\n    const { stack } = model;\n    const stackDimensions = stack\n        ? [...(stack.groupbyField ? [stack.groupbyField] : []), ...stack.stackBy.map(s => s.fieldDef.field)]\n        : undefined;\n    // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n    if (isSortField(sort)) {\n        const isStackedMeasure = stack && !util.contains(stackDimensions, sort.field);\n        return normalizeSortField(sort, isStackedMeasure);\n    }\n    else if (isSortByEncoding(sort)) {\n        const { encoding, order } = sort;\n        const fieldDefToSortBy = model.fieldDef(encoding);\n        const { aggregate, field } = fieldDefToSortBy;\n        const isStackedMeasure = stack && !util.contains(stackDimensions, field);\n        if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            return normalizeSortField({\n                field: vgField(fieldDefToSortBy),\n                order\n            }, isStackedMeasure);\n        }\n        else if (isAggregateOp(aggregate) || !aggregate) {\n            return normalizeSortField({\n                op: aggregate,\n                field,\n                order\n            }, isStackedMeasure);\n        }\n    }\n    else if (sort === 'descending') {\n        return {\n            op: 'min',\n            field: model.vgField(channel),\n            order: 'descending'\n        };\n    }\n    else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n        return true;\n    }\n    // sort == null\n    return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n    const { aggregate, type } = fieldDef;\n    if (!aggregate) {\n        return {\n            valid: false,\n            reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n        };\n    }\n    if (isString(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {\n        return {\n            valid: false,\n            reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n        };\n    }\n    if (type === 'quantitative') {\n        if (scaleType === 'log') {\n            return {\n                valid: false,\n                reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n            };\n        }\n    }\n    return { valid: true };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n    if (v1.explicit && v2.explicit) {\n        log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n    }\n    // If equal score, concat the domains so that we union them later.\n    return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains) {\n    const uniqueDomains = util.unique(domains.map(domain => {\n        // ignore sort property when computing the unique domains\n        if (isDataRefDomain(domain)) {\n            const { sort: _s } = domain, domainWithoutSort = __rest(domain, [\"sort\"]);\n            return domainWithoutSort;\n        }\n        return domain;\n    }), util.hash);\n    const sorts = util.unique(domains\n        .map(d => {\n        if (isDataRefDomain(d)) {\n            const s = d.sort;\n            if (s !== undefined && !util.isBoolean(s)) {\n                if ('op' in s && s.op === 'count') {\n                    // let's make sure that if op is count, we don't use a field\n                    delete s.field;\n                }\n                if (s.order === 'ascending') {\n                    // drop order: ascending as it is the default\n                    delete s.order;\n                }\n            }\n            return s;\n        }\n        return undefined;\n    })\n        .filter(s => s !== undefined), util.hash);\n    if (uniqueDomains.length === 0) {\n        return undefined;\n    }\n    else if (uniqueDomains.length === 1) {\n        const domain = domains[0];\n        if (isDataRefDomain(domain) && sorts.length > 0) {\n            let sort = sorts[0];\n            if (sorts.length > 1) {\n                log.warn(log.message.MORE_THAN_ONE_SORT);\n                sort = true;\n            }\n            else {\n                // Simplify domain sort by removing field and op when the field is the same as the domain field.\n                if (isObject(sort) && 'field' in sort) {\n                    const sortField = sort.field;\n                    if (domain.field === sortField) {\n                        sort = sort.order ? { order: sort.order } : true;\n                    }\n                }\n            }\n            return Object.assign(Object.assign({}, domain), { sort });\n        }\n        return domain;\n    }\n    // only keep sort properties that work with unioned domains\n    const unionDomainSorts = util.unique(sorts.map(s => {\n        if (util.isBoolean(s) || !('op' in s) || (isString(s.op) && s.op in UNIONDOMAIN_SORT_OP_INDEX)) {\n            return s;\n        }\n        log.warn(log.message.domainSortDropped(s));\n        return true;\n    }), util.hash);\n    let sort;\n    if (unionDomainSorts.length === 1) {\n        sort = unionDomainSorts[0];\n    }\n    else if (unionDomainSorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n    }\n    const allData = util.unique(domains.map(d => {\n        if (isDataRefDomain(d)) {\n            return d.data;\n        }\n        return null;\n    }), x => x);\n    if (allData.length === 1 && allData[0] !== null) {\n        // create a union domain of different fields with a single data source\n        const domain = Object.assign({ data: allData[0], fields: uniqueDomains.map(d => d.field) }, (sort ? { sort } : {}));\n        return domain;\n    }\n    return Object.assign({ fields: uniqueDomains }, (sort ? { sort } : {}));\n}\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\nexport function getFieldFromDomain(domain) {\n    if (isDataRefDomain(domain) && isString(domain.field)) {\n        return domain.field;\n    }\n    else if (isDataRefUnionedDomain(domain)) {\n        let field;\n        for (const nonUnionDomain of domain.fields) {\n            if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n                if (!field) {\n                    field = nonUnionDomain.field;\n                }\n                else if (field !== nonUnionDomain.field) {\n                    log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n                    return field;\n                }\n            }\n        }\n        log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n        return field;\n    }\n    else if (isFieldRefUnionDomain(domain)) {\n        log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n        const field = domain.fields[0];\n        return isString(field) ? field : undefined;\n    }\n    return undefined;\n}\nexport function assembleDomain(model, channel) {\n    const scaleComponent = model.component.scales[channel];\n    const domains = scaleComponent.get('domains').map((domain) => {\n        // Correct references to data as the original domain's data was determined\n        // in parseScale, which happens before parseData. Thus the original data\n        // reference can be incorrect.\n        if (isDataRefDomain(domain)) {\n            domain.data = model.lookupDataSource(domain.data);\n        }\n        return domain;\n    });\n    // domains is an array that has to be merged into a single vega domain\n    return mergeDomains(domains);\n}\n//# sourceMappingURL=domain.js.map"]},"metadata":{},"sourceType":"module"}