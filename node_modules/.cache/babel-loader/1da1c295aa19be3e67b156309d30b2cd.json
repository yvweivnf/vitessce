{"ast":null,"code":"import { extent } from 'd3-array';\nimport range from 'lodash/range';\nimport clustersSchema from '../schemas/clusters.schema.json';\nimport JsonLoader from './JsonLoader';\nimport { AbstractLoaderError } from './errors';\nimport LoaderResult from './LoaderResult';\nexport default class ClustersJsonAsMatrixZarrLoader extends JsonLoader {\n  constructor(dataSource, params) {\n    super(dataSource, params);\n    this.schema = clustersSchema;\n  }\n\n  async load() {\n    const payload = await super.load().catch(reason => Promise.resolve(reason));\n\n    if (payload instanceof AbstractLoaderError) {\n      return Promise.reject(payload);\n    }\n\n    const {\n      data,\n      url\n    } = payload;\n    const {\n      rows,\n      cols,\n      matrix\n    } = data;\n    const attrs = {\n      rows: cols,\n      cols: rows\n    };\n    const shape = [attrs.rows.length, attrs.cols.length]; // Normalize values by converting to one-byte integers.\n    // Normalize for each gene (column) independently.\n\n    const normalizedMatrix = matrix.map(col => {\n      const [min, max] = extent(col);\n\n      const normalize = d => Math.floor((d - min) / (max - min) * 255);\n\n      return col.map(normalize);\n    }); // Transpose the normalized matrix.\n\n    const tNormalizedMatrix = range(shape[0]).map(i => range(shape[1]).map(j => normalizedMatrix[j][i])); // Flatten the transposed matrix.\n\n    const normalizedFlatMatrix = tNormalizedMatrix.flat(); // Need to wrap the NestedArray to mock the HTTPStore-based array\n    // which returns promises.\n\n    const arr = {\n      data: Uint8Array.from(normalizedFlatMatrix)\n    };\n    return Promise.resolve(new LoaderResult([attrs, arr], url));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/ClustersJsonAsMatrixZarrLoader.js"],"names":["extent","range","clustersSchema","JsonLoader","AbstractLoaderError","LoaderResult","ClustersJsonAsMatrixZarrLoader","constructor","dataSource","params","schema","load","payload","catch","reason","Promise","resolve","reject","data","url","rows","cols","matrix","attrs","shape","length","normalizedMatrix","map","col","min","max","normalize","d","Math","floor","tNormalizedMatrix","i","j","normalizedFlatMatrix","flat","arr","Uint8Array","from"],"mappings":"AAAA,SAASA,MAAT,QAAuB,UAAvB;AACA,OAAOC,KAAP,MAAkB,cAAlB;AACA,OAAOC,cAAP,MAA2B,iCAA3B;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,SAASC,mBAAT,QAAoC,UAApC;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AAEA,eAAe,MAAMC,8BAAN,SAA6CH,UAA7C,CAAwD;AACrEI,EAAAA,WAAW,CAACC,UAAD,EAAaC,MAAb,EAAqB;AAC9B,UAAMD,UAAN,EAAkBC,MAAlB;AAEA,SAAKC,MAAL,GAAcR,cAAd;AACD;;AAED,QAAMS,IAAN,GAAa;AACX,UAAMC,OAAO,GAAG,MAAM,MAAMD,IAAN,GAAaE,KAAb,CAAmBC,MAAM,IAAIC,OAAO,CAACC,OAAR,CAAgBF,MAAhB,CAA7B,CAAtB;;AACA,QAAIF,OAAO,YAAYR,mBAAvB,EAA4C;AAC1C,aAAOW,OAAO,CAACE,MAAR,CAAeL,OAAf,CAAP;AACD;;AACD,UAAM;AAAEM,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAgBP,OAAtB;AACA,UAAM;AAAEQ,MAAAA,IAAF;AAAQC,MAAAA,IAAR;AAAcC,MAAAA;AAAd,QAAyBJ,IAA/B;AACA,UAAMK,KAAK,GAAG;AACZH,MAAAA,IAAI,EAAEC,IADM;AAEZA,MAAAA,IAAI,EAAED;AAFM,KAAd;AAIA,UAAMI,KAAK,GAAG,CAACD,KAAK,CAACH,IAAN,CAAWK,MAAZ,EAAoBF,KAAK,CAACF,IAAN,CAAWI,MAA/B,CAAd,CAXW,CAYX;AACA;;AACA,UAAMC,gBAAgB,GAAGJ,MAAM,CAACK,GAAP,CAAYC,GAAD,IAAS;AAC3C,YAAM,CAACC,GAAD,EAAMC,GAAN,IAAa9B,MAAM,CAAC4B,GAAD,CAAzB;;AACA,YAAMG,SAAS,GAAGC,CAAC,IAAIC,IAAI,CAACC,KAAL,CAAY,CAACF,CAAC,GAAGH,GAAL,KAAaC,GAAG,GAAGD,GAAnB,CAAD,GAA4B,GAAvC,CAAvB;;AACA,aAAOD,GAAG,CAACD,GAAJ,CAAQI,SAAR,CAAP;AACD,KAJwB,CAAzB,CAdW,CAmBX;;AACA,UAAMI,iBAAiB,GAAGlC,KAAK,CAACuB,KAAK,CAAC,CAAD,CAAN,CAAL,CACvBG,GADuB,CACnBS,CAAC,IAAInC,KAAK,CAACuB,KAAK,CAAC,CAAD,CAAN,CAAL,CAAgBG,GAAhB,CAAoBU,CAAC,IAAIX,gBAAgB,CAACW,CAAD,CAAhB,CAAoBD,CAApB,CAAzB,CADc,CAA1B,CApBW,CAsBX;;AACA,UAAME,oBAAoB,GAAGH,iBAAiB,CAACI,IAAlB,EAA7B,CAvBW,CAwBX;AACA;;AACA,UAAMC,GAAG,GAAG;AAAEtB,MAAAA,IAAI,EAAEuB,UAAU,CAACC,IAAX,CAAgBJ,oBAAhB;AAAR,KAAZ;AACA,WAAOvB,OAAO,CAACC,OAAR,CAAgB,IAAIX,YAAJ,CAAiB,CAACkB,KAAD,EAAQiB,GAAR,CAAjB,EAA+BrB,GAA/B,CAAhB,CAAP;AACD;;AAnCoE","sourcesContent":["import { extent } from 'd3-array';\nimport range from 'lodash/range';\nimport clustersSchema from '../schemas/clusters.schema.json';\nimport JsonLoader from './JsonLoader';\nimport { AbstractLoaderError } from './errors';\nimport LoaderResult from './LoaderResult';\n\nexport default class ClustersJsonAsMatrixZarrLoader extends JsonLoader {\n  constructor(dataSource, params) {\n    super(dataSource, params);\n\n    this.schema = clustersSchema;\n  }\n\n  async load() {\n    const payload = await super.load().catch(reason => Promise.resolve(reason));\n    if (payload instanceof AbstractLoaderError) {\n      return Promise.reject(payload);\n    }\n    const { data, url } = payload;\n    const { rows, cols, matrix } = data;\n    const attrs = {\n      rows: cols,\n      cols: rows,\n    };\n    const shape = [attrs.rows.length, attrs.cols.length];\n    // Normalize values by converting to one-byte integers.\n    // Normalize for each gene (column) independently.\n    const normalizedMatrix = matrix.map((col) => {\n      const [min, max] = extent(col);\n      const normalize = d => Math.floor(((d - min) / (max - min)) * 255);\n      return col.map(normalize);\n    });\n    // Transpose the normalized matrix.\n    const tNormalizedMatrix = range(shape[0])\n      .map(i => range(shape[1]).map(j => normalizedMatrix[j][i]));\n    // Flatten the transposed matrix.\n    const normalizedFlatMatrix = tNormalizedMatrix.flat();\n    // Need to wrap the NestedArray to mock the HTTPStore-based array\n    // which returns promises.\n    const arr = { data: Uint8Array.from(normalizedFlatMatrix) };\n    return Promise.resolve(new LoaderResult([attrs, arr], url));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}