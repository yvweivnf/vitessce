{"ast":null,"code":"import { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class CalculateNode extends DataFlowNode {\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  static parseAllForSortIndex(parent, model) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n\n      if (isSortArray(fieldDef.sort)) {\n        const {\n          field,\n          timeUnit\n        } = fieldDef;\n        const sort = fieldDef.sort; // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n\n        const calculate = sort.map((sortValue, i) => {\n          return `${fieldFilterExpression({\n            field,\n            timeUnit,\n            equal: sortValue\n          })} ? ${i} : `;\n        }).join('') + sort.length;\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {\n            forAs: true\n          })\n        });\n      }\n    });\n    return parent;\n  }\n\n  producedFields() {\n    return new Set([this.transform.as]);\n  }\n\n  dependentFields() {\n    return this._dependentFields;\n  }\n\n  assemble() {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n\n}\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n  return vgField(fieldDef, Object.assign({\n    prefix: channel,\n    suffix: 'sort_index'\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}","map":{"version":3,"sources":["../../../../src/compile/data/calculate.ts"],"names":[],"mappings":"AAEA,SAAwB,eAAxB,EAAwD,OAAxD,QAAsE,kBAAtE;AAEA,SAAQ,qBAAR,QAAoC,iBAApC;AACA,SAAQ,WAAR,QAA0B,YAA1B;AAEA,SAAQ,SAAR,EAAmB,IAAnB,QAA8B,YAA9B;AAEA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,kBAAR,QAAiC,eAAjC;AAEA,OAAM,MAAO,aAAP,SAA6B,YAA7B,CAAyC;AAO7C,EAAA,WAAA,CAAY,MAAZ,EAAmD,SAAnD,EAAgF;AAC9E,UAAM,MAAN;AADiD,SAAA,SAAA,GAAA,SAAA;AAGjD,SAAK,gBAAL,GAAwB,kBAAkB,CAAC,KAAK,SAAL,CAAe,SAAhB,CAA1C;AACD;;AARM,EAAA,KAAK,GAAA;AACV,WAAO,IAAI,aAAJ,CAAkB,IAAlB,EAAwB,SAAS,CAAC,KAAK,SAAN,CAAjC,CAAP;AACD;;AAQM,SAAO,oBAAP,CAA4B,MAA5B,EAAkD,KAAlD,EAAuE;AAC5E;AACA,IAAA,KAAK,CAAC,eAAN,CAAsB,CAAC,QAAD,EAAkC,OAAlC,KAA+D;AACnF,UAAI,CAAC,eAAe,CAAC,QAAD,CAApB,EAAgC;AAC9B;AACD;;AACD,UAAI,WAAW,CAAC,QAAQ,CAAC,IAAV,CAAf,EAAgC;AAC9B,cAAM;AAAC,UAAA,KAAD;AAAQ,UAAA;AAAR,YAAoB,QAA1B;AACA,cAAM,IAAI,GAA6C,QAAQ,CAAC,IAAhE,CAF8B,CAG9B;;AACA,cAAM,SAAS,GACb,IAAI,CACD,GADH,CACO,CAAC,SAAD,EAAY,CAAZ,KAAiB;AACpB,iBAAO,GAAG,qBAAqB,CAAC;AAAC,YAAA,KAAD;AAAQ,YAAA,QAAR;AAAkB,YAAA,KAAK,EAAE;AAAzB,WAAD,CAAqC,MAAM,CAAC,KAA3E;AACD,SAHH,EAIG,IAJH,CAIQ,EAJR,IAIc,IAAI,CAAC,MALrB;AAOA,QAAA,MAAM,GAAG,IAAI,aAAJ,CAAkB,MAAlB,EAA0B;AACjC,UAAA,SADiC;AAEjC,UAAA,EAAE,EAAE,mBAAmB,CAAC,QAAD,EAAW,OAAX,EAAoB;AAAC,YAAA,KAAK,EAAE;AAAR,WAApB;AAFU,SAA1B,CAAT;AAID;AACF,KApBD;AAqBA,WAAO,MAAP;AACD;;AAEM,EAAA,cAAc,GAAA;AACnB,WAAO,IAAI,GAAJ,CAAQ,CAAC,KAAK,SAAL,CAAe,EAAhB,CAAR,CAAP;AACD;;AAEM,EAAA,eAAe,GAAA;AACpB,WAAO,KAAK,gBAAZ;AACD;;AAEM,EAAA,QAAQ,GAAA;AACb,WAAO;AACL,MAAA,IAAI,EAAE,SADD;AAEL,MAAA,IAAI,EAAE,KAAK,SAAL,CAAe,SAFhB;AAGL,MAAA,EAAE,EAAE,KAAK,SAAL,CAAe;AAHd,KAAP;AAKD;;AAEM,EAAA,IAAI,GAAA;AACT,WAAO,aAAa,IAAI,CAAC,KAAK,SAAN,CAAgB,EAAxC;AACD;;AAzD4C;AA4D/C,OAAM,SAAU,mBAAV,CAA8B,QAA9B,EAA+D,OAA/D,EAA0F,GAA1F,EAA8G;AAClH,SAAO,OAAO,CAAC,QAAD,EAAS,MAAA,CAAA,MAAA,CAAA;AAAG,IAAA,MAAM,EAAE,OAAX;AAAoB,IAAA,MAAM,EAAE;AAA5B,GAAA,EAA8C,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAA,GAAA,GAAO,EAArD,CAAT,CAAd;AACD","sourceRoot":"","sourcesContent":["import { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class CalculateNode extends DataFlowNode {\n    constructor(parent, transform) {\n        super(parent);\n        this.transform = transform;\n        this._dependentFields = getDependentFields(this.transform.calculate);\n    }\n    clone() {\n        return new CalculateNode(null, duplicate(this.transform));\n    }\n    static parseAllForSortIndex(parent, model) {\n        // get all the encoding with sort fields from model\n        model.forEachFieldDef((fieldDef, channel) => {\n            if (!isScaleFieldDef(fieldDef)) {\n                return;\n            }\n            if (isSortArray(fieldDef.sort)) {\n                const { field, timeUnit } = fieldDef;\n                const sort = fieldDef.sort;\n                // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n                const calculate = sort\n                    .map((sortValue, i) => {\n                    return `${fieldFilterExpression({ field, timeUnit, equal: sortValue })} ? ${i} : `;\n                })\n                    .join('') + sort.length;\n                parent = new CalculateNode(parent, {\n                    calculate,\n                    as: sortArrayIndexField(fieldDef, channel, { forAs: true })\n                });\n            }\n        });\n        return parent;\n    }\n    producedFields() {\n        return new Set([this.transform.as]);\n    }\n    dependentFields() {\n        return this._dependentFields;\n    }\n    assemble() {\n        return {\n            type: 'formula',\n            expr: this.transform.calculate,\n            as: this.transform.as\n        };\n    }\n    hash() {\n        return `Calculate ${hash(this.transform)}`;\n    }\n}\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n    return vgField(fieldDef, Object.assign({ prefix: channel, suffix: 'sort_index' }, (opt !== null && opt !== void 0 ? opt : {})));\n}\n//# sourceMappingURL=calculate.js.map"]},"metadata":{},"sourceType":"module"}