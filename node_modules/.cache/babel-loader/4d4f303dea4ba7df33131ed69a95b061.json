{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './project';\nimport scales from './scales';\nexport var BRUSH = '_brush';\nexport var SCALE_TRIGGER = '_scale_trigger';\nvar interval = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'interval';\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var fieldsSg = name + TUPLE_FIELDS;\n    var hasScales = scales.defined(selCmpt);\n    var init = selCmpt.init ? selCmpt.init[0] : null;\n    var dataSignals = [];\n    var scaleTriggers = [];\n\n    if (selCmpt.translate && !hasScales) {\n      var filterExpr = \"!event.item || event.item.mark.name !== \".concat(stringValue(name + BRUSH));\n      events(selCmpt, function (on, evt) {\n        var _a;\n\n        var _b;\n\n        var filters = array((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : _b.filter = []);\n\n        if (!filters.includes(filterExpr)) {\n          filters.push(filterExpr);\n        }\n\n        return on;\n      });\n    }\n\n    selCmpt.project.items.forEach(function (proj, i) {\n      var channel = proj.channel;\n\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      var val = init ? init[i] : null;\n      var cs = channelSignals(model, selCmpt, proj, val);\n      var dname = proj.signals.data;\n      var vname = proj.signals.visual;\n      var scaleName = stringValue(model.scaleName(channel));\n      var scaleType = model.getScaleComponent(channel).get('type');\n      var toNum = hasContinuousDomain(scaleType) ? '+' : '';\n\n      _signals.push.apply(_signals, _toConsumableArray(cs));\n\n      dataSignals.push(dname);\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr: \"(!isArray(\".concat(dname, \") || \") + \"(\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[0] === \").concat(toNum).concat(dname, \"[0] && \") + \"\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[1] === \").concat(toNum).concat(dname, \"[1]))\")\n      });\n    }); // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n\n    if (!hasScales && scaleTriggers.length) {\n      _signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [{\n          events: scaleTriggers.map(function (t) {\n            return {\n              scale: t.scaleName\n            };\n          }),\n          update: \"\".concat(scaleTriggers.map(function (t) {\n            return t.expr;\n          }).join(' && '), \" ? \").concat(name + SCALE_TRIGGER, \" : {}\")\n        }]\n      });\n    } // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n\n\n    var update = \"unit: \".concat(unitName(model), \", fields: \").concat(fieldsSg, \", values\");\n    return _signals.concat(Object.assign(Object.assign({\n      name: name + TUPLE\n    }, init ? {\n      init: \"{\".concat(update, \": \").concat(assembleInit(init), \"}\")\n    } : {}), dataSignals.length ? {\n      on: [{\n        events: [{\n          signal: dataSignals.join(' || ')\n        }],\n        update: \"\".concat(dataSignals.join(' && '), \" ? {\").concat(update, \": [\").concat(dataSignals, \"]} : null\")\n      }]\n    } : {}));\n  },\n  marks: function marks(model, selCmpt, _marks) {\n    var name = selCmpt.name;\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n        x = _selCmpt$project$hasC.x,\n        y = _selCmpt$project$hasC.y;\n    var xvname = x && x.signals.visual;\n    var yvname = y && y.signals.visual;\n    var store = \"data(\".concat(stringValue(selCmpt.name + STORE), \")\"); // Do not add a brush if we're binding to scales\n    // or we don't have a valid interval projection\n\n    if (scales.defined(selCmpt) || !x && !y) {\n      return _marks;\n    }\n\n    var update = {\n      x: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      y: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      x2: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[1]\")\n      } : {\n        field: {\n          group: 'width'\n        }\n      },\n      y2: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[1]\")\n      } : {\n        field: {\n          group: 'height'\n        }\n      }\n    }; // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n\n    if (selCmpt.resolve === 'global') {\n      var _iterator = _createForOfIteratorHelper(keys(update)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          update[key] = [Object.assign({\n            test: \"\".concat(store, \".length && \").concat(store, \"[0].unit === \").concat(unitName(model))\n          }, update[key]), {\n            value: 0\n          }];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n\n\n    var _a = selCmpt.mark,\n        fill = _a.fill,\n        fillOpacity = _a.fillOpacity,\n        cursor = _a.cursor,\n        stroke = __rest(_a, [\"fill\", \"fillOpacity\", \"cursor\"]);\n\n    var vgStroke = keys(stroke).reduce(function (def, k) {\n      def[k] = [{\n        test: [x !== undefined && \"\".concat(xvname, \"[0] !== \").concat(xvname, \"[1]\"), y !== undefined && \"\".concat(yvname, \"[0] !== \").concat(yvname, \"[1]\")].filter(function (t) {\n          return t;\n        }).join(' && '),\n        value: stroke[k]\n      }, {\n        value: null\n      }];\n      return def;\n    }, {});\n    return [{\n      name: \"\".concat(name + BRUSH, \"_bg\"),\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: fill\n          },\n          fillOpacity: {\n            value: fillOpacity\n          }\n        },\n        update: update\n      }\n    }].concat(_toConsumableArray(_marks), [{\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: Object.assign(Object.assign({}, cursor ? {\n          cursor: {\n            value: cursor\n          }\n        } : {}), {\n          fill: {\n            value: 'transparent'\n          }\n        }),\n        update: Object.assign(Object.assign({}, update), vgStroke)\n      }\n    }]);\n  }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\n\nfunction channelSignals(model, selCmpt, proj, init) {\n  var channel = proj.channel;\n  var vname = proj.signals.visual;\n  var dname = proj.signals.data;\n  var hasScales = scales.defined(selCmpt);\n  var scaleName = stringValue(model.scaleName(channel));\n  var scale = model.getScaleComponent(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n\n  var scaled = function scaled(str) {\n    return \"scale(\".concat(scaleName, \", \").concat(str, \")\");\n  };\n\n  var size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  var coord = \"\".concat(channel, \"(unit)\");\n  var on = events(selCmpt, function (def, evt) {\n    return [].concat(_toConsumableArray(def), [{\n      events: evt.between[0],\n      update: \"[\".concat(coord, \", \").concat(coord, \"]\")\n    }, {\n      events: evt,\n      update: \"[\".concat(vname, \"[0], clamp(\").concat(coord, \", 0, \").concat(size, \")]\")\n    } // Brush End\n    ]);\n  }); // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n\n  on.push({\n    events: {\n      signal: selCmpt.name + SCALE_TRIGGER\n    },\n    update: hasContinuousDomain(scaleType) ? \"[\".concat(scaled(\"\".concat(dname, \"[0]\")), \", \").concat(scaled(\"\".concat(dname, \"[1]\")), \"]\") : \"[0, 0]\"\n  });\n  return hasScales ? [{\n    name: dname,\n    on: []\n  }] : [Object.assign(Object.assign({\n    name: vname\n  }, init ? {\n    init: assembleInit(init, true, scaled)\n  } : {\n    value: []\n  }), {\n    on: on\n  }), Object.assign(Object.assign({\n    name: dname\n  }, init ? {\n    init: assembleInit(init)\n  } : {}), {\n    on: [{\n      events: {\n        signal: vname\n      },\n      update: \"\".concat(vname, \"[0] === \").concat(vname, \"[1] ? null : invert(\").concat(scaleName, \", \").concat(vname, \")\")\n    }]\n  })];\n}\n\nfunction events(selCmpt, cb) {\n  return selCmpt.events.reduce(function (on, evt) {\n    if (!evt.between) {\n      warn(\"\".concat(evt, \" is not an ordered event stream for interval selections.\"));\n      return on;\n    }\n\n    return cb(on, evt);\n  }, []);\n}","map":{"version":3,"sources":["../../../../src/compile/selection/interval.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './project';\nimport scales from './scales';\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\nconst interval = {\n    defined: selCmpt => selCmpt.type === 'interval',\n    signals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const fieldsSg = name + TUPLE_FIELDS;\n        const hasScales = scales.defined(selCmpt);\n        const init = selCmpt.init ? selCmpt.init[0] : null;\n        const dataSignals = [];\n        const scaleTriggers = [];\n        if (selCmpt.translate && !hasScales) {\n            const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n            events(selCmpt, (on, evt) => {\n                var _a;\n                var _b;\n                const filters = array(((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : (_b.filter = [])));\n                if (!filters.includes(filterExpr)) {\n                    filters.push(filterExpr);\n                }\n                return on;\n            });\n        }\n        selCmpt.project.items.forEach((proj, i) => {\n            const channel = proj.channel;\n            if (channel !== X && channel !== Y) {\n                warn('Interval selections only support x and y encoding channels.');\n                return;\n            }\n            const val = init ? init[i] : null;\n            const cs = channelSignals(model, selCmpt, proj, val);\n            const dname = proj.signals.data;\n            const vname = proj.signals.visual;\n            const scaleName = stringValue(model.scaleName(channel));\n            const scaleType = model.getScaleComponent(channel).get('type');\n            const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n            signals.push(...cs);\n            dataSignals.push(dname);\n            scaleTriggers.push({\n                scaleName: model.scaleName(channel),\n                expr: `(!isArray(${dname}) || ` +\n                    `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n                    `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`\n            });\n        });\n        // Proxy scale reactions to ensure that an infinite loop doesn't occur\n        // when an interval selection filter touches the scale.\n        if (!hasScales && scaleTriggers.length) {\n            signals.push({\n                name: name + SCALE_TRIGGER,\n                value: {},\n                on: [\n                    {\n                        events: scaleTriggers.map(t => ({ scale: t.scaleName })),\n                        update: `${scaleTriggers.map(t => t.expr).join(' && ')} ? ${name + SCALE_TRIGGER} : {}`\n                    }\n                ]\n            });\n        }\n        // Only add an interval to the store if it has valid data extents. Data extents\n        // are set to null if pixel extents are equal to account for intervals over\n        // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n        const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n        return signals.concat(Object.assign(Object.assign({ name: name + TUPLE }, (init ? { init: `{${update}: ${assembleInit(init)}}` } : {})), (dataSignals.length\n            ? {\n                on: [\n                    {\n                        events: [{ signal: dataSignals.join(' || ') }],\n                        update: `${dataSignals.join(' && ')} ? {${update}: [${dataSignals}]} : null`\n                    }\n                ]\n            }\n            : {})));\n    },\n    marks: (model, selCmpt, marks) => {\n        const name = selCmpt.name;\n        const { x, y } = selCmpt.project.hasChannel;\n        const xvname = x && x.signals.visual;\n        const yvname = y && y.signals.visual;\n        const store = `data(${stringValue(selCmpt.name + STORE)})`;\n        // Do not add a brush if we're binding to scales\n        // or we don't have a valid interval projection\n        if (scales.defined(selCmpt) || (!x && !y)) {\n            return marks;\n        }\n        const update = {\n            x: x !== undefined ? { signal: `${xvname}[0]` } : { value: 0 },\n            y: y !== undefined ? { signal: `${yvname}[0]` } : { value: 0 },\n            x2: x !== undefined ? { signal: `${xvname}[1]` } : { field: { group: 'width' } },\n            y2: y !== undefined ? { signal: `${yvname}[1]` } : { field: { group: 'height' } }\n        };\n        // If the selection is resolved to global, only a single interval is in\n        // the store. Wrap brush mark's encodings with a production rule to test\n        // this based on the `unit` property. Hide the brush mark if it corresponds\n        // to a unit different from the one in the store.\n        if (selCmpt.resolve === 'global') {\n            for (const key of keys(update)) {\n                update[key] = [\n                    Object.assign({ test: `${store}.length && ${store}[0].unit === ${unitName(model)}` }, update[key]),\n                    { value: 0 }\n                ];\n            }\n        }\n        // Two brush marks ensure that fill colors and other aesthetic choices do\n        // not interefere with the core marks, but that the brushed region can still\n        // be interacted with (e.g., dragging it around).\n        const _a = selCmpt.mark, { fill, fillOpacity, cursor } = _a, stroke = __rest(_a, [\"fill\", \"fillOpacity\", \"cursor\"]);\n        const vgStroke = keys(stroke).reduce((def, k) => {\n            def[k] = [\n                {\n                    test: [x !== undefined && `${xvname}[0] !== ${xvname}[1]`, y !== undefined && `${yvname}[0] !== ${yvname}[1]`]\n                        .filter(t => t)\n                        .join(' && '),\n                    value: stroke[k]\n                },\n                { value: null }\n            ];\n            return def;\n        }, {});\n        return [\n            {\n                name: `${name + BRUSH}_bg`,\n                type: 'rect',\n                clip: true,\n                encode: {\n                    enter: {\n                        fill: { value: fill },\n                        fillOpacity: { value: fillOpacity }\n                    },\n                    update: update\n                }\n            },\n            ...marks,\n            {\n                name: name + BRUSH,\n                type: 'rect',\n                clip: true,\n                encode: {\n                    enter: Object.assign(Object.assign({}, (cursor ? { cursor: { value: cursor } } : {})), { fill: { value: 'transparent' } }),\n                    update: Object.assign(Object.assign({}, update), vgStroke)\n                }\n            }\n        ];\n    }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(model, selCmpt, proj, init) {\n    const channel = proj.channel;\n    const vname = proj.signals.visual;\n    const dname = proj.signals.data;\n    const hasScales = scales.defined(selCmpt);\n    const scaleName = stringValue(model.scaleName(channel));\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const scaled = (str) => `scale(${scaleName}, ${str})`;\n    const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n    const coord = `${channel}(unit)`;\n    const on = events(selCmpt, (def, evt) => {\n        return [\n            ...def,\n            { events: evt.between[0], update: `[${coord}, ${coord}]` },\n            { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]` } // Brush End\n        ];\n    });\n    // React to pan/zooms of continuous scales. Non-continuous scales\n    // (band, point) cannot be pan/zoomed and any other changes\n    // to their domains (e.g., filtering) should clear the brushes.\n    on.push({\n        events: { signal: selCmpt.name + SCALE_TRIGGER },\n        update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n    });\n    return hasScales\n        ? [{ name: dname, on: [] }]\n        : [\n            Object.assign(Object.assign({ name: vname }, (init ? { init: assembleInit(init, true, scaled) } : { value: [] })), { on: on }),\n            Object.assign(Object.assign({ name: dname }, (init ? { init: assembleInit(init) } : {})), { on: [\n                    {\n                        events: { signal: vname },\n                        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n                    }\n                ] })\n        ];\n}\nfunction events(selCmpt, cb) {\n    return selCmpt.events.reduce((on, evt) => {\n        if (!evt.between) {\n            warn(`${evt} is not an ordered event stream for interval selections.`);\n            return on;\n        }\n        return cb(on, evt);\n    }, []);\n}\n//# sourceMappingURL=interval.js.map"]},"metadata":{},"sourceType":"module"}