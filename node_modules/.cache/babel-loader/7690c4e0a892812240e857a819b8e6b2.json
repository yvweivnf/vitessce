{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { assert } from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport { getImageSize } from '../category-api/parsed-image-api';\nimport { generateUrl } from './generate-url';\nimport { deepLoad, shallowLoad } from './deep-load';\nexport function loadImage(_x) {\n  return _loadImage.apply(this, arguments);\n}\n\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(getUrl) {\n    var options,\n        imageUrls,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _context.next = 3;\n            return getImageUrls(getUrl, options);\n\n          case 3:\n            imageUrls = _context.sent;\n            _context.next = 6;\n            return deepLoad(imageUrls, parseImage, options);\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadImage.apply(this, arguments);\n}\n\nexport function getImageUrls(_x2, _x3) {\n  return _getImageUrls.apply(this, arguments);\n}\n\nfunction _getImageUrls() {\n  _getImageUrls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(getUrl, options) {\n    var urlOptions,\n        mipLevels,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            urlOptions = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n            mipLevels = options && options.image && options.image.mipLevels || 0;\n\n            if (!(mipLevels !== 0)) {\n              _context2.next = 8;\n              break;\n            }\n\n            _context2.next = 5;\n            return getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions);\n\n          case 5:\n            _context2.t0 = _context2.sent;\n            _context2.next = 9;\n            break;\n\n          case 8:\n            _context2.t0 = generateUrl(getUrl, options, urlOptions);\n\n          case 9:\n            return _context2.abrupt(\"return\", _context2.t0);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getImageUrls.apply(this, arguments);\n}\n\nfunction getMipmappedImageUrls(_x4, _x5, _x6, _x7) {\n  return _getMipmappedImageUrls.apply(this, arguments);\n}\n\nfunction _getMipmappedImageUrls() {\n  _getMipmappedImageUrls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(getUrl, mipLevels, options, urlOptions) {\n    var urls, url, image, _getImageSize, width, height, mipLevel, _url;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            urls = [];\n\n            if (!(mipLevels === 'auto')) {\n              _context3.next = 9;\n              break;\n            }\n\n            url = generateUrl(getUrl, options, _objectSpread({}, urlOptions, {\n              lod: 0\n            }));\n            _context3.next = 5;\n            return shallowLoad(url, parseImage, options);\n\n          case 5:\n            image = _context3.sent;\n            _getImageSize = getImageSize(image), width = _getImageSize.width, height = _getImageSize.height;\n            mipLevels = getMipLevels({\n              width: width,\n              height: height\n            });\n            urls.push(url);\n\n          case 9:\n            assert(mipLevels > 0);\n\n            for (mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n              _url = generateUrl(getUrl, options, _objectSpread({}, urlOptions, {\n                lod: mipLevel\n              }));\n              urls.push(_url);\n            }\n\n            return _context3.abrupt(\"return\", urls);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getMipmappedImageUrls.apply(this, arguments);\n}\n\nexport function getMipLevels(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}","map":{"version":3,"sources":["../../../../src/lib/texture-api/load-image.ts"],"names":["options","imageUrls","getImageUrls","deepLoad","urlOptions","mipLevels","getMipmappedImageUrls","generateUrl","urls","url","lod","image","shallowLoad","height","getImageSize","getMipLevels","width","assert","mipLevel","Math"],"mappings":"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","sourcesContent":["import {assert} from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n"]},"metadata":{},"sourceType":"module"}