{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport DebugLogger from \"debug\";\nimport { multicast, Observable, Subject } from \"observable-fns\";\nimport { allSettled } from \"../ponyfills\";\nimport { defaultPoolSize } from \"./implementation\";\nimport { PoolEventType } from \"./pool-types\";\nimport { Thread } from \"./thread\";\nexport { PoolEventType, Thread };\nlet nextPoolID = 1;\n\nfunction createArray(size) {\n  const array = [];\n\n  for (let index = 0; index < size; index++) {\n    array.push(index);\n  }\n\n  return array;\n}\n\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction flatMap(array, mapper) {\n  return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\n\nfunction slugify(text) {\n  return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\n\nfunction spawnWorkers(spawnWorker, count) {\n  return createArray(count).map(() => ({\n    init: spawnWorker(),\n    runningTasks: []\n  }));\n}\n\nclass WorkerPool {\n  constructor(spawnWorker, optionsOrSize) {\n    this.eventSubject = new Subject();\n    this.initErrors = [];\n    this.isClosing = false;\n    this.nextTaskID = 1;\n    this.taskQueue = [];\n    const options = typeof optionsOrSize === \"number\" ? {\n      size: optionsOrSize\n    } : optionsOrSize || {};\n    const {\n      size = defaultPoolSize\n    } = options;\n    this.debug = DebugLogger(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n    this.options = options;\n    this.workers = spawnWorkers(spawnWorker, size);\n    this.eventObservable = multicast(Observable.from(this.eventSubject));\n    Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n      type: PoolEventType.initialized,\n      size: this.workers.length\n    }), error => {\n      this.debug(\"Error while initializing pool worker:\", error);\n      this.eventSubject.error(error);\n      this.initErrors.push(error);\n    });\n  }\n\n  findIdlingWorker() {\n    const {\n      concurrency = 1\n    } = this.options;\n    return this.workers.find(worker => worker.runningTasks.length < concurrency);\n  }\n\n  runPoolTask(worker, task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const workerID = this.workers.indexOf(worker) + 1;\n      this.debug(`Running task #${task.id} on worker #${workerID}...`);\n      this.eventSubject.next({\n        type: PoolEventType.taskStart,\n        taskID: task.id,\n        workerID\n      });\n\n      try {\n        const returnValue = yield task.run((yield worker.init));\n        this.debug(`Task #${task.id} completed successfully`);\n        this.eventSubject.next({\n          type: PoolEventType.taskCompleted,\n          returnValue,\n          taskID: task.id,\n          workerID\n        });\n      } catch (error) {\n        this.debug(`Task #${task.id} failed`);\n        this.eventSubject.next({\n          type: PoolEventType.taskFailed,\n          taskID: task.id,\n          error,\n          workerID\n        });\n      }\n    });\n  }\n\n  run(worker, task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n        const removeTaskFromWorkersRunningTasks = () => {\n          worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n        }; // Defer task execution by one tick to give handlers time to subscribe\n\n\n        yield delay(0);\n\n        try {\n          yield this.runPoolTask(worker, task);\n        } finally {\n          removeTaskFromWorkersRunningTasks();\n\n          if (!this.isClosing) {\n            this.scheduleWork();\n          }\n        }\n      }))();\n\n      worker.runningTasks.push(runPromise);\n    });\n  }\n\n  scheduleWork() {\n    this.debug(`Attempt de-queueing a task in order to run it...`);\n    const availableWorker = this.findIdlingWorker();\n    if (!availableWorker) return;\n    const nextTask = this.taskQueue.shift();\n\n    if (!nextTask) {\n      this.debug(`Task queue is empty`);\n      this.eventSubject.next({\n        type: PoolEventType.taskQueueDrained\n      });\n      return;\n    }\n\n    this.run(availableWorker, nextTask);\n  }\n\n  taskCompletion(taskID) {\n    return new Promise((resolve, reject) => {\n      const eventSubscription = this.events().subscribe(event => {\n        if (event.type === PoolEventType.taskCompleted && event.taskID === taskID) {\n          eventSubscription.unsubscribe();\n          resolve(event.returnValue);\n        } else if (event.type === PoolEventType.taskFailed && event.taskID === taskID) {\n          eventSubscription.unsubscribe();\n          reject(event.error);\n        } else if (event.type === PoolEventType.terminated) {\n          eventSubscription.unsubscribe();\n          reject(Error(\"Pool has been terminated before task was run.\"));\n        }\n      });\n    });\n  }\n\n  settled(allowResolvingImmediately = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n\n      const taskFailures = [];\n      const failureSubscription = this.eventObservable.subscribe(event => {\n        if (event.type === PoolEventType.taskFailed) {\n          taskFailures.push(event.error);\n        }\n      });\n\n      if (this.initErrors.length > 0) {\n        return Promise.reject(this.initErrors[0]);\n      }\n\n      if (allowResolvingImmediately && this.taskQueue.length === 0) {\n        yield allSettled(getCurrentlyRunningTasks());\n        return taskFailures;\n      }\n\n      yield new Promise((resolve, reject) => {\n        const subscription = this.eventObservable.subscribe({\n          next(event) {\n            if (event.type === PoolEventType.taskQueueDrained) {\n              subscription.unsubscribe();\n              resolve(void 0);\n            }\n          },\n\n          error: reject // make a pool-wide error reject the completed() result promise\n\n        });\n      });\n      yield allSettled(getCurrentlyRunningTasks());\n      failureSubscription.unsubscribe();\n      return taskFailures;\n    });\n  }\n\n  completed(allowResolvingImmediately = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const settlementPromise = this.settled(allowResolvingImmediately);\n      const earlyExitPromise = new Promise((resolve, reject) => {\n        const subscription = this.eventObservable.subscribe({\n          next(event) {\n            if (event.type === PoolEventType.taskQueueDrained) {\n              subscription.unsubscribe();\n              resolve(settlementPromise);\n            } else if (event.type === PoolEventType.taskFailed) {\n              subscription.unsubscribe();\n              reject(event.error);\n            }\n          },\n\n          error: reject // make a pool-wide error reject the completed() result promise\n\n        });\n      });\n      const errors = yield Promise.race([settlementPromise, earlyExitPromise]);\n\n      if (errors.length > 0) {\n        throw errors[0];\n      }\n    });\n  }\n\n  events() {\n    return this.eventObservable;\n  }\n\n  queue(taskFunction) {\n    const {\n      maxQueuedJobs = Infinity\n    } = this.options;\n\n    if (this.isClosing) {\n      throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n    }\n\n    if (this.initErrors.length > 0) {\n      throw this.initErrors[0];\n    }\n\n    const taskID = this.nextTaskID++;\n    const taskCompletion = this.taskCompletion(taskID);\n    taskCompletion.catch(error => {\n      // Prevent unhandled rejections here as we assume the user will use\n      // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n      this.debug(`Task #${taskID} errored:`, error);\n    });\n    const task = {\n      id: taskID,\n      run: taskFunction,\n      cancel: () => {\n        if (this.taskQueue.indexOf(task) === -1) return;\n        this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n        this.eventSubject.next({\n          type: PoolEventType.taskCanceled,\n          taskID: task.id\n        });\n      },\n      then: taskCompletion.then.bind(taskCompletion)\n    };\n\n    if (this.taskQueue.length >= maxQueuedJobs) {\n      throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" + \"This usually happens for one of two reasons: We are either at peak \" + \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n    }\n\n    this.debug(`Queueing task #${task.id}...`);\n    this.taskQueue.push(task);\n    this.eventSubject.next({\n      type: PoolEventType.taskQueued,\n      taskID: task.id\n    });\n    this.scheduleWork();\n    return task;\n  }\n\n  terminate(force) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isClosing = true;\n\n      if (!force) {\n        yield this.completed(true);\n      }\n\n      this.eventSubject.next({\n        type: PoolEventType.terminated,\n        remainingQueue: [...this.taskQueue]\n      });\n      this.eventSubject.complete();\n      yield Promise.all(this.workers.map(worker => __awaiter(this, void 0, void 0, function* () {\n        return Thread.terminate((yield worker.init));\n      })));\n    });\n  }\n\n}\n\nWorkerPool.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\n\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n  // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n  // If the Pool is a class or not is an implementation detail that should not concern the user.\n  return new WorkerPool(spawnWorker, optionsOrSize);\n}\n\nPoolConstructor.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\n\nexport const Pool = PoolConstructor;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/master/pool.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","DebugLogger","multicast","Observable","Subject","allSettled","defaultPoolSize","PoolEventType","Thread","nextPoolID","createArray","size","array","index","push","delay","ms","setTimeout","flatMap","mapper","reduce","flattened","element","slugify","text","replace","trim","spawnWorkers","spawnWorker","count","map","init","runningTasks","WorkerPool","constructor","optionsOrSize","eventSubject","initErrors","isClosing","nextTaskID","taskQueue","options","debug","name","String","workers","eventObservable","from","all","worker","type","initialized","length","error","findIdlingWorker","concurrency","find","runPoolTask","task","workerID","indexOf","id","taskStart","taskID","returnValue","run","taskCompleted","taskFailed","runPromise","removeTaskFromWorkersRunningTasks","filter","someRunPromise","scheduleWork","availableWorker","nextTask","shift","taskQueueDrained","taskCompletion","eventSubscription","events","subscribe","event","unsubscribe","terminated","Error","settled","allowResolvingImmediately","getCurrentlyRunningTasks","taskFailures","failureSubscription","subscription","completed","settlementPromise","earlyExitPromise","errors","race","queue","taskFunction","maxQueuedJobs","Infinity","catch","cancel","someTask","taskCanceled","bind","taskQueued","terminate","force","remainingQueue","complete","EventType","PoolConstructor","Pool"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASA,OAAOO,WAAP,MAAwB,OAAxB;AACA,SAASC,SAAT,EAAoBC,UAApB,EAAgCC,OAAhC,QAA+C,gBAA/C;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,eAAT,QAAgC,kBAAhC;AACA,SAASC,aAAT,QAA8B,cAA9B;AACA,SAASC,MAAT,QAAuB,UAAvB;AACA,SAASD,aAAT,EAAwBC,MAAxB;AACA,IAAIC,UAAU,GAAG,CAAjB;;AACA,SAASC,WAAT,CAAqBC,IAArB,EAA2B;AACvB,QAAMC,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,IAA5B,EAAkCE,KAAK,EAAvC,EAA2C;AACvCD,IAAAA,KAAK,CAACE,IAAN,CAAWD,KAAX;AACH;;AACD,SAAOD,KAAP;AACH;;AACD,SAASG,KAAT,CAAeC,EAAf,EAAmB;AACf,SAAO,IAAI1B,OAAJ,CAAYD,OAAO,IAAI4B,UAAU,CAAC5B,OAAD,EAAU2B,EAAV,CAAjC,CAAP;AACH;;AACD,SAASE,OAAT,CAAiBN,KAAjB,EAAwBO,MAAxB,EAAgC;AAC5B,SAAOP,KAAK,CAACQ,MAAN,CAAa,CAACC,SAAD,EAAYC,OAAZ,KAAwB,CAAC,GAAGD,SAAJ,EAAe,GAAGF,MAAM,CAACG,OAAD,CAAxB,CAArC,EAAyE,EAAzE,CAAP;AACH;;AACD,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;AACnB,SAAOA,IAAI,CAACC,OAAL,CAAa,KAAb,EAAoB,GAApB,EAAyBC,IAAzB,GAAgCD,OAAhC,CAAwC,MAAxC,EAAgD,GAAhD,CAAP;AACH;;AACD,SAASE,YAAT,CAAsBC,WAAtB,EAAmCC,KAAnC,EAA0C;AACtC,SAAOnB,WAAW,CAACmB,KAAD,CAAX,CAAmBC,GAAnB,CAAuB,OAAO;AACjCC,IAAAA,IAAI,EAAEH,WAAW,EADgB;AAEjCI,IAAAA,YAAY,EAAE;AAFmB,GAAP,CAAvB,CAAP;AAIH;;AACD,MAAMC,UAAN,CAAiB;AACbC,EAAAA,WAAW,CAACN,WAAD,EAAcO,aAAd,EAA6B;AACpC,SAAKC,YAAL,GAAoB,IAAIhC,OAAJ,EAApB;AACA,SAAKiC,UAAL,GAAkB,EAAlB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,UAAMC,OAAO,GAAG,OAAON,aAAP,KAAyB,QAAzB,GACV;AAAExB,MAAAA,IAAI,EAAEwB;AAAR,KADU,GAEVA,aAAa,IAAI,EAFvB;AAGA,UAAM;AAAExB,MAAAA,IAAI,GAAGL;AAAT,QAA6BmC,OAAnC;AACA,SAAKC,KAAL,GAAazC,WAAW,CAAE,gBAAesB,OAAO,CAACkB,OAAO,CAACE,IAAR,IAAgBC,MAAM,CAACnC,UAAU,EAAX,CAAvB,CAAuC,EAA/D,CAAxB;AACA,SAAKgC,OAAL,GAAeA,OAAf;AACA,SAAKI,OAAL,GAAelB,YAAY,CAACC,WAAD,EAAcjB,IAAd,CAA3B;AACA,SAAKmC,eAAL,GAAuB5C,SAAS,CAACC,UAAU,CAAC4C,IAAX,CAAgB,KAAKX,YAArB,CAAD,CAAhC;AACA9C,IAAAA,OAAO,CAAC0D,GAAR,CAAY,KAAKH,OAAL,CAAaf,GAAb,CAAiBmB,MAAM,IAAIA,MAAM,CAAClB,IAAlC,CAAZ,EAAqDhC,IAArD,CAA0D,MAAM,KAAKqC,YAAL,CAAkB1C,IAAlB,CAAuB;AACnFwD,MAAAA,IAAI,EAAE3C,aAAa,CAAC4C,WAD+D;AAEnFxC,MAAAA,IAAI,EAAE,KAAKkC,OAAL,CAAaO;AAFgE,KAAvB,CAAhE,EAGIC,KAAK,IAAI;AACT,WAAKX,KAAL,CAAW,uCAAX,EAAoDW,KAApD;AACA,WAAKjB,YAAL,CAAkBiB,KAAlB,CAAwBA,KAAxB;AACA,WAAKhB,UAAL,CAAgBvB,IAAhB,CAAqBuC,KAArB;AACH,KAPD;AAQH;;AACDC,EAAAA,gBAAgB,GAAG;AACf,UAAM;AAAEC,MAAAA,WAAW,GAAG;AAAhB,QAAsB,KAAKd,OAAjC;AACA,WAAO,KAAKI,OAAL,CAAaW,IAAb,CAAkBP,MAAM,IAAIA,MAAM,CAACjB,YAAP,CAAoBoB,MAApB,GAA6BG,WAAzD,CAAP;AACH;;AACDE,EAAAA,WAAW,CAACR,MAAD,EAASS,IAAT,EAAe;AACtB,WAAO5E,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAM6E,QAAQ,GAAG,KAAKd,OAAL,CAAae,OAAb,CAAqBX,MAArB,IAA+B,CAAhD;AACA,WAAKP,KAAL,CAAY,iBAAgBgB,IAAI,CAACG,EAAG,eAAcF,QAAS,KAA3D;AACA,WAAKvB,YAAL,CAAkB1C,IAAlB,CAAuB;AACnBwD,QAAAA,IAAI,EAAE3C,aAAa,CAACuD,SADD;AAEnBC,QAAAA,MAAM,EAAEL,IAAI,CAACG,EAFM;AAGnBF,QAAAA;AAHmB,OAAvB;;AAKA,UAAI;AACA,cAAMK,WAAW,GAAG,MAAMN,IAAI,CAACO,GAAL,EAAS,MAAMhB,MAAM,CAAClB,IAAtB,EAA1B;AACA,aAAKW,KAAL,CAAY,SAAQgB,IAAI,CAACG,EAAG,yBAA5B;AACA,aAAKzB,YAAL,CAAkB1C,IAAlB,CAAuB;AACnBwD,UAAAA,IAAI,EAAE3C,aAAa,CAAC2D,aADD;AAEnBF,UAAAA,WAFmB;AAGnBD,UAAAA,MAAM,EAAEL,IAAI,CAACG,EAHM;AAInBF,UAAAA;AAJmB,SAAvB;AAMH,OATD,CAUA,OAAON,KAAP,EAAc;AACV,aAAKX,KAAL,CAAY,SAAQgB,IAAI,CAACG,EAAG,SAA5B;AACA,aAAKzB,YAAL,CAAkB1C,IAAlB,CAAuB;AACnBwD,UAAAA,IAAI,EAAE3C,aAAa,CAAC4D,UADD;AAEnBJ,UAAAA,MAAM,EAAEL,IAAI,CAACG,EAFM;AAGnBR,UAAAA,KAHmB;AAInBM,UAAAA;AAJmB,SAAvB;AAMH;AACJ,KA3Be,CAAhB;AA4BH;;AACDM,EAAAA,GAAG,CAAChB,MAAD,EAASS,IAAT,EAAe;AACd,WAAO5E,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAMsF,UAAU,GAAG,CAAC,MAAMtF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AACnE,cAAMuF,iCAAiC,GAAG,MAAM;AAC5CpB,UAAAA,MAAM,CAACjB,YAAP,GAAsBiB,MAAM,CAACjB,YAAP,CAAoBsC,MAApB,CAA2BC,cAAc,IAAIA,cAAc,KAAKH,UAAhE,CAAtB;AACH,SAFD,CADmE,CAInE;;;AACA,cAAMrD,KAAK,CAAC,CAAD,CAAX;;AACA,YAAI;AACA,gBAAM,KAAK0C,WAAL,CAAiBR,MAAjB,EAAyBS,IAAzB,CAAN;AACH,SAFD,SAGQ;AACJW,UAAAA,iCAAiC;;AACjC,cAAI,CAAC,KAAK/B,SAAV,EAAqB;AACjB,iBAAKkC,YAAL;AACH;AACJ;AACJ,OAfkC,CAAhB,GAAnB;;AAgBAvB,MAAAA,MAAM,CAACjB,YAAP,CAAoBlB,IAApB,CAAyBsD,UAAzB;AACH,KAlBe,CAAhB;AAmBH;;AACDI,EAAAA,YAAY,GAAG;AACX,SAAK9B,KAAL,CAAY,kDAAZ;AACA,UAAM+B,eAAe,GAAG,KAAKnB,gBAAL,EAAxB;AACA,QAAI,CAACmB,eAAL,EACI;AACJ,UAAMC,QAAQ,GAAG,KAAKlC,SAAL,CAAemC,KAAf,EAAjB;;AACA,QAAI,CAACD,QAAL,EAAe;AACX,WAAKhC,KAAL,CAAY,qBAAZ;AACA,WAAKN,YAAL,CAAkB1C,IAAlB,CAAuB;AAAEwD,QAAAA,IAAI,EAAE3C,aAAa,CAACqE;AAAtB,OAAvB;AACA;AACH;;AACD,SAAKX,GAAL,CAASQ,eAAT,EAA0BC,QAA1B;AACH;;AACDG,EAAAA,cAAc,CAACd,MAAD,EAAS;AACnB,WAAO,IAAIzE,OAAJ,CAAY,CAACD,OAAD,EAAUE,MAAV,KAAqB;AACpC,YAAMuF,iBAAiB,GAAG,KAAKC,MAAL,GAAcC,SAAd,CAAwBC,KAAK,IAAI;AACvD,YAAIA,KAAK,CAAC/B,IAAN,KAAe3C,aAAa,CAAC2D,aAA7B,IAA8Ce,KAAK,CAAClB,MAAN,KAAiBA,MAAnE,EAA2E;AACvEe,UAAAA,iBAAiB,CAACI,WAAlB;AACA7F,UAAAA,OAAO,CAAC4F,KAAK,CAACjB,WAAP,CAAP;AACH,SAHD,MAIK,IAAIiB,KAAK,CAAC/B,IAAN,KAAe3C,aAAa,CAAC4D,UAA7B,IAA2Cc,KAAK,CAAClB,MAAN,KAAiBA,MAAhE,EAAwE;AACzEe,UAAAA,iBAAiB,CAACI,WAAlB;AACA3F,UAAAA,MAAM,CAAC0F,KAAK,CAAC5B,KAAP,CAAN;AACH,SAHI,MAIA,IAAI4B,KAAK,CAAC/B,IAAN,KAAe3C,aAAa,CAAC4E,UAAjC,EAA6C;AAC9CL,UAAAA,iBAAiB,CAACI,WAAlB;AACA3F,UAAAA,MAAM,CAAC6F,KAAK,CAAC,+CAAD,CAAN,CAAN;AACH;AACJ,OAbyB,CAA1B;AAcH,KAfM,CAAP;AAgBH;;AACDC,EAAAA,OAAO,CAACC,yBAAyB,GAAG,KAA7B,EAAoC;AACvC,WAAOxG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAMyG,wBAAwB,GAAG,MAAMrE,OAAO,CAAC,KAAK2B,OAAN,EAAeI,MAAM,IAAIA,MAAM,CAACjB,YAAhC,CAA9C;;AACA,YAAMwD,YAAY,GAAG,EAArB;AACA,YAAMC,mBAAmB,GAAG,KAAK3C,eAAL,CAAqBkC,SAArB,CAA+BC,KAAK,IAAI;AAChE,YAAIA,KAAK,CAAC/B,IAAN,KAAe3C,aAAa,CAAC4D,UAAjC,EAA6C;AACzCqB,UAAAA,YAAY,CAAC1E,IAAb,CAAkBmE,KAAK,CAAC5B,KAAxB;AACH;AACJ,OAJ2B,CAA5B;;AAKA,UAAI,KAAKhB,UAAL,CAAgBe,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B,eAAO9D,OAAO,CAACC,MAAR,CAAe,KAAK8C,UAAL,CAAgB,CAAhB,CAAf,CAAP;AACH;;AACD,UAAIiD,yBAAyB,IAAI,KAAK9C,SAAL,CAAeY,MAAf,KAA0B,CAA3D,EAA8D;AAC1D,cAAM/C,UAAU,CAACkF,wBAAwB,EAAzB,CAAhB;AACA,eAAOC,YAAP;AACH;;AACD,YAAM,IAAIlG,OAAJ,CAAY,CAACD,OAAD,EAAUE,MAAV,KAAqB;AACnC,cAAMmG,YAAY,GAAG,KAAK5C,eAAL,CAAqBkC,SAArB,CAA+B;AAChDtF,UAAAA,IAAI,CAACuF,KAAD,EAAQ;AACR,gBAAIA,KAAK,CAAC/B,IAAN,KAAe3C,aAAa,CAACqE,gBAAjC,EAAmD;AAC/Cc,cAAAA,YAAY,CAACR,WAAb;AACA7F,cAAAA,OAAO,CAAC,KAAK,CAAN,CAAP;AACH;AACJ,WAN+C;;AAOhDgE,UAAAA,KAAK,EAAE9D,MAPyC,CAOlC;;AAPkC,SAA/B,CAArB;AASH,OAVK,CAAN;AAWA,YAAMc,UAAU,CAACkF,wBAAwB,EAAzB,CAAhB;AACAE,MAAAA,mBAAmB,CAACP,WAApB;AACA,aAAOM,YAAP;AACH,KA7Be,CAAhB;AA8BH;;AACDG,EAAAA,SAAS,CAACL,yBAAyB,GAAG,KAA7B,EAAoC;AACzC,WAAOxG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAM8G,iBAAiB,GAAG,KAAKP,OAAL,CAAaC,yBAAb,CAA1B;AACA,YAAMO,gBAAgB,GAAG,IAAIvG,OAAJ,CAAY,CAACD,OAAD,EAAUE,MAAV,KAAqB;AACtD,cAAMmG,YAAY,GAAG,KAAK5C,eAAL,CAAqBkC,SAArB,CAA+B;AAChDtF,UAAAA,IAAI,CAACuF,KAAD,EAAQ;AACR,gBAAIA,KAAK,CAAC/B,IAAN,KAAe3C,aAAa,CAACqE,gBAAjC,EAAmD;AAC/Cc,cAAAA,YAAY,CAACR,WAAb;AACA7F,cAAAA,OAAO,CAACuG,iBAAD,CAAP;AACH,aAHD,MAIK,IAAIX,KAAK,CAAC/B,IAAN,KAAe3C,aAAa,CAAC4D,UAAjC,EAA6C;AAC9CuB,cAAAA,YAAY,CAACR,WAAb;AACA3F,cAAAA,MAAM,CAAC0F,KAAK,CAAC5B,KAAP,CAAN;AACH;AACJ,WAV+C;;AAWhDA,UAAAA,KAAK,EAAE9D,MAXyC,CAWlC;;AAXkC,SAA/B,CAArB;AAaH,OAdwB,CAAzB;AAeA,YAAMuG,MAAM,GAAG,MAAMxG,OAAO,CAACyG,IAAR,CAAa,CAC9BH,iBAD8B,EAE9BC,gBAF8B,CAAb,CAArB;;AAIA,UAAIC,MAAM,CAAC1C,MAAP,GAAgB,CAApB,EAAuB;AACnB,cAAM0C,MAAM,CAAC,CAAD,CAAZ;AACH;AACJ,KAxBe,CAAhB;AAyBH;;AACDf,EAAAA,MAAM,GAAG;AACL,WAAO,KAAKjC,eAAZ;AACH;;AACDkD,EAAAA,KAAK,CAACC,YAAD,EAAe;AAChB,UAAM;AAAEC,MAAAA,aAAa,GAAGC;AAAlB,QAA+B,KAAK1D,OAA1C;;AACA,QAAI,KAAKH,SAAT,EAAoB;AAChB,YAAM8C,KAAK,CAAE,+DAAF,CAAX;AACH;;AACD,QAAI,KAAK/C,UAAL,CAAgBe,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B,YAAM,KAAKf,UAAL,CAAgB,CAAhB,CAAN;AACH;;AACD,UAAM0B,MAAM,GAAG,KAAKxB,UAAL,EAAf;AACA,UAAMsC,cAAc,GAAG,KAAKA,cAAL,CAAoBd,MAApB,CAAvB;AACAc,IAAAA,cAAc,CAACuB,KAAf,CAAsB/C,KAAD,IAAW;AAC5B;AACA;AACA,WAAKX,KAAL,CAAY,SAAQqB,MAAO,WAA3B,EAAuCV,KAAvC;AACH,KAJD;AAKA,UAAMK,IAAI,GAAG;AACTG,MAAAA,EAAE,EAAEE,MADK;AAETE,MAAAA,GAAG,EAAEgC,YAFI;AAGTI,MAAAA,MAAM,EAAE,MAAM;AACV,YAAI,KAAK7D,SAAL,CAAeoB,OAAf,CAAuBF,IAAvB,MAAiC,CAAC,CAAtC,EACI;AACJ,aAAKlB,SAAL,GAAiB,KAAKA,SAAL,CAAe8B,MAAf,CAAsBgC,QAAQ,IAAIA,QAAQ,KAAK5C,IAA/C,CAAjB;AACA,aAAKtB,YAAL,CAAkB1C,IAAlB,CAAuB;AACnBwD,UAAAA,IAAI,EAAE3C,aAAa,CAACgG,YADD;AAEnBxC,UAAAA,MAAM,EAAEL,IAAI,CAACG;AAFM,SAAvB;AAIH,OAXQ;AAYT9D,MAAAA,IAAI,EAAE8E,cAAc,CAAC9E,IAAf,CAAoByG,IAApB,CAAyB3B,cAAzB;AAZG,KAAb;;AAcA,QAAI,KAAKrC,SAAL,CAAeY,MAAf,IAAyB8C,aAA7B,EAA4C;AACxC,YAAMd,KAAK,CAAC,0EACR,qEADQ,GAER,6EAFO,CAAX;AAGH;;AACD,SAAK1C,KAAL,CAAY,kBAAiBgB,IAAI,CAACG,EAAG,KAArC;AACA,SAAKrB,SAAL,CAAe1B,IAAf,CAAoB4C,IAApB;AACA,SAAKtB,YAAL,CAAkB1C,IAAlB,CAAuB;AACnBwD,MAAAA,IAAI,EAAE3C,aAAa,CAACkG,UADD;AAEnB1C,MAAAA,MAAM,EAAEL,IAAI,CAACG;AAFM,KAAvB;AAIA,SAAKW,YAAL;AACA,WAAOd,IAAP;AACH;;AACDgD,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACb,WAAO7H,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,WAAKwD,SAAL,GAAiB,IAAjB;;AACA,UAAI,CAACqE,KAAL,EAAY;AACR,cAAM,KAAKhB,SAAL,CAAe,IAAf,CAAN;AACH;;AACD,WAAKvD,YAAL,CAAkB1C,IAAlB,CAAuB;AACnBwD,QAAAA,IAAI,EAAE3C,aAAa,CAAC4E,UADD;AAEnByB,QAAAA,cAAc,EAAE,CAAC,GAAG,KAAKpE,SAAT;AAFG,OAAvB;AAIA,WAAKJ,YAAL,CAAkByE,QAAlB;AACA,YAAMvH,OAAO,CAAC0D,GAAR,CAAY,KAAKH,OAAL,CAAaf,GAAb,CAAkBmB,MAAD,IAAYnE,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAAE,eAAO0B,MAAM,CAACkG,SAAP,EAAiB,MAAMzD,MAAM,CAAClB,IAA9B,EAAP;AAA6C,OAAnF,CAAtC,CAAZ,CAAN;AACH,KAXe,CAAhB;AAYH;;AApOY;;AAsOjBE,UAAU,CAAC6E,SAAX,GAAuBvG,aAAvB;AACA;;;;AAGA,SAASwG,eAAT,CAAyBnF,WAAzB,EAAsCO,aAAtC,EAAqD;AACjD;AACA;AACA,SAAO,IAAIF,UAAJ,CAAeL,WAAf,EAA4BO,aAA5B,CAAP;AACH;;AACD4E,eAAe,CAACD,SAAhB,GAA4BvG,aAA5B;AACA;;;;AAGA,OAAO,MAAMyG,IAAI,GAAGD,eAAb","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DebugLogger from \"debug\";\nimport { multicast, Observable, Subject } from \"observable-fns\";\nimport { allSettled } from \"../ponyfills\";\nimport { defaultPoolSize } from \"./implementation\";\nimport { PoolEventType } from \"./pool-types\";\nimport { Thread } from \"./thread\";\nexport { PoolEventType, Thread };\nlet nextPoolID = 1;\nfunction createArray(size) {\n    const array = [];\n    for (let index = 0; index < size; index++) {\n        array.push(index);\n    }\n    return array;\n}\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction flatMap(array, mapper) {\n    return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\nfunction slugify(text) {\n    return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n    return createArray(count).map(() => ({\n        init: spawnWorker(),\n        runningTasks: []\n    }));\n}\nclass WorkerPool {\n    constructor(spawnWorker, optionsOrSize) {\n        this.eventSubject = new Subject();\n        this.initErrors = [];\n        this.isClosing = false;\n        this.nextTaskID = 1;\n        this.taskQueue = [];\n        const options = typeof optionsOrSize === \"number\"\n            ? { size: optionsOrSize }\n            : optionsOrSize || {};\n        const { size = defaultPoolSize } = options;\n        this.debug = DebugLogger(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n        this.options = options;\n        this.workers = spawnWorkers(spawnWorker, size);\n        this.eventObservable = multicast(Observable.from(this.eventSubject));\n        Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n            type: PoolEventType.initialized,\n            size: this.workers.length\n        }), error => {\n            this.debug(\"Error while initializing pool worker:\", error);\n            this.eventSubject.error(error);\n            this.initErrors.push(error);\n        });\n    }\n    findIdlingWorker() {\n        const { concurrency = 1 } = this.options;\n        return this.workers.find(worker => worker.runningTasks.length < concurrency);\n    }\n    runPoolTask(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workerID = this.workers.indexOf(worker) + 1;\n            this.debug(`Running task #${task.id} on worker #${workerID}...`);\n            this.eventSubject.next({\n                type: PoolEventType.taskStart,\n                taskID: task.id,\n                workerID\n            });\n            try {\n                const returnValue = yield task.run(yield worker.init);\n                this.debug(`Task #${task.id} completed successfully`);\n                this.eventSubject.next({\n                    type: PoolEventType.taskCompleted,\n                    returnValue,\n                    taskID: task.id,\n                    workerID\n                });\n            }\n            catch (error) {\n                this.debug(`Task #${task.id} failed`);\n                this.eventSubject.next({\n                    type: PoolEventType.taskFailed,\n                    taskID: task.id,\n                    error,\n                    workerID\n                });\n            }\n        });\n    }\n    run(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n                const removeTaskFromWorkersRunningTasks = () => {\n                    worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n                };\n                // Defer task execution by one tick to give handlers time to subscribe\n                yield delay(0);\n                try {\n                    yield this.runPoolTask(worker, task);\n                }\n                finally {\n                    removeTaskFromWorkersRunningTasks();\n                    if (!this.isClosing) {\n                        this.scheduleWork();\n                    }\n                }\n            }))();\n            worker.runningTasks.push(runPromise);\n        });\n    }\n    scheduleWork() {\n        this.debug(`Attempt de-queueing a task in order to run it...`);\n        const availableWorker = this.findIdlingWorker();\n        if (!availableWorker)\n            return;\n        const nextTask = this.taskQueue.shift();\n        if (!nextTask) {\n            this.debug(`Task queue is empty`);\n            this.eventSubject.next({ type: PoolEventType.taskQueueDrained });\n            return;\n        }\n        this.run(availableWorker, nextTask);\n    }\n    taskCompletion(taskID) {\n        return new Promise((resolve, reject) => {\n            const eventSubscription = this.events().subscribe(event => {\n                if (event.type === PoolEventType.taskCompleted && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    resolve(event.returnValue);\n                }\n                else if (event.type === PoolEventType.taskFailed && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    reject(event.error);\n                }\n                else if (event.type === PoolEventType.terminated) {\n                    eventSubscription.unsubscribe();\n                    reject(Error(\"Pool has been terminated before task was run.\"));\n                }\n            });\n        });\n    }\n    settled(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n            const taskFailures = [];\n            const failureSubscription = this.eventObservable.subscribe(event => {\n                if (event.type === PoolEventType.taskFailed) {\n                    taskFailures.push(event.error);\n                }\n            });\n            if (this.initErrors.length > 0) {\n                return Promise.reject(this.initErrors[0]);\n            }\n            if (allowResolvingImmediately && this.taskQueue.length === 0) {\n                yield allSettled(getCurrentlyRunningTasks());\n                return taskFailures;\n            }\n            yield new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(void 0);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            yield allSettled(getCurrentlyRunningTasks());\n            failureSubscription.unsubscribe();\n            return taskFailures;\n        });\n    }\n    completed(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const settlementPromise = this.settled(allowResolvingImmediately);\n            const earlyExitPromise = new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(settlementPromise);\n                        }\n                        else if (event.type === PoolEventType.taskFailed) {\n                            subscription.unsubscribe();\n                            reject(event.error);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            const errors = yield Promise.race([\n                settlementPromise,\n                earlyExitPromise\n            ]);\n            if (errors.length > 0) {\n                throw errors[0];\n            }\n        });\n    }\n    events() {\n        return this.eventObservable;\n    }\n    queue(taskFunction) {\n        const { maxQueuedJobs = Infinity } = this.options;\n        if (this.isClosing) {\n            throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n        }\n        if (this.initErrors.length > 0) {\n            throw this.initErrors[0];\n        }\n        const taskID = this.nextTaskID++;\n        const taskCompletion = this.taskCompletion(taskID);\n        taskCompletion.catch((error) => {\n            // Prevent unhandled rejections here as we assume the user will use\n            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n            this.debug(`Task #${taskID} errored:`, error);\n        });\n        const task = {\n            id: taskID,\n            run: taskFunction,\n            cancel: () => {\n                if (this.taskQueue.indexOf(task) === -1)\n                    return;\n                this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n                this.eventSubject.next({\n                    type: PoolEventType.taskCanceled,\n                    taskID: task.id\n                });\n            },\n            then: taskCompletion.then.bind(taskCompletion)\n        };\n        if (this.taskQueue.length >= maxQueuedJobs) {\n            throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" +\n                \"This usually happens for one of two reasons: We are either at peak \" +\n                \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n        }\n        this.debug(`Queueing task #${task.id}...`);\n        this.taskQueue.push(task);\n        this.eventSubject.next({\n            type: PoolEventType.taskQueued,\n            taskID: task.id\n        });\n        this.scheduleWork();\n        return task;\n    }\n    terminate(force) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.isClosing = true;\n            if (!force) {\n                yield this.completed(true);\n            }\n            this.eventSubject.next({\n                type: PoolEventType.terminated,\n                remainingQueue: [...this.taskQueue]\n            });\n            this.eventSubject.complete();\n            yield Promise.all(this.workers.map((worker) => __awaiter(this, void 0, void 0, function* () { return Thread.terminate(yield worker.init); })));\n        });\n    }\n}\nWorkerPool.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n    // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n    // If the Pool is a class or not is an implementation detail that should not concern the user.\n    return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexport const Pool = PoolConstructor;\n"]},"metadata":{},"sourceType":"module"}