{"ast":null,"code":"/* eslint-disable no-plusplus */\nimport shortNumber from 'short-number';\nimport isEqual from 'lodash/isEqual';\nimport { getDefaultInitialViewState, MultiscaleImageLayer, ImageLayer, VolumeLayer } from '@hms-dbmi/viv';\nimport { extent } from 'd3-array';\nimport { Matrix4 } from 'math.gl';\nimport { divide, compare, unit } from 'mathjs';\nimport { pluralize, getSourceFromLoader, isRgb } from '../../utils';\nimport { VIEWER_PALETTE } from '../utils';\nimport { GLOBAL_LABELS, DEFAULT_RASTER_LAYER_PROPS, DEFAULT_LAYER_TYPE_ORDERING } from './constants';\nimport BitmaskLayer from '../../layers/BitmaskLayer';\nimport { getMultiSelectionStats } from '../layer-controller/utils';\nexport function square(x, y, r) {\n  return [[x, y + r], [x + r, y], [x, y - r], [x - r, y]];\n}\n/**\n * Sort spatial layer definition array,\n * to keep the ordering in the layer controller\n * consistent.\n * Intended to be used with auto-initialized layer\n * definition arrays only, as a pre-defined layer array\n * should not be re-ordered.\n * @param {object[]} layers Array of layer definition objects.\n * Object must have a .type property.\n */\n\nexport function sortLayers(layers) {\n  return layers.sort((a, b) => DEFAULT_LAYER_TYPE_ORDERING.indexOf(a.type) - DEFAULT_LAYER_TYPE_ORDERING.indexOf(b.type));\n}\n/**\n * Return the midpoint of the global dimensions.\n * @param {object} source PixelSource object from Viv\n * @returns {object} The selection.\n */\n\nfunction getDefaultGlobalSelection(source) {\n  const globalIndices = source.labels.filter(dim => GLOBAL_LABELS.includes(dim));\n  const selection = {};\n  globalIndices.forEach(dim => {\n    selection[dim] = Math.floor((source.shape[source.labels.indexOf(dim)] || 0) / 2);\n  });\n  return selection;\n}\n/**\n * Create a default selection using the midpoint of the available global dimensions,\n * and then the first four available selections from the first selectable channel.\n * @param {object} source PixelSource object from Viv\n * @returns {object} The selection.\n */\n\n\nfunction buildDefaultSelection(source) {\n  const selection = [];\n  const globalSelection = getDefaultGlobalSelection(source); // First non-global dimension with some sort of selectable values\n\n  const firstNonGlobalDimension = source.labels.filter(dim => !GLOBAL_LABELS.includes(dim) && source.shape[source.labels.indexOf(dim)])[0];\n\n  for (let i = 0; i < Math.min(4, source.shape[source.labels.indexOf(firstNonGlobalDimension)]); i += 1) {\n    selection.push({\n      [firstNonGlobalDimension]: i,\n      ...globalSelection\n    });\n  }\n\n  return selection;\n}\n/**\n * @param {Array.<number>} shape loader shape\n */\n\n\nexport function isInterleaved(shape) {\n  const lastDimSize = shape[shape.length - 1];\n  return lastDimSize === 3 || lastDimSize === 4;\n}\n/**\n * Initialize the channel selections for an individual layer.\n * @param {object} loader A viv loader instance with channel names appended by Vitessce loaders\n * of the form { data: (PixelSource[]|PixelSource), metadata: Object, channels }\n * @returns {object[]} An array of selected channels with default\n * domain/slider settings.\n */\n\nexport async function initializeLayerChannels(loader, use3d) {\n  const result = [];\n  const source = getSourceFromLoader(loader); // Add channel automatically as the first avaialable value for each dimension.\n\n  let defaultSelection = buildDefaultSelection(source);\n  defaultSelection = isInterleaved(source.shape) ? [{ ...defaultSelection[0],\n    c: 0\n  }] : defaultSelection;\n  const stats = await getMultiSelectionStats({\n    loader: loader.data,\n    selections: defaultSelection,\n    use3d\n  });\n  const domains = isRgb(loader) ? [[0, 255], [0, 255], [0, 255]] : stats.domains;\n  const colors = isRgb(loader) ? [[255, 0, 0], [0, 255, 0], [0, 0, 255]] : null;\n  const sliders = isRgb(loader) ? [[0, 255], [0, 255], [0, 255]] : stats.sliders;\n  defaultSelection.forEach((selection, i) => {\n    const domain = domains[i];\n    const slider = sliders[i];\n    const channel = {\n      selection,\n      // eslint-disable-next-line no-nested-ternary\n      color: colors ? colors[i] : defaultSelection.length !== 1 ? VIEWER_PALETTE[i] : [255, 255, 255],\n      visible: true,\n      slider: slider || domain\n    };\n    result.push(channel);\n  });\n  return result;\n}\n\nfunction getMetaWithTransformMatrices(imageMeta, imageLoaders) {\n  // Do not fill in transformation matrices if any of the layers specify one.\n  const sources = imageLoaders.map(loader => getSourceFromLoader(loader));\n\n  if (imageMeta.map(meta => {\n    var _meta$metadata, _meta$metadata$transf, _meta$metadata2, _meta$metadata2$trans, _meta$metadata3, _meta$metadata3$trans;\n\n    return (meta === null || meta === void 0 ? void 0 : (_meta$metadata = meta.metadata) === null || _meta$metadata === void 0 ? void 0 : (_meta$metadata$transf = _meta$metadata.transform) === null || _meta$metadata$transf === void 0 ? void 0 : _meta$metadata$transf.matrix) || (meta === null || meta === void 0 ? void 0 : (_meta$metadata2 = meta.metadata) === null || _meta$metadata2 === void 0 ? void 0 : (_meta$metadata2$trans = _meta$metadata2.transform) === null || _meta$metadata2$trans === void 0 ? void 0 : _meta$metadata2$trans.scale) || (meta === null || meta === void 0 ? void 0 : (_meta$metadata3 = meta.metadata) === null || _meta$metadata3 === void 0 ? void 0 : (_meta$metadata3$trans = _meta$metadata3.transform) === null || _meta$metadata3$trans === void 0 ? void 0 : _meta$metadata3$trans.translate);\n  }).some(Boolean) || sources.every(source => {\n    var _source$meta, _source$meta$physical, _source$meta2, _source$meta2$physica;\n\n    return !((_source$meta = source.meta) === null || _source$meta === void 0 ? void 0 : (_source$meta$physical = _source$meta.physicalSizes) === null || _source$meta$physical === void 0 ? void 0 : _source$meta$physical.x) || !((_source$meta2 = source.meta) === null || _source$meta2 === void 0 ? void 0 : (_source$meta2$physica = _source$meta2.physicalSizes) === null || _source$meta2$physica === void 0 ? void 0 : _source$meta2$physica.y);\n  })) {\n    return imageMeta;\n  } // Get the minimum physical among all the current images.\n\n\n  const minPhysicalSize = sources.reduce((acc, source) => {\n    var _source$meta3, _source$meta3$physica, _source$meta3$physica2, _source$meta4, _source$meta5, _source$meta6, _source$meta7;\n\n    const hasZPhyscialSize = (_source$meta3 = source.meta) === null || _source$meta3 === void 0 ? void 0 : (_source$meta3$physica = _source$meta3.physicalSizes) === null || _source$meta3$physica === void 0 ? void 0 : (_source$meta3$physica2 = _source$meta3$physica.z) === null || _source$meta3$physica2 === void 0 ? void 0 : _source$meta3$physica2.size;\n    const sizes = [unit(`${(_source$meta4 = source.meta) === null || _source$meta4 === void 0 ? void 0 : _source$meta4.physicalSizes.x.size} ${(_source$meta5 = source.meta) === null || _source$meta5 === void 0 ? void 0 : _source$meta5.physicalSizes.x.unit}`.replace('µ', 'u')), unit(`${(_source$meta6 = source.meta) === null || _source$meta6 === void 0 ? void 0 : _source$meta6.physicalSizes.y.size} ${(_source$meta7 = source.meta) === null || _source$meta7 === void 0 ? void 0 : _source$meta7.physicalSizes.y.unit}`.replace('µ', 'u'))];\n\n    if (hasZPhyscialSize) {\n      var _source$meta8, _source$meta9;\n\n      sizes.push(unit(`${(_source$meta8 = source.meta) === null || _source$meta8 === void 0 ? void 0 : _source$meta8.physicalSizes.z.size} ${(_source$meta9 = source.meta) === null || _source$meta9 === void 0 ? void 0 : _source$meta9.physicalSizes.z.unit}`.replace('µ', 'u')));\n    }\n\n    acc[0] = acc[0] === undefined || compare(sizes[0], acc[0]) === -1 ? sizes[0] : acc[0];\n    acc[1] = acc[1] === undefined || compare(sizes[1], acc[1]) === -1 ? sizes[1] : acc[1];\n    acc[2] = acc[2] === undefined || compare(sizes[2], acc[2]) === -1 ? sizes[2] : acc[2];\n    return acc;\n  }, []);\n  const imageMetaWithTransform = imageMeta.map((meta, j) => {\n    var _source$meta10, _source$meta10$physic, _source$meta10$physic2, _source$meta11, _source$meta12, _source$meta13, _source$meta14;\n\n    const source = sources[j];\n    const hasZPhyscialSize = (_source$meta10 = source.meta) === null || _source$meta10 === void 0 ? void 0 : (_source$meta10$physic = _source$meta10.physicalSizes) === null || _source$meta10$physic === void 0 ? void 0 : (_source$meta10$physic2 = _source$meta10$physic.z) === null || _source$meta10$physic2 === void 0 ? void 0 : _source$meta10$physic2.size;\n    const sizes = [unit(`${(_source$meta11 = source.meta) === null || _source$meta11 === void 0 ? void 0 : _source$meta11.physicalSizes.x.size} ${(_source$meta12 = source.meta) === null || _source$meta12 === void 0 ? void 0 : _source$meta12.physicalSizes.x.unit}`.replace('µ', 'u')), unit(`${(_source$meta13 = source.meta) === null || _source$meta13 === void 0 ? void 0 : _source$meta13.physicalSizes.y.size} ${(_source$meta14 = source.meta) === null || _source$meta14 === void 0 ? void 0 : _source$meta14.physicalSizes.y.unit}`.replace('µ', 'u'))];\n\n    if (hasZPhyscialSize) {\n      var _source$meta15, _source$meta16;\n\n      sizes.push(unit(`${(_source$meta15 = source.meta) === null || _source$meta15 === void 0 ? void 0 : _source$meta15.physicalSizes.z.size} ${(_source$meta16 = source.meta) === null || _source$meta16 === void 0 ? void 0 : _source$meta16.physicalSizes.z.unit}`.replace('µ', 'u')));\n    } // Find the ratio of the sizes to get the scaling factor.\n\n\n    const scale = sizes.map((i, k) => divide(i, minPhysicalSize[k])); // Add in z dimension needed for Matrix4 scale API.\n\n    if (!scale[2]) {\n      scale[2] = 1;\n    } // no need to store/use identity scaling\n\n\n    if (isEqual(scale, [1, 1, 1])) {\n      return meta;\n    } // Make sure to scale the z direction by one.\n\n\n    const matrix = new Matrix4().scale([...scale]);\n    const newMeta = { ...meta\n    };\n    newMeta.metadata = { ...newMeta.metadata,\n      // We don't want to store matrix objects in the view config.\n      transform: {\n        matrix: matrix.toArray()\n      }\n    };\n    return newMeta;\n  });\n  return imageMetaWithTransform;\n}\n/**\n * Given a set of image layer loader creator functions,\n * create loader objects for an initial layer or set of layers,\n * which will be selected based on default values predefined in\n * the image data file or otherwise by a heuristic\n * (the midpoint of the layers array).\n * @param {object[]} rasterLayers A list of layer metadata objects with\n * shape { name, type, url, createLoader }.\n * @param {(string[]|null)} rasterRenderLayers A list of default raster layers. Optional.\n */\n\n\nexport async function initializeRasterLayersAndChannels(rasterLayers, rasterRenderLayers, usePhysicalSizeScaling) {\n  const nextImageLoaders = [];\n  let nextImageMetaAndLayers = [];\n  const autoImageLayerDefPromises = []; // Start all loader creators immediately.\n  // Reference: https://eslint.org/docs/rules/no-await-in-loop\n\n  const loaders = await Promise.all(rasterLayers.map(layer => layer.loaderCreator()));\n\n  for (let i = 0; i < rasterLayers.length; i++) {\n    const layer = rasterLayers[i];\n    const loader = loaders[i];\n    nextImageLoaders[i] = loader;\n    nextImageMetaAndLayers[i] = layer;\n  }\n\n  if (usePhysicalSizeScaling) {\n    nextImageMetaAndLayers = getMetaWithTransformMatrices(nextImageMetaAndLayers, nextImageLoaders);\n  } // No layers were pre-defined so set up the default image layers.\n\n\n  if (!rasterRenderLayers) {\n    // Midpoint of images list as default image to show.\n    const layerIndex = Math.floor(rasterLayers.length / 2);\n    const loader = nextImageLoaders[layerIndex];\n    const autoImageLayerDefPromise = initializeLayerChannels(loader).then(channels => {\n      var _nextImageMetaAndLaye, _nextImageMetaAndLaye2, _nextImageMetaAndLaye3, _nextImageMetaAndLaye4, _nextImageMetaAndLaye5;\n\n      return Promise.resolve({\n        type: ((_nextImageMetaAndLaye = nextImageMetaAndLayers[layerIndex]) === null || _nextImageMetaAndLaye === void 0 ? void 0 : (_nextImageMetaAndLaye2 = _nextImageMetaAndLaye.metadata) === null || _nextImageMetaAndLaye2 === void 0 ? void 0 : _nextImageMetaAndLaye2.isBitmask) ? 'bitmask' : 'raster',\n        index: layerIndex,\n        ...DEFAULT_RASTER_LAYER_PROPS,\n        channels: channels.map((channel, j) => ({ ...channel,\n          ...(nextImageMetaAndLayers[layerIndex].channels ? nextImageMetaAndLayers[layerIndex].channels[j] : [])\n        })),\n        modelMatrix: (_nextImageMetaAndLaye3 = nextImageMetaAndLayers[layerIndex]) === null || _nextImageMetaAndLaye3 === void 0 ? void 0 : (_nextImageMetaAndLaye4 = _nextImageMetaAndLaye3.metadata) === null || _nextImageMetaAndLaye4 === void 0 ? void 0 : (_nextImageMetaAndLaye5 = _nextImageMetaAndLaye4.transform) === null || _nextImageMetaAndLaye5 === void 0 ? void 0 : _nextImageMetaAndLaye5.matrix,\n        transparentColor: layerIndex > 0 ? [0, 0, 0] : null\n      });\n    });\n    autoImageLayerDefPromises.push(autoImageLayerDefPromise);\n  } else {\n    // The renderLayers parameter is a list of layer names to show by default.\n    const globalIndicesOfRenderLayers = rasterRenderLayers.map(imageName => rasterLayers.findIndex(image => image.name === imageName));\n\n    for (let i = 0; i < globalIndicesOfRenderLayers.length; i++) {\n      const layerIndex = globalIndicesOfRenderLayers[i];\n      const loader = nextImageLoaders[layerIndex];\n      const autoImageLayerDefPromise = initializeLayerChannels(loader) // eslint-disable-next-line no-loop-func\n      .then(channels => {\n        var _nextImageMetaAndLaye6, _nextImageMetaAndLaye7, _nextImageMetaAndLaye8, _nextImageMetaAndLaye9, _nextImageMetaAndLaye10;\n\n        return Promise.resolve({\n          type: ((_nextImageMetaAndLaye6 = nextImageMetaAndLayers[layerIndex]) === null || _nextImageMetaAndLaye6 === void 0 ? void 0 : (_nextImageMetaAndLaye7 = _nextImageMetaAndLaye6.metadata) === null || _nextImageMetaAndLaye7 === void 0 ? void 0 : _nextImageMetaAndLaye7.isBitmask) ? 'bitmask' : 'raster',\n          index: layerIndex,\n          ...DEFAULT_RASTER_LAYER_PROPS,\n          channels: channels.map((channel, j) => ({ ...channel,\n            ...(nextImageMetaAndLayers[layerIndex].channels ? nextImageMetaAndLayers[layerIndex].channels[j] : [])\n          })),\n          domainType: 'Min/Max',\n          modelMatrix: (_nextImageMetaAndLaye8 = nextImageMetaAndLayers[layerIndex]) === null || _nextImageMetaAndLaye8 === void 0 ? void 0 : (_nextImageMetaAndLaye9 = _nextImageMetaAndLaye8.metadata) === null || _nextImageMetaAndLaye9 === void 0 ? void 0 : (_nextImageMetaAndLaye10 = _nextImageMetaAndLaye9.transform) === null || _nextImageMetaAndLaye10 === void 0 ? void 0 : _nextImageMetaAndLaye10.matrix,\n          transparentColor: i > 0 ? [0, 0, 0] : null\n        });\n      });\n      autoImageLayerDefPromises.push(autoImageLayerDefPromise);\n    }\n  }\n\n  const autoImageLayerDefs = await Promise.all(autoImageLayerDefPromises);\n  return [autoImageLayerDefs, nextImageLoaders, nextImageMetaAndLayers];\n}\n/**\n * Make a subtitle for the spatial component.\n * @param {object} params\n * @param {number} params.observationsCount\n * @param {string} params.observationsLabel\n * @param {string} params.observationsPluralLabel\n * @param {number} params.subobservationsCount\n * @param {string} params.subobservationsLabel\n * @param {string} params.subobservationsPluralLabel\n * @param {number} params.locationsCount\n * @returns {string} The subtitle string,\n * with info about items with zero counts omitted.\n */\n\nexport function makeSpatialSubtitle({\n  observationsCount,\n  observationsLabel,\n  observationsPluralLabel,\n  subobservationsCount,\n  subobservationsLabel,\n  subobservationsPluralLabel,\n  locationsCount\n}) {\n  const parts = [];\n\n  if (subobservationsCount > 0) {\n    let part = `${subobservationsCount} ${pluralize(subobservationsLabel, subobservationsPluralLabel, subobservationsCount)}`;\n\n    if (locationsCount > 0) {\n      part += ` at ${shortNumber(locationsCount)} locations`;\n    }\n\n    parts.push(part);\n  }\n\n  if (observationsCount > 0) {\n    parts.push(`${observationsCount} ${pluralize(observationsLabel, observationsPluralLabel, observationsCount)}`);\n  }\n\n  return parts.join(', ');\n}\nexport function getInitialSpatialTargets({\n  width,\n  height,\n  cells,\n  imageLayerLoaders,\n  useRaster,\n  use3d\n}) {\n  let initialTargetX = -Infinity;\n  let initialTargetY = -Infinity;\n  let initialTargetZ = -Infinity;\n  let initialZoom = -Infinity; // Some backoff from completely filling the screen.\n\n  const zoomBackoff = use3d ? 1.5 : 0.1;\n  const cellValues = Object.values(cells);\n\n  if (imageLayerLoaders.length > 0 && useRaster) {\n    for (let i = 0; i < imageLayerLoaders.length; i += 1) {\n      const viewSize = {\n        height,\n        width\n      };\n      const {\n        target,\n        zoom: newViewStateZoom\n      } = getDefaultInitialViewState(imageLayerLoaders[i].data, viewSize, zoomBackoff, use3d);\n\n      if (target[0] > initialTargetX) {\n        // eslint-disable-next-line prefer-destructuring\n        initialTargetX = target[0];\n        initialZoom = newViewStateZoom;\n      }\n\n      if (target[1] > initialTargetY) {\n        // eslint-disable-next-line prefer-destructuring\n        initialTargetY = target[1];\n        initialZoom = newViewStateZoom;\n      }\n\n      if (target[2] > initialTargetZ) {\n        // eslint-disable-next-line prefer-destructuring\n        initialTargetZ = target[2];\n        initialZoom = newViewStateZoom;\n      } else {\n        initialTargetZ = null;\n      }\n    }\n  } else if (cellValues.length > 0 // Only use cellValues in quadtree calculation if there is\n  // centroid data in the cells (i.e not just ids).\n  && cellValues[0].xy && !useRaster) {\n    const cellCoordinates = cellValues.map(c => c.xy);\n    let xExtent = extent(cellCoordinates, c => c[0]);\n    let yExtent = extent(cellCoordinates, c => c[1]);\n    let xRange = xExtent[1] - xExtent[0];\n    let yRange = yExtent[1] - yExtent[0];\n\n    const getViewExtentFromPolygonExtents = extents => [Math.min(...extents.map(i => i[0])), Math.max(...extents.map(i => i[1]))];\n\n    if (xRange === 0) {\n      // The fall back is the cells' polygon coordinates, if the original range\n      // is 0 i.e the centroids are all on the same axis.\n      const polygonExtentsX = cellValues.map(cell => extent(cell.poly, i => i[0]));\n      xExtent = getViewExtentFromPolygonExtents(polygonExtentsX);\n      xRange = xExtent[1] - xExtent[0];\n    }\n\n    if (yRange === 0) {\n      // The fall back is the first cells' polygon coordinates, if the original range\n      // is 0 i.e the centroids are all on the same axis.\n      const polygonExtentsY = cellValues.map(cell => extent(cell.poly, i => i[1]));\n      yExtent = getViewExtentFromPolygonExtents(polygonExtentsY);\n      yRange = yExtent[1] - yExtent[0];\n    }\n\n    initialTargetX = xExtent[0] + xRange / 2;\n    initialTargetY = yExtent[0] + yRange / 2;\n    initialTargetZ = null;\n    initialZoom = Math.log2(Math.min(width / xRange, height / yRange)) - zoomBackoff;\n  } else {\n    return {\n      initialTargetX: null,\n      initialTargetY: null,\n      initialTargetZ: null,\n      initialZoom: null\n    };\n  }\n\n  return {\n    initialTargetX,\n    initialTargetY,\n    initialZoom,\n    initialTargetZ\n  };\n}\n/**\n * Make a subtitle for the spatial component.\n * @param {object} data PixelSource | PixelSource[]\n * @returns {Array} [Layer, PixelSource | PixelSource[]] tuple.\n */\n\nexport function getLayerLoaderTuple(data, use3d) {\n  const loader = Array.isArray(data) && data.length > 1 || !Array.isArray(data) ? data : data[0];\n\n  if (use3d) {\n    return [VolumeLayer, Array.isArray(loader) ? loader : [loader]];\n  }\n\n  const Layer = Array.isArray(data) && data.length > 1 ? MultiscaleImageLayer : ImageLayer;\n  return [Layer, loader];\n}\nexport function renderSubBitmaskLayers(props) {\n  const {\n    bbox: {\n      left,\n      top,\n      right,\n      bottom\n    },\n    x,\n    y,\n    z\n  } = props.tile;\n  const {\n    data,\n    id,\n    loader\n  } = props; // Only render in positive coorinate system\n\n  if ([left, bottom, right, top].some(v => v < 0) || !data) {\n    return null;\n  }\n\n  const base = loader[0];\n  const [height, width] = loader[0].shape.slice(-2); // Tiles are exactly fitted to have height and width such that their bounds\n  // match that of the actual image (not some padded version).\n  // Thus the right/bottom given by deck.gl are incorrect since\n  // they assume tiles are of uniform sizes, which is not the case for us.\n\n  const bounds = [left, data.height < base.tileSize ? height : bottom, data.width < base.tileSize ? width : right, top];\n  return new BitmaskLayer(props, {\n    channelData: data,\n    // Uncomment to help debugging - shades the tile being hovered over.\n    // autoHighlight: true,\n    // highlightColor: [80, 80, 80, 50],\n    // Shared props with BitmapLayer:\n    bounds,\n    id: `sub-layer-${bounds}-${id}`,\n    tileId: {\n      x,\n      y,\n      z\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/spatial/utils.js"],"names":["shortNumber","isEqual","getDefaultInitialViewState","MultiscaleImageLayer","ImageLayer","VolumeLayer","extent","Matrix4","divide","compare","unit","pluralize","getSourceFromLoader","isRgb","VIEWER_PALETTE","GLOBAL_LABELS","DEFAULT_RASTER_LAYER_PROPS","DEFAULT_LAYER_TYPE_ORDERING","BitmaskLayer","getMultiSelectionStats","square","x","y","r","sortLayers","layers","sort","a","b","indexOf","type","getDefaultGlobalSelection","source","globalIndices","labels","filter","dim","includes","selection","forEach","Math","floor","shape","buildDefaultSelection","globalSelection","firstNonGlobalDimension","i","min","push","isInterleaved","lastDimSize","length","initializeLayerChannels","loader","use3d","result","defaultSelection","c","stats","data","selections","domains","colors","sliders","domain","slider","channel","color","visible","getMetaWithTransformMatrices","imageMeta","imageLoaders","sources","map","meta","metadata","transform","matrix","scale","translate","some","Boolean","every","physicalSizes","minPhysicalSize","reduce","acc","hasZPhyscialSize","z","size","sizes","replace","undefined","imageMetaWithTransform","j","k","newMeta","toArray","initializeRasterLayersAndChannels","rasterLayers","rasterRenderLayers","usePhysicalSizeScaling","nextImageLoaders","nextImageMetaAndLayers","autoImageLayerDefPromises","loaders","Promise","all","layer","loaderCreator","layerIndex","autoImageLayerDefPromise","then","channels","resolve","isBitmask","index","modelMatrix","transparentColor","globalIndicesOfRenderLayers","imageName","findIndex","image","name","domainType","autoImageLayerDefs","makeSpatialSubtitle","observationsCount","observationsLabel","observationsPluralLabel","subobservationsCount","subobservationsLabel","subobservationsPluralLabel","locationsCount","parts","part","join","getInitialSpatialTargets","width","height","cells","imageLayerLoaders","useRaster","initialTargetX","Infinity","initialTargetY","initialTargetZ","initialZoom","zoomBackoff","cellValues","Object","values","viewSize","target","zoom","newViewStateZoom","xy","cellCoordinates","xExtent","yExtent","xRange","yRange","getViewExtentFromPolygonExtents","extents","max","polygonExtentsX","cell","poly","polygonExtentsY","log2","getLayerLoaderTuple","Array","isArray","Layer","renderSubBitmaskLayers","props","bbox","left","top","right","bottom","tile","id","v","base","slice","bounds","tileSize","channelData","tileId"],"mappings":"AAAA;AACA,OAAOA,WAAP,MAAwB,cAAxB;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SACEC,0BADF,EAEEC,oBAFF,EAGEC,UAHF,EAIEC,WAJF,QAKO,eALP;AAMA,SAASC,MAAT,QAAuB,UAAvB;AACA,SAASC,OAAT,QAAwB,SAAxB;AACA,SAASC,MAAT,EAAiBC,OAAjB,EAA0BC,IAA1B,QAAsC,QAAtC;AACA,SAASC,SAAT,EAAoBC,mBAApB,EAAyCC,KAAzC,QAAsD,aAAtD;AACA,SAASC,cAAT,QAA+B,UAA/B;AACA,SACEC,aADF,EAEEC,0BAFF,EAGEC,2BAHF,QAIO,aAJP;AAKA,OAAOC,YAAP,MAAyB,2BAAzB;AACA,SAASC,sBAAT,QAAuC,2BAAvC;AAEA,OAAO,SAASC,MAAT,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyB;AAC9B,SAAO,CAAC,CAACF,CAAD,EAAIC,CAAC,GAAGC,CAAR,CAAD,EAAa,CAACF,CAAC,GAAGE,CAAL,EAAQD,CAAR,CAAb,EAAyB,CAACD,CAAD,EAAIC,CAAC,GAAGC,CAAR,CAAzB,EAAqC,CAACF,CAAC,GAAGE,CAAL,EAAQD,CAAR,CAArC,CAAP;AACD;AAED;;;;;;;;;;;AAUA,OAAO,SAASE,UAAT,CAAoBC,MAApB,EAA4B;AACjC,SAAOA,MAAM,CAACC,IAAP,CAAY,CAACC,CAAD,EAAIC,CAAJ,KACjBX,2BAA2B,CAACY,OAA5B,CAAoCF,CAAC,CAACG,IAAtC,IAA8Cb,2BAA2B,CAACY,OAA5B,CAAoCD,CAAC,CAACE,IAAtC,CADzC,CAAP;AAGD;AAED;;;;;;AAKA,SAASC,yBAAT,CAAmCC,MAAnC,EAA2C;AACzC,QAAMC,aAAa,GAAGD,MAAM,CAACE,MAAP,CACnBC,MADmB,CACZC,GAAG,IAAIrB,aAAa,CAACsB,QAAd,CAAuBD,GAAvB,CADK,CAAtB;AAEA,QAAME,SAAS,GAAG,EAAlB;AACAL,EAAAA,aAAa,CAACM,OAAd,CAAuBH,GAAD,IAAS;AAC7BE,IAAAA,SAAS,CAACF,GAAD,CAAT,GAAiBI,IAAI,CAACC,KAAL,CACf,CAACT,MAAM,CAACU,KAAP,CAAaV,MAAM,CAACE,MAAP,CAAcL,OAAd,CAAsBO,GAAtB,CAAb,KAA4C,CAA7C,IAAkD,CADnC,CAAjB;AAGD,GAJD;AAKA,SAAOE,SAAP;AACD;AAED;;;;;;;;AAMA,SAASK,qBAAT,CAA+BX,MAA/B,EAAuC;AACrC,QAAMM,SAAS,GAAG,EAAlB;AACA,QAAMM,eAAe,GAAGb,yBAAyB,CAACC,MAAD,CAAjD,CAFqC,CAGrC;;AACA,QAAMa,uBAAuB,GAAGb,MAAM,CAACE,MAAP,CAAcC,MAAd,CAC9BC,GAAG,IAAI,CAACrB,aAAa,CAACsB,QAAd,CAAuBD,GAAvB,CAAD,IACFJ,MAAM,CAACU,KAAP,CAAaV,MAAM,CAACE,MAAP,CAAcL,OAAd,CAAsBO,GAAtB,CAAb,CAFyB,EAG9B,CAH8B,CAAhC;;AAIA,OAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACO,GAAL,CAAS,CAAT,EAAYf,MAAM,CAACU,KAAP,CAC9BV,MAAM,CAACE,MAAP,CAAcL,OAAd,CAAsBgB,uBAAtB,CAD8B,CAAZ,CAApB,EAEIC,CAAC,IAAI,CAFT,EAEY;AACVR,IAAAA,SAAS,CAACU,IAAV,CACE;AACE,OAACH,uBAAD,GAA2BC,CAD7B;AAEE,SAAGF;AAFL,KADF;AAMD;;AACD,SAAON,SAAP;AACD;AAED;;;;;AAGA,OAAO,SAASW,aAAT,CAAuBP,KAAvB,EAA8B;AACnC,QAAMQ,WAAW,GAAGR,KAAK,CAACA,KAAK,CAACS,MAAN,GAAe,CAAhB,CAAzB;AACA,SAAOD,WAAW,KAAK,CAAhB,IAAqBA,WAAW,KAAK,CAA5C;AACD;AAED;;;;;;;;AAOA,OAAO,eAAeE,uBAAf,CAAuCC,MAAvC,EAA+CC,KAA/C,EAAsD;AAC3D,QAAMC,MAAM,GAAG,EAAf;AACA,QAAMvB,MAAM,GAAGpB,mBAAmB,CAACyC,MAAD,CAAlC,CAF2D,CAG3D;;AACA,MAAIG,gBAAgB,GAAGb,qBAAqB,CAACX,MAAD,CAA5C;AACAwB,EAAAA,gBAAgB,GAAGP,aAAa,CAACjB,MAAM,CAACU,KAAR,CAAb,GACf,CAAC,EAAE,GAAGc,gBAAgB,CAAC,CAAD,CAArB;AAA0BC,IAAAA,CAAC,EAAE;AAA7B,GAAD,CADe,GACsBD,gBADzC;AAEA,QAAME,KAAK,GAAG,MAAMvC,sBAAsB,CAAC;AACzCkC,IAAAA,MAAM,EAAEA,MAAM,CAACM,IAD0B;AACpBC,IAAAA,UAAU,EAAEJ,gBADQ;AACUF,IAAAA;AADV,GAAD,CAA1C;AAIA,QAAMO,OAAO,GAAGhD,KAAK,CAACwC,MAAD,CAAL,GACZ,CAAC,CAAC,CAAD,EAAI,GAAJ,CAAD,EAAW,CAAC,CAAD,EAAI,GAAJ,CAAX,EAAqB,CAAC,CAAD,EAAI,GAAJ,CAArB,CADY,GAEZK,KAAK,CAACG,OAFV;AAGA,QAAMC,MAAM,GAAGjD,KAAK,CAACwC,MAAD,CAAL,GACX,CAAC,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,CAAD,EAAc,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,CAAd,EAA2B,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,CAA3B,CADW,GAEX,IAFJ;AAGA,QAAMU,OAAO,GAAGlD,KAAK,CAACwC,MAAD,CAAL,GACZ,CAAC,CAAC,CAAD,EAAI,GAAJ,CAAD,EAAW,CAAC,CAAD,EAAI,GAAJ,CAAX,EAAqB,CAAC,CAAD,EAAI,GAAJ,CAArB,CADY,GAEZK,KAAK,CAACK,OAFV;AAIAP,EAAAA,gBAAgB,CAACjB,OAAjB,CAAyB,CAACD,SAAD,EAAYQ,CAAZ,KAAkB;AACzC,UAAMkB,MAAM,GAAGH,OAAO,CAACf,CAAD,CAAtB;AACA,UAAMmB,MAAM,GAAGF,OAAO,CAACjB,CAAD,CAAtB;AACA,UAAMoB,OAAO,GAAG;AACd5B,MAAAA,SADc;AAEd;AACA6B,MAAAA,KAAK,EAAEL,MAAM,GAAGA,MAAM,CAAChB,CAAD,CAAT,GACTU,gBAAgB,CAACL,MAAjB,KAA4B,CAA5B,GACErC,cAAc,CAACgC,CAAD,CADhB,GACsB,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CALZ;AAMdsB,MAAAA,OAAO,EAAE,IANK;AAOdH,MAAAA,MAAM,EAAEA,MAAM,IAAID;AAPJ,KAAhB;AASAT,IAAAA,MAAM,CAACP,IAAP,CAAYkB,OAAZ;AACD,GAbD;AAcA,SAAOX,MAAP;AACD;;AAED,SAASc,4BAAT,CAAsCC,SAAtC,EAAiDC,YAAjD,EAA+D;AAC7D;AACA,QAAMC,OAAO,GAAGD,YAAY,CAACE,GAAb,CAAiBpB,MAAM,IAAIzC,mBAAmB,CAACyC,MAAD,CAA9C,CAAhB;;AACA,MACEiB,SAAS,CAACG,GAAV,CAAcC,IAAI;AAAA;;AAAA,WAAI,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,8BAAAA,IAAI,CAAEC,QAAN,2FAAgBC,SAAhB,gFAA2BC,MAA3B,MACjBH,IADiB,aACjBA,IADiB,0CACjBA,IAAI,CAAEC,QADW,6EACjB,gBAAgBC,SADC,0DACjB,sBAA2BE,KADV,MAEjBJ,IAFiB,aAEjBA,IAFiB,0CAEjBA,IAAI,CAAEC,QAFW,6EAEjB,gBAAgBC,SAFC,0DAEjB,sBAA2BG,SAFV,CAAJ;AAAA,GAAlB,EAE2CC,IAF3C,CAEgDC,OAFhD,KAGGT,OAAO,CAACU,KAAR,CACDlD,MAAM;AAAA;;AAAA,WAAI,kBAACA,MAAM,CAAC0C,IAAR,0EAAC,aAAaS,aAAd,0DAAC,sBAA4B9D,CAA7B,KAAkC,mBAACW,MAAM,CAAC0C,IAAR,2EAAC,cAAaS,aAAd,0DAAC,sBAA4B7D,CAA7B,CAAtC;AAAA,GADL,CAJL,EAOE;AACA,WAAOgD,SAAP;AACD,GAZ4D,CAa7D;;;AACA,QAAMc,eAAe,GAAGZ,OAAO,CAACa,MAAR,CAAe,CAACC,GAAD,EAAMtD,MAAN,KAAiB;AAAA;;AACtD,UAAMuD,gBAAgB,oBAAGvD,MAAM,CAAC0C,IAAV,2EAAG,cAAaS,aAAhB,oFAAG,sBAA4BK,CAA/B,2DAAG,uBAA+BC,IAAxD;AACA,UAAMC,KAAK,GAAG,CACZhF,IAAI,CAAE,GAAD,iBAAGsB,MAAM,CAAC0C,IAAV,kDAAG,cAAaS,aAAb,CAA2B9D,CAA3B,CAA6BoE,IAAK,IAArC,iBAAwCzD,MAAM,CAAC0C,IAA/C,kDAAwC,cAAaS,aAAb,CAA2B9D,CAA3B,CAA6BX,IAAK,EAA1E,CAA4EiF,OAA5E,CAAoF,GAApF,EAAyF,GAAzF,CAAD,CADQ,EAEZjF,IAAI,CAAE,GAAD,iBAAGsB,MAAM,CAAC0C,IAAV,kDAAG,cAAaS,aAAb,CAA2B7D,CAA3B,CAA6BmE,IAAK,IAArC,iBAAwCzD,MAAM,CAAC0C,IAA/C,kDAAwC,cAAaS,aAAb,CAA2B7D,CAA3B,CAA6BZ,IAAK,EAA1E,CAA4EiF,OAA5E,CAAoF,GAApF,EAAyF,GAAzF,CAAD,CAFQ,CAAd;;AAIA,QAAIJ,gBAAJ,EAAsB;AAAA;;AACpBG,MAAAA,KAAK,CAAC1C,IAAN,CAAWtC,IAAI,CAAE,GAAD,iBAAGsB,MAAM,CAAC0C,IAAV,kDAAG,cAAaS,aAAb,CAA2BK,CAA3B,CAA6BC,IAAK,IAArC,iBAAwCzD,MAAM,CAAC0C,IAA/C,kDAAwC,cAAaS,aAAb,CAA2BK,CAA3B,CAA6B9E,IAAK,EAA1E,CAA4EiF,OAA5E,CAAoF,GAApF,EAAyF,GAAzF,CAAD,CAAf;AACD;;AACDL,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAUA,GAAG,CAAC,CAAD,CAAH,KAAWM,SAAX,IAAwBnF,OAAO,CAACiF,KAAK,CAAC,CAAD,CAAN,EAAWJ,GAAG,CAAC,CAAD,CAAd,CAAP,KAA8B,CAAC,CAAxD,GAA6DI,KAAK,CAAC,CAAD,CAAlE,GAAwEJ,GAAG,CAAC,CAAD,CAApF;AACAA,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAUA,GAAG,CAAC,CAAD,CAAH,KAAWM,SAAX,IAAwBnF,OAAO,CAACiF,KAAK,CAAC,CAAD,CAAN,EAAWJ,GAAG,CAAC,CAAD,CAAd,CAAP,KAA8B,CAAC,CAAxD,GAA6DI,KAAK,CAAC,CAAD,CAAlE,GAAwEJ,GAAG,CAAC,CAAD,CAApF;AACAA,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAUA,GAAG,CAAC,CAAD,CAAH,KAAWM,SAAX,IAAwBnF,OAAO,CAACiF,KAAK,CAAC,CAAD,CAAN,EAAWJ,GAAG,CAAC,CAAD,CAAd,CAAP,KAA8B,CAAC,CAAxD,GAA6DI,KAAK,CAAC,CAAD,CAAlE,GAAwEJ,GAAG,CAAC,CAAD,CAApF;AACA,WAAOA,GAAP;AACD,GAbuB,EAarB,EAbqB,CAAxB;AAcA,QAAMO,sBAAsB,GAAGvB,SAAS,CAACG,GAAV,CAAc,CAACC,IAAD,EAAOoB,CAAP,KAAa;AAAA;;AACxD,UAAM9D,MAAM,GAAGwC,OAAO,CAACsB,CAAD,CAAtB;AACA,UAAMP,gBAAgB,qBAAGvD,MAAM,CAAC0C,IAAV,4EAAG,eAAaS,aAAhB,oFAAG,sBAA4BK,CAA/B,2DAAG,uBAA+BC,IAAxD;AACA,UAAMC,KAAK,GAAG,CACZhF,IAAI,CAAE,GAAD,kBAAGsB,MAAM,CAAC0C,IAAV,mDAAG,eAAaS,aAAb,CAA2B9D,CAA3B,CAA6BoE,IAAK,IAArC,kBAAwCzD,MAAM,CAAC0C,IAA/C,mDAAwC,eAAaS,aAAb,CAA2B9D,CAA3B,CAA6BX,IAAK,EAA1E,CAA4EiF,OAA5E,CAAoF,GAApF,EAAyF,GAAzF,CAAD,CADQ,EAEZjF,IAAI,CAAE,GAAD,kBAAGsB,MAAM,CAAC0C,IAAV,mDAAG,eAAaS,aAAb,CAA2B7D,CAA3B,CAA6BmE,IAAK,IAArC,kBAAwCzD,MAAM,CAAC0C,IAA/C,mDAAwC,eAAaS,aAAb,CAA2B7D,CAA3B,CAA6BZ,IAAK,EAA1E,CAA4EiF,OAA5E,CAAoF,GAApF,EAAyF,GAAzF,CAAD,CAFQ,CAAd;;AAIA,QAAIJ,gBAAJ,EAAsB;AAAA;;AACpBG,MAAAA,KAAK,CAAC1C,IAAN,CAAWtC,IAAI,CAAE,GAAD,kBAAGsB,MAAM,CAAC0C,IAAV,mDAAG,eAAaS,aAAb,CAA2BK,CAA3B,CAA6BC,IAAK,IAArC,kBAAwCzD,MAAM,CAAC0C,IAA/C,mDAAwC,eAAaS,aAAb,CAA2BK,CAA3B,CAA6B9E,IAAK,EAA1E,CAA4EiF,OAA5E,CAAoF,GAApF,EAAyF,GAAzF,CAAD,CAAf;AACD,KATuD,CAUxD;;;AACA,UAAMb,KAAK,GAAGY,KAAK,CAACjB,GAAN,CAAU,CAAC3B,CAAD,EAAIiD,CAAJ,KAAUvF,MAAM,CAACsC,CAAD,EAAIsC,eAAe,CAACW,CAAD,CAAnB,CAA1B,CAAd,CAXwD,CAYxD;;AACA,QAAI,CAACjB,KAAK,CAAC,CAAD,CAAV,EAAe;AACbA,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAW,CAAX;AACD,KAfuD,CAgBxD;;;AACA,QAAI7E,OAAO,CAAC6E,KAAD,EAAQ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAR,CAAX,EAA+B;AAC7B,aAAOJ,IAAP;AACD,KAnBuD,CAoBxD;;;AACA,UAAMG,MAAM,GAAG,IAAItE,OAAJ,GAAcuE,KAAd,CAAoB,CAAC,GAAGA,KAAJ,CAApB,CAAf;AACA,UAAMkB,OAAO,GAAG,EAAE,GAAGtB;AAAL,KAAhB;AACAsB,IAAAA,OAAO,CAACrB,QAAR,GAAmB,EACjB,GAAGqB,OAAO,CAACrB,QADM;AAEjB;AACAC,MAAAA,SAAS,EAAE;AAAEC,QAAAA,MAAM,EAAEA,MAAM,CAACoB,OAAP;AAAV;AAHM,KAAnB;AAKA,WAAOD,OAAP;AACD,GA7B8B,CAA/B;AA8BA,SAAOH,sBAAP;AACD;AAED;;;;;;;;;;;;AAUA,OAAO,eAAeK,iCAAf,CACLC,YADK,EAELC,kBAFK,EAGLC,sBAHK,EAIL;AACA,QAAMC,gBAAgB,GAAG,EAAzB;AACA,MAAIC,sBAAsB,GAAG,EAA7B;AACA,QAAMC,yBAAyB,GAAG,EAAlC,CAHA,CAKA;AACA;;AACA,QAAMC,OAAO,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYR,YAAY,CAAC1B,GAAb,CAAiBmC,KAAK,IAAIA,KAAK,CAACC,aAAN,EAA1B,CAAZ,CAAtB;;AAEA,OAAK,IAAI/D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,YAAY,CAAChD,MAAjC,EAAyCL,CAAC,EAA1C,EAA8C;AAC5C,UAAM8D,KAAK,GAAGT,YAAY,CAACrD,CAAD,CAA1B;AACA,UAAMO,MAAM,GAAGoD,OAAO,CAAC3D,CAAD,CAAtB;AACAwD,IAAAA,gBAAgB,CAACxD,CAAD,CAAhB,GAAsBO,MAAtB;AACAkD,IAAAA,sBAAsB,CAACzD,CAAD,CAAtB,GAA4B8D,KAA5B;AACD;;AACD,MAAIP,sBAAJ,EAA4B;AAC1BE,IAAAA,sBAAsB,GAAGlC,4BAA4B,CAACkC,sBAAD,EAAyBD,gBAAzB,CAArD;AACD,GAjBD,CAkBA;;;AACA,MAAI,CAACF,kBAAL,EAAyB;AACvB;AACA,UAAMU,UAAU,GAAGtE,IAAI,CAACC,KAAL,CAAW0D,YAAY,CAAChD,MAAb,GAAsB,CAAjC,CAAnB;AACA,UAAME,MAAM,GAAGiD,gBAAgB,CAACQ,UAAD,CAA/B;AACA,UAAMC,wBAAwB,GAAG3D,uBAAuB,CAACC,MAAD,CAAvB,CAC9B2D,IAD8B,CACzBC,QAAQ;AAAA;;AAAA,aAAIP,OAAO,CAACQ,OAAR,CAAgB;AAChCpF,QAAAA,IAAI,EAAE,0BAAAyE,sBAAsB,CAACO,UAAD,CAAtB,0GAAoCnC,QAApC,kFAA8CwC,SAA9C,IAA0D,SAA1D,GAAsE,QAD5C;AAEhCC,QAAAA,KAAK,EAAEN,UAFyB;AAGhC,WAAG9F,0BAH6B;AAIhCiG,QAAAA,QAAQ,EAAEA,QAAQ,CAACxC,GAAT,CAAa,CAACP,OAAD,EAAU4B,CAAV,MAAiB,EACtC,GAAG5B,OADmC;AAEtC,cAAIqC,sBAAsB,CAACO,UAAD,CAAtB,CAAmCG,QAAnC,GACAV,sBAAsB,CAACO,UAAD,CAAtB,CAAmCG,QAAnC,CAA4CnB,CAA5C,CADA,GACiD,EADrD;AAFsC,SAAjB,CAAb,CAJsB;AAShCuB,QAAAA,WAAW,4BAAEd,sBAAsB,CAACO,UAAD,CAAxB,qFAAE,uBAAoCnC,QAAtC,qFAAE,uBAA8CC,SAAhD,2DAAE,uBAAyDC,MATtC;AAUhCyC,QAAAA,gBAAgB,EAAER,UAAU,GAAG,CAAb,GAAiB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAjB,GAA6B;AAVf,OAAhB,CAAJ;AAAA,KADiB,CAAjC;AAaAN,IAAAA,yBAAyB,CAACxD,IAA1B,CAA+B+D,wBAA/B;AACD,GAlBD,MAkBO;AACL;AACA,UAAMQ,2BAA2B,GAAGnB,kBAAkB,CACnD3B,GADiC,CAC7B+C,SAAS,IAAIrB,YAAY,CAACsB,SAAb,CAAuBC,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeH,SAA/C,CADgB,CAApC;;AAEA,SAAK,IAAI1E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyE,2BAA2B,CAACpE,MAAhD,EAAwDL,CAAC,EAAzD,EAA6D;AAC3D,YAAMgE,UAAU,GAAGS,2BAA2B,CAACzE,CAAD,CAA9C;AACA,YAAMO,MAAM,GAAGiD,gBAAgB,CAACQ,UAAD,CAA/B;AACA,YAAMC,wBAAwB,GAAG3D,uBAAuB,CAACC,MAAD,CAAvB,CAC/B;AAD+B,OAE9B2D,IAF8B,CAEzBC,QAAQ;AAAA;;AAAA,eAAIP,OAAO,CAACQ,OAAR,CAAgB;AAChCpF,UAAAA,IAAI,EAAE,2BAAAyE,sBAAsB,CAACO,UAAD,CAAtB,4GAAoCnC,QAApC,kFAA8CwC,SAA9C,IAA0D,SAA1D,GAAsE,QAD5C;AAEhCC,UAAAA,KAAK,EAAEN,UAFyB;AAGhC,aAAG9F,0BAH6B;AAIhCiG,UAAAA,QAAQ,EAAEA,QAAQ,CAACxC,GAAT,CAAa,CAACP,OAAD,EAAU4B,CAAV,MAAiB,EACtC,GAAG5B,OADmC;AAEtC,gBAAIqC,sBAAsB,CAACO,UAAD,CAAtB,CAAmCG,QAAnC,GACAV,sBAAsB,CAACO,UAAD,CAAtB,CAAmCG,QAAnC,CAA4CnB,CAA5C,CADA,GACiD,EADrD;AAFsC,WAAjB,CAAb,CAJsB;AAShC8B,UAAAA,UAAU,EAAE,SAToB;AAUhCP,UAAAA,WAAW,4BAAEd,sBAAsB,CAACO,UAAD,CAAxB,qFAAE,uBAAoCnC,QAAtC,sFAAE,uBAA8CC,SAAhD,4DAAE,wBAAyDC,MAVtC;AAWhCyC,UAAAA,gBAAgB,EAAExE,CAAC,GAAG,CAAJ,GAAQ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAR,GAAoB;AAXN,SAAhB,CAAJ;AAAA,OAFiB,CAAjC;AAeA0D,MAAAA,yBAAyB,CAACxD,IAA1B,CAA+B+D,wBAA/B;AACD;AACF;;AAED,QAAMc,kBAAkB,GAAG,MAAMnB,OAAO,CAACC,GAAR,CAAYH,yBAAZ,CAAjC;AACA,SAAO,CAACqB,kBAAD,EAAqBvB,gBAArB,EAAuCC,sBAAvC,CAAP;AACD;AAED;;;;;;;;;;;;;;AAaA,OAAO,SAASuB,mBAAT,CAA6B;AAClCC,EAAAA,iBADkC;AACfC,EAAAA,iBADe;AACIC,EAAAA,uBADJ;AAElCC,EAAAA,oBAFkC;AAEZC,EAAAA,oBAFY;AAEUC,EAAAA,0BAFV;AAGlCC,EAAAA;AAHkC,CAA7B,EAIJ;AACD,QAAMC,KAAK,GAAG,EAAd;;AACA,MAAIJ,oBAAoB,GAAG,CAA3B,EAA8B;AAC5B,QAAIK,IAAI,GAAI,GAAEL,oBAAqB,IAAGvH,SAAS,CAACwH,oBAAD,EAAuBC,0BAAvB,EAAmDF,oBAAnD,CAAyE,EAAxH;;AACA,QAAIG,cAAc,GAAG,CAArB,EAAwB;AACtBE,MAAAA,IAAI,IAAK,OAAMvI,WAAW,CAACqI,cAAD,CAAiB,YAA3C;AACD;;AACDC,IAAAA,KAAK,CAACtF,IAAN,CAAWuF,IAAX;AACD;;AACD,MAAIR,iBAAiB,GAAG,CAAxB,EAA2B;AACzBO,IAAAA,KAAK,CAACtF,IAAN,CAAY,GAAE+E,iBAAkB,IAAGpH,SAAS,CAACqH,iBAAD,EAAoBC,uBAApB,EAA6CF,iBAA7C,CAAgE,EAA5G;AACD;;AACD,SAAOO,KAAK,CAACE,IAAN,CAAW,IAAX,CAAP;AACD;AAED,OAAO,SAASC,wBAAT,CAAkC;AACvCC,EAAAA,KADuC;AAEvCC,EAAAA,MAFuC;AAGvCC,EAAAA,KAHuC;AAIvCC,EAAAA,iBAJuC;AAKvCC,EAAAA,SALuC;AAMvCxF,EAAAA;AANuC,CAAlC,EAOJ;AACD,MAAIyF,cAAc,GAAG,CAACC,QAAtB;AACA,MAAIC,cAAc,GAAG,CAACD,QAAtB;AACA,MAAIE,cAAc,GAAG,CAACF,QAAtB;AACA,MAAIG,WAAW,GAAG,CAACH,QAAnB,CAJC,CAKD;;AACA,QAAMI,WAAW,GAAG9F,KAAK,GAAG,GAAH,GAAS,GAAlC;AACA,QAAM+F,UAAU,GAAGC,MAAM,CAACC,MAAP,CAAcX,KAAd,CAAnB;;AACA,MAAIC,iBAAiB,CAAC1F,MAAlB,GAA2B,CAA3B,IAAgC2F,SAApC,EAA+C;AAC7C,SAAK,IAAIhG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+F,iBAAiB,CAAC1F,MAAtC,EAA8CL,CAAC,IAAI,CAAnD,EAAsD;AACpD,YAAM0G,QAAQ,GAAG;AAAEb,QAAAA,MAAF;AAAUD,QAAAA;AAAV,OAAjB;AACA,YAAM;AAAEe,QAAAA,MAAF;AAAUC,QAAAA,IAAI,EAAEC;AAAhB,UAAqCzJ,0BAA0B,CACnE2I,iBAAiB,CAAC/F,CAAD,CAAjB,CAAqBa,IAD8C,EAEnE6F,QAFmE,EAGnEJ,WAHmE,EAInE9F,KAJmE,CAArE;;AAMA,UAAImG,MAAM,CAAC,CAAD,CAAN,GAAYV,cAAhB,EAAgC;AAC9B;AACAA,QAAAA,cAAc,GAAGU,MAAM,CAAC,CAAD,CAAvB;AACAN,QAAAA,WAAW,GAAGQ,gBAAd;AACD;;AACD,UAAIF,MAAM,CAAC,CAAD,CAAN,GAAYR,cAAhB,EAAgC;AAC9B;AACAA,QAAAA,cAAc,GAAGQ,MAAM,CAAC,CAAD,CAAvB;AACAN,QAAAA,WAAW,GAAGQ,gBAAd;AACD;;AACD,UAAIF,MAAM,CAAC,CAAD,CAAN,GAAYP,cAAhB,EAAgC;AAC9B;AACAA,QAAAA,cAAc,GAAGO,MAAM,CAAC,CAAD,CAAvB;AACAN,QAAAA,WAAW,GAAGQ,gBAAd;AACD,OAJD,MAIO;AACLT,QAAAA,cAAc,GAAG,IAAjB;AACD;AACF;AACF,GA3BD,MA2BO,IAAIG,UAAU,CAAClG,MAAX,GAAoB,CAApB,CACT;AACA;AAFS,KAGNkG,UAAU,CAAC,CAAD,CAAV,CAAcO,EAHR,IAIN,CAACd,SAJC,EAIU;AACf,UAAMe,eAAe,GAAGR,UAAU,CAAC5E,GAAX,CAAehB,CAAC,IAAIA,CAAC,CAACmG,EAAtB,CAAxB;AACA,QAAIE,OAAO,GAAGxJ,MAAM,CAACuJ,eAAD,EAAkBpG,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAxB,CAApB;AACA,QAAIsG,OAAO,GAAGzJ,MAAM,CAACuJ,eAAD,EAAkBpG,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAxB,CAApB;AACA,QAAIuG,MAAM,GAAGF,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAAjC;AACA,QAAIG,MAAM,GAAGF,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAAjC;;AACA,UAAMG,+BAA+B,GAAGC,OAAO,IAAI,CACjD3H,IAAI,CAACO,GAAL,CAAS,GAAGoH,OAAO,CAAC1F,GAAR,CAAY3B,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAlB,CAAZ,CADiD,EAEjDN,IAAI,CAAC4H,GAAL,CAAS,GAAGD,OAAO,CAAC1F,GAAR,CAAY3B,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAlB,CAAZ,CAFiD,CAAnD;;AAIA,QAAIkH,MAAM,KAAK,CAAf,EAAkB;AAChB;AACA;AACA,YAAMK,eAAe,GAAGhB,UAAU,CAAC5E,GAAX,CAAe6F,IAAI,IAAIhK,MAAM,CAACgK,IAAI,CAACC,IAAN,EAAYzH,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAlB,CAA7B,CAAxB;AACAgH,MAAAA,OAAO,GAAGI,+BAA+B,CAACG,eAAD,CAAzC;AACAL,MAAAA,MAAM,GAAGF,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAA7B;AACD;;AACD,QAAIG,MAAM,KAAK,CAAf,EAAkB;AAChB;AACA;AACA,YAAMO,eAAe,GAAGnB,UAAU,CAAC5E,GAAX,CAAe6F,IAAI,IAAIhK,MAAM,CAACgK,IAAI,CAACC,IAAN,EAAYzH,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAlB,CAA7B,CAAxB;AACAiH,MAAAA,OAAO,GAAGG,+BAA+B,CAACM,eAAD,CAAzC;AACAP,MAAAA,MAAM,GAAGF,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAA7B;AACD;;AACDhB,IAAAA,cAAc,GAAGe,OAAO,CAAC,CAAD,CAAP,GAAaE,MAAM,GAAG,CAAvC;AACAf,IAAAA,cAAc,GAAGc,OAAO,CAAC,CAAD,CAAP,GAAaE,MAAM,GAAG,CAAvC;AACAf,IAAAA,cAAc,GAAG,IAAjB;AACAC,IAAAA,WAAW,GAAG3G,IAAI,CAACiI,IAAL,CAAUjI,IAAI,CAACO,GAAL,CAAS2F,KAAK,GAAGsB,MAAjB,EAAyBrB,MAAM,GAAGsB,MAAlC,CAAV,IAAuDb,WAArE;AACD,GAhCM,MAgCA;AACL,WAAO;AACLL,MAAAA,cAAc,EAAE,IADX;AACiBE,MAAAA,cAAc,EAAE,IADjC;AACuCC,MAAAA,cAAc,EAAE,IADvD;AAC6DC,MAAAA,WAAW,EAAE;AAD1E,KAAP;AAGD;;AACD,SAAO;AACLJ,IAAAA,cADK;AACWE,IAAAA,cADX;AAC2BE,IAAAA,WAD3B;AACwCD,IAAAA;AADxC,GAAP;AAGD;AAED;;;;;;AAKA,OAAO,SAASwB,mBAAT,CAA6B/G,IAA7B,EAAmCL,KAAnC,EAA0C;AAC/C,QAAMD,MAAM,GAAKsH,KAAK,CAACC,OAAN,CAAcjH,IAAd,KAAuBA,IAAI,CAACR,MAAL,GAAc,CAAtC,IAA4C,CAACwH,KAAK,CAACC,OAAN,CAAcjH,IAAd,CAA9C,GACXA,IADW,GACJA,IAAI,CAAC,CAAD,CADf;;AAEA,MAAIL,KAAJ,EAAW;AACT,WAAO,CAACjD,WAAD,EAAcsK,KAAK,CAACC,OAAN,CAAcvH,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAA/C,CAAP;AACD;;AACD,QAAMwH,KAAK,GAAIF,KAAK,CAACC,OAAN,CAAcjH,IAAd,KAAuBA,IAAI,CAACR,MAAL,GAAc,CAAtC,GAA2ChD,oBAA3C,GAAkEC,UAAhF;AACA,SAAO,CAACyK,KAAD,EAAQxH,MAAR,CAAP;AACD;AAGD,OAAO,SAASyH,sBAAT,CAAgCC,KAAhC,EAAuC;AAC5C,QAAM;AACJC,IAAAA,IAAI,EAAE;AACJC,MAAAA,IADI;AACEC,MAAAA,GADF;AACOC,MAAAA,KADP;AACcC,MAAAA;AADd,KADF;AAIJ/J,IAAAA,CAJI;AAKJC,IAAAA,CALI;AAMJkE,IAAAA;AANI,MAOFuF,KAAK,CAACM,IAPV;AAQA,QAAM;AACJ1H,IAAAA,IADI;AACE2H,IAAAA,EADF;AACMjI,IAAAA;AADN,MAEF0H,KAFJ,CAT4C,CAY5C;;AACA,MAAI,CAACE,IAAD,EAAOG,MAAP,EAAeD,KAAf,EAAsBD,GAAtB,EAA2BlG,IAA3B,CAAgCuG,CAAC,IAAIA,CAAC,GAAG,CAAzC,KAA+C,CAAC5H,IAApD,EAA0D;AACxD,WAAO,IAAP;AACD;;AACD,QAAM6H,IAAI,GAAGnI,MAAM,CAAC,CAAD,CAAnB;AACA,QAAM,CAACsF,MAAD,EAASD,KAAT,IAAkBrF,MAAM,CAAC,CAAD,CAAN,CAAUX,KAAV,CAAgB+I,KAAhB,CAAsB,CAAC,CAAvB,CAAxB,CAjB4C,CAkB5C;AACA;AACA;AACA;;AACA,QAAMC,MAAM,GAAG,CACbT,IADa,EAEbtH,IAAI,CAACgF,MAAL,GAAc6C,IAAI,CAACG,QAAnB,GAA8BhD,MAA9B,GAAuCyC,MAF1B,EAGbzH,IAAI,CAAC+E,KAAL,GAAa8C,IAAI,CAACG,QAAlB,GAA6BjD,KAA7B,GAAqCyC,KAHxB,EAIbD,GAJa,CAAf;AAMA,SAAO,IAAIhK,YAAJ,CAAiB6J,KAAjB,EAAwB;AAC7Ba,IAAAA,WAAW,EAAEjI,IADgB;AAE7B;AACA;AACA;AACA;AACA+H,IAAAA,MAN6B;AAO7BJ,IAAAA,EAAE,EAAG,aAAYI,MAAO,IAAGJ,EAAG,EAPD;AAQ7BO,IAAAA,MAAM,EAAE;AAAExK,MAAAA,CAAF;AAAKC,MAAAA,CAAL;AAAQkE,MAAAA;AAAR;AARqB,GAAxB,CAAP;AAUD","sourcesContent":["/* eslint-disable no-plusplus */\nimport shortNumber from 'short-number';\nimport isEqual from 'lodash/isEqual';\nimport {\n  getDefaultInitialViewState,\n  MultiscaleImageLayer,\n  ImageLayer,\n  VolumeLayer,\n} from '@hms-dbmi/viv';\nimport { extent } from 'd3-array';\nimport { Matrix4 } from 'math.gl';\nimport { divide, compare, unit } from 'mathjs';\nimport { pluralize, getSourceFromLoader, isRgb } from '../../utils';\nimport { VIEWER_PALETTE } from '../utils';\nimport {\n  GLOBAL_LABELS,\n  DEFAULT_RASTER_LAYER_PROPS,\n  DEFAULT_LAYER_TYPE_ORDERING,\n} from './constants';\nimport BitmaskLayer from '../../layers/BitmaskLayer';\nimport { getMultiSelectionStats } from '../layer-controller/utils';\n\nexport function square(x, y, r) {\n  return [[x, y + r], [x + r, y], [x, y - r], [x - r, y]];\n}\n\n/**\n * Sort spatial layer definition array,\n * to keep the ordering in the layer controller\n * consistent.\n * Intended to be used with auto-initialized layer\n * definition arrays only, as a pre-defined layer array\n * should not be re-ordered.\n * @param {object[]} layers Array of layer definition objects.\n * Object must have a .type property.\n */\nexport function sortLayers(layers) {\n  return layers.sort((a, b) => (\n    DEFAULT_LAYER_TYPE_ORDERING.indexOf(a.type) - DEFAULT_LAYER_TYPE_ORDERING.indexOf(b.type)\n  ));\n}\n\n/**\n * Return the midpoint of the global dimensions.\n * @param {object} source PixelSource object from Viv\n * @returns {object} The selection.\n */\nfunction getDefaultGlobalSelection(source) {\n  const globalIndices = source.labels\n    .filter(dim => GLOBAL_LABELS.includes(dim));\n  const selection = {};\n  globalIndices.forEach((dim) => {\n    selection[dim] = Math.floor(\n      (source.shape[source.labels.indexOf(dim)] || 0) / 2,\n    );\n  });\n  return selection;\n}\n\n/**\n * Create a default selection using the midpoint of the available global dimensions,\n * and then the first four available selections from the first selectable channel.\n * @param {object} source PixelSource object from Viv\n * @returns {object} The selection.\n */\nfunction buildDefaultSelection(source) {\n  const selection = [];\n  const globalSelection = getDefaultGlobalSelection(source);\n  // First non-global dimension with some sort of selectable values\n  const firstNonGlobalDimension = source.labels.filter(\n    dim => !GLOBAL_LABELS.includes(dim)\n      && source.shape[source.labels.indexOf(dim)],\n  )[0];\n  for (let i = 0; i < Math.min(4, source.shape[\n    source.labels.indexOf(firstNonGlobalDimension)\n  ]); i += 1) {\n    selection.push(\n      {\n        [firstNonGlobalDimension]: i,\n        ...globalSelection,\n      },\n    );\n  }\n  return selection;\n}\n\n/**\n * @param {Array.<number>} shape loader shape\n */\nexport function isInterleaved(shape) {\n  const lastDimSize = shape[shape.length - 1];\n  return lastDimSize === 3 || lastDimSize === 4;\n}\n\n/**\n * Initialize the channel selections for an individual layer.\n * @param {object} loader A viv loader instance with channel names appended by Vitessce loaders\n * of the form { data: (PixelSource[]|PixelSource), metadata: Object, channels }\n * @returns {object[]} An array of selected channels with default\n * domain/slider settings.\n */\nexport async function initializeLayerChannels(loader, use3d) {\n  const result = [];\n  const source = getSourceFromLoader(loader);\n  // Add channel automatically as the first avaialable value for each dimension.\n  let defaultSelection = buildDefaultSelection(source);\n  defaultSelection = isInterleaved(source.shape)\n    ? [{ ...defaultSelection[0], c: 0 }] : defaultSelection;\n  const stats = await getMultiSelectionStats({\n    loader: loader.data, selections: defaultSelection, use3d,\n  });\n\n  const domains = isRgb(loader)\n    ? [[0, 255], [0, 255], [0, 255]]\n    : stats.domains;\n  const colors = isRgb(loader)\n    ? [[255, 0, 0], [0, 255, 0], [0, 0, 255]]\n    : null;\n  const sliders = isRgb(loader)\n    ? [[0, 255], [0, 255], [0, 255]]\n    : stats.sliders;\n\n  defaultSelection.forEach((selection, i) => {\n    const domain = domains[i];\n    const slider = sliders[i];\n    const channel = {\n      selection,\n      // eslint-disable-next-line no-nested-ternary\n      color: colors ? colors[i]\n        : defaultSelection.length !== 1\n          ? VIEWER_PALETTE[i] : [255, 255, 255],\n      visible: true,\n      slider: slider || domain,\n    };\n    result.push(channel);\n  });\n  return result;\n}\n\nfunction getMetaWithTransformMatrices(imageMeta, imageLoaders) {\n  // Do not fill in transformation matrices if any of the layers specify one.\n  const sources = imageLoaders.map(loader => getSourceFromLoader(loader));\n  if (\n    imageMeta.map(meta => meta?.metadata?.transform?.matrix\n      || meta?.metadata?.transform?.scale\n      || meta?.metadata?.transform?.translate).some(Boolean)\n    || sources.every(\n      source => !source.meta?.physicalSizes?.x || !source.meta?.physicalSizes?.y,\n    )\n  ) {\n    return imageMeta;\n  }\n  // Get the minimum physical among all the current images.\n  const minPhysicalSize = sources.reduce((acc, source) => {\n    const hasZPhyscialSize = source.meta?.physicalSizes?.z?.size;\n    const sizes = [\n      unit(`${source.meta?.physicalSizes.x.size} ${source.meta?.physicalSizes.x.unit}`.replace('µ', 'u')),\n      unit(`${source.meta?.physicalSizes.y.size} ${source.meta?.physicalSizes.y.unit}`.replace('µ', 'u')),\n    ];\n    if (hasZPhyscialSize) {\n      sizes.push(unit(`${source.meta?.physicalSizes.z.size} ${source.meta?.physicalSizes.z.unit}`.replace('µ', 'u')));\n    }\n    acc[0] = (acc[0] === undefined || compare(sizes[0], acc[0]) === -1) ? sizes[0] : acc[0];\n    acc[1] = (acc[1] === undefined || compare(sizes[1], acc[1]) === -1) ? sizes[1] : acc[1];\n    acc[2] = (acc[2] === undefined || compare(sizes[2], acc[2]) === -1) ? sizes[2] : acc[2];\n    return acc;\n  }, []);\n  const imageMetaWithTransform = imageMeta.map((meta, j) => {\n    const source = sources[j];\n    const hasZPhyscialSize = source.meta?.physicalSizes?.z?.size;\n    const sizes = [\n      unit(`${source.meta?.physicalSizes.x.size} ${source.meta?.physicalSizes.x.unit}`.replace('µ', 'u')),\n      unit(`${source.meta?.physicalSizes.y.size} ${source.meta?.physicalSizes.y.unit}`.replace('µ', 'u')),\n    ];\n    if (hasZPhyscialSize) {\n      sizes.push(unit(`${source.meta?.physicalSizes.z.size} ${source.meta?.physicalSizes.z.unit}`.replace('µ', 'u')));\n    }\n    // Find the ratio of the sizes to get the scaling factor.\n    const scale = sizes.map((i, k) => divide(i, minPhysicalSize[k]));\n    // Add in z dimension needed for Matrix4 scale API.\n    if (!scale[2]) {\n      scale[2] = 1;\n    }\n    // no need to store/use identity scaling\n    if (isEqual(scale, [1, 1, 1])) {\n      return meta;\n    }\n    // Make sure to scale the z direction by one.\n    const matrix = new Matrix4().scale([...scale]);\n    const newMeta = { ...meta };\n    newMeta.metadata = {\n      ...newMeta.metadata,\n      // We don't want to store matrix objects in the view config.\n      transform: { matrix: matrix.toArray() },\n    };\n    return newMeta;\n  });\n  return imageMetaWithTransform;\n}\n\n/**\n * Given a set of image layer loader creator functions,\n * create loader objects for an initial layer or set of layers,\n * which will be selected based on default values predefined in\n * the image data file or otherwise by a heuristic\n * (the midpoint of the layers array).\n * @param {object[]} rasterLayers A list of layer metadata objects with\n * shape { name, type, url, createLoader }.\n * @param {(string[]|null)} rasterRenderLayers A list of default raster layers. Optional.\n */\nexport async function initializeRasterLayersAndChannels(\n  rasterLayers,\n  rasterRenderLayers,\n  usePhysicalSizeScaling,\n) {\n  const nextImageLoaders = [];\n  let nextImageMetaAndLayers = [];\n  const autoImageLayerDefPromises = [];\n\n  // Start all loader creators immediately.\n  // Reference: https://eslint.org/docs/rules/no-await-in-loop\n  const loaders = await Promise.all(rasterLayers.map(layer => layer.loaderCreator()));\n\n  for (let i = 0; i < rasterLayers.length; i++) {\n    const layer = rasterLayers[i];\n    const loader = loaders[i];\n    nextImageLoaders[i] = loader;\n    nextImageMetaAndLayers[i] = layer;\n  }\n  if (usePhysicalSizeScaling) {\n    nextImageMetaAndLayers = getMetaWithTransformMatrices(nextImageMetaAndLayers, nextImageLoaders);\n  }\n  // No layers were pre-defined so set up the default image layers.\n  if (!rasterRenderLayers) {\n    // Midpoint of images list as default image to show.\n    const layerIndex = Math.floor(rasterLayers.length / 2);\n    const loader = nextImageLoaders[layerIndex];\n    const autoImageLayerDefPromise = initializeLayerChannels(loader)\n      .then(channels => Promise.resolve({\n        type: nextImageMetaAndLayers[layerIndex]?.metadata?.isBitmask ? 'bitmask' : 'raster',\n        index: layerIndex,\n        ...DEFAULT_RASTER_LAYER_PROPS,\n        channels: channels.map((channel, j) => ({\n          ...channel,\n          ...(nextImageMetaAndLayers[layerIndex].channels\n            ? nextImageMetaAndLayers[layerIndex].channels[j] : []),\n        })),\n        modelMatrix: nextImageMetaAndLayers[layerIndex]?.metadata?.transform?.matrix,\n        transparentColor: layerIndex > 0 ? [0, 0, 0] : null,\n      }));\n    autoImageLayerDefPromises.push(autoImageLayerDefPromise);\n  } else {\n    // The renderLayers parameter is a list of layer names to show by default.\n    const globalIndicesOfRenderLayers = rasterRenderLayers\n      .map(imageName => rasterLayers.findIndex(image => image.name === imageName));\n    for (let i = 0; i < globalIndicesOfRenderLayers.length; i++) {\n      const layerIndex = globalIndicesOfRenderLayers[i];\n      const loader = nextImageLoaders[layerIndex];\n      const autoImageLayerDefPromise = initializeLayerChannels(loader)\n        // eslint-disable-next-line no-loop-func\n        .then(channels => Promise.resolve({\n          type: nextImageMetaAndLayers[layerIndex]?.metadata?.isBitmask ? 'bitmask' : 'raster',\n          index: layerIndex,\n          ...DEFAULT_RASTER_LAYER_PROPS,\n          channels: channels.map((channel, j) => ({\n            ...channel,\n            ...(nextImageMetaAndLayers[layerIndex].channels\n              ? nextImageMetaAndLayers[layerIndex].channels[j] : []),\n          })),\n          domainType: 'Min/Max',\n          modelMatrix: nextImageMetaAndLayers[layerIndex]?.metadata?.transform?.matrix,\n          transparentColor: i > 0 ? [0, 0, 0] : null,\n        }));\n      autoImageLayerDefPromises.push(autoImageLayerDefPromise);\n    }\n  }\n\n  const autoImageLayerDefs = await Promise.all(autoImageLayerDefPromises);\n  return [autoImageLayerDefs, nextImageLoaders, nextImageMetaAndLayers];\n}\n\n/**\n * Make a subtitle for the spatial component.\n * @param {object} params\n * @param {number} params.observationsCount\n * @param {string} params.observationsLabel\n * @param {string} params.observationsPluralLabel\n * @param {number} params.subobservationsCount\n * @param {string} params.subobservationsLabel\n * @param {string} params.subobservationsPluralLabel\n * @param {number} params.locationsCount\n * @returns {string} The subtitle string,\n * with info about items with zero counts omitted.\n */\nexport function makeSpatialSubtitle({\n  observationsCount, observationsLabel, observationsPluralLabel,\n  subobservationsCount, subobservationsLabel, subobservationsPluralLabel,\n  locationsCount,\n}) {\n  const parts = [];\n  if (subobservationsCount > 0) {\n    let part = `${subobservationsCount} ${pluralize(subobservationsLabel, subobservationsPluralLabel, subobservationsCount)}`;\n    if (locationsCount > 0) {\n      part += ` at ${shortNumber(locationsCount)} locations`;\n    }\n    parts.push(part);\n  }\n  if (observationsCount > 0) {\n    parts.push(`${observationsCount} ${pluralize(observationsLabel, observationsPluralLabel, observationsCount)}`);\n  }\n  return parts.join(', ');\n}\n\nexport function getInitialSpatialTargets({\n  width,\n  height,\n  cells,\n  imageLayerLoaders,\n  useRaster,\n  use3d,\n}) {\n  let initialTargetX = -Infinity;\n  let initialTargetY = -Infinity;\n  let initialTargetZ = -Infinity;\n  let initialZoom = -Infinity;\n  // Some backoff from completely filling the screen.\n  const zoomBackoff = use3d ? 1.5 : 0.1;\n  const cellValues = Object.values(cells);\n  if (imageLayerLoaders.length > 0 && useRaster) {\n    for (let i = 0; i < imageLayerLoaders.length; i += 1) {\n      const viewSize = { height, width };\n      const { target, zoom: newViewStateZoom } = getDefaultInitialViewState(\n        imageLayerLoaders[i].data,\n        viewSize,\n        zoomBackoff,\n        use3d,\n      );\n      if (target[0] > initialTargetX) {\n        // eslint-disable-next-line prefer-destructuring\n        initialTargetX = target[0];\n        initialZoom = newViewStateZoom;\n      }\n      if (target[1] > initialTargetY) {\n        // eslint-disable-next-line prefer-destructuring\n        initialTargetY = target[1];\n        initialZoom = newViewStateZoom;\n      }\n      if (target[2] > initialTargetZ) {\n        // eslint-disable-next-line prefer-destructuring\n        initialTargetZ = target[2];\n        initialZoom = newViewStateZoom;\n      } else {\n        initialTargetZ = null;\n      }\n    }\n  } else if (cellValues.length > 0\n    // Only use cellValues in quadtree calculation if there is\n    // centroid data in the cells (i.e not just ids).\n    && cellValues[0].xy\n    && !useRaster) {\n    const cellCoordinates = cellValues.map(c => c.xy);\n    let xExtent = extent(cellCoordinates, c => c[0]);\n    let yExtent = extent(cellCoordinates, c => c[1]);\n    let xRange = xExtent[1] - xExtent[0];\n    let yRange = yExtent[1] - yExtent[0];\n    const getViewExtentFromPolygonExtents = extents => [\n      Math.min(...extents.map(i => i[0])),\n      Math.max(...extents.map(i => i[1])),\n    ];\n    if (xRange === 0) {\n      // The fall back is the cells' polygon coordinates, if the original range\n      // is 0 i.e the centroids are all on the same axis.\n      const polygonExtentsX = cellValues.map(cell => extent(cell.poly, i => i[0]));\n      xExtent = getViewExtentFromPolygonExtents(polygonExtentsX);\n      xRange = xExtent[1] - xExtent[0];\n    }\n    if (yRange === 0) {\n      // The fall back is the first cells' polygon coordinates, if the original range\n      // is 0 i.e the centroids are all on the same axis.\n      const polygonExtentsY = cellValues.map(cell => extent(cell.poly, i => i[1]));\n      yExtent = getViewExtentFromPolygonExtents(polygonExtentsY);\n      yRange = yExtent[1] - yExtent[0];\n    }\n    initialTargetX = xExtent[0] + xRange / 2;\n    initialTargetY = yExtent[0] + yRange / 2;\n    initialTargetZ = null;\n    initialZoom = Math.log2(Math.min(width / xRange, height / yRange)) - zoomBackoff;\n  } else {\n    return {\n      initialTargetX: null, initialTargetY: null, initialTargetZ: null, initialZoom: null,\n    };\n  }\n  return {\n    initialTargetX, initialTargetY, initialZoom, initialTargetZ,\n  };\n}\n\n/**\n * Make a subtitle for the spatial component.\n * @param {object} data PixelSource | PixelSource[]\n * @returns {Array} [Layer, PixelSource | PixelSource[]] tuple.\n */\nexport function getLayerLoaderTuple(data, use3d) {\n  const loader = ((Array.isArray(data) && data.length > 1) || !Array.isArray(data))\n    ? data : data[0];\n  if (use3d) {\n    return [VolumeLayer, Array.isArray(loader) ? loader : [loader]];\n  }\n  const Layer = (Array.isArray(data) && data.length > 1) ? MultiscaleImageLayer : ImageLayer;\n  return [Layer, loader];\n}\n\n\nexport function renderSubBitmaskLayers(props) {\n  const {\n    bbox: {\n      left, top, right, bottom,\n    },\n    x,\n    y,\n    z,\n  } = props.tile;\n  const {\n    data, id, loader,\n  } = props;\n  // Only render in positive coorinate system\n  if ([left, bottom, right, top].some(v => v < 0) || !data) {\n    return null;\n  }\n  const base = loader[0];\n  const [height, width] = loader[0].shape.slice(-2);\n  // Tiles are exactly fitted to have height and width such that their bounds\n  // match that of the actual image (not some padded version).\n  // Thus the right/bottom given by deck.gl are incorrect since\n  // they assume tiles are of uniform sizes, which is not the case for us.\n  const bounds = [\n    left,\n    data.height < base.tileSize ? height : bottom,\n    data.width < base.tileSize ? width : right,\n    top,\n  ];\n  return new BitmaskLayer(props, {\n    channelData: data,\n    // Uncomment to help debugging - shades the tile being hovered over.\n    // autoHighlight: true,\n    // highlightColor: [80, 80, 80, 50],\n    // Shared props with BitmapLayer:\n    bounds,\n    id: `sub-layer-${bounds}-${id}`,\n    tileId: { x, y, z },\n  });\n}\n"]},"metadata":{},"sourceType":"module"}