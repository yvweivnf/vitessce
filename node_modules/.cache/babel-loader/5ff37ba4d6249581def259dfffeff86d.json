{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash as _hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\n\nexport var FacetNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(FacetNode, _DataFlowNode);\n\n  var _super = _createSuper(FacetNode);\n\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  function FacetNode(parent, model, name, data) {\n    var _this;\n\n    _classCallCheck(this, FacetNode);\n\n    _this = _super.call(this, parent);\n    _this.model = model;\n    _this.name = name;\n    _this.data = data;\n\n    var _iterator = _createForOfIteratorHelper(FACET_CHANNELS),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var channel = _step.value;\n        var fieldDef = model.facet[channel];\n\n        if (fieldDef) {\n          var bin = fieldDef.bin,\n              sort = fieldDef.sort;\n          _this[channel] = Object.assign({\n            name: model.getName(\"\".concat(channel, \"_domain\")),\n            fields: [vgField(fieldDef)].concat(_toConsumableArray(isBinning(bin) ? [vgField(fieldDef, {\n              binSuffix: 'end'\n            })] : []))\n          }, isSortField(sort) ? {\n            sortField: sort\n          } : isArray(sort) ? {\n            sortIndexField: sortArrayIndexField(fieldDef, channel)\n          } : {});\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    _this.childModel = model.child;\n    return _this;\n  }\n\n  _createClass(FacetNode, [{\n    key: \"hash\",\n    value: function hash() {\n      var out = \"Facet\";\n\n      var _iterator2 = _createForOfIteratorHelper(FACET_CHANNELS),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var channel = _step2.value;\n\n          if (this[channel]) {\n            out += \" \".concat(channel.charAt(0), \":\").concat(_hash(this[channel]));\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return out;\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var depFields = new Set(this.fields);\n\n      var _iterator3 = _createForOfIteratorHelper(FACET_CHANNELS),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var channel = _step3.value;\n\n          if (this[channel]) {\n            if (this[channel].sortField) {\n              depFields.add(this[channel].sortField.field);\n            }\n\n            if (this[channel].sortIndexField) {\n              depFields.add(this[channel].sortIndexField);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return depFields;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(); // facet does not produce any new fields\n    }\n    /**\n     * The name to reference this source is its name.\n     */\n\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.name;\n    }\n  }, {\n    key: \"getChildIndependentFieldsWithStep\",\n    value: function getChildIndependentFieldsWithStep() {\n      var childIndependentFieldsWithStep = {};\n\n      var _iterator4 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var channel = _step4.value;\n          var childScaleComponent = this.childModel.component.scales[channel];\n\n          if (childScaleComponent && !childScaleComponent.merged) {\n            // independent scale\n            var type = childScaleComponent.get('type');\n            var range = childScaleComponent.get('range');\n\n            if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n              var domain = assembleDomain(this.childModel, channel);\n              var field = getFieldFromDomain(domain);\n\n              if (field) {\n                childIndependentFieldsWithStep[channel] = field;\n              } else {\n                log.warn(log.message.unknownField(channel));\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return childIndependentFieldsWithStep;\n    }\n  }, {\n    key: \"assembleRowColumnHeaderData\",\n    value: function assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n      var childChannel = {\n        row: 'y',\n        column: 'x',\n        facet: undefined\n      }[channel];\n      var fields = [];\n      var ops = [];\n      var as = [];\n\n      if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n        if (crossedDataName) {\n          // If there is a crossed data, calculate max\n          fields.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n          ops.push('max');\n        } else {\n          // If there is no crossed data, just calculate distinct\n          fields.push(childIndependentFieldsWithStep[childChannel]);\n          ops.push('distinct');\n        } // Although it is technically a max, just name it distinct so it's easier to refer to it\n\n\n        as.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n      }\n\n      var _this$channel = this[channel],\n          sortField = _this$channel.sortField,\n          sortIndexField = _this$channel.sortIndexField;\n\n      if (sortField) {\n        var _sortField$op = sortField.op,\n            op = _sortField$op === void 0 ? DEFAULT_SORT_OP : _sortField$op,\n            field = sortField.field;\n        fields.push(field);\n        ops.push(op);\n        as.push(vgField(sortField, {\n          forAs: true\n        }));\n      } else if (sortIndexField) {\n        fields.push(sortIndexField);\n        ops.push('max');\n        as.push(sortIndexField);\n      }\n\n      return {\n        name: this[channel].name,\n        // Use data from the crossed one if it exist\n        source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n        transform: [Object.assign({\n          type: 'aggregate',\n          groupby: this[channel].fields\n        }, fields.length ? {\n          fields: fields,\n          ops: ops,\n          as: as\n        } : {})]\n      };\n    }\n  }, {\n    key: \"assembleFacetHeaderData\",\n    value: function assembleFacetHeaderData(childIndependentFieldsWithStep) {\n      var _a, _b;\n\n      var columns = this.model.layout.columns;\n      var layoutHeaders = this.model.component.layoutHeaders;\n      var data = [];\n      var hasSharedAxis = {};\n\n      var _iterator5 = _createForOfIteratorHelper(HEADER_CHANNELS),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var headerChannel = _step5.value;\n\n          var _iterator6 = _createForOfIteratorHelper(HEADER_TYPES),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var headerType = _step6.value;\n              var headers = (_a = layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) !== null && _a !== void 0 ? _a : [];\n\n              var _iterator7 = _createForOfIteratorHelper(headers),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var header = _step7.value;\n\n                  if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                    hasSharedAxis[headerChannel] = true;\n                    break;\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          if (hasSharedAxis[headerChannel]) {\n            var cardinality = \"length(data(\\\"\".concat(this.facet.name, \"\\\"))\");\n            var stop = headerChannel === 'row' ? columns ? {\n              signal: \"ceil(\".concat(cardinality, \" / \").concat(columns, \")\")\n            } : 1 : columns ? {\n              signal: \"min(\".concat(cardinality, \", \").concat(columns, \")\")\n            } : {\n              signal: cardinality\n            };\n            data.push({\n              name: \"\".concat(this.facet.name, \"_\").concat(headerChannel),\n              transform: [{\n                type: 'sequence',\n                start: 0,\n                stop: stop\n              }]\n            });\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var row = hasSharedAxis.row,\n          column = hasSharedAxis.column;\n\n      if (row || column) {\n        data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n      }\n\n      return data;\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _a, _b;\n\n      var data = [];\n      var crossedDataName = null;\n      var childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n      var column = this.column,\n          row = this.row,\n          facet = this.facet;\n\n      if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n        // Need to create a cross dataset to correctly calculate cardinality\n        crossedDataName = \"cross_\".concat(this.column.name, \"_\").concat(this.row.name);\n        var fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);\n        var ops = fields.map(function () {\n          return 'distinct';\n        });\n        data.push({\n          name: crossedDataName,\n          source: this.data,\n          transform: [{\n            type: 'aggregate',\n            groupby: this.fields,\n            fields: fields,\n            ops: ops\n          }]\n        });\n      }\n\n      for (var _i = 0, _arr = [COLUMN, ROW]; _i < _arr.length; _i++) {\n        var channel = _arr[_i];\n\n        if (this[channel]) {\n          data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n        }\n      }\n\n      if (facet) {\n        var facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n\n        if (facetData) {\n          data.push.apply(data, _toConsumableArray(facetData));\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"fields\",\n    get: function get() {\n      var _a;\n\n      var f = [];\n\n      var _iterator8 = _createForOfIteratorHelper(FACET_CHANNELS),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var channel = _step8.value;\n\n          if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n            f.push.apply(f, _toConsumableArray(this[channel].fields));\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return f;\n    }\n  }]);\n\n  return FacetNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/facet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n    /**\n     * @param model The facet model.\n     * @param name The name that this facet source will have.\n     * @param data The source data for this facet data.\n     */\n    constructor(parent, model, name, data) {\n        super(parent);\n        this.model = model;\n        this.name = name;\n        this.data = data;\n        for (const channel of FACET_CHANNELS) {\n            const fieldDef = model.facet[channel];\n            if (fieldDef) {\n                const { bin, sort } = fieldDef;\n                this[channel] = Object.assign({ name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, { binSuffix: 'end' })] : [])] }, (isSortField(sort)\n                    ? { sortField: sort }\n                    : isArray(sort)\n                        ? { sortIndexField: sortArrayIndexField(fieldDef, channel) }\n                        : {}));\n            }\n        }\n        this.childModel = model.child;\n    }\n    hash() {\n        let out = `Facet`;\n        for (const channel of FACET_CHANNELS) {\n            if (this[channel]) {\n                out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n            }\n        }\n        return out;\n    }\n    get fields() {\n        var _a;\n        const f = [];\n        for (const channel of FACET_CHANNELS) {\n            if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n                f.push(...this[channel].fields);\n            }\n        }\n        return f;\n    }\n    dependentFields() {\n        const depFields = new Set(this.fields);\n        for (const channel of FACET_CHANNELS) {\n            if (this[channel]) {\n                if (this[channel].sortField) {\n                    depFields.add(this[channel].sortField.field);\n                }\n                if (this[channel].sortIndexField) {\n                    depFields.add(this[channel].sortIndexField);\n                }\n            }\n        }\n        return depFields;\n    }\n    producedFields() {\n        return new Set(); // facet does not produce any new fields\n    }\n    /**\n     * The name to reference this source is its name.\n     */\n    getSource() {\n        return this.name;\n    }\n    getChildIndependentFieldsWithStep() {\n        const childIndependentFieldsWithStep = {};\n        for (const channel of POSITION_SCALE_CHANNELS) {\n            const childScaleComponent = this.childModel.component.scales[channel];\n            if (childScaleComponent && !childScaleComponent.merged) {\n                // independent scale\n                const type = childScaleComponent.get('type');\n                const range = childScaleComponent.get('range');\n                if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                    const domain = assembleDomain(this.childModel, channel);\n                    const field = getFieldFromDomain(domain);\n                    if (field) {\n                        childIndependentFieldsWithStep[channel] = field;\n                    }\n                    else {\n                        log.warn(log.message.unknownField(channel));\n                    }\n                }\n            }\n        }\n        return childIndependentFieldsWithStep;\n    }\n    assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n        const childChannel = { row: 'y', column: 'x', facet: undefined }[channel];\n        const fields = [];\n        const ops = [];\n        const as = [];\n        if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n            if (crossedDataName) {\n                // If there is a crossed data, calculate max\n                fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n                ops.push('max');\n            }\n            else {\n                // If there is no crossed data, just calculate distinct\n                fields.push(childIndependentFieldsWithStep[childChannel]);\n                ops.push('distinct');\n            }\n            // Although it is technically a max, just name it distinct so it's easier to refer to it\n            as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n        }\n        const { sortField, sortIndexField } = this[channel];\n        if (sortField) {\n            const { op = DEFAULT_SORT_OP, field } = sortField;\n            fields.push(field);\n            ops.push(op);\n            as.push(vgField(sortField, { forAs: true }));\n        }\n        else if (sortIndexField) {\n            fields.push(sortIndexField);\n            ops.push('max');\n            as.push(sortIndexField);\n        }\n        return {\n            name: this[channel].name,\n            // Use data from the crossed one if it exist\n            source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n            transform: [\n                Object.assign({ type: 'aggregate', groupby: this[channel].fields }, (fields.length\n                    ? {\n                        fields,\n                        ops,\n                        as\n                    }\n                    : {}))\n            ]\n        };\n    }\n    assembleFacetHeaderData(childIndependentFieldsWithStep) {\n        var _a, _b;\n        const { columns } = this.model.layout;\n        const { layoutHeaders } = this.model.component;\n        const data = [];\n        const hasSharedAxis = {};\n        for (const headerChannel of HEADER_CHANNELS) {\n            for (const headerType of HEADER_TYPES) {\n                const headers = (_a = (layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType])) !== null && _a !== void 0 ? _a : [];\n                for (const header of headers) {\n                    if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                        hasSharedAxis[headerChannel] = true;\n                        break;\n                    }\n                }\n            }\n            if (hasSharedAxis[headerChannel]) {\n                const cardinality = `length(data(\"${this.facet.name}\"))`;\n                const stop = headerChannel === 'row'\n                    ? columns\n                        ? { signal: `ceil(${cardinality} / ${columns})` }\n                        : 1\n                    : columns\n                        ? { signal: `min(${cardinality}, ${columns})` }\n                        : { signal: cardinality };\n                data.push({\n                    name: `${this.facet.name}_${headerChannel}`,\n                    transform: [\n                        {\n                            type: 'sequence',\n                            start: 0,\n                            stop\n                        }\n                    ]\n                });\n            }\n        }\n        const { row, column } = hasSharedAxis;\n        if (row || column) {\n            data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n        }\n        return data;\n    }\n    assemble() {\n        var _a, _b;\n        const data = [];\n        let crossedDataName = null;\n        const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n        const { column, row, facet } = this;\n        if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n            // Need to create a cross dataset to correctly calculate cardinality\n            crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n            const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);\n            const ops = fields.map(() => 'distinct');\n            data.push({\n                name: crossedDataName,\n                source: this.data,\n                transform: [\n                    {\n                        type: 'aggregate',\n                        groupby: this.fields,\n                        fields,\n                        ops\n                    }\n                ]\n            });\n        }\n        for (const channel of [COLUMN, ROW]) {\n            if (this[channel]) {\n                data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n            }\n        }\n        if (facet) {\n            const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n            if (facetData) {\n                data.push(...facetData);\n            }\n        }\n        return data;\n    }\n}\n//# sourceMappingURL=facet.js.map"]},"metadata":{},"sourceType":"module"}