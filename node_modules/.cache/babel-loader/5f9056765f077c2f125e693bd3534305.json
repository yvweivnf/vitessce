{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _core = require(\"@deck.gl/core\");\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _meshLayers = require(\"@deck.gl/mesh-layers\");\n\nvar _pathOutlineLayer = _interopRequireDefault(require(\"../path-outline-layer/path-outline-layer\"));\n\nvar _arrow2dGeometry = _interopRequireDefault(require(\"./arrow-2d-geometry\"));\n\nvar _createPathMarkers = _interopRequireDefault(require(\"./create-path-markers\"));\n\nvar _polyline = require(\"./polyline\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DISTANCE_FOR_MULTI_ARROWS = 0.1;\nvar ARROW_HEAD_SIZE = 0.2;\nvar ARROW_TAIL_WIDTH = 0.05; // const ARROW_CENTER_ADJUST = -0.8;\n\nvar DEFAULT_MARKER_LAYER = _meshLayers.SimpleMeshLayer;\nvar DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new _arrow2dGeometry[\"default\"]({\n    headSize: ARROW_HEAD_SIZE,\n    tailWidth: ARROW_TAIL_WIDTH\n  })\n};\nvar defaultProps = Object.assign({}, _pathOutlineLayer[\"default\"].defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n  sizeScale: 100,\n  fp64: false,\n  hightlightIndex: -1,\n  highlightPoint: null,\n  getPath: function getPath(x) {\n    return x.path;\n  },\n  getColor: function getColor(x) {\n    return x.color;\n  },\n  getMarkerColor: function getMarkerColor(x) {\n    return [0, 0, 0, 255];\n  },\n  getDirection: function getDirection(x) {\n    return x.direction;\n  },\n  getMarkerPercentages: function getMarkerPercentages(object, _ref) {\n    var lineLength = _ref.lineLength;\n    return lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5];\n  }\n});\n\nvar PathMarkerLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(PathMarkerLayer, _CompositeLayer);\n\n  var _super = _createSuper(PathMarkerLayer);\n\n  function PathMarkerLayer() {\n    _classCallCheck(this, PathMarkerLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PathMarkerLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        markers: [],\n        mesh: new _arrow2dGeometry[\"default\"]({\n          headSize: ARROW_HEAD_SIZE,\n          tailWidth: ARROW_TAIL_WIDTH\n        }),\n        closestPoint: null\n      };\n    } // @ts-ignore\n\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n      if (coordinateSystem === _core.COORDINATE_SYSTEM.METER_OFFSETS) {\n        var _viewport$metersToLng = viewport.metersToLngLatDelta(xyz),\n            _viewport$metersToLng2 = _slicedToArray(_viewport$metersToLng, 2),\n            dx = _viewport$metersToLng2[0],\n            dy = _viewport$metersToLng2[1];\n\n        var _coordinateOrigin = _slicedToArray(coordinateOrigin, 2),\n            x = _coordinateOrigin[0],\n            y = _coordinateOrigin[1];\n\n        return viewport.projectFlat([x + dx, dy + y]);\n      } else if (coordinateSystem === _core.COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n        var _xyz = _slicedToArray(xyz, 2),\n            _dx = _xyz[0],\n            _dy = _xyz[1];\n\n        var _coordinateOrigin2 = _slicedToArray(coordinateOrigin, 2),\n            _x = _coordinateOrigin2[0],\n            _y = _coordinateOrigin2[1];\n\n        return viewport.projectFlat([_x + _dx, _dy + _y]);\n      }\n\n      return viewport.projectFlat(xyz);\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var _this = this;\n\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n        var _this$props = this.props,\n            data = _this$props.data,\n            getPath = _this$props.getPath,\n            getDirection = _this$props.getDirection,\n            getMarkerColor = _this$props.getMarkerColor,\n            getMarkerPercentages = _this$props.getMarkerPercentages,\n            coordinateSystem = _this$props.coordinateSystem,\n            coordinateOrigin = _this$props.coordinateOrigin; // @ts-ignore\n\n        var viewport = this.context.viewport;\n\n        var projectFlat = function projectFlat(o) {\n          return _this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n        };\n\n        this.state.markers = (0, _createPathMarkers[\"default\"])({\n          data: data,\n          getPath: getPath,\n          getDirection: getDirection,\n          getColor: getMarkerColor,\n          getMarkerPercentages: getMarkerPercentages,\n          projectFlat: projectFlat\n        });\n\n        this._recalculateClosestPoint();\n      }\n\n      if (changeFlags.propsChanged) {\n        if (props.point !== oldProps.point) {\n          this._recalculateClosestPoint();\n        }\n      }\n    }\n  }, {\n    key: \"_recalculateClosestPoint\",\n    value: function _recalculateClosestPoint() {\n      var _this$props2 = this.props,\n          highlightPoint = _this$props2.highlightPoint,\n          highlightIndex = _this$props2.highlightIndex;\n\n      if (highlightPoint && highlightIndex >= 0) {\n        var object = this.props.data[highlightIndex];\n        var points = this.props.getPath(object);\n\n        var _getClosestPointOnPol = (0, _polyline.getClosestPointOnPolyline)({\n          points: points,\n          p: highlightPoint\n        }),\n            point = _getClosestPointOnPol.point;\n\n        this.state.closestPoints = [{\n          position: point\n        }];\n      } else {\n        this.state.closestPoints = [];\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      return Object.assign(info, {\n        // override object with picked feature\n        object: info.object && info.object.path || info.object\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return [new _pathOutlineLayer[\"default\"](this.props, // @ts-ignore\n      this.getSubLayerProps({\n        id: 'paths',\n        // Note: data has to be passed explicitly like this to avoid being empty\n        data: this.props.data\n      })), new this.props.MarkerLayer(this.getSubLayerProps(Object.assign({}, this.props.markerLayerProps, {\n        id: 'markers',\n        data: this.state.markers,\n        getOrientation: function getOrientation(x) {\n          return [0, -x.angle, 0];\n        },\n        getColor: function getColor(x) {\n          return x.color;\n        },\n        sizeScale: this.props.sizeScale,\n        fp64: this.props.fp64,\n        pickable: false,\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      }))), this.state.closestPoints && new _layers.ScatterplotLayer({\n        id: \"\".concat(this.props.id, \"-highlight\"),\n        data: this.state.closestPoints,\n        // @ts-ignore\n        fp64: this.props.fp64\n      })];\n    }\n  }]);\n\n  return PathMarkerLayer;\n}(_core.CompositeLayer);\n\nexports[\"default\"] = PathMarkerLayer;\n\n_defineProperty(PathMarkerLayer, \"layerName\", 'PathMarkerLayer');\n\n_defineProperty(PathMarkerLayer, \"defaultProps\", defaultProps);","map":{"version":3,"sources":["../../../src/layers/path-marker-layer/path-marker-layer.ts"],"names":["DISTANCE_FOR_MULTI_ARROWS","ARROW_HEAD_SIZE","ARROW_TAIL_WIDTH","DEFAULT_MARKER_LAYER","SimpleMeshLayer","DEFAULT_MARKER_LAYER_PROPS","mesh","Arrow2DGeometry","headSize","tailWidth","defaultProps","PathOutlineLayer","MarkerLayer","markerLayerProps","sizeScale","fp64","hightlightIndex","highlightPoint","getPath","x","getColor","getMarkerColor","getDirection","getMarkerPercentages","lineLength","PathMarkerLayer","CompositeLayer","markers","closestPoint","xyz","viewport","coordinateSystem","coordinateOrigin","COORDINATE_SYSTEM","dx","dy","y","props","oldProps","changeFlags","data","projectFlat","highlightIndex","object","points","point","p","position","info","id","getOrientation","pickable","parameters","blend","depthTest","ScatterplotLayer"],"mappings":";;;;;;;AAAA,IAAA,KAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,0CAAA,CAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,qBAAA,CAAA,CAAA;;AAEA,IAAA,kBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,uBAAA,CAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,yBAAyB,GAA/B,GAAA;AACA,IAAMC,eAAe,GAArB,GAAA;AACA,IAAMC,gBAAgB,GAAtB,IAAA,C,CACA;;AAEA,IAAMC,oBAAoB,GAAGC,WAAAA,CAA7B,eAAA;AAEA,IAAMC,0BAA0B,GAAG;AACjCC,EAAAA,IAAI,EAAE,IAAIC,gBAAAA,CAAJ,SAAIA,CAAJ,CAAoB;AAAEC,IAAAA,QAAQ,EAAV,eAAA;AAA6BC,IAAAA,SAAS,EAAEP;AAAxC,GAApB;AAD2B,CAAnC;AAIA,IAAMQ,YAAY,GAAG,MAAM,CAAN,MAAA,CAAA,EAAA,EAAkBC,iBAAAA,CAAAA,SAAAA,CAAAA,CAAlB,YAAA,EAAiD;AACpEC,EAAAA,WAAW,EADyD,oBAAA;AAEpEC,EAAAA,gBAAgB,EAFoD,0BAAA;AAIpEC,EAAAA,SAAS,EAJ2D,GAAA;AAKpEC,EAAAA,IAAI,EALgE,KAAA;AAOpEC,EAAAA,eAAe,EAAE,CAPmD,CAAA;AAQpEC,EAAAA,cAAc,EARsD,IAAA;AAUpEC,EAAAA,OAAO,EAAE,SAAA,OAAA,CAAA,CAAA,EAAA;AAAA,WAAOC,CAAC,CAAR,IAAA;AAV2D,GAAA;AAWpEC,EAAAA,QAAQ,EAAE,SAAA,QAAA,CAAA,CAAA,EAAA;AAAA,WAAOD,CAAC,CAAR,KAAA;AAX0D,GAAA;AAYpEE,EAAAA,cAAc,EAAE,SAAA,cAAA,CAAA,CAAA,EAAA;AAAA,WAAO,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAP,GAAO,CAAP;AAZoD,GAAA;AAapEC,EAAAA,YAAY,EAAE,SAAA,YAAA,CAAA,CAAA,EAAA;AAAA,WAAOH,CAAC,CAAR,SAAA;AAbsD,GAAA;AAcpEI,EAAAA,oBAAoB,EAAE,SAAA,oBAAA,CAAA,MAAA,EAAA,IAAA,EAAA;AAAA,QAAWC,UAAX,GAAA,IAAA,CAAA,UAAA;AAAA,WACpBA,UAAU,GAAVA,yBAAAA,GAAyC,CAAA,IAAA,EAAA,GAAA,EAAzCA,IAAyC,CAAzCA,GAA6D,CADzC,GACyC,CADzC;AAAA;AAd8C,CAAjD,CAArB;;IAkBqBC,e;;;;;;;;;;;;;sCAID;AAChB,WAAA,KAAA,GAAa;AACXE,QAAAA,OAAO,EADI,EAAA;AAEXrB,QAAAA,IAAI,EAAE,IAAIC,gBAAAA,CAAJ,SAAIA,CAAJ,CAAoB;AAAEC,UAAAA,QAAQ,EAAV,eAAA;AAA6BC,UAAAA,SAAS,EAAEP;AAAxC,SAApB,CAFK;AAGX0B,QAAAA,YAAY,EAAE;AAHH,OAAb;MAMF;;;;gCACYC,G,EAAKC,Q,EAAUC,gB,EAAkBC,gB,EAAkB;AAC7D,UAAID,gBAAgB,KAAKE,KAAAA,CAAAA,iBAAAA,CAAzB,aAAA,EAA0D;AAAA,YAAA,qBAAA,GACvCH,QAAQ,CAARA,mBAAAA,CADuC,GACvCA,CADuC;AAAA,YAAA,sBAAA,GAAA,cAAA,CAAA,qBAAA,EAAA,CAAA,CAAA;AAAA,YACjDI,EADiD,GAAA,sBAAA,CAAA,CAAA,CAAA;AAAA,YAC7CC,EAD6C,GAAA,sBAAA,CAAA,CAAA,CAAA;;AAAA,YAAA,iBAAA,GAAA,cAAA,CAAA,gBAAA,EAAA,CAAA,CAAA;AAAA,YAEjDhB,CAFiD,GAAA,iBAAA,CAAA,CAAA,CAAA;AAAA,YAE9CiB,CAF8C,GAAA,iBAAA,CAAA,CAAA,CAAA;;AAGxD,eAAON,QAAQ,CAARA,WAAAA,CAAqB,CAACX,CAAC,GAAF,EAAA,EAASgB,EAAE,GAAvC,CAA4B,CAArBL,CAAP;AAHF,OAAA,MAIO,IAAIC,gBAAgB,KAAKE,KAAAA,CAAAA,iBAAAA,CAAzB,cAAA,EAA2D;AAAA,YAAA,IAAA,GAAA,cAAA,CAAA,GAAA,EAAA,CAAA,CAAA;AAAA,YACzDC,GADyD,GAAA,IAAA,CAAA,CAAA,CAAA;AAAA,YACrDC,GADqD,GAAA,IAAA,CAAA,CAAA,CAAA;;AAAA,YAAA,kBAAA,GAAA,cAAA,CAAA,gBAAA,EAAA,CAAA,CAAA;AAAA,YAEzDhB,EAFyD,GAAA,kBAAA,CAAA,CAAA,CAAA;AAAA,YAEtDiB,EAFsD,GAAA,kBAAA,CAAA,CAAA,CAAA;;AAGhE,eAAON,QAAQ,CAARA,WAAAA,CAAqB,CAACX,EAAC,GAAF,GAAA,EAASgB,GAAE,GAAvC,EAA4B,CAArBL,CAAP;AACD;;AAED,aAAOA,QAAQ,CAARA,WAAAA,CAAP,GAAOA,CAAP;AACD;;;uCAE6C;AAAA,UAAA,KAAA,GAAA,IAAA;;AAAA,UAAhCO,KAAgC,GAAA,KAAA,CAAhCA,KAAgC;AAAA,UAAzBC,QAAyB,GAAA,KAAA,CAAzBA,QAAyB;AAAA,UAAfC,WAAe,GAAA,KAAA,CAAfA,WAAe;;AAC5C,UAAIA,WAAW,CAAXA,WAAAA,IAA2BA,WAAW,CAA1C,qBAAA,EAAkE;AAAA,YAAA,WAAA,GAS5D,KAT4D,KAAA;AAAA,YAE9DC,IAF8D,GAAA,WAAA,CAAA,IAAA;AAAA,YAG9DtB,OAH8D,GAAA,WAAA,CAAA,OAAA;AAAA,YAI9DI,YAJ8D,GAAA,WAAA,CAAA,YAAA;AAAA,YAK9DD,cAL8D,GAAA,WAAA,CAAA,cAAA;AAAA,YAM9DE,oBAN8D,GAAA,WAAA,CAAA,oBAAA;AAAA,YAO9DQ,gBAP8D,GAAA,WAAA,CAAA,gBAAA;AAAA,YAQ9DC,gBAR8D,GAAA,WAAA,CAAA,gBAAA,CAAA,CAUhE;;AAVgE,YAWxDF,QAXwD,GAW3C,KAX2C,OAW3C,CAX2C,QAAA;;AAYhE,YAAMW,WAAW,GAAG,SAAdA,WAAc,CAAA,CAAA,EAAA;AAAA,iBAAO,KAAI,CAAJ,WAAA,CAAA,CAAA,EAAA,QAAA,EAAA,gBAAA,EAAP,gBAAO,CAAP;AAApB,SAAA;;AACA,aAAA,KAAA,CAAA,OAAA,GAAqB,CAAA,GAAA,kBAAA,CAAA,SAAA,CAAA,EAAkB;AACrCD,UAAAA,IAAI,EADiC,IAAA;AAErCtB,UAAAA,OAAO,EAF8B,OAAA;AAGrCI,UAAAA,YAAY,EAHyB,YAAA;AAIrCF,UAAAA,QAAQ,EAJ6B,cAAA;AAKrCG,UAAAA,oBAAoB,EALiB,oBAAA;AAMrCkB,UAAAA,WAAW,EAAXA;AANqC,SAAlB,CAArB;;AAQA,aAAA,wBAAA;AACD;;AACD,UAAIF,WAAW,CAAf,YAAA,EAA8B;AAC5B,YAAIF,KAAK,CAALA,KAAAA,KAAgBC,QAAQ,CAA5B,KAAA,EAAoC;AAClC,eAAA,wBAAA;AACD;AACF;AACF;;;+CAE0B;AAAA,UAAA,YAAA,GACkB,KADlB,KAAA;AAAA,UACjBrB,cADiB,GAAA,YAAA,CAAA,cAAA;AAAA,UACDyB,cADC,GAAA,YAAA,CAAA,cAAA;;AAEzB,UAAIzB,cAAc,IAAIyB,cAAc,IAApC,CAAA,EAA2C;AACzC,YAAMC,MAAM,GAAG,KAAA,KAAA,CAAA,IAAA,CAAf,cAAe,CAAf;AACA,YAAMC,MAAM,GAAG,KAAA,KAAA,CAAA,OAAA,CAAf,MAAe,CAAf;;AAFyC,YAAA,qBAAA,GAGvB,CAAA,GAAA,SAAA,CAAA,yBAAA,EAA0B;AAAEA,UAAAA,MAAM,EAAR,MAAA;AAAUE,UAAAA,CAAC,EAAE7B;AAAb,SAA1B,CAHuB;AAAA,YAGjC4B,KAHiC,GAAA,qBAAA,CAAA,KAAA;;AAIzC,aAAA,KAAA,CAAA,aAAA,GAA2B,CACzB;AACEE,UAAAA,QAAQ,EAAEF;AADZ,SADyB,CAA3B;AAJF,OAAA,MASO;AACL,aAAA,KAAA,CAAA,aAAA,GAAA,EAAA;AACD;AACF;;;0CAEwB;AAAA,UAARG,IAAQ,GAAA,KAAA,CAARA,IAAQ;AACvB,aAAO,MAAM,CAAN,MAAA,CAAA,IAAA,EAAoB;AACzB;AACAL,QAAAA,MAAM,EAAGK,IAAI,CAAJA,MAAAA,IAAeA,IAAI,CAAJA,MAAAA,CAAhB,IAACA,IAAoCA,IAAI,CAACL;AAFzB,OAApB,CAAP;AAID;;;mCAEc;AACb,aAAO,CACL,IAAIhC,iBAAAA,CAAJ,SAAIA,CAAJ,CACE,KADF,KAAA,EAEE;AACA,WAAA,gBAAA,CAAsB;AACpBsC,QAAAA,EAAE,EADkB,OAAA;AAEpB;AACAT,QAAAA,IAAI,EAAE,KAAA,KAAA,CAAWA;AAHG,OAAtB,CAHF,CADK,EAUL,IAAI,KAAA,KAAA,CAAJ,WAAA,CACE,KAAA,gBAAA,CACE,MAAM,CAAN,MAAA,CAAA,EAAA,EAAkB,KAAA,KAAA,CAAlB,gBAAA,EAA+C;AAC7CS,QAAAA,EAAE,EAD2C,SAAA;AAE7CT,QAAAA,IAAI,EAAE,KAAA,KAAA,CAFuC,OAAA;AAG7CU,QAAAA,cAAc,EAAE,SAAA,cAAA,CAAA,CAAA,EAAA;AAAA,iBAAO,CAAA,CAAA,EAAI,CAAC/B,CAAC,CAAN,KAAA,EAAP,CAAO,CAAP;AAH6B,SAAA;AAI7CC,QAAAA,QAAQ,EAAE,SAAA,QAAA,CAAA,CAAA,EAAA;AAAA,iBAAOD,CAAC,CAAR,KAAA;AAJmC,SAAA;AAK7CL,QAAAA,SAAS,EAAE,KAAA,KAAA,CALkC,SAAA;AAM7CC,QAAAA,IAAI,EAAE,KAAA,KAAA,CANuC,IAAA;AAO7CoC,QAAAA,QAAQ,EAPqC,KAAA;AAQ7CC,QAAAA,UAAU,EAAE;AACVC,UAAAA,KAAK,EADK,KAAA;AAEVC,UAAAA,SAAS,EAAE;AAFD;AARiC,OAA/C,CADF,CADF,CAVK,EA2BL,KAAA,KAAA,CAAA,aAAA,IACE,IAAIC,OAAAA,CAAJ,gBAAA,CAAqB;AACnBN,QAAAA,EAAE,EAAA,GAAA,MAAA,CAAK,KAAA,KAAA,CAAL,EAAA,EADiB,YACjB,CADiB;AAEnBT,QAAAA,IAAI,EAAE,KAAA,KAAA,CAFa,aAAA;AAGnB;AACAzB,QAAAA,IAAI,EAAE,KAAA,KAAA,CAAWA;AAJE,OAArB,CA5BG,CAAP;AAmCD;;;;EApH0CW,KAAAA,CAAAA,c;;;;gBAAxBD,e,eACA,iB;;gBADAA,e,kBAEGf,Y","sourcesContent":["import { CompositeLayer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport PathOutlineLayer from '../path-outline-layer/path-outline-layer';\nimport Arrow2DGeometry from './arrow-2d-geometry';\n\nimport createPathMarkers from './create-path-markers';\nimport { getClosestPointOnPolyline } from './polyline';\n\nconst DISTANCE_FOR_MULTI_ARROWS = 0.1;\nconst ARROW_HEAD_SIZE = 0.2;\nconst ARROW_TAIL_WIDTH = 0.05;\n// const ARROW_CENTER_ADJUST = -0.8;\n\nconst DEFAULT_MARKER_LAYER = SimpleMeshLayer;\n\nconst DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n};\n\nconst defaultProps = Object.assign({}, PathOutlineLayer.defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n\n  sizeScale: 100,\n  fp64: false,\n\n  hightlightIndex: -1,\n  highlightPoint: null,\n\n  getPath: (x) => x.path,\n  getColor: (x) => x.color,\n  getMarkerColor: (x) => [0, 0, 0, 255],\n  getDirection: (x) => x.direction,\n  getMarkerPercentages: (object, { lineLength }) =>\n    lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5],\n});\n\nexport default class PathMarkerLayer extends CompositeLayer<any> {\n  static layerName = 'PathMarkerLayer';\n  static defaultProps = defaultProps;\n\n  initializeState() {\n    this.state = {\n      markers: [],\n      mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n      closestPoint: null,\n    };\n  }\n  // @ts-ignore\n  projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n    if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n      const [dx, dy] = viewport.metersToLngLatDelta(xyz);\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    } else if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n      const [dx, dy] = xyz;\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    }\n\n    return viewport.projectFlat(xyz);\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n      const {\n        data,\n        getPath,\n        getDirection,\n        getMarkerColor,\n        getMarkerPercentages,\n        coordinateSystem,\n        coordinateOrigin,\n      } = this.props;\n      // @ts-ignore\n      const { viewport } = this.context;\n      const projectFlat = (o) => this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n      this.state.markers = createPathMarkers({\n        data,\n        getPath,\n        getDirection,\n        getColor: getMarkerColor,\n        getMarkerPercentages,\n        projectFlat,\n      });\n      this._recalculateClosestPoint();\n    }\n    if (changeFlags.propsChanged) {\n      if (props.point !== oldProps.point) {\n        this._recalculateClosestPoint();\n      }\n    }\n  }\n\n  _recalculateClosestPoint() {\n    const { highlightPoint, highlightIndex } = this.props;\n    if (highlightPoint && highlightIndex >= 0) {\n      const object = this.props.data[highlightIndex];\n      const points = this.props.getPath(object);\n      const { point } = getClosestPointOnPolyline({ points, p: highlightPoint });\n      this.state.closestPoints = [\n        {\n          position: point,\n        },\n      ];\n    } else {\n      this.state.closestPoints = [];\n    }\n  }\n\n  getPickingInfo({ info }) {\n    return Object.assign(info, {\n      // override object with picked feature\n      object: (info.object && info.object.path) || info.object,\n    });\n  }\n\n  renderLayers() {\n    return [\n      new PathOutlineLayer(\n        this.props,\n        // @ts-ignore\n        this.getSubLayerProps({\n          id: 'paths',\n          // Note: data has to be passed explicitly like this to avoid being empty\n          data: this.props.data,\n        })\n      ),\n      new this.props.MarkerLayer(\n        this.getSubLayerProps(\n          Object.assign({}, this.props.markerLayerProps, {\n            id: 'markers',\n            data: this.state.markers,\n            getOrientation: (x) => [0, -x.angle, 0],\n            getColor: (x) => x.color,\n            sizeScale: this.props.sizeScale,\n            fp64: this.props.fp64,\n            pickable: false,\n            parameters: {\n              blend: false,\n              depthTest: false,\n            },\n          })\n        )\n      ),\n      this.state.closestPoints &&\n        new ScatterplotLayer({\n          id: `${this.props.id}-highlight`,\n          data: this.state.closestPoints,\n          // @ts-ignore\n          fp64: this.props.fp64,\n        }),\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}