{"ast":null,"code":"import { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n  model.component.legends = legendComponent;\n  return legendComponent;\n}\n\nfunction parseUnitLegend(model) {\n  const {\n    encoding\n  } = model;\n  const legendComponent = {};\n\n  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n    const def = getFieldOrDatumDef(encoding[channel]);\n\n    if (!def || !model.getScaleComponent(channel)) {\n      continue;\n    }\n\n    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n      continue;\n    }\n\n    legendComponent[channel] = parseLegendForChannel(model, channel);\n  }\n\n  return legendComponent;\n}\n\nfunction getLegendDefWithScale(model, channel) {\n  const scale = model.scaleName(channel);\n\n  if (model.mark === 'trail') {\n    if (channel === 'color') {\n      // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n      return {\n        stroke: scale\n      };\n    } else if (channel === 'size') {\n      return {\n        strokeWidth: scale\n      };\n    }\n  }\n\n  if (channel === 'color') {\n    return model.markDef.filled ? {\n      fill: scale\n    } : {\n      stroke: scale\n    };\n  }\n\n  return {\n    [channel]: scale\n  };\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nfunction isExplicit(value, property, legend, fieldDef) {\n  switch (property) {\n    case 'disable':\n      return legend !== undefined;\n    // if axis is specified or null/false, then its enable/disable state is explicit\n\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!(legend === null || legend === void 0 ? void 0 : legend.values);\n\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {\n        return true;\n      }\n\n  } // Otherwise, things are explicit if the returned value matches the specified property\n\n\n  return value === (legend || {})[property];\n}\n\nexport function parseLegendForChannel(model, channel) {\n  var _a, _b, _c;\n\n  let legend = model.legend(channel);\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const legendConfig = config.legend;\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n  const disable = legend !== undefined ? !legend : legendConfig.disable;\n  legendCmpt.set('disable', disable, legend !== undefined);\n\n  if (disable) {\n    return legendCmpt;\n  }\n\n  legend = legend || {};\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n  const orient = legend.orient || config.legend.orient || 'right';\n  const legendType = getLegendType({\n    legend,\n    channel,\n    timeUnit,\n    scaleType\n  });\n  const direction = getDirection({\n    legend,\n    legendType,\n    orient,\n    legendConfig\n  });\n  const ruleParams = {\n    legend,\n    channel,\n    model,\n    markDef,\n    encoding,\n    fieldOrDatumDef,\n    legendConfig,\n    config,\n    scaleType,\n    orient,\n    legendType,\n    direction\n  };\n\n  for (const property of LEGEND_COMPONENT_PROPERTIES) {\n    if (legendType === 'gradient' && property.startsWith('symbol') || legendType === 'symbol' && property.startsWith('gradient')) {\n      continue;\n    }\n\n    const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n\n      if (explicit || config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};\n  const selections = legendCmpt.get('selections');\n  const legendEncode = {};\n  const legendEncodeParams = {\n    fieldOrDatumDef,\n    model,\n    channel,\n    legendCmpt,\n    legendType\n  };\n\n  for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {\n    const legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);\n    const value = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n    : legendEncodingPart; // no rule -- just default values\n\n    if (value !== undefined && !isEmpty(value)) {\n      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? {\n        name: `${varName(fieldOrDatumDef.field)}_legend_${part}`\n      } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? {\n        interactive: !!selections\n      } : {}), {\n        update: value\n      });\n    }\n  }\n\n  if (!isEmpty(legendEncode)) {\n    legendCmpt.set('encode', legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));\n  }\n\n  return legendCmpt;\n}\n\nfunction parseNonUnitLegend(model) {\n  const {\n    legends,\n    resolve\n  } = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    for (const channel of keys(child.component.legends)) {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    }\n  }\n\n  for (const channel of keys(legends)) {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  }\n\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n  var _a, _b, _c, _d;\n\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false; // Otherwise, let's merge\n\n  for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', // Tie breaker function\n    (v1, v2) => {\n      switch (prop) {\n        case 'symbolType':\n          return mergeSymbolType(v1, v2);\n\n        case 'title':\n          return mergeTitleComponent(v1, v2);\n\n        case 'type':\n          // There are only two types. If we have different types, then prefer symbol over gradient.\n          typeMerged = true;\n          return makeImplicit('symbol');\n      }\n\n      return defaultTieBreaker(v1, v2, prop, 'legend');\n    });\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n\n  if (typeMerged) {\n    if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n\n    if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1, st2) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n\n  return st1;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n    const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n    model.component.legends = legendComponent;\n    return legendComponent;\n}\nfunction parseUnitLegend(model) {\n    const { encoding } = model;\n    const legendComponent = {};\n    for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n        const def = getFieldOrDatumDef(encoding[channel]);\n        if (!def || !model.getScaleComponent(channel)) {\n            continue;\n        }\n        if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n            continue;\n        }\n        legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n    return legendComponent;\n}\nfunction getLegendDefWithScale(model, channel) {\n    const scale = model.scaleName(channel);\n    if (model.mark === 'trail') {\n        if (channel === 'color') {\n            // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n            return { stroke: scale };\n        }\n        else if (channel === 'size') {\n            return { strokeWidth: scale };\n        }\n    }\n    if (channel === 'color') {\n        return model.markDef.filled ? { fill: scale } : { stroke: scale };\n    }\n    return { [channel]: scale };\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isExplicit(value, property, legend, fieldDef) {\n    switch (property) {\n        case 'disable':\n            return legend !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n        case 'values':\n            // specified legend.values is already respected, but may get transformed.\n            return !!(legend === null || legend === void 0 ? void 0 : legend.values);\n        case 'title':\n            // title can be explicit if fieldDef.title is set\n            if (property === 'title' && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {\n                return true;\n            }\n    }\n    // Otherwise, things are explicit if the returned value matches the specified property\n    return value === (legend || {})[property];\n}\nexport function parseLegendForChannel(model, channel) {\n    var _a, _b, _c;\n    let legend = model.legend(channel);\n    const { markDef, encoding, config } = model;\n    const legendConfig = config.legend;\n    const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n    parseInteractiveLegend(model, channel, legendCmpt);\n    const disable = legend !== undefined ? !legend : legendConfig.disable;\n    legendCmpt.set('disable', disable, legend !== undefined);\n    if (disable) {\n        return legendCmpt;\n    }\n    legend = legend || {};\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n    const orient = legend.orient || config.legend.orient || 'right';\n    const legendType = getLegendType({ legend, channel, timeUnit, scaleType });\n    const direction = getDirection({ legend, legendType, orient, legendConfig });\n    const ruleParams = {\n        legend,\n        channel,\n        model,\n        markDef,\n        encoding,\n        fieldOrDatumDef,\n        legendConfig,\n        config,\n        scaleType,\n        orient,\n        legendType,\n        direction\n    };\n    for (const property of LEGEND_COMPONENT_PROPERTIES) {\n        if ((legendType === 'gradient' && property.startsWith('symbol')) ||\n            (legendType === 'symbol' && property.startsWith('gradient'))) {\n            continue;\n        }\n        const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n        if (value !== undefined) {\n            const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n            if (explicit || config.legend[property] === undefined) {\n                legendCmpt.set(property, value, explicit);\n            }\n        }\n    }\n    const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};\n    const selections = legendCmpt.get('selections');\n    const legendEncode = {};\n    const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType };\n    for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {\n        const legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);\n        const value = part in legendEncodeRules\n            ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n            : legendEncodingPart; // no rule -- just default values\n        if (value !== undefined && !isEmpty(value)) {\n            legendEncode[part] = Object.assign(Object.assign(Object.assign({}, ((selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef)\n                ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` }\n                : {})), ((selections === null || selections === void 0 ? void 0 : selections.length) ? { interactive: !!selections } : {})), { update: value });\n        }\n    }\n    if (!isEmpty(legendEncode)) {\n        legendCmpt.set('encode', legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));\n    }\n    return legendCmpt;\n}\nfunction parseNonUnitLegend(model) {\n    const { legends, resolve } = model.component;\n    for (const child of model.children) {\n        parseLegend(child);\n        for (const channel of keys(child.component.legends)) {\n            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n            if (resolve.legend[channel] === 'shared') {\n                // If the resolve says shared (and has not been overridden)\n                // We will try to merge and see if there is a conflict\n                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n                if (!legends[channel]) {\n                    // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n                    // Thus, mark legend as independent and remove the legend component.\n                    resolve.legend[channel] = 'independent';\n                    delete legends[channel];\n                }\n            }\n        }\n    }\n    for (const channel of keys(legends)) {\n        for (const child of model.children) {\n            if (!child.component.legends[channel]) {\n                // skip if the child does not have a particular legend\n                continue;\n            }\n            if (resolve.legend[channel] === 'shared') {\n                // After merging shared legend, make sure to remove legend from child\n                delete child.component.legends[channel];\n            }\n        }\n    }\n    return legends;\n}\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n    var _a, _b, _c, _d;\n    if (!mergedLegend) {\n        return childLegend.clone();\n    }\n    const mergedOrient = mergedLegend.getWithExplicit('orient');\n    const childOrient = childLegend.getWithExplicit('orient');\n    if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n        // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n        // Cannot merge due to inconsistent orient\n        return undefined;\n    }\n    let typeMerged = false;\n    // Otherwise, let's merge\n    for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n        const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', \n        // Tie breaker function\n        (v1, v2) => {\n            switch (prop) {\n                case 'symbolType':\n                    return mergeSymbolType(v1, v2);\n                case 'title':\n                    return mergeTitleComponent(v1, v2);\n                case 'type':\n                    // There are only two types. If we have different types, then prefer symbol over gradient.\n                    typeMerged = true;\n                    return makeImplicit('symbol');\n            }\n            return defaultTieBreaker(v1, v2, prop, 'legend');\n        });\n        mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n    }\n    if (typeMerged) {\n        if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {\n            deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n        }\n        if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {\n            deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n        }\n    }\n    return mergedLegend;\n}\nfunction mergeSymbolType(st1, st2) {\n    if (st2.value === 'circle') {\n        // prefer \"circle\" over \"stroke\"\n        return st2;\n    }\n    return st1;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}