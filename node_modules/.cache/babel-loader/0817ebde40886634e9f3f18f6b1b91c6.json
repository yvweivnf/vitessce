{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bbox_1 = __importDefault(require(\"@turf/bbox\"));\n\nvar boolean_point_in_polygon_1 = __importDefault(require(\"@turf/boolean-point-in-polygon\"));\n\nvar boolean_point_on_line_1 = __importDefault(require(\"@turf/boolean-point-on-line\"));\n\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\n\n\nfunction booleanContains(feature1, feature2) {\n  var geom1 = invariant_1.getGeom(feature1);\n  var geom2 = invariant_1.getGeom(feature2);\n  var type1 = invariant_1.getType(feature1);\n  var type2 = invariant_1.getType(feature2);\n  var coords1 = invariant_1.getCoords(feature1);\n  var coords2 = invariant_1.getCoords(feature2);\n\n  switch (type1) {\n    case \"Point\":\n      switch (type2) {\n        case \"Point\":\n          return compareCoords(coords1, coords2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"Point\":\n          return isPointInMultiPoint(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointInMultiPoint(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"LineString\":\n      switch (type2) {\n        case \"Point\":\n          return boolean_point_on_line_1.default(geom2, geom1, {\n            ignoreEndVertices: true\n          });\n\n        case \"LineString\":\n          return isLineOnLine(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointOnLine(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"Polygon\":\n      switch (type2) {\n        case \"Point\":\n          return boolean_point_in_polygon_1.default(geom2, geom1, {\n            ignoreBoundary: true\n          });\n\n        case \"LineString\":\n          return isLineInPoly(geom1, geom2);\n\n        case \"Polygon\":\n          return isPolyInPoly(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointInPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\n\nexports.default = booleanContains;\n\nfunction isPointInMultiPoint(multiPoint, pt) {\n  var i;\n  var output = false;\n\n  for (i = 0; i < multiPoint.coordinates.length; i++) {\n    if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n      output = true;\n      break;\n    }\n  }\n\n  return output;\n}\n\nexports.isPointInMultiPoint = isPointInMultiPoint;\n\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n  for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n    var coord2 = _a[_i];\n    var matchFound = false;\n\n    for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n      var coord1 = _c[_b];\n\n      if (compareCoords(coord2, coord1)) {\n        matchFound = true;\n        break;\n      }\n    }\n\n    if (!matchFound) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;\n\nfunction isMultiPointOnLine(lineString, multiPoint) {\n  var haveFoundInteriorPoint = false;\n\n  for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n    var coord = _a[_i];\n\n    if (boolean_point_on_line_1.default(coord, lineString, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n\n    if (!boolean_point_on_line_1.default(coord, lineString)) {\n      return false;\n    }\n  }\n\n  if (haveFoundInteriorPoint) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isMultiPointOnLine = isMultiPointOnLine;\n\nfunction isMultiPointInPoly(polygon, multiPoint) {\n  for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n    var coord = _a[_i];\n\n    if (!boolean_point_in_polygon_1.default(coord, polygon, {\n      ignoreBoundary: true\n    })) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isMultiPointInPoly = isMultiPointInPoly;\n\nfunction isLineOnLine(lineString1, lineString2) {\n  var haveFoundInteriorPoint = false;\n\n  for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n    var coords = _a[_i];\n\n    if (boolean_point_on_line_1.default({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n\n    if (!boolean_point_on_line_1.default({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: false\n    })) {\n      return false;\n    }\n  }\n\n  return haveFoundInteriorPoint;\n}\n\nexports.isLineOnLine = isLineOnLine;\n\nfunction isLineInPoly(polygon, linestring) {\n  var output = false;\n  var i = 0;\n  var polyBbox = bbox_1.default(polygon);\n  var lineBbox = bbox_1.default(linestring);\n\n  if (!doBBoxOverlap(polyBbox, lineBbox)) {\n    return false;\n  }\n\n  for (i; i < linestring.coordinates.length - 1; i++) {\n    var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n\n    if (boolean_point_in_polygon_1.default({\n      type: \"Point\",\n      coordinates: midPoint\n    }, polygon, {\n      ignoreBoundary: true\n    })) {\n      output = true;\n      break;\n    }\n  }\n\n  return output;\n}\n\nexports.isLineInPoly = isLineInPoly;\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\n\nfunction isPolyInPoly(feature1, feature2) {\n  // Handle Nulls\n  if (feature1.type === \"Feature\" && feature1.geometry === null) {\n    return false;\n  }\n\n  if (feature2.type === \"Feature\" && feature2.geometry === null) {\n    return false;\n  }\n\n  var poly1Bbox = bbox_1.default(feature1);\n  var poly2Bbox = bbox_1.default(feature2);\n\n  if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n    return false;\n  }\n\n  var coords = invariant_1.getGeom(feature2).coordinates;\n\n  for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n    var ring = coords_1[_i];\n\n    for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n      var coord = ring_1[_a];\n\n      if (!boolean_point_in_polygon_1.default(coord, feature1)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexports.isPolyInPoly = isPolyInPoly;\n\nfunction doBBoxOverlap(bbox1, bbox2) {\n  if (bbox1[0] > bbox2[0]) {\n    return false;\n  }\n\n  if (bbox1[2] < bbox2[2]) {\n    return false;\n  }\n\n  if (bbox1[1] > bbox2[1]) {\n    return false;\n  }\n\n  if (bbox1[3] < bbox2[3]) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.doBBoxOverlap = doBBoxOverlap;\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\n\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n\nexports.compareCoords = compareCoords;\n\nfunction getMidpoint(pair1, pair2) {\n  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\n\nexports.getMidpoint = getMidpoint;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/boolean-contains/index.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","bbox_1","require","boolean_point_in_polygon_1","boolean_point_on_line_1","invariant_1","booleanContains","feature1","feature2","geom1","getGeom","geom2","type1","getType","type2","coords1","getCoords","coords2","compareCoords","Error","isPointInMultiPoint","isMultiPointInMultiPoint","default","ignoreEndVertices","isLineOnLine","isMultiPointOnLine","ignoreBoundary","isLineInPoly","isPolyInPoly","isMultiPointInPoly","multiPoint","pt","i","output","coordinates","length","multiPoint1","multiPoint2","_i","_a","coord2","matchFound","_b","_c","coord1","lineString","haveFoundInteriorPoint","coord","polygon","lineString1","lineString2","coords","type","linestring","polyBbox","lineBbox","doBBoxOverlap","midPoint","getMidpoint","geometry","poly1Bbox","poly2Bbox","coords_1","ring","ring_1","bbox1","bbox2","pair1","pair2"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = __importDefault(require(\"@turf/bbox\"));\nvar boolean_point_in_polygon_1 = __importDefault(require(\"@turf/boolean-point-in-polygon\"));\nvar boolean_point_on_line_1 = __importDefault(require(\"@turf/boolean-point-on-line\"));\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\nfunction booleanContains(feature1, feature2) {\n    var geom1 = invariant_1.getGeom(feature1);\n    var geom2 = invariant_1.getGeom(feature2);\n    var type1 = invariant_1.getType(feature1);\n    var type2 = invariant_1.getType(feature2);\n    var coords1 = invariant_1.getCoords(feature1);\n    var coords2 = invariant_1.getCoords(feature2);\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"Point\":\n                    return compareCoords(coords1, coords2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointOnLine(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });\n                case \"LineString\":\n                    return isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return isPolyInPoly(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nexports.default = booleanContains;\nfunction isPointInMultiPoint(multiPoint, pt) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isPointInMultiPoint = isPointInMultiPoint;\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n        var coord2 = _a[_i];\n        var matchFound = false;\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n            var coord1 = _c[_b];\n            if (compareCoords(coord2, coord1)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;\nfunction isMultiPointOnLine(lineString, multiPoint) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default(coord, lineString)) {\n            return false;\n        }\n    }\n    if (haveFoundInteriorPoint) {\n        return true;\n    }\n    return false;\n}\nexports.isMultiPointOnLine = isMultiPointOnLine;\nfunction isMultiPointInPoly(polygon, multiPoint) {\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInPoly = isMultiPointInPoly;\nfunction isLineOnLine(lineString1, lineString2) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n        var coords = _a[_i];\n        if (boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: false })) {\n            return false;\n        }\n    }\n    return haveFoundInteriorPoint;\n}\nexports.isLineOnLine = isLineOnLine;\nfunction isLineInPoly(polygon, linestring) {\n    var output = false;\n    var i = 0;\n    var polyBbox = bbox_1.default(polygon);\n    var lineBbox = bbox_1.default(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    for (i; i < linestring.coordinates.length - 1; i++) {\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n        if (boolean_point_in_polygon_1.default({ type: \"Point\", coordinates: midPoint }, polygon, { ignoreBoundary: true })) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isLineInPoly = isLineInPoly;\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    // Handle Nulls\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\n        return false;\n    }\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\n        return false;\n    }\n    var poly1Bbox = bbox_1.default(feature1);\n    var poly2Bbox = bbox_1.default(feature2);\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n        return false;\n    }\n    var coords = invariant_1.getGeom(feature2).coordinates;\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n        var ring = coords_1[_i];\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n            var coord = ring_1[_a];\n            if (!boolean_point_in_polygon_1.default(coord, feature1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.isPolyInPoly = isPolyInPoly;\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0]) {\n        return false;\n    }\n    if (bbox1[2] < bbox2[2]) {\n        return false;\n    }\n    if (bbox1[1] > bbox2[1]) {\n        return false;\n    }\n    if (bbox1[3] < bbox2[3]) {\n        return false;\n    }\n    return true;\n}\nexports.doBBoxOverlap = doBBoxOverlap;\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexports.compareCoords = compareCoords;\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexports.getMidpoint = getMidpoint;\n"]},"metadata":{},"sourceType":"script"}