{"ast":null,"code":"import center from '@turf/center';\nimport { GeoJSONReader, BufferOp, GeoJSONWriter } from 'turf-jsts';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { geoAzimuthalEquidistant } from 'd3-geo';\nimport { featureCollection, earthRadius, radiansToLength, lengthToRadians, feature } from '@turf/helpers';\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=8] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\n\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {}; // use user supplied options or default values\n\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8; // validation\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\"); // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n\n  if (radius === undefined) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n  var results = [];\n\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        var multiBuffered = bufferFeature(feature, radius, units, steps);\n\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n\n  return bufferFeature(geojson, radius, units, steps);\n}\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=8] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\n\n\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson; // Geometry Types faster than jsts\n\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  } // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)\n\n\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection)\n  }; // JSTS buffer operation\n\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered); // Detect if empty geometries\n\n  if (coordsIsNaN(buffered.coordinates)) return undefined; // Unproject coordinates (convert to Degrees)\n\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection)\n  };\n  return feature(result, properties);\n}\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\n\n\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\n\n\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\n\n\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n/**\n * Define Azimuthal Equidistant projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection\n */\n\n\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\n\nexport default buffer;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/buffer/dist/es/index.js"],"names":["center","GeoJSONReader","BufferOp","GeoJSONWriter","featureEach","geomEach","geoAzimuthalEquidistant","featureCollection","earthRadius","radiansToLength","lengthToRadians","feature","buffer","geojson","radius","options","units","steps","Error","undefined","results","type","geometry","buffered","bufferFeature","push","multiBuffered","properties","projection","defineProjection","projected","coordinates","projectCoords","reader","geom","read","distance","bufferOp","writer","write","coordsIsNaN","result","unprojectCoords","coords","Array","isArray","isNaN","proj","map","coord","invert","rotation","rotate","scale"],"mappings":"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","sourcesContent":["import center from '@turf/center';\nimport { GeoJSONReader, BufferOp, GeoJSONWriter } from 'turf-jsts';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { geoAzimuthalEquidistant } from 'd3-geo';\nimport { featureCollection, earthRadius, radiansToLength, lengthToRadians, feature } from '@turf/helpers';\n\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=8] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {};\n\n  // use user supplied options or default values\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8;\n\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\");\n\n  // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n  if (radius === undefined) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        var multiBuffered = bufferFeature(feature, radius, units, steps);\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n  return bufferFeature(geojson, radius, units, steps);\n}\n\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=8] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson;\n\n  // Geometry Types faster than jsts\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  }\n\n  // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection),\n  };\n\n  // JSTS buffer operation\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered);\n\n  // Detect if empty geometries\n  if (coordsIsNaN(buffered.coordinates)) return undefined;\n\n  // Unproject coordinates (convert to Degrees)\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection),\n  };\n\n  return feature(result, properties);\n}\n\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n\n/**\n * Define Azimuthal Equidistant projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection\n */\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\n\nexport default buffer;\n"]},"metadata":{},"sourceType":"module"}