{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport var CalculateNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(CalculateNode, _DataFlowNode);\n\n  var _super = _createSuper(CalculateNode);\n\n  function CalculateNode(parent, transform) {\n    var _this;\n\n    _classCallCheck(this, CalculateNode);\n\n    _this = _super.call(this, parent);\n    _this.transform = transform;\n    _this._dependentFields = getDependentFields(_this.transform.calculate);\n    return _this;\n  }\n\n  _createClass(CalculateNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new CalculateNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set([this.transform.as]);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return this._dependentFields;\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return {\n        type: 'formula',\n        expr: this.transform.calculate,\n        as: this.transform.as\n      };\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Calculate \".concat(_hash(this.transform));\n    }\n  }], [{\n    key: \"parseAllForSortIndex\",\n    value: function parseAllForSortIndex(parent, model) {\n      // get all the encoding with sort fields from model\n      model.forEachFieldDef(function (fieldDef, channel) {\n        if (!isScaleFieldDef(fieldDef)) {\n          return;\n        }\n\n        if (isSortArray(fieldDef.sort)) {\n          var field = fieldDef.field,\n              timeUnit = fieldDef.timeUnit;\n          var sort = fieldDef.sort; // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n\n          var calculate = sort.map(function (sortValue, i) {\n            return \"\".concat(fieldFilterExpression({\n              field: field,\n              timeUnit: timeUnit,\n              equal: sortValue\n            }), \" ? \").concat(i, \" : \");\n          }).join('') + sort.length;\n          parent = new CalculateNode(parent, {\n            calculate: calculate,\n            as: sortArrayIndexField(fieldDef, channel, {\n              forAs: true\n            })\n          });\n        }\n      });\n      return parent;\n    }\n  }]);\n\n  return CalculateNode;\n}(DataFlowNode);\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n  return vgField(fieldDef, Object.assign({\n    prefix: channel,\n    suffix: 'sort_index'\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}","map":{"version":3,"sources":["../../../../src/compile/data/calculate.ts"],"names":[],"mappings":";;;;AAEA,SAAwB,eAAxB,EAAwD,OAAxD,QAAsE,kBAAtE;AAEA,SAAQ,qBAAR,QAAoC,iBAApC;AACA,SAAQ,WAAR,QAA0B,YAA1B;AAEA,SAAQ,SAAR,EAAmB,IAAI,IAAJ,KAAnB,QAA8B,YAA9B;AAEA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,kBAAR,QAAiC,eAAjC;AAEA,WAAa,aAAb;AAAA;;AAAA;;AAOE,yBAAY,MAAZ,EAAmD,SAAnD,EAAgF;AAAA;;AAAA;;AAC9E,8BAAM,MAAN;AADiD,UAAA,SAAA,GAAA,SAAA;AAGjD,UAAK,gBAAL,GAAwB,kBAAkB,CAAC,MAAK,SAAL,CAAe,SAAhB,CAA1C;AAH8E;AAI/E;;AAXH;AAAA;AAAA,4BAGc;AACV,aAAO,IAAI,aAAJ,CAAkB,IAAlB,EAAwB,SAAS,CAAC,KAAK,SAAN,CAAjC,CAAP;AACD;AALH;AAAA;AAAA,qCAuCuB;AACnB,aAAO,IAAI,GAAJ,CAAQ,CAAC,KAAK,SAAL,CAAe,EAAhB,CAAR,CAAP;AACD;AAzCH;AAAA;AAAA,sCA2CwB;AACpB,aAAO,KAAK,gBAAZ;AACD;AA7CH;AAAA;AAAA,+BA+CiB;AACb,aAAO;AACL,QAAA,IAAI,EAAE,SADD;AAEL,QAAA,IAAI,EAAE,KAAK,SAAL,CAAe,SAFhB;AAGL,QAAA,EAAE,EAAE,KAAK,SAAL,CAAe;AAHd,OAAP;AAKD;AArDH;AAAA;AAAA,2BAuDa;AACT,iCAAoB,KAAI,CAAC,KAAK,SAAN,CAAxB;AACD;AAzDH;AAAA;AAAA,yCAaqC,MAbrC,EAa2D,KAb3D,EAagF;AAC5E;AACA,MAAA,KAAK,CAAC,eAAN,CAAsB,UAAC,QAAD,EAAkC,OAAlC,EAA+D;AACnF,YAAI,CAAC,eAAe,CAAC,QAAD,CAApB,EAAgC;AAC9B;AACD;;AACD,YAAI,WAAW,CAAC,QAAQ,CAAC,IAAV,CAAf,EAAgC;AAAA,cACvB,KADuB,GACJ,QADI,CACvB,KADuB;AAAA,cAChB,QADgB,GACJ,QADI,CAChB,QADgB;AAE9B,cAAM,IAAI,GAA6C,QAAQ,CAAC,IAAhE,CAF8B,CAG9B;;AACA,cAAM,SAAS,GACb,IAAI,CACD,GADH,CACO,UAAC,SAAD,EAAY,CAAZ,EAAiB;AACpB,6BAAU,qBAAqB,CAAC;AAAC,cAAA,KAAK,EAAL,KAAD;AAAQ,cAAA,QAAQ,EAAR,QAAR;AAAkB,cAAA,KAAK,EAAE;AAAzB,aAAD,CAA/B,gBAA0E,CAA1E;AACD,WAHH,EAIG,IAJH,CAIQ,EAJR,IAIc,IAAI,CAAC,MALrB;AAOA,UAAA,MAAM,GAAG,IAAI,aAAJ,CAAkB,MAAlB,EAA0B;AACjC,YAAA,SAAS,EAAT,SADiC;AAEjC,YAAA,EAAE,EAAE,mBAAmB,CAAC,QAAD,EAAW,OAAX,EAAoB;AAAC,cAAA,KAAK,EAAE;AAAR,aAApB;AAFU,WAA1B,CAAT;AAID;AACF,OApBD;AAqBA,aAAO,MAAP;AACD;AArCH;;AAAA;AAAA,EAAmC,YAAnC;AA4DA,OAAM,SAAU,mBAAV,CAA8B,QAA9B,EAA+D,OAA/D,EAA0F,GAA1F,EAA8G;AAClH,SAAO,OAAO,CAAC,QAAD,EAAS,MAAA,CAAA,MAAA,CAAA;AAAG,IAAA,MAAM,EAAE,OAAX;AAAoB,IAAA,MAAM,EAAE;AAA5B,GAAA,EAA8C,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAA,GAAA,GAAO,EAArD,CAAT,CAAd;AACD","sourceRoot":"","sourcesContent":["import { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class CalculateNode extends DataFlowNode {\n    constructor(parent, transform) {\n        super(parent);\n        this.transform = transform;\n        this._dependentFields = getDependentFields(this.transform.calculate);\n    }\n    clone() {\n        return new CalculateNode(null, duplicate(this.transform));\n    }\n    static parseAllForSortIndex(parent, model) {\n        // get all the encoding with sort fields from model\n        model.forEachFieldDef((fieldDef, channel) => {\n            if (!isScaleFieldDef(fieldDef)) {\n                return;\n            }\n            if (isSortArray(fieldDef.sort)) {\n                const { field, timeUnit } = fieldDef;\n                const sort = fieldDef.sort;\n                // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n                const calculate = sort\n                    .map((sortValue, i) => {\n                    return `${fieldFilterExpression({ field, timeUnit, equal: sortValue })} ? ${i} : `;\n                })\n                    .join('') + sort.length;\n                parent = new CalculateNode(parent, {\n                    calculate,\n                    as: sortArrayIndexField(fieldDef, channel, { forAs: true })\n                });\n            }\n        });\n        return parent;\n    }\n    producedFields() {\n        return new Set([this.transform.as]);\n    }\n    dependentFields() {\n        return this._dependentFields;\n    }\n    assemble() {\n        return {\n            type: 'formula',\n            expr: this.transform.calculate,\n            as: this.transform.as\n        };\n    }\n    hash() {\n        return `Calculate ${hash(this.transform)}`;\n    }\n}\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n    return vgField(fieldDef, Object.assign({ prefix: channel, suffix: 'sort_index' }, (opt !== null && opt !== void 0 ? opt : {})));\n}\n//# sourceMappingURL=calculate.js.map"]},"metadata":{},"sourceType":"module"}