{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = createPathMarkers;\n\nvar _math = require(\"math.gl\");\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  var lineLength = 0;\n\n  for (var i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n\n  return lineLength;\n}\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar DEFAULT_DIRECTION = {\n  forward: true,\n  backward: false\n};\n\nfunction createPathMarkers(_ref) {\n  var data = _ref.data,\n      _ref$getPath = _ref.getPath,\n      getPath = _ref$getPath === void 0 ? function (x) {\n    return x.path;\n  } : _ref$getPath,\n      _ref$getDirection = _ref.getDirection,\n      getDirection = _ref$getDirection === void 0 ? function (x) {\n    return x.direction;\n  } : _ref$getDirection,\n      _ref$getColor = _ref.getColor,\n      getColor = _ref$getColor === void 0 ? function (x) {\n    return DEFAULT_COLOR;\n  } : _ref$getColor,\n      _ref$getMarkerPercent = _ref.getMarkerPercentages,\n      getMarkerPercentages = _ref$getMarkerPercent === void 0 ? function (x) {\n    return [0.5];\n  } : _ref$getMarkerPercent,\n      projectFlat = _ref.projectFlat;\n  var markers = [];\n\n  var _iterator = _createForOfIteratorHelper(data),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var object = _step.value;\n      var path = getPath(object);\n      var direction = getDirection(object) || DEFAULT_DIRECTION;\n      var color = getColor(object);\n      var vPoints = path.map(function (p) {\n        return new _math.Vector2(p);\n      });\n      var vPointsReverse = vPoints.slice(0).reverse(); // calculate total length\n\n      var lineLength = getLineLength(vPoints); // Ask for where to put markers\n      // @ts-ignore\n\n      var percentages = getMarkerPercentages(object, {\n        lineLength: lineLength\n      }); // Create the markers\n\n      var _iterator2 = _createForOfIteratorHelper(percentages),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var percentage = _step2.value;\n\n          if (direction.forward) {\n            var marker = createMarkerAlongPath({\n              path: vPoints,\n              percentage: percentage,\n              lineLength: lineLength,\n              color: color,\n              object: object,\n              projectFlat: projectFlat\n            });\n            markers.push(marker);\n          }\n\n          if (direction.backward) {\n            var _marker = createMarkerAlongPath({\n              path: vPointsReverse,\n              percentage: percentage,\n              lineLength: lineLength,\n              color: color,\n              object: object,\n              projectFlat: projectFlat\n            });\n\n            markers.push(_marker);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath(_ref2) {\n  var path = _ref2.path,\n      percentage = _ref2.percentage,\n      lineLength = _ref2.lineLength,\n      color = _ref2.color,\n      object = _ref2.object,\n      projectFlat = _ref2.projectFlat;\n  var distanceAlong = lineLength * percentage;\n  var currentDistance = 0;\n  var previousDistance = 0;\n  var i = 0;\n\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n\n    previousDistance = currentDistance;\n  }\n\n  var vDirection = path[i + 1].clone().subtract(path[i]).normalize();\n  var along = distanceAlong - previousDistance;\n  var vCenter = vDirection.clone().multiply(new _math.Vector2(along, along)).add(path[i]);\n  var vDirection2 = new _math.Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n  var angle = vDirection2.verticalAngle() * 180 / Math.PI;\n  return {\n    position: [vCenter.x, vCenter.y, 0],\n    angle: angle,\n    color: color,\n    object: object\n  };\n}","map":{"version":3,"sources":["../../../src/layers/path-marker-layer/create-path-markers.ts"],"names":["lineLength","i","vPoints","DEFAULT_COLOR","DEFAULT_DIRECTION","forward","backward","data","getPath","x","getDirection","getColor","getMarkerPercentages","projectFlat","markers","object","path","direction","color","Vector2","vPointsReverse","getLineLength","percentages","percentage","marker","createMarkerAlongPath","distanceAlong","currentDistance","previousDistance","vDirection","along","vCenter","vDirection2","angle","Math","position"],"mappings":"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","sourcesContent":["import { Vector2 } from 'math.gl';\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  let lineLength = 0;\n  for (let i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n  return lineLength;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_DIRECTION = { forward: true, backward: false };\n\nexport default function createPathMarkers({\n  data,\n  getPath = (x) => x.path,\n  getDirection = (x) => x.direction,\n  getColor = (x) => DEFAULT_COLOR,\n  getMarkerPercentages = (x) => [0.5],\n  projectFlat,\n}) {\n  const markers = [];\n\n  for (const object of data) {\n    const path = getPath(object);\n    const direction = getDirection(object) || DEFAULT_DIRECTION;\n    const color = getColor(object);\n\n    const vPoints = path.map((p) => new Vector2(p));\n    const vPointsReverse = vPoints.slice(0).reverse();\n\n    // calculate total length\n    const lineLength = getLineLength(vPoints);\n\n    // Ask for where to put markers\n    // @ts-ignore\n    const percentages = getMarkerPercentages(object, { lineLength });\n\n    // Create the markers\n    for (const percentage of percentages) {\n      if (direction.forward) {\n        const marker = createMarkerAlongPath({\n          path: vPoints,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat,\n        });\n        markers.push(marker);\n      }\n\n      if (direction.backward) {\n        const marker = createMarkerAlongPath({\n          path: vPointsReverse,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat,\n        });\n        markers.push(marker);\n      }\n    }\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath({ path, percentage, lineLength, color, object, projectFlat }) {\n  const distanceAlong = lineLength * percentage;\n  let currentDistance = 0;\n  let previousDistance = 0;\n  let i = 0;\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n    previousDistance = currentDistance;\n  }\n\n  const vDirection = path[i + 1].clone().subtract(path[i]).normalize();\n  const along = distanceAlong - previousDistance;\n  const vCenter = vDirection.clone().multiply(new Vector2(along, along)).add(path[i]);\n\n  const vDirection2 = new Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n\n  const angle = (vDirection2.verticalAngle() * 180) / Math.PI;\n\n  return { position: [vCenter.x, vCenter.y, 0], angle, color, object };\n}\n"]},"metadata":{},"sourceType":"script"}