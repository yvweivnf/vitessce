{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport var legendRules = {\n  direction: function direction(_ref) {\n    var _direction = _ref.direction;\n    return _direction;\n  },\n  format: function format(_ref2) {\n    var fieldOrDatumDef = _ref2.fieldOrDatumDef,\n        legend = _ref2.legend,\n        config = _ref2.config;\n    var format = legend.format,\n        formatType = legend.formatType;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n  formatType: function formatType(_ref3) {\n    var legend = _ref3.legend,\n        fieldOrDatumDef = _ref3.fieldOrDatumDef,\n        scaleType = _ref3.scaleType;\n    var formatType = legend.formatType;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  gradientLength: function gradientLength(params) {\n    var _a, _b;\n\n    var legend = params.legend,\n        legendConfig = params.legendConfig;\n    return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);\n  },\n  labelOverlap: function labelOverlap(_ref4) {\n    var legend = _ref4.legend,\n        legendConfig = _ref4.legendConfig,\n        scaleType = _ref4.scaleType;\n\n    var _a, _b;\n\n    return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType);\n  },\n  symbolType: function symbolType(_ref5) {\n    var legend = _ref5.legend,\n        markDef = _ref5.markDef,\n        channel = _ref5.channel,\n        encoding = _ref5.encoding;\n\n    var _a;\n\n    return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);\n  },\n  title: function title(_ref6) {\n    var fieldOrDatumDef = _ref6.fieldOrDatumDef,\n        config = _ref6.config;\n    return fieldDefTitle(fieldOrDatumDef, config, {\n      allowDisabling: true\n    });\n  },\n  type: function type(_ref7) {\n    var legendType = _ref7.legendType,\n        scaleType = _ref7.scaleType,\n        channel = _ref7.channel;\n\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n\n    return legendType;\n  },\n  values: function values(_ref8) {\n    var fieldOrDatumDef = _ref8.fieldOrDatumDef,\n        legend = _ref8.legend;\n    return _values(legend, fieldOrDatumDef);\n  }\n};\n\nfunction _values(legend, fieldOrDatumDef) {\n  var vals = legend.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\n\nexport { _values as values };\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  var _a;\n\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    var shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;\n\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n\n  return undefined;\n}\nexport function getLegendType(params) {\n  var legend = params.legend;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType(_ref9) {\n  var channel = _ref9.channel,\n      timeUnit = _ref9.timeUnit,\n      scaleType = _ref9.scaleType;\n\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n\n  return 'symbol';\n}\nexport function getDirection(_ref10) {\n  var legendConfig = _ref10.legendConfig,\n      legendType = _ref10.legendType,\n      orient = _ref10.orient,\n      legend = _ref10.legend;\n\n  var _a, _b;\n\n  return (_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? 'gradientDirection' : 'symbolDirection']) !== null && _b !== void 0 ? _b : defaultDirection(orient, legendType);\n}\nexport function defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\nexport function defaultGradientLength(_ref11) {\n  var legendConfig = _ref11.legendConfig,\n      model = _ref11.model,\n      direction = _ref11.direction,\n      orient = _ref11.orient,\n      scaleType = _ref11.scaleType;\n  var gradientHorizontalMaxLength = legendConfig.gradientHorizontalMaxLength,\n      gradientHorizontalMinLength = legendConfig.gradientHorizontalMinLength,\n      gradientVerticalMaxLength = legendConfig.gradientVerticalMaxLength,\n      gradientVerticalMinLength = legendConfig.gradientVerticalMinLength;\n\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n\n  return undefined;\n}\n\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  var sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: \"clamp(\".concat(sizeSignal, \", \").concat(min, \", \").concat(max, \")\")\n  };\n}\n\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n    direction: ({ direction }) => direction,\n    format: ({ fieldOrDatumDef, legend, config }) => {\n        const { format, formatType } = legend;\n        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n    },\n    formatType: ({ legend, fieldOrDatumDef, scaleType }) => {\n        const { formatType } = legend;\n        return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n    },\n    gradientLength: params => {\n        var _a, _b;\n        const { legend, legendConfig } = params;\n        return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);\n    },\n    labelOverlap: ({ legend, legendConfig, scaleType }) => { var _a, _b; return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType); },\n    symbolType: ({ legend, markDef, channel, encoding }) => { var _a; return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape); },\n    title: ({ fieldOrDatumDef, config }) => fieldDefTitle(fieldOrDatumDef, config, { allowDisabling: true }),\n    type: ({ legendType, scaleType, channel }) => {\n        if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n            if (legendType === 'gradient') {\n                return undefined;\n            }\n        }\n        else if (legendType === 'symbol') {\n            return undefined;\n        }\n        return legendType;\n    },\n    values: ({ fieldOrDatumDef, legend }) => values(legend, fieldOrDatumDef)\n};\nexport function values(legend, fieldOrDatumDef) {\n    const vals = legend.values;\n    if (isArray(vals)) {\n        return valueArray(fieldOrDatumDef, vals);\n    }\n    else if (isSignalRef(vals)) {\n        return vals;\n    }\n    return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n    var _a;\n    if (channel !== 'shape') {\n        // use the value from the shape encoding or the mark config if they exist\n        const shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;\n        if (shape) {\n            return shape;\n        }\n    }\n    switch (mark) {\n        case 'bar':\n        case 'rect':\n        case 'image':\n        case 'square':\n            return 'square';\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return 'stroke';\n        case 'arc':\n        case 'point':\n        case 'circle':\n        case 'tick':\n        case 'geoshape':\n        case 'area':\n        case 'text':\n            return 'circle';\n    }\n}\nexport function clipHeight(legendType) {\n    if (legendType === 'gradient') {\n        return 20;\n    }\n    return undefined;\n}\nexport function getLegendType(params) {\n    const { legend } = params;\n    return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType({ channel, timeUnit, scaleType }) {\n    // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n    if (isColorChannel(channel)) {\n        if (contains(['quarter', 'month', 'day'], timeUnit)) {\n            return 'symbol';\n        }\n        if (isContinuousToContinuous(scaleType)) {\n            return 'gradient';\n        }\n    }\n    return 'symbol';\n}\nexport function getDirection({ legendConfig, legendType, orient, legend }) {\n    var _a, _b;\n    return ((_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? 'gradientDirection' : 'symbolDirection']) !== null && _b !== void 0 ? _b : defaultDirection(orient, legendType));\n}\nexport function defaultDirection(orient, legendType) {\n    switch (orient) {\n        case 'top':\n        case 'bottom':\n            return 'horizontal';\n        case 'left':\n        case 'right':\n        case 'none':\n        case undefined: // undefined = \"right\" in Vega\n            return undefined; // vertical is Vega's default\n        default:\n            // top-left / ...\n            // For inner legend, uses compact layout like Tableau\n            return legendType === 'gradient' ? 'horizontal' : undefined;\n    }\n}\nexport function defaultGradientLength({ legendConfig, model, direction, orient, scaleType }) {\n    const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;\n    if (isContinuousToContinuous(scaleType)) {\n        if (direction === 'horizontal') {\n            if (orient === 'top' || orient === 'bottom') {\n                return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n            }\n            else {\n                return gradientHorizontalMinLength;\n            }\n        }\n        else {\n            // vertical / undefined (Vega uses vertical by default)\n            return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n        }\n    }\n    return undefined;\n}\nfunction gradientLengthSignal(model, sizeType, min, max) {\n    const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n    return { signal: `clamp(${sizeSignal}, ${min}, ${max})` };\n}\nexport function defaultLabelOverlap(scaleType) {\n    if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n        return 'greedy';\n    }\n    return undefined;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}