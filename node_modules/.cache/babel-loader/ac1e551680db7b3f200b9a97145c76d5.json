{"ast":null,"code":"import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getAxisConfig } from './config';\nexport var axisRules = {\n  scale: function scale(_ref) {\n    var model = _ref.model,\n        channel = _ref.channel;\n    return model.scaleName(channel);\n  },\n  format: function format(_ref2) {\n    var fieldOrDatumDef = _ref2.fieldOrDatumDef,\n        config = _ref2.config,\n        axis = _ref2.axis;\n    var format = axis.format,\n        formatType = axis.formatType;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n  },\n  formatType: function formatType(_ref3) {\n    var axis = _ref3.axis,\n        fieldOrDatumDef = _ref3.fieldOrDatumDef,\n        scaleType = _ref3.scaleType;\n    var formatType = axis.formatType;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  grid: function grid(_ref4) {\n    var fieldOrDatumDef = _ref4.fieldOrDatumDef,\n        axis = _ref4.axis,\n        scaleType = _ref4.scaleType;\n\n    var _a;\n\n    return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef);\n  },\n  gridScale: function gridScale(_ref5) {\n    var model = _ref5.model,\n        channel = _ref5.channel;\n    return _gridScale(model, channel);\n  },\n  labelAlign: function labelAlign(_ref6) {\n    var axis = _ref6.axis,\n        labelAngle = _ref6.labelAngle,\n        orient = _ref6.orient,\n        channel = _ref6.channel;\n    return axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel);\n  },\n  labelAngle: function labelAngle(_ref7) {\n    var _labelAngle = _ref7.labelAngle;\n    return _labelAngle;\n  },\n  labelBaseline: function labelBaseline(_ref8) {\n    var axis = _ref8.axis,\n        labelAngle = _ref8.labelAngle,\n        orient = _ref8.orient,\n        channel = _ref8.channel;\n    return axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel);\n  },\n  labelFlush: function labelFlush(_ref9) {\n    var axis = _ref9.axis,\n        fieldOrDatumDef = _ref9.fieldOrDatumDef,\n        channel = _ref9.channel;\n\n    var _a;\n\n    return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel);\n  },\n  labelOverlap: function labelOverlap(_ref10) {\n    var axis = _ref10.axis,\n        fieldOrDatumDef = _ref10.fieldOrDatumDef,\n        scaleType = _ref10.scaleType;\n\n    var _a;\n\n    return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n  },\n  // we already calculate orient in parse\n  orient: function orient(_ref11) {\n    var _orient = _ref11.orient;\n    return _orient;\n  },\n  tickCount: function tickCount(_ref12) {\n    var channel = _ref12.channel,\n        model = _ref12.model,\n        axis = _ref12.axis,\n        fieldOrDatumDef = _ref12.fieldOrDatumDef,\n        scaleType = _ref12.scaleType;\n\n    var _a;\n\n    var sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    var size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n    return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({\n      fieldOrDatumDef: fieldOrDatumDef,\n      scaleType: scaleType,\n      size: size,\n      values: axis.values\n    });\n  },\n  title: function title(_ref13) {\n    var axis = _ref13.axis,\n        model = _ref13.model,\n        channel = _ref13.channel;\n\n    if (axis.title !== undefined) {\n      return axis.title;\n    }\n\n    var fieldDefTitle = getFieldDefTitle(model, channel);\n\n    if (fieldDefTitle !== undefined) {\n      return fieldDefTitle;\n    }\n\n    var fieldDef = model.typedFieldDef(channel);\n    var channel2 = channel === 'x' ? 'x2' : 'y2';\n    var fieldDef2 = model.fieldDef(channel2); // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n\n    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n  },\n  values: function values(_ref14) {\n    var axis = _ref14.axis,\n        fieldOrDatumDef = _ref14.fieldOrDatumDef;\n    return _values(axis, fieldOrDatumDef);\n  },\n  zindex: function zindex(_ref15) {\n    var axis = _ref15.axis,\n        fieldOrDatumDef = _ref15.fieldOrDatumDef,\n        mark = _ref15.mark;\n\n    var _a;\n\n    return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef);\n  }\n}; // TODO: we need to refactor this method after we take care of config refactoring\n\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\n\nexport function defaultGrid(scaleType, fieldDef) {\n  return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);\n}\n\nfunction _gridScale(model, channel) {\n  var gridChannel = channel === 'x' ? 'y' : 'x';\n\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n\n  return undefined;\n}\n\nexport { _gridScale as gridScale };\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n  var labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle; // try axis value\n\n  if (labelAngle !== undefined) {\n    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n  } else {\n    // try axis config value\n    var _getAxisConfig = getAxisConfig('labelAngle', styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs),\n        angle = _getAxisConfig.configValue;\n\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n        return 270;\n      } // no default\n\n\n      return undefined;\n    }\n  }\n}\nexport function normalizeAngleExpr(angle) {\n  return \"(((\".concat(angle.signal, \" % 360) + 360) % 360)\");\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n  if (angle !== undefined) {\n    if (channel === 'x') {\n      if (isSignalRef(angle)) {\n        var a = normalizeAngleExpr(angle);\n        var orientIsTop = isSignalRef(orient) ? \"(\".concat(orient.signal, \" === \\\"top\\\")\") : orient === 'top';\n        return {\n          signal: \"(45 < \".concat(a, \" && \").concat(a, \" < 135) || (225 < \").concat(a, \" && \").concat(a, \" < 315) ? \\\"middle\\\" :\") + \"(\".concat(a, \" <= 45 || 315 <= \").concat(a, \") === \").concat(orientIsTop, \" ? \\\"bottom\\\" : \\\"top\\\"\")\n        };\n      }\n\n      if (45 < angle && angle < 135 || 225 < angle && angle < 315) {\n        return 'middle';\n      }\n\n      if (isSignalRef(orient)) {\n        var op = angle <= 45 || 315 <= angle ? '===' : '!==';\n        return {\n          signal: \"\".concat(orient.signal, \" \").concat(op, \" \\\"top\\\" ? \\\"bottom\\\" : \\\"top\\\"\")\n        };\n      }\n\n      return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n    } else {\n      if (isSignalRef(angle)) {\n        var _a2 = normalizeAngleExpr(angle);\n\n        var orientIsLeft = isSignalRef(orient) ? \"(\".concat(orient.signal, \" === \\\"left\\\")\") : orient === 'left';\n        var middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n        return {\n          signal: \"\".concat(_a2, \" <= 45 || 315 <= \").concat(_a2, \" || (135 <= \").concat(_a2, \" && \").concat(_a2, \" <= 225) ? \").concat(middle, \" : (45 <= \").concat(_a2, \" && \").concat(_a2, \" <= 135) === \").concat(orientIsLeft, \" ? \\\"top\\\" : \\\"bottom\\\"\")\n        };\n      }\n\n      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {\n        return alwaysIncludeMiddle ? 'middle' : null;\n      }\n\n      if (isSignalRef(orient)) {\n        var _op = 45 <= angle && angle <= 135 ? '===' : '!==';\n\n        return {\n          signal: \"\".concat(orient.signal, \" \").concat(_op, \" \\\"left\\\" ? \\\"top\\\" : \\\"bottom\\\"\")\n        };\n      }\n\n      return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n    }\n  }\n\n  return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n  if (angle === undefined) {\n    return undefined;\n  }\n\n  var isX = channel === 'x';\n  var startAngle = isX ? 0 : 90;\n  var mainOrient = isX ? 'bottom' : 'left';\n\n  if (isSignalRef(angle)) {\n    var a = normalizeAngleExpr(angle);\n    var orientIsMain = isSignalRef(orient) ? \"(\".concat(orient.signal, \" === \\\"\").concat(mainOrient, \"\\\")\") : orient === mainOrient;\n    return {\n      signal: \"(\".concat(startAngle ? \"(\".concat(a, \" + 90)\") : a, \" % 180 === 0) ? \").concat(isX ? null : '\"center\"', \" :\") + \"(\".concat(startAngle, \" < \").concat(a, \" && \").concat(a, \" < \").concat(180 + startAngle, \") === \").concat(orientIsMain, \" ? \\\"left\\\" : \\\"right\\\"\")\n    };\n  }\n\n  if ((angle + startAngle) % 180 === 0) {\n    // For bottom, use default label align so label flush still works\n    return isX ? null : 'center';\n  }\n\n  if (isSignalRef(orient)) {\n    var op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n\n    var _orientIsMain = \"\".concat(orient.signal, \" \").concat(op, \" \\\"\").concat(mainOrient, \"\\\"\");\n\n    return {\n      signal: \"\".concat(_orientIsMain, \" ? \\\"left\\\" : \\\"right\\\"\")\n    };\n  }\n\n  if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n    return 'left';\n  }\n\n  return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (hasTimeUnit && !isObject(sort) || type !== 'nominal' && type !== 'ordinal') {\n    if (scaleType === 'log' || scaleType === 'symlog') {\n      return 'greedy';\n    }\n\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultOrient(channel) {\n  return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount(_ref16) {\n  var fieldOrDatumDef = _ref16.fieldOrDatumDef,\n      scaleType = _ref16.scaleType,\n      size = _ref16.size,\n      vals = _ref16.values;\n\n  var _a;\n\n  if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n    if (isFieldDef(fieldOrDatumDef)) {\n      if (isBinning(fieldOrDatumDef.bin)) {\n        // for binned data, we don't want more ticks than maxbins\n        return {\n          signal: \"ceil(\".concat(size.signal, \"/10)\")\n        };\n      }\n\n      if (fieldOrDatumDef.timeUnit && contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {\n        return undefined;\n      }\n    }\n\n    return {\n      signal: \"ceil(\".concat(size.signal, \"/40)\")\n    };\n  }\n\n  return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n  var channel2 = channel === 'x' ? 'x2' : 'y2';\n  var fieldDef = model.fieldDef(channel);\n  var fieldDef2 = model.fieldDef(channel2);\n  var title1 = fieldDef ? fieldDef.title : undefined;\n  var title2 = fieldDef2 ? fieldDef2.title : undefined;\n\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n\n  return undefined;\n}\n\nfunction _values(axis, fieldOrDatumDef) {\n  var vals = axis.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\n\nexport { _values as values };\nexport function defaultZindex(mark, fieldDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getAxisConfig } from './config';\nexport const axisRules = {\n    scale: ({ model, channel }) => model.scaleName(channel),\n    format: ({ fieldOrDatumDef, config, axis }) => {\n        const { format, formatType } = axis;\n        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n    },\n    formatType: ({ axis, fieldOrDatumDef, scaleType }) => {\n        const { formatType } = axis;\n        return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n    },\n    grid: ({ fieldOrDatumDef, axis, scaleType }) => { var _a; return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef); },\n    gridScale: ({ model, channel }) => gridScale(model, channel),\n    labelAlign: ({ axis, labelAngle, orient, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel),\n    labelAngle: ({ labelAngle }) => labelAngle,\n    labelBaseline: ({ axis, labelAngle, orient, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel),\n    labelFlush: ({ axis, fieldOrDatumDef, channel }) => { var _a; return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel); },\n    labelOverlap: ({ axis, fieldOrDatumDef, scaleType }) => {\n        var _a;\n        return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n    },\n    // we already calculate orient in parse\n    orient: ({ orient }) => orient,\n    tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType }) => {\n        var _a;\n        const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n        const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n        return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({ fieldOrDatumDef, scaleType, size, values: axis.values });\n    },\n    title: ({ axis, model, channel }) => {\n        if (axis.title !== undefined) {\n            return axis.title;\n        }\n        const fieldDefTitle = getFieldDefTitle(model, channel);\n        if (fieldDefTitle !== undefined) {\n            return fieldDefTitle;\n        }\n        const fieldDef = model.typedFieldDef(channel);\n        const channel2 = channel === 'x' ? 'x2' : 'y2';\n        const fieldDef2 = model.fieldDef(channel2);\n        // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n        return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n    },\n    values: ({ axis, fieldOrDatumDef }) => values(axis, fieldOrDatumDef),\n    zindex: ({ axis, fieldOrDatumDef, mark }) => { var _a; return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef); }\n};\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function defaultGrid(scaleType, fieldDef) {\n    return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);\n}\nexport function gridScale(model, channel) {\n    const gridChannel = channel === 'x' ? 'y' : 'x';\n    if (model.getScaleComponent(gridChannel)) {\n        return model.scaleName(gridChannel);\n    }\n    return undefined;\n}\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n    const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;\n    // try axis value\n    if (labelAngle !== undefined) {\n        return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n    }\n    else {\n        // try axis config value\n        const { configValue: angle } = getAxisConfig('labelAngle', styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);\n        if (angle !== undefined) {\n            return normalizeAngle(angle);\n        }\n        else {\n            // get default value\n            if (channel === X &&\n                contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) &&\n                !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n                return 270;\n            }\n            // no default\n            return undefined;\n        }\n    }\n}\nexport function normalizeAngleExpr(angle) {\n    return `(((${angle.signal} % 360) + 360) % 360)`;\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n    if (angle !== undefined) {\n        if (channel === 'x') {\n            if (isSignalRef(angle)) {\n                const a = normalizeAngleExpr(angle);\n                const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n                return {\n                    signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` +\n                        `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n                };\n            }\n            if ((45 < angle && angle < 135) || (225 < angle && angle < 315)) {\n                return 'middle';\n            }\n            if (isSignalRef(orient)) {\n                const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n                return { signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"` };\n            }\n            return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n        }\n        else {\n            if (isSignalRef(angle)) {\n                const a = normalizeAngleExpr(angle);\n                const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n                const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n                return {\n                    signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n                };\n            }\n            if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n                return alwaysIncludeMiddle ? 'middle' : null;\n            }\n            if (isSignalRef(orient)) {\n                const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n                return { signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"` };\n            }\n            return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n        }\n    }\n    return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n    if (angle === undefined) {\n        return undefined;\n    }\n    const isX = channel === 'x';\n    const startAngle = isX ? 0 : 90;\n    const mainOrient = isX ? 'bottom' : 'left';\n    if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n        return {\n            signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` +\n                `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n        };\n    }\n    if ((angle + startAngle) % 180 === 0) {\n        // For bottom, use default label align so label flush still works\n        return isX ? null : 'center';\n    }\n    if (isSignalRef(orient)) {\n        const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n        const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n        return {\n            signal: `${orientIsMain} ? \"left\" : \"right\"`\n        };\n    }\n    if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n        return 'left';\n    }\n    return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n    if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n        return true;\n    }\n    return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n    // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n    if ((hasTimeUnit && !isObject(sort)) || (type !== 'nominal' && type !== 'ordinal')) {\n        if (scaleType === 'log' || scaleType === 'symlog') {\n            return 'greedy';\n        }\n        return true;\n    }\n    return undefined;\n}\nexport function defaultOrient(channel) {\n    return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount({ fieldOrDatumDef, scaleType, size, values: vals }) {\n    var _a;\n    if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n        if (isFieldDef(fieldOrDatumDef)) {\n            if (isBinning(fieldOrDatumDef.bin)) {\n                // for binned data, we don't want more ticks than maxbins\n                return { signal: `ceil(${size.signal}/10)` };\n            }\n            if (fieldOrDatumDef.timeUnit &&\n                contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {\n                return undefined;\n            }\n        }\n        return { signal: `ceil(${size.signal}/40)` };\n    }\n    return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef = model.fieldDef(channel);\n    const fieldDef2 = model.fieldDef(channel2);\n    const title1 = fieldDef ? fieldDef.title : undefined;\n    const title2 = fieldDef2 ? fieldDef2.title : undefined;\n    if (title1 && title2) {\n        return mergeTitle(title1, title2);\n    }\n    else if (title1) {\n        return title1;\n    }\n    else if (title2) {\n        return title2;\n    }\n    else if (title1 !== undefined) {\n        // falsy value to disable config\n        return title1;\n    }\n    else if (title2 !== undefined) {\n        // falsy value to disable config\n        return title2;\n    }\n    return undefined;\n}\nexport function values(axis, fieldOrDatumDef) {\n    const vals = axis.values;\n    if (isArray(vals)) {\n        return valueArray(fieldOrDatumDef, vals);\n    }\n    else if (isSignalRef(vals)) {\n        return vals;\n    }\n    return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n    if (mark === 'rect' && isDiscrete(fieldDef)) {\n        return 1;\n    }\n    return 0;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}