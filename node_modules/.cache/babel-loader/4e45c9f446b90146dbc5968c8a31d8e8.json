{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\n\nfunction rangeFormula(model, fieldDef, channel, config) {\n  var _a, _b;\n\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    const guide = isUnitModel(model) ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};\n    const startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    const endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n    };\n  }\n\n  return {};\n}\n\nfunction binKey(bin, field) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nexport function getBinSignalName(model, field, bin) {\n  var _a;\n\n  const normalizedBin = (_a = normalizeBin(bin, undefined)) !== null && _a !== void 0 ? _a : {};\n  const key = binKey(normalizedBin, field);\n  return model.getName(`${key}_bins`);\n}\n\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t, bin, model) {\n  let as;\n  let span;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n\n  const normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n  const key = binKey(normalizedBin, t.field);\n  const {\n    signal,\n    extentSignal\n  } = getSignalsFromModel(model, key);\n\n  if (isParameterExtent(normalizedBin.extent)) {\n    const ext = normalizedBin.extent;\n    span = parseSelectionExtent(model, ext.param, ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  const binComponent = Object.assign(Object.assign(Object.assign({\n    bin: normalizedBin,\n    field: t.field,\n    as: [as]\n  }, signal ? {\n    signal\n  } : {}), extentSignal ? {\n    extentSignal\n  } : {}), span ? {\n    span\n  } : {});\n  return {\n    key,\n    binComponent\n  };\n}\n\nexport class BinNode extends DataFlowNode {\n  constructor(parent, bins) {\n    super(parent);\n    this.bins = bins;\n  }\n\n  clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const {\n          key,\n          binComponent\n        } = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n      }\n\n      return binComponentIndex;\n    }, {});\n\n    if (isEmpty(bins)) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n\n\n  static makeFromTransform(parent, t, model) {\n    const {\n      key,\n      binComponent\n    } = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n\n\n  merge(other, renameSignal) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal); // Ensure that we don't have duplicate names for signal pairs\n\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  producedFields() {\n    return new Set(vals(this.bins).map(c => c.as).flat(2));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n\n  hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  assemble() {\n    return vals(this.bins).flatMap(bin => {\n      const transform = [];\n      const [binAs, ...remainingAs] = bin.as;\n\n      const _a = bin.bin,\n            {\n        extent\n      } = _a,\n            params = __rest(_a, [\"extent\"]);\n\n      const binTrans = Object.assign(Object.assign(Object.assign({\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal\n      }, !isParameterExtent(extent) ? {\n        extent\n      } : {\n        extent: null\n      }), bin.span ? {\n        span: {\n          signal: `span(${bin.span})`\n        }\n      } : {}), params);\n\n      if (!extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {\n          signal: bin.extentSignal\n        };\n      }\n\n      transform.push(binTrans);\n\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({\n              field: binAs[i]\n            }, {\n              expr: 'datum'\n            }),\n            as: as[i]\n          });\n        }\n      }\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n\n      return transform;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/bin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\nfunction rangeFormula(model, fieldDef, channel, config) {\n    var _a, _b;\n    if (binRequiresRange(fieldDef, channel)) {\n        // read format from axis or legend, if there is no format then use config.numberFormat\n        const guide = isUnitModel(model)\n            ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {}\n            : {};\n        const startField = vgField(fieldDef, { expr: 'datum' });\n        const endField = vgField(fieldDef, { expr: 'datum', binSuffix: 'end' });\n        return {\n            formulaAs: vgField(fieldDef, { binSuffix: 'range', forAs: true }),\n            formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n        };\n    }\n    return {};\n}\nfunction binKey(bin, field) {\n    return `${binToString(bin)}_${field}`;\n}\nfunction getSignalsFromModel(model, key) {\n    return {\n        signal: model.getName(`${key}_bins`),\n        extentSignal: model.getName(`${key}_extent`)\n    };\n}\nexport function getBinSignalName(model, field, bin) {\n    var _a;\n    const normalizedBin = (_a = normalizeBin(bin, undefined)) !== null && _a !== void 0 ? _a : {};\n    const key = binKey(normalizedBin, field);\n    return model.getName(`${key}_bins`);\n}\nfunction isBinTransform(t) {\n    return 'as' in t;\n}\nfunction createBinComponent(t, bin, model) {\n    let as;\n    let span;\n    if (isBinTransform(t)) {\n        as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n    }\n    else {\n        as = [vgField(t, { forAs: true }), vgField(t, { binSuffix: 'end', forAs: true })];\n    }\n    const normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n    const key = binKey(normalizedBin, t.field);\n    const { signal, extentSignal } = getSignalsFromModel(model, key);\n    if (isParameterExtent(normalizedBin.extent)) {\n        const ext = normalizedBin.extent;\n        span = parseSelectionExtent(model, ext.param, ext);\n        delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n    }\n    const binComponent = Object.assign(Object.assign(Object.assign({ bin: normalizedBin, field: t.field, as: [as] }, (signal ? { signal } : {})), (extentSignal ? { extentSignal } : {})), (span ? { span } : {}));\n    return { key, binComponent };\n}\nexport class BinNode extends DataFlowNode {\n    constructor(parent, bins) {\n        super(parent);\n        this.bins = bins;\n    }\n    clone() {\n        return new BinNode(null, duplicate(this.bins));\n    }\n    static makeFromEncoding(parent, model) {\n        const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n            if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n                const { key, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);\n                binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n            }\n            return binComponentIndex;\n        }, {});\n        if (isEmpty(bins)) {\n            return null;\n        }\n        return new BinNode(parent, bins);\n    }\n    /**\n     * Creates a bin node from BinTransform.\n     * The optional parameter should provide\n     */\n    static makeFromTransform(parent, t, model) {\n        const { key, binComponent } = createBinComponent(t, t.bin, model);\n        return new BinNode(parent, {\n            [key]: binComponent\n        });\n    }\n    /**\n     * Merge bin nodes. This method either integrates the bin config from the other node\n     * or if this node already has a bin config, renames the corresponding signal in the model.\n     */\n    merge(other, renameSignal) {\n        for (const key of keys(other.bins)) {\n            if (key in this.bins) {\n                renameSignal(other.bins[key].signal, this.bins[key].signal);\n                // Ensure that we don't have duplicate names for signal pairs\n                this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n            }\n            else {\n                this.bins[key] = other.bins[key];\n            }\n        }\n        for (const child of other.children) {\n            other.removeChild(child);\n            child.parent = this;\n        }\n        other.remove();\n    }\n    producedFields() {\n        return new Set(vals(this.bins)\n            .map(c => c.as)\n            .flat(2));\n    }\n    dependentFields() {\n        return new Set(vals(this.bins).map(c => c.field));\n    }\n    hash() {\n        return `Bin ${hash(this.bins)}`;\n    }\n    assemble() {\n        return vals(this.bins).flatMap(bin => {\n            const transform = [];\n            const [binAs, ...remainingAs] = bin.as;\n            const _a = bin.bin, { extent } = _a, params = __rest(_a, [\"extent\"]);\n            const binTrans = Object.assign(Object.assign(Object.assign({ type: 'bin', field: replacePathInField(bin.field), as: binAs, signal: bin.signal }, (!isParameterExtent(extent) ? { extent } : { extent: null })), (bin.span ? { span: { signal: `span(${bin.span})` } } : {})), params);\n            if (!extent && bin.extentSignal) {\n                transform.push({\n                    type: 'extent',\n                    field: replacePathInField(bin.field),\n                    signal: bin.extentSignal\n                });\n                binTrans.extent = { signal: bin.extentSignal };\n            }\n            transform.push(binTrans);\n            for (const as of remainingAs) {\n                for (let i = 0; i < 2; i++) {\n                    transform.push({\n                        type: 'formula',\n                        expr: vgField({ field: binAs[i] }, { expr: 'datum' }),\n                        as: as[i]\n                    });\n                }\n            }\n            if (bin.formula) {\n                transform.push({\n                    type: 'formula',\n                    expr: bin.formula,\n                    as: bin.formulaAs\n                });\n            }\n            return transform;\n        });\n    }\n}\n//# sourceMappingURL=bin.js.map"]},"metadata":{},"sourceType":"module"}