{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport isSomeObservable from \"is-observable\";\nimport { deserialize, serialize } from \"../common\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nimport Implementation from \"./implementation\";\nexport { registerSerializer } from \"../common\";\nexport { Transfer } from \"../transferable\";\n/** Returns `true` if this code is currently running in a worker. */\n\nexport const isWorkerRuntime = Implementation.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\n\nconst isMasterJobCancelMessage = thing => thing && thing.type === MasterMessageType.cancel;\n\nconst isMasterJobRunMessage = thing => thing && thing.type === MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\n\n\nconst isObservable = thing => isSomeObservable(thing) || isZenObservable(thing);\n\nfunction isZenObservable(thing) {\n  return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\n\nfunction deconstructTransfer(thing) {\n  return isTransferDescriptor(thing) ? {\n    payload: thing.send,\n    transferables: thing.transferables\n  } : {\n    payload: thing,\n    transferables: undefined\n  };\n}\n\nfunction postFunctionInitMessage() {\n  const initMessage = {\n    type: WorkerMessageType.init,\n    exposed: {\n      type: \"function\"\n    }\n  };\n  Implementation.postMessageToMaster(initMessage);\n}\n\nfunction postModuleInitMessage(methodNames) {\n  const initMessage = {\n    type: WorkerMessageType.init,\n    exposed: {\n      type: \"module\",\n      methods: methodNames\n    }\n  };\n  Implementation.postMessageToMaster(initMessage);\n}\n\nfunction postJobErrorMessage(uid, rawError) {\n  const {\n    payload: error,\n    transferables\n  } = deconstructTransfer(rawError);\n  const errorMessage = {\n    type: WorkerMessageType.error,\n    uid,\n    error: serialize(error)\n  };\n  Implementation.postMessageToMaster(errorMessage, transferables);\n}\n\nfunction postJobResultMessage(uid, completed, resultValue) {\n  const {\n    payload,\n    transferables\n  } = deconstructTransfer(resultValue);\n  const resultMessage = {\n    type: WorkerMessageType.result,\n    uid,\n    complete: completed ? true : undefined,\n    payload\n  };\n  Implementation.postMessageToMaster(resultMessage, transferables);\n}\n\nfunction postJobStartMessage(uid, resultType) {\n  const startMessage = {\n    type: WorkerMessageType.running,\n    uid,\n    resultType\n  };\n  Implementation.postMessageToMaster(startMessage);\n}\n\nfunction postUncaughtErrorMessage(error) {\n  try {\n    const errorMessage = {\n      type: WorkerMessageType.uncaughtError,\n      error: serialize(error)\n    };\n    Implementation.postMessageToMaster(errorMessage);\n  } catch (subError) {\n    // tslint:disable-next-line no-console\n    console.error(\"Not reporting uncaught error back to master thread as it \" + \"occured while reporting an uncaught error already.\" + \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n  }\n}\n\nfunction runFunction(jobUID, fn, args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let syncResult;\n\n    try {\n      syncResult = fn(...args);\n    } catch (error) {\n      return postJobErrorMessage(jobUID, error);\n    }\n\n    const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n    postJobStartMessage(jobUID, resultType);\n\n    if (isObservable(syncResult)) {\n      const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, serialize(value)), error => {\n        postJobErrorMessage(jobUID, serialize(error));\n        activeSubscriptions.delete(jobUID);\n      }, () => {\n        postJobResultMessage(jobUID, true);\n        activeSubscriptions.delete(jobUID);\n      });\n      activeSubscriptions.set(jobUID, subscription);\n    } else {\n      try {\n        const result = yield syncResult;\n        postJobResultMessage(jobUID, true, serialize(result));\n      } catch (error) {\n        postJobErrorMessage(jobUID, serialize(error));\n      }\n    }\n  });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\n\n\nexport function expose(exposed) {\n  if (!Implementation.isWorkerRuntime()) {\n    throw Error(\"expose() called in the master thread.\");\n  }\n\n  if (exposeCalled) {\n    throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n  }\n\n  exposeCalled = true;\n\n  if (typeof exposed === \"function\") {\n    Implementation.subscribeToMasterMessages(messageData => {\n      if (isMasterJobRunMessage(messageData) && !messageData.method) {\n        runFunction(messageData.uid, exposed, messageData.args.map(deserialize));\n      }\n    });\n    postFunctionInitMessage();\n  } else if (typeof exposed === \"object\" && exposed) {\n    Implementation.subscribeToMasterMessages(messageData => {\n      if (isMasterJobRunMessage(messageData) && messageData.method) {\n        runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(deserialize));\n      }\n    });\n    const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n    postModuleInitMessage(methodNames);\n  } else {\n    throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n  }\n\n  Implementation.subscribeToMasterMessages(messageData => {\n    if (isMasterJobCancelMessage(messageData)) {\n      const jobUID = messageData.uid;\n      const subscription = activeSubscriptions.get(jobUID);\n\n      if (subscription) {\n        subscription.unsubscribe();\n        activeSubscriptions.delete(jobUID);\n      }\n    }\n  });\n}\n\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && Implementation.isWorkerRuntime()) {\n  self.addEventListener(\"error\", event => {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n  });\n  self.addEventListener(\"unhandledrejection\", event => {\n    const error = event.reason;\n\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(() => postUncaughtErrorMessage(error), 250);\n    }\n  });\n}\n\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && Implementation.isWorkerRuntime()) {\n  process.on(\"uncaughtException\", error => {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(() => postUncaughtErrorMessage(error), 250);\n  });\n  process.on(\"unhandledRejection\", error => {\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(() => postUncaughtErrorMessage(error), 250);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/worker/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","isSomeObservable","deserialize","serialize","isTransferDescriptor","MasterMessageType","WorkerMessageType","Implementation","registerSerializer","Transfer","isWorkerRuntime","exposeCalled","activeSubscriptions","Map","isMasterJobCancelMessage","thing","type","cancel","isMasterJobRunMessage","run","isObservable","isZenObservable","subscribe","deconstructTransfer","payload","send","transferables","undefined","postFunctionInitMessage","initMessage","init","exposed","postMessageToMaster","postModuleInitMessage","methodNames","methods","postJobErrorMessage","uid","rawError","error","errorMessage","postJobResultMessage","completed","resultValue","resultMessage","complete","postJobStartMessage","resultType","startMessage","running","postUncaughtErrorMessage","uncaughtError","subError","console","runFunction","jobUID","fn","args","syncResult","subscription","delete","set","expose","Error","subscribeToMasterMessages","messageData","method","map","Object","keys","filter","key","get","unsubscribe","self","addEventListener","event","setTimeout","reason","message","process","on"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport isSomeObservable from \"is-observable\";\nimport { deserialize, serialize } from \"../common\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nimport Implementation from \"./implementation\";\nexport { registerSerializer } from \"../common\";\nexport { Transfer } from \"../transferable\";\n/** Returns `true` if this code is currently running in a worker. */\nexport const isWorkerRuntime = Implementation.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\nconst isMasterJobCancelMessage = (thing) => thing && thing.type === MasterMessageType.cancel;\nconst isMasterJobRunMessage = (thing) => thing && thing.type === MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\nconst isObservable = (thing) => isSomeObservable(thing) || isZenObservable(thing);\nfunction isZenObservable(thing) {\n    return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\nfunction deconstructTransfer(thing) {\n    return isTransferDescriptor(thing)\n        ? { payload: thing.send, transferables: thing.transferables }\n        : { payload: thing, transferables: undefined };\n}\nfunction postFunctionInitMessage() {\n    const initMessage = {\n        type: WorkerMessageType.init,\n        exposed: {\n            type: \"function\"\n        }\n    };\n    Implementation.postMessageToMaster(initMessage);\n}\nfunction postModuleInitMessage(methodNames) {\n    const initMessage = {\n        type: WorkerMessageType.init,\n        exposed: {\n            type: \"module\",\n            methods: methodNames\n        }\n    };\n    Implementation.postMessageToMaster(initMessage);\n}\nfunction postJobErrorMessage(uid, rawError) {\n    const { payload: error, transferables } = deconstructTransfer(rawError);\n    const errorMessage = {\n        type: WorkerMessageType.error,\n        uid,\n        error: serialize(error)\n    };\n    Implementation.postMessageToMaster(errorMessage, transferables);\n}\nfunction postJobResultMessage(uid, completed, resultValue) {\n    const { payload, transferables } = deconstructTransfer(resultValue);\n    const resultMessage = {\n        type: WorkerMessageType.result,\n        uid,\n        complete: completed ? true : undefined,\n        payload\n    };\n    Implementation.postMessageToMaster(resultMessage, transferables);\n}\nfunction postJobStartMessage(uid, resultType) {\n    const startMessage = {\n        type: WorkerMessageType.running,\n        uid,\n        resultType\n    };\n    Implementation.postMessageToMaster(startMessage);\n}\nfunction postUncaughtErrorMessage(error) {\n    try {\n        const errorMessage = {\n            type: WorkerMessageType.uncaughtError,\n            error: serialize(error)\n        };\n        Implementation.postMessageToMaster(errorMessage);\n    }\n    catch (subError) {\n        // tslint:disable-next-line no-console\n        console.error(\"Not reporting uncaught error back to master thread as it \" +\n            \"occured while reporting an uncaught error already.\" +\n            \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n    }\n}\nfunction runFunction(jobUID, fn, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let syncResult;\n        try {\n            syncResult = fn(...args);\n        }\n        catch (error) {\n            return postJobErrorMessage(jobUID, error);\n        }\n        const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n        postJobStartMessage(jobUID, resultType);\n        if (isObservable(syncResult)) {\n            const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, serialize(value)), error => {\n                postJobErrorMessage(jobUID, serialize(error));\n                activeSubscriptions.delete(jobUID);\n            }, () => {\n                postJobResultMessage(jobUID, true);\n                activeSubscriptions.delete(jobUID);\n            });\n            activeSubscriptions.set(jobUID, subscription);\n        }\n        else {\n            try {\n                const result = yield syncResult;\n                postJobResultMessage(jobUID, true, serialize(result));\n            }\n            catch (error) {\n                postJobErrorMessage(jobUID, serialize(error));\n            }\n        }\n    });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\nexport function expose(exposed) {\n    if (!Implementation.isWorkerRuntime()) {\n        throw Error(\"expose() called in the master thread.\");\n    }\n    if (exposeCalled) {\n        throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n    }\n    exposeCalled = true;\n    if (typeof exposed === \"function\") {\n        Implementation.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && !messageData.method) {\n                runFunction(messageData.uid, exposed, messageData.args.map(deserialize));\n            }\n        });\n        postFunctionInitMessage();\n    }\n    else if (typeof exposed === \"object\" && exposed) {\n        Implementation.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && messageData.method) {\n                runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(deserialize));\n            }\n        });\n        const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n        postModuleInitMessage(methodNames);\n    }\n    else {\n        throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n    }\n    Implementation.subscribeToMasterMessages(messageData => {\n        if (isMasterJobCancelMessage(messageData)) {\n            const jobUID = messageData.uid;\n            const subscription = activeSubscriptions.get(jobUID);\n            if (subscription) {\n                subscription.unsubscribe();\n                activeSubscriptions.delete(jobUID);\n            }\n        }\n    });\n}\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && Implementation.isWorkerRuntime()) {\n    self.addEventListener(\"error\", event => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n    });\n    self.addEventListener(\"unhandledrejection\", event => {\n        const error = event.reason;\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && Implementation.isWorkerRuntime()) {\n    process.on(\"uncaughtException\", (error) => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(error), 250);\n    });\n    process.on(\"unhandledRejection\", (error) => {\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\n"]},"metadata":{},"sourceType":"module"}