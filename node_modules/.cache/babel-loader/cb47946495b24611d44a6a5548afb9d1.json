{"ast":null,"code":"import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import{OrthographicView}from'deck.gl';import clamp from'lodash/clamp';// Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\n// Reference: https://observablehq.com/@bmschmidt/dot-density-election-maps-with-webgl\nexport function getPointSizeDevicePixels(devicePixelRatio,zoom,xRange,yRange,width,height){// Size of a point, in units of the diagonal axis.\nvar pointSize=0.001;// Point size maximum, in screen pixels.\nvar pointScreenSizeMax=10;// Point size minimum, in screen pixels.\nvar pointScreenSizeMin=1/devicePixelRatio;var scaleFactor=Math.pow(2,zoom);var xAxisRange=2.0/(xRange*scaleFactor/width);var yAxisRange=2.0/(yRange*scaleFactor/height);// The diagonal screen size as a fraction of the current diagonal axis range,\n// then converted to device pixels.\nvar diagonalScreenSize=Math.sqrt(Math.pow(width,2)+Math.pow(height,2));var diagonalAxisRange=Math.sqrt(Math.pow(xAxisRange,2)+Math.pow(yAxisRange,2));var diagonalFraction=pointSize/diagonalAxisRange;var deviceSize=diagonalFraction*diagonalScreenSize;var pointSizeDevicePixels=clamp(deviceSize,pointScreenSizeMin,pointScreenSizeMax);return pointSizeDevicePixels;}// Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\nexport function getPointOpacity(zoom,xRange,yRange,width,height,numCells,avgFillDensity){var N=numCells;var _OrthographicView$mak=new OrthographicView({zoom:zoom}).makeViewport({height:height,width:width,viewState:{zoom:zoom,target:[0,0,0]}}).getBounds(),_OrthographicView$mak2=_slicedToArray(_OrthographicView$mak,4),minX=_OrthographicView$mak2[0],minY=_OrthographicView$mak2[1],maxX=_OrthographicView$mak2[2],maxY=_OrthographicView$mak2[3];var X=maxY-minY;var Y=maxX-minX;var X0=xRange;var Y0=yRange;var W=width;var H=height;var rho=avgFillDensity;if(!rho){rho=Math.min(1,1/Math.pow(10,Math.log10(N)-3));}// p in the calculation is the pixel length/width of a given point, which for us is 1\n// so it does not factor into our calculation here.\nvar alpha=rho*W*H/N*(Y0/Y)*(X0/X);var pointOpacity=clamp(alpha,1.01/255,1.0);return pointOpacity;}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/shared-spatial-scatterplot/dynamic-opacity.js"],"names":["OrthographicView","clamp","getPointSizeDevicePixels","devicePixelRatio","zoom","xRange","yRange","width","height","pointSize","pointScreenSizeMax","pointScreenSizeMin","scaleFactor","xAxisRange","yAxisRange","diagonalScreenSize","Math","sqrt","diagonalAxisRange","diagonalFraction","deviceSize","pointSizeDevicePixels","getPointOpacity","numCells","avgFillDensity","N","makeViewport","viewState","target","getBounds","minX","minY","maxX","maxY","X","Y","X0","Y0","W","H","rho","min","log10","alpha","pointOpacity"],"mappings":"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","sourcesContent":["import { OrthographicView } from 'deck.gl';\nimport clamp from 'lodash/clamp';\n\n// Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\n// Reference: https://observablehq.com/@bmschmidt/dot-density-election-maps-with-webgl\nexport function getPointSizeDevicePixels(devicePixelRatio, zoom, xRange, yRange, width, height) {\n  // Size of a point, in units of the diagonal axis.\n  const pointSize = 0.001;\n  // Point size maximum, in screen pixels.\n  const pointScreenSizeMax = 10;\n\n  // Point size minimum, in screen pixels.\n  const pointScreenSizeMin = 1 / devicePixelRatio;\n\n  const scaleFactor = 2 ** zoom;\n  const xAxisRange = 2.0 / ((xRange * scaleFactor) / width);\n  const yAxisRange = 2.0 / ((yRange * scaleFactor) / height);\n\n  // The diagonal screen size as a fraction of the current diagonal axis range,\n  // then converted to device pixels.\n  const diagonalScreenSize = Math.sqrt((width ** 2) + (height ** 2));\n  const diagonalAxisRange = Math.sqrt((xAxisRange ** 2) + (yAxisRange ** 2));\n  const diagonalFraction = pointSize / diagonalAxisRange;\n  const deviceSize = diagonalFraction * diagonalScreenSize;\n\n  const pointSizeDevicePixels = clamp(\n    deviceSize,\n    pointScreenSizeMin,\n    pointScreenSizeMax,\n  );\n  return pointSizeDevicePixels;\n}\n\n// Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\nexport function getPointOpacity(zoom, xRange, yRange, width, height, numCells, avgFillDensity) {\n  const N = numCells;\n  const [minX, minY, maxX, maxY] = new OrthographicView({ zoom }).makeViewport({\n    height,\n    width,\n    viewState: { zoom, target: [0, 0, 0] },\n  }).getBounds();\n  const X = maxY - minY;\n  const Y = maxX - minX;\n  const X0 = xRange;\n  const Y0 = yRange;\n  const W = width;\n  const H = height;\n\n  let rho = avgFillDensity;\n  if (!rho) {\n    rho = Math.min(1, 1 / (10 ** (Math.log10(N) - 3)));\n  }\n  // p in the calculation is the pixel length/width of a given point, which for us is 1\n  // so it does not factor into our calculation here.\n  const alpha = ((rho * W * H) / N) * (Y0 / Y) * (X0 / X);\n  const pointOpacity = clamp(alpha, 1.01 / 255, 1.0);\n  return pointOpacity;\n}\n"]},"metadata":{},"sourceType":"module"}