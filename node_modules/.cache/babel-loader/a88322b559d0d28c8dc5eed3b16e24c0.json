{"ast":null,"code":"import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, isContinuous, Sequential, Linear, Time, UTC, Pow, Sqrt, Ordinal, scaleImplicit, Log, Symlog, isLogarithmic, BinOrdinal, bandSpace, isInterpolating, interpolateRange, quantizeInterpolator, interpolateColors, interpolate, Band, Point, scheme, Threshold, Quantile, Quantize, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(AxisTicks, Transform, {\n  transform: function transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        ticks = this.value,\n        scale = _.scale,\n        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n        count = tickCount(scale, tally, _.minstep),\n        format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n        values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map(function (value, i) {\n      return ingest({\n        index: i / (values.length - 1 || 1),\n        value: value,\n        label: format(value)\n      });\n    });\n\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n});\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\n\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\n\nfunction defaultItemCreate() {\n  return ingest({});\n}\n\nfunction newMap(key) {\n  var map = fastmap().test(function (t) {\n    return t.exit;\n  });\n\n  map.lookup = function (t) {\n    return map.get(key(t));\n  };\n\n  return map;\n}\n\ninherits(DataJoin, Transform, {\n  transform: function transform(_, pulse) {\n    var df = pulse.dataflow,\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        item = _.item || defaultItemCreate,\n        key = _.key || tupleid,\n        map = this.value; // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n\n    pulse.visit(pulse.ADD, function (t) {\n      var k = key(t);\n      var x = map.get(k);\n\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, function (t) {\n      var k = key(t),\n          x = map.get(k);\n\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, function (t) {\n      var k = key(t),\n          x = map.get(k);\n\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n\n    return out;\n  }\n});\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\n\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Encode, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n        fmod = _.mod || false,\n        encoders = _.encoders,\n        encode = pulse.encode; // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(function (e) {\n        return encoders[e];\n      })) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    } // marshall encoder functions\n\n\n    var reenter = encode === 'enter',\n        update = encoders.update || falsy,\n        enter = encoders.enter || falsy,\n        exit = encoders.exit || falsy,\n        set = (encode && !reenter ? encoders[encode] : update) || falsy;\n\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, function (t) {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, function (t) {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, function (t) {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n\n    if (reenter || set !== falsy) {\n      var flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n\n      if (reenter) {\n        pulse.visit(flag, function (t) {\n          var mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, function (t) {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n\n      if (out.mod.length) out.modifies(set.output);\n    }\n\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n});\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\n\ninherits(LegendEntries, Transform, {\n  transform: function transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        items = this.value,\n        type = _.type || SymbolLegend,\n        scale = _.scale,\n        limit = +_.limit,\n        count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n        lskip = !!_.values || type === SymbolLegend,\n        format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n        values = _.values || labelValues(scale, count),\n        domain,\n        fraction,\n        size,\n        offset,\n        ellipsis;\n    if (items) out.rem = items;\n\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        } // compute size offset for legend entries\n\n\n        offset = items.reduce(function (max, value) {\n          return Math.max(max, size(value, _));\n        }, 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n\n      items = items.map(function (value, index) {\n        return ingest({\n          index: index,\n          label: format(value, index, items),\n          value: value,\n          offset: offset,\n          size: size(value, _)\n        });\n      });\n\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: \"\\u2026\".concat(values.length - items.length, \" entries\"),\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n\n      items = values.map(function (value, index) {\n        return ingest({\n          index: index,\n          label: format(value, index, values),\n          value: value,\n          perc: fraction(value)\n        });\n      });\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map(function (value, index) {\n        return ingest({\n          index: index,\n          label: format(value, index, values),\n          value: value,\n          perc: index ? fraction(value) : 0,\n          perc2: index === size ? 1 : fraction(values[index + 1])\n        });\n      });\n    }\n\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n});\n\nvar sourceX = function sourceX(t) {\n  return t.source.x;\n};\n\nvar sourceY = function sourceY(t) {\n  return t.source.y;\n};\n\nvar targetX = function targetX(t) {\n  return t.target.x;\n};\n\nvar targetY = function targetY(t) {\n  return t.target.y;\n};\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\n\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform: function transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n        sy = _.sourceY || sourceY,\n        tx = _.targetX || targetX,\n        ty = _.targetY || targetY,\n        as = _.as || 'path',\n        orient = _.orient || 'vertical',\n        shape = _.shape || 'line',\n        path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n\n    pulse.visit(pulse.SOURCE, function (t) {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\n\nvar line = function line(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\n};\n\nvar lineR = function lineR(sa, sr, ta, tr) {\n  return line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n};\n\nvar arc = function arc(sx, sy, tx, ty) {\n  var dx = tx - sx,\n      dy = ty - sy,\n      rr = Math.sqrt(dx * dx + dy * dy) / 2,\n      ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\n\nvar arcR = function arcR(sa, sr, ta, tr) {\n  return arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n};\n\nvar curve = function curve(sx, sy, tx, ty) {\n  var dx = tx - sx,\n      dy = ty - sy,\n      ix = 0.2 * (dx + dy),\n      iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\n\nvar curveR = function curveR(sa, sr, ta, tr) {\n  return curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n};\n\nvar orthoX = function orthoX(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\n};\n\nvar orthoY = function orthoY(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\n};\n\nvar orthoR = function orthoR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\n\nvar diagonalX = function diagonalX(sx, sy, tx, ty) {\n  var m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\n\nvar diagonalY = function diagonalY(sx, sy, tx, ty) {\n  var m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\n\nvar diagonalR = function diagonalR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\n\nvar Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2Ï€] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\n\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\n\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform: function transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n        startAngle = as[0],\n        endAngle = as[1],\n        field = _.field || one,\n        start = _.startAngle || 0,\n        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n        data = pulse.source,\n        values = data.map(field),\n        n = values.length,\n        a = start,\n        k = (stop - start) / sum(values),\n        index = range(n),\n        i,\n        t,\n        v;\n\n    if (_.sort) {\n      index.sort(function (a, b) {\n        return values[a] - values[b];\n      });\n    }\n\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nvar DEFAULT_COUNT = 5;\n\nfunction includeZero(scale) {\n  var type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\n\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\n\nvar SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\ninherits(Scale, Transform, {\n  transform: function transform(_, pulse) {\n    var df = pulse.dataflow,\n        scale$1 = this.value,\n        key = scaleKey(_);\n\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n\n    for (key in _) {\n      if (!SKIP[key]) {\n        // padding is a scale property for band/point but not others\n        if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found\n\n        isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n      }\n    }\n\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n});\n\nfunction scaleKey(_) {\n  var t = _.type,\n      d = '',\n      n; // backwards compatibility pre Vega 5.\n\n  if (t === Sequential) return Sequential + '-' + Linear;\n\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n\n  return (d + t || Linear).toLowerCase();\n}\n\nfunction isContinuousColor(_) {\n  var t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\n\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  var raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n      type = scale.type,\n      zero = _.zero || _.zero === undefined && includeZero(scale),\n      n,\n      mid;\n  if (!domain) return 0; // adjust continuous domain for minimum pixel padding\n\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  } // adjust domain based on zero, min, max settings\n\n\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      var i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  } // set the scale domain\n\n\n  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  } // perform 'nice' adjustment as requested\n\n\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  } // return the cardinality of the domain\n\n\n  return domain.length;\n}\n\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\n\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n      frac = span / (span - 2 * pad),\n      d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\n\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce(function (s, v) {\n      return s + (v < 0 ? -1 : v > 0 ? 1 : 0);\n    }, 0));\n\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n\n  return domain;\n}\n\nfunction configureBins(scale, _, count) {\n  var bins = _.bins;\n\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    var domain = scale.domain(),\n        lo = domain[0],\n        hi = peek(domain),\n        step = bins.step;\n    var start = bins.start == null ? lo : bins.start,\n        stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  } // special handling for bin-ordinal scales\n\n\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  } // return domain cardinality\n\n\n  return count;\n}\n\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n      round = _.round || false,\n      range = _.range; // if range step specified, calculate full range extent\n\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  } // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(type, _, count);\n\n    if (isFunction(range)) {\n      if (scale.interpolator) {\n        return scale.interpolator(range);\n      } else {\n        error(\"Scale type \".concat(type, \" does not support interpolating color schemes.\"));\n      }\n    }\n  } // given a range array for an interpolating scale, convert to interpolator\n\n\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  } // configure rounding / interpolation\n\n\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n\n  if (range) scale.range(flip(range, _.reverse));\n}\n\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  } // calculate full range based on requested step size and padding\n\n\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n      inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\n\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n      name,\n      scheme$1;\n\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(\"Unrecognized scheme name: \".concat(_.scheme));\n  } // determine size for potential discrete range\n\n\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate\n\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\n\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\n\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\n\n\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(SortItems, Transform, {\n  transform: function transform(_, pulse) {\n    var mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n});\nvar Zero = 'zero',\n    Center = 'center',\n    Normalize = 'normalize',\n    DefOutput = ['y0', 'y1'];\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\n\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\n\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform: function transform(_, pulse) {\n    var as = _.as || DefOutput,\n        y0 = as[0],\n        y1 = as[1],\n        sort = stableCompare(_.sort),\n        field = _.field || one,\n        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n        groups,\n        i,\n        n,\n        max; // partition, sum, and sort the stack groups\n\n    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group\n\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\n\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n      m = group.length,\n      j = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\n\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n      last = 0,\n      m = group.length,\n      j = 0,\n      v = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\n\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n      lastNeg = 0,\n      m = group.length,\n      j = 0,\n      v,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\n\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n      get = function get(f) {\n    return f(t);\n  },\n      map,\n      i,\n      n,\n      m,\n      t,\n      k,\n      g,\n      s,\n      max; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  } // compute sums of groups, sort groups as needed\n\n\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n\n  groups.max = max;\n  return groups;\n}\n\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-encode/build/vega-encode.module.js"],"names":["Transform","ingest","tupleid","stableCompare","tickCount","tickFormat","validTicks","tickValues","SymbolLegend","labelFormat","labelValues","GradientLegend","scaleFraction","labelFraction","scale","isContinuous","Sequential","Linear","Time","UTC","Pow","Sqrt","Ordinal","scaleImplicit","Log","Symlog","isLogarithmic","BinOrdinal","bandSpace","isInterpolating","interpolateRange","quantizeInterpolator","interpolateColors","interpolate","Band","Point","scheme","Threshold","Quantile","Quantize","Diverging","inherits","isArray","error","fastmap","falsy","isFunction","constant","peek","one","toSet","isString","zoomLog","zoomPow","zoomSymlog","zoomLinear","stringValue","sum","range","interpolateRound","interpolate$1","AxisTicks","params","call","transform","_","pulse","value","modified","StopPropagation","locale","dataflow","out","fork","NO_SOURCE","NO_FIELDS","ticks","tally","count","values","length","minstep","format","formatSpecifier","formatType","rem","map","i","index","label","extra","push","source","add","DataJoin","defaultItemCreate","newMap","key","test","t","exit","lookup","get","df","item","encode","addAll","visit","ADD","k","x","empty","mod","set","datum","MOD","REM","changed","ADD_MOD","modifies","clean","cleanThreshold","runAfter","Encode","ADD_REM","fmod","encoders","every","e","reenter","update","enter","output","flag","REFLOW","LegendEntries","items","type","limit","lskip","domain","fraction","size","offset","ellipsis","warn","slice","reduce","max","Math","concat","perc","perc2","sourceX","sourceY","y","targetX","target","targetY","LinkPath","Definition","sx","sy","tx","ty","as","orient","shape","path","Paths","SOURCE","reflow","line","lineR","sa","sr","ta","tr","cos","sin","arc","dx","dy","rr","sqrt","ra","atan2","PI","arcR","curve","ix","iy","curveR","orthoX","orthoY","orthoR","sc","ss","tc","ts","sf","abs","diagonalX","m","diagonalY","diagonalR","mr","Pie","startAngle","endAngle","field","start","stop","data","n","a","v","sort","b","DEFAULT_COUNT","includeZero","bins","includePad","SKIP","Scale","scale$1","scaleKey","configureRange","configureBins","configureDomain","d","isContinuousColor","rawDomain","domainMid","toLowerCase","raw","domainRaw","zero","undefined","mid","padding","padDomain","exponent","domainMin","domainMax","splice","domainCheck","unknown","domainImplicit","nice","pad","span","frac","s","lo","hi","step","ceil","floor","round","rangeStep","configureRangeStep","configureScheme","interpolator","flip","reverse","interpolateGamma","rangeRound","outer","paddingOuter","inner","paddingInner","extent","schemeExtent","name","scheme$1","schemeCount","adjustScheme","array","SortItems","fields","Zero","Center","Normalize","DefOutput","Stack","y0","y1","stack","stackCenter","stackNormalize","stackZero","groups","partition","groupby","group","last","j","lastPos","lastNeg","f","g","axisticks","datajoin","legendentries","linkpath","pie","sortitems"],"mappings":"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","sourcesContent":["import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, isContinuous, Sequential, Linear, Time, UTC, Pow, Sqrt, Ordinal, scaleImplicit, Log, Symlog, isLogarithmic, BinOrdinal, bandSpace, isInterpolating, interpolateRange, quantizeInterpolator, interpolateColors, interpolate, Band, Point, scheme, Threshold, Quantile, Quantize, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\ninherits(AxisTicks, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        ticks = this.value,\n        scale = _.scale,\n        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n        count = tickCount(scale, tally, _.minstep),\n        format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n        values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map((value, i) => ingest({\n      index: i / (values.length - 1 || 1),\n      value: value,\n      label: format(value)\n    }));\n\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n\n});\n\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\n\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\n\nfunction defaultItemCreate() {\n  return ingest({});\n}\n\nfunction newMap(key) {\n  const map = fastmap().test(t => t.exit);\n\n  map.lookup = t => map.get(key(t));\n\n  return map;\n}\n\ninherits(DataJoin, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        item = _.item || defaultItemCreate,\n        key = _.key || tupleid,\n        map = this.value; // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      let x = map.get(k);\n\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n\n    return out;\n  }\n\n});\n\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\n\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\ninherits(Encode, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n        fmod = _.mod || false,\n        encoders = _.encoders,\n        encode = pulse.encode; // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(e => encoders[e])) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    } // marshall encoder functions\n\n\n    var reenter = encode === 'enter',\n        update = encoders.update || falsy,\n        enter = encoders.enter || falsy,\n        exit = encoders.exit || falsy,\n        set = (encode && !reenter ? encoders[encode] : update) || falsy;\n\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, t => {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, t => {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, t => {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n\n    if (reenter || set !== falsy) {\n      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n\n      if (reenter) {\n        pulse.visit(flag, t => {\n          const mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, t => {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n\n      if (out.mod.length) out.modifies(set.output);\n    }\n\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n\n});\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\ninherits(LegendEntries, Transform, {\n  transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        items = this.value,\n        type = _.type || SymbolLegend,\n        scale = _.scale,\n        limit = +_.limit,\n        count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n        lskip = !!_.values || type === SymbolLegend,\n        format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n        values = _.values || labelValues(scale, count),\n        domain,\n        fraction,\n        size,\n        offset,\n        ellipsis;\n    if (items) out.rem = items;\n\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        } // compute size offset for legend entries\n\n\n        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n\n      items = items.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      }));\n\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: \"\\u2026\".concat(values.length - items.length, \" entries\"),\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      }));\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      }));\n    }\n\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n\n});\n\nconst sourceX = t => t.source.x;\n\nconst sourceY = t => t.source.y;\n\nconst targetX = t => t.target.x;\n\nconst targetY = t => t.target.y;\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n        sy = _.sourceY || sourceY,\n        tx = _.targetX || targetX,\n        ty = _.targetY || targetY,\n        as = _.as || 'path',\n        orient = _.orient || 'vertical',\n        shape = _.shape || 'line',\n        path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n\n    pulse.visit(pulse.SOURCE, t => {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nconst line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\n\nconst lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst arc = (sx, sy, tx, ty) => {\n  var dx = tx - sx,\n      dy = ty - sy,\n      rr = Math.sqrt(dx * dx + dy * dy) / 2,\n      ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\n\nconst arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst curve = (sx, sy, tx, ty) => {\n  const dx = tx - sx,\n        dy = ty - sy,\n        ix = 0.2 * (dx + dy),\n        iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\n\nconst curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\n\nconst orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\n\nconst orthoR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\n\nconst diagonalX = (sx, sy, tx, ty) => {\n  const m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\n\nconst diagonalY = (sx, sy, tx, ty) => {\n  const m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\n\nconst diagonalR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\n\nconst Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2Ï€] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\n\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n        startAngle = as[0],\n        endAngle = as[1],\n        field = _.field || one,\n        start = _.startAngle || 0,\n        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n        data = pulse.source,\n        values = data.map(field),\n        n = values.length,\n        a = start,\n        k = (stop - start) / sum(values),\n        index = range(n),\n        i,\n        t,\n        v;\n\n    if (_.sort) {\n      index.sort((a, b) => values[a] - values[b]);\n    }\n\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nconst DEFAULT_COUNT = 5;\n\nfunction includeZero(scale) {\n  const type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\n\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\n\nconst SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Scale, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        scale$1 = this.value,\n        key = scaleKey(_);\n\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n\n    for (key in _) if (!SKIP[key]) {\n      // padding is a scale property for band/point but not others\n      if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found\n\n      isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n    }\n\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n\n});\n\nfunction scaleKey(_) {\n  var t = _.type,\n      d = '',\n      n; // backwards compatibility pre Vega 5.\n\n  if (t === Sequential) return Sequential + '-' + Linear;\n\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n\n  return (d + t || Linear).toLowerCase();\n}\n\nfunction isContinuousColor(_) {\n  const t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\n\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  const raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n      type = scale.type,\n      zero = _.zero || _.zero === undefined && includeZero(scale),\n      n,\n      mid;\n  if (!domain) return 0; // adjust continuous domain for minimum pixel padding\n\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  } // adjust domain based on zero, min, max settings\n\n\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  } // set the scale domain\n\n\n  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  } // perform 'nice' adjustment as requested\n\n\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  } // return the cardinality of the domain\n\n\n  return domain.length;\n}\n\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\n\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n      frac = span / (span - 2 * pad),\n      d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\n\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\n\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n\n  return domain;\n}\n\nfunction configureBins(scale, _, count) {\n  let bins = _.bins;\n\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    const domain = scale.domain(),\n          lo = domain[0],\n          hi = peek(domain),\n          step = bins.step;\n    let start = bins.start == null ? lo : bins.start,\n        stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  } // special handling for bin-ordinal scales\n\n\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  } // return domain cardinality\n\n\n  return count;\n}\n\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n      round = _.round || false,\n      range = _.range; // if range step specified, calculate full range extent\n\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  } // else if a range scheme is defined, use that\n  else if (_.scheme) {\n      range = configureScheme(type, _, count);\n\n      if (isFunction(range)) {\n        if (scale.interpolator) {\n          return scale.interpolator(range);\n        } else {\n          error(\"Scale type \".concat(type, \" does not support interpolating color schemes.\"));\n        }\n      }\n    } // given a range array for an interpolating scale, convert to interpolator\n\n\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  } // configure rounding / interpolation\n\n\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n\n  if (range) scale.range(flip(range, _.reverse));\n}\n\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  } // calculate full range based on requested step size and padding\n\n\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n      inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\n\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n      name,\n      scheme$1;\n\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(\"Unrecognized scheme name: \".concat(_.scheme));\n  } // determine size for potential discrete range\n\n\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate\n\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\n\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\n\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\n\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\ninherits(SortItems, Transform, {\n  transform(_, pulse) {\n    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n\n});\n\nconst Zero = 'zero',\n      Center = 'center',\n      Normalize = 'normalize',\n      DefOutput = ['y0', 'y1'];\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\n\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform(_, pulse) {\n    var as = _.as || DefOutput,\n        y0 = as[0],\n        y1 = as[1],\n        sort = stableCompare(_.sort),\n        field = _.field || one,\n        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n        groups,\n        i,\n        n,\n        max; // partition, sum, and sort the stack groups\n\n    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group\n\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n      m = group.length,\n      j = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\n\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n      last = 0,\n      m = group.length,\n      j = 0,\n      v = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\n\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n      lastNeg = 0,\n      m = group.length,\n      j = 0,\n      v,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\n\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      m,\n      t,\n      k,\n      g,\n      s,\n      max; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  } // compute sums of groups, sort groups as needed\n\n\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n\n  groups.max = max;\n  return groups;\n}\n\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };\n"]},"metadata":{},"sourceType":"module"}