{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\n\nvar Tesselator = /*#__PURE__*/function () {\n  function Tesselator() {\n    _classCallCheck(this, Tesselator);\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _opts$attributes = opts.attributes,\n        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  _createClass(Tesselator, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      Object.assign(this.opts, opts);\n      var _this$opts = this.opts,\n          data = _this$opts.data,\n          _this$opts$buffers = _this$opts.buffers,\n          buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers,\n          getGeometry = _this$opts.getGeometry,\n          geometryBuffer = _this$opts.geometryBuffer,\n          positionFormat = _this$opts.positionFormat,\n          dataChanged = _this$opts.dataChanged,\n          _this$opts$normalize = _this$opts.normalize,\n          normalize = _this$opts$normalize === void 0 ? true : _this$opts$normalize;\n      this.data = data;\n      this.getGeometry = getGeometry;\n      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n      this.buffers = buffers;\n      this.normalize = normalize;\n\n      if (geometryBuffer) {\n        assert(data.startIndices);\n        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n        if (!normalize) {\n          buffers.positions = geometryBuffer;\n        }\n      }\n\n      this.geometryBuffer = buffers.positions;\n\n      if (Array.isArray(dataChanged)) {\n        var _iterator = _createForOfIteratorHelper(dataChanged),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dataRange = _step.value;\n\n            this._rebuildGeometry(dataRange);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        this._rebuildGeometry();\n      }\n    }\n  }, {\n    key: \"updatePartialGeometry\",\n    value: function updatePartialGeometry(_ref) {\n      var startRow = _ref.startRow,\n          endRow = _ref.endRow;\n\n      this._rebuildGeometry({\n        startRow: startRow,\n        endRow: endRow\n      });\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(geometry) {\n      return geometry;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(geometry, startIndex, size) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(geometry) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(geometryBuffer) {\n      var value = geometryBuffer.value || geometryBuffer;\n      assert(ArrayBuffer.isView(value));\n      return getAccessorFromBuffer(value, {\n        size: this.positionSize,\n        offset: geometryBuffer.offset,\n        stride: geometryBuffer.stride,\n        startIndices: this.data.startIndices\n      });\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(instanceCount, copy) {\n      var attributes = this.attributes,\n          buffers = this.buffers,\n          _attributeDefs = this._attributeDefs,\n          typedArrayManager = this.typedArrayManager;\n\n      for (var name in _attributeDefs) {\n        if (name in buffers) {\n          typedArrayManager.release(attributes[name]);\n          attributes[name] = null;\n        } else {\n          var def = _attributeDefs[name];\n          def.copy = copy;\n          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n        }\n      }\n    }\n  }, {\n    key: \"_forEachGeometry\",\n    value: function _forEachGeometry(visitor, startRow, endRow) {\n      var data = this.data,\n          getGeometry = this.getGeometry;\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iterator2 = _createForOfIteratorHelper(iterable),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var object = _step2.value;\n          objectInfo.index++;\n          var geometry = getGeometry(object, objectInfo);\n          visitor(geometry, objectInfo.index);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_rebuildGeometry\",\n    value: function _rebuildGeometry(dataRange) {\n      var _this = this;\n\n      if (!this.data || !this.getGeometry) {\n        return;\n      }\n\n      var indexStarts = this.indexStarts,\n          vertexStarts = this.vertexStarts,\n          instanceCount = this.instanceCount;\n      var data = this.data,\n          geometryBuffer = this.geometryBuffer;\n\n      var _ref2 = dataRange || {},\n          _ref2$startRow = _ref2.startRow,\n          startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow,\n          _ref2$endRow = _ref2.endRow,\n          endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;\n\n      var normalizedData = {};\n\n      if (!dataRange) {\n        indexStarts = [0];\n        vertexStarts = [0];\n      }\n\n      if (this.normalize || !geometryBuffer) {\n        this._forEachGeometry(function (geometry, dataIndex) {\n          geometry = _this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + _this.getGeometrySize(geometry);\n        }, startRow, endRow);\n\n        instanceCount = vertexStarts[vertexStarts.length - 1];\n      } else if (geometryBuffer.buffer instanceof Buffer) {\n        var byteStride = geometryBuffer.stride || this.positionSize * 4;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n      } else {\n        var bufferValue = geometryBuffer.value || geometryBuffer;\n        var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n      }\n\n      this._allocate(instanceCount, Boolean(dataRange));\n\n      this.indexStarts = indexStarts;\n      this.vertexStarts = vertexStarts;\n      this.instanceCount = instanceCount;\n      var context = {};\n\n      this._forEachGeometry(function (geometry, dataIndex) {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n\n        _this.updateGeometryAttributes(geometry, context);\n      }, startRow, endRow);\n\n      this.vertexCount = indexStarts[indexStarts.length - 1];\n    }\n  }]);\n\n  return Tesselator;\n}();\n\nexport { Tesselator as default };","map":{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["constructor","opts","attributes","Object","buffers","normalize","geometryBuffer","positionFormat","assert","data","Array","endRow","startRow","value","ArrayBuffer","getAccessorFromBuffer","size","offset","stride","startIndices","typedArrayManager","name","def","_attributeDefs","getGeometry","objectInfo","createIterable","geometry","visitor","instanceCount","Infinity","dataRange","normalizedData","indexStarts","vertexStarts","dataIndex","byteStride","bufferValue","elementStride","Boolean","context","vertexEnd"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value)); // invalid binary geometries\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}