{"ast":null,"code":"export function isLogicalOr(op) {\n  return !!op.or;\n}\nexport function isLogicalAnd(op) {\n  return !!op.and;\n}\nexport function isLogicalNot(op) {\n  return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\nexport function normalizeLogicalComposition(op, normalizer) {\n  if (isLogicalNot(op)) {\n    return {\n      not: normalizeLogicalComposition(op.not, normalizer)\n    };\n  } else if (isLogicalAnd(op)) {\n    return {\n      and: op.and.map(o => normalizeLogicalComposition(o, normalizer))\n    };\n  } else if (isLogicalOr(op)) {\n    return {\n      or: op.or.map(o => normalizeLogicalComposition(o, normalizer))\n    };\n  } else {\n    return normalizer(op);\n  }\n}","map":{"version":3,"sources":["../../src/logical.ts"],"names":[],"mappings":"AAcA,OAAM,SAAU,WAAV,CAAsB,EAAtB,EAAiD;AACrD,SAAO,CAAC,CAAC,EAAE,CAAC,EAAZ;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAAkD;AACtD,SAAO,CAAC,CAAC,EAAE,CAAC,GAAZ;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAAkD;AACtD,SAAO,CAAC,CAAC,EAAE,CAAC,GAAZ;AACD;AAED,OAAM,SAAU,WAAV,CAAyB,EAAzB,EAAoD,EAApD,EAAuE;AAC3E,MAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AACpB,IAAA,WAAW,CAAC,EAAE,CAAC,GAAJ,EAAS,EAAT,CAAX;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AAC3B,SAAK,MAAM,KAAX,IAAoB,EAAE,CAAC,GAAvB,EAA4B;AAC1B,MAAA,WAAW,CAAC,KAAD,EAAQ,EAAR,CAAX;AACD;AACF,GAJM,MAIA,IAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AAC1B,SAAK,MAAM,KAAX,IAAoB,EAAE,CAAC,EAAvB,EAA2B;AACzB,MAAA,WAAW,CAAC,KAAD,EAAQ,EAAR,CAAX;AACD;AACF,GAJM,MAIA;AACL,IAAA,EAAE,CAAC,EAAD,CAAF;AACD;AACF;AAED,OAAM,SAAU,2BAAV,CACJ,EADI,EAEJ,UAFI,EAEmB;AAEvB,MAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AACpB,WAAO;AAAC,MAAA,GAAG,EAAE,2BAA2B,CAAC,EAAE,CAAC,GAAJ,EAAS,UAAT;AAAjC,KAAP;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AAC3B,WAAO;AAAC,MAAA,GAAG,EAAE,EAAE,CAAC,GAAH,CAAO,GAAP,CAAW,CAAC,IAAI,2BAA2B,CAAC,CAAD,EAAI,UAAJ,CAA3C;AAAN,KAAP;AACD,GAFM,MAEA,IAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AAC1B,WAAO;AAAC,MAAA,EAAE,EAAE,EAAE,CAAC,EAAH,CAAM,GAAN,CAAU,CAAC,IAAI,2BAA2B,CAAC,CAAD,EAAI,UAAJ,CAA1C;AAAL,KAAP;AACD,GAFM,MAEA;AACL,WAAO,UAAU,CAAC,EAAD,CAAjB;AACD;AACF","sourceRoot":"","sourcesContent":["export function isLogicalOr(op) {\n    return !!op.or;\n}\nexport function isLogicalAnd(op) {\n    return !!op.and;\n}\nexport function isLogicalNot(op) {\n    return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n    if (isLogicalNot(op)) {\n        forEachLeaf(op.not, fn);\n    }\n    else if (isLogicalAnd(op)) {\n        for (const subop of op.and) {\n            forEachLeaf(subop, fn);\n        }\n    }\n    else if (isLogicalOr(op)) {\n        for (const subop of op.or) {\n            forEachLeaf(subop, fn);\n        }\n    }\n    else {\n        fn(op);\n    }\n}\nexport function normalizeLogicalComposition(op, normalizer) {\n    if (isLogicalNot(op)) {\n        return { not: normalizeLogicalComposition(op.not, normalizer) };\n    }\n    else if (isLogicalAnd(op)) {\n        return { and: op.and.map(o => normalizeLogicalComposition(o, normalizer)) };\n    }\n    else if (isLogicalOr(op)) {\n        return { or: op.or.map(o => normalizeLogicalComposition(o, normalizer)) };\n    }\n    else {\n        return normalizer(op);\n    }\n}\n//# sourceMappingURL=logical.js.map"]},"metadata":{},"sourceType":"module"}