{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isContinuousFieldOrDatumDef, isFieldOrDatumDef, title } from '../channeldef';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { replaceAll, titleCase } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, getCompositeMarkTooltip, makeCompositeAggregatePartFactory } from './common';\nexport var ERRORBAR = 'errorbar';\nexport var ERRORBAR_PARTS = ['ticks', 'rule'];\nexport var errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\nexport function normalizeErrorBar(spec, _ref) {\n  var config = _ref.config;\n  // Need to initEncoding first so we can infer type\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n\n  var _errorBarParams = errorBarParams(spec, ERRORBAR, config),\n      transform = _errorBarParams.transform,\n      continuousAxisChannelDef = _errorBarParams.continuousAxisChannelDef,\n      continuousAxis = _errorBarParams.continuousAxis,\n      encodingWithoutContinuousAxis = _errorBarParams.encodingWithoutContinuousAxis,\n      ticksOrient = _errorBarParams.ticksOrient,\n      markDef = _errorBarParams.markDef,\n      outerSpec = _errorBarParams.outerSpec,\n      tooltipEncoding = _errorBarParams.tooltipEncoding;\n\n  delete encodingWithoutContinuousAxis['size'];\n  var makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);\n  var thickness = markDef.thickness;\n  var size = markDef.size;\n  var tick = Object.assign(Object.assign({\n    type: 'tick',\n    orient: ticksOrient,\n    aria: false\n  }, thickness !== undefined ? {\n    thickness: thickness\n  } : {}), size !== undefined ? {\n    size: size\n  } : {});\n  var layer = [].concat(_toConsumableArray(makeErrorBarPart({\n    partName: 'ticks',\n    mark: tick,\n    positionPrefix: 'lower',\n    extraEncoding: tooltipEncoding\n  })), _toConsumableArray(makeErrorBarPart({\n    partName: 'ticks',\n    mark: tick,\n    positionPrefix: 'upper',\n    extraEncoding: tooltipEncoding\n  })), _toConsumableArray(makeErrorBarPart({\n    partName: 'rule',\n    mark: Object.assign({\n      type: 'rule',\n      ariaRoleDescription: 'errorbar'\n    }, thickness !== undefined ? {\n      size: thickness\n    } : {}),\n    positionPrefix: 'lower',\n    endPositionPrefix: 'upper',\n    extraEncoding: tooltipEncoding\n  })));\n  return Object.assign(Object.assign(Object.assign({}, outerSpec), {\n    transform: transform\n  }), layer.length > 1 ? {\n    layer: layer\n  } : Object.assign({}, layer[0]));\n}\n\nfunction errorBarOrientAndInputType(spec, compositeMark) {\n  var encoding = spec.encoding;\n\n  if (errorBarIsInputTypeRaw(encoding)) {\n    return {\n      orient: compositeMarkOrient(spec, compositeMark),\n      inputType: 'raw'\n    };\n  }\n\n  var isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);\n  var isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);\n  var x = encoding.x;\n  var y = encoding.y;\n\n  if (isTypeAggregatedUpperLower) {\n    // type is aggregated-upper-lower\n    if (isTypeAggregatedError) {\n      throw new Error(\"\".concat(compositeMark, \" cannot be both type aggregated-upper-lower and aggregated-error\"));\n    }\n\n    var x2 = encoding.x2;\n    var y2 = encoding.y2;\n\n    if (isFieldOrDatumDef(x2) && isFieldOrDatumDef(y2)) {\n      // having both x, x2 and y, y2\n      throw new Error(\"\".concat(compositeMark, \" cannot have both x2 and y2\"));\n    } else if (isFieldOrDatumDef(x2)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x, x2 quantitative and field y, y2 are not specified\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having x, x2 that are not both quantitative\n        throw new Error(\"Both x and x2 have to be quantitative in \".concat(compositeMark));\n      }\n    } else if (isFieldOrDatumDef(y2)) {\n      // y2 is a FieldDef\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y, y2 quantitative and field x, x2 are not specified\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having y, y2 that are not both quantitative\n        throw new Error(\"Both y and y2 have to be quantitative in \".concat(compositeMark));\n      }\n    }\n\n    throw new Error('No ranged axis');\n  } else {\n    // type is aggregated-error\n    var xError = encoding.xError;\n    var xError2 = encoding.xError2;\n    var yError = encoding.yError;\n    var yError2 = encoding.yError2;\n\n    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {\n      // having xError2 without xError\n      throw new Error(\"\".concat(compositeMark, \" cannot have xError2 without xError\"));\n    }\n\n    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {\n      // having yError2 without yError\n      throw new Error(\"\".concat(compositeMark, \" cannot have yError2 without yError\"));\n    }\n\n    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {\n      // having both xError and yError\n      throw new Error(\"\".concat(compositeMark, \" cannot have both xError and yError with both are quantiative\"));\n    } else if (isFieldOrDatumDef(xError)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x and xError that are all quantitative\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having x, xError, and xError2 that are not all quantitative\n        throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n      }\n    } else if (isFieldOrDatumDef(yError)) {\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y and yError that are all quantitative\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having y, yError, and yError2 that are not all quantitative\n        throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n      }\n    }\n\n    throw new Error('No ranged axis');\n  }\n}\n\nfunction errorBarIsInputTypeRaw(encoding) {\n  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);\n}\n\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding) {\n  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);\n}\n\nfunction errorBarIsInputTypeAggregatedError(encoding) {\n  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);\n}\n\nexport function errorBarParams(spec, compositeMark, config) {\n  var _a; // TODO: use selection\n\n\n  var mark = spec.mark,\n      encoding = spec.encoding,\n      params = spec.params,\n      _p = spec.projection,\n      outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n\n  var markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (params) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  var _errorBarOrientAndInp = errorBarOrientAndInputType(spec, compositeMark),\n      orient = _errorBarOrientAndInp.orient,\n      inputType = _errorBarOrientAndInp.inputType;\n\n  var _compositeMarkContinu = compositeMarkContinuousAxis(spec, orient, compositeMark),\n      continuousAxisChannelDef = _compositeMarkContinu.continuousAxisChannelDef,\n      continuousAxisChannelDef2 = _compositeMarkContinu.continuousAxisChannelDef2,\n      continuousAxisChannelDefError = _compositeMarkContinu.continuousAxisChannelDefError,\n      continuousAxisChannelDefError2 = _compositeMarkContinu.continuousAxisChannelDefError2,\n      continuousAxis = _compositeMarkContinu.continuousAxis;\n\n  var _errorBarAggregationA = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config),\n      errorBarSpecificAggregate = _errorBarAggregationA.errorBarSpecificAggregate,\n      postAggregateCalculates = _errorBarAggregationA.postAggregateCalculates,\n      tooltipSummary = _errorBarAggregationA.tooltipSummary,\n      tooltipTitleWithFieldName = _errorBarAggregationA.tooltipTitleWithFieldName;\n\n  var _b = encoding,\n      _c = continuousAxis,\n      oldContinuousAxisChannelDef = _b[_c],\n      _d = continuousAxis === 'x' ? 'x2' : 'y2',\n      oldContinuousAxisChannelDef2 = _b[_d],\n      _e = continuousAxis === 'x' ? 'xError' : 'yError',\n      oldContinuousAxisChannelDefError = _b[_e],\n      _f = continuousAxis === 'x' ? 'xError2' : 'yError2',\n      oldContinuousAxisChannelDefError2 = _b[_f],\n      oldEncodingWithoutContinuousAxis = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\", typeof _d === \"symbol\" ? _d : _d + \"\", typeof _e === \"symbol\" ? _e : _e + \"\", typeof _f === \"symbol\" ? _f : _f + \"\"]);\n\n  var _extractTransformsFro = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config),\n      bins = _extractTransformsFro.bins,\n      timeUnits = _extractTransformsFro.timeUnits,\n      oldAggregate = _extractTransformsFro.aggregate,\n      oldGroupBy = _extractTransformsFro.groupby,\n      encodingWithoutContinuousAxis = _extractTransformsFro.encoding;\n\n  var aggregate = [].concat(_toConsumableArray(oldAggregate), _toConsumableArray(errorBarSpecificAggregate));\n  var groupby = inputType !== 'raw' ? [] : oldGroupBy;\n  var tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);\n  return {\n    transform: [].concat(_toConsumableArray((_a = outerSpec.transform) !== null && _a !== void 0 ? _a : []), _toConsumableArray(bins), _toConsumableArray(timeUnits), _toConsumableArray(aggregate.length === 0 ? [] : [{\n      aggregate: aggregate,\n      groupby: groupby\n    }]), _toConsumableArray(postAggregateCalculates)),\n    groupby: groupby,\n    continuousAxisChannelDef: continuousAxisChannelDef,\n    continuousAxis: continuousAxis,\n    encodingWithoutContinuousAxis: encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef: markDef,\n    outerSpec: outerSpec,\n    tooltipEncoding: tooltipEncoding\n  };\n}\n\nfunction errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {\n  var errorBarSpecificAggregate = [];\n  var postAggregateCalculates = [];\n  var continuousFieldName = continuousAxisChannelDef.field;\n  var tooltipSummary;\n  var tooltipTitleWithFieldName = false;\n\n  if (inputType === 'raw') {\n    var center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === 'iqr' ? 'median' : 'mean' : config.errorbar.center;\n    var extent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if (center === 'median' !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [{\n        op: extent,\n        field: continuousFieldName,\n        as: \"extent_\".concat(continuousFieldName)\n      }, {\n        op: center,\n        field: continuousFieldName,\n        as: \"center_\".concat(continuousFieldName)\n      }];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"center_\".concat(continuousFieldName, \"\\\"] + datum[\\\"extent_\").concat(continuousFieldName, \"\\\"]\"),\n        as: \"upper_\".concat(continuousFieldName)\n      }, {\n        calculate: \"datum[\\\"center_\".concat(continuousFieldName, \"\\\"] - datum[\\\"extent_\").concat(continuousFieldName, \"\\\"]\"),\n        as: \"lower_\".concat(continuousFieldName)\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'center_',\n        titlePrefix: titleCase(center)\n      }, {\n        fieldPrefix: 'upper_',\n        titlePrefix: getTitlePrefix(center, extent, '+')\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: getTitlePrefix(center, extent, '-')\n      }];\n      tooltipTitleWithFieldName = true;\n    } else {\n      var centerOp;\n      var lowerExtentOp;\n      var upperExtentOp;\n\n      if (extent === 'ci') {\n        centerOp = 'mean';\n        lowerExtentOp = 'ci0';\n        upperExtentOp = 'ci1';\n      } else {\n        centerOp = 'median';\n        lowerExtentOp = 'q1';\n        upperExtentOp = 'q3';\n      }\n\n      errorBarSpecificAggregate = [{\n        op: lowerExtentOp,\n        field: continuousFieldName,\n        as: \"lower_\".concat(continuousFieldName)\n      }, {\n        op: upperExtentOp,\n        field: continuousFieldName,\n        as: \"upper_\".concat(continuousFieldName)\n      }, {\n        op: centerOp,\n        field: continuousFieldName,\n        as: \"center_\".concat(continuousFieldName)\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'upper_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: upperExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: lowerExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'center_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: centerOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }];\n    }\n  } else {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    if (inputType === 'aggregated-upper-lower') {\n      tooltipSummary = [];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"\".concat(continuousAxisChannelDef2.field, \"\\\"]\"),\n        as: \"upper_\".concat(continuousFieldName)\n      }, {\n        calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"]\"),\n        as: \"lower_\".concat(continuousFieldName)\n      }];\n    } else if (inputType === 'aggregated-error') {\n      tooltipSummary = [{\n        fieldPrefix: '',\n        titlePrefix: continuousFieldName\n      }];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] + datum[\\\"\").concat(continuousAxisChannelDefError.field, \"\\\"]\"),\n        as: \"upper_\".concat(continuousFieldName)\n      }];\n\n      if (continuousAxisChannelDefError2) {\n        postAggregateCalculates.push({\n          calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] + datum[\\\"\").concat(continuousAxisChannelDefError2.field, \"\\\"]\"),\n          as: \"lower_\".concat(continuousFieldName)\n        });\n      } else {\n        postAggregateCalculates.push({\n          calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] - datum[\\\"\").concat(continuousAxisChannelDefError.field, \"\\\"]\"),\n          as: \"lower_\".concat(continuousFieldName)\n        });\n      }\n    }\n\n    var _iterator = _createForOfIteratorHelper(postAggregateCalculates),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var postAggregateCalculate = _step.value;\n        tooltipSummary.push({\n          fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n          titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return {\n    postAggregateCalculates: postAggregateCalculates,\n    errorBarSpecificAggregate: errorBarSpecificAggregate,\n    tooltipSummary: tooltipSummary,\n    tooltipTitleWithFieldName: tooltipTitleWithFieldName\n  };\n}\n\nfunction getTitlePrefix(center, extent, operation) {\n  return \"\".concat(titleCase(center), \" \").concat(operation, \" \").concat(extent);\n}","map":{"version":3,"sources":["../../../src/compositemark/errorbar.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isContinuousFieldOrDatumDef, isFieldOrDatumDef, title } from '../channeldef';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { replaceAll, titleCase } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, getCompositeMarkTooltip, makeCompositeAggregatePartFactory } from './common';\nexport const ERRORBAR = 'errorbar';\nexport const ERRORBAR_PARTS = ['ticks', 'rule'];\nexport const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\nexport function normalizeErrorBar(spec, { config }) {\n    // Need to initEncoding first so we can infer type\n    spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });\n    const { transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);\n    delete encodingWithoutContinuousAxis['size'];\n    const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);\n    const thickness = markDef.thickness;\n    const size = markDef.size;\n    const tick = Object.assign(Object.assign({ type: 'tick', orient: ticksOrient, aria: false }, (thickness !== undefined ? { thickness } : {})), (size !== undefined ? { size } : {}));\n    const layer = [\n        ...makeErrorBarPart({\n            partName: 'ticks',\n            mark: tick,\n            positionPrefix: 'lower',\n            extraEncoding: tooltipEncoding\n        }),\n        ...makeErrorBarPart({\n            partName: 'ticks',\n            mark: tick,\n            positionPrefix: 'upper',\n            extraEncoding: tooltipEncoding\n        }),\n        ...makeErrorBarPart({\n            partName: 'rule',\n            mark: Object.assign({ type: 'rule', ariaRoleDescription: 'errorbar' }, (thickness !== undefined ? { size: thickness } : {})),\n            positionPrefix: 'lower',\n            endPositionPrefix: 'upper',\n            extraEncoding: tooltipEncoding\n        })\n    ];\n    return Object.assign(Object.assign(Object.assign({}, outerSpec), { transform }), (layer.length > 1 ? { layer } : Object.assign({}, layer[0])));\n}\nfunction errorBarOrientAndInputType(spec, compositeMark) {\n    const { encoding } = spec;\n    if (errorBarIsInputTypeRaw(encoding)) {\n        return {\n            orient: compositeMarkOrient(spec, compositeMark),\n            inputType: 'raw'\n        };\n    }\n    const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);\n    const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);\n    const x = encoding.x;\n    const y = encoding.y;\n    if (isTypeAggregatedUpperLower) {\n        // type is aggregated-upper-lower\n        if (isTypeAggregatedError) {\n            throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);\n        }\n        const x2 = encoding.x2;\n        const y2 = encoding.y2;\n        if (isFieldOrDatumDef(x2) && isFieldOrDatumDef(y2)) {\n            // having both x, x2 and y, y2\n            throw new Error(`${compositeMark} cannot have both x2 and y2`);\n        }\n        else if (isFieldOrDatumDef(x2)) {\n            if (isContinuousFieldOrDatumDef(x)) {\n                // having x, x2 quantitative and field y, y2 are not specified\n                return { orient: 'horizontal', inputType: 'aggregated-upper-lower' };\n            }\n            else {\n                // having x, x2 that are not both quantitative\n                throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);\n            }\n        }\n        else if (isFieldOrDatumDef(y2)) {\n            // y2 is a FieldDef\n            if (isContinuousFieldOrDatumDef(y)) {\n                // having y, y2 quantitative and field x, x2 are not specified\n                return { orient: 'vertical', inputType: 'aggregated-upper-lower' };\n            }\n            else {\n                // having y, y2 that are not both quantitative\n                throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);\n            }\n        }\n        throw new Error('No ranged axis');\n    }\n    else {\n        // type is aggregated-error\n        const xError = encoding.xError;\n        const xError2 = encoding.xError2;\n        const yError = encoding.yError;\n        const yError2 = encoding.yError2;\n        if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {\n            // having xError2 without xError\n            throw new Error(`${compositeMark} cannot have xError2 without xError`);\n        }\n        if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {\n            // having yError2 without yError\n            throw new Error(`${compositeMark} cannot have yError2 without yError`);\n        }\n        if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {\n            // having both xError and yError\n            throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);\n        }\n        else if (isFieldOrDatumDef(xError)) {\n            if (isContinuousFieldOrDatumDef(x)) {\n                // having x and xError that are all quantitative\n                return { orient: 'horizontal', inputType: 'aggregated-error' };\n            }\n            else {\n                // having x, xError, and xError2 that are not all quantitative\n                throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n            }\n        }\n        else if (isFieldOrDatumDef(yError)) {\n            if (isContinuousFieldOrDatumDef(y)) {\n                // having y and yError that are all quantitative\n                return { orient: 'vertical', inputType: 'aggregated-error' };\n            }\n            else {\n                // having y, yError, and yError2 that are not all quantitative\n                throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n            }\n        }\n        throw new Error('No ranged axis');\n    }\n}\nfunction errorBarIsInputTypeRaw(encoding) {\n    return ((isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) &&\n        !isFieldOrDatumDef(encoding.x2) &&\n        !isFieldOrDatumDef(encoding.y2) &&\n        !isFieldOrDatumDef(encoding.xError) &&\n        !isFieldOrDatumDef(encoding.xError2) &&\n        !isFieldOrDatumDef(encoding.yError) &&\n        !isFieldOrDatumDef(encoding.yError2));\n}\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding) {\n    return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);\n}\nfunction errorBarIsInputTypeAggregatedError(encoding) {\n    return (isFieldOrDatumDef(encoding.xError) ||\n        isFieldOrDatumDef(encoding.xError2) ||\n        isFieldOrDatumDef(encoding.yError) ||\n        isFieldOrDatumDef(encoding.yError2));\n}\nexport function errorBarParams(spec, compositeMark, config) {\n    var _a;\n    // TODO: use selection\n    const { mark, encoding, params, projection: _p } = spec, outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n    const markDef = isMarkDef(mark) ? mark : { type: mark };\n    // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n    if (params) {\n        log.warn(log.message.selectionNotSupported(compositeMark));\n    }\n    const { orient, inputType } = errorBarOrientAndInputType(spec, compositeMark);\n    const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient, compositeMark);\n    const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);\n    const _b = encoding, _c = continuousAxis, oldContinuousAxisChannelDef = _b[_c], _d = continuousAxis === 'x' ? 'x2' : 'y2', oldContinuousAxisChannelDef2 = _b[_d], _e = continuousAxis === 'x' ? 'xError' : 'yError', oldContinuousAxisChannelDefError = _b[_e], _f = continuousAxis === 'x' ? 'xError2' : 'yError2', oldContinuousAxisChannelDefError2 = _b[_f], oldEncodingWithoutContinuousAxis = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\", typeof _d === \"symbol\" ? _d : _d + \"\", typeof _e === \"symbol\" ? _e : _e + \"\", typeof _f === \"symbol\" ? _f : _f + \"\"]);\n    const { bins, timeUnits, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n    const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];\n    const groupby = inputType !== 'raw' ? [] : oldGroupBy;\n    const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);\n    return {\n        transform: [\n            ...((_a = outerSpec.transform) !== null && _a !== void 0 ? _a : []),\n            ...bins,\n            ...timeUnits,\n            ...(aggregate.length === 0 ? [] : [{ aggregate, groupby }]),\n            ...postAggregateCalculates\n        ],\n        groupby,\n        continuousAxisChannelDef,\n        continuousAxis,\n        encodingWithoutContinuousAxis,\n        ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n        markDef,\n        outerSpec,\n        tooltipEncoding\n    };\n}\nfunction errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {\n    let errorBarSpecificAggregate = [];\n    let postAggregateCalculates = [];\n    const continuousFieldName = continuousAxisChannelDef.field;\n    let tooltipSummary;\n    let tooltipTitleWithFieldName = false;\n    if (inputType === 'raw') {\n        const center = markDef.center\n            ? markDef.center\n            : markDef.extent\n                ? markDef.extent === 'iqr'\n                    ? 'median'\n                    : 'mean'\n                : config.errorbar.center;\n        const extent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n        if ((center === 'median') !== (extent === 'iqr')) {\n            log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n        }\n        if (extent === 'stderr' || extent === 'stdev') {\n            errorBarSpecificAggregate = [\n                { op: extent, field: continuousFieldName, as: `extent_${continuousFieldName}` },\n                { op: center, field: continuousFieldName, as: `center_${continuousFieldName}` }\n            ];\n            postAggregateCalculates = [\n                {\n                    calculate: `datum[\"center_${continuousFieldName}\"] + datum[\"extent_${continuousFieldName}\"]`,\n                    as: `upper_${continuousFieldName}`\n                },\n                {\n                    calculate: `datum[\"center_${continuousFieldName}\"] - datum[\"extent_${continuousFieldName}\"]`,\n                    as: `lower_${continuousFieldName}`\n                }\n            ];\n            tooltipSummary = [\n                { fieldPrefix: 'center_', titlePrefix: titleCase(center) },\n                { fieldPrefix: 'upper_', titlePrefix: getTitlePrefix(center, extent, '+') },\n                { fieldPrefix: 'lower_', titlePrefix: getTitlePrefix(center, extent, '-') }\n            ];\n            tooltipTitleWithFieldName = true;\n        }\n        else {\n            let centerOp;\n            let lowerExtentOp;\n            let upperExtentOp;\n            if (extent === 'ci') {\n                centerOp = 'mean';\n                lowerExtentOp = 'ci0';\n                upperExtentOp = 'ci1';\n            }\n            else {\n                centerOp = 'median';\n                lowerExtentOp = 'q1';\n                upperExtentOp = 'q3';\n            }\n            errorBarSpecificAggregate = [\n                { op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}` },\n                { op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}` },\n                { op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}` }\n            ];\n            tooltipSummary = [\n                {\n                    fieldPrefix: 'upper_',\n                    titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: 'quantitative' }, config, {\n                        allowDisabling: false\n                    })\n                },\n                {\n                    fieldPrefix: 'lower_',\n                    titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: 'quantitative' }, config, {\n                        allowDisabling: false\n                    })\n                },\n                {\n                    fieldPrefix: 'center_',\n                    titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: 'quantitative' }, config, {\n                        allowDisabling: false\n                    })\n                }\n            ];\n        }\n    }\n    else {\n        if (markDef.center || markDef.extent) {\n            log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n        }\n        if (inputType === 'aggregated-upper-lower') {\n            tooltipSummary = [];\n            postAggregateCalculates = [\n                { calculate: `datum[\"${continuousAxisChannelDef2.field}\"]`, as: `upper_${continuousFieldName}` },\n                { calculate: `datum[\"${continuousFieldName}\"]`, as: `lower_${continuousFieldName}` }\n            ];\n        }\n        else if (inputType === 'aggregated-error') {\n            tooltipSummary = [{ fieldPrefix: '', titlePrefix: continuousFieldName }];\n            postAggregateCalculates = [\n                {\n                    calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError.field}\"]`,\n                    as: `upper_${continuousFieldName}`\n                }\n            ];\n            if (continuousAxisChannelDefError2) {\n                postAggregateCalculates.push({\n                    calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError2.field}\"]`,\n                    as: `lower_${continuousFieldName}`\n                });\n            }\n            else {\n                postAggregateCalculates.push({\n                    calculate: `datum[\"${continuousFieldName}\"] - datum[\"${continuousAxisChannelDefError.field}\"]`,\n                    as: `lower_${continuousFieldName}`\n                });\n            }\n        }\n        for (const postAggregateCalculate of postAggregateCalculates) {\n            tooltipSummary.push({\n                fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n                titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n            });\n        }\n    }\n    return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };\n}\nfunction getTitlePrefix(center, extent, operation) {\n    return `${titleCase(center)} ${operation} ${extent}`;\n}\n//# sourceMappingURL=errorbar.js.map"]},"metadata":{},"sourceType":"module"}