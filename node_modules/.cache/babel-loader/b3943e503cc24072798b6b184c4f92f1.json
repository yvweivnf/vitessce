{"ast":null,"code":"import { array, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { getSecondaryRangeChannel, NONPOSITION_CHANNELS } from './channel';\nimport { channelDefType, getFieldDef, isFieldDef, isFieldOrDatumDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { ARC, AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nimport { contains } from './util';\nconst STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\nexport function isStackOffset(s) {\n  return s in STACK_OFFSET_INDEX;\n}\nexport const STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);\n\nfunction isUnbinnedQuantitative(channelDef) {\n  return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\n\nfunction potentialStackedChannel(encoding, x) {\n  var _a, _b;\n\n  const y = x === 'x' ? 'y' : 'radius';\n  const xDef = encoding[x];\n  const yDef = encoding[y];\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n      if (xDef.stack) {\n        return x;\n      } else if (yDef.stack) {\n        return y;\n      }\n\n      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate; // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n\n      if (xAggregate !== yAggregate) {\n        return xAggregate ? x : y;\n      } else {\n        const xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;\n        const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;\n\n        if (xScale && xScale !== 'linear') {\n          return y;\n        } else if (yScale && yScale !== 'linear') {\n          return x;\n        }\n      }\n    } else if (isUnbinnedQuantitative(xDef)) {\n      return x;\n    } else if (isUnbinnedQuantitative(yDef)) {\n      return y;\n    }\n  } else if (isUnbinnedQuantitative(xDef)) {\n    return x;\n  } else if (isUnbinnedQuantitative(yDef)) {\n    return y;\n  }\n\n  return undefined;\n}\n\nfunction getDimensionChannel(channel) {\n  switch (channel) {\n    case 'x':\n      return 'y';\n\n    case 'y':\n      return 'x';\n\n    case 'theta':\n      return 'radius';\n\n    case 'radius':\n      return 'theta';\n  }\n} // Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\n\n\nexport function stack(m, encoding, opt = {}) {\n  var _a, _b;\n\n  const mark = isMarkDef(m) ? m.type : m; // Should have stackable mark\n\n  if (!STACKABLE_MARKS.has(mark)) {\n    return null;\n  } // Run potential stacked twice, one for Cartesian and another for Polar,\n  // so text marks can be stacked in any of the coordinates.\n  // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n  // However, since we probably never want to do that, let's just note the limitation here.\n\n\n  const fieldChannel = potentialStackedChannel(encoding, 'x') || potentialStackedChannel(encoding, 'theta');\n\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel];\n  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n  let dimensionChannel = getDimensionChannel(fieldChannel);\n  let dimensionDef = encoding[dimensionChannel];\n  let dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined; // avoid grouping by the stacked field\n\n  if (dimensionField === stackedField) {\n    dimensionField = undefined;\n    dimensionDef = undefined;\n    dimensionChannel = undefined;\n  } // Should have grouping level of detail that is different from the dimension field\n\n\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n\n      for (const cDef of array(channelDef)) {\n        const fieldDef = getFieldDef(cDef);\n\n        if (fieldDef.aggregate) {\n          continue;\n        } // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n\n\n        const f = vgField(fieldDef, {});\n\n        if ( // if fielddef is a repeat, just include it in the stack by\n        !f || // otherwise, the field must be different from x and y fields.\n        f !== dimensionField) {\n          sc.push({\n            channel,\n            fieldDef\n          });\n        }\n      }\n    }\n\n    return sc;\n  }, []); // Automatically determine offset\n\n  let offset;\n\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n    offset = 'zero';\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  } // warn when stacking non-linear\n\n\n  if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {\n    if (opt.disallowNonLinearStack) {\n      return null;\n    } else {\n      log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n    }\n  } // Check if it is a ranged mark\n\n\n  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n\n    return null;\n  } // Warn if stacking non-summative aggregate\n\n\n  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannel: dimensionDef ? dimensionChannel : undefined,\n    groupbyField: dimensionField,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}","map":{"version":3,"sources":["../../src/stack.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { getSecondaryRangeChannel, NONPOSITION_CHANNELS } from './channel';\nimport { channelDefType, getFieldDef, isFieldDef, isFieldOrDatumDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { ARC, AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nimport { contains } from './util';\nconst STACK_OFFSET_INDEX = {\n    zero: 1,\n    center: 1,\n    normalize: 1\n};\nexport function isStackOffset(s) {\n    return s in STACK_OFFSET_INDEX;\n}\nexport const STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);\nfunction isUnbinnedQuantitative(channelDef) {\n    return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\nfunction potentialStackedChannel(encoding, x) {\n    var _a, _b;\n    const y = x === 'x' ? 'y' : 'radius';\n    const xDef = encoding[x];\n    const yDef = encoding[y];\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n        if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n            if (xDef.stack) {\n                return x;\n            }\n            else if (yDef.stack) {\n                return y;\n            }\n            const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n            const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;\n            // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n            if (xAggregate !== yAggregate) {\n                return xAggregate ? x : y;\n            }\n            else {\n                const xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;\n                const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;\n                if (xScale && xScale !== 'linear') {\n                    return y;\n                }\n                else if (yScale && yScale !== 'linear') {\n                    return x;\n                }\n            }\n        }\n        else if (isUnbinnedQuantitative(xDef)) {\n            return x;\n        }\n        else if (isUnbinnedQuantitative(yDef)) {\n            return y;\n        }\n    }\n    else if (isUnbinnedQuantitative(xDef)) {\n        return x;\n    }\n    else if (isUnbinnedQuantitative(yDef)) {\n        return y;\n    }\n    return undefined;\n}\nfunction getDimensionChannel(channel) {\n    switch (channel) {\n        case 'x':\n            return 'y';\n        case 'y':\n            return 'x';\n        case 'theta':\n            return 'radius';\n        case 'radius':\n            return 'theta';\n    }\n}\n// Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\nexport function stack(m, encoding, opt = {}) {\n    var _a, _b;\n    const mark = isMarkDef(m) ? m.type : m;\n    // Should have stackable mark\n    if (!STACKABLE_MARKS.has(mark)) {\n        return null;\n    }\n    // Run potential stacked twice, one for Cartesian and another for Polar,\n    // so text marks can be stacked in any of the coordinates.\n    // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n    // However, since we probably never want to do that, let's just note the limitation here.\n    const fieldChannel = potentialStackedChannel(encoding, 'x') || potentialStackedChannel(encoding, 'theta');\n    if (!fieldChannel) {\n        return null;\n    }\n    const stackedFieldDef = encoding[fieldChannel];\n    const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n    let dimensionChannel = getDimensionChannel(fieldChannel);\n    let dimensionDef = encoding[dimensionChannel];\n    let dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n    // avoid grouping by the stacked field\n    if (dimensionField === stackedField) {\n        dimensionField = undefined;\n        dimensionDef = undefined;\n        dimensionChannel = undefined;\n    }\n    // Should have grouping level of detail that is different from the dimension field\n    const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n        // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n        if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n            const channelDef = encoding[channel];\n            for (const cDef of array(channelDef)) {\n                const fieldDef = getFieldDef(cDef);\n                if (fieldDef.aggregate) {\n                    continue;\n                }\n                // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n                const f = vgField(fieldDef, {});\n                if (\n                // if fielddef is a repeat, just include it in the stack by\n                !f ||\n                    // otherwise, the field must be different from x and y fields.\n                    f !== dimensionField) {\n                    sc.push({ channel, fieldDef });\n                }\n            }\n        }\n        return sc;\n    }, []);\n    // Automatically determine offset\n    let offset;\n    if (stackedFieldDef.stack !== undefined) {\n        if (isBoolean(stackedFieldDef.stack)) {\n            offset = stackedFieldDef.stack ? 'zero' : null;\n        }\n        else {\n            offset = stackedFieldDef.stack;\n        }\n    }\n    else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n        offset = 'zero';\n    }\n    if (!offset || !isStackOffset(offset)) {\n        return null;\n    }\n    if (isAggregate(encoding) && stackBy.length === 0) {\n        return null;\n    }\n    // warn when stacking non-linear\n    if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {\n        if (opt.disallowNonLinearStack) {\n            return null;\n        }\n        else {\n            log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n        }\n    }\n    // Check if it is a ranged mark\n    if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n        if (stackedFieldDef.stack !== undefined) {\n            log.warn(log.message.cannotStackRangedMark(fieldChannel));\n        }\n        return null;\n    }\n    // Warn if stacking non-summative aggregate\n    if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {\n        log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n    }\n    return {\n        groupbyChannel: dimensionDef ? dimensionChannel : undefined,\n        groupbyField: dimensionField,\n        fieldChannel,\n        impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n        stackBy,\n        offset\n    };\n}\n//# sourceMappingURL=stack.js.map"]},"metadata":{},"sourceType":"module"}