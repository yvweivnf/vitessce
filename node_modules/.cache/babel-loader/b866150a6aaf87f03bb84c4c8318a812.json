{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _Optimizer_modified;\n\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\n\nexport function isDataSourceNode(node) {\n  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\n\nexport var Optimizer = /*#__PURE__*/function () {\n  function Optimizer() {\n    _classCallCheck(this, Optimizer);\n\n    _Optimizer_modified.set(this, void 0);\n\n    __classPrivateFieldSet(this, _Optimizer_modified, false, \"f\");\n  } // Once true, #modified is never set to false\n\n\n  _createClass(Optimizer, [{\n    key: \"setModified\",\n    value: function setModified() {\n      __classPrivateFieldSet(this, _Optimizer_modified, true, \"f\");\n    }\n  }, {\n    key: \"modifiedFlag\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _Optimizer_modified, \"f\");\n    }\n  }]);\n\n  return Optimizer;\n}();\n_Optimizer_modified = new WeakMap();\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\n\nexport var BottomUpOptimizer = /*#__PURE__*/function (_Optimizer) {\n  _inherits(BottomUpOptimizer, _Optimizer);\n\n  var _super = _createSuper(BottomUpOptimizer);\n\n  function BottomUpOptimizer() {\n    _classCallCheck(this, BottomUpOptimizer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(BottomUpOptimizer, [{\n    key: \"getNodeDepths\",\n\n    /**\n     * Compute a map of node depths that we can use to determine a topological sort order.\n     */\n    value: function getNodeDepths(node, depth, depths) {\n      depths.set(node, depth);\n\n      var _iterator = _createForOfIteratorHelper(node.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          this.getNodeDepths(child, depth + 1, depths);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return depths;\n    }\n    /**\n     * Run the optimizer on all nodes starting from the leaves.\n     */\n\n  }, {\n    key: \"optimize\",\n    value: function optimize(node) {\n      var depths = this.getNodeDepths(node, 0, new Map());\n\n      var topologicalSort = _toConsumableArray(depths.entries()).sort(function (a, b) {\n        return b[1] - a[1];\n      });\n\n      var _iterator2 = _createForOfIteratorHelper(topologicalSort),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var tuple = _step2.value;\n          this.run(tuple[0]);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return this.modifiedFlag;\n    }\n  }]);\n\n  return BottomUpOptimizer;\n}(Optimizer);\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\n\nexport var TopDownOptimizer = /*#__PURE__*/function (_Optimizer2) {\n  _inherits(TopDownOptimizer, _Optimizer2);\n\n  var _super2 = _createSuper(TopDownOptimizer);\n\n  function TopDownOptimizer() {\n    _classCallCheck(this, TopDownOptimizer);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(TopDownOptimizer, [{\n    key: \"optimize\",\n\n    /**\n     * Run the optimizer depth first on all nodes starting from the roots.\n     */\n    value: function optimize(node) {\n      this.run(node);\n\n      var _iterator3 = _createForOfIteratorHelper(node.children),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          this.optimize(child);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return this.modifiedFlag;\n    }\n  }]);\n\n  return TopDownOptimizer;\n}(Optimizer);","map":{"version":3,"sources":["../../../../src/compile/data/optimizer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,UAAR,QAAyB,UAAzB;AAEA;;;;AAGA,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAA6C;AACjD,SAAO,IAAI,YAAY,UAAhB,IAA8B,IAAI,YAAY,aAA9C,IAA+D,IAAI,YAAY,YAAtF;AACD;AAED;;;;;AAIA,WAAsB,SAAtB;AAGE,uBAAA;AAAA;;AAFA,IAAA,mBAAA,CAAA,GAAA,CAAA,IAAA,EAAA,KAAA,CAAA;;AAGE,IAAA,sBAAA,CAAA,IAAA,EAAI,mBAAJ,EAAiB,KAAjB,EAAsB,GAAtB,CAAA;AACD,GALH,CAOE;;;AAPF;AAAA;AAAA,kCAQoB;AAChB,MAAA,sBAAA,CAAA,IAAA,EAAI,mBAAJ,EAAiB,IAAjB,EAAqB,GAArB,CAAA;AACD;AAVH;AAAA;AAAA,wBAYkB;AACd,aAAO,sBAAA,CAAA,IAAA,EAAI,mBAAJ,EAAI,GAAJ,CAAP;AACD;AAdH;;AAAA;AAAA;;AAsBA;;;;;AAIA,WAAsB,iBAAtB;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAME;;;AANF,kCAUI,IAVJ,EAWI,KAXJ,EAYI,MAZJ,EAYqC;AAEjC,MAAA,MAAM,CAAC,GAAP,CAAW,IAAX,EAAiB,KAAjB;;AAFiC,iDAIb,IAAI,CAAC,QAJQ;AAAA;;AAAA;AAIjC,4DAAmC;AAAA,cAAxB,KAAwB;AACjC,eAAK,aAAL,CAAmB,KAAnB,EAA0B,KAAK,GAAG,CAAlC,EAAqC,MAArC;AACD;AANgC;AAAA;AAAA;AAAA;AAAA;;AAQjC,aAAO,MAAP;AACD;AAED;;;;AAvBF;AAAA;AAAA,6BA0BkB,IA1BlB,EA0BoC;AAChC,UAAM,MAAM,GAAG,KAAK,aAAL,CAAmB,IAAnB,EAAyB,CAAzB,EAA4B,IAAI,GAAJ,EAA5B,CAAf;;AACA,UAAM,eAAe,GAAG,mBAAI,MAAM,CAAC,OAAP,EAAJ,EAAsB,IAAtB,CAA2B,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAlB;AAAA,OAA3B,CAAxB;;AAFgC,kDAIZ,eAJY;AAAA;;AAAA;AAIhC,+DAAqC;AAAA,cAA1B,KAA0B;AACnC,eAAK,GAAL,CAAS,KAAK,CAAC,CAAD,CAAd;AACD;AAN+B;AAAA;AAAA;AAAA;AAAA;;AAQhC,aAAO,KAAK,YAAZ;AACD;AAnCH;;AAAA;AAAA,EAAgD,SAAhD;AAsCA;;;;AAGA,WAAsB,gBAAtB;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAME;;;AANF,6BASkB,IATlB,EASoC;AAChC,WAAK,GAAL,CAAS,IAAT;;AADgC,kDAGZ,IAAI,CAAC,QAHO;AAAA;;AAAA;AAGhC,+DAAmC;AAAA,cAAxB,KAAwB;AACjC,eAAK,QAAL,CAAc,KAAd;AACD;AAL+B;AAAA;AAAA;AAAA;AAAA;;AAOhC,aAAO,KAAK,YAAZ;AACD;AAjBH;;AAAA;AAAA,EAA+C,SAA/C","sourceRoot":"","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Optimizer_modified;\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\nexport function isDataSourceNode(node) {\n    return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\nexport class Optimizer {\n    constructor() {\n        _Optimizer_modified.set(this, void 0);\n        __classPrivateFieldSet(this, _Optimizer_modified, false, \"f\");\n    }\n    // Once true, #modified is never set to false\n    setModified() {\n        __classPrivateFieldSet(this, _Optimizer_modified, true, \"f\");\n    }\n    get modifiedFlag() {\n        return __classPrivateFieldGet(this, _Optimizer_modified, \"f\");\n    }\n}\n_Optimizer_modified = new WeakMap();\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\nexport class BottomUpOptimizer extends Optimizer {\n    /**\n     * Compute a map of node depths that we can use to determine a topological sort order.\n     */\n    getNodeDepths(node, depth, depths) {\n        depths.set(node, depth);\n        for (const child of node.children) {\n            this.getNodeDepths(child, depth + 1, depths);\n        }\n        return depths;\n    }\n    /**\n     * Run the optimizer on all nodes starting from the leaves.\n     */\n    optimize(node) {\n        const depths = this.getNodeDepths(node, 0, new Map());\n        const topologicalSort = [...depths.entries()].sort((a, b) => b[1] - a[1]);\n        for (const tuple of topologicalSort) {\n            this.run(tuple[0]);\n        }\n        return this.modifiedFlag;\n    }\n}\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\nexport class TopDownOptimizer extends Optimizer {\n    /**\n     * Run the optimizer depth first on all nodes starting from the roots.\n     */\n    optimize(node) {\n        this.run(node);\n        for (const child of node.children) {\n            this.optimize(child);\n        }\n        return this.modifiedFlag;\n    }\n}\n//# sourceMappingURL=optimizer.js.map"]},"metadata":{},"sourceType":"module"}