{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nconst scaleBindings = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: (model, selCmpt) => {\n    const bound = selCmpt.scales = [];\n\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n\n      scale.set('selectionExtent', {\n        param: selCmpt.name,\n        field: proj.field\n      }, true);\n      bound.push(proj);\n    }\n  },\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0); // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    } // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n\n\n    const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n    let update = namedSg.update;\n\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = `{${bound.map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`).join(', ')}}`;\n    } else {\n      for (const proj of bound) {\n        const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n\n        if (!update.includes(mapping)) {\n          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n        }\n      }\n\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(proj => ({\n      name: proj.signals.data\n    })));\n  },\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal = signals.filter(s => s.name === proj.signals.data)[0];\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n\n    return signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n\nfunction isTopLevelLayer(model) {\n  var _a;\n\n  return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}","map":{"version":3,"sources":["../../../../src/compile/selection/scales.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nconst scaleBindings = {\n    defined: selCmpt => {\n        return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n    },\n    parse: (model, selCmpt) => {\n        const bound = (selCmpt.scales = []);\n        for (const proj of selCmpt.project.items) {\n            const channel = proj.channel;\n            if (!isScaleChannel(channel)) {\n                continue;\n            }\n            const scale = model.getScaleComponent(channel);\n            const scaleType = scale ? scale.get('type') : undefined;\n            if (!scale || !hasContinuousDomain(scaleType)) {\n                log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n                continue;\n            }\n            scale.set('selectionExtent', { param: selCmpt.name, field: proj.field }, true);\n            bound.push(proj);\n        }\n    },\n    topLevelSignals: (model, selCmpt, signals) => {\n        const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);\n        // Top-level signals are only needed for multiview displays and if this\n        // view's top-level signals haven't already been generated.\n        if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n            return signals;\n        }\n        // vlSelectionResolve does not account for the behavior of bound scales in\n        // multiview displays. Each unit view adds a tuple to the store, but the\n        // state of the selection is the unit selection most recently updated. This\n        // state is captured by the top-level signals that we insert and \"push\n        // outer\" to from within the units. We need to reassemble this state into\n        // the top-level named signal, except no single selCmpt has a global view.\n        const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n        let update = namedSg.update;\n        if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n            namedSg.update = `{${bound\n                .map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`)\n                .join(', ')}}`;\n        }\n        else {\n            for (const proj of bound) {\n                const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n                if (!update.includes(mapping)) {\n                    update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n                }\n            }\n            namedSg.update = update;\n        }\n        return signals.concat(bound.map(proj => ({ name: proj.signals.data })));\n    },\n    signals: (model, selCmpt, signals) => {\n        // Nested signals need only push to top-level signals with multiview displays.\n        if (model.parent && !isTopLevelLayer(model)) {\n            for (const proj of selCmpt.scales) {\n                const signal = signals.filter(s => s.name === proj.signals.data)[0];\n                signal.push = 'outer';\n                delete signal.value;\n                delete signal.update;\n            }\n        }\n        return signals;\n    }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n    const scale = stringValue(model.scaleName(channel));\n    return `domain(${scale})`;\n}\nfunction isTopLevelLayer(model) {\n    var _a;\n    return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}\n//# sourceMappingURL=scales.js.map"]},"metadata":{},"sourceType":"module"}