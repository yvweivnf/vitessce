{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { createIterable } from '@deck.gl/core';\nimport { getGridOffset } from '../utils/grid-aggregation-utils';\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  var hashInfo = pointsToGridHashing(props, aggregationParams);\n  var result = getGridLayerDataFromGridHash(hashInfo);\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\nfunction pointsToGridHashing(props, aggregationParams) {\n  var _props$data = props.data,\n      data = _props$data === void 0 ? [] : _props$data,\n      cellSize = props.cellSize;\n  var attributes = aggregationParams.attributes,\n      viewport = aggregationParams.viewport,\n      projectPoints = aggregationParams.projectPoints,\n      numInstances = aggregationParams.numInstances;\n  var positions = attributes.positions.value;\n\n  var _attributes$positions = attributes.positions.getAccessor(),\n      size = _attributes$positions.size;\n\n  var boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  var offsets = aggregationParams.posOffset || [180, 90];\n  var gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset: gridOffset\n    };\n  }\n\n  var width = viewport.width,\n      height = viewport.height;\n  var numCol = Math.ceil(width / gridOffset.xOffset);\n  var numRow = Math.ceil(height / gridOffset.yOffset);\n  var gridHash = {};\n\n  var _createIterable = createIterable(data),\n      iterable = _createIterable.iterable,\n      objectInfo = _createIterable.objectInfo;\n\n  var position = new Array(3);\n\n  var _iterator = _createForOfIteratorHelper(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pt = _step.value;\n      objectInfo.index++;\n      position[0] = positions[objectInfo.index * size];\n      position[1] = positions[objectInfo.index * size + 1];\n      position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n\n      var _ref2 = projectPoints ? viewport.project(position) : position,\n          _ref3 = _slicedToArray(_ref2, 2),\n          x = _ref3[0],\n          y = _ref3[1];\n\n      if (Number.isFinite(x) && Number.isFinite(y)) {\n        var yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n        var xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n\n        if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {\n          var key = \"\".concat(yIndex, \"-\").concat(xIndex);\n          gridHash[key] = gridHash[key] || {\n            count: 0,\n            points: [],\n            lonIdx: xIndex,\n            latIdx: yIndex\n          };\n          gridHash[key].count += 1;\n          gridHash[key].points.push({\n            source: pt,\n            index: objectInfo.index\n          });\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    gridHash: gridHash,\n    gridOffset: gridOffset,\n    offsets: [offsets[0] * -1, offsets[1] * -1]\n  };\n}\n\nfunction getGridLayerDataFromGridHash(_ref) {\n  var gridHash = _ref.gridHash,\n      gridOffset = _ref.gridOffset,\n      offsets = _ref.offsets;\n  var data = new Array(Object.keys(gridHash).length);\n  var i = 0;\n\n  for (var key in gridHash) {\n    var idxs = key.split('-');\n    var latIdx = parseInt(idxs[0], 10);\n    var lonIdx = parseInt(idxs[1], 10);\n    var index = i++;\n    data[index] = _objectSpread({\n      index: index,\n      position: [offsets[0] + gridOffset.xOffset * lonIdx, offsets[1] + gridOffset.yOffset * latIdx]\n    }, gridHash[key]);\n  }\n\n  return data;\n}\n\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  var positions = positionAttribute.value;\n\n  var _positionAttribute$ge = positionAttribute.getAccessor(),\n      size = _positionAttribute$ge.size;\n\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n\n  for (var i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {\n    xMin: xMin,\n    xMax: xMax,\n    yMin: yMin,\n    yMax: yMax\n  };\n}","map":{"version":3,"sources":["../../../src/cpu-grid-layer/grid-aggregator.js"],"names":["hashInfo","pointsToGridHashing","result","getGridLayerDataFromGridHash","gridHash","gridOffset","data","cellSize","numInstances","positions","attributes","size","boundingBox","aggregationParams","getPositionBoundingBox","offsets","getGridOffset","height","numCol","Math","width","numRow","objectInfo","createIterable","position","projectPoints","viewport","Number","yIndex","y","xIndex","x","key","count","points","lonIdx","latIdx","source","index","Object","i","idxs","parseInt","positionAttribute","yMin","yMax","xMin","xMax"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {createIterable} from '@deck.gl/core';\nimport {getGridOffset} from '../utils/grid-aggregation-utils';\n\n/**\n * Calculate density grid from an array of points\n * @param {Object} props - object containing :\n * @param {Iterable} [props.data] - data objects to be aggregated\n * @param {Integer} [props.cellSize] - size of the grid cell\n *\n * @param {Object} aggregationParams - object containing :\n * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters\n * @param {Integer} width - width of the grid\n * @param {Integer} height - height of the grid\n * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise\n * @param {Array} attributes - attributes array containing position values\n * @param {Viewport} viewport - viewport to be used for projection\n * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index\n * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data\n *\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable max-statements, complexity */\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {data = [], cellSize} = props;\n  const {attributes, viewport, projectPoints, numInstances} = aggregationParams;\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n  const boundingBox =\n    aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  const {width, height} = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n\n  // calculate count per cell\n  const gridHash = {};\n\n  const {iterable, objectInfo} = createIterable(data);\n  const position = new Array(3);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n      if (\n        !projectPoints ||\n        // when doing screen space agggregation (projectPoints = true), filter points outside of the viewport range.\n        (xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow)\n      ) {\n        const key = `${yIndex}-${xIndex}`;\n\n        gridHash[key] = gridHash[key] || {count: 0, points: [], lonIdx: xIndex, latIdx: yIndex};\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n\n  return {gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1]};\n}\n/* eslint-enable max-statements, complexity */\n\nfunction getGridLayerDataFromGridHash({gridHash, gridOffset, offsets}) {\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n\n    data[index] = {\n      index,\n      position: [\n        offsets[0] + gridOffset.xOffset * lonIdx,\n        offsets[1] + gridOffset.yOffset * latIdx\n      ],\n      ...gridHash[key]\n    };\n  }\n  return data;\n}\n\n// Calculate bounding box of position attribute\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = positionAttribute.value;\n  const {size} = positionAttribute.getAccessor();\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {xMin, xMax, yMin, yMax};\n}\n"]},"metadata":{},"sourceType":"module"}