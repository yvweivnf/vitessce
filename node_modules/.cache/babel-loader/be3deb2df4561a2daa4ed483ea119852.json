{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Buffer, Texture2D, assert } from '@luma.gl/webgl';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { Transform } from '@luma.gl/engine';\nimport { default as textureFilterModule } from './texture-filter';\nimport { POLY_TEX_VS, FILTER_VS } from './shaders';\nimport * as Polygon from './polygon';\nvar TEXTURE_SIZE = 512;\n\nvar GPUPointInPolygon = /*#__PURE__*/function () {\n  function GPUPointInPolygon(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GPUPointInPolygon);\n\n    this.gl = gl;\n    assert(isWebGL2(gl));\n    this.textureSize = TEXTURE_SIZE;\n\n    this._setupResources();\n\n    this.update(opts);\n  }\n\n  _createClass(GPUPointInPolygon, [{\n    key: \"update\",\n    value: function update() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          polygons = _ref.polygons,\n          textureSize = _ref.textureSize;\n\n      if (textureSize) {\n        this.textureSize = textureSize;\n      }\n\n      if (!polygons || polygons.length === 0) {\n        return;\n      }\n\n      var _triangulatePolygons = triangulatePolygons(polygons),\n          vertices = _triangulatePolygons.vertices,\n          indices = _triangulatePolygons.indices,\n          vertexCount = _triangulatePolygons.vertexCount,\n          ids = _triangulatePolygons.ids;\n\n      this._updateResources(vertices, indices, ids, vertexCount);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(_ref2) {\n      var positionBuffer = _ref2.positionBuffer,\n          filterValueIndexBuffer = _ref2.filterValueIndexBuffer,\n          count = _ref2.count;\n      this.filterTransform.update({\n        sourceBuffers: {\n          a_position: positionBuffer\n        },\n        feedbackBuffers: {\n          filterValueIndex: filterValueIndexBuffer\n        },\n        elementCount: count\n      });\n      var polygonTexture = this.polygonTexture,\n          boundingBox = this.boundingBox;\n      this.filterTransform.run({\n        moduleSettings: {\n          boundingBox: boundingBox,\n          texture: polygonTexture\n        }\n      });\n    }\n  }, {\n    key: \"_setupResources\",\n    value: function _setupResources() {\n      var _parameters;\n\n      var gl = this.gl;\n      this.polygonTexture = new Texture2D(gl, {\n        format: 6407,\n        type: 5121,\n        dataFormat: 6407,\n        border: 0,\n        mipmaps: false,\n        parameters: (_parameters = {}, _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10241, 9728), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters)\n      });\n      this.positionBuffer = new Buffer(gl, {\n        accessor: {\n          type: 5126,\n          size: 2\n        }\n      });\n      this.idBuffer = new Buffer(gl, {\n        accessor: {\n          type: 5126,\n          size: 1\n        }\n      });\n      this.indexBuffer = new Buffer(gl, {\n        target: 34963,\n        accessor: {\n          type: 5123\n        }\n      });\n      this.polyTextureTransform = new Transform(gl, {\n        id: \"polygon-texture-creation-transform\",\n        elementCount: 0,\n        _targetTexture: this.polygonTexture,\n        _targetTextureVarying: 'v_polygonColor',\n        vs: POLY_TEX_VS,\n        drawMode: 4,\n        isIndexed: true,\n        sourceBuffers: {\n          a_position: this.positionBuffer,\n          a_polygonID: this.idBuffer,\n          indices: this.indexBuffer\n        }\n      });\n      this.filterTransform = new Transform(gl, {\n        id: 'filter transform',\n        vs: FILTER_VS,\n        modules: [textureFilterModule],\n        varyings: ['filterValueIndex']\n      });\n    }\n  }, {\n    key: \"_updateResources\",\n    value: function _updateResources(vertices, indices, ids, vertexCount) {\n      var boundingBox = getBoundingBox(vertices, vertexCount);\n\n      var _boundingBox = _slicedToArray(boundingBox, 4),\n          xMin = _boundingBox[0],\n          yMin = _boundingBox[1],\n          xMax = _boundingBox[2],\n          yMax = _boundingBox[3];\n\n      var width = xMax - xMin;\n      var height = yMax - yMin;\n      var whRatio = width / height;\n      var textureSize = this.textureSize;\n      var texWidth = textureSize;\n      var texHeight = textureSize;\n\n      if (whRatio > 1) {\n        texHeight = texWidth / whRatio;\n      } else {\n        texWidth = texHeight * whRatio;\n      }\n\n      this.boundingBox = boundingBox;\n      this.polygonTexture.resize({\n        width: texWidth,\n        height: texHeight,\n        mipmaps: false\n      });\n      this.positionBuffer.setData(new Float32Array(vertices));\n      this.idBuffer.setData(new Float32Array(ids));\n      this.indexBuffer.setData(new Uint16Array(indices));\n      this.polyTextureTransform.update({\n        elementCount: indices.length,\n        _targetTexture: this.polygonTexture\n      });\n      this.polyTextureTransform.run({\n        uniforms: {\n          boundingBoxOriginSize: [xMin, yMin, width, height]\n        }\n      });\n    }\n  }]);\n\n  return GPUPointInPolygon;\n}();\n\nexport { GPUPointInPolygon as default };\n\nfunction getBoundingBox(positions, vertexCount) {\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n\n  for (var i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  var SIZE = 2;\n  var vertices = [];\n  var indices = [];\n  var ids = [];\n  var count = 0;\n  var polygonId = 0;\n\n  for (var i = 0; i < polygons.length; i++) {\n    var normalized = Polygon.normalize(polygons[i], SIZE);\n    var curVertices = normalized.positions || normalized;\n    var curCount = curVertices.length / SIZE;\n    var curIds = new Array(curCount).fill(polygonId);\n    vertices.push.apply(vertices, _toConsumableArray(curVertices));\n    ids.push.apply(ids, _toConsumableArray(curIds));\n    var curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    var indexCount = curIndices.length;\n\n    for (var j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n\n    count += curCount;\n    indices.push.apply(indices, _toConsumableArray(curIndices));\n    polygonId++;\n  }\n\n  assert(count < 65536);\n  var vertexCount = Polygon.getVertexCount(vertices, SIZE);\n  return {\n    vertices: vertices,\n    indices: indices,\n    ids: ids,\n    vertexCount: vertexCount\n  };\n}","map":{"version":3,"sources":["../../../../src/gpgpu/point-in-polygon/gpu-point-in-polygon.js"],"names":["default","TEXTURE_SIZE","constructor","opts","assert","isWebGL2","textureSize","polygons","ids","triangulatePolygons","count","sourceBuffers","a_position","positionBuffer","feedbackBuffers","filterValueIndex","filterValueIndexBuffer","elementCount","boundingBox","moduleSettings","texture","polygonTexture","gl","format","type","dataFormat","border","mipmaps","parameters","accessor","size","target","id","_targetTexture","_targetTextureVarying","vs","drawMode","isIndexed","a_polygonID","indices","indexBuffer","modules","varyings","getBoundingBox","width","xMax","height","yMax","whRatio","texWidth","texHeight","uniforms","boundingBoxOriginSize","yMin","xMin","i","x","positions","y","SIZE","vertices","polygonId","normalized","Polygon","curVertices","curCount","curIds","curIndices","indexCount","j","vertexCount"],"mappings":"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","sourcesContent":["// @ts-nocheck TODO remove\n\nimport GL from '@luma.gl/constants';\nimport {Buffer, Texture2D, assert} from '@luma.gl/webgl';\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {Transform} from '@luma.gl/engine';\nimport {default as textureFilterModule} from './texture-filter';\nimport {POLY_TEX_VS, FILTER_VS} from './shaders';\nimport * as Polygon from './polygon';\nconst TEXTURE_SIZE = 512;\n\nexport default class GPUPointInPolygon {\n  constructor(gl, opts = {}) {\n    this.gl = gl;\n    assert(isWebGL2(gl)); // supports WebGL2 only\n    this.textureSize = TEXTURE_SIZE;\n    this._setupResources();\n    this.update(opts);\n  }\n\n  update({polygons, textureSize} = {}) {\n    if (textureSize) {\n      this.textureSize = textureSize;\n    }\n    if (!polygons || polygons.length === 0) {\n      return;\n    }\n\n    const {vertices, indices, vertexCount, ids} = triangulatePolygons(polygons);\n    this._updateResources(vertices, indices, ids, vertexCount);\n  }\n\n  filter({positionBuffer, filterValueIndexBuffer, count}) {\n    this.filterTransform.update({\n      sourceBuffers: {\n        a_position: positionBuffer\n      },\n      feedbackBuffers: {\n        filterValueIndex: filterValueIndexBuffer\n      },\n      elementCount: count\n    });\n    const {polygonTexture, boundingBox} = this;\n\n    this.filterTransform.run({\n      moduleSettings: {boundingBox, texture: polygonTexture}\n    });\n  }\n\n  // PRIVATE\n\n  _setupResources() {\n    const {gl} = this;\n\n    // texture to render polygons to\n    this.polygonTexture = new Texture2D(gl, {\n      format: GL.RGB,\n      type: GL.UNSIGNED_BYTE,\n      dataFormat: GL.RGB,\n      border: 0,\n      mipmaps: false,\n      parameters: {\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n    this.positionBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 2}});\n    this.idBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 1}});\n    this.indexBuffer = new Buffer(gl, {\n      target: GL.ELEMENT_ARRAY_BUFFER,\n      accessor: {type: GL.UNSIGNED_SHORT}\n    });\n\n    // transform to generate polygon texture\n    this.polyTextureTransform = new Transform(gl, {\n      id: `polygon-texture-creation-transform`,\n      elementCount: 0,\n      _targetTexture: this.polygonTexture,\n      _targetTextureVarying: 'v_polygonColor',\n      vs: POLY_TEX_VS,\n      drawMode: GL.TRIANGLES,\n      isIndexed: true,\n      sourceBuffers: {\n        a_position: this.positionBuffer,\n        a_polygonID: this.idBuffer,\n        indices: this.indexBuffer\n      }\n    });\n\n    // transform to perform filtering\n    this.filterTransform = new Transform(gl, {\n      id: 'filter transform',\n      vs: FILTER_VS,\n      modules: [textureFilterModule],\n      varyings: ['filterValueIndex']\n    });\n  }\n\n  _updateResources(vertices, indices, ids, vertexCount) {\n    const boundingBox = getBoundingBox(vertices, vertexCount);\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const width = xMax - xMin;\n    const height = yMax - yMin;\n    const whRatio = width / height;\n    const {textureSize} = this;\n\n    // calculate max texture size with same aspect ratio\n    let texWidth = textureSize;\n    let texHeight = textureSize;\n    if (whRatio > 1) {\n      texHeight = texWidth / whRatio;\n    } else {\n      texWidth = texHeight * whRatio;\n    }\n\n    this.boundingBox = boundingBox;\n    this.polygonTexture.resize({width: texWidth, height: texHeight, mipmaps: false});\n    this.positionBuffer.setData(new Float32Array(vertices));\n    this.idBuffer.setData(new Float32Array(ids));\n    this.indexBuffer.setData(new Uint16Array(indices));\n    this.polyTextureTransform.update({\n      elementCount: indices.length,\n      _targetTexture: this.polygonTexture\n    });\n\n    this.polyTextureTransform.run({\n      uniforms: {\n        boundingBoxOriginSize: [xMin, yMin, width, height]\n      }\n    });\n  }\n}\n\n// Helper methods\n\nfunction getBoundingBox(positions, vertexCount) {\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  const SIZE = 2;\n  const vertices = [];\n  const indices = [];\n  const ids = [];\n  let count = 0;\n  let polygonId = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    const normalized = Polygon.normalize(polygons[i], SIZE);\n    const curVertices = normalized.positions || normalized;\n    const curCount = curVertices.length / SIZE;\n    const curIds = new Array(curCount).fill(polygonId);\n    vertices.push(...curVertices);\n    ids.push(...curIds);\n    const curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    const indexCount = curIndices.length;\n    for (let j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n    count += curCount;\n    indices.push(...curIndices);\n    polygonId++;\n  }\n\n  // UInt16 (UNSIGNED_SHORT) buffer is used for indices\n  assert(count < 65536); // 0xFFFF\n\n  const vertexCount = Polygon.getVertexCount(vertices, SIZE);\n\n  return {vertices, indices, ids, vertexCount};\n}\n"]},"metadata":{},"sourceType":"module"}