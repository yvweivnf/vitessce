{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n  var markDef = model.markDef,\n      config = model.config;\n  var enableAria = getMarkPropOrConfig('aria', markDef, config); // We can ignore other aria properties if ariaHidden is true.\n\n  if (enableAria === false) {\n    // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n    return {};\n  }\n\n  return Object.assign(Object.assign(Object.assign({}, enableAria ? {\n    aria: enableAria\n  } : {}), ariaRoleDescription(model)), description(model));\n}\n\nfunction ariaRoleDescription(model) {\n  var mark = model.mark,\n      markDef = model.markDef,\n      config = model.config;\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  var ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n\n  if (ariaRoleDesc != null) {\n    return {\n      ariaRoleDescription: {\n        value: ariaRoleDesc\n      }\n    };\n  }\n\n  return mark in VG_MARK_INDEX ? {} : {\n    ariaRoleDescription: {\n      value: mark\n    }\n  };\n}\n\nexport function description(model) {\n  var encoding = model.encoding,\n      markDef = model.markDef,\n      config = model.config,\n      stack = model.stack;\n  var channelDef = encoding.description;\n\n  if (channelDef) {\n    return wrapCondition(model, channelDef, 'description', function (cDef) {\n      return textRef(cDef, model.config);\n    });\n  } // Use default from mark def or config if defined.\n  // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n\n\n  var descriptionValue = getMarkPropOrConfig('description', markDef, config);\n\n  if (descriptionValue != null) {\n    return {\n      description: signalOrValueRef(descriptionValue)\n    };\n  }\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  var data = tooltipData(encoding, stack, config);\n\n  if (isEmpty(data)) {\n    return undefined;\n  }\n\n  return {\n    description: {\n      signal: entries(data).map(function (_ref, index) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        return \"\\\"\".concat(index > 0 ? '; ' : '').concat(key, \": \\\" + (\").concat(value, \")\");\n      }).join(' + ')\n    }\n  };\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/aria.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n    const { markDef, config } = model;\n    const enableAria = getMarkPropOrConfig('aria', markDef, config);\n    // We can ignore other aria properties if ariaHidden is true.\n    if (enableAria === false) {\n        // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n        return {};\n    }\n    return Object.assign(Object.assign(Object.assign({}, (enableAria ? { aria: enableAria } : {})), ariaRoleDescription(model)), description(model));\n}\nfunction ariaRoleDescription(model) {\n    const { mark, markDef, config } = model;\n    if (config.aria === false) {\n        return {};\n    }\n    const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n    if (ariaRoleDesc != null) {\n        return { ariaRoleDescription: { value: ariaRoleDesc } };\n    }\n    return mark in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark } };\n}\nexport function description(model) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding.description;\n    if (channelDef) {\n        return wrapCondition(model, channelDef, 'description', cDef => textRef(cDef, model.config));\n    }\n    // Use default from mark def or config if defined.\n    // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n    const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n    if (descriptionValue != null) {\n        return {\n            description: signalOrValueRef(descriptionValue)\n        };\n    }\n    if (config.aria === false) {\n        return {};\n    }\n    const data = tooltipData(encoding, stack, config);\n    if (isEmpty(data)) {\n        return undefined;\n    }\n    return {\n        description: {\n            signal: entries(data)\n                .map(([key, value], index) => `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`)\n                .join(' + ')\n        }\n    };\n}\n//# sourceMappingURL=aria.js.map"]},"metadata":{},"sourceType":"module"}