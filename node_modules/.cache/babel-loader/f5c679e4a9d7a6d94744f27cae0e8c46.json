{"ast":null,"code":"import { Layer, fp64LowPart, project32, gouraudLighting, picking } from '@deck.gl/core';\nimport { Model, CubeGeometry } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  gridSize: {\n    type: 'array',\n    min: 0,\n    value: [1, 1]\n  },\n  gridOrigin: {\n    type: 'array',\n    min: 0,\n    value: [0, 0]\n  },\n  gridOffset: {\n    type: 'array',\n    min: 0,\n    value: [0, 0]\n  },\n  cellSize: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 1000\n  },\n  offset: {\n    type: 'array',\n    min: 0,\n    value: [1, 1]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  extruded: true,\n  material: true\n};\nexport default class GPUGridCellLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking, fp64arithmetic]\n    });\n  }\n\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      colors: {\n        size: 4,\n        noAlloc: true\n      },\n      elevations: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n\n    const model = this._getModel(gl);\n\n    this._setupUniformBuffer(model);\n\n    this.setState({\n      model\n    });\n  }\n\n  _getModel(gl) {\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    });\n  }\n\n  draw(_ref) {\n    let {\n      uniforms\n    } = _ref;\n    const {\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOffset,\n      elevationRange,\n      colorMaxMinBuffer,\n      elevationMaxMinBuffer\n    } = this.props;\n    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n    const domainUniforms = this.getDomainUniforms();\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    this.state.model.setUniforms(uniforms).setUniforms(domainUniforms).setUniforms({\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOriginLow,\n      gridOffset,\n      gridOffsetLow,\n      colorRange,\n      elevationRange\n    }).draw();\n    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n  }\n\n  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.bind({\n      target: 35345,\n      index: COLOR_DATA_UBO_INDEX\n    });\n    elevationMaxMinBuffer.bind({\n      target: 35345,\n      index: ELEVATION_DATA_UBO_INDEX\n    });\n  }\n\n  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.unbind({\n      target: 35345,\n      index: COLOR_DATA_UBO_INDEX\n    });\n    elevationMaxMinBuffer.unbind({\n      target: 35345,\n      index: ELEVATION_DATA_UBO_INDEX\n    });\n  }\n\n  getDomainUniforms() {\n    const {\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const domainUniforms = {};\n\n    if (colorDomain !== null) {\n      domainUniforms.colorDomainValid = true;\n      domainUniforms.colorDomain = colorDomain;\n    } else {\n      domainUniforms.colorDomainValid = false;\n    }\n\n    if (elevationDomain !== null) {\n      domainUniforms.elevationDomainValid = true;\n      domainUniforms.elevationDomain = elevationDomain;\n    } else {\n      domainUniforms.elevationDomainValid = false;\n    }\n\n    return domainUniforms;\n  }\n\n  _setupUniformBuffer(model) {\n    const gl = this.context.gl;\n    const programHandle = model.program.handle;\n    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n  }\n\n}\nGPUGridCellLayer.layerName = 'GPUGridCellLayer';\nGPUGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/gpu-grid-layer/gpu-grid-cell-layer.js"],"names":["COLOR_DATA_UBO_INDEX","ELEVATION_DATA_UBO_INDEX","defaultProps","colorDomain","colorRange","elevationDomain","elevationRange","elevationScale","type","min","value","gridSize","gridOrigin","gridOffset","cellSize","max","offset","coverage","extruded","material","getShaders","modules","initializeState","gl","attributeManager","colors","size","noAlloc","elevations","model","_getModel","id","geometry","isInstanced","draw","uniforms","elevationMaxMinBuffer","gridOriginLow","fp64LowPart","gridOffsetLow","domainUniforms","colorRangeToFlatArray","bindUniformBuffers","colorMaxMinBuffer","target","index","unbindUniformBuffers","getDomainUniforms","_setupUniformBuffer","programHandle","colorIndex","elevationIndex","GPUGridCellLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, fp64LowPart, project32, gouraudLighting, picking} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, CubeGeometry} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\n\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\n\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\n\nconst defaultProps = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  gridSize: {type: 'array', min: 0, value: [1, 1]},\n  gridOrigin: {type: 'array', min: 0, value: [0, 0]},\n  gridOffset: {type: 'array', min: 0, value: [0, 0]},\n\n  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},\n  offset: {type: 'array', min: 0, value: [1, 1]},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: true,\n\n  material: true // Use lighting module defaults\n};\n\nexport default class GPUGridCellLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking, fp64arithmetic]\n    });\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      colors: {\n        size: 4,\n        noAlloc: true\n      },\n      elevations: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    const model = this._getModel(gl);\n    this._setupUniformBuffer(model);\n    this.setState({model});\n  }\n\n  _getModel(gl) {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    });\n  }\n\n  draw({uniforms}) {\n    const {\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOffset,\n      elevationRange,\n      colorMaxMinBuffer,\n      elevationMaxMinBuffer\n    } = this.props;\n\n    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n    const domainUniforms = this.getDomainUniforms();\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms(domainUniforms)\n      .setUniforms({\n        cellSize,\n        offset,\n        extruded,\n        elevationScale,\n        coverage,\n        gridSize,\n        gridOrigin,\n        gridOriginLow,\n        gridOffset,\n        gridOffsetLow,\n        colorRange,\n        elevationRange\n      })\n      .draw();\n    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n  }\n\n  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  getDomainUniforms() {\n    const {colorDomain, elevationDomain} = this.props;\n    const domainUniforms = {};\n    if (colorDomain !== null) {\n      domainUniforms.colorDomainValid = true;\n      domainUniforms.colorDomain = colorDomain;\n    } else {\n      domainUniforms.colorDomainValid = false;\n    }\n    if (elevationDomain !== null) {\n      domainUniforms.elevationDomainValid = true;\n      domainUniforms.elevationDomain = elevationDomain;\n    } else {\n      domainUniforms.elevationDomainValid = false;\n    }\n    return domainUniforms;\n  }\n\n  _setupUniformBuffer(model) {\n    const gl = this.context.gl;\n    const programHandle = model.program.handle;\n\n    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n  }\n}\n\nGPUGridCellLayer.layerName = 'GPUGridCellLayer';\nGPUGridCellLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}