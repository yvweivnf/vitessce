{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { array } from 'vega-util';\nimport { isConditionalDef, isConditionalParameter } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\n\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n  var condition = isConditionalDef(channelDef) && channelDef.condition;\n  var valueRef = refFn(channelDef);\n\n  if (condition) {\n    var conditions = array(condition);\n    var vgConditions = conditions.map(function (c) {\n      var conditionValueRef = refFn(c);\n\n      if (isConditionalParameter(c)) {\n        var param = c.param,\n            empty = c.empty;\n        var test = parseSelectionPredicate(model, {\n          param: param,\n          empty: empty\n        });\n        return Object.assign({\n          test: test\n        }, conditionValueRef);\n      } else {\n        var _test = expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n\n\n        return Object.assign({\n          test: _test\n        }, conditionValueRef);\n      }\n    });\n    return _defineProperty({}, vgChannel, [].concat(_toConsumableArray(vgConditions), _toConsumableArray(valueRef !== undefined ? [valueRef] : [])));\n  } else {\n    return valueRef !== undefined ? _defineProperty({}, vgChannel, valueRef) : {};\n  }\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/conditional.ts"],"names":[],"mappings":";;AAAA,SAAQ,KAAR,QAAoB,WAApB;AACA,SAA0C,gBAA1C,EAA4D,sBAA5D,QAAyF,qBAAzF;AAGA,SAAQ,UAAR,QAAyB,iBAAzB;AACA,SAAQ,uBAAR,QAAsC,uBAAtC;AAGA;;;;;AAIA,OAAM,SAAU,aAAV,CACJ,KADI,EAEJ,UAFI,EAGJ,SAHI,EAIJ,KAJI,EAI2B;AAE/B,MAAM,SAAS,GAAG,gBAAgB,CAAK,UAAL,CAAhB,IAAoC,UAAU,CAAC,SAAjE;AACA,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAD,CAAtB;;AACA,MAAI,SAAJ,EAAe;AACb,QAAM,UAAU,GAAG,KAAK,CAAC,SAAD,CAAxB;AACA,QAAM,YAAY,GAAG,UAAU,CAAC,GAAX,CAAe,UAAA,CAAC,EAAG;AACtC,UAAM,iBAAiB,GAAG,KAAK,CAAC,CAAD,CAA/B;;AACA,UAAI,sBAAsB,CAAM,CAAN,CAA1B,EAAoC;AAAA,YAC3B,KAD2B,GACX,CADW,CAC3B,KAD2B;AAAA,YACpB,KADoB,GACX,CADW,CACpB,KADoB;AAElC,YAAM,IAAI,GAAG,uBAAuB,CAAC,KAAD,EAAQ;AAAC,UAAA,KAAK,EAAL,KAAD;AAAQ,UAAA,KAAK,EAAL;AAAR,SAAR,CAApC;AACA,eAAA,MAAA,CAAA,MAAA,CAAA;AAAQ,UAAA,IAAI,EAAJ;AAAR,SAAA,EAAiB,iBAAjB,CAAA;AACD,OAJD,MAIO;AACL,YAAM,KAAI,GAAG,UAAU,CAAC,KAAD,EAAS,CAA+B,CAAC,IAAzC,CAAvB,CADK,CACkE;;;AACvE,eAAA,MAAA,CAAA,MAAA,CAAA;AAAQ,UAAA,IAAI,EAAJ;AAAR,SAAA,EAAiB,iBAAjB,CAAA;AACD;AACF,KAVoB,CAArB;AAWA,+BACG,SADH,+BACmB,YADnB,sBACqC,QAAQ,KAAK,SAAb,GAAyB,CAAC,QAAD,CAAzB,GAAsC,EAD3E;AAGD,GAhBD,MAgBO;AACL,WAAO,QAAQ,KAAK,SAAb,uBAA2B,SAA3B,EAAuC,QAAvC,IAAmD,EAA1D;AACD;AACF","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { isConditionalDef, isConditionalParameter } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n    const condition = isConditionalDef(channelDef) && channelDef.condition;\n    const valueRef = refFn(channelDef);\n    if (condition) {\n        const conditions = array(condition);\n        const vgConditions = conditions.map(c => {\n            const conditionValueRef = refFn(c);\n            if (isConditionalParameter(c)) {\n                const { param, empty } = c;\n                const test = parseSelectionPredicate(model, { param, empty });\n                return Object.assign({ test }, conditionValueRef);\n            }\n            else {\n                const test = expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n                return Object.assign({ test }, conditionValueRef);\n            }\n        });\n        return {\n            [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n        };\n    }\n    else {\n        return valueRef !== undefined ? { [vgChannel]: valueRef } : {};\n    }\n}\n//# sourceMappingURL=conditional.js.map"]},"metadata":{},"sourceType":"module"}