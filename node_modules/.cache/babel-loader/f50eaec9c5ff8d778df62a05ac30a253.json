{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = require(\"events\");\n\nvar _document = _interopRequireDefault(require(\"global/document\"));\n\nvar _core = require(\"@deck.gl/core\");\n\nvar _deckDrawer = _interopRequireDefault(require(\"./deck-renderer/deck-drawer\"));\n\nvar _layerMouseEvent = _interopRequireDefault(require(\"./layer-mouse-event\"));\n\nvar _nebulaLayer = _interopRequireDefault(require(\"./nebula-layer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar LOGGER_PREFIX = 'Nebula: ';\n\nvar Nebula = /*#__PURE__*/function () {\n  function Nebula() {\n    var _this = this;\n\n    _classCallCheck(this, Nebula);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"deckgl\", void 0);\n\n    _defineProperty(this, \"mainContainer\", void 0);\n\n    _defineProperty(this, \"deckglMouseOverInfo\", void 0);\n\n    _defineProperty(this, \"_deckDrawer\", void 0);\n\n    _defineProperty(this, \"_mouseWasDown\", void 0);\n\n    _defineProperty(this, \"wmViewport\", void 0);\n\n    _defineProperty(this, \"queryObjectEvents\", new _events.EventEmitter());\n\n    _defineProperty(this, \"forceUpdate\", void 0);\n\n    _defineProperty(this, \"inited\", void 0);\n\n    _defineProperty(this, \"_onMouseEvent\", function (event) {\n      if (!_this._isNebulaEvent(event)) {\n        return;\n      }\n\n      if (event.type === 'mousedown') {\n        _this._mouseWasDown = true;\n      } // offsetX/Y of the MouseEvent provides the offset in the X/Y coordinate\n      // of the mouse pointer between that event and the padding edge of the target node.\n      // We set our listener to document so we need to adjust offsetX/Y\n      // in case the target is not be our WebGL canvas.\n\n\n      var _ref = _this.mainContainer ? _this.mainContainer.getBoundingClientRect() : {},\n          _ref$top = _ref.top,\n          top = _ref$top === void 0 ? 0 : _ref$top,\n          _ref$left = _ref.left,\n          left = _ref$left === void 0 ? 0 : _ref$left;\n\n      var proxyEvent = new Proxy(event, {\n        get: function get(original, propertyName) {\n          if (propertyName === 'offsetX') {\n            return original.pageX - left;\n          }\n\n          if (propertyName === 'offsetY') {\n            return original.pageY - top;\n          } // TODO: Properly use pointer events\n\n\n          if (propertyName === 'type') {\n            return original.type.replace('pointer', 'mouse');\n          }\n\n          var result = original[propertyName];\n\n          if (typeof result === 'function') {\n            return result.bind(original);\n          }\n\n          return result;\n        }\n      });\n\n      _this._handleDeckGLEvent(proxyEvent);\n    });\n  }\n\n  _createClass(Nebula, [{\n    key: \"init\",\n    value: function init(props) {\n      var _this2 = this;\n\n      this.props = props;\n      this.wmViewport = new _core.WebMercatorViewport(this.props.viewport); // TODO: Properly use pointer events: ['click', 'pointermove', 'pointerup', 'pointerdown']\n\n      ['click', 'mousemove', 'mouseup', 'mousedown'].forEach(function (name) {\n        return _document[\"default\"].addEventListener(name, _this2._onMouseEvent, true);\n      });\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      var _this3 = this; // TODO: Properly use pointer events: ['click', 'pointermove', 'pointerup', 'pointerdown']\n\n\n      ['click', 'mousemove', 'mouseup', 'mousedown'].forEach(function (name) {\n        return _document[\"default\"].removeEventListener(name, _this3._onMouseEvent, true);\n      });\n    }\n  }, {\n    key: \"updateProps\",\n    value: function updateProps(newProps) {\n      this.props = newProps;\n      var viewport = this.props.viewport;\n      this.wmViewport = new _core.WebMercatorViewport(viewport);\n    }\n  }, {\n    key: \"log\",\n    value: function log(message) {\n      var logger = this.props.logger;\n\n      if (logger && logger.info) {\n        logger.info(LOGGER_PREFIX + message);\n      }\n    }\n  }, {\n    key: \"updateAllDeckObjects\",\n    value: function updateAllDeckObjects() {\n      this.getAllLayers().forEach(function (layer) {\n        if (layer && layer.deckCache) {\n          layer.deckCache.updateAllDeckObjects();\n        }\n      });\n      this.forceUpdate();\n    }\n  }, {\n    key: \"updateDeckObjectsByIds\",\n    value: function updateDeckObjectsByIds(ids) {\n      this.getAllLayers().forEach(function (layer) {\n        if (layer && layer.deckCache) {\n          layer.deckCache.updateDeckObjectsByIds(ids);\n        }\n      });\n      this.forceUpdate();\n    }\n  }, {\n    key: \"rerenderLayers\",\n    value: function rerenderLayers() {\n      this.updateAllDeckObjects();\n    }\n  }, {\n    key: \"_isNebulaEvent\",\n    value: function _isNebulaEvent(_ref2) {\n      var buttons = _ref2.buttons,\n          target = _ref2.target,\n          type = _ref2.type;\n      var viewport = this.props.viewport; // allow mouseup event aggressively to cancel drag properly\n      // TODO: use pointer capture setPointerCapture() to capture mouseup properly after deckgl\n\n      if (this._mouseWasDown && type === 'mouseup') {\n        this._mouseWasDown = false;\n        return true;\n      } // allow mousemove event while dragging\n\n\n      if (type === 'mousemove' && buttons > 0) {\n        return true;\n      }\n\n      if (!target.getBoundingClientRect) {\n        return false;\n      }\n\n      var rect = target.getBoundingClientRect(); // Only listen to events coming from the basemap\n      // identified by the canvas of the same size as viewport.\n      // Need to round the rect dimension as some monitors\n      // have some sub-pixel difference with viewport.\n\n      return Math.round(rect.width) === Math.round(viewport.width) && Math.round(rect.height) === Math.round(viewport.height);\n    }\n  }, {\n    key: \"getMouseGroundPosition\",\n    value: function getMouseGroundPosition(event) {\n      return this.wmViewport.unproject([event.offsetX, event.offsetY]);\n    }\n  }, {\n    key: \"unprojectMousePosition\",\n    value: function unprojectMousePosition(mousePosition) {\n      // @ts-ignore\n      return this.wmViewport.unproject(mousePosition);\n    }\n  }, {\n    key: \"_handleDeckGLEvent\",\n    value: function _handleDeckGLEvent(event) {\n      var deckgl = this.deckgl,\n          _this$props = this.props,\n          onMapMouseEvent = _this$props.onMapMouseEvent,\n          selectionType = _this$props.selectionType,\n          eventFilter = _this$props.eventFilter;\n      var sendMapEvent = true;\n      var cursor = 'auto';\n\n      if (event && deckgl && selectionType) {\n        if (!this._deckDrawer) this._deckDrawer = new _deckDrawer[\"default\"](this);\n        var lngLat = this.getMouseGroundPosition(event);\n        if (eventFilter && !eventFilter(lngLat, event)) return; // @ts-ignore\n\n        var drawerResult = this._deckDrawer.handleEvent(event, lngLat, selectionType);\n\n        if (drawerResult.redraw) this.forceUpdate();\n        return;\n      }\n\n      if (event && deckgl && (!event.buttons || event.type !== 'mousemove')) {\n        // TODO: sort by mouse priority\n        var layerIds = deckgl.props.layers.filter(function (l) {\n          return l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enablePicking;\n        }).map(function (l) {\n          return l.id;\n        });\n        var pickingInfo = deckgl.pickObject({\n          x: event.offsetX,\n          y: event.offsetY,\n          radius: 5,\n          layerIds: layerIds\n        });\n        this.queryObjectEvents.emit('pick', {\n          event: event,\n          pickingInfo: pickingInfo\n        });\n\n        if (pickingInfo) {\n          sendMapEvent = false;\n          var index = pickingInfo.index,\n              _lngLat = pickingInfo.lngLat;\n          if (eventFilter && !eventFilter(_lngLat, event)) return;\n          var deckLayer = pickingInfo.layer,\n              object = pickingInfo.object;\n\n          if (deckLayer && deckLayer.props && deckLayer.props.nebulaLayer && deckLayer.props.nebulaLayer.eventHandler) {\n            deckLayer.props.nebulaLayer.eventHandler(event, pickingInfo);\n          }\n\n          var original = object.original || deckLayer.props.nebulaLayer && deckLayer.props.nebulaLayer.deckCache && deckLayer.props.nebulaLayer.deckCache.originals[index];\n\n          if (original) {\n            this.deckglMouseOverInfo = {\n              originalLayer: deckLayer.props.nebulaLayer,\n              index: index\n            }; // @ts-ignore\n\n            var nebulaMouseEvent = new _layerMouseEvent[\"default\"](event, {\n              data: original,\n              metadata: object.metadata,\n              groundPoint: _lngLat,\n              nebula: this\n            });\n            deckLayer.props.nebulaLayer.emit(event.type, nebulaMouseEvent);\n            this.forceUpdate();\n          }\n\n          cursor = 'pointer';\n        }\n      }\n\n      if (_document[\"default\"].documentElement) {\n        _document[\"default\"].documentElement.style.cursor = cursor;\n      }\n\n      if (sendMapEvent) {\n        this.deckglMouseOverInfo = null;\n\n        var _lngLat2 = this.getMouseGroundPosition(event);\n\n        if (eventFilter && !eventFilter(_lngLat2, event)) return; // send to layers first\n        // @ts-ignore\n\n        var _nebulaMouseEvent = new _layerMouseEvent[\"default\"](event, {\n          groundPoint: _lngLat2,\n          nebula: this\n        });\n\n        this.getAllLayers().filter(function (layer) {\n          return layer && layer.usesMapEvents;\n        }).forEach(function (layer) {\n          return layer.emit('mapMouseEvent', _nebulaMouseEvent);\n        });\n        this.getAllLayers().filter(function (layer) {\n          return layer && layer.props && layer.props.nebulaLayer && layer.props.nebulaLayer.mapMouseEvent;\n        }).forEach(function (layer) {\n          return layer.props.nebulaLayer.mapMouseEvent(_nebulaMouseEvent, layer);\n        });\n\n        if (onMapMouseEvent) {\n          onMapMouseEvent(event, _lngLat2);\n        }\n      }\n    }\n  }, {\n    key: \"getExtraDeckLayers\",\n    value: function getExtraDeckLayers() {\n      var result = [];\n      if (this._deckDrawer) result.push.apply(result, _toConsumableArray(this._deckDrawer.render()));\n      return result;\n    }\n  }, {\n    key: \"renderDeckLayers\",\n    value: function renderDeckLayers() {\n      var _this4 = this;\n\n      return this.getAllLayers().map(function (layer) {\n        return layer instanceof _nebulaLayer[\"default\"] ? layer.render({\n          nebula: _this4\n        }) : layer;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"getAllLayers\",\n    value: function getAllLayers() {\n      var result = [];\n      this.props.layers.filter(Boolean).forEach(function (layer) {\n        result.push(layer); // Only NebulaLayers have helpers, Deck GL layers don't.\n\n        if (layer instanceof _nebulaLayer[\"default\"]) {\n          result.push.apply(result, _toConsumableArray(layer.helperLayers));\n        }\n      });\n      return result.filter(Boolean);\n    }\n  }, {\n    key: \"getRenderedLayers\",\n    value: function getRenderedLayers() {\n      return [].concat(_toConsumableArray(this.renderDeckLayers()), _toConsumableArray(this.getExtraDeckLayers()));\n    }\n  }, {\n    key: \"updateAndGetRenderedLayers\",\n    value: function updateAndGetRenderedLayers(layers, viewport, container) {\n      if (this.inited) {\n        this.updateProps({\n          layers: layers,\n          viewport: viewport\n        });\n\n        this.forceUpdate = function () {\n          return container.forceUpdate();\n        };\n      } else {\n        this.inited = true;\n        this.init({\n          layers: layers,\n          viewport: viewport\n        });\n\n        this.forceUpdate = function () {\n          return container.forceUpdate();\n        };\n\n        this.updateAllDeckObjects();\n      }\n\n      return this.getRenderedLayers();\n    }\n  }, {\n    key: \"setDeck\",\n    value: function setDeck(deckgl) {\n      if (deckgl) {\n        this.deckgl = deckgl;\n      }\n    }\n  }, {\n    key: \"setMainContainer\",\n    value: function setMainContainer(mainContainer) {\n      if (mainContainer) {\n        this.mainContainer = mainContainer;\n      }\n    }\n  }]);\n\n  return Nebula;\n}();\n\nexports[\"default\"] = Nebula;","map":{"version":3,"sources":["../../src/lib/nebula.ts"],"names":["LOGGER_PREFIX","Nebula","props","WebMercatorViewport","document","newProps","viewport","EventEmitter","message","logger","layer","ids","buttons","target","type","rect","Math","event","top","left","proxyEvent","get","propertyName","original","result","mousePosition","deckgl","onMapMouseEvent","selectionType","eventFilter","sendMapEvent","cursor","DeckDrawer","lngLat","drawerResult","layerIds","l","pickingInfo","x","y","radius","index","deckLayer","object","originalLayer","nebulaMouseEvent","LayerMouseEvent","data","metadata","groundPoint","nebula","NebulaLayer","layers","container","mainContainer"],"mappings":";;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAA,SAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AAEA,IAAA,KAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,IAAA,WAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,6BAAA,CAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,qBAAA,CAAA,CAAA;;AACA,IAAA,YAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,aAAa,GAAnB,UAAA;;IAEqBC,M;;;;;;;;;;;;;;;;;;;;+CAgCe,IAAIM,OAAAA,CAAJ,YAAA,E;;;;;;2CA+DlB,UAAA,KAAA,EAA8B;AAC5C,UAAI,CAAC,KAAI,CAAJ,cAAA,CAAL,KAAK,CAAL,EAAiC;AAC/B;AACD;;AAED,UAAIU,KAAK,CAALA,IAAAA,KAAJ,WAAA,EAAgC;AAC9B,QAAA,KAAI,CAAJ,aAAA,GAAA,IAAA;AAN0C,OAAA,CAS5C;AACA;AACA;AACA;;;AAZ4C,UAAA,IAAA,GAad,KAAI,CAAJ,aAAA,GAC1B,KAAI,CAAJ,aAAA,CAD0B,qBAC1B,EAD0B,GAbc,EAAA;AAAA,UAAA,QAAA,GAAA,IAAA,CAAA,GAAA;AAAA,UAapCC,GAboC,GAAA,QAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,QAAA;AAAA,UAAA,SAAA,GAAA,IAAA,CAAA,IAAA;AAAA,UAa3BC,IAb2B,GAAA,SAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,SAAA;;AAgB5C,UAAMC,UAAU,GAAG,IAAA,KAAA,CAAA,KAAA,EAAiB;AAClCC,QAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,QAAA,EAAA,YAAA,EAAyC;AAC5C,cAAIC,YAAY,KAAhB,SAAA,EAAgC;AAC9B,mBAAOC,QAAQ,CAARA,KAAAA,GAAP,IAAA;AACD;;AAED,cAAID,YAAY,KAAhB,SAAA,EAAgC;AAC9B,mBAAOC,QAAQ,CAARA,KAAAA,GAAP,GAAA;AAN0C,WAAA,CAS5C;;;AACA,cAAID,YAAY,KAAhB,MAAA,EAA6B;AAC3B,mBAAOC,QAAQ,CAARA,IAAAA,CAAAA,OAAAA,CAAAA,SAAAA,EAAP,OAAOA,CAAP;AACD;;AAED,cAAMC,MAAM,GAAGD,QAAQ,CAAvB,YAAuB,CAAvB;;AACA,cAAI,OAAA,MAAA,KAAJ,UAAA,EAAkC;AAChC,mBAAOC,MAAM,CAANA,IAAAA,CAAP,QAAOA,CAAP;AACD;;AACD,iBAAA,MAAA;AACD;AApBiC,OAAjB,CAAnB;;AAuBA,MAAA,KAAI,CAAJ,kBAAA,CAAA,UAAA;;;;;;yBArIGtB,K,EAA4B;AAAA,UAAA,MAAA,GAAA,IAAA;;AAC/B,WAAA,KAAA,GAAA,KAAA;AACA,WAAA,UAAA,GAAkB,IAAIC,KAAAA,CAAJ,mBAAA,CAAwB,KAAA,KAAA,CAFX,QAEb,CAAlB,CAF+B,CAI/B;;AACA,OAAA,OAAA,EAAA,WAAA,EAAA,SAAA,EAAA,WAAA,EAAA,OAAA,CAAuD,UAAA,IAAA,EAAA;AAAA,eACrDC,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,gBAAAA,CAAAA,IAAAA,EAAgC,MAAI,CAApCA,aAAAA,EADqD,IACrDA,CADqD;AAAvD,OAAA;AAGD;;;6BAEQ;AAAA,UAAA,MAAA,GAAA,IAAA,CAAA,CACP;;;AACA,OAAA,OAAA,EAAA,WAAA,EAAA,SAAA,EAAA,WAAA,EAAA,OAAA,CAAuD,UAAA,IAAA,EAAA;AAAA,eACrDA,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,mBAAAA,CAAAA,IAAAA,EAAmC,MAAI,CAAvCA,aAAAA,EADqD,IACrDA,CADqD;AAAvD,OAAA;AAGD;;;gCAEWC,Q,EAA+B;AACzC,WAAA,KAAA,GAAA,QAAA;AADyC,UAEjCC,QAFiC,GAEpB,KAFoB,KAEpB,CAFoB,QAAA;AAIzC,WAAA,UAAA,GAAkB,IAAIH,KAAAA,CAAJ,mBAAA,CAAlB,QAAkB,CAAlB;AACD;;;wBAaGK,O,EAAiB;AAAA,UACXC,MADW,GACA,KADA,KACA,CADA,MAAA;;AAEnB,UAAIA,MAAM,IAAIA,MAAM,CAApB,IAAA,EAA2B;AACzBA,QAAAA,MAAM,CAANA,IAAAA,CAAYT,aAAa,GAAzBS,OAAAA;AACD;AACF;;;2CAEsB;AACrB,WAAA,YAAA,GAAA,OAAA,CAA4B,UAAA,KAAA,EAAW;AACrC,YAAIC,KAAK,IAAIA,KAAK,CAAlB,SAAA,EAA8B;AAC3BA,UAAAA,KAAK,CAAN,SAACA,CAAD,oBAACA;AACF;AAHH,OAAA;AAKA,WAAA,WAAA;AACD;;;2CAEsBC,G,EAAe;AACpC,WAAA,YAAA,GAAA,OAAA,CAA4B,UAAA,KAAA,EAAW;AACrC,YAAID,KAAK,IAAIA,KAAK,CAAlB,SAAA,EAA8B;AAC3BA,UAAAA,KAAK,CAAN,SAACA,CAAD,sBAACA,CAAD,GAACA;AACF;AAHH,OAAA;AAKA,WAAA,WAAA;AACD;;;qCAEgB;AACf,WAAA,oBAAA;AACD;;;0CAE8D;AAAA,UAA9CE,OAA8C,GAAA,KAAA,CAA9CA,OAA8C;AAAA,UAArCC,MAAqC,GAAA,KAAA,CAArCA,MAAqC;AAAA,UAA7BC,IAA6B,GAAA,KAAA,CAA7BA,IAA6B;AAAA,UACrDR,QADqD,GACxC,KADwC,KACxC,CADwC,QAAA,CAAA,CAG7D;AACA;;AACA,UAAI,KAAA,aAAA,IAAsBQ,IAAI,KAA9B,SAAA,EAA8C;AAC5C,aAAA,aAAA,GAAA,KAAA;AACA,eAAA,IAAA;AAP2D,OAAA,CAU7D;;;AACA,UAAIA,IAAI,KAAJA,WAAAA,IAAwBF,OAAO,GAAnC,CAAA,EAAyC;AACvC,eAAA,IAAA;AACD;;AAED,UAAI,CAACC,MAAM,CAAX,qBAAA,EAAmC;AACjC,eAAA,KAAA;AACD;;AAED,UAAME,IAAI,GAAGF,MAAM,CAnB0C,qBAmBhDA,EAAb,CAnB6D,CAoB7D;AACA;AACA;AACA;;AACA,aACEG,IAAI,CAAJA,KAAAA,CAAWD,IAAI,CAAfC,KAAAA,MAA2BA,IAAI,CAAJA,KAAAA,CAAWV,QAAQ,CAA9CU,KAA2BA,CAA3BA,IACAA,IAAI,CAAJA,KAAAA,CAAWD,IAAI,CAAfC,MAAAA,MAA4BA,IAAI,CAAJA,KAAAA,CAAWV,QAAQ,CAFjD,MAE8BU,CAF9B;AAID;;;2CA4CsBC,K,EAA4B;AACjD,aAAO,KAAA,UAAA,CAAA,SAAA,CAA0B,CAACA,KAAK,CAAN,OAAA,EAAgBA,KAAK,CAAtD,OAAiC,CAA1B,CAAP;AACD;;;2CAEsBQ,a,EAAmD;AACxE;AACA,aAAO,KAAA,UAAA,CAAA,SAAA,CAAP,aAAO,CAAP;AACD;;;uCAEkBR,K,EAA4B;AAAA,UAE3CS,MAF2C,GAAA,KAAA,MAAA;AAAA,UAAA,WAAA,GAAA,KAAA,KAAA;AAAA,UAGlCC,eAHkC,GAAA,WAAA,CAAA,eAAA;AAAA,UAGjBC,aAHiB,GAAA,WAAA,CAAA,aAAA;AAAA,UAGFC,WAHE,GAAA,WAAA,CAAA,WAAA;AAK7C,UAAIC,YAAY,GAAhB,IAAA;AACA,UAAIC,MAAM,GAAV,MAAA;;AAEA,UAAId,KAAK,IAALA,MAAAA,IAAJ,aAAA,EAAsC;AACpC,YAAI,CAAC,KAAL,WAAA,EAAuB,KAAA,WAAA,GAAmB,IAAIe,WAAAA,CAAJ,SAAIA,CAAJ,CAAnB,IAAmB,CAAnB;AAEvB,YAAMC,MAAM,GAAG,KAAA,sBAAA,CAAf,KAAe,CAAf;AACA,YAAIJ,WAAW,IAAI,CAACA,WAAW,CAAA,MAAA,EAA/B,KAA+B,CAA/B,EAJoC,OAAA,CAKpC;;AACA,YAAMK,YAAY,GAAG,KAAA,WAAA,CAAA,WAAA,CAAA,KAAA,EAAA,MAAA,EAArB,aAAqB,CAArB;;AACA,YAAIA,YAAY,CAAhB,MAAA,EAAyB,KAAA,WAAA;AACzB;AACD;;AAED,UAAIjB,KAAK,IAALA,MAAAA,KAAoB,CAACA,KAAK,CAAN,OAAA,IAAkBA,KAAK,CAALA,IAAAA,KAA1C,WAAIA,CAAJ,EAAuE;AACrE;AACA,YAAMkB,QAAQ,GAAG,MAAM,CAAN,KAAA,CAAA,MAAA,CAAA,MAAA,CAEb,UAAA,CAAA,EAAA;AAAA,iBAAYC,CAAC,IAAIA,CAAC,CAANA,KAAAA,IAAgBA,CAAC,CAADA,KAAAA,CAAhBA,WAAAA,IAAuCA,CAAC,CAADA,KAAAA,CAAAA,WAAAA,CAAnD,aAAA;AAFa,SAAA,EAAA,GAAA,CAIV,UAAA,CAAA,EAAA;AAAA,iBAAYA,CAAC,CAAb,EAAA;AAJP,SAAiB,CAAjB;AAMA,YAAMC,WAAW,GAAG,MAAM,CAAN,UAAA,CAAkB;AACpCC,UAAAA,CAAC,EAAErB,KAAK,CAD4B,OAAA;AAEpCsB,UAAAA,CAAC,EAAEtB,KAAK,CAF4B,OAAA;AAGpCuB,UAAAA,MAAM,EAH8B,CAAA;AAIpCL,UAAAA,QAAQ,EAARA;AAJoC,SAAlB,CAApB;AAMA,aAAA,iBAAA,CAAA,IAAA,CAAA,MAAA,EAAoC;AAAElB,UAAAA,KAAK,EAAP,KAAA;AAASoB,UAAAA,WAAW,EAAXA;AAAT,SAApC;;AACA,YAAA,WAAA,EAAiB;AACfP,UAAAA,YAAY,GAAZA,KAAAA;AADe,cAGPW,KAHO,GAGWJ,WAHX,CAAA,KAAA;AAAA,cAGAJ,OAHA,GAGWI,WAHX,CAAA,MAAA;AAIf,cAAIR,WAAW,IAAI,CAACA,WAAW,CAAA,OAAA,EAA/B,KAA+B,CAA/B,EAAgD;AAJjC,cAMAa,SANA,GAMsBL,WANtB,CAAA,KAAA;AAAA,cAMWM,MANX,GAMsBN,WANtB,CAAA,MAAA;;AAQf,cACEK,SAAS,IACTA,SAAS,CADTA,KAAAA,IAEAA,SAAS,CAATA,KAAAA,CAFAA,WAAAA,IAGAA,SAAS,CAATA,KAAAA,CAAAA,WAAAA,CAJF,YAAA,EAKE;AACAA,YAAAA,SAAS,CAATA,KAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,KAAAA,EAAAA,WAAAA;AACD;;AAED,cAAMnB,QAAQ,GACZoB,MAAM,CAANA,QAAAA,IACCD,SAAS,CAATA,KAAAA,CAAAA,WAAAA,IACCA,SAAS,CAATA,KAAAA,CAAAA,WAAAA,CADDA,SAAAA,IAECA,SAAS,CAATA,KAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CAAAA,SAAAA,CAJJ,KAIIA,CAJJ;;AAMA,cAAA,QAAA,EAAc;AACZ,iBAAA,mBAAA,GAA2B;AAAEE,cAAAA,aAAa,EAAEF,SAAS,CAATA,KAAAA,CAAjB,WAAA;AAA8CD,cAAAA,KAAK,EAALA;AAA9C,aAA3B,CADY,CAEZ;;AACA,gBAAMI,gBAAgB,GAAG,IAAIC,gBAAAA,CAAJ,SAAIA,CAAJ,CAAA,KAAA,EAA2B;AAClDC,cAAAA,IAAI,EAD8C,QAAA;AAElDC,cAAAA,QAAQ,EAAEL,MAAM,CAFkC,QAAA;AAGlDM,cAAAA,WAAW,EAHuC,OAAA;AAIlDC,cAAAA,MAAM,EAAE;AAJ0C,aAA3B,CAAzB;AAMAR,YAAAA,SAAS,CAATA,KAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CAAiCzB,KAAK,CAAtCyB,IAAAA,EAAAA,gBAAAA;AACA,iBAAA,WAAA;AACD;;AAEDX,UAAAA,MAAM,GAANA,SAAAA;AACD;AACF;;AAED,UAAI3B,SAAAA,CAAAA,SAAAA,CAAAA,CAAJ,eAAA,EAA8B;AAC5BA,QAAAA,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,eAAAA,CAAAA,KAAAA,CAAAA,MAAAA,GAAAA,MAAAA;AACD;;AAED,UAAA,YAAA,EAAkB;AAChB,aAAA,mBAAA,GAAA,IAAA;;AAEA,YAAM6B,QAAM,GAAG,KAAA,sBAAA,CAAf,KAAe,CAAf;;AACA,YAAIJ,WAAW,IAAI,CAACA,WAAW,CAAA,QAAA,EAA/B,KAA+B,CAA/B,EAJgB,OAAA,CAMhB;AACA;;AACA,YAAMgB,iBAAgB,GAAG,IAAIC,gBAAAA,CAAJ,SAAIA,CAAJ,CAAA,KAAA,EAA2B;AAClDG,UAAAA,WAAW,EADuC,QAAA;AAElDC,UAAAA,MAAM,EAAE;AAF0C,SAA3B,CAAzB;;AAIA,aAAA,YAAA,GAAA,MAAA,CACU,UAAA,KAAA,EAAA;AAAA,iBAAWxC,KAAK,IAAIA,KAAK,CAAzB,aAAA;AADV,SAAA,EAAA,OAAA,CAEW,UAAA,KAAA,EAAA;AAAA,iBAAWA,KAAK,CAALA,IAAAA,CAAAA,eAAAA,EAAX,iBAAWA,CAAX;AAFX,SAAA;AAIA,aAAA,YAAA,GAAA,MAAA,CAEI,UAAA,KAAA,EAAA;AAAA,iBACEA,KAAK,IAAIA,KAAK,CAAdA,KAAAA,IAAwBA,KAAK,CAALA,KAAAA,CAAxBA,WAAAA,IAAmDA,KAAK,CAALA,KAAAA,CAAAA,WAAAA,CADrD,aAAA;AAFJ,SAAA,EAAA,OAAA,CAKW,UAAA,KAAA,EAAA;AAAA,iBAAWA,KAAK,CAALA,KAAAA,CAAAA,WAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,EAAX,KAAWA,CAAX;AALX,SAAA;;AAOA,YAAA,eAAA,EAAqB;AACnBiB,UAAAA,eAAe,CAAA,KAAA,EAAfA,QAAe,CAAfA;AACD;AACF;AACF;;;yCAE2C;AAC1C,UAAMH,MAAM,GAAZ,EAAA;AAEA,UAAI,KAAJ,WAAA,EAAsBA,MAAM,CAANA,IAAAA,CAAAA,KAAAA,CAAAA,MAAAA,EAAM,kBAAA,CAAS,KAAA,WAAA,CAAfA,MAAe,EAAT,CAANA;AAEtB,aAAA,MAAA;AACD;;;uCAEkB;AAAA,UAAA,MAAA,GAAA,IAAA;;AACjB,aAAO,KAAA,YAAA,GAAA,GAAA,CACA,UAAA,KAAA,EAAA;AAAA,eAAY,KAAK,YAAY2B,YAAAA,CAAjB,SAAiBA,CAAjB,GAA+B,KAAK,CAAL,MAAA,CAAa;AAAED,UAAAA,MAAM,EAAE;AAAV,SAAb,CAA/B,GAAZ,KAAA;AADA,OAAA,EAAA,MAAA,CAAP,OAAO,CAAP;AAGD;;;mCAEc;AACb,UAAM1B,MAAM,GAAZ,EAAA;AAEA,WAAA,KAAA,CAAA,MAAA,CAAA,MAAA,CAAA,OAAA,EAAA,OAAA,CAA0C,UAAA,KAAA,EAAW;AACnDA,QAAAA,MAAM,CAANA,IAAAA,CADmD,KACnDA,EADmD,CAEnD;;AACA,YAAId,KAAK,YAAYyC,YAAAA,CAArB,SAAqBA,CAArB,EAAkC;AAChC3B,UAAAA,MAAM,CAANA,IAAAA,CAAAA,KAAAA,CAAAA,MAAAA,EAAM,kBAAA,CAASd,KAAK,CAApBc,YAAM,CAANA;AACD;AALH,OAAA;AAQA,aAAOA,MAAM,CAANA,MAAAA,CAAP,OAAOA,CAAP;AACD;;;wCAEmB;AAClB,aAAA,GAAA,MAAA,CAAA,kBAAA,CAAW,KAAX,gBAAW,EAAX,CAAA,EAAA,kBAAA,CAAuC,KAAvC,kBAAuC,EAAvC,CAAA,CAAA;AACD;;;+CAGC4B,M,EACA9C,Q,EACA+C,S,EACA;AACA,UAAI,KAAJ,MAAA,EAAiB;AACf,aAAA,WAAA,CAAiB;AAAED,UAAAA,MAAM,EAAR,MAAA;AAAU9C,UAAAA,QAAQ,EAARA;AAAV,SAAjB;;AACA,aAAA,WAAA,GAAmB,YAAA;AAAA,iBAAM+C,SAAS,CAAf,WAAMA,EAAN;AAAnB,SAAA;AAFF,OAAA,MAGO;AACL,aAAA,MAAA,GAAA,IAAA;AACA,aAAA,IAAA,CAAU;AAAED,UAAAA,MAAM,EAAR,MAAA;AAAU9C,UAAAA,QAAQ,EAARA;AAAV,SAAV;;AACA,aAAA,WAAA,GAAmB,YAAA;AAAA,iBAAM+C,SAAS,CAAf,WAAMA,EAAN;AAAnB,SAAA;;AACA,aAAA,oBAAA;AACD;;AAED,aAAO,KAAP,iBAAO,EAAP;AACD;;;4BAEO3B,M,EAAoC;AAC1C,UAAA,MAAA,EAAY;AACV,aAAA,MAAA,GAAA,MAAA;AACD;AACF;;;qCAEgB4B,a,EAA2C;AAC1D,UAAA,aAAA,EAAmB;AACjB,aAAA,aAAA,GAAA,aAAA;AACD;AACF","sourcesContent":["import { EventEmitter } from 'events';\n\nimport document from 'global/document';\nimport window from 'global/window';\nimport { WebMercatorViewport } from '@deck.gl/core';\n\nimport DeckDrawer from './deck-renderer/deck-drawer';\nimport LayerMouseEvent from './layer-mouse-event';\nimport NebulaLayer from './nebula-layer';\n\nconst LOGGER_PREFIX = 'Nebula: ';\n\nexport default class Nebula {\n  init(props: Record<string, any>) {\n    this.props = props;\n    this.wmViewport = new WebMercatorViewport(this.props.viewport);\n\n    // TODO: Properly use pointer events: ['click', 'pointermove', 'pointerup', 'pointerdown']\n    ['click', 'mousemove', 'mouseup', 'mousedown'].forEach((name) =>\n      document.addEventListener(name, this._onMouseEvent, true)\n    );\n  }\n\n  detach() {\n    // TODO: Properly use pointer events: ['click', 'pointermove', 'pointerup', 'pointerdown']\n    ['click', 'mousemove', 'mouseup', 'mousedown'].forEach((name) =>\n      document.removeEventListener(name, this._onMouseEvent, true)\n    );\n  }\n\n  updateProps(newProps: Record<string, any>) {\n    this.props = newProps;\n    const { viewport } = this.props;\n\n    this.wmViewport = new WebMercatorViewport(viewport);\n  }\n\n  props: Record<string, any>;\n  deckgl: Record<string, any> | null;\n  mainContainer: Record<string, any> | null;\n  deckglMouseOverInfo: Record<string, any> | null | undefined;\n  _deckDrawer: DeckDrawer;\n  _mouseWasDown: boolean;\n  wmViewport: WebMercatorViewport;\n  queryObjectEvents: EventEmitter = new EventEmitter();\n  forceUpdate: Function;\n  inited: boolean;\n\n  log(message: string) {\n    const { logger } = this.props;\n    if (logger && logger.info) {\n      logger.info(LOGGER_PREFIX + message);\n    }\n  }\n\n  updateAllDeckObjects() {\n    this.getAllLayers().forEach((layer) => {\n      if (layer && layer.deckCache) {\n        (layer.deckCache as any).updateAllDeckObjects();\n      }\n    });\n    this.forceUpdate();\n  }\n\n  updateDeckObjectsByIds(ids: string[]) {\n    this.getAllLayers().forEach((layer) => {\n      if (layer && layer.deckCache) {\n        (layer.deckCache as any).updateDeckObjectsByIds(ids);\n      }\n    });\n    this.forceUpdate();\n  }\n\n  rerenderLayers() {\n    this.updateAllDeckObjects();\n  }\n\n  _isNebulaEvent({ buttons, target, type }: Record<string, any>) {\n    const { viewport } = this.props;\n\n    // allow mouseup event aggressively to cancel drag properly\n    // TODO: use pointer capture setPointerCapture() to capture mouseup properly after deckgl\n    if (this._mouseWasDown && type === 'mouseup') {\n      this._mouseWasDown = false;\n      return true;\n    }\n\n    // allow mousemove event while dragging\n    if (type === 'mousemove' && buttons > 0) {\n      return true;\n    }\n\n    if (!target.getBoundingClientRect) {\n      return false;\n    }\n\n    const rect = target.getBoundingClientRect();\n    // Only listen to events coming from the basemap\n    // identified by the canvas of the same size as viewport.\n    // Need to round the rect dimension as some monitors\n    // have some sub-pixel difference with viewport.\n    return (\n      Math.round(rect.width) === Math.round(viewport.width) &&\n      Math.round(rect.height) === Math.round(viewport.height)\n    );\n  }\n\n  _onMouseEvent = (event: window.MouseEvent) => {\n    if (!this._isNebulaEvent(event)) {\n      return;\n    }\n\n    if (event.type === 'mousedown') {\n      this._mouseWasDown = true;\n    }\n\n    // offsetX/Y of the MouseEvent provides the offset in the X/Y coordinate\n    // of the mouse pointer between that event and the padding edge of the target node.\n    // We set our listener to document so we need to adjust offsetX/Y\n    // in case the target is not be our WebGL canvas.\n    const { top = 0, left = 0 } = this.mainContainer\n      ? this.mainContainer.getBoundingClientRect()\n      : {};\n    const proxyEvent = new Proxy(event, {\n      get: (original: any, propertyName: string) => {\n        if (propertyName === 'offsetX') {\n          return original.pageX - left;\n        }\n\n        if (propertyName === 'offsetY') {\n          return original.pageY - top;\n        }\n\n        // TODO: Properly use pointer events\n        if (propertyName === 'type') {\n          return original.type.replace('pointer', 'mouse');\n        }\n\n        const result = original[propertyName];\n        if (typeof result === 'function') {\n          return result.bind(original);\n        }\n        return result;\n      },\n    });\n\n    this._handleDeckGLEvent(proxyEvent);\n  };\n\n  getMouseGroundPosition(event: Record<string, any>) {\n    return this.wmViewport.unproject([event.offsetX, event.offsetY]);\n  }\n\n  unprojectMousePosition(mousePosition: [number, number]): [number, number] {\n    // @ts-ignore\n    return this.wmViewport.unproject(mousePosition);\n  }\n\n  _handleDeckGLEvent(event: Record<string, any>) {\n    const {\n      deckgl,\n      props: { onMapMouseEvent, selectionType, eventFilter },\n    } = this;\n    let sendMapEvent = true;\n    let cursor = 'auto';\n\n    if (event && deckgl && selectionType) {\n      if (!this._deckDrawer) this._deckDrawer = new DeckDrawer(this);\n\n      const lngLat = this.getMouseGroundPosition(event);\n      if (eventFilter && !eventFilter(lngLat, event)) return;\n      // @ts-ignore\n      const drawerResult = this._deckDrawer.handleEvent(event, lngLat, selectionType);\n      if (drawerResult.redraw) this.forceUpdate();\n      return;\n    }\n\n    if (event && deckgl && (!event.buttons || event.type !== 'mousemove')) {\n      // TODO: sort by mouse priority\n      const layerIds = deckgl.props.layers\n        .filter(\n          (l: any) => l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enablePicking\n        )\n        .map((l: any) => l.id);\n\n      const pickingInfo = deckgl.pickObject({\n        x: event.offsetX,\n        y: event.offsetY,\n        radius: 5,\n        layerIds,\n      });\n      this.queryObjectEvents.emit('pick', { event, pickingInfo });\n      if (pickingInfo) {\n        sendMapEvent = false;\n\n        const { index, lngLat } = pickingInfo;\n        if (eventFilter && !eventFilter(lngLat, event)) return;\n\n        const { layer: deckLayer, object } = pickingInfo;\n\n        if (\n          deckLayer &&\n          deckLayer.props &&\n          deckLayer.props.nebulaLayer &&\n          deckLayer.props.nebulaLayer.eventHandler\n        ) {\n          deckLayer.props.nebulaLayer.eventHandler(event, pickingInfo);\n        }\n\n        const original =\n          object.original ||\n          (deckLayer.props.nebulaLayer &&\n            deckLayer.props.nebulaLayer.deckCache &&\n            deckLayer.props.nebulaLayer.deckCache.originals[index]);\n\n        if (original) {\n          this.deckglMouseOverInfo = { originalLayer: deckLayer.props.nebulaLayer, index };\n          // @ts-ignore\n          const nebulaMouseEvent = new LayerMouseEvent(event, {\n            data: original,\n            metadata: object.metadata,\n            groundPoint: lngLat,\n            nebula: this,\n          });\n          deckLayer.props.nebulaLayer.emit(event.type, nebulaMouseEvent);\n          this.forceUpdate();\n        }\n\n        cursor = 'pointer';\n      }\n    }\n\n    if (document.documentElement) {\n      document.documentElement.style.cursor = cursor;\n    }\n\n    if (sendMapEvent) {\n      this.deckglMouseOverInfo = null;\n\n      const lngLat = this.getMouseGroundPosition(event);\n      if (eventFilter && !eventFilter(lngLat, event)) return;\n\n      // send to layers first\n      // @ts-ignore\n      const nebulaMouseEvent = new LayerMouseEvent(event, {\n        groundPoint: lngLat,\n        nebula: this,\n      });\n      this.getAllLayers()\n        .filter((layer) => layer && layer.usesMapEvents)\n        .forEach((layer) => layer.emit('mapMouseEvent', nebulaMouseEvent));\n\n      this.getAllLayers()\n        .filter(\n          (layer) =>\n            layer && layer.props && layer.props.nebulaLayer && layer.props.nebulaLayer.mapMouseEvent\n        )\n        .forEach((layer) => layer.props.nebulaLayer.mapMouseEvent(nebulaMouseEvent, layer));\n\n      if (onMapMouseEvent) {\n        onMapMouseEvent(event, lngLat);\n      }\n    }\n  }\n\n  getExtraDeckLayers(): Record<string, any>[] {\n    const result = [];\n\n    if (this._deckDrawer) result.push(...this._deckDrawer.render());\n\n    return result;\n  }\n\n  renderDeckLayers() {\n    return this.getAllLayers()\n      .map((layer) => (layer instanceof NebulaLayer ? layer.render({ nebula: this }) : layer))\n      .filter(Boolean);\n  }\n\n  getAllLayers() {\n    const result = [];\n\n    this.props.layers.filter(Boolean).forEach((layer) => {\n      result.push(layer);\n      // Only NebulaLayers have helpers, Deck GL layers don't.\n      if (layer instanceof NebulaLayer) {\n        result.push(...layer.helperLayers);\n      }\n    });\n\n    return result.filter(Boolean);\n  }\n\n  getRenderedLayers() {\n    return [...this.renderDeckLayers(), ...this.getExtraDeckLayers()];\n  }\n\n  updateAndGetRenderedLayers(\n    layers: Record<string, any>[],\n    viewport: WebMercatorViewport,\n    container: Record<string, any>\n  ) {\n    if (this.inited) {\n      this.updateProps({ layers, viewport });\n      this.forceUpdate = () => container.forceUpdate();\n    } else {\n      this.inited = true;\n      this.init({ layers, viewport });\n      this.forceUpdate = () => container.forceUpdate();\n      this.updateAllDeckObjects();\n    }\n\n    return this.getRenderedLayers();\n  }\n\n  setDeck(deckgl: Record<string, any> | null) {\n    if (deckgl) {\n      this.deckgl = deckgl;\n    }\n  }\n\n  setMainContainer(mainContainer: Record<string, any> | null) {\n    if (mainContainer) {\n      this.mainContainer = mainContainer;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}