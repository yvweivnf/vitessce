{"ast":null,"code":"function adjustSpatial(item, encode, swap) {\n  let t;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (swap && item.x > item.x2) {\n        t = item.x;\n        item.x = item.x2;\n        item.x2 = t;\n      }\n\n      item.width = item.x2 - item.x;\n    } else {\n      item.x = item.x2 - (item.width || 0);\n    }\n  }\n\n  if (encode.xc) {\n    item.x = item.xc - (item.width || 0) / 2;\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (swap && item.y > item.y2) {\n        t = item.y;\n        item.y = item.y2;\n        item.y2 = t;\n      }\n\n      item.height = item.y2 - item.y;\n    } else {\n      item.y = item.y2 - (item.height || 0);\n    }\n  }\n\n  if (encode.yc) {\n    item.y = item.yc - (item.height || 0) / 2;\n  }\n}\n\nvar Constants = {\n  NaN: NaN,\n  E: Math.E,\n  LN2: Math.LN2,\n  LN10: Math.LN10,\n  LOG2E: Math.LOG2E,\n  LOG10E: Math.LOG10E,\n  PI: Math.PI,\n  SQRT1_2: Math.SQRT1_2,\n  SQRT2: Math.SQRT2,\n  MIN_VALUE: Number.MIN_VALUE,\n  MAX_VALUE: Number.MAX_VALUE\n};\nvar Ops = {\n  '*': (a, b) => a * b,\n  '+': (a, b) => a + b,\n  '-': (a, b) => a - b,\n  '/': (a, b) => a / b,\n  '%': (a, b) => a % b,\n  '>': (a, b) => a > b,\n  '<': (a, b) => a < b,\n  '<=': (a, b) => a <= b,\n  '>=': (a, b) => a >= b,\n  '==': (a, b) => a == b,\n  '!=': (a, b) => a != b,\n  '===': (a, b) => a === b,\n  '!==': (a, b) => a !== b,\n  '&': (a, b) => a & b,\n  '|': (a, b) => a | b,\n  '^': (a, b) => a ^ b,\n  '<<': (a, b) => a << b,\n  '>>': (a, b) => a >> b,\n  '>>>': (a, b) => a >>> b\n};\nvar Unary = {\n  '+': a => +a,\n  '-': a => -a,\n  '~': a => ~a,\n  '!': a => !a\n};\nconst slice = Array.prototype.slice;\n\nconst apply = (m, args, cast) => {\n  const obj = cast ? cast(args[0]) : args[0];\n  return obj[m].apply(obj, slice.call(args, 1));\n};\n\nconst datetime = (y, m, d, H, M, S, ms) => new Date(y, m || 0, d != null ? d : 1, H || 0, M || 0, S || 0, ms || 0);\n\nvar Functions = {\n  // math functions\n  isNaN: Number.isNaN,\n  isFinite: Number.isFinite,\n  abs: Math.abs,\n  acos: Math.acos,\n  asin: Math.asin,\n  atan: Math.atan,\n  atan2: Math.atan2,\n  ceil: Math.ceil,\n  cos: Math.cos,\n  exp: Math.exp,\n  floor: Math.floor,\n  log: Math.log,\n  max: Math.max,\n  min: Math.min,\n  pow: Math.pow,\n  random: Math.random,\n  round: Math.round,\n  sin: Math.sin,\n  sqrt: Math.sqrt,\n  tan: Math.tan,\n  clamp: (a, b, c) => Math.max(b, Math.min(c, a)),\n  // date functions\n  now: Date.now,\n  utc: Date.UTC,\n  datetime: datetime,\n  date: d => new Date(d).getDate(),\n  day: d => new Date(d).getDay(),\n  year: d => new Date(d).getFullYear(),\n  month: d => new Date(d).getMonth(),\n  hours: d => new Date(d).getHours(),\n  minutes: d => new Date(d).getMinutes(),\n  seconds: d => new Date(d).getSeconds(),\n  milliseconds: d => new Date(d).getMilliseconds(),\n  time: d => new Date(d).getTime(),\n  timezoneoffset: d => new Date(d).getTimezoneOffset(),\n  utcdate: d => new Date(d).getUTCDate(),\n  utcday: d => new Date(d).getUTCDay(),\n  utcyear: d => new Date(d).getUTCFullYear(),\n  utcmonth: d => new Date(d).getUTCMonth(),\n  utchours: d => new Date(d).getUTCHours(),\n  utcminutes: d => new Date(d).getUTCMinutes(),\n  utcseconds: d => new Date(d).getUTCSeconds(),\n  utcmilliseconds: d => new Date(d).getUTCMilliseconds(),\n  // sequence functions\n  length: x => x.length,\n  join: function () {\n    return apply('join', arguments);\n  },\n  indexof: function () {\n    return apply('indexOf', arguments);\n  },\n  lastindexof: function () {\n    return apply('lastIndexOf', arguments);\n  },\n  slice: function () {\n    return apply('slice', arguments);\n  },\n  reverse: x => x.slice().reverse(),\n  // string functions\n  parseFloat: parseFloat,\n  parseInt: parseInt,\n  upper: x => String(x).toUpperCase(),\n  lower: x => String(x).toLowerCase(),\n  substring: function () {\n    return apply('substring', arguments, String);\n  },\n  split: function () {\n    return apply('split', arguments, String);\n  },\n  replace: function () {\n    return apply('replace', arguments, String);\n  },\n  trim: x => String(x).trim(),\n  // regexp functions\n  regexp: RegExp,\n  test: (r, t) => RegExp(r).test(t)\n};\nconst EventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'];\nconst Visitors = {\n  Literal: ($, n) => n.value,\n  Identifier: ($, n) => {\n    const id = n.name;\n    return $.memberDepth > 0 ? id : id === 'datum' ? $.datum : id === 'event' ? $.event : id === 'item' ? $.item : Constants[id] || $.params['$' + id];\n  },\n  MemberExpression: ($, n) => {\n    const d = !n.computed,\n          o = $(n.object);\n    if (d) $.memberDepth += 1;\n    const p = $(n.property);\n    if (d) $.memberDepth -= 1;\n    return o[p];\n  },\n  CallExpression: ($, n) => {\n    const args = n.arguments;\n    let name = n.callee.name; // handle special internal functions used by encoders\n    // re-route to corresponding standard function\n\n    if (name.startsWith('_')) {\n      name = name.slice(1);\n    } // special case \"if\" due to conditional evaluation of branches\n\n\n    return name === 'if' ? $(args[0]) ? $(args[1]) : $(args[2]) : ($.fn[name] || Functions[name]).apply($.fn, args.map($));\n  },\n  ArrayExpression: ($, n) => n.elements.map($),\n  BinaryExpression: ($, n) => Ops[n.operator]($(n.left), $(n.right)),\n  UnaryExpression: ($, n) => Unary[n.operator]($(n.argument)),\n  ConditionalExpression: ($, n) => $(n.test) ? $(n.consequent) : $(n.alternate),\n  LogicalExpression: ($, n) => n.operator === '&&' ? $(n.left) && $(n.right) : $(n.left) || $(n.right),\n  ObjectExpression: ($, n) => n.properties.reduce((o, p) => {\n    $.memberDepth += 1;\n    const k = $(p.key);\n    $.memberDepth -= 1;\n    o[k] = $(p.value);\n    return o;\n  }, {})\n};\n\nfunction interpret(ast, fn, params, datum, event, item) {\n  const $ = n => Visitors[n.type]($, n);\n\n  $.memberDepth = 0;\n  $.fn = Object.create(fn);\n  $.params = params;\n  $.datum = datum;\n  $.event = event;\n  $.item = item; // route event functions to annotated vega event context\n\n  EventFunctions.forEach(f => $.fn[f] = (...args) => event.vega[f](...args));\n  return $(ast);\n}\n\nvar expression = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return _ => interpret(ast, fn, _);\n  },\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return (datum, _) => interpret(ast, fn, _, datum);\n  },\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return event => interpret(ast, fn, undefined, undefined, event);\n  },\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return (_, event) => {\n      const datum = event.item && event.item.datum;\n      return interpret(ast, fn, _, datum, event);\n    };\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode(ctx, encode) {\n    const {\n      marktype,\n      channels\n    } = encode,\n          fn = ctx.functions,\n          swap = marktype === 'group' || marktype === 'image' || marktype === 'rect';\n    return (item, _) => {\n      const datum = item.datum;\n      let m = 0,\n          v;\n\n      for (const name in channels) {\n        v = interpret(channels[name].ast, fn, _, datum, undefined, item);\n\n        if (item[name] !== v) {\n          item[name] = v;\n          m = 1;\n        }\n      }\n\n      if (marktype !== 'rule') {\n        adjustSpatial(item, channels, swap);\n      }\n\n      return m;\n    };\n  }\n\n};\nexport { expression as expressionInterpreter };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-interpreter/build/vega-interpreter.module.js"],"names":["adjustSpatial","item","encode","swap","t","x2","x","width","xc","y2","y","height","yc","Constants","NaN","E","Math","LN2","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2","MIN_VALUE","Number","MAX_VALUE","Ops","a","b","Unary","slice","Array","prototype","apply","m","args","cast","obj","call","datetime","d","H","M","S","ms","Date","Functions","isNaN","isFinite","abs","acos","asin","atan","atan2","ceil","cos","exp","floor","log","max","min","pow","random","round","sin","sqrt","tan","clamp","c","now","utc","UTC","date","getDate","day","getDay","year","getFullYear","month","getMonth","hours","getHours","minutes","getMinutes","seconds","getSeconds","milliseconds","getMilliseconds","time","getTime","timezoneoffset","getTimezoneOffset","utcdate","getUTCDate","utcday","getUTCDay","utcyear","getUTCFullYear","utcmonth","getUTCMonth","utchours","getUTCHours","utcminutes","getUTCMinutes","utcseconds","getUTCSeconds","utcmilliseconds","getUTCMilliseconds","length","join","arguments","indexof","lastindexof","reverse","parseFloat","parseInt","upper","String","toUpperCase","lower","toLowerCase","substring","split","replace","trim","regexp","RegExp","test","r","EventFunctions","Visitors","Literal","$","n","value","Identifier","id","name","memberDepth","datum","event","params","MemberExpression","computed","o","object","p","property","CallExpression","callee","startsWith","fn","map","ArrayExpression","elements","BinaryExpression","operator","left","right","UnaryExpression","argument","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","properties","reduce","k","key","interpret","ast","type","Object","create","forEach","f","vega","expression","ctx","expr","functions","_","parameter","undefined","handler","marktype","channels","v","expressionInterpreter"],"mappings":"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","sourcesContent":["function adjustSpatial (item, encode, swap) {\n  let t;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (swap && item.x > item.x2) {\n        t = item.x;\n        item.x = item.x2;\n        item.x2 = t;\n      }\n\n      item.width = item.x2 - item.x;\n    } else {\n      item.x = item.x2 - (item.width || 0);\n    }\n  }\n\n  if (encode.xc) {\n    item.x = item.xc - (item.width || 0) / 2;\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (swap && item.y > item.y2) {\n        t = item.y;\n        item.y = item.y2;\n        item.y2 = t;\n      }\n\n      item.height = item.y2 - item.y;\n    } else {\n      item.y = item.y2 - (item.height || 0);\n    }\n  }\n\n  if (encode.yc) {\n    item.y = item.yc - (item.height || 0) / 2;\n  }\n}\n\nvar Constants = {\n  NaN: NaN,\n  E: Math.E,\n  LN2: Math.LN2,\n  LN10: Math.LN10,\n  LOG2E: Math.LOG2E,\n  LOG10E: Math.LOG10E,\n  PI: Math.PI,\n  SQRT1_2: Math.SQRT1_2,\n  SQRT2: Math.SQRT2,\n  MIN_VALUE: Number.MIN_VALUE,\n  MAX_VALUE: Number.MAX_VALUE\n};\n\nvar Ops = {\n  '*': (a, b) => a * b,\n  '+': (a, b) => a + b,\n  '-': (a, b) => a - b,\n  '/': (a, b) => a / b,\n  '%': (a, b) => a % b,\n  '>': (a, b) => a > b,\n  '<': (a, b) => a < b,\n  '<=': (a, b) => a <= b,\n  '>=': (a, b) => a >= b,\n  '==': (a, b) => a == b,\n  '!=': (a, b) => a != b,\n  '===': (a, b) => a === b,\n  '!==': (a, b) => a !== b,\n  '&': (a, b) => a & b,\n  '|': (a, b) => a | b,\n  '^': (a, b) => a ^ b,\n  '<<': (a, b) => a << b,\n  '>>': (a, b) => a >> b,\n  '>>>': (a, b) => a >>> b\n};\n\nvar Unary = {\n  '+': a => +a,\n  '-': a => -a,\n  '~': a => ~a,\n  '!': a => !a\n};\n\nconst slice = Array.prototype.slice;\n\nconst apply = (m, args, cast) => {\n  const obj = cast ? cast(args[0]) : args[0];\n  return obj[m].apply(obj, slice.call(args, 1));\n};\n\nconst datetime = (y, m, d, H, M, S, ms) => new Date(y, m || 0, d != null ? d : 1, H || 0, M || 0, S || 0, ms || 0);\n\nvar Functions = {\n  // math functions\n  isNaN: Number.isNaN,\n  isFinite: Number.isFinite,\n  abs: Math.abs,\n  acos: Math.acos,\n  asin: Math.asin,\n  atan: Math.atan,\n  atan2: Math.atan2,\n  ceil: Math.ceil,\n  cos: Math.cos,\n  exp: Math.exp,\n  floor: Math.floor,\n  log: Math.log,\n  max: Math.max,\n  min: Math.min,\n  pow: Math.pow,\n  random: Math.random,\n  round: Math.round,\n  sin: Math.sin,\n  sqrt: Math.sqrt,\n  tan: Math.tan,\n  clamp: (a, b, c) => Math.max(b, Math.min(c, a)),\n  // date functions\n  now: Date.now,\n  utc: Date.UTC,\n  datetime: datetime,\n  date: d => new Date(d).getDate(),\n  day: d => new Date(d).getDay(),\n  year: d => new Date(d).getFullYear(),\n  month: d => new Date(d).getMonth(),\n  hours: d => new Date(d).getHours(),\n  minutes: d => new Date(d).getMinutes(),\n  seconds: d => new Date(d).getSeconds(),\n  milliseconds: d => new Date(d).getMilliseconds(),\n  time: d => new Date(d).getTime(),\n  timezoneoffset: d => new Date(d).getTimezoneOffset(),\n  utcdate: d => new Date(d).getUTCDate(),\n  utcday: d => new Date(d).getUTCDay(),\n  utcyear: d => new Date(d).getUTCFullYear(),\n  utcmonth: d => new Date(d).getUTCMonth(),\n  utchours: d => new Date(d).getUTCHours(),\n  utcminutes: d => new Date(d).getUTCMinutes(),\n  utcseconds: d => new Date(d).getUTCSeconds(),\n  utcmilliseconds: d => new Date(d).getUTCMilliseconds(),\n  // sequence functions\n  length: x => x.length,\n  join: function () {\n    return apply('join', arguments);\n  },\n  indexof: function () {\n    return apply('indexOf', arguments);\n  },\n  lastindexof: function () {\n    return apply('lastIndexOf', arguments);\n  },\n  slice: function () {\n    return apply('slice', arguments);\n  },\n  reverse: x => x.slice().reverse(),\n  // string functions\n  parseFloat: parseFloat,\n  parseInt: parseInt,\n  upper: x => String(x).toUpperCase(),\n  lower: x => String(x).toLowerCase(),\n  substring: function () {\n    return apply('substring', arguments, String);\n  },\n  split: function () {\n    return apply('split', arguments, String);\n  },\n  replace: function () {\n    return apply('replace', arguments, String);\n  },\n  trim: x => String(x).trim(),\n  // regexp functions\n  regexp: RegExp,\n  test: (r, t) => RegExp(r).test(t)\n};\n\nconst EventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'];\nconst Visitors = {\n  Literal: ($, n) => n.value,\n  Identifier: ($, n) => {\n    const id = n.name;\n    return $.memberDepth > 0 ? id : id === 'datum' ? $.datum : id === 'event' ? $.event : id === 'item' ? $.item : Constants[id] || $.params['$' + id];\n  },\n  MemberExpression: ($, n) => {\n    const d = !n.computed,\n          o = $(n.object);\n    if (d) $.memberDepth += 1;\n    const p = $(n.property);\n    if (d) $.memberDepth -= 1;\n    return o[p];\n  },\n  CallExpression: ($, n) => {\n    const args = n.arguments;\n    let name = n.callee.name; // handle special internal functions used by encoders\n    // re-route to corresponding standard function\n\n    if (name.startsWith('_')) {\n      name = name.slice(1);\n    } // special case \"if\" due to conditional evaluation of branches\n\n\n    return name === 'if' ? $(args[0]) ? $(args[1]) : $(args[2]) : ($.fn[name] || Functions[name]).apply($.fn, args.map($));\n  },\n  ArrayExpression: ($, n) => n.elements.map($),\n  BinaryExpression: ($, n) => Ops[n.operator]($(n.left), $(n.right)),\n  UnaryExpression: ($, n) => Unary[n.operator]($(n.argument)),\n  ConditionalExpression: ($, n) => $(n.test) ? $(n.consequent) : $(n.alternate),\n  LogicalExpression: ($, n) => n.operator === '&&' ? $(n.left) && $(n.right) : $(n.left) || $(n.right),\n  ObjectExpression: ($, n) => n.properties.reduce((o, p) => {\n    $.memberDepth += 1;\n    const k = $(p.key);\n    $.memberDepth -= 1;\n    o[k] = $(p.value);\n    return o;\n  }, {})\n};\nfunction interpret (ast, fn, params, datum, event, item) {\n  const $ = n => Visitors[n.type]($, n);\n\n  $.memberDepth = 0;\n  $.fn = Object.create(fn);\n  $.params = params;\n  $.datum = datum;\n  $.event = event;\n  $.item = item; // route event functions to annotated vega event context\n\n  EventFunctions.forEach(f => $.fn[f] = (...args) => event.vega[f](...args));\n  return $(ast);\n}\n\nvar expression = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return _ => interpret(ast, fn, _);\n  },\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return (datum, _) => interpret(ast, fn, _, datum);\n  },\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return event => interpret(ast, fn, undefined, undefined, event);\n  },\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler(ctx, expr) {\n    const ast = expr.ast,\n          fn = ctx.functions;\n    return (_, event) => {\n      const datum = event.item && event.item.datum;\n      return interpret(ast, fn, _, datum, event);\n    };\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode(ctx, encode) {\n    const {\n      marktype,\n      channels\n    } = encode,\n          fn = ctx.functions,\n          swap = marktype === 'group' || marktype === 'image' || marktype === 'rect';\n    return (item, _) => {\n      const datum = item.datum;\n      let m = 0,\n          v;\n\n      for (const name in channels) {\n        v = interpret(channels[name].ast, fn, _, datum, undefined, item);\n\n        if (item[name] !== v) {\n          item[name] = v;\n          m = 1;\n        }\n      }\n\n      if (marktype !== 'rule') {\n        adjustSpatial(item, channels, swap);\n      }\n\n      return m;\n    };\n  }\n\n};\n\nexport { expression as expressionInterpreter };\n"]},"metadata":{},"sourceType":"module"}