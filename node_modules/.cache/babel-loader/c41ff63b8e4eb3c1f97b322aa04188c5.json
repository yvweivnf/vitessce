{"ast":null,"code":"import Observable from \"./observable\";\nimport Subject from \"./subject\";\nimport unsubscribe from \"./unsubscribe\"; // TODO: Subject already creates additional observables \"under the hood\",\n//       now we introduce even more. A true native MulticastObservable\n//       would be preferable.\n\n/**\n * Takes a \"cold\" observable and returns a wrapping \"hot\" observable that\n * proxies the input observable's values and errors.\n *\n * An observable is called \"cold\" when its initialization function is run\n * for each new subscriber. This is how observable-fns's `Observable`\n * implementation works.\n *\n * A hot observable is an observable where new subscribers subscribe to\n * the upcoming values of an already-initialiazed observable.\n *\n * The multicast observable will lazily subscribe to the source observable\n * once it has its first own subscriber and will unsubscribe from the\n * source observable when its last own subscriber unsubscribed.\n */\n\nfunction multicast(coldObservable) {\n  const subject = new Subject();\n  let sourceSubscription;\n  let subscriberCount = 0;\n  return new Observable(observer => {\n    // Init source subscription lazily\n    if (!sourceSubscription) {\n      sourceSubscription = coldObservable.subscribe(subject);\n    } // Pipe all events from `subject` into this observable\n\n\n    const subscription = subject.subscribe(observer);\n    subscriberCount++;\n    return () => {\n      subscriberCount--;\n      subscription.unsubscribe(); // Close source subscription once last subscriber has unsubscribed\n\n      if (subscriberCount === 0) {\n        unsubscribe(sourceSubscription);\n        sourceSubscription = undefined;\n      }\n    };\n  });\n}\n\nexport default multicast;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/observable-fns/dist.esm/multicast.js"],"names":["Observable","Subject","unsubscribe","multicast","coldObservable","subject","sourceSubscription","subscriberCount","observer","subscribe","subscription","undefined"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,cAAvB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,WAAP,MAAwB,eAAxB,C,CACA;AACA;AACA;;AACA;;;;;;;;;;;;;;;;AAeA,SAASC,SAAT,CAAmBC,cAAnB,EAAmC;AAC/B,QAAMC,OAAO,GAAG,IAAIJ,OAAJ,EAAhB;AACA,MAAIK,kBAAJ;AACA,MAAIC,eAAe,GAAG,CAAtB;AACA,SAAO,IAAIP,UAAJ,CAAeQ,QAAQ,IAAI;AAC9B;AACA,QAAI,CAACF,kBAAL,EAAyB;AACrBA,MAAAA,kBAAkB,GAAGF,cAAc,CAACK,SAAf,CAAyBJ,OAAzB,CAArB;AACH,KAJ6B,CAK9B;;;AACA,UAAMK,YAAY,GAAGL,OAAO,CAACI,SAAR,CAAkBD,QAAlB,CAArB;AACAD,IAAAA,eAAe;AACf,WAAO,MAAM;AACTA,MAAAA,eAAe;AACfG,MAAAA,YAAY,CAACR,WAAb,GAFS,CAGT;;AACA,UAAIK,eAAe,KAAK,CAAxB,EAA2B;AACvBL,QAAAA,WAAW,CAACI,kBAAD,CAAX;AACAA,QAAAA,kBAAkB,GAAGK,SAArB;AACH;AACJ,KARD;AASH,GAjBM,CAAP;AAkBH;;AACD,eAAeR,SAAf","sourcesContent":["import Observable from \"./observable\";\nimport Subject from \"./subject\";\nimport unsubscribe from \"./unsubscribe\";\n// TODO: Subject already creates additional observables \"under the hood\",\n//       now we introduce even more. A true native MulticastObservable\n//       would be preferable.\n/**\n * Takes a \"cold\" observable and returns a wrapping \"hot\" observable that\n * proxies the input observable's values and errors.\n *\n * An observable is called \"cold\" when its initialization function is run\n * for each new subscriber. This is how observable-fns's `Observable`\n * implementation works.\n *\n * A hot observable is an observable where new subscribers subscribe to\n * the upcoming values of an already-initialiazed observable.\n *\n * The multicast observable will lazily subscribe to the source observable\n * once it has its first own subscriber and will unsubscribe from the\n * source observable when its last own subscriber unsubscribed.\n */\nfunction multicast(coldObservable) {\n    const subject = new Subject();\n    let sourceSubscription;\n    let subscriberCount = 0;\n    return new Observable(observer => {\n        // Init source subscription lazily\n        if (!sourceSubscription) {\n            sourceSubscription = coldObservable.subscribe(subject);\n        }\n        // Pipe all events from `subject` into this observable\n        const subscription = subject.subscribe(observer);\n        subscriberCount++;\n        return () => {\n            subscriberCount--;\n            subscription.unsubscribe();\n            // Close source subscription once last subscriber has unsubscribed\n            if (subscriberCount === 0) {\n                unsubscribe(sourceSubscription);\n                sourceSubscription = undefined;\n            }\n        };\n    });\n}\nexport default multicast;\n"]},"metadata":{},"sourceType":"module"}