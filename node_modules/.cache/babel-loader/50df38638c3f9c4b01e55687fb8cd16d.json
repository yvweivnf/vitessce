{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../../utils/assert';\n\nvar Schema = /*#__PURE__*/function () {\n  function Schema(fields, metadata) {\n    _classCallCheck(this, Schema);\n\n    _defineProperty(this, \"fields\", void 0);\n\n    _defineProperty(this, \"metadata\", void 0);\n\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  _createClass(Schema, [{\n    key: \"compareTo\",\n    value: function compareTo(other) {\n      if (this.metadata !== other.metadata) {\n        return false;\n      }\n\n      if (this.fields.length !== other.fields.length) {\n        return false;\n      }\n\n      for (var i = 0; i < this.fields.length; ++i) {\n        if (!this.fields[i].compareTo(other.fields[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      var nameMap = Object.create(null);\n\n      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        columnNames[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _columnNames = columnNames; _i < _columnNames.length; _i++) {\n        var name = _columnNames[_i];\n        nameMap[name] = true;\n      }\n\n      var selectedFields = this.fields.filter(function (field) {\n        return nameMap[field.name];\n      });\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"selectAt\",\n    value: function selectAt() {\n      var _this = this;\n\n      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        columnIndices[_key2] = arguments[_key2];\n      }\n\n      var selectedFields = columnIndices.map(function (index) {\n        return _this.fields[index];\n      }).filter(Boolean);\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"assign\",\n    value: function assign(schemaOrFields) {\n      var fields;\n      var metadata = this.metadata;\n\n      if (schemaOrFields instanceof Schema) {\n        var otherSchema = schemaOrFields;\n        fields = otherSchema.fields;\n        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n      } else {\n        fields = schemaOrFields;\n      }\n\n      var fieldMap = Object.create(null);\n\n      var _iterator = _createForOfIteratorHelper(this.fields),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          fieldMap[field.name] = field;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(fields),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _field = _step2.value;\n          fieldMap[_field.name] = _field;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var mergedFields = Object.values(fieldMap);\n      return new Schema(mergedFields, metadata);\n    }\n  }]);\n\n  return Schema;\n}();\n\nexport { Schema as default };\n\nfunction checkNames(fields) {\n  var usedNames = {};\n\n  var _iterator3 = _createForOfIteratorHelper(fields),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var field = _step3.value;\n\n      if (usedNames[field.name]) {\n        console.warn('Schema: duplicated field name', field.name, field);\n      }\n\n      usedNames[field.name] = true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nfunction mergeMaps(m1, m2) {\n  return new Map([].concat(_toConsumableArray(m1 || new Map()), _toConsumableArray(m2 || new Map())));\n}","map":{"version":3,"sources":["../../../../../src/lib/schema/impl/schema.ts"],"names":["constructor","assert","Array","checkNames","metadata","other","i","nameMap","Object","name","selectedFields","field","columnIndices","index","schemaOrFields","otherSchema","fields","mergeMaps","fieldMap","mergedFields","usedNames","console","m1","m2"],"mappings":"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","sourcesContent":["import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields: Field[]): void {\n  const usedNames: Record<string, boolean> = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"]},"metadata":{},"sourceType":"module"}