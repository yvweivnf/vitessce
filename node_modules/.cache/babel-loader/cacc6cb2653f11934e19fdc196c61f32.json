{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport DebugLogger from \"debug\";\nimport { Observable } from \"observable-fns\";\nimport { deserialize } from \"../common\";\nimport { createPromiseWithResolver } from \"../promise\";\nimport { $errors, $events, $terminate, $worker } from \"../symbols\";\nimport { WorkerEventType } from \"../types/master\";\nimport { createProxyFunction, createProxyModule } from \"./invocation-proxy\";\nvar debugMessages = DebugLogger(\"threads:master:messages\");\nvar debugSpawn = DebugLogger(\"threads:master:spawn\");\nvar debugThreadUtils = DebugLogger(\"threads:master:thread-utils\");\n\nvar isInitMessage = function isInitMessage(data) {\n  return data && data.type === \"init\";\n};\n\nvar isUncaughtErrorMessage = function isUncaughtErrorMessage(data) {\n  return data && data.type === \"uncaughtError\";\n};\n\nvar initMessageTimeout = typeof process !== \"undefined\" && process.env.THREADS_WORKER_INIT_TIMEOUT ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10) : 10000;\n\nfunction withTimeout(promise, timeoutInMs, errorMessage) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var timeoutHandle, timeout, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            timeout = new Promise(function (resolve, reject) {\n              timeoutHandle = setTimeout(function () {\n                return reject(Error(errorMessage));\n              }, timeoutInMs);\n            });\n            _context.next = 3;\n            return Promise.race([promise, timeout]);\n\n          case 3:\n            result = _context.sent;\n            clearTimeout(timeoutHandle);\n            return _context.abrupt(\"return\", result);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nfunction receiveInitMessage(worker) {\n  return new Promise(function (resolve, reject) {\n    var messageHandler = function messageHandler(event) {\n      debugMessages(\"Message from worker before finishing initialization:\", event.data);\n\n      if (isInitMessage(event.data)) {\n        worker.removeEventListener(\"message\", messageHandler);\n        resolve(event.data);\n      } else if (isUncaughtErrorMessage(event.data)) {\n        worker.removeEventListener(\"message\", messageHandler);\n        reject(deserialize(event.data.error));\n      }\n    };\n\n    worker.addEventListener(\"message\", messageHandler);\n  });\n}\n\nfunction createEventObservable(worker, workerTermination) {\n  return new Observable(function (observer) {\n    var messageHandler = function messageHandler(messageEvent) {\n      var workerEvent = {\n        type: WorkerEventType.message,\n        data: messageEvent.data\n      };\n      observer.next(workerEvent);\n    };\n\n    var rejectionHandler = function rejectionHandler(errorEvent) {\n      debugThreadUtils(\"Unhandled promise rejection event in thread:\", errorEvent);\n      var workerEvent = {\n        type: WorkerEventType.internalError,\n        error: Error(errorEvent.reason)\n      };\n      observer.next(workerEvent);\n    };\n\n    worker.addEventListener(\"message\", messageHandler);\n    worker.addEventListener(\"unhandledrejection\", rejectionHandler);\n    workerTermination.then(function () {\n      var terminationEvent = {\n        type: WorkerEventType.termination\n      };\n      worker.removeEventListener(\"message\", messageHandler);\n      worker.removeEventListener(\"unhandledrejection\", rejectionHandler);\n      observer.next(terminationEvent);\n      observer.complete();\n    });\n  });\n}\n\nfunction createTerminator(worker) {\n  var _this = this;\n\n  var _createPromiseWithRes = createPromiseWithResolver(),\n      _createPromiseWithRes2 = _slicedToArray(_createPromiseWithRes, 2),\n      termination = _createPromiseWithRes2[0],\n      resolver = _createPromiseWithRes2[1];\n\n  var terminate = function terminate() {\n    return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              debugThreadUtils(\"Terminating worker\"); // Newer versions of worker_threads workers return a promise\n\n              _context2.next = 3;\n              return worker.terminate();\n\n            case 3:\n              resolver();\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n  };\n\n  return {\n    terminate: terminate,\n    termination: termination\n  };\n}\n\nfunction setPrivateThreadProps(raw, worker, workerEvents, terminate) {\n  var _Object$assign;\n\n  var workerErrors = workerEvents.filter(function (event) {\n    return event.type === WorkerEventType.internalError;\n  }).map(function (errorEvent) {\n    return errorEvent.error;\n  }); // tslint:disable-next-line prefer-object-spread\n\n  return Object.assign(raw, (_Object$assign = {}, _defineProperty(_Object$assign, $errors, workerErrors), _defineProperty(_Object$assign, $events, workerEvents), _defineProperty(_Object$assign, $terminate, terminate), _defineProperty(_Object$assign, $worker, worker), _Object$assign));\n}\n/**\n * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin\n * abstraction layer to provide the transparent API and verifies that\n * the worker has initialized successfully.\n *\n * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.\n * @param [options]\n * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.\n */\n\n\nexport function spawn(worker, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var timeout, initMessage, exposed, _createTerminator, termination, terminate, events, proxy, _proxy, type;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            debugSpawn(\"Initializing new thread\");\n            timeout = options && options.timeout ? options.timeout : initMessageTimeout;\n            _context3.next = 4;\n            return withTimeout(receiveInitMessage(worker), timeout, \"Timeout: Did not receive an init message from worker after \".concat(timeout, \"ms. Make sure the worker calls expose().\"));\n\n          case 4:\n            initMessage = _context3.sent;\n            exposed = initMessage.exposed;\n            _createTerminator = createTerminator(worker), termination = _createTerminator.termination, terminate = _createTerminator.terminate;\n            events = createEventObservable(worker, termination);\n\n            if (!(exposed.type === \"function\")) {\n              _context3.next = 13;\n              break;\n            }\n\n            proxy = createProxyFunction(worker);\n            return _context3.abrupt(\"return\", setPrivateThreadProps(proxy, worker, events, terminate));\n\n          case 13:\n            if (!(exposed.type === \"module\")) {\n              _context3.next = 18;\n              break;\n            }\n\n            _proxy = createProxyModule(worker, exposed.methods);\n            return _context3.abrupt(\"return\", setPrivateThreadProps(_proxy, worker, events, terminate));\n\n          case 18:\n            type = exposed.type;\n            throw Error(\"Worker init message states unexpected type of expose(): \".concat(type));\n\n          case 20:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/master/spawn.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","DebugLogger","Observable","deserialize","createPromiseWithResolver","$errors","$events","$terminate","$worker","WorkerEventType","createProxyFunction","createProxyModule","debugMessages","debugSpawn","debugThreadUtils","isInitMessage","data","type","isUncaughtErrorMessage","initMessageTimeout","process","env","THREADS_WORKER_INIT_TIMEOUT","Number","parseInt","withTimeout","promise","timeoutInMs","errorMessage","timeout","timeoutHandle","setTimeout","Error","race","clearTimeout","receiveInitMessage","worker","messageHandler","event","removeEventListener","error","addEventListener","createEventObservable","workerTermination","observer","messageEvent","workerEvent","message","rejectionHandler","errorEvent","internalError","reason","terminationEvent","termination","complete","createTerminator","resolver","terminate","setPrivateThreadProps","raw","workerEvents","workerErrors","filter","map","Object","assign","spawn","options","initMessage","exposed","events","proxy","methods"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DebugLogger from \"debug\";\nimport { Observable } from \"observable-fns\";\nimport { deserialize } from \"../common\";\nimport { createPromiseWithResolver } from \"../promise\";\nimport { $errors, $events, $terminate, $worker } from \"../symbols\";\nimport { WorkerEventType } from \"../types/master\";\nimport { createProxyFunction, createProxyModule } from \"./invocation-proxy\";\nconst debugMessages = DebugLogger(\"threads:master:messages\");\nconst debugSpawn = DebugLogger(\"threads:master:spawn\");\nconst debugThreadUtils = DebugLogger(\"threads:master:thread-utils\");\nconst isInitMessage = (data) => data && data.type === \"init\";\nconst isUncaughtErrorMessage = (data) => data && data.type === \"uncaughtError\";\nconst initMessageTimeout = typeof process !== \"undefined\" && process.env.THREADS_WORKER_INIT_TIMEOUT\n    ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10)\n    : 10000;\nfunction withTimeout(promise, timeoutInMs, errorMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let timeoutHandle;\n        const timeout = new Promise((resolve, reject) => {\n            timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);\n        });\n        const result = yield Promise.race([\n            promise,\n            timeout\n        ]);\n        clearTimeout(timeoutHandle);\n        return result;\n    });\n}\nfunction receiveInitMessage(worker) {\n    return new Promise((resolve, reject) => {\n        const messageHandler = ((event) => {\n            debugMessages(\"Message from worker before finishing initialization:\", event.data);\n            if (isInitMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                resolve(event.data);\n            }\n            else if (isUncaughtErrorMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                reject(deserialize(event.data.error));\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n    });\n}\nfunction createEventObservable(worker, workerTermination) {\n    return new Observable(observer => {\n        const messageHandler = ((messageEvent) => {\n            const workerEvent = {\n                type: WorkerEventType.message,\n                data: messageEvent.data\n            };\n            observer.next(workerEvent);\n        });\n        const rejectionHandler = ((errorEvent) => {\n            debugThreadUtils(\"Unhandled promise rejection event in thread:\", errorEvent);\n            const workerEvent = {\n                type: WorkerEventType.internalError,\n                error: Error(errorEvent.reason)\n            };\n            observer.next(workerEvent);\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        worker.addEventListener(\"unhandledrejection\", rejectionHandler);\n        workerTermination.then(() => {\n            const terminationEvent = {\n                type: WorkerEventType.termination\n            };\n            worker.removeEventListener(\"message\", messageHandler);\n            worker.removeEventListener(\"unhandledrejection\", rejectionHandler);\n            observer.next(terminationEvent);\n            observer.complete();\n        });\n    });\n}\nfunction createTerminator(worker) {\n    const [termination, resolver] = createPromiseWithResolver();\n    const terminate = () => __awaiter(this, void 0, void 0, function* () {\n        debugThreadUtils(\"Terminating worker\");\n        // Newer versions of worker_threads workers return a promise\n        yield worker.terminate();\n        resolver();\n    });\n    return { terminate, termination };\n}\nfunction setPrivateThreadProps(raw, worker, workerEvents, terminate) {\n    const workerErrors = workerEvents\n        .filter(event => event.type === WorkerEventType.internalError)\n        .map(errorEvent => errorEvent.error);\n    // tslint:disable-next-line prefer-object-spread\n    return Object.assign(raw, {\n        [$errors]: workerErrors,\n        [$events]: workerEvents,\n        [$terminate]: terminate,\n        [$worker]: worker\n    });\n}\n/**\n * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin\n * abstraction layer to provide the transparent API and verifies that\n * the worker has initialized successfully.\n *\n * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.\n * @param [options]\n * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.\n */\nexport function spawn(worker, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        debugSpawn(\"Initializing new thread\");\n        const timeout = options && options.timeout ? options.timeout : initMessageTimeout;\n        const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);\n        const exposed = initMessage.exposed;\n        const { termination, terminate } = createTerminator(worker);\n        const events = createEventObservable(worker, termination);\n        if (exposed.type === \"function\") {\n            const proxy = createProxyFunction(worker);\n            return setPrivateThreadProps(proxy, worker, events, terminate);\n        }\n        else if (exposed.type === \"module\") {\n            const proxy = createProxyModule(worker, exposed.methods);\n            return setPrivateThreadProps(proxy, worker, events, terminate);\n        }\n        else {\n            const type = exposed.type;\n            throw Error(`Worker init message states unexpected type of expose(): ${type}`);\n        }\n    });\n}\n"]},"metadata":{},"sourceType":"module"}