{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Observable } from \"observable-fns\";\n\nvar doNothing = function doNothing() {\n  return undefined;\n};\n\nvar returnInput = function returnInput(input) {\n  return input;\n};\n\nvar runDeferred = function runDeferred(fn) {\n  return Promise.resolve().then(fn);\n};\n\nfunction fail(error) {\n  throw error;\n}\n\nfunction isThenable(thing) {\n  return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\n\n\nexport var ObservablePromise = /*#__PURE__*/function (_Observable) {\n  _inherits(ObservablePromise, _Observable);\n\n  var _super = _createSuper(ObservablePromise);\n\n  function ObservablePromise(init) {\n    var _this;\n\n    _classCallCheck(this, ObservablePromise);\n\n    _this = _super.call(this, function (originalObserver) {\n      // tslint:disable-next-line no-this-assignment\n      var self = _assertThisInitialized(_this);\n\n      var observer = Object.assign(Object.assign({}, originalObserver), {\n        complete: function complete() {\n          originalObserver.complete();\n          self.onCompletion();\n        },\n        error: function error(_error) {\n          originalObserver.error(_error);\n          self.onError(_error);\n        },\n        next: function next(value) {\n          originalObserver.next(value);\n          self.onNext(value);\n        }\n      });\n\n      try {\n        _this.initHasRun = true;\n        return init(observer);\n      } catch (error) {\n        observer.error(error);\n      }\n    });\n    _this.initHasRun = false;\n    _this.fulfillmentCallbacks = [];\n    _this.rejectionCallbacks = [];\n    _this.firstValueSet = false;\n    _this.state = \"pending\";\n    return _this;\n  }\n\n  _createClass(ObservablePromise, [{\n    key: \"onNext\",\n    value: function onNext(value) {\n      if (!this.firstValueSet) {\n        this.firstValue = value;\n        this.firstValueSet = true;\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      this.state = \"rejected\";\n      this.rejection = error;\n\n      var _iterator = _createForOfIteratorHelper(this.rejectionCallbacks),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var onRejected = _step.value;\n          // Promisifying the call to turn errors into unhandled promise rejections\n          // instead of them failing sync and cancelling the iteration\n          runDeferred(function () {\n            return onRejected(error);\n          });\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"onCompletion\",\n    value: function onCompletion() {\n      var _this2 = this;\n\n      this.state = \"fulfilled\";\n\n      var _iterator2 = _createForOfIteratorHelper(this.fulfillmentCallbacks),\n          _step2;\n\n      try {\n        var _loop2 = function _loop2() {\n          var onFulfilled = _step2.value;\n          // Promisifying the call to turn errors into unhandled promise rejections\n          // instead of them failing sync and cancelling the iteration\n          runDeferred(function () {\n            return onFulfilled(_this2.firstValue);\n          });\n        };\n\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"then\",\n    value: function then(onFulfilledRaw, onRejectedRaw) {\n      var _this3 = this;\n\n      var onFulfilled = onFulfilledRaw || returnInput;\n      var onRejected = onRejectedRaw || fail;\n      var onRejectedCalled = false;\n      return new Promise(function (resolve, reject) {\n        var rejectionCallback = function rejectionCallback(error) {\n          if (onRejectedCalled) return;\n          onRejectedCalled = true;\n\n          try {\n            resolve(onRejected(error));\n          } catch (anotherError) {\n            reject(anotherError);\n          }\n        };\n\n        var fulfillmentCallback = function fulfillmentCallback(value) {\n          try {\n            resolve(onFulfilled(value));\n          } catch (error) {\n            rejectionCallback(error);\n          }\n        };\n\n        if (!_this3.initHasRun) {\n          _this3.subscribe({\n            error: rejectionCallback\n          });\n        }\n\n        if (_this3.state === \"fulfilled\") {\n          return resolve(onFulfilled(_this3.firstValue));\n        }\n\n        if (_this3.state === \"rejected\") {\n          onRejectedCalled = true;\n          return resolve(onRejected(_this3.rejection));\n        }\n\n        _this3.fulfillmentCallbacks.push(fulfillmentCallback);\n\n        _this3.rejectionCallbacks.push(rejectionCallback);\n      });\n    }\n  }, {\n    key: \"catch\",\n    value: function _catch(onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  }, {\n    key: \"finally\",\n    value: function _finally(onCompleted) {\n      var handler = onCompleted || doNothing;\n      return this.then(function (value) {\n        handler();\n        return value;\n      }, function () {\n        return handler();\n      });\n    }\n  }], [{\n    key: \"from\",\n    value: function from(thing) {\n      if (isThenable(thing)) {\n        return new ObservablePromise(function (observer) {\n          var onFulfilled = function onFulfilled(value) {\n            observer.next(value);\n            observer.complete();\n          };\n\n          var onRejected = function onRejected(error) {\n            observer.error(error);\n          };\n\n          thing.then(onFulfilled, onRejected);\n        });\n      } else {\n        return _get(_getPrototypeOf(ObservablePromise), \"from\", this).call(this, thing);\n      }\n    }\n  }]);\n\n  return ObservablePromise;\n}(Observable);","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/observable-promise.js"],"names":["Observable","doNothing","undefined","returnInput","input","runDeferred","fn","Promise","resolve","then","fail","error","isThenable","thing","ObservablePromise","init","originalObserver","self","observer","Object","assign","complete","onCompletion","onError","next","value","onNext","initHasRun","fulfillmentCallbacks","rejectionCallbacks","firstValueSet","state","firstValue","rejection","onRejected","onFulfilled","onFulfilledRaw","onRejectedRaw","onRejectedCalled","reject","rejectionCallback","anotherError","fulfillmentCallback","subscribe","push","onCompleted","handler"],"mappings":"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","sourcesContent":["import { Observable } from \"observable-fns\";\nconst doNothing = () => undefined;\nconst returnInput = (input) => input;\nconst runDeferred = (fn) => Promise.resolve().then(fn);\nfunction fail(error) {\n    throw error;\n}\nfunction isThenable(thing) {\n    return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nexport class ObservablePromise extends Observable {\n    constructor(init) {\n        super((originalObserver) => {\n            // tslint:disable-next-line no-this-assignment\n            const self = this;\n            const observer = Object.assign(Object.assign({}, originalObserver), { complete() {\n                    originalObserver.complete();\n                    self.onCompletion();\n                }, error(error) {\n                    originalObserver.error(error);\n                    self.onError(error);\n                },\n                next(value) {\n                    originalObserver.next(value);\n                    self.onNext(value);\n                } });\n            try {\n                this.initHasRun = true;\n                return init(observer);\n            }\n            catch (error) {\n                observer.error(error);\n            }\n        });\n        this.initHasRun = false;\n        this.fulfillmentCallbacks = [];\n        this.rejectionCallbacks = [];\n        this.firstValueSet = false;\n        this.state = \"pending\";\n    }\n    onNext(value) {\n        if (!this.firstValueSet) {\n            this.firstValue = value;\n            this.firstValueSet = true;\n        }\n    }\n    onError(error) {\n        this.state = \"rejected\";\n        this.rejection = error;\n        for (const onRejected of this.rejectionCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onRejected(error));\n        }\n    }\n    onCompletion() {\n        this.state = \"fulfilled\";\n        for (const onFulfilled of this.fulfillmentCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onFulfilled(this.firstValue));\n        }\n    }\n    then(onFulfilledRaw, onRejectedRaw) {\n        const onFulfilled = onFulfilledRaw || returnInput;\n        const onRejected = onRejectedRaw || fail;\n        let onRejectedCalled = false;\n        return new Promise((resolve, reject) => {\n            const rejectionCallback = (error) => {\n                if (onRejectedCalled)\n                    return;\n                onRejectedCalled = true;\n                try {\n                    resolve(onRejected(error));\n                }\n                catch (anotherError) {\n                    reject(anotherError);\n                }\n            };\n            const fulfillmentCallback = (value) => {\n                try {\n                    resolve(onFulfilled(value));\n                }\n                catch (error) {\n                    rejectionCallback(error);\n                }\n            };\n            if (!this.initHasRun) {\n                this.subscribe({ error: rejectionCallback });\n            }\n            if (this.state === \"fulfilled\") {\n                return resolve(onFulfilled(this.firstValue));\n            }\n            if (this.state === \"rejected\") {\n                onRejectedCalled = true;\n                return resolve(onRejected(this.rejection));\n            }\n            this.fulfillmentCallbacks.push(fulfillmentCallback);\n            this.rejectionCallbacks.push(rejectionCallback);\n        });\n    }\n    catch(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n    finally(onCompleted) {\n        const handler = onCompleted || doNothing;\n        return this.then((value) => {\n            handler();\n            return value;\n        }, () => handler());\n    }\n    static from(thing) {\n        if (isThenable(thing)) {\n            return new ObservablePromise(observer => {\n                const onFulfilled = (value) => {\n                    observer.next(value);\n                    observer.complete();\n                };\n                const onRejected = (error) => {\n                    observer.error(error);\n                };\n                thing.then(onFulfilled, onRejected);\n            });\n        }\n        else {\n            return super.from(thing);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}