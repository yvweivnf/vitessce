{"ast":null,"code":"import { Transform, rederive, ingest, replace } from 'vega-dataflow';\nimport { error, extent, inherits, identity, isArray, isFunction, isNumber, constant, array, one, accessorName, accessorFields, field, extend, toSet, zero } from 'vega-util';\nimport { range, tickStep, max, sum } from 'd3-array';\nimport { bandwidthNRD } from 'vega-statistics';\nimport { getProjectionPath, projectionProperties, projection } from 'vega-projection';\nimport { geoGraticule } from 'd3-geo';\nimport { rgb } from 'd3-color';\nimport { canvas } from 'vega-canvas';\n\nfunction noop() {}\n\nconst cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []]; // Implementation adapted from d3/d3-contour. Thanks!\n\nfunction contours() {\n  var dx = 1,\n      dy = 1,\n      smooth = smoothLinear;\n\n  function contours(values, tz) {\n    return tz.map(value => contour(values, value));\n  } // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n\n\n  function contour(values, value) {\n    var polygons = [],\n        holes = [];\n    isorings(values, value, ring => {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(hole => {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: 'MultiPolygon',\n      value: value,\n      coordinates: polygons\n    };\n  } // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n\n\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array(),\n        fragmentByEnd = new Array(),\n        x,\n        y,\n        t0,\n        t1,\n        t2,\n        t3; // Special case for the first row (y = -1, t2 = t3 = 0).\n\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n\n    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.\n\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n\n      cases[t1 | t2 << 3].forEach(stitch);\n    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n\n\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f,\n          g;\n\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(point => {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v0,\n          v1 = values[yt * dx + xt];\n\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n\n    var _0 = Math.floor(_[0]),\n        _1 = Math.floor(_[1]);\n\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n\nfunction area(ring) {\n  var i = 0,\n      n = ring.length,\n      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n\n  return area;\n}\n\nfunction contains(ring, hole) {\n  var i = -1,\n      n = hole.length,\n      c;\n\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n\n  return 0;\n}\n\nfunction ringContains(ring, point) {\n  var x = point[0],\n      y = point[1],\n      contains = -1;\n\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i],\n        xi = pi[0],\n        yi = pi[1],\n        pj = ring[j],\n        xj = pj[0],\n        yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;\n  }\n\n  return contains;\n}\n\nfunction segmentContains(a, b, c) {\n  var i;\n  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\n\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n\nfunction quantize(k, nice, zero) {\n  return function (values) {\n    var ex = extent(values),\n        start = zero ? Math.min(ex[0], 0) : ex[0],\n        stop = ex[1],\n        span = stop - start,\n        step = nice ? tickStep(start, stop, k) : span / (k + 1);\n    return range(start + step, stop, step);\n  };\n}\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\n\n\nfunction Isocontour(params) {\n  Transform.call(this, null, params);\n}\n\nIsocontour.Definition = {\n  'type': 'Isocontour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'levels',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'zero',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'scale',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'translate',\n    'type': 'number',\n    'array': true,\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'default': 'contour'\n  }]\n};\ninherits(Isocontour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        source = pulse.materialize(pulse.SOURCE).source,\n        field = _.field || identity,\n        contour = contours().smooth(_.smooth !== false),\n        tz = _.thresholds || levels(source, field, _),\n        as = _.as === null ? null : _.as || 'contour',\n        values = [];\n    source.forEach(t => {\n      const grid = field(t); // generate contour paths in GeoJSON format\n\n      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed\n\n      transformPaths(paths, grid, t, _); // ingest; copy source data properties to output\n\n      paths.forEach(p => {\n        values.push(rederive(t, ingest(as != null ? {\n          [as]: p\n        } : p)));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n\n});\n\nfunction levels(values, f, _) {\n  const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(t => max(f(t).values)));\n}\n\nfunction transformPaths(paths, grid, datum, _) {\n  let s = _.scale || grid.scale,\n      t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  const sx = (isNumber(s) ? s : s[0]) || 1,\n        sy = (isNumber(s) ? s : s[1]) || 1,\n        tx = t && t[0] || 0,\n        ty = t && t[1] || 0;\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\n\nfunction transform(grid, sx, sy, tx, ty) {\n  const x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        flip = sx * sy < 0;\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n\n    coordinates.forEach(transformPoint);\n  }\n\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}\n\nfunction radius(bw, data, f) {\n  const v = bw >= 0 ? bw : bandwidthNRD(data, f);\n  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\n}\n\nfunction number(_) {\n  return isFunction(_) ? _ : constant(+_);\n} // Implementation adapted from d3/d3-contour. Thanks!\n\n\nfunction density2D() {\n  var x = d => d[0],\n      y = d => d[1],\n      weight = one,\n      bandwidth = [-1, -1],\n      dx = 960,\n      dy = 500,\n      k = 2; // log2(cellSize)\n\n\n  function density(data, counts) {\n    const rx = radius(bandwidth[0], data, x) >> k,\n          // blur x-radius\n    ry = radius(bandwidth[1], data, y) >> k,\n          // blur y-radius\n    ox = rx ? rx + 2 : 0,\n          // x-offset padding for blur\n    oy = ry ? ry + 2 : 0,\n          // y-offset padding for blur\n    n = 2 * ox + (dx >> k),\n          // grid width\n    m = 2 * oy + (dy >> k),\n          // grid height\n    values0 = new Float32Array(n * m),\n          values1 = new Float32Array(n * m);\n    let values = values0;\n    data.forEach(d => {\n      const xi = ox + (+x(d) >> k),\n            yi = oy + (+y(d) >> k);\n\n      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        values0[xi + yi * n] += +weight(d);\n      }\n    });\n\n    if (rx > 0 && ry > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n    } else if (rx > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurX(n, m, values1, values0, rx);\n      blurX(n, m, values0, values1, rx);\n      values = values1;\n    } else if (ry > 0) {\n      blurY(n, m, values0, values1, ry);\n      blurY(n, m, values1, values0, ry);\n      blurY(n, m, values0, values1, ry);\n      values = values1;\n    } // scale density estimates\n    // density in points per square pixel or probability density\n\n\n    const s = counts ? Math.pow(2, -2 * k) : 1 / sum(values);\n\n    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;\n\n    return {\n      values: values,\n      scale: 1 << k,\n      width: n,\n      height: m,\n      x1: ox,\n      y1: oy,\n      x2: ox + (dx >> k),\n      y2: oy + (dy >> k)\n    };\n  }\n\n  density.x = function (_) {\n    return arguments.length ? (x = number(_), density) : x;\n  };\n\n  density.y = function (_) {\n    return arguments.length ? (y = number(_), density) : y;\n  };\n\n  density.weight = function (_) {\n    return arguments.length ? (weight = number(_), density) : weight;\n  };\n\n  density.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n\n    var _0 = +_[0],\n        _1 = +_[1];\n\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, density;\n  };\n\n  density.cellSize = function (_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) error('invalid cell size');\n    k = Math.floor(Math.log(_) / Math.LN2);\n    return density;\n  };\n\n  density.bandwidth = function (_) {\n    if (!arguments.length) return bandwidth;\n    _ = array(_);\n    if (_.length === 1) _ = [+_[0], +_[0]];\n    if (_.length !== 2) error('invalid bandwidth');\n    return bandwidth = _, density;\n  };\n\n  return density;\n}\n\nfunction blurX(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n\n  for (let j = 0; j < m; ++j) {\n    for (let i = 0, sr = 0; i < n + r; ++i) {\n      if (i < n) {\n        sr += source[i + j * n];\n      }\n\n      if (i >= r) {\n        if (i >= w) {\n          sr -= source[i - w + j * n];\n        }\n\n        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n      }\n    }\n  }\n}\n\nfunction blurY(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0, sr = 0; j < m + r; ++j) {\n      if (j < m) {\n        sr += source[i + j * n];\n      }\n\n      if (j >= r) {\n        if (j >= w) {\n          sr -= source[i + (j - w) * n];\n        }\n\n        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n      }\n    }\n  }\n}\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\n\n\nfunction KDE2D(params) {\n  Transform.call(this, null, params);\n}\n\nKDE2D.Definition = {\n  'type': 'KDE2D',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'grid'\n  }]\n};\nconst PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\n\nfunction params(obj, _) {\n  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n  return obj;\n}\n\ninherits(KDE2D, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        kde = params(density2D(), _),\n        as = _.as || 'grid',\n        values = [];\n\n    function set(t, vals) {\n      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];\n\n      return t;\n    } // generate density raster grids\n\n\n    values = groups.map(g => ingest(set({\n      [as]: kde(g, _.counts)\n    }, g.dims)));\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n\n});\n\nfunction partition(data, groupby) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\n\n\nfunction Contour(params) {\n  Transform.call(this, null, params);\n}\n\nContour.Definition = {\n  'type': 'Contour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'values',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'x',\n    'type': 'field'\n  }, {\n    'name': 'y',\n    'type': 'field'\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number'\n  }, {\n    'name': 'count',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }]\n};\ninherits(Contour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        contour = contours().smooth(_.smooth !== false),\n        values = _.values,\n        thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n        size = _.size,\n        grid,\n        post;\n\n    if (!values) {\n      values = pulse.materialize(pulse.SOURCE).source;\n      grid = params(density2D(), _)(values, true);\n      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n      size = [grid.width, grid.height];\n      values = grid.values;\n    }\n\n    thresh = isArray(thresh) ? thresh : thresh(values);\n    values = contour.size(size)(values, thresh);\n    if (post) values.forEach(post);\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = (values || []).map(ingest);\n    return out;\n  }\n\n});\nconst Feature = 'Feature';\nconst FeatureCollection = 'FeatureCollection';\nconst MultiPoint = 'MultiPoint';\n/**\n * Consolidate an array of [longitude, latitude] points or GeoJSON features\n * into a combined GeoJSON object. This transform is particularly useful for\n * combining geo data for a Projection's fit argument. The resulting GeoJSON\n * data is available as this transform's value. Input pulses are unchanged.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.fields] - A two-element array\n *   of field accessors for the longitude and latitude values.\n * @param {function(object): *} params.geojson - A field accessor for\n *   retrieving GeoJSON feature data.\n */\n\nfunction GeoJSON(params) {\n  Transform.call(this, null, params);\n}\n\nGeoJSON.Definition = {\n  'type': 'GeoJSON',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'geojson',\n    'type': 'field'\n  }]\n};\ninherits(GeoJSON, Transform, {\n  transform(_, pulse) {\n    var features = this._features,\n        points = this._points,\n        fields = _.fields,\n        lon = fields && fields[0],\n        lat = fields && fields[1],\n        geojson = _.geojson || !fields && identity,\n        flag = pulse.ADD,\n        mod;\n    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified(accessorFields(geojson)) || lon && pulse.modified(accessorFields(lon)) || lat && pulse.modified(accessorFields(lat));\n\n    if (!this.value || mod) {\n      flag = pulse.SOURCE;\n      this._features = features = [];\n      this._points = points = [];\n    }\n\n    if (geojson) {\n      pulse.visit(flag, t => features.push(geojson(t)));\n    }\n\n    if (lon && lat) {\n      pulse.visit(flag, t => {\n        var x = lon(t),\n            y = lat(t);\n\n        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n          points.push([x, y]);\n        }\n      });\n      features = features.concat({\n        type: Feature,\n        geometry: {\n          type: MultiPoint,\n          coordinates: points\n        }\n      });\n    }\n\n    this.value = {\n      type: FeatureCollection,\n      features: features\n    };\n  }\n\n});\n/**\n * Map GeoJSON data to an SVG path string.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='path'] - The output field in which to store\n *   the generated path data (default 'path').\n */\n\nfunction GeoPath(params) {\n  Transform.call(this, null, params);\n}\n\nGeoPath.Definition = {\n  'type': 'GeoPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(GeoPath, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        path = this.value,\n        field = _.field || identity,\n        as = _.as || 'path',\n        flag = out.SOURCE;\n\n    if (!path || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = path = getProjectionPath(_.projection);\n      out.materialize().reflow();\n    } else {\n      flag = field === identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;\n    }\n\n    const prev = initPath(path, _.pointRadius);\n    out.visit(flag, t => t[as] = path(field(t)));\n    path.pointRadius(prev);\n    return out.modifies(as);\n  }\n\n});\n\nfunction initPath(path, pointRadius) {\n  const prev = path.pointRadius();\n  path.context(null);\n\n  if (pointRadius != null) {\n    path.pointRadius(pointRadius);\n  }\n\n  return prev;\n}\n/**\n * Geo-code a longitude/latitude point to an x/y coordinate.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {Array<function(object): *>} params.fields - A two-element array of\n *   field accessors for the longitude and latitude values.\n * @param {Array<string>} [params.as] - A two-element array of field names\n *   under which to store the result. Defaults to ['x','y'].\n */\n\n\nfunction GeoPoint(params) {\n  Transform.call(this, null, params);\n}\n\nGeoPoint.Definition = {\n  'type': 'GeoPoint',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection',\n    'required': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['x', 'y']\n  }]\n};\ninherits(GeoPoint, Transform, {\n  transform(_, pulse) {\n    var proj = _.projection,\n        lon = _.fields[0],\n        lat = _.fields[1],\n        as = _.as || ['x', 'y'],\n        x = as[0],\n        y = as[1],\n        mod;\n\n    function set(t) {\n      const xy = proj([lon(t), lat(t)]);\n\n      if (xy) {\n        t[x] = xy[0];\n        t[y] = xy[1];\n      } else {\n        t[x] = undefined;\n        t[y] = undefined;\n      }\n    }\n\n    if (_.modified()) {\n      // parameters updated, reflow\n      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n    } else {\n      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n    }\n\n    return pulse.modifies(as);\n  }\n\n});\n/**\n * Annotate items with a geopath shape generator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='shape'] - The output field in which to store\n *   the generated path data (default 'shape').\n */\n\nfunction GeoShape(params) {\n  Transform.call(this, null, params);\n}\n\nGeoShape.Definition = {\n  'type': 'GeoShape',\n  'metadata': {\n    'modifies': true,\n    'nomod': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'default': 'datum'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'shape'\n  }]\n};\ninherits(GeoShape, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        shape = this.value,\n        as = _.as || 'shape',\n        flag = out.ADD;\n\n    if (!shape || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = shape = shapeGenerator(getProjectionPath(_.projection), _.field || field('datum'), _.pointRadius);\n      out.materialize().reflow();\n      flag = out.SOURCE;\n    }\n\n    out.visit(flag, t => t[as] = shape);\n    return out.modifies(as);\n  }\n\n});\n\nfunction shapeGenerator(path, field, pointRadius) {\n  const shape = pointRadius == null ? _ => path(field(_)) : _ => {\n    var prev = path.pointRadius(),\n        value = path.pointRadius(pointRadius)(field(_));\n    path.pointRadius(prev);\n    return value;\n  };\n\n  shape.context = _ => {\n    path.context(_);\n    return shape;\n  };\n\n  return shape;\n}\n/**\n * GeoJSON feature generator for creating graticules.\n * @constructor\n */\n\n\nfunction Graticule(params) {\n  Transform.call(this, [], params);\n  this.generator = geoGraticule();\n}\n\nGraticule.Definition = {\n  'type': 'Graticule',\n  'metadata': {\n    'changes': true,\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMajor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMinor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'stepMajor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [90, 360]\n  }, {\n    'name': 'stepMinor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [10, 10]\n  }, {\n    'name': 'precision',\n    'type': 'number',\n    'default': 2.5\n  }]\n};\ninherits(Graticule, Transform, {\n  transform(_, pulse) {\n    var src = this.value,\n        gen = this.generator,\n        t;\n\n    if (!src.length || _.modified()) {\n      for (const prop in _) {\n        if (isFunction(gen[prop])) {\n          gen[prop](_[prop]);\n        }\n      }\n    }\n\n    t = gen();\n\n    if (src.length) {\n      pulse.mod.push(replace(src[0], t));\n    } else {\n      pulse.add.push(ingest(t));\n    }\n\n    src[0] = t;\n    return pulse;\n  }\n\n});\n/**\n * Render a heatmap image for input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {string} [params.color] - A constant color value or function for\n *   individual pixel color. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {number} [params.opacity] - A constant opacity value or function for\n *   individual pixel opacity. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {string} [params.resolve] - The method for resolving maximum values\n *   across multiple input grids. If 'independent' (the default), maximum\n *   calculation will be performed separately for each grid. If 'shared',\n *   a single global maximum will be used for all input grids.\n * @param {string} [params.as='image'] - The output field in which to store\n *   the generated bitmap canvas images (default 'image').\n */\n\nfunction Heatmap(params) {\n  Transform.call(this, null, params);\n}\n\nHeatmap.Definition = {\n  'type': 'heatmap',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'color',\n    'type': 'string',\n    'expr': true\n  }, {\n    'name': 'opacity',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'image'\n  }]\n};\ninherits(Heatmap, Transform, {\n  transform(_, pulse) {\n    if (!pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var source = pulse.materialize(pulse.SOURCE).source,\n        shared = _.resolve === 'shared',\n        field = _.field || identity,\n        opacity = opacity_(_.opacity, _),\n        color = color_(_.color, _),\n        as = _.as || 'image',\n        obj = {\n      $x: 0,\n      $y: 0,\n      $value: 0,\n      $max: shared ? max(source.map(t => max(field(t).values))) : 0\n    };\n    source.forEach(t => {\n      const v = field(t); // build proxy data object\n\n      const o = extend({}, t, obj); // set maximum value if not globally shared\n\n      if (!shared) o.$max = max(v.values || []); // generate canvas image\n      // optimize color/opacity if not pixel-dependent\n\n      t[as] = toCanvas(v, o, color.dep ? color : constant(color(o)), opacity.dep ? opacity : constant(opacity(o)));\n    });\n    return pulse.reflow(true).modifies(as);\n  }\n\n}); // get image color function\n\nfunction color_(color, _) {\n  let f;\n\n  if (isFunction(color)) {\n    f = obj => rgb(color(obj, _));\n\n    f.dep = dependency(color);\n  } else {\n    // default to mid-grey\n    f = constant(rgb(color || '#888'));\n  }\n\n  return f;\n} // get image opacity function\n\n\nfunction opacity_(opacity, _) {\n  let f;\n\n  if (isFunction(opacity)) {\n    f = obj => opacity(obj, _);\n\n    f.dep = dependency(opacity);\n  } else if (opacity) {\n    f = constant(opacity);\n  } else {\n    // default to [0, max] opacity gradient\n    f = obj => obj.$value / obj.$max || 0;\n\n    f.dep = true;\n  }\n\n  return f;\n} // check if function depends on individual pixel data\n\n\nfunction dependency(f) {\n  if (!isFunction(f)) return false;\n  const set = toSet(accessorFields(f));\n  return set.$x || set.$y || set.$value || set.$max;\n} // render raster grid to canvas\n\n\nfunction toCanvas(grid, obj, color, opacity) {\n  const n = grid.width,\n        m = grid.height,\n        x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        x2 = grid.x2 || n,\n        y2 = grid.y2 || m,\n        val = grid.values,\n        value = val ? i => val[i] : zero,\n        can = canvas(x2 - x1, y2 - y1),\n        ctx = can.getContext('2d'),\n        img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n        pix = img.data;\n\n  for (let j = y1, k = 0; j < y2; ++j) {\n    obj.$y = j - y1;\n\n    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {\n      obj.$x = i - x1;\n      obj.$value = value(i + r);\n      const v = color(obj);\n      pix[k + 0] = v.r;\n      pix[k + 1] = v.g;\n      pix[k + 2] = v.b;\n      pix[k + 3] = ~~(255 * opacity(obj));\n    }\n  }\n\n  ctx.putImageData(img, 0, 0);\n  return can;\n}\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\ninherits(Projection, Transform, {\n  transform(_, pulse) {\n    let proj = this.value;\n\n    if (!proj || _.modified('type')) {\n      this.value = proj = create(_.type);\n      projectionProperties.forEach(prop => {\n        if (_[prop] != null) set(proj, prop, _[prop]);\n      });\n    } else {\n      projectionProperties.forEach(prop => {\n        if (_.modified(prop)) set(proj, prop, _[prop]);\n      });\n    }\n\n    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n    if (_.fit) fit(proj, _);\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n\n});\n\nfunction fit(proj, _) {\n  const data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;\n}\n\nfunction create(type) {\n  const constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\n\nfunction set(proj, key, value) {\n  if (isFunction(proj[key])) proj[key](value);\n}\n\nfunction collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0] : {\n    type: FeatureCollection,\n    features: data.reduce((a, f) => a.concat(featurize(f)), [])\n  };\n}\n\nfunction featurize(f) {\n  return f.type === FeatureCollection ? f.features : array(f).filter(d => d != null).map(d => d.type === Feature ? d : {\n    type: Feature,\n    geometry: d\n  });\n}\n\nexport { Contour as contour, GeoJSON as geojson, GeoPath as geopath, GeoPoint as geopoint, GeoShape as geoshape, Graticule as graticule, Heatmap as heatmap, Isocontour as isocontour, KDE2D as kde2d, Projection as projection };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-geo/build/vega-geo.module.js"],"names":["Transform","rederive","ingest","replace","error","extent","inherits","identity","isArray","isFunction","isNumber","constant","array","one","accessorName","accessorFields","field","extend","toSet","zero","range","tickStep","max","sum","bandwidthNRD","getProjectionPath","projectionProperties","projection","geoGraticule","rgb","canvas","noop","cases","contours","dx","dy","smooth","smoothLinear","values","tz","map","value","contour","polygons","holes","isorings","ring","area","push","forEach","hole","i","n","length","polygon","contains","type","coordinates","callback","fragmentByStart","Array","fragmentByEnd","x","y","t0","t1","t2","t3","stitch","line","start","end","startIndex","index","endIndex","f","g","concat","unshift","point","xt","yt","v0","v1","size","_","arguments","_0","Math","floor","_1","c","ringContains","j","pi","xi","yi","pj","xj","yj","segmentContains","a","b","collinear","within","p","q","r","quantize","k","nice","ex","min","stop","span","step","Isocontour","params","call","Definition","transform","pulse","changed","modified","StopPropagation","out","fork","NO_SOURCE","NO_FIELDS","source","materialize","SOURCE","thresholds","levels","as","t","grid","paths","width","height","transformPaths","rem","add","resolve","datum","s","scale","translate","sx","sy","tx","ty","x1","y1","flip","transformPolygon","transformRing","reverse","transformPoint","geometry","radius","bw","data","v","round","sqrt","number","density2D","d","weight","bandwidth","density","counts","rx","ry","ox","oy","m","values0","Float32Array","values1","blurX","blurY","pow","sz","x2","y2","cellSize","log","LN2","target","w","sr","KDE2D","PARAMS","obj","param","groups","partition","groupby","names","kde","set","vals","dims","get","Contour","thresh","count","post","Feature","FeatureCollection","MultiPoint","GeoJSON","features","_features","points","_points","fields","lon","lat","geojson","flag","ADD","mod","REM","visit","GeoPath","ALL","path","reflow","ADD_MOD","prev","initPath","pointRadius","modifies","context","GeoPoint","proj","xy","undefined","GeoShape","shape","shapeGenerator","Graticule","generator","src","gen","prop","Heatmap","shared","opacity","opacity_","color","color_","$x","$y","$value","$max","o","toCanvas","dep","dependency","val","can","ctx","getContext","img","getImageData","pix","putImageData","Projection","create","fit","collectGeoJSON","fitExtent","fitSize","constructor","toLowerCase","key","reduce","featurize","filter","geopath","geopoint","geoshape","graticule","heatmap","isocontour","kde2d"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,EAA8BC,MAA9B,EAAsCC,OAAtC,QAAqD,eAArD;AACA,SAASC,KAAT,EAAgBC,MAAhB,EAAwBC,QAAxB,EAAkCC,QAAlC,EAA4CC,OAA5C,EAAqDC,UAArD,EAAiEC,QAAjE,EAA2EC,QAA3E,EAAqFC,KAArF,EAA4FC,GAA5F,EAAiGC,YAAjG,EAA+GC,cAA/G,EAA+HC,KAA/H,EAAsIC,MAAtI,EAA8IC,KAA9I,EAAqJC,IAArJ,QAAiK,WAAjK;AACA,SAASC,KAAT,EAAgBC,QAAhB,EAA0BC,GAA1B,EAA+BC,GAA/B,QAA0C,UAA1C;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,SAASC,iBAAT,EAA4BC,oBAA5B,EAAkDC,UAAlD,QAAoE,iBAApE;AACA,SAASC,YAAT,QAA6B,QAA7B;AACA,SAASC,GAAT,QAAoB,UAApB;AACA,SAASC,MAAT,QAAuB,aAAvB;;AAEA,SAASC,IAAT,GAAgB,CAAE;;AAElB,MAAMC,KAAK,GAAG,CAAC,EAAD,EAAK,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAL,EAAiC,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAjC,EAA6D,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAA7D,EAAyF,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAzF,EAAqH,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,EAA2B,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAA3B,CAArH,EAA2K,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAA3K,EAAuM,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAvM,EAAmO,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAnO,EAA+P,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAA/P,EAA2R,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,EAA2B,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAA3B,CAA3R,EAAiV,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAjV,EAA6W,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAA7W,EAAyY,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAzY,EAAqa,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,CAAC,GAAD,EAAM,GAAN,CAAb,CAAD,CAAra,EAAic,EAAjc,CAAd,C,CAAod;;AAEpd,SAASC,QAAT,GAAqB;AACnB,MAAIC,EAAE,GAAG,CAAT;AAAA,MACIC,EAAE,GAAG,CADT;AAAA,MAEIC,MAAM,GAAGC,YAFb;;AAIA,WAASJ,QAAT,CAAkBK,MAAlB,EAA0BC,EAA1B,EAA8B;AAC5B,WAAOA,EAAE,CAACC,GAAH,CAAOC,KAAK,IAAIC,OAAO,CAACJ,MAAD,EAASG,KAAT,CAAvB,CAAP;AACD,GAPkB,CAOjB;AACF;;;AAGA,WAASC,OAAT,CAAiBJ,MAAjB,EAAyBG,KAAzB,EAAgC;AAC9B,QAAIE,QAAQ,GAAG,EAAf;AAAA,QACIC,KAAK,GAAG,EADZ;AAEAC,IAAAA,QAAQ,CAACP,MAAD,EAASG,KAAT,EAAgBK,IAAI,IAAI;AAC9BV,MAAAA,MAAM,CAACU,IAAD,EAAOR,MAAP,EAAeG,KAAf,CAAN;AACA,UAAIM,IAAI,CAACD,IAAD,CAAJ,GAAa,CAAjB,EAAoBH,QAAQ,CAACK,IAAT,CAAc,CAACF,IAAD,CAAd,EAApB,KAA+CF,KAAK,CAACI,IAAN,CAAWF,IAAX;AAChD,KAHO,CAAR;AAIAF,IAAAA,KAAK,CAACK,OAAN,CAAcC,IAAI,IAAI;AACpB,WAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGT,QAAQ,CAACU,MAAxB,EAAgCC,OAArC,EAA8CH,CAAC,GAAGC,CAAlD,EAAqD,EAAED,CAAvD,EAA0D;AACxD,YAAII,QAAQ,CAAC,CAACD,OAAO,GAAGX,QAAQ,CAACQ,CAAD,CAAnB,EAAwB,CAAxB,CAAD,EAA6BD,IAA7B,CAAR,KAA+C,CAAC,CAApD,EAAuD;AACrDI,UAAAA,OAAO,CAACN,IAAR,CAAaE,IAAb;AACA;AACD;AACF;AACF,KAPD;AAQA,WAAO;AACLM,MAAAA,IAAI,EAAE,cADD;AAELf,MAAAA,KAAK,EAAEA,KAFF;AAGLgB,MAAAA,WAAW,EAAEd;AAHR,KAAP;AAKD,GA/BkB,CA+BjB;AACF;;;AAGA,WAASE,QAAT,CAAkBP,MAAlB,EAA0BG,KAA1B,EAAiCiB,QAAjC,EAA2C;AACzC,QAAIC,eAAe,GAAG,IAAIC,KAAJ,EAAtB;AAAA,QACIC,aAAa,GAAG,IAAID,KAAJ,EADpB;AAAA,QAEIE,CAFJ;AAAA,QAGIC,CAHJ;AAAA,QAIIC,EAJJ;AAAA,QAKIC,EALJ;AAAA,QAMIC,EANJ;AAAA,QAOIC,EAPJ,CADyC,CAQjC;;AAERL,IAAAA,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAT;AACAE,IAAAA,EAAE,GAAG3B,MAAM,CAAC,CAAD,CAAN,IAAaG,KAAlB;AACAT,IAAAA,KAAK,CAACiC,EAAE,IAAI,CAAP,CAAL,CAAehB,OAAf,CAAuBmB,MAAvB;;AAEA,WAAO,EAAEN,CAAF,GAAM5B,EAAE,GAAG,CAAlB,EAAqB;AACnB8B,MAAAA,EAAE,GAAGC,EAAL,EAASA,EAAE,GAAG3B,MAAM,CAACwB,CAAC,GAAG,CAAL,CAAN,IAAiBrB,KAA/B;AACAT,MAAAA,KAAK,CAACgC,EAAE,GAAGC,EAAE,IAAI,CAAZ,CAAL,CAAoBhB,OAApB,CAA4BmB,MAA5B;AACD;;AAEDpC,IAAAA,KAAK,CAACiC,EAAE,IAAI,CAAP,CAAL,CAAehB,OAAf,CAAuBmB,MAAvB,EAnByC,CAmBT;;AAEhC,WAAO,EAAEL,CAAF,GAAM5B,EAAE,GAAG,CAAlB,EAAqB;AACnB2B,MAAAA,CAAC,GAAG,CAAC,CAAL;AACAG,MAAAA,EAAE,GAAG3B,MAAM,CAACyB,CAAC,GAAG7B,EAAJ,GAASA,EAAV,CAAN,IAAuBO,KAA5B;AACAyB,MAAAA,EAAE,GAAG5B,MAAM,CAACyB,CAAC,GAAG7B,EAAL,CAAN,IAAkBO,KAAvB;AACAT,MAAAA,KAAK,CAACiC,EAAE,IAAI,CAAN,GAAUC,EAAE,IAAI,CAAjB,CAAL,CAAyBjB,OAAzB,CAAiCmB,MAAjC;;AAEA,aAAO,EAAEN,CAAF,GAAM5B,EAAE,GAAG,CAAlB,EAAqB;AACnB8B,QAAAA,EAAE,GAAGC,EAAL,EAASA,EAAE,GAAG3B,MAAM,CAACyB,CAAC,GAAG7B,EAAJ,GAASA,EAAT,GAAc4B,CAAd,GAAkB,CAAnB,CAAN,IAA+BrB,KAA7C;AACA0B,QAAAA,EAAE,GAAGD,EAAL,EAASA,EAAE,GAAG5B,MAAM,CAACyB,CAAC,GAAG7B,EAAJ,GAAS4B,CAAT,GAAa,CAAd,CAAN,IAA0BrB,KAAxC;AACAT,QAAAA,KAAK,CAACgC,EAAE,GAAGC,EAAE,IAAI,CAAX,GAAeC,EAAE,IAAI,CAArB,GAAyBC,EAAE,IAAI,CAAhC,CAAL,CAAwClB,OAAxC,CAAgDmB,MAAhD;AACD;;AAEDpC,MAAAA,KAAK,CAACiC,EAAE,GAAGC,EAAE,IAAI,CAAZ,CAAL,CAAoBjB,OAApB,CAA4BmB,MAA5B;AACD,KAlCwC,CAkCvC;;;AAGFN,IAAAA,CAAC,GAAG,CAAC,CAAL;AACAI,IAAAA,EAAE,GAAG5B,MAAM,CAACyB,CAAC,GAAG7B,EAAL,CAAN,IAAkBO,KAAvB;AACAT,IAAAA,KAAK,CAACkC,EAAE,IAAI,CAAP,CAAL,CAAejB,OAAf,CAAuBmB,MAAvB;;AAEA,WAAO,EAAEN,CAAF,GAAM5B,EAAE,GAAG,CAAlB,EAAqB;AACnBiC,MAAAA,EAAE,GAAGD,EAAL,EAASA,EAAE,GAAG5B,MAAM,CAACyB,CAAC,GAAG7B,EAAJ,GAAS4B,CAAT,GAAa,CAAd,CAAN,IAA0BrB,KAAxC;AACAT,MAAAA,KAAK,CAACkC,EAAE,IAAI,CAAN,GAAUC,EAAE,IAAI,CAAjB,CAAL,CAAyBlB,OAAzB,CAAiCmB,MAAjC;AACD;;AAEDpC,IAAAA,KAAK,CAACkC,EAAE,IAAI,CAAP,CAAL,CAAejB,OAAf,CAAuBmB,MAAvB;;AAEA,aAASA,MAAT,CAAgBC,IAAhB,EAAsB;AACpB,UAAIC,KAAK,GAAG,CAACD,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,IAAaP,CAAd,EAAiBO,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,IAAaN,CAA9B,CAAZ;AAAA,UACIQ,GAAG,GAAG,CAACF,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,IAAaP,CAAd,EAAiBO,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,IAAaN,CAA9B,CADV;AAAA,UAEIS,UAAU,GAAGC,KAAK,CAACH,KAAD,CAFtB;AAAA,UAGII,QAAQ,GAAGD,KAAK,CAACF,GAAD,CAHpB;AAAA,UAIII,CAJJ;AAAA,UAKIC,CALJ;;AAOA,UAAID,CAAC,GAAGd,aAAa,CAACW,UAAD,CAArB,EAAmC;AACjC,YAAII,CAAC,GAAGjB,eAAe,CAACe,QAAD,CAAvB,EAAmC;AACjC,iBAAOb,aAAa,CAACc,CAAC,CAACJ,GAAH,CAApB;AACA,iBAAOZ,eAAe,CAACiB,CAAC,CAACN,KAAH,CAAtB;;AAEA,cAAIK,CAAC,KAAKC,CAAV,EAAa;AACXD,YAAAA,CAAC,CAAC7B,IAAF,CAAOE,IAAP,CAAYuB,GAAZ;AACAb,YAAAA,QAAQ,CAACiB,CAAC,CAAC7B,IAAH,CAAR;AACD,WAHD,MAGO;AACLa,YAAAA,eAAe,CAACgB,CAAC,CAACL,KAAH,CAAf,GAA2BT,aAAa,CAACe,CAAC,CAACL,GAAH,CAAb,GAAuB;AAChDD,cAAAA,KAAK,EAAEK,CAAC,CAACL,KADuC;AAEhDC,cAAAA,GAAG,EAAEK,CAAC,CAACL,GAFyC;AAGhDzB,cAAAA,IAAI,EAAE6B,CAAC,CAAC7B,IAAF,CAAO+B,MAAP,CAAcD,CAAC,CAAC9B,IAAhB;AAH0C,aAAlD;AAKD;AACF,SAdD,MAcO;AACL,iBAAOe,aAAa,CAACc,CAAC,CAACJ,GAAH,CAApB;AACAI,UAAAA,CAAC,CAAC7B,IAAF,CAAOE,IAAP,CAAYuB,GAAZ;AACAV,UAAAA,aAAa,CAACc,CAAC,CAACJ,GAAF,GAAQG,QAAT,CAAb,GAAkCC,CAAlC;AACD;AACF,OApBD,MAoBO,IAAIA,CAAC,GAAGhB,eAAe,CAACe,QAAD,CAAvB,EAAmC;AACxC,YAAIE,CAAC,GAAGf,aAAa,CAACW,UAAD,CAArB,EAAmC;AACjC,iBAAOb,eAAe,CAACgB,CAAC,CAACL,KAAH,CAAtB;AACA,iBAAOT,aAAa,CAACe,CAAC,CAACL,GAAH,CAApB;;AAEA,cAAII,CAAC,KAAKC,CAAV,EAAa;AACXD,YAAAA,CAAC,CAAC7B,IAAF,CAAOE,IAAP,CAAYuB,GAAZ;AACAb,YAAAA,QAAQ,CAACiB,CAAC,CAAC7B,IAAH,CAAR;AACD,WAHD,MAGO;AACLa,YAAAA,eAAe,CAACiB,CAAC,CAACN,KAAH,CAAf,GAA2BT,aAAa,CAACc,CAAC,CAACJ,GAAH,CAAb,GAAuB;AAChDD,cAAAA,KAAK,EAAEM,CAAC,CAACN,KADuC;AAEhDC,cAAAA,GAAG,EAAEI,CAAC,CAACJ,GAFyC;AAGhDzB,cAAAA,IAAI,EAAE8B,CAAC,CAAC9B,IAAF,CAAO+B,MAAP,CAAcF,CAAC,CAAC7B,IAAhB;AAH0C,aAAlD;AAKD;AACF,SAdD,MAcO;AACL,iBAAOa,eAAe,CAACgB,CAAC,CAACL,KAAH,CAAtB;AACAK,UAAAA,CAAC,CAAC7B,IAAF,CAAOgC,OAAP,CAAeR,KAAf;AACAX,UAAAA,eAAe,CAACgB,CAAC,CAACL,KAAF,GAAUE,UAAX,CAAf,GAAwCG,CAAxC;AACD;AACF,OApBM,MAoBA;AACLhB,QAAAA,eAAe,CAACa,UAAD,CAAf,GAA8BX,aAAa,CAACa,QAAD,CAAb,GAA0B;AACtDJ,UAAAA,KAAK,EAAEE,UAD+C;AAEtDD,UAAAA,GAAG,EAAEG,QAFiD;AAGtD5B,UAAAA,IAAI,EAAE,CAACwB,KAAD,EAAQC,GAAR;AAHgD,SAAxD;AAKD;AACF;AACF;;AAED,WAASE,KAAT,CAAeM,KAAf,EAAsB;AACpB,WAAOA,KAAK,CAAC,CAAD,CAAL,GAAW,CAAX,GAAeA,KAAK,CAAC,CAAD,CAAL,IAAY7C,EAAE,GAAG,CAAjB,IAAsB,CAA5C;AACD;;AAED,WAASG,YAAT,CAAsBS,IAAtB,EAA4BR,MAA5B,EAAoCG,KAApC,EAA2C;AACzCK,IAAAA,IAAI,CAACG,OAAL,CAAa8B,KAAK,IAAI;AACpB,UAAIjB,CAAC,GAAGiB,KAAK,CAAC,CAAD,CAAb;AAAA,UACIhB,CAAC,GAAGgB,KAAK,CAAC,CAAD,CADb;AAAA,UAEIC,EAAE,GAAGlB,CAAC,GAAG,CAFb;AAAA,UAGImB,EAAE,GAAGlB,CAAC,GAAG,CAHb;AAAA,UAIImB,EAJJ;AAAA,UAKIC,EAAE,GAAG7C,MAAM,CAAC2C,EAAE,GAAG/C,EAAL,GAAU8C,EAAX,CALf;;AAOA,UAAIlB,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG5B,EAAb,IAAmB8C,EAAE,KAAKlB,CAA9B,EAAiC;AAC/BoB,QAAAA,EAAE,GAAG5C,MAAM,CAAC2C,EAAE,GAAG/C,EAAL,GAAU8C,EAAV,GAAe,CAAhB,CAAX;AACAD,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWjB,CAAC,GAAG,CAACrB,KAAK,GAAGyC,EAAT,KAAgBC,EAAE,GAAGD,EAArB,CAAJ,GAA+B,GAA1C;AACD;;AAED,UAAInB,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG5B,EAAb,IAAmB8C,EAAE,KAAKlB,CAA9B,EAAiC;AAC/BmB,QAAAA,EAAE,GAAG5C,MAAM,CAAC,CAAC2C,EAAE,GAAG,CAAN,IAAW/C,EAAX,GAAgB8C,EAAjB,CAAX;AACAD,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWhB,CAAC,GAAG,CAACtB,KAAK,GAAGyC,EAAT,KAAgBC,EAAE,GAAGD,EAArB,CAAJ,GAA+B,GAA1C;AACD;AACF,KAjBD;AAkBD;;AAEDjD,EAAAA,QAAQ,CAACS,OAAT,GAAmBA,OAAnB;;AAEAT,EAAAA,QAAQ,CAACmD,IAAT,GAAgB,UAAUC,CAAV,EAAa;AAC3B,QAAI,CAACC,SAAS,CAACjC,MAAf,EAAuB,OAAO,CAACnB,EAAD,EAAKC,EAAL,CAAP;;AAEvB,QAAIoD,EAAE,GAAGC,IAAI,CAACC,KAAL,CAAWJ,CAAC,CAAC,CAAD,CAAZ,CAAT;AAAA,QACIK,EAAE,GAAGF,IAAI,CAACC,KAAL,CAAWJ,CAAC,CAAC,CAAD,CAAZ,CADT;;AAGA,QAAI,EAAEE,EAAE,IAAI,CAAN,IAAWG,EAAE,IAAI,CAAnB,CAAJ,EAA2BtF,KAAK,CAAC,cAAD,CAAL;AAC3B,WAAO8B,EAAE,GAAGqD,EAAL,EAASpD,EAAE,GAAGuD,EAAd,EAAkBzD,QAAzB;AACD,GARD;;AAUAA,EAAAA,QAAQ,CAACG,MAAT,GAAkB,UAAUiD,CAAV,EAAa;AAC7B,WAAOC,SAAS,CAACjC,MAAV,IAAoBjB,MAAM,GAAGiD,CAAC,GAAGhD,YAAH,GAAkBN,IAA5B,EAAkCE,QAAtD,IAAkEG,MAAM,KAAKC,YAApF;AACD,GAFD;;AAIA,SAAOJ,QAAP;AACD;;AAED,SAASc,IAAT,CAAcD,IAAd,EAAoB;AAClB,MAAIK,CAAC,GAAG,CAAR;AAAA,MACIC,CAAC,GAAGN,IAAI,CAACO,MADb;AAAA,MAEIN,IAAI,GAAGD,IAAI,CAACM,CAAC,GAAG,CAAL,CAAJ,CAAY,CAAZ,IAAiBN,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAjB,GAA8BA,IAAI,CAACM,CAAC,GAAG,CAAL,CAAJ,CAAY,CAAZ,IAAiBN,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAF1D;;AAIA,SAAO,EAAEK,CAAF,GAAMC,CAAb,EAAgBL,IAAI,IAAID,IAAI,CAACK,CAAC,GAAG,CAAL,CAAJ,CAAY,CAAZ,IAAiBL,IAAI,CAACK,CAAD,CAAJ,CAAQ,CAAR,CAAjB,GAA8BL,IAAI,CAACK,CAAC,GAAG,CAAL,CAAJ,CAAY,CAAZ,IAAiBL,IAAI,CAACK,CAAD,CAAJ,CAAQ,CAAR,CAAvD;;AAEhB,SAAOJ,IAAP;AACD;;AAED,SAASQ,QAAT,CAAkBT,IAAlB,EAAwBI,IAAxB,EAA8B;AAC5B,MAAIC,CAAC,GAAG,CAAC,CAAT;AAAA,MACIC,CAAC,GAAGF,IAAI,CAACG,MADb;AAAA,MAEIsC,CAFJ;;AAIA,SAAO,EAAExC,CAAF,GAAMC,CAAb,EAAgB,IAAIuC,CAAC,GAAGC,YAAY,CAAC9C,IAAD,EAAOI,IAAI,CAACC,CAAD,CAAX,CAApB,EAAqC,OAAOwC,CAAP;;AAErD,SAAO,CAAP;AACD;;AAED,SAASC,YAAT,CAAsB9C,IAAtB,EAA4BiC,KAA5B,EAAmC;AACjC,MAAIjB,CAAC,GAAGiB,KAAK,CAAC,CAAD,CAAb;AAAA,MACIhB,CAAC,GAAGgB,KAAK,CAAC,CAAD,CADb;AAAA,MAEIxB,QAAQ,GAAG,CAAC,CAFhB;;AAIA,OAAK,IAAIJ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGN,IAAI,CAACO,MAApB,EAA4BwC,CAAC,GAAGzC,CAAC,GAAG,CAAzC,EAA4CD,CAAC,GAAGC,CAAhD,EAAmDyC,CAAC,GAAG1C,CAAC,EAAxD,EAA4D;AAC1D,QAAI2C,EAAE,GAAGhD,IAAI,CAACK,CAAD,CAAb;AAAA,QACI4C,EAAE,GAAGD,EAAE,CAAC,CAAD,CADX;AAAA,QAEIE,EAAE,GAAGF,EAAE,CAAC,CAAD,CAFX;AAAA,QAGIG,EAAE,GAAGnD,IAAI,CAAC+C,CAAD,CAHb;AAAA,QAIIK,EAAE,GAAGD,EAAE,CAAC,CAAD,CAJX;AAAA,QAKIE,EAAE,GAAGF,EAAE,CAAC,CAAD,CALX;AAMA,QAAIG,eAAe,CAACN,EAAD,EAAKG,EAAL,EAASlB,KAAT,CAAnB,EAAoC,OAAO,CAAP;AACpC,QAAIiB,EAAE,GAAGjC,CAAL,KAAWoC,EAAE,GAAGpC,CAAhB,IAAqBD,CAAC,GAAG,CAACoC,EAAE,GAAGH,EAAN,KAAahC,CAAC,GAAGiC,EAAjB,KAAwBG,EAAE,GAAGH,EAA7B,IAAmCD,EAAhE,EAAoExC,QAAQ,GAAG,CAACA,QAAZ;AACrE;;AAED,SAAOA,QAAP;AACD;;AAED,SAAS6C,eAAT,CAAyBC,CAAzB,EAA4BC,CAA5B,EAA+BX,CAA/B,EAAkC;AAChC,MAAIxC,CAAJ;AACA,SAAOoD,SAAS,CAACF,CAAD,EAAIC,CAAJ,EAAOX,CAAP,CAAT,IAAsBa,MAAM,CAACH,CAAC,CAAClD,CAAC,GAAG,EAAEkD,CAAC,CAAC,CAAD,CAAD,KAASC,CAAC,CAAC,CAAD,CAAZ,CAAL,CAAF,EAA0BX,CAAC,CAACxC,CAAD,CAA3B,EAAgCmD,CAAC,CAACnD,CAAD,CAAjC,CAAnC;AACD;;AAED,SAASoD,SAAT,CAAmBF,CAAnB,EAAsBC,CAAtB,EAAyBX,CAAzB,EAA4B;AAC1B,SAAO,CAACW,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAT,KAAiBV,CAAC,CAAC,CAAD,CAAD,GAAOU,CAAC,CAAC,CAAD,CAAzB,MAAkC,CAACV,CAAC,CAAC,CAAD,CAAD,GAAOU,CAAC,CAAC,CAAD,CAAT,KAAiBC,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAzB,CAAzC;AACD;;AAED,SAASG,MAAT,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyB;AACvB,SAAOF,CAAC,IAAIC,CAAL,IAAUA,CAAC,IAAIC,CAAf,IAAoBA,CAAC,IAAID,CAAL,IAAUA,CAAC,IAAID,CAA1C;AACD;;AAED,SAASG,QAAT,CAAmBC,CAAnB,EAAsBC,IAAtB,EAA4B3F,IAA5B,EAAkC;AAChC,SAAO,UAAUmB,MAAV,EAAkB;AACvB,QAAIyE,EAAE,GAAG1G,MAAM,CAACiC,MAAD,CAAf;AAAA,QACIgC,KAAK,GAAGnD,IAAI,GAAGqE,IAAI,CAACwB,GAAL,CAASD,EAAE,CAAC,CAAD,CAAX,EAAgB,CAAhB,CAAH,GAAwBA,EAAE,CAAC,CAAD,CAD1C;AAAA,QAEIE,IAAI,GAAGF,EAAE,CAAC,CAAD,CAFb;AAAA,QAGIG,IAAI,GAAGD,IAAI,GAAG3C,KAHlB;AAAA,QAII6C,IAAI,GAAGL,IAAI,GAAGzF,QAAQ,CAACiD,KAAD,EAAQ2C,IAAR,EAAcJ,CAAd,CAAX,GAA8BK,IAAI,IAAIL,CAAC,GAAG,CAAR,CAJjD;AAKA,WAAOzF,KAAK,CAACkD,KAAK,GAAG6C,IAAT,EAAeF,IAAf,EAAqBE,IAArB,CAAZ;AACD,GAPD;AAQD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAASC,UAAT,CAAoBC,MAApB,EAA4B;AAC1BrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDD,UAAU,CAACG,UAAX,GAAwB;AACtB,UAAQ,YADc;AAEtB,cAAY;AACV,iBAAa;AADH,GAFU;AAKtB,YAAU,CAAC;AACT,YAAQ,OADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,YADP;AAED,YAAQ,QAFP;AAGD,aAAS;AAHR,GAHO,EAOP;AACD,YAAQ,QADP;AAED,YAAQ;AAFP,GAPO,EAUP;AACD,YAAQ,MADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GAVO,EAcP;AACD,YAAQ,SADP;AAED,YAAQ,MAFP;AAGD,cAAU,CAAC,QAAD,EAAW,aAAX,CAHT;AAID,eAAW;AAJV,GAdO,EAmBP;AACD,YAAQ,MADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GAnBO,EAuBP;AACD,YAAQ,QADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GAvBO,EA2BP;AACD,YAAQ,OADP;AAED,YAAQ,QAFP;AAGD,YAAQ;AAHP,GA3BO,EA+BP;AACD,YAAQ,WADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,YAAQ;AAJP,GA/BO,EAoCP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,YAAQ,IAHP;AAID,eAAW;AAJV,GApCO;AALY,CAAxB;AAgDAjH,QAAQ,CAAC8G,UAAD,EAAapH,SAAb,EAAwB;AAC9BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAI,KAAKhF,KAAL,IAAc,CAACgF,KAAK,CAACC,OAAN,EAAf,IAAkC,CAACrC,CAAC,CAACsC,QAAF,EAAvC,EAAqD;AACnD,aAAOF,KAAK,CAACG,eAAb;AACD;;AAED,QAAIC,GAAG,GAAGJ,KAAK,CAACK,IAAN,CAAWL,KAAK,CAACM,SAAN,GAAkBN,KAAK,CAACO,SAAnC,CAAV;AAAA,QACIC,MAAM,GAAGR,KAAK,CAACS,WAAN,CAAkBT,KAAK,CAACU,MAAxB,EAAgCF,MAD7C;AAAA,QAEIjH,KAAK,GAAGqE,CAAC,CAACrE,KAAF,IAAWT,QAFvB;AAAA,QAGImC,OAAO,GAAGT,QAAQ,GAAGG,MAAX,CAAkBiD,CAAC,CAACjD,MAAF,KAAa,KAA/B,CAHd;AAAA,QAIIG,EAAE,GAAG8C,CAAC,CAAC+C,UAAF,IAAgBC,MAAM,CAACJ,MAAD,EAASjH,KAAT,EAAgBqE,CAAhB,CAJ/B;AAAA,QAKIiD,EAAE,GAAGjD,CAAC,CAACiD,EAAF,KAAS,IAAT,GAAgB,IAAhB,GAAuBjD,CAAC,CAACiD,EAAF,IAAQ,SALxC;AAAA,QAMIhG,MAAM,GAAG,EANb;AAOA2F,IAAAA,MAAM,CAAChF,OAAP,CAAesF,CAAC,IAAI;AAClB,YAAMC,IAAI,GAAGxH,KAAK,CAACuH,CAAD,CAAlB,CADkB,CACK;;AAEvB,YAAME,KAAK,GAAG/F,OAAO,CAAC0C,IAAR,CAAa,CAACoD,IAAI,CAACE,KAAN,EAAaF,IAAI,CAACG,MAAlB,CAAb,EAAwCH,IAAI,CAAClG,MAA7C,EAAqD9B,OAAO,CAAC+B,EAAD,CAAP,GAAcA,EAAd,GAAmBA,EAAE,CAACiG,IAAI,CAAClG,MAAN,CAA1E,CAAd,CAHkB,CAGsF;;AAExGsG,MAAAA,cAAc,CAACH,KAAD,EAAQD,IAAR,EAAcD,CAAd,EAAiBlD,CAAjB,CAAd,CALkB,CAKiB;;AAEnCoD,MAAAA,KAAK,CAACxF,OAAN,CAAcwD,CAAC,IAAI;AACjBnE,QAAAA,MAAM,CAACU,IAAP,CAAY/C,QAAQ,CAACsI,CAAD,EAAIrI,MAAM,CAACoI,EAAE,IAAI,IAAN,GAAa;AAC1C,WAACA,EAAD,GAAM7B;AADoC,SAAb,GAE3BA,CAF0B,CAAV,CAApB;AAGD,OAJD;AAKD,KAZD;AAaA,QAAI,KAAKhE,KAAT,EAAgBoF,GAAG,CAACgB,GAAJ,GAAU,KAAKpG,KAAf;AAChB,SAAKA,KAAL,GAAaoF,GAAG,CAACI,MAAJ,GAAaJ,GAAG,CAACiB,GAAJ,GAAUxG,MAApC;AACA,WAAOuF,GAAP;AACD;;AA7B6B,CAAxB,CAAR;;AAiCA,SAASQ,MAAT,CAAgB/F,MAAhB,EAAwBqC,CAAxB,EAA2BU,CAA3B,EAA8B;AAC5B,QAAMqB,CAAC,GAAGE,QAAQ,CAACvB,CAAC,CAACgD,MAAF,IAAY,EAAb,EAAiBhD,CAAC,CAACyB,IAAnB,EAAyBzB,CAAC,CAAClE,IAAF,KAAW,KAApC,CAAlB;AACA,SAAOkE,CAAC,CAAC0D,OAAF,KAAc,QAAd,GAAyBrC,CAAzB,GAA6BA,CAAC,CAACpE,MAAM,CAACE,GAAP,CAAW+F,CAAC,IAAIjH,GAAG,CAACqD,CAAC,CAAC4D,CAAD,CAAD,CAAKjG,MAAN,CAAnB,CAAD,CAArC;AACD;;AAED,SAASsG,cAAT,CAAwBH,KAAxB,EAA+BD,IAA/B,EAAqCQ,KAArC,EAA4C3D,CAA5C,EAA+C;AAC7C,MAAI4D,CAAC,GAAG5D,CAAC,CAAC6D,KAAF,IAAWV,IAAI,CAACU,KAAxB;AAAA,MACIX,CAAC,GAAGlD,CAAC,CAAC8D,SAAF,IAAeX,IAAI,CAACW,SAD5B;AAEA,MAAI1I,UAAU,CAACwI,CAAD,CAAd,EAAmBA,CAAC,GAAGA,CAAC,CAACD,KAAD,EAAQ3D,CAAR,CAAL;AACnB,MAAI5E,UAAU,CAAC8H,CAAD,CAAd,EAAmBA,CAAC,GAAGA,CAAC,CAACS,KAAD,EAAQ3D,CAAR,CAAL;AACnB,MAAI,CAAC4D,CAAC,KAAK,CAAN,IAAWA,CAAC,IAAI,IAAjB,KAA0B,CAACV,CAA/B,EAAkC;AAClC,QAAMa,EAAE,GAAG,CAAC1I,QAAQ,CAACuI,CAAD,CAAR,GAAcA,CAAd,GAAkBA,CAAC,CAAC,CAAD,CAApB,KAA4B,CAAvC;AAAA,QACMI,EAAE,GAAG,CAAC3I,QAAQ,CAACuI,CAAD,CAAR,GAAcA,CAAd,GAAkBA,CAAC,CAAC,CAAD,CAApB,KAA4B,CADvC;AAAA,QAEMK,EAAE,GAAGf,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAN,IAAa,CAFxB;AAAA,QAGMgB,EAAE,GAAGhB,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAN,IAAa,CAHxB;AAIAE,EAAAA,KAAK,CAACxF,OAAN,CAAcuE,SAAS,CAACgB,IAAD,EAAOY,EAAP,EAAWC,EAAX,EAAeC,EAAf,EAAmBC,EAAnB,CAAvB;AACD;;AAED,SAAS/B,SAAT,CAAmBgB,IAAnB,EAAyBY,EAAzB,EAA6BC,EAA7B,EAAiCC,EAAjC,EAAqCC,EAArC,EAAyC;AACvC,QAAMC,EAAE,GAAGhB,IAAI,CAACgB,EAAL,IAAW,CAAtB;AAAA,QACMC,EAAE,GAAGjB,IAAI,CAACiB,EAAL,IAAW,CADtB;AAAA,QAEMC,IAAI,GAAGN,EAAE,GAAGC,EAAL,GAAU,CAFvB;;AAIA,WAASM,gBAAT,CAA0BlG,WAA1B,EAAuC;AACrCA,IAAAA,WAAW,CAACR,OAAZ,CAAoB2G,aAApB;AACD;;AAED,WAASA,aAAT,CAAuBnG,WAAvB,EAAoC;AAClC,QAAIiG,IAAJ,EAAUjG,WAAW,CAACoG,OAAZ,GADwB,CACD;;AAEjCpG,IAAAA,WAAW,CAACR,OAAZ,CAAoB6G,cAApB;AACD;;AAED,WAASA,cAAT,CAAwBrG,WAAxB,EAAqC;AACnCA,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAACA,WAAW,CAAC,CAAD,CAAX,GAAiB+F,EAAlB,IAAwBJ,EAAxB,GAA6BE,EAA9C;AACA7F,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAACA,WAAW,CAAC,CAAD,CAAX,GAAiBgG,EAAlB,IAAwBJ,EAAxB,GAA6BE,EAA9C;AACD;;AAED,SAAO,UAAUQ,QAAV,EAAoB;AACzBA,IAAAA,QAAQ,CAACtG,WAAT,CAAqBR,OAArB,CAA6B0G,gBAA7B;AACA,WAAOI,QAAP;AACD,GAHD;AAID;;AAED,SAASC,MAAT,CAAgBC,EAAhB,EAAoBC,IAApB,EAA0BvF,CAA1B,EAA6B;AAC3B,QAAMwF,CAAC,GAAGF,EAAE,IAAI,CAAN,GAAUA,EAAV,GAAezI,YAAY,CAAC0I,IAAD,EAAOvF,CAAP,CAArC;AACA,SAAOa,IAAI,CAAC4E,KAAL,CAAW,CAAC5E,IAAI,CAAC6E,IAAL,CAAU,IAAIF,CAAJ,GAAQA,CAAR,GAAY,CAAtB,IAA2B,CAA5B,IAAiC,CAA5C,CAAP;AACD;;AAED,SAASG,MAAT,CAAgBjF,CAAhB,EAAmB;AACjB,SAAO5E,UAAU,CAAC4E,CAAD,CAAV,GAAgBA,CAAhB,GAAoB1E,QAAQ,CAAC,CAAC0E,CAAF,CAAnC;AACD,C,CAAC;;;AAGF,SAASkF,SAAT,GAAsB;AACpB,MAAIzG,CAAC,GAAG0G,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAd;AAAA,MACIzG,CAAC,GAAGyG,CAAC,IAAIA,CAAC,CAAC,CAAD,CADd;AAAA,MAEIC,MAAM,GAAG5J,GAFb;AAAA,MAGI6J,SAAS,GAAG,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAHhB;AAAA,MAIIxI,EAAE,GAAG,GAJT;AAAA,MAKIC,EAAE,GAAG,GALT;AAAA,MAMI0E,CAAC,GAAG,CANR,CADoB,CAOT;;;AAGX,WAAS8D,OAAT,CAAiBT,IAAjB,EAAuBU,MAAvB,EAA+B;AAC7B,UAAMC,EAAE,GAAGb,MAAM,CAACU,SAAS,CAAC,CAAD,CAAV,EAAeR,IAAf,EAAqBpG,CAArB,CAAN,IAAiC+C,CAA5C;AAAA,UACM;AACNiE,IAAAA,EAAE,GAAGd,MAAM,CAACU,SAAS,CAAC,CAAD,CAAV,EAAeR,IAAf,EAAqBnG,CAArB,CAAN,IAAiC8C,CAFtC;AAAA,UAGM;AACNkE,IAAAA,EAAE,GAAGF,EAAE,GAAGA,EAAE,GAAG,CAAR,GAAY,CAJnB;AAAA,UAKM;AACNG,IAAAA,EAAE,GAAGF,EAAE,GAAGA,EAAE,GAAG,CAAR,GAAY,CANnB;AAAA,UAOM;AACN1H,IAAAA,CAAC,GAAG,IAAI2H,EAAJ,IAAU7I,EAAE,IAAI2E,CAAhB,CARJ;AAAA,UASM;AACNoE,IAAAA,CAAC,GAAG,IAAID,EAAJ,IAAU7I,EAAE,IAAI0E,CAAhB,CAVJ;AAAA,UAWM;AACNqE,IAAAA,OAAO,GAAG,IAAIC,YAAJ,CAAiB/H,CAAC,GAAG6H,CAArB,CAZV;AAAA,UAaMG,OAAO,GAAG,IAAID,YAAJ,CAAiB/H,CAAC,GAAG6H,CAArB,CAbhB;AAcA,QAAI3I,MAAM,GAAG4I,OAAb;AACAhB,IAAAA,IAAI,CAACjH,OAAL,CAAauH,CAAC,IAAI;AAChB,YAAMzE,EAAE,GAAGgF,EAAE,IAAI,CAACjH,CAAC,CAAC0G,CAAD,CAAF,IAAS3D,CAAb,CAAb;AAAA,YACMb,EAAE,GAAGgF,EAAE,IAAI,CAACjH,CAAC,CAACyG,CAAD,CAAF,IAAS3D,CAAb,CADb;;AAGA,UAAId,EAAE,IAAI,CAAN,IAAWA,EAAE,GAAG3C,CAAhB,IAAqB4C,EAAE,IAAI,CAA3B,IAAgCA,EAAE,GAAGiF,CAAzC,EAA4C;AAC1CC,QAAAA,OAAO,CAACnF,EAAE,GAAGC,EAAE,GAAG5C,CAAX,CAAP,IAAwB,CAACqH,MAAM,CAACD,CAAD,CAA/B;AACD;AACF,KAPD;;AASA,QAAIK,EAAE,GAAG,CAAL,IAAUC,EAAE,GAAG,CAAnB,EAAsB;AACpBO,MAAAA,KAAK,CAACjI,CAAD,EAAI6H,CAAJ,EAAOC,OAAP,EAAgBE,OAAhB,EAAyBP,EAAzB,CAAL;AACAS,MAAAA,KAAK,CAAClI,CAAD,EAAI6H,CAAJ,EAAOG,OAAP,EAAgBF,OAAhB,EAAyBJ,EAAzB,CAAL;AACAO,MAAAA,KAAK,CAACjI,CAAD,EAAI6H,CAAJ,EAAOC,OAAP,EAAgBE,OAAhB,EAAyBP,EAAzB,CAAL;AACAS,MAAAA,KAAK,CAAClI,CAAD,EAAI6H,CAAJ,EAAOG,OAAP,EAAgBF,OAAhB,EAAyBJ,EAAzB,CAAL;AACAO,MAAAA,KAAK,CAACjI,CAAD,EAAI6H,CAAJ,EAAOC,OAAP,EAAgBE,OAAhB,EAAyBP,EAAzB,CAAL;AACAS,MAAAA,KAAK,CAAClI,CAAD,EAAI6H,CAAJ,EAAOG,OAAP,EAAgBF,OAAhB,EAAyBJ,EAAzB,CAAL;AACD,KAPD,MAOO,IAAID,EAAE,GAAG,CAAT,EAAY;AACjBQ,MAAAA,KAAK,CAACjI,CAAD,EAAI6H,CAAJ,EAAOC,OAAP,EAAgBE,OAAhB,EAAyBP,EAAzB,CAAL;AACAQ,MAAAA,KAAK,CAACjI,CAAD,EAAI6H,CAAJ,EAAOG,OAAP,EAAgBF,OAAhB,EAAyBL,EAAzB,CAAL;AACAQ,MAAAA,KAAK,CAACjI,CAAD,EAAI6H,CAAJ,EAAOC,OAAP,EAAgBE,OAAhB,EAAyBP,EAAzB,CAAL;AACAvI,MAAAA,MAAM,GAAG8I,OAAT;AACD,KALM,MAKA,IAAIN,EAAE,GAAG,CAAT,EAAY;AACjBQ,MAAAA,KAAK,CAAClI,CAAD,EAAI6H,CAAJ,EAAOC,OAAP,EAAgBE,OAAhB,EAAyBN,EAAzB,CAAL;AACAQ,MAAAA,KAAK,CAAClI,CAAD,EAAI6H,CAAJ,EAAOG,OAAP,EAAgBF,OAAhB,EAAyBJ,EAAzB,CAAL;AACAQ,MAAAA,KAAK,CAAClI,CAAD,EAAI6H,CAAJ,EAAOC,OAAP,EAAgBE,OAAhB,EAAyBN,EAAzB,CAAL;AACAxI,MAAAA,MAAM,GAAG8I,OAAT;AACD,KA1C4B,CA0C3B;AACF;;;AAGA,UAAMnC,CAAC,GAAG2B,MAAM,GAAGpF,IAAI,CAAC+F,GAAL,CAAS,CAAT,EAAY,CAAC,CAAD,GAAK1E,CAAjB,CAAH,GAAyB,IAAItF,GAAG,CAACe,MAAD,CAAhD;;AAEA,SAAK,IAAIa,CAAC,GAAG,CAAR,EAAWqI,EAAE,GAAGpI,CAAC,GAAG6H,CAAzB,EAA4B9H,CAAC,GAAGqI,EAAhC,EAAoC,EAAErI,CAAtC,EAAyCb,MAAM,CAACa,CAAD,CAAN,IAAa8F,CAAb;;AAEzC,WAAO;AACL3G,MAAAA,MAAM,EAAEA,MADH;AAEL4G,MAAAA,KAAK,EAAE,KAAKrC,CAFP;AAGL6B,MAAAA,KAAK,EAAEtF,CAHF;AAILuF,MAAAA,MAAM,EAAEsC,CAJH;AAKLzB,MAAAA,EAAE,EAAEuB,EALC;AAMLtB,MAAAA,EAAE,EAAEuB,EANC;AAOLS,MAAAA,EAAE,EAAEV,EAAE,IAAI7I,EAAE,IAAI2E,CAAV,CAPD;AAQL6E,MAAAA,EAAE,EAAEV,EAAE,IAAI7I,EAAE,IAAI0E,CAAV;AARD,KAAP;AAUD;;AAED8D,EAAAA,OAAO,CAAC7G,CAAR,GAAY,UAAUuB,CAAV,EAAa;AACvB,WAAOC,SAAS,CAACjC,MAAV,IAAoBS,CAAC,GAAGwG,MAAM,CAACjF,CAAD,CAAV,EAAesF,OAAnC,IAA8C7G,CAArD;AACD,GAFD;;AAIA6G,EAAAA,OAAO,CAAC5G,CAAR,GAAY,UAAUsB,CAAV,EAAa;AACvB,WAAOC,SAAS,CAACjC,MAAV,IAAoBU,CAAC,GAAGuG,MAAM,CAACjF,CAAD,CAAV,EAAesF,OAAnC,IAA8C5G,CAArD;AACD,GAFD;;AAIA4G,EAAAA,OAAO,CAACF,MAAR,GAAiB,UAAUpF,CAAV,EAAa;AAC5B,WAAOC,SAAS,CAACjC,MAAV,IAAoBoH,MAAM,GAAGH,MAAM,CAACjF,CAAD,CAAf,EAAoBsF,OAAxC,IAAmDF,MAA1D;AACD,GAFD;;AAIAE,EAAAA,OAAO,CAACvF,IAAR,GAAe,UAAUC,CAAV,EAAa;AAC1B,QAAI,CAACC,SAAS,CAACjC,MAAf,EAAuB,OAAO,CAACnB,EAAD,EAAKC,EAAL,CAAP;;AAEvB,QAAIoD,EAAE,GAAG,CAACF,CAAC,CAAC,CAAD,CAAX;AAAA,QACIK,EAAE,GAAG,CAACL,CAAC,CAAC,CAAD,CADX;;AAGA,QAAI,EAAEE,EAAE,IAAI,CAAN,IAAWG,EAAE,IAAI,CAAnB,CAAJ,EAA2BtF,KAAK,CAAC,cAAD,CAAL;AAC3B,WAAO8B,EAAE,GAAGqD,EAAL,EAASpD,EAAE,GAAGuD,EAAd,EAAkBiF,OAAzB;AACD,GARD;;AAUAA,EAAAA,OAAO,CAACgB,QAAR,GAAmB,UAAUtG,CAAV,EAAa;AAC9B,QAAI,CAACC,SAAS,CAACjC,MAAf,EAAuB,OAAO,KAAKwD,CAAZ;AACvB,QAAI,EAAE,CAACxB,CAAC,GAAG,CAACA,CAAN,KAAY,CAAd,CAAJ,EAAsBjF,KAAK,CAAC,mBAAD,CAAL;AACtByG,IAAAA,CAAC,GAAGrB,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACoG,GAAL,CAASvG,CAAT,IAAcG,IAAI,CAACqG,GAA9B,CAAJ;AACA,WAAOlB,OAAP;AACD,GALD;;AAOAA,EAAAA,OAAO,CAACD,SAAR,GAAoB,UAAUrF,CAAV,EAAa;AAC/B,QAAI,CAACC,SAAS,CAACjC,MAAf,EAAuB,OAAOqH,SAAP;AACvBrF,IAAAA,CAAC,GAAGzE,KAAK,CAACyE,CAAD,CAAT;AACA,QAAIA,CAAC,CAAChC,MAAF,KAAa,CAAjB,EAAoBgC,CAAC,GAAG,CAAC,CAACA,CAAC,CAAC,CAAD,CAAH,EAAQ,CAACA,CAAC,CAAC,CAAD,CAAV,CAAJ;AACpB,QAAIA,CAAC,CAAChC,MAAF,KAAa,CAAjB,EAAoBjD,KAAK,CAAC,mBAAD,CAAL;AACpB,WAAOsK,SAAS,GAAGrF,CAAZ,EAAesF,OAAtB;AACD,GAND;;AAQA,SAAOA,OAAP;AACD;;AAED,SAASU,KAAT,CAAejI,CAAf,EAAkB6H,CAAlB,EAAqBhD,MAArB,EAA6B6D,MAA7B,EAAqCnF,CAArC,EAAwC;AACtC,QAAMoF,CAAC,GAAG,CAACpF,CAAC,IAAI,CAAN,IAAW,CAArB;;AAEA,OAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoF,CAApB,EAAuB,EAAEpF,CAAzB,EAA4B;AAC1B,SAAK,IAAI1C,CAAC,GAAG,CAAR,EAAW6I,EAAE,GAAG,CAArB,EAAwB7I,CAAC,GAAGC,CAAC,GAAGuD,CAAhC,EAAmC,EAAExD,CAArC,EAAwC;AACtC,UAAIA,CAAC,GAAGC,CAAR,EAAW;AACT4I,QAAAA,EAAE,IAAI/D,MAAM,CAAC9E,CAAC,GAAG0C,CAAC,GAAGzC,CAAT,CAAZ;AACD;;AAED,UAAID,CAAC,IAAIwD,CAAT,EAAY;AACV,YAAIxD,CAAC,IAAI4I,CAAT,EAAY;AACVC,UAAAA,EAAE,IAAI/D,MAAM,CAAC9E,CAAC,GAAG4I,CAAJ,GAAQlG,CAAC,GAAGzC,CAAb,CAAZ;AACD;;AAED0I,QAAAA,MAAM,CAAC3I,CAAC,GAAGwD,CAAJ,GAAQd,CAAC,GAAGzC,CAAb,CAAN,GAAwB4I,EAAE,GAAGxG,IAAI,CAACwB,GAAL,CAAS7D,CAAC,GAAG,CAAb,EAAgBC,CAAC,GAAG,CAAJ,GAAQ2I,CAAR,GAAY5I,CAA5B,EAA+B4I,CAA/B,CAA7B;AACD;AACF;AACF;AACF;;AAED,SAAST,KAAT,CAAelI,CAAf,EAAkB6H,CAAlB,EAAqBhD,MAArB,EAA6B6D,MAA7B,EAAqCnF,CAArC,EAAwC;AACtC,QAAMoF,CAAC,GAAG,CAACpF,CAAC,IAAI,CAAN,IAAW,CAArB;;AAEA,OAAK,IAAIxD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,CAApB,EAAuB,EAAED,CAAzB,EAA4B;AAC1B,SAAK,IAAI0C,CAAC,GAAG,CAAR,EAAWmG,EAAE,GAAG,CAArB,EAAwBnG,CAAC,GAAGoF,CAAC,GAAGtE,CAAhC,EAAmC,EAAEd,CAArC,EAAwC;AACtC,UAAIA,CAAC,GAAGoF,CAAR,EAAW;AACTe,QAAAA,EAAE,IAAI/D,MAAM,CAAC9E,CAAC,GAAG0C,CAAC,GAAGzC,CAAT,CAAZ;AACD;;AAED,UAAIyC,CAAC,IAAIc,CAAT,EAAY;AACV,YAAId,CAAC,IAAIkG,CAAT,EAAY;AACVC,UAAAA,EAAE,IAAI/D,MAAM,CAAC9E,CAAC,GAAG,CAAC0C,CAAC,GAAGkG,CAAL,IAAU3I,CAAf,CAAZ;AACD;;AAED0I,QAAAA,MAAM,CAAC3I,CAAC,GAAG,CAAC0C,CAAC,GAAGc,CAAL,IAAUvD,CAAf,CAAN,GAA0B4I,EAAE,GAAGxG,IAAI,CAACwB,GAAL,CAASnB,CAAC,GAAG,CAAb,EAAgBoF,CAAC,GAAG,CAAJ,GAAQc,CAAR,GAAYlG,CAA5B,EAA+BkG,CAA/B,CAA/B;AACD;AACF;AACF;AACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAASE,KAAT,CAAe5E,MAAf,EAAuB;AACrBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD4E,KAAK,CAAC1E,UAAN,GAAmB;AACjB,UAAQ,OADS;AAEjB,cAAY;AACV,iBAAa;AADH,GAFK;AAKjB,YAAU,CAAC;AACT,YAAQ,MADC;AAET,YAAQ,QAFC;AAGT,aAAS,IAHA;AAIT,cAAU,CAJD;AAKT,gBAAY;AALH,GAAD,EAMP;AACD,YAAQ,GADP;AAED,YAAQ,OAFP;AAGD,gBAAY;AAHX,GANO,EAUP;AACD,YAAQ,GADP;AAED,YAAQ,OAFP;AAGD,gBAAY;AAHX,GAVO,EAcP;AACD,YAAQ,QADP;AAED,YAAQ;AAFP,GAdO,EAiBP;AACD,YAAQ,SADP;AAED,YAAQ,OAFP;AAGD,aAAS;AAHR,GAjBO,EAqBP;AACD,YAAQ,UADP;AAED,YAAQ;AAFP,GArBO,EAwBP;AACD,YAAQ,WADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU;AAJT,GAxBO,EA6BP;AACD,YAAQ,QADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GA7BO,EAiCP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAjCO;AALO,CAAnB;AA4CA,MAAM2E,MAAM,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,QAAX,EAAqB,MAArB,EAA6B,UAA7B,EAAyC,WAAzC,CAAf;;AACA,SAAS7E,MAAT,CAAgB8E,GAAhB,EAAqB9G,CAArB,EAAwB;AACtB6G,EAAAA,MAAM,CAACjJ,OAAP,CAAemJ,KAAK,IAAI/G,CAAC,CAAC+G,KAAD,CAAD,IAAY,IAAZ,GAAmBD,GAAG,CAACC,KAAD,CAAH,CAAW/G,CAAC,CAAC+G,KAAD,CAAZ,CAAnB,GAA0C,CAAlE;AACA,SAAOD,GAAP;AACD;;AACD7L,QAAQ,CAAC2L,KAAD,EAAQjM,SAAR,EAAmB;AACzBwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAI,KAAKhF,KAAL,IAAc,CAACgF,KAAK,CAACC,OAAN,EAAf,IAAkC,CAACrC,CAAC,CAACsC,QAAF,EAAvC,EAAqD,OAAOF,KAAK,CAACG,eAAb;AACrD,QAAIC,GAAG,GAAGJ,KAAK,CAACK,IAAN,CAAWL,KAAK,CAACM,SAAN,GAAkBN,KAAK,CAACO,SAAnC,CAAV;AAAA,QACIC,MAAM,GAAGR,KAAK,CAACS,WAAN,CAAkBT,KAAK,CAACU,MAAxB,EAAgCF,MAD7C;AAAA,QAEIoE,MAAM,GAAGC,SAAS,CAACrE,MAAD,EAAS5C,CAAC,CAACkH,OAAX,CAFtB;AAAA,QAGIC,KAAK,GAAG,CAACnH,CAAC,CAACkH,OAAF,IAAa,EAAd,EAAkB/J,GAAlB,CAAsB1B,YAAtB,CAHZ;AAAA,QAII2L,GAAG,GAAGpF,MAAM,CAACkD,SAAS,EAAV,EAAclF,CAAd,CAJhB;AAAA,QAKIiD,EAAE,GAAGjD,CAAC,CAACiD,EAAF,IAAQ,MALjB;AAAA,QAMIhG,MAAM,GAAG,EANb;;AAQA,aAASoK,GAAT,CAAanE,CAAb,EAAgBoE,IAAhB,EAAsB;AACpB,WAAK,IAAIxJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqJ,KAAK,CAACnJ,MAA1B,EAAkC,EAAEF,CAApC,EAAuCoF,CAAC,CAACiE,KAAK,CAACrJ,CAAD,CAAN,CAAD,GAAcwJ,IAAI,CAACxJ,CAAD,CAAlB;;AAEvC,aAAOoF,CAAP;AACD,KAdiB,CAchB;;;AAGFjG,IAAAA,MAAM,GAAG+J,MAAM,CAAC7J,GAAP,CAAWoC,CAAC,IAAI1E,MAAM,CAACwM,GAAG,CAAC;AAClC,OAACpE,EAAD,GAAMmE,GAAG,CAAC7H,CAAD,EAAIS,CAAC,CAACuF,MAAN;AADyB,KAAD,EAEhChG,CAAC,CAACgI,IAF8B,CAAJ,CAAtB,CAAT;AAGA,QAAI,KAAKnK,KAAT,EAAgBoF,GAAG,CAACgB,GAAJ,GAAU,KAAKpG,KAAf;AAChB,SAAKA,KAAL,GAAaoF,GAAG,CAACI,MAAJ,GAAaJ,GAAG,CAACiB,GAAJ,GAAUxG,MAApC;AACA,WAAOuF,GAAP;AACD;;AAxBwB,CAAnB,CAAR;;AA2BA,SAASyE,SAAT,CAAmBpC,IAAnB,EAAyBqC,OAAzB,EAAkC;AAChC,MAAIF,MAAM,GAAG,EAAb;AAAA,MACIQ,GAAG,GAAGlI,CAAC,IAAIA,CAAC,CAAC4D,CAAD,CADhB;AAAA,MAEI/F,GAFJ;AAAA,MAGIW,CAHJ;AAAA,MAIIC,CAJJ;AAAA,MAKImF,CALJ;AAAA,MAMI1B,CANJ;AAAA,MAOIjC,CAPJ,CADgC,CAQzB;;;AAGP,MAAI2H,OAAO,IAAI,IAAf,EAAqB;AACnBF,IAAAA,MAAM,CAACrJ,IAAP,CAAYkH,IAAZ;AACD,GAFD,MAEO;AACL,SAAK1H,GAAG,GAAG,EAAN,EAAUW,CAAC,GAAG,CAAd,EAAiBC,CAAC,GAAG8G,IAAI,CAAC7G,MAA/B,EAAuCF,CAAC,GAAGC,CAA3C,EAA8C,EAAED,CAAhD,EAAmD;AACjDoF,MAAAA,CAAC,GAAG2B,IAAI,CAAC/G,CAAD,CAAR;AACA0D,MAAAA,CAAC,GAAG0F,OAAO,CAAC/J,GAAR,CAAYqK,GAAZ,CAAJ;AACAjI,MAAAA,CAAC,GAAGpC,GAAG,CAACqE,CAAD,CAAP;;AAEA,UAAI,CAACjC,CAAL,EAAQ;AACNpC,QAAAA,GAAG,CAACqE,CAAD,CAAH,GAASjC,CAAC,GAAG,EAAb;AACAA,QAAAA,CAAC,CAACgI,IAAF,GAAS/F,CAAT;AACAwF,QAAAA,MAAM,CAACrJ,IAAP,CAAY4B,CAAZ;AACD;;AAEDA,MAAAA,CAAC,CAAC5B,IAAF,CAAOuF,CAAP;AACD;AACF;;AAED,SAAO8D,MAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAASS,OAAT,CAAiBzF,MAAjB,EAAyB;AACvBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDyF,OAAO,CAACvF,UAAR,GAAqB;AACnB,UAAQ,SADW;AAEnB,cAAY;AACV,iBAAa;AADH,GAFO;AAKnB,YAAU,CAAC;AACT,YAAQ,MADC;AAET,YAAQ,QAFC;AAGT,aAAS,IAHA;AAIT,cAAU,CAJD;AAKT,gBAAY;AALH,GAAD,EAMP;AACD,YAAQ,QADP;AAED,YAAQ,QAFP;AAGD,aAAS;AAHR,GANO,EAUP;AACD,YAAQ,GADP;AAED,YAAQ;AAFP,GAVO,EAaP;AACD,YAAQ,GADP;AAED,YAAQ;AAFP,GAbO,EAgBP;AACD,YAAQ,QADP;AAED,YAAQ;AAFP,GAhBO,EAmBP;AACD,YAAQ,UADP;AAED,YAAQ;AAFP,GAnBO,EAsBP;AACD,YAAQ,WADP;AAED,YAAQ;AAFP,GAtBO,EAyBP;AACD,YAAQ,OADP;AAED,YAAQ;AAFP,GAzBO,EA4BP;AACD,YAAQ,MADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GA5BO,EAgCP;AACD,YAAQ,YADP;AAED,YAAQ,QAFP;AAGD,aAAS;AAHR,GAhCO,EAoCP;AACD,YAAQ,QADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GApCO;AALS,CAArB;AA+CAjH,QAAQ,CAACwM,OAAD,EAAU9M,SAAV,EAAqB;AAC3BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAI,KAAKhF,KAAL,IAAc,CAACgF,KAAK,CAACC,OAAN,EAAf,IAAkC,CAACrC,CAAC,CAACsC,QAAF,EAAvC,EAAqD;AACnD,aAAOF,KAAK,CAACG,eAAb;AACD;;AAED,QAAIC,GAAG,GAAGJ,KAAK,CAACK,IAAN,CAAWL,KAAK,CAACM,SAAN,GAAkBN,KAAK,CAACO,SAAnC,CAAV;AAAA,QACItF,OAAO,GAAGT,QAAQ,GAAGG,MAAX,CAAkBiD,CAAC,CAACjD,MAAF,KAAa,KAA/B,CADd;AAAA,QAEIE,MAAM,GAAG+C,CAAC,CAAC/C,MAFf;AAAA,QAGIyK,MAAM,GAAG1H,CAAC,CAAC+C,UAAF,IAAgBxB,QAAQ,CAACvB,CAAC,CAAC2H,KAAF,IAAW,EAAZ,EAAgB3H,CAAC,CAACyB,IAAlB,EAAwB,CAAC,CAACxE,MAA1B,CAHrC;AAAA,QAII8C,IAAI,GAAGC,CAAC,CAACD,IAJb;AAAA,QAKIoD,IALJ;AAAA,QAMIyE,IANJ;;AAQA,QAAI,CAAC3K,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAGmF,KAAK,CAACS,WAAN,CAAkBT,KAAK,CAACU,MAAxB,EAAgCF,MAAzC;AACAO,MAAAA,IAAI,GAAGnB,MAAM,CAACkD,SAAS,EAAV,EAAclF,CAAd,CAAN,CAAuB/C,MAAvB,EAA+B,IAA/B,CAAP;AACA2K,MAAAA,IAAI,GAAGzF,SAAS,CAACgB,IAAD,EAAOA,IAAI,CAACU,KAAL,IAAc,CAArB,EAAwBV,IAAI,CAACU,KAAL,IAAc,CAAtC,EAAyC,CAAzC,EAA4C,CAA5C,CAAhB;AACA9D,MAAAA,IAAI,GAAG,CAACoD,IAAI,CAACE,KAAN,EAAaF,IAAI,CAACG,MAAlB,CAAP;AACArG,MAAAA,MAAM,GAAGkG,IAAI,CAAClG,MAAd;AACD;;AAEDyK,IAAAA,MAAM,GAAGvM,OAAO,CAACuM,MAAD,CAAP,GAAkBA,MAAlB,GAA2BA,MAAM,CAACzK,MAAD,CAA1C;AACAA,IAAAA,MAAM,GAAGI,OAAO,CAAC0C,IAAR,CAAaA,IAAb,EAAmB9C,MAAnB,EAA2ByK,MAA3B,CAAT;AACA,QAAIE,IAAJ,EAAU3K,MAAM,CAACW,OAAP,CAAegK,IAAf;AACV,QAAI,KAAKxK,KAAT,EAAgBoF,GAAG,CAACgB,GAAJ,GAAU,KAAKpG,KAAf;AAChB,SAAKA,KAAL,GAAaoF,GAAG,CAACI,MAAJ,GAAaJ,GAAG,CAACiB,GAAJ,GAAU,CAACxG,MAAM,IAAI,EAAX,EAAeE,GAAf,CAAmBtC,MAAnB,CAApC;AACA,WAAO2H,GAAP;AACD;;AA5B0B,CAArB,CAAR;AAgCA,MAAMqF,OAAO,GAAG,SAAhB;AACA,MAAMC,iBAAiB,GAAG,mBAA1B;AACA,MAAMC,UAAU,GAAG,YAAnB;AAEA;;;;;;;;;;;;;AAaA,SAASC,OAAT,CAAiBhG,MAAjB,EAAyB;AACvBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDgG,OAAO,CAAC9F,UAAR,GAAqB;AACnB,UAAQ,SADW;AAEnB,cAAY,EAFO;AAGnB,YAAU,CAAC;AACT,YAAQ,QADC;AAET,YAAQ,OAFC;AAGT,aAAS,IAHA;AAIT,cAAU;AAJD,GAAD,EAKP;AACD,YAAQ,SADP;AAED,YAAQ;AAFP,GALO;AAHS,CAArB;AAaAjH,QAAQ,CAAC+M,OAAD,EAAUrN,SAAV,EAAqB;AAC3BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAI6F,QAAQ,GAAG,KAAKC,SAApB;AAAA,QACIC,MAAM,GAAG,KAAKC,OADlB;AAAA,QAEIC,MAAM,GAAGrI,CAAC,CAACqI,MAFf;AAAA,QAGIC,GAAG,GAAGD,MAAM,IAAIA,MAAM,CAAC,CAAD,CAH1B;AAAA,QAIIE,GAAG,GAAGF,MAAM,IAAIA,MAAM,CAAC,CAAD,CAJ1B;AAAA,QAKIG,OAAO,GAAGxI,CAAC,CAACwI,OAAF,IAAa,CAACH,MAAD,IAAWnN,QALtC;AAAA,QAMIuN,IAAI,GAAGrG,KAAK,CAACsG,GANjB;AAAA,QAOIC,GAPJ;AAQAA,IAAAA,GAAG,GAAG3I,CAAC,CAACsC,QAAF,MAAgBF,KAAK,CAACC,OAAN,CAAcD,KAAK,CAACwG,GAApB,CAAhB,IAA4CxG,KAAK,CAACE,QAAN,CAAe5G,cAAc,CAAC8M,OAAD,CAA7B,CAA5C,IAAuFF,GAAG,IAAIlG,KAAK,CAACE,QAAN,CAAe5G,cAAc,CAAC4M,GAAD,CAA7B,CAA9F,IAAqIC,GAAG,IAAInG,KAAK,CAACE,QAAN,CAAe5G,cAAc,CAAC6M,GAAD,CAA7B,CAAlJ;;AAEA,QAAI,CAAC,KAAKnL,KAAN,IAAeuL,GAAnB,EAAwB;AACtBF,MAAAA,IAAI,GAAGrG,KAAK,CAACU,MAAb;AACA,WAAKoF,SAAL,GAAiBD,QAAQ,GAAG,EAA5B;AACA,WAAKG,OAAL,GAAeD,MAAM,GAAG,EAAxB;AACD;;AAED,QAAIK,OAAJ,EAAa;AACXpG,MAAAA,KAAK,CAACyG,KAAN,CAAYJ,IAAZ,EAAkBvF,CAAC,IAAI+E,QAAQ,CAACtK,IAAT,CAAc6K,OAAO,CAACtF,CAAD,CAArB,CAAvB;AACD;;AAED,QAAIoF,GAAG,IAAIC,GAAX,EAAgB;AACdnG,MAAAA,KAAK,CAACyG,KAAN,CAAYJ,IAAZ,EAAkBvF,CAAC,IAAI;AACrB,YAAIzE,CAAC,GAAG6J,GAAG,CAACpF,CAAD,CAAX;AAAA,YACIxE,CAAC,GAAG6J,GAAG,CAACrF,CAAD,CADX;;AAGA,YAAIzE,CAAC,IAAI,IAAL,IAAaC,CAAC,IAAI,IAAlB,IAA0B,CAACD,CAAC,GAAG,CAACA,CAAN,MAAaA,CAAvC,IAA4C,CAACC,CAAC,GAAG,CAACA,CAAN,MAAaA,CAA7D,EAAgE;AAC9DyJ,UAAAA,MAAM,CAACxK,IAAP,CAAY,CAACc,CAAD,EAAIC,CAAJ,CAAZ;AACD;AACF,OAPD;AAQAuJ,MAAAA,QAAQ,GAAGA,QAAQ,CAACzI,MAAT,CAAgB;AACzBrB,QAAAA,IAAI,EAAE0J,OADmB;AAEzBnD,QAAAA,QAAQ,EAAE;AACRvG,UAAAA,IAAI,EAAE4J,UADE;AAER3J,UAAAA,WAAW,EAAE+J;AAFL;AAFe,OAAhB,CAAX;AAOD;;AAED,SAAK/K,KAAL,GAAa;AACXe,MAAAA,IAAI,EAAE2J,iBADK;AAEXG,MAAAA,QAAQ,EAAEA;AAFC,KAAb;AAID;;AA5C0B,CAArB,CAAR;AAgDA;;;;;;;;;;;;AAYA,SAASa,OAAT,CAAiB9G,MAAjB,EAAyB;AACvBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD8G,OAAO,CAAC5G,UAAR,GAAqB;AACnB,UAAQ,SADW;AAEnB,cAAY;AACV,gBAAY;AADF,GAFO;AAKnB,YAAU,CAAC;AACT,YAAQ,YADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,OADP;AAED,YAAQ;AAFP,GAHO,EAMP;AACD,YAAQ,aADP;AAED,YAAQ,QAFP;AAGD,YAAQ;AAHP,GANO,EAUP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAVO;AALS,CAArB;AAqBAjH,QAAQ,CAAC6N,OAAD,EAAUnO,SAAV,EAAqB;AAC3BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAII,GAAG,GAAGJ,KAAK,CAACK,IAAN,CAAWL,KAAK,CAAC2G,GAAjB,CAAV;AAAA,QACIC,IAAI,GAAG,KAAK5L,KADhB;AAAA,QAEIzB,KAAK,GAAGqE,CAAC,CAACrE,KAAF,IAAWT,QAFvB;AAAA,QAGI+H,EAAE,GAAGjD,CAAC,CAACiD,EAAF,IAAQ,MAHjB;AAAA,QAIIwF,IAAI,GAAGjG,GAAG,CAACM,MAJf;;AAMA,QAAI,CAACkG,IAAD,IAAShJ,CAAC,CAACsC,QAAF,EAAb,EAA2B;AACzB;AACA,WAAKlF,KAAL,GAAa4L,IAAI,GAAG5M,iBAAiB,CAAC4D,CAAC,CAAC1D,UAAH,CAArC;AACAkG,MAAAA,GAAG,CAACK,WAAJ,GAAkBoG,MAAlB;AACD,KAJD,MAIO;AACLR,MAAAA,IAAI,GAAG9M,KAAK,KAAKT,QAAV,IAAsBkH,KAAK,CAACE,QAAN,CAAe3G,KAAK,CAAC0M,MAArB,CAAtB,GAAqD7F,GAAG,CAAC0G,OAAzD,GAAmE1G,GAAG,CAACkG,GAA9E;AACD;;AAED,UAAMS,IAAI,GAAGC,QAAQ,CAACJ,IAAD,EAAOhJ,CAAC,CAACqJ,WAAT,CAArB;AACA7G,IAAAA,GAAG,CAACqG,KAAJ,CAAUJ,IAAV,EAAgBvF,CAAC,IAAIA,CAAC,CAACD,EAAD,CAAD,GAAQ+F,IAAI,CAACrN,KAAK,CAACuH,CAAD,CAAN,CAAjC;AACA8F,IAAAA,IAAI,CAACK,WAAL,CAAiBF,IAAjB;AACA,WAAO3G,GAAG,CAAC8G,QAAJ,CAAarG,EAAb,CAAP;AACD;;AApB0B,CAArB,CAAR;;AAwBA,SAASmG,QAAT,CAAkBJ,IAAlB,EAAwBK,WAAxB,EAAqC;AACnC,QAAMF,IAAI,GAAGH,IAAI,CAACK,WAAL,EAAb;AACAL,EAAAA,IAAI,CAACO,OAAL,CAAa,IAAb;;AAEA,MAAIF,WAAW,IAAI,IAAnB,EAAyB;AACvBL,IAAAA,IAAI,CAACK,WAAL,CAAiBA,WAAjB;AACD;;AAED,SAAOF,IAAP;AACD;AAED;;;;;;;;;;;;;AAYA,SAASK,QAAT,CAAkBxH,MAAlB,EAA0B;AACxBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDwH,QAAQ,CAACtH,UAAT,GAAsB;AACpB,UAAQ,UADY;AAEpB,cAAY;AACV,gBAAY;AADF,GAFQ;AAKpB,YAAU,CAAC;AACT,YAAQ,YADC;AAET,YAAQ,YAFC;AAGT,gBAAY;AAHH,GAAD,EAIP;AACD,YAAQ,QADP;AAED,YAAQ,OAFP;AAGD,aAAS,IAHR;AAID,gBAAY,IAJX;AAKD,cAAU;AALT,GAJO,EAUP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU,CAJT;AAKD,eAAW,CAAC,GAAD,EAAM,GAAN;AALV,GAVO;AALU,CAAtB;AAuBAjH,QAAQ,CAACuO,QAAD,EAAW7O,SAAX,EAAsB;AAC5BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAIqH,IAAI,GAAGzJ,CAAC,CAAC1D,UAAb;AAAA,QACIgM,GAAG,GAAGtI,CAAC,CAACqI,MAAF,CAAS,CAAT,CADV;AAAA,QAEIE,GAAG,GAAGvI,CAAC,CAACqI,MAAF,CAAS,CAAT,CAFV;AAAA,QAGIpF,EAAE,GAAGjD,CAAC,CAACiD,EAAF,IAAQ,CAAC,GAAD,EAAM,GAAN,CAHjB;AAAA,QAIIxE,CAAC,GAAGwE,EAAE,CAAC,CAAD,CAJV;AAAA,QAKIvE,CAAC,GAAGuE,EAAE,CAAC,CAAD,CALV;AAAA,QAMI0F,GANJ;;AAQA,aAAStB,GAAT,CAAanE,CAAb,EAAgB;AACd,YAAMwG,EAAE,GAAGD,IAAI,CAAC,CAACnB,GAAG,CAACpF,CAAD,CAAJ,EAASqF,GAAG,CAACrF,CAAD,CAAZ,CAAD,CAAf;;AAEA,UAAIwG,EAAJ,EAAQ;AACNxG,QAAAA,CAAC,CAACzE,CAAD,CAAD,GAAOiL,EAAE,CAAC,CAAD,CAAT;AACAxG,QAAAA,CAAC,CAACxE,CAAD,CAAD,GAAOgL,EAAE,CAAC,CAAD,CAAT;AACD,OAHD,MAGO;AACLxG,QAAAA,CAAC,CAACzE,CAAD,CAAD,GAAOkL,SAAP;AACAzG,QAAAA,CAAC,CAACxE,CAAD,CAAD,GAAOiL,SAAP;AACD;AACF;;AAED,QAAI3J,CAAC,CAACsC,QAAF,EAAJ,EAAkB;AAChB;AACAF,MAAAA,KAAK,GAAGA,KAAK,CAACS,WAAN,GAAoBoG,MAApB,CAA2B,IAA3B,EAAiCJ,KAAjC,CAAuCzG,KAAK,CAACU,MAA7C,EAAqDuE,GAArD,CAAR;AACD,KAHD,MAGO;AACLsB,MAAAA,GAAG,GAAGvG,KAAK,CAACE,QAAN,CAAegG,GAAG,CAACD,MAAnB,KAA8BjG,KAAK,CAACE,QAAN,CAAeiG,GAAG,CAACF,MAAnB,CAApC;AACAjG,MAAAA,KAAK,CAACyG,KAAN,CAAYF,GAAG,GAAGvG,KAAK,CAAC8G,OAAT,GAAmB9G,KAAK,CAACsG,GAAxC,EAA6CrB,GAA7C;AACD;;AAED,WAAOjF,KAAK,CAACkH,QAAN,CAAerG,EAAf,CAAP;AACD;;AA/B2B,CAAtB,CAAR;AAmCA;;;;;;;;;;;;AAYA,SAAS2G,QAAT,CAAkB5H,MAAlB,EAA0B;AACxBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD4H,QAAQ,CAAC1H,UAAT,GAAsB;AACpB,UAAQ,UADY;AAEpB,cAAY;AACV,gBAAY,IADF;AAEV,aAAS;AAFC,GAFQ;AAMpB,YAAU,CAAC;AACT,YAAQ,YADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,OADP;AAED,YAAQ,OAFP;AAGD,eAAW;AAHV,GAHO,EAOP;AACD,YAAQ,aADP;AAED,YAAQ,QAFP;AAGD,YAAQ;AAHP,GAPO,EAWP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAXO;AANU,CAAtB;AAuBAjH,QAAQ,CAAC2O,QAAD,EAAWjP,SAAX,EAAsB;AAC5BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAII,GAAG,GAAGJ,KAAK,CAACK,IAAN,CAAWL,KAAK,CAAC2G,GAAjB,CAAV;AAAA,QACIc,KAAK,GAAG,KAAKzM,KADjB;AAAA,QAEI6F,EAAE,GAAGjD,CAAC,CAACiD,EAAF,IAAQ,OAFjB;AAAA,QAGIwF,IAAI,GAAGjG,GAAG,CAACkG,GAHf;;AAKA,QAAI,CAACmB,KAAD,IAAU7J,CAAC,CAACsC,QAAF,EAAd,EAA4B;AAC1B;AACA,WAAKlF,KAAL,GAAayM,KAAK,GAAGC,cAAc,CAAC1N,iBAAiB,CAAC4D,CAAC,CAAC1D,UAAH,CAAlB,EAAkC0D,CAAC,CAACrE,KAAF,IAAWA,KAAK,CAAC,OAAD,CAAlD,EAA6DqE,CAAC,CAACqJ,WAA/D,CAAnC;AACA7G,MAAAA,GAAG,CAACK,WAAJ,GAAkBoG,MAAlB;AACAR,MAAAA,IAAI,GAAGjG,GAAG,CAACM,MAAX;AACD;;AAEDN,IAAAA,GAAG,CAACqG,KAAJ,CAAUJ,IAAV,EAAgBvF,CAAC,IAAIA,CAAC,CAACD,EAAD,CAAD,GAAQ4G,KAA7B;AACA,WAAOrH,GAAG,CAAC8G,QAAJ,CAAarG,EAAb,CAAP;AACD;;AAhB2B,CAAtB,CAAR;;AAoBA,SAAS6G,cAAT,CAAwBd,IAAxB,EAA8BrN,KAA9B,EAAqC0N,WAArC,EAAkD;AAChD,QAAMQ,KAAK,GAAGR,WAAW,IAAI,IAAf,GAAsBrJ,CAAC,IAAIgJ,IAAI,CAACrN,KAAK,CAACqE,CAAD,CAAN,CAA/B,GAA4CA,CAAC,IAAI;AAC7D,QAAImJ,IAAI,GAAGH,IAAI,CAACK,WAAL,EAAX;AAAA,QACIjM,KAAK,GAAG4L,IAAI,CAACK,WAAL,CAAiBA,WAAjB,EAA8B1N,KAAK,CAACqE,CAAD,CAAnC,CADZ;AAEAgJ,IAAAA,IAAI,CAACK,WAAL,CAAiBF,IAAjB;AACA,WAAO/L,KAAP;AACD,GALD;;AAOAyM,EAAAA,KAAK,CAACN,OAAN,GAAgBvJ,CAAC,IAAI;AACnBgJ,IAAAA,IAAI,CAACO,OAAL,CAAavJ,CAAb;AACA,WAAO6J,KAAP;AACD,GAHD;;AAKA,SAAOA,KAAP;AACD;AAED;;;;;;AAKA,SAASE,SAAT,CAAmB/H,MAAnB,EAA2B;AACzBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,EAArB,EAAyBD,MAAzB;AACA,OAAKgI,SAAL,GAAiBzN,YAAY,EAA7B;AACD;;AACDwN,SAAS,CAAC7H,UAAV,GAAuB;AACrB,UAAQ,WADa;AAErB,cAAY;AACV,eAAW,IADD;AAEV,iBAAa;AAFH,GAFS;AAMrB,YAAU,CAAC;AACT,YAAQ,QADC;AAET,YAAQ,OAFC;AAGT,aAAS,IAHA;AAIT,cAAU,CAJD;AAKT,eAAW;AACT,cAAQ,QADC;AAET,eAAS,IAFA;AAGT,gBAAU;AAHD;AALF,GAAD,EAUP;AACD,YAAQ,aADP;AAED,YAAQ,OAFP;AAGD,aAAS,IAHR;AAID,cAAU,CAJT;AAKD,eAAW;AACT,cAAQ,QADC;AAET,eAAS,IAFA;AAGT,gBAAU;AAHD;AALV,GAVO,EAoBP;AACD,YAAQ,aADP;AAED,YAAQ,OAFP;AAGD,aAAS,IAHR;AAID,cAAU,CAJT;AAKD,eAAW;AACT,cAAQ,QADC;AAET,eAAS,IAFA;AAGT,gBAAU;AAHD;AALV,GApBO,EA8BP;AACD,YAAQ,MADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU;AAJT,GA9BO,EAmCP;AACD,YAAQ,WADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU,CAJT;AAKD,eAAW,CAAC,EAAD,EAAK,GAAL;AALV,GAnCO,EAyCP;AACD,YAAQ,WADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU,CAJT;AAKD,eAAW,CAAC,EAAD,EAAK,EAAL;AALV,GAzCO,EA+CP;AACD,YAAQ,WADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GA/CO;AANW,CAAvB;AA2DAjH,QAAQ,CAAC8O,SAAD,EAAYpP,SAAZ,EAAuB;AAC7BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAI6H,GAAG,GAAG,KAAK7M,KAAf;AAAA,QACI8M,GAAG,GAAG,KAAKF,SADf;AAAA,QAEI9G,CAFJ;;AAIA,QAAI,CAAC+G,GAAG,CAACjM,MAAL,IAAegC,CAAC,CAACsC,QAAF,EAAnB,EAAiC;AAC/B,WAAK,MAAM6H,IAAX,IAAmBnK,CAAnB,EAAsB;AACpB,YAAI5E,UAAU,CAAC8O,GAAG,CAACC,IAAD,CAAJ,CAAd,EAA2B;AACzBD,UAAAA,GAAG,CAACC,IAAD,CAAH,CAAUnK,CAAC,CAACmK,IAAD,CAAX;AACD;AACF;AACF;;AAEDjH,IAAAA,CAAC,GAAGgH,GAAG,EAAP;;AAEA,QAAID,GAAG,CAACjM,MAAR,EAAgB;AACdoE,MAAAA,KAAK,CAACuG,GAAN,CAAUhL,IAAV,CAAe7C,OAAO,CAACmP,GAAG,CAAC,CAAD,CAAJ,EAAS/G,CAAT,CAAtB;AACD,KAFD,MAEO;AACLd,MAAAA,KAAK,CAACqB,GAAN,CAAU9F,IAAV,CAAe9C,MAAM,CAACqI,CAAD,CAArB;AACD;;AAED+G,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAS/G,CAAT;AACA,WAAOd,KAAP;AACD;;AAxB4B,CAAvB,CAAR;AA4BA;;;;;;;;;;;;;;;;;;;;AAoBA,SAASgI,OAAT,CAAiBpI,MAAjB,EAAyB;AACvBrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDoI,OAAO,CAAClI,UAAR,GAAqB;AACnB,UAAQ,SADW;AAEnB,cAAY;AACV,gBAAY;AADF,GAFO;AAKnB,YAAU,CAAC;AACT,YAAQ,OADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,OADP;AAED,YAAQ,QAFP;AAGD,YAAQ;AAHP,GAHO,EAOP;AACD,YAAQ,SADP;AAED,YAAQ,QAFP;AAGD,YAAQ;AAHP,GAPO,EAWP;AACD,YAAQ,SADP;AAED,YAAQ,MAFP;AAGD,cAAU,CAAC,QAAD,EAAW,aAAX,CAHT;AAID,eAAW;AAJV,GAXO,EAgBP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAhBO;AALS,CAArB;AA2BAjH,QAAQ,CAACmP,OAAD,EAAUzP,SAAV,EAAqB;AAC3BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAI,CAACA,KAAK,CAACC,OAAN,EAAD,IAAoB,CAACrC,CAAC,CAACsC,QAAF,EAAzB,EAAuC;AACrC,aAAOF,KAAK,CAACG,eAAb;AACD;;AAED,QAAIK,MAAM,GAAGR,KAAK,CAACS,WAAN,CAAkBT,KAAK,CAACU,MAAxB,EAAgCF,MAA7C;AAAA,QACIyH,MAAM,GAAGrK,CAAC,CAAC0D,OAAF,KAAc,QAD3B;AAAA,QAEI/H,KAAK,GAAGqE,CAAC,CAACrE,KAAF,IAAWT,QAFvB;AAAA,QAGIoP,OAAO,GAAGC,QAAQ,CAACvK,CAAC,CAACsK,OAAH,EAAYtK,CAAZ,CAHtB;AAAA,QAIIwK,KAAK,GAAGC,MAAM,CAACzK,CAAC,CAACwK,KAAH,EAAUxK,CAAV,CAJlB;AAAA,QAKIiD,EAAE,GAAGjD,CAAC,CAACiD,EAAF,IAAQ,OALjB;AAAA,QAMI6D,GAAG,GAAG;AACR4D,MAAAA,EAAE,EAAE,CADI;AAERC,MAAAA,EAAE,EAAE,CAFI;AAGRC,MAAAA,MAAM,EAAE,CAHA;AAIRC,MAAAA,IAAI,EAAER,MAAM,GAAGpO,GAAG,CAAC2G,MAAM,CAACzF,GAAP,CAAW+F,CAAC,IAAIjH,GAAG,CAACN,KAAK,CAACuH,CAAD,CAAL,CAASjG,MAAV,CAAnB,CAAD,CAAN,GAAgD;AAJpD,KANV;AAYA2F,IAAAA,MAAM,CAAChF,OAAP,CAAesF,CAAC,IAAI;AAClB,YAAM4B,CAAC,GAAGnJ,KAAK,CAACuH,CAAD,CAAf,CADkB,CACE;;AAEpB,YAAM4H,CAAC,GAAGlP,MAAM,CAAC,EAAD,EAAKsH,CAAL,EAAQ4D,GAAR,CAAhB,CAHkB,CAGY;;AAE9B,UAAI,CAACuD,MAAL,EAAaS,CAAC,CAACD,IAAF,GAAS5O,GAAG,CAAC6I,CAAC,CAAC7H,MAAF,IAAY,EAAb,CAAZ,CALK,CAKyB;AAC3C;;AAEAiG,MAAAA,CAAC,CAACD,EAAD,CAAD,GAAQ8H,QAAQ,CAACjG,CAAD,EAAIgG,CAAJ,EAAON,KAAK,CAACQ,GAAN,GAAYR,KAAZ,GAAoBlP,QAAQ,CAACkP,KAAK,CAACM,CAAD,CAAN,CAAnC,EAA+CR,OAAO,CAACU,GAAR,GAAcV,OAAd,GAAwBhP,QAAQ,CAACgP,OAAO,CAACQ,CAAD,CAAR,CAA/E,CAAhB;AACD,KATD;AAUA,WAAO1I,KAAK,CAAC6G,MAAN,CAAa,IAAb,EAAmBK,QAAnB,CAA4BrG,EAA5B,CAAP;AACD;;AA7B0B,CAArB,CAAR,C,CA+BI;;AAEJ,SAASwH,MAAT,CAAgBD,KAAhB,EAAuBxK,CAAvB,EAA0B;AACxB,MAAIV,CAAJ;;AAEA,MAAIlE,UAAU,CAACoP,KAAD,CAAd,EAAuB;AACrBlL,IAAAA,CAAC,GAAGwH,GAAG,IAAItK,GAAG,CAACgO,KAAK,CAAC1D,GAAD,EAAM9G,CAAN,CAAN,CAAd;;AAEAV,IAAAA,CAAC,CAAC0L,GAAF,GAAQC,UAAU,CAACT,KAAD,CAAlB;AACD,GAJD,MAIO;AACL;AACAlL,IAAAA,CAAC,GAAGhE,QAAQ,CAACkB,GAAG,CAACgO,KAAK,IAAI,MAAV,CAAJ,CAAZ;AACD;;AAED,SAAOlL,CAAP;AACD,C,CAAC;;;AAGF,SAASiL,QAAT,CAAkBD,OAAlB,EAA2BtK,CAA3B,EAA8B;AAC5B,MAAIV,CAAJ;;AAEA,MAAIlE,UAAU,CAACkP,OAAD,CAAd,EAAyB;AACvBhL,IAAAA,CAAC,GAAGwH,GAAG,IAAIwD,OAAO,CAACxD,GAAD,EAAM9G,CAAN,CAAlB;;AAEAV,IAAAA,CAAC,CAAC0L,GAAF,GAAQC,UAAU,CAACX,OAAD,CAAlB;AACD,GAJD,MAIO,IAAIA,OAAJ,EAAa;AAClBhL,IAAAA,CAAC,GAAGhE,QAAQ,CAACgP,OAAD,CAAZ;AACD,GAFM,MAEA;AACL;AACAhL,IAAAA,CAAC,GAAGwH,GAAG,IAAIA,GAAG,CAAC8D,MAAJ,GAAa9D,GAAG,CAAC+D,IAAjB,IAAyB,CAApC;;AAEAvL,IAAAA,CAAC,CAAC0L,GAAF,GAAQ,IAAR;AACD;;AAED,SAAO1L,CAAP;AACD,C,CAAC;;;AAGF,SAAS2L,UAAT,CAAoB3L,CAApB,EAAuB;AACrB,MAAI,CAAClE,UAAU,CAACkE,CAAD,CAAf,EAAoB,OAAO,KAAP;AACpB,QAAM+H,GAAG,GAAGxL,KAAK,CAACH,cAAc,CAAC4D,CAAD,CAAf,CAAjB;AACA,SAAO+H,GAAG,CAACqD,EAAJ,IAAUrD,GAAG,CAACsD,EAAd,IAAoBtD,GAAG,CAACuD,MAAxB,IAAkCvD,GAAG,CAACwD,IAA7C;AACD,C,CAAC;;;AAGF,SAASE,QAAT,CAAkB5H,IAAlB,EAAwB2D,GAAxB,EAA6B0D,KAA7B,EAAoCF,OAApC,EAA6C;AAC3C,QAAMvM,CAAC,GAAGoF,IAAI,CAACE,KAAf;AAAA,QACMuC,CAAC,GAAGzC,IAAI,CAACG,MADf;AAAA,QAEMa,EAAE,GAAGhB,IAAI,CAACgB,EAAL,IAAW,CAFtB;AAAA,QAGMC,EAAE,GAAGjB,IAAI,CAACiB,EAAL,IAAW,CAHtB;AAAA,QAIMgC,EAAE,GAAGjD,IAAI,CAACiD,EAAL,IAAWrI,CAJtB;AAAA,QAKMsI,EAAE,GAAGlD,IAAI,CAACkD,EAAL,IAAWT,CALtB;AAAA,QAMMsF,GAAG,GAAG/H,IAAI,CAAClG,MANjB;AAAA,QAOMG,KAAK,GAAG8N,GAAG,GAAGpN,CAAC,IAAIoN,GAAG,CAACpN,CAAD,CAAX,GAAiBhC,IAPlC;AAAA,QAQMqP,GAAG,GAAG1O,MAAM,CAAC2J,EAAE,GAAGjC,EAAN,EAAUkC,EAAE,GAAGjC,EAAf,CARlB;AAAA,QASMgH,GAAG,GAAGD,GAAG,CAACE,UAAJ,CAAe,IAAf,CATZ;AAAA,QAUMC,GAAG,GAAGF,GAAG,CAACG,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuBnF,EAAE,GAAGjC,EAA5B,EAAgCkC,EAAE,GAAGjC,EAArC,CAVZ;AAAA,QAWMoH,GAAG,GAAGF,GAAG,CAACzG,IAXhB;;AAaA,OAAK,IAAIrE,CAAC,GAAG4D,EAAR,EAAY5C,CAAC,GAAG,CAArB,EAAwBhB,CAAC,GAAG6F,EAA5B,EAAgC,EAAE7F,CAAlC,EAAqC;AACnCsG,IAAAA,GAAG,CAAC6D,EAAJ,GAASnK,CAAC,GAAG4D,EAAb;;AAEA,SAAK,IAAItG,CAAC,GAAGqG,EAAR,EAAY7C,CAAC,GAAGd,CAAC,GAAGzC,CAAzB,EAA4BD,CAAC,GAAGsI,EAAhC,EAAoC,EAAEtI,CAAF,EAAK0D,CAAC,IAAI,CAA9C,EAAiD;AAC/CsF,MAAAA,GAAG,CAAC4D,EAAJ,GAAS5M,CAAC,GAAGqG,EAAb;AACA2C,MAAAA,GAAG,CAAC8D,MAAJ,GAAaxN,KAAK,CAACU,CAAC,GAAGwD,CAAL,CAAlB;AACA,YAAMwD,CAAC,GAAG0F,KAAK,CAAC1D,GAAD,CAAf;AACA0E,MAAAA,GAAG,CAAChK,CAAC,GAAG,CAAL,CAAH,GAAasD,CAAC,CAACxD,CAAf;AACAkK,MAAAA,GAAG,CAAChK,CAAC,GAAG,CAAL,CAAH,GAAasD,CAAC,CAACvF,CAAf;AACAiM,MAAAA,GAAG,CAAChK,CAAC,GAAG,CAAL,CAAH,GAAasD,CAAC,CAAC7D,CAAf;AACAuK,MAAAA,GAAG,CAAChK,CAAC,GAAG,CAAL,CAAH,GAAa,CAAC,EAAE,MAAM8I,OAAO,CAACxD,GAAD,CAAf,CAAd;AACD;AACF;;AAEDsE,EAAAA,GAAG,CAACK,YAAJ,CAAiBH,GAAjB,EAAsB,CAAtB,EAAyB,CAAzB;AACA,SAAOH,GAAP;AACD;AAED;;;;;;;AAMA,SAASO,UAAT,CAAoB1J,MAApB,EAA4B;AAC1BrH,EAAAA,SAAS,CAACsH,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACA,OAAKM,QAAL,CAAc,IAAd,EAF0B,CAEL;AACtB;;AACDrH,QAAQ,CAACyQ,UAAD,EAAa/Q,SAAb,EAAwB;AAC9BwH,EAAAA,SAAS,CAACnC,CAAD,EAAIoC,KAAJ,EAAW;AAClB,QAAIqH,IAAI,GAAG,KAAKrM,KAAhB;;AAEA,QAAI,CAACqM,IAAD,IAASzJ,CAAC,CAACsC,QAAF,CAAW,MAAX,CAAb,EAAiC;AAC/B,WAAKlF,KAAL,GAAaqM,IAAI,GAAGkC,MAAM,CAAC3L,CAAC,CAAC7B,IAAH,CAA1B;AACA9B,MAAAA,oBAAoB,CAACuB,OAArB,CAA6BuM,IAAI,IAAI;AACnC,YAAInK,CAAC,CAACmK,IAAD,CAAD,IAAW,IAAf,EAAqB9C,GAAG,CAACoC,IAAD,EAAOU,IAAP,EAAanK,CAAC,CAACmK,IAAD,CAAd,CAAH;AACtB,OAFD;AAGD,KALD,MAKO;AACL9N,MAAAA,oBAAoB,CAACuB,OAArB,CAA6BuM,IAAI,IAAI;AACnC,YAAInK,CAAC,CAACsC,QAAF,CAAW6H,IAAX,CAAJ,EAAsB9C,GAAG,CAACoC,IAAD,EAAOU,IAAP,EAAanK,CAAC,CAACmK,IAAD,CAAd,CAAH;AACvB,OAFD;AAGD;;AAED,QAAInK,CAAC,CAACqJ,WAAF,IAAiB,IAArB,EAA2BI,IAAI,CAACT,IAAL,CAAUK,WAAV,CAAsBrJ,CAAC,CAACqJ,WAAxB;AAC3B,QAAIrJ,CAAC,CAAC4L,GAAN,EAAWA,GAAG,CAACnC,IAAD,EAAOzJ,CAAP,CAAH;AACX,WAAOoC,KAAK,CAACK,IAAN,CAAWL,KAAK,CAACM,SAAN,GAAkBN,KAAK,CAACO,SAAnC,CAAP;AACD;;AAlB6B,CAAxB,CAAR;;AAsBA,SAASiJ,GAAT,CAAanC,IAAb,EAAmBzJ,CAAnB,EAAsB;AACpB,QAAM6E,IAAI,GAAGgH,cAAc,CAAC7L,CAAC,CAAC4L,GAAH,CAA3B;AACA5L,EAAAA,CAAC,CAAChF,MAAF,GAAWyO,IAAI,CAACqC,SAAL,CAAe9L,CAAC,CAAChF,MAAjB,EAAyB6J,IAAzB,CAAX,GAA4C7E,CAAC,CAACD,IAAF,GAAS0J,IAAI,CAACsC,OAAL,CAAa/L,CAAC,CAACD,IAAf,EAAqB8E,IAArB,CAAT,GAAsC,CAAlF;AACD;;AAED,SAAS8G,MAAT,CAAgBxN,IAAhB,EAAsB;AACpB,QAAM6N,WAAW,GAAG1P,UAAU,CAAC,CAAC6B,IAAI,IAAI,UAAT,EAAqB8N,WAArB,EAAD,CAA9B;AACA,MAAI,CAACD,WAAL,EAAkBjR,KAAK,CAAC,mCAAmCoD,IAApC,CAAL;AAClB,SAAO6N,WAAW,EAAlB;AACD;;AAED,SAAS3E,GAAT,CAAaoC,IAAb,EAAmByC,GAAnB,EAAwB9O,KAAxB,EAA+B;AAC7B,MAAIhC,UAAU,CAACqO,IAAI,CAACyC,GAAD,CAAL,CAAd,EAA2BzC,IAAI,CAACyC,GAAD,CAAJ,CAAU9O,KAAV;AAC5B;;AAED,SAASyO,cAAT,CAAwBhH,IAAxB,EAA8B;AAC5BA,EAAAA,IAAI,GAAGtJ,KAAK,CAACsJ,IAAD,CAAZ;AACA,SAAOA,IAAI,CAAC7G,MAAL,KAAgB,CAAhB,GAAoB6G,IAAI,CAAC,CAAD,CAAxB,GAA8B;AACnC1G,IAAAA,IAAI,EAAE2J,iBAD6B;AAEnCG,IAAAA,QAAQ,EAAEpD,IAAI,CAACsH,MAAL,CAAY,CAACnL,CAAD,EAAI1B,CAAJ,KAAU0B,CAAC,CAACxB,MAAF,CAAS4M,SAAS,CAAC9M,CAAD,CAAlB,CAAtB,EAA8C,EAA9C;AAFyB,GAArC;AAID;;AAED,SAAS8M,SAAT,CAAmB9M,CAAnB,EAAsB;AACpB,SAAOA,CAAC,CAACnB,IAAF,KAAW2J,iBAAX,GAA+BxI,CAAC,CAAC2I,QAAjC,GAA4C1M,KAAK,CAAC+D,CAAD,CAAL,CAAS+M,MAAT,CAAgBlH,CAAC,IAAIA,CAAC,IAAI,IAA1B,EAAgChI,GAAhC,CAAoCgI,CAAC,IAAIA,CAAC,CAAChH,IAAF,KAAW0J,OAAX,GAAqB1C,CAArB,GAAyB;AACnHhH,IAAAA,IAAI,EAAE0J,OAD6G;AAEnHnD,IAAAA,QAAQ,EAAES;AAFyG,GAAlE,CAAnD;AAID;;AAED,SAASsC,OAAO,IAAIpK,OAApB,EAA6B2K,OAAO,IAAIQ,OAAxC,EAAiDM,OAAO,IAAIwD,OAA5D,EAAqE9C,QAAQ,IAAI+C,QAAjF,EAA2F3C,QAAQ,IAAI4C,QAAvG,EAAiHzC,SAAS,IAAI0C,SAA9H,EAAyIrC,OAAO,IAAIsC,OAApJ,EAA6J3K,UAAU,IAAI4K,UAA3K,EAAuL/F,KAAK,IAAIgG,KAAhM,EAAuMlB,UAAU,IAAIpP,UAArN","sourcesContent":["import { Transform, rederive, ingest, replace } from 'vega-dataflow';\nimport { error, extent, inherits, identity, isArray, isFunction, isNumber, constant, array, one, accessorName, accessorFields, field, extend, toSet, zero } from 'vega-util';\nimport { range, tickStep, max, sum } from 'd3-array';\nimport { bandwidthNRD } from 'vega-statistics';\nimport { getProjectionPath, projectionProperties, projection } from 'vega-projection';\nimport { geoGraticule } from 'd3-geo';\nimport { rgb } from 'd3-color';\nimport { canvas } from 'vega-canvas';\n\nfunction noop() {}\n\nconst cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []]; // Implementation adapted from d3/d3-contour. Thanks!\n\nfunction contours () {\n  var dx = 1,\n      dy = 1,\n      smooth = smoothLinear;\n\n  function contours(values, tz) {\n    return tz.map(value => contour(values, value));\n  } // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n\n\n  function contour(values, value) {\n    var polygons = [],\n        holes = [];\n    isorings(values, value, ring => {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(hole => {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: 'MultiPolygon',\n      value: value,\n      coordinates: polygons\n    };\n  } // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n\n\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array(),\n        fragmentByEnd = new Array(),\n        x,\n        y,\n        t0,\n        t1,\n        t2,\n        t3; // Special case for the first row (y = -1, t2 = t3 = 0).\n\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n\n    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.\n\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n\n      cases[t1 | t2 << 3].forEach(stitch);\n    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n\n\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f,\n          g;\n\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(point => {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v0,\n          v1 = values[yt * dx + xt];\n\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n\n    var _0 = Math.floor(_[0]),\n        _1 = Math.floor(_[1]);\n\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n\nfunction area(ring) {\n  var i = 0,\n      n = ring.length,\n      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n\n  return area;\n}\n\nfunction contains(ring, hole) {\n  var i = -1,\n      n = hole.length,\n      c;\n\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n\n  return 0;\n}\n\nfunction ringContains(ring, point) {\n  var x = point[0],\n      y = point[1],\n      contains = -1;\n\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i],\n        xi = pi[0],\n        yi = pi[1],\n        pj = ring[j],\n        xj = pj[0],\n        yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;\n  }\n\n  return contains;\n}\n\nfunction segmentContains(a, b, c) {\n  var i;\n  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\n\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n\nfunction quantize (k, nice, zero) {\n  return function (values) {\n    var ex = extent(values),\n        start = zero ? Math.min(ex[0], 0) : ex[0],\n        stop = ex[1],\n        span = stop - start,\n        step = nice ? tickStep(start, stop, k) : span / (k + 1);\n    return range(start + step, stop, step);\n  };\n}\n\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\n\nfunction Isocontour(params) {\n  Transform.call(this, null, params);\n}\nIsocontour.Definition = {\n  'type': 'Isocontour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'levels',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'zero',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'scale',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'translate',\n    'type': 'number',\n    'array': true,\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'default': 'contour'\n  }]\n};\ninherits(Isocontour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        source = pulse.materialize(pulse.SOURCE).source,\n        field = _.field || identity,\n        contour = contours().smooth(_.smooth !== false),\n        tz = _.thresholds || levels(source, field, _),\n        as = _.as === null ? null : _.as || 'contour',\n        values = [];\n    source.forEach(t => {\n      const grid = field(t); // generate contour paths in GeoJSON format\n\n      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed\n\n      transformPaths(paths, grid, t, _); // ingest; copy source data properties to output\n\n      paths.forEach(p => {\n        values.push(rederive(t, ingest(as != null ? {\n          [as]: p\n        } : p)));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n\n});\n\nfunction levels(values, f, _) {\n  const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(t => max(f(t).values)));\n}\n\nfunction transformPaths(paths, grid, datum, _) {\n  let s = _.scale || grid.scale,\n      t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  const sx = (isNumber(s) ? s : s[0]) || 1,\n        sy = (isNumber(s) ? s : s[1]) || 1,\n        tx = t && t[0] || 0,\n        ty = t && t[1] || 0;\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\n\nfunction transform(grid, sx, sy, tx, ty) {\n  const x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        flip = sx * sy < 0;\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n\n    coordinates.forEach(transformPoint);\n  }\n\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}\n\nfunction radius(bw, data, f) {\n  const v = bw >= 0 ? bw : bandwidthNRD(data, f);\n  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\n}\n\nfunction number(_) {\n  return isFunction(_) ? _ : constant(+_);\n} // Implementation adapted from d3/d3-contour. Thanks!\n\n\nfunction density2D () {\n  var x = d => d[0],\n      y = d => d[1],\n      weight = one,\n      bandwidth = [-1, -1],\n      dx = 960,\n      dy = 500,\n      k = 2; // log2(cellSize)\n\n\n  function density(data, counts) {\n    const rx = radius(bandwidth[0], data, x) >> k,\n          // blur x-radius\n    ry = radius(bandwidth[1], data, y) >> k,\n          // blur y-radius\n    ox = rx ? rx + 2 : 0,\n          // x-offset padding for blur\n    oy = ry ? ry + 2 : 0,\n          // y-offset padding for blur\n    n = 2 * ox + (dx >> k),\n          // grid width\n    m = 2 * oy + (dy >> k),\n          // grid height\n    values0 = new Float32Array(n * m),\n          values1 = new Float32Array(n * m);\n    let values = values0;\n    data.forEach(d => {\n      const xi = ox + (+x(d) >> k),\n            yi = oy + (+y(d) >> k);\n\n      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        values0[xi + yi * n] += +weight(d);\n      }\n    });\n\n    if (rx > 0 && ry > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n    } else if (rx > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurX(n, m, values1, values0, rx);\n      blurX(n, m, values0, values1, rx);\n      values = values1;\n    } else if (ry > 0) {\n      blurY(n, m, values0, values1, ry);\n      blurY(n, m, values1, values0, ry);\n      blurY(n, m, values0, values1, ry);\n      values = values1;\n    } // scale density estimates\n    // density in points per square pixel or probability density\n\n\n    const s = counts ? Math.pow(2, -2 * k) : 1 / sum(values);\n\n    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;\n\n    return {\n      values: values,\n      scale: 1 << k,\n      width: n,\n      height: m,\n      x1: ox,\n      y1: oy,\n      x2: ox + (dx >> k),\n      y2: oy + (dy >> k)\n    };\n  }\n\n  density.x = function (_) {\n    return arguments.length ? (x = number(_), density) : x;\n  };\n\n  density.y = function (_) {\n    return arguments.length ? (y = number(_), density) : y;\n  };\n\n  density.weight = function (_) {\n    return arguments.length ? (weight = number(_), density) : weight;\n  };\n\n  density.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n\n    var _0 = +_[0],\n        _1 = +_[1];\n\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, density;\n  };\n\n  density.cellSize = function (_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) error('invalid cell size');\n    k = Math.floor(Math.log(_) / Math.LN2);\n    return density;\n  };\n\n  density.bandwidth = function (_) {\n    if (!arguments.length) return bandwidth;\n    _ = array(_);\n    if (_.length === 1) _ = [+_[0], +_[0]];\n    if (_.length !== 2) error('invalid bandwidth');\n    return bandwidth = _, density;\n  };\n\n  return density;\n}\n\nfunction blurX(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n\n  for (let j = 0; j < m; ++j) {\n    for (let i = 0, sr = 0; i < n + r; ++i) {\n      if (i < n) {\n        sr += source[i + j * n];\n      }\n\n      if (i >= r) {\n        if (i >= w) {\n          sr -= source[i - w + j * n];\n        }\n\n        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n      }\n    }\n  }\n}\n\nfunction blurY(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0, sr = 0; j < m + r; ++j) {\n      if (j < m) {\n        sr += source[i + j * n];\n      }\n\n      if (j >= r) {\n        if (j >= w) {\n          sr -= source[i + (j - w) * n];\n        }\n\n        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n      }\n    }\n  }\n}\n\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\n\nfunction KDE2D(params) {\n  Transform.call(this, null, params);\n}\nKDE2D.Definition = {\n  'type': 'KDE2D',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'grid'\n  }]\n};\nconst PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\nfunction params(obj, _) {\n  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n  return obj;\n}\ninherits(KDE2D, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        kde = params(density2D(), _),\n        as = _.as || 'grid',\n        values = [];\n\n    function set(t, vals) {\n      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];\n\n      return t;\n    } // generate density raster grids\n\n\n    values = groups.map(g => ingest(set({\n      [as]: kde(g, _.counts)\n    }, g.dims)));\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n\n});\nfunction partition(data, groupby) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\n\nfunction Contour(params) {\n  Transform.call(this, null, params);\n}\nContour.Definition = {\n  'type': 'Contour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'values',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'x',\n    'type': 'field'\n  }, {\n    'name': 'y',\n    'type': 'field'\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number'\n  }, {\n    'name': 'count',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }]\n};\ninherits(Contour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        contour = contours().smooth(_.smooth !== false),\n        values = _.values,\n        thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n        size = _.size,\n        grid,\n        post;\n\n    if (!values) {\n      values = pulse.materialize(pulse.SOURCE).source;\n      grid = params(density2D(), _)(values, true);\n      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n      size = [grid.width, grid.height];\n      values = grid.values;\n    }\n\n    thresh = isArray(thresh) ? thresh : thresh(values);\n    values = contour.size(size)(values, thresh);\n    if (post) values.forEach(post);\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = (values || []).map(ingest);\n    return out;\n  }\n\n});\n\nconst Feature = 'Feature';\nconst FeatureCollection = 'FeatureCollection';\nconst MultiPoint = 'MultiPoint';\n\n/**\n * Consolidate an array of [longitude, latitude] points or GeoJSON features\n * into a combined GeoJSON object. This transform is particularly useful for\n * combining geo data for a Projection's fit argument. The resulting GeoJSON\n * data is available as this transform's value. Input pulses are unchanged.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.fields] - A two-element array\n *   of field accessors for the longitude and latitude values.\n * @param {function(object): *} params.geojson - A field accessor for\n *   retrieving GeoJSON feature data.\n */\n\nfunction GeoJSON(params) {\n  Transform.call(this, null, params);\n}\nGeoJSON.Definition = {\n  'type': 'GeoJSON',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'geojson',\n    'type': 'field'\n  }]\n};\ninherits(GeoJSON, Transform, {\n  transform(_, pulse) {\n    var features = this._features,\n        points = this._points,\n        fields = _.fields,\n        lon = fields && fields[0],\n        lat = fields && fields[1],\n        geojson = _.geojson || !fields && identity,\n        flag = pulse.ADD,\n        mod;\n    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified(accessorFields(geojson)) || lon && pulse.modified(accessorFields(lon)) || lat && pulse.modified(accessorFields(lat));\n\n    if (!this.value || mod) {\n      flag = pulse.SOURCE;\n      this._features = features = [];\n      this._points = points = [];\n    }\n\n    if (geojson) {\n      pulse.visit(flag, t => features.push(geojson(t)));\n    }\n\n    if (lon && lat) {\n      pulse.visit(flag, t => {\n        var x = lon(t),\n            y = lat(t);\n\n        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n          points.push([x, y]);\n        }\n      });\n      features = features.concat({\n        type: Feature,\n        geometry: {\n          type: MultiPoint,\n          coordinates: points\n        }\n      });\n    }\n\n    this.value = {\n      type: FeatureCollection,\n      features: features\n    };\n  }\n\n});\n\n/**\n * Map GeoJSON data to an SVG path string.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='path'] - The output field in which to store\n *   the generated path data (default 'path').\n */\n\nfunction GeoPath(params) {\n  Transform.call(this, null, params);\n}\nGeoPath.Definition = {\n  'type': 'GeoPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(GeoPath, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        path = this.value,\n        field = _.field || identity,\n        as = _.as || 'path',\n        flag = out.SOURCE;\n\n    if (!path || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = path = getProjectionPath(_.projection);\n      out.materialize().reflow();\n    } else {\n      flag = field === identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;\n    }\n\n    const prev = initPath(path, _.pointRadius);\n    out.visit(flag, t => t[as] = path(field(t)));\n    path.pointRadius(prev);\n    return out.modifies(as);\n  }\n\n});\n\nfunction initPath(path, pointRadius) {\n  const prev = path.pointRadius();\n  path.context(null);\n\n  if (pointRadius != null) {\n    path.pointRadius(pointRadius);\n  }\n\n  return prev;\n}\n\n/**\n * Geo-code a longitude/latitude point to an x/y coordinate.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {Array<function(object): *>} params.fields - A two-element array of\n *   field accessors for the longitude and latitude values.\n * @param {Array<string>} [params.as] - A two-element array of field names\n *   under which to store the result. Defaults to ['x','y'].\n */\n\nfunction GeoPoint(params) {\n  Transform.call(this, null, params);\n}\nGeoPoint.Definition = {\n  'type': 'GeoPoint',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection',\n    'required': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['x', 'y']\n  }]\n};\ninherits(GeoPoint, Transform, {\n  transform(_, pulse) {\n    var proj = _.projection,\n        lon = _.fields[0],\n        lat = _.fields[1],\n        as = _.as || ['x', 'y'],\n        x = as[0],\n        y = as[1],\n        mod;\n\n    function set(t) {\n      const xy = proj([lon(t), lat(t)]);\n\n      if (xy) {\n        t[x] = xy[0];\n        t[y] = xy[1];\n      } else {\n        t[x] = undefined;\n        t[y] = undefined;\n      }\n    }\n\n    if (_.modified()) {\n      // parameters updated, reflow\n      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n    } else {\n      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n    }\n\n    return pulse.modifies(as);\n  }\n\n});\n\n/**\n * Annotate items with a geopath shape generator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='shape'] - The output field in which to store\n *   the generated path data (default 'shape').\n */\n\nfunction GeoShape(params) {\n  Transform.call(this, null, params);\n}\nGeoShape.Definition = {\n  'type': 'GeoShape',\n  'metadata': {\n    'modifies': true,\n    'nomod': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'default': 'datum'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'shape'\n  }]\n};\ninherits(GeoShape, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        shape = this.value,\n        as = _.as || 'shape',\n        flag = out.ADD;\n\n    if (!shape || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = shape = shapeGenerator(getProjectionPath(_.projection), _.field || field('datum'), _.pointRadius);\n      out.materialize().reflow();\n      flag = out.SOURCE;\n    }\n\n    out.visit(flag, t => t[as] = shape);\n    return out.modifies(as);\n  }\n\n});\n\nfunction shapeGenerator(path, field, pointRadius) {\n  const shape = pointRadius == null ? _ => path(field(_)) : _ => {\n    var prev = path.pointRadius(),\n        value = path.pointRadius(pointRadius)(field(_));\n    path.pointRadius(prev);\n    return value;\n  };\n\n  shape.context = _ => {\n    path.context(_);\n    return shape;\n  };\n\n  return shape;\n}\n\n/**\n * GeoJSON feature generator for creating graticules.\n * @constructor\n */\n\nfunction Graticule(params) {\n  Transform.call(this, [], params);\n  this.generator = geoGraticule();\n}\nGraticule.Definition = {\n  'type': 'Graticule',\n  'metadata': {\n    'changes': true,\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMajor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMinor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'stepMajor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [90, 360]\n  }, {\n    'name': 'stepMinor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [10, 10]\n  }, {\n    'name': 'precision',\n    'type': 'number',\n    'default': 2.5\n  }]\n};\ninherits(Graticule, Transform, {\n  transform(_, pulse) {\n    var src = this.value,\n        gen = this.generator,\n        t;\n\n    if (!src.length || _.modified()) {\n      for (const prop in _) {\n        if (isFunction(gen[prop])) {\n          gen[prop](_[prop]);\n        }\n      }\n    }\n\n    t = gen();\n\n    if (src.length) {\n      pulse.mod.push(replace(src[0], t));\n    } else {\n      pulse.add.push(ingest(t));\n    }\n\n    src[0] = t;\n    return pulse;\n  }\n\n});\n\n/**\n * Render a heatmap image for input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {string} [params.color] - A constant color value or function for\n *   individual pixel color. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {number} [params.opacity] - A constant opacity value or function for\n *   individual pixel opacity. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {string} [params.resolve] - The method for resolving maximum values\n *   across multiple input grids. If 'independent' (the default), maximum\n *   calculation will be performed separately for each grid. If 'shared',\n *   a single global maximum will be used for all input grids.\n * @param {string} [params.as='image'] - The output field in which to store\n *   the generated bitmap canvas images (default 'image').\n */\n\nfunction Heatmap(params) {\n  Transform.call(this, null, params);\n}\nHeatmap.Definition = {\n  'type': 'heatmap',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'color',\n    'type': 'string',\n    'expr': true\n  }, {\n    'name': 'opacity',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'image'\n  }]\n};\ninherits(Heatmap, Transform, {\n  transform(_, pulse) {\n    if (!pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var source = pulse.materialize(pulse.SOURCE).source,\n        shared = _.resolve === 'shared',\n        field = _.field || identity,\n        opacity = opacity_(_.opacity, _),\n        color = color_(_.color, _),\n        as = _.as || 'image',\n        obj = {\n      $x: 0,\n      $y: 0,\n      $value: 0,\n      $max: shared ? max(source.map(t => max(field(t).values))) : 0\n    };\n    source.forEach(t => {\n      const v = field(t); // build proxy data object\n\n      const o = extend({}, t, obj); // set maximum value if not globally shared\n\n      if (!shared) o.$max = max(v.values || []); // generate canvas image\n      // optimize color/opacity if not pixel-dependent\n\n      t[as] = toCanvas(v, o, color.dep ? color : constant(color(o)), opacity.dep ? opacity : constant(opacity(o)));\n    });\n    return pulse.reflow(true).modifies(as);\n  }\n\n}); // get image color function\n\nfunction color_(color, _) {\n  let f;\n\n  if (isFunction(color)) {\n    f = obj => rgb(color(obj, _));\n\n    f.dep = dependency(color);\n  } else {\n    // default to mid-grey\n    f = constant(rgb(color || '#888'));\n  }\n\n  return f;\n} // get image opacity function\n\n\nfunction opacity_(opacity, _) {\n  let f;\n\n  if (isFunction(opacity)) {\n    f = obj => opacity(obj, _);\n\n    f.dep = dependency(opacity);\n  } else if (opacity) {\n    f = constant(opacity);\n  } else {\n    // default to [0, max] opacity gradient\n    f = obj => obj.$value / obj.$max || 0;\n\n    f.dep = true;\n  }\n\n  return f;\n} // check if function depends on individual pixel data\n\n\nfunction dependency(f) {\n  if (!isFunction(f)) return false;\n  const set = toSet(accessorFields(f));\n  return set.$x || set.$y || set.$value || set.$max;\n} // render raster grid to canvas\n\n\nfunction toCanvas(grid, obj, color, opacity) {\n  const n = grid.width,\n        m = grid.height,\n        x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        x2 = grid.x2 || n,\n        y2 = grid.y2 || m,\n        val = grid.values,\n        value = val ? i => val[i] : zero,\n        can = canvas(x2 - x1, y2 - y1),\n        ctx = can.getContext('2d'),\n        img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n        pix = img.data;\n\n  for (let j = y1, k = 0; j < y2; ++j) {\n    obj.$y = j - y1;\n\n    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {\n      obj.$x = i - x1;\n      obj.$value = value(i + r);\n      const v = color(obj);\n      pix[k + 0] = v.r;\n      pix[k + 1] = v.g;\n      pix[k + 2] = v.b;\n      pix[k + 3] = ~~(255 * opacity(obj));\n    }\n  }\n\n  ctx.putImageData(img, 0, 0);\n  return can;\n}\n\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Projection, Transform, {\n  transform(_, pulse) {\n    let proj = this.value;\n\n    if (!proj || _.modified('type')) {\n      this.value = proj = create(_.type);\n      projectionProperties.forEach(prop => {\n        if (_[prop] != null) set(proj, prop, _[prop]);\n      });\n    } else {\n      projectionProperties.forEach(prop => {\n        if (_.modified(prop)) set(proj, prop, _[prop]);\n      });\n    }\n\n    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n    if (_.fit) fit(proj, _);\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n\n});\n\nfunction fit(proj, _) {\n  const data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;\n}\n\nfunction create(type) {\n  const constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\n\nfunction set(proj, key, value) {\n  if (isFunction(proj[key])) proj[key](value);\n}\n\nfunction collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0] : {\n    type: FeatureCollection,\n    features: data.reduce((a, f) => a.concat(featurize(f)), [])\n  };\n}\n\nfunction featurize(f) {\n  return f.type === FeatureCollection ? f.features : array(f).filter(d => d != null).map(d => d.type === Feature ? d : {\n    type: Feature,\n    geometry: d\n  });\n}\n\nexport { Contour as contour, GeoJSON as geojson, GeoPath as geopath, GeoPoint as geopoint, GeoShape as geoshape, Graticule as graticule, Heatmap as heatmap, Isocontour as isocontour, KDE2D as kde2d, Projection as projection };\n"]},"metadata":{},"sourceType":"module"}