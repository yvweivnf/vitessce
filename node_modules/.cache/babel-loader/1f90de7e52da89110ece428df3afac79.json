{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtrudeMode = void 0;\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _utils = require(\"../utils\");\n\nvar _modifyMode = require(\"./modify-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ExtrudeMode = /*#__PURE__*/function (_ModifyMode) {\n  _inherits(ExtrudeMode, _ModifyMode);\n\n  var _super = _createSuper(ExtrudeMode);\n\n  function ExtrudeMode() {\n    var _this;\n\n    _classCallCheck(this, ExtrudeMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"isPointAdded\", false);\n\n    return _this;\n  }\n\n  _createClass(ExtrudeMode, [{\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (editHandle) {\n        var featureIndex = editHandle.properties.featureIndex;\n        var positionIndexes = editHandle.properties.positionIndexes;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n        positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes; // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          // p3 and p4 are end points for moving (extruding) edge\n          var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords),\n              _generatePointsParall2 = _slicedToArray(_generatePointsParall, 2),\n              p3 = _generatePointsParall2[0],\n              p4 = _generatePointsParall2[1];\n\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'extruding',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: this.nextPositionIndexes(positionIndexes, size),\n              position: p3\n            }\n          });\n          event.cancelPan();\n        }\n      }\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var _editHandle$propertie = editHandle.properties,\n            positionIndexes = _editHandle$propertie.positionIndexes,\n            featureIndex = _editHandle$propertie.featureIndex;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data); // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n\n          if (!this.isOrthogonal(positionIndexes, featureIndex, size, props.data)) {\n            updatedData = updatedData.addPosition(featureIndex, positionIndexes, p2);\n          }\n\n          if (!this.isOrthogonal(this.prevPositionIndexes(positionIndexes, size), featureIndex, size, props.data)) {\n            updatedData = updatedData.addPosition(featureIndex, positionIndexes, p1);\n            this.isPointAdded = true;\n          }\n\n          props.onEdit({\n            updatedData: updatedData.getObject(),\n            editType: 'startExtruding',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: p1\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var featureIndex = editHandle.properties.featureIndex;\n        var positionIndexes = editHandle.properties.positionIndexes;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n        positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes; // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          // p3 and p4 are end points for new moved (extruded) edge\n          var _generatePointsParall3 = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords),\n              _generatePointsParall4 = _slicedToArray(_generatePointsParall3, 2),\n              p3 = _generatePointsParall4[0],\n              p4 = _generatePointsParall4[1];\n\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'extruded',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: p3\n            }\n          });\n        }\n      }\n\n      this.isPointAdded = false;\n    }\n  }, {\n    key: \"coordinatesSize\",\n    value: function coordinatesSize(positionIndexes, featureIndex, _ref) {\n      var features = _ref.features;\n      var size = 0;\n\n      if (Array.isArray(positionIndexes)) {\n        var feature = features[featureIndex];\n        var coordinates = feature.geometry.coordinates; // for Multi polygons, length will be 3\n\n        if (positionIndexes.length === 3) {\n          var _positionIndexes = _slicedToArray(positionIndexes, 2),\n              a = _positionIndexes[0],\n              b = _positionIndexes[1];\n\n          if (coordinates.length && coordinates[a].length) {\n            size = coordinates[a][b].length;\n          }\n        } else {\n          var _positionIndexes2 = _slicedToArray(positionIndexes, 1),\n              _b = _positionIndexes2[0];\n\n          if (coordinates.length && coordinates[_b].length) {\n            size = coordinates[_b].length;\n          }\n        }\n      }\n\n      return size;\n    }\n  }, {\n    key: \"getBearing\",\n    value: function getBearing(p1, p2) {\n      var angle = (0, _bearing[\"default\"])(p1, p2);\n\n      if (angle < 0) {\n        return Math.floor(360 + angle);\n      }\n\n      return Math.floor(angle);\n    }\n  }, {\n    key: \"isOrthogonal\",\n    value: function isOrthogonal(positionIndexes, featureIndex, size, features) {\n      if (!Array.isArray(positionIndexes)) {\n        return false;\n      }\n\n      if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n        positionIndexes[positionIndexes.length - 1] = 0;\n      }\n\n      var prevPoint = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, features);\n      var nextPoint = this.getPointForPositionIndexes(this.nextPositionIndexes(positionIndexes, size), featureIndex, features);\n      var currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex, features);\n      var prevAngle = this.getBearing(currentPoint, prevPoint);\n      var nextAngle = this.getBearing(currentPoint, nextPoint);\n      return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n    }\n  }, {\n    key: \"nextPositionIndexes\",\n    value: function nextPositionIndexes(positionIndexes, size) {\n      if (!Array.isArray(positionIndexes)) {\n        return [];\n      }\n\n      var next = _toConsumableArray(positionIndexes);\n\n      if (next.length) {\n        next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n      }\n\n      return next;\n    }\n  }, {\n    key: \"prevPositionIndexes\",\n    value: function prevPositionIndexes(positionIndexes, size) {\n      if (!Array.isArray(positionIndexes)) {\n        return [];\n      }\n\n      var prev = _toConsumableArray(positionIndexes);\n\n      if (prev.length) {\n        prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n      }\n\n      return prev;\n    }\n  }, {\n    key: \"getPointForPositionIndexes\",\n    value: function getPointForPositionIndexes(positionIndexes, featureIndex, _ref2) {\n      var features = _ref2.features;\n      var p1;\n\n      if (Array.isArray(positionIndexes)) {\n        var feature = features[featureIndex];\n        var coordinates = feature.geometry.coordinates; // for Multi polygons, length will be 3\n\n        if (positionIndexes.length === 3) {\n          var _positionIndexes3 = _slicedToArray(positionIndexes, 3),\n              a = _positionIndexes3[0],\n              b = _positionIndexes3[1],\n              c = _positionIndexes3[2];\n\n          if (coordinates.length && coordinates[a].length) {\n            p1 = coordinates[a][b][c];\n          }\n        } else {\n          var _positionIndexes4 = _slicedToArray(positionIndexes, 2),\n              _b2 = _positionIndexes4[0],\n              _c = _positionIndexes4[1];\n\n          if (coordinates.length && coordinates[_b2].length) {\n            p1 = coordinates[_b2][_c];\n          }\n        }\n      }\n\n      return p1;\n    }\n  }]);\n\n  return ExtrudeMode;\n}(_modifyMode.ModifyMode);\n\nexports.ExtrudeMode = ExtrudeMode;","map":{"version":3,"sources":["../../src/lib/extrude-mode.ts"],"names":["ExtrudeMode","ModifyMode","event","props","editHandle","featureIndex","positionIndexes","size","p1","p2","p3","p4","updatedData","ImmutableFeatureCollection","editType","editContext","featureIndexes","position","selectedFeatureIndexes","features","Array","feature","coordinates","a","b","angle","Math","prevPoint","nextPoint","currentPoint","prevAngle","nextAngle","next","prev","c"],"mappings":"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","sourcesContent":["import bearing from '@turf/bearing';\nimport {\n  generatePointsParallelToLinePoints,\n  getPickedEditHandle,\n  getPickedIntermediateEditHandle,\n} from '../utils';\nimport { FeatureCollection } from '../geojson-types';\nimport { ModeProps, StartDraggingEvent, StopDraggingEvent, DraggingEvent } from '../types';\nimport { ModifyMode } from './modify-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ExtrudeMode extends ModifyMode {\n  // this mode is busted =(\n\n  isPointAdded = false;\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (editHandle) {\n      const { featureIndex } = editHandle.properties;\n      let { positionIndexes } = editHandle.properties;\n\n      const size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n      positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(positionIndexes, size)\n        : positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n      if (p1 && p2) {\n        // p3 and p4 are end points for moving (extruding) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.mapCoords);\n\n        const updatedData = new ImmutableFeatureCollection(props.data)\n          .replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4)\n          .replacePosition(featureIndex, positionIndexes, p3)\n          .getObject();\n\n        props.onEdit({\n          updatedData,\n          editType: 'extruding',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes: this.nextPositionIndexes(positionIndexes, size),\n            position: p3,\n          },\n        });\n\n        event.cancelPan();\n      }\n    }\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const editHandle = getPickedIntermediateEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const { positionIndexes, featureIndex } = editHandle.properties;\n\n      const size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n      if (p1 && p2) {\n        let updatedData = new ImmutableFeatureCollection(props.data);\n        if (!this.isOrthogonal(positionIndexes, featureIndex, size, props.data)) {\n          updatedData = updatedData.addPosition(featureIndex, positionIndexes, p2);\n        }\n        if (\n          !this.isOrthogonal(\n            this.prevPositionIndexes(positionIndexes, size),\n            featureIndex,\n            size,\n            props.data\n          )\n        ) {\n          updatedData = updatedData.addPosition(featureIndex, positionIndexes, p1);\n          this.isPointAdded = true;\n        }\n\n        props.onEdit({\n          updatedData: updatedData.getObject(),\n          editType: 'startExtruding',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes,\n            position: p1,\n          },\n        });\n      }\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const { featureIndex } = editHandle.properties;\n      let { positionIndexes } = editHandle.properties;\n\n      const size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n      positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(positionIndexes, size)\n        : positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n      if (p1 && p2) {\n        // p3 and p4 are end points for new moved (extruded) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.mapCoords);\n\n        const updatedData = new ImmutableFeatureCollection(props.data)\n          .replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4)\n          .replacePosition(featureIndex, positionIndexes, p3)\n          .getObject();\n\n        props.onEdit({\n          updatedData,\n          editType: 'extruded',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes,\n            position: p3,\n          },\n        });\n      }\n    }\n    this.isPointAdded = false;\n  }\n\n  coordinatesSize(\n    positionIndexes: number[] | null | undefined,\n    featureIndex: number,\n    { features }: FeatureCollection\n  ) {\n    let size = 0;\n    if (Array.isArray(positionIndexes)) {\n      const feature = features[featureIndex];\n      const coordinates: any = feature.geometry.coordinates;\n      // for Multi polygons, length will be 3\n      if (positionIndexes.length === 3) {\n        const [a, b] = positionIndexes;\n        if (coordinates.length && coordinates[a].length) {\n          size = coordinates[a][b].length;\n        }\n      } else {\n        const [b] = positionIndexes;\n        if (coordinates.length && coordinates[b].length) {\n          size = coordinates[b].length;\n        }\n      }\n    }\n    return size;\n  }\n\n  getBearing(p1: any, p2: any) {\n    const angle = bearing(p1, p2);\n    if (angle < 0) {\n      return Math.floor(360 + angle);\n    }\n    return Math.floor(angle);\n  }\n\n  isOrthogonal(\n    positionIndexes: number[] | null | undefined,\n    featureIndex: number,\n    size: number,\n    features: FeatureCollection\n  ) {\n    if (!Array.isArray(positionIndexes)) {\n      return false;\n    }\n    if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n      positionIndexes[positionIndexes.length - 1] = 0;\n    }\n    const prevPoint = this.getPointForPositionIndexes(\n      this.prevPositionIndexes(positionIndexes, size),\n      featureIndex,\n      features\n    );\n    const nextPoint = this.getPointForPositionIndexes(\n      this.nextPositionIndexes(positionIndexes, size),\n      featureIndex,\n      features\n    );\n    const currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex, features);\n    const prevAngle = this.getBearing(currentPoint, prevPoint);\n    const nextAngle = this.getBearing(currentPoint, nextPoint);\n    return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n  }\n\n  nextPositionIndexes(positionIndexes: number[] | null | undefined, size: number): number[] {\n    if (!Array.isArray(positionIndexes)) {\n      return [];\n    }\n    const next = [...positionIndexes];\n    if (next.length) {\n      next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n    }\n    return next;\n  }\n\n  prevPositionIndexes(positionIndexes: number[] | null | undefined, size: number): number[] {\n    if (!Array.isArray(positionIndexes)) {\n      return [];\n    }\n    const prev = [...positionIndexes];\n    if (prev.length) {\n      prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n    }\n    return prev;\n  }\n\n  getPointForPositionIndexes(\n    positionIndexes: number[] | null | undefined,\n    featureIndex: number,\n    { features }: FeatureCollection\n  ) {\n    let p1;\n    if (Array.isArray(positionIndexes)) {\n      const feature = features[featureIndex];\n      const coordinates: any = feature.geometry.coordinates;\n      // for Multi polygons, length will be 3\n      if (positionIndexes.length === 3) {\n        const [a, b, c] = positionIndexes;\n        if (coordinates.length && coordinates[a].length) {\n          p1 = coordinates[a][b][c];\n        }\n      } else {\n        const [b, c] = positionIndexes;\n        if (coordinates.length && coordinates[b].length) {\n          p1 = coordinates[b][c];\n        }\n      }\n    }\n    return p1;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}