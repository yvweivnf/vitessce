{"ast":null,"code":"import { ToInteger, defaultCompareFunction } from \"./spec\";\nimport { isStringNumberKey, isArrayBuffer } from \"./is\";\nimport { createPrivateStorage } from \"./private\";\nimport memoize from \"lodash-es/memoize\";\nimport { roundToFloat16Bits, convertToNumber } from \"./lib\";\nimport { isTypedArrayIndexedPropertyWritable } from \"./bug\";\n\nconst _ = createPrivateStorage();\n\nfunction isFloat16Array(target) {\n  return target instanceof Float16Array;\n}\n\nfunction assertFloat16Array(target) {\n  if (!isFloat16Array(target)) {\n    throw new TypeError(\"This is not a Float16Array\");\n  }\n}\n\nfunction isDefaultFloat16ArrayMethods(target) {\n  return typeof target === \"function\" && defaultFloat16ArrayMethods.has(target);\n}\n\nfunction copyToArray(float16bits) {\n  const length = float16bits.length;\n  const array = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    array[i] = convertToNumber(float16bits[i]);\n  }\n\n  return array;\n} // proxy handler\n\n\nconst applyHandler = {\n  apply(func, thisArg, args) {\n    // peel off proxy\n    if (isFloat16Array(thisArg) && isDefaultFloat16ArrayMethods(func)) return Reflect.apply(func, _(thisArg).target, args);\n    return Reflect.apply(func, thisArg, args);\n  }\n\n};\nconst handler = {\n  get(target, key) {\n    let wrapper = null;\n\n    if (!isTypedArrayIndexedPropertyWritable) {\n      wrapper = target;\n      target = _(wrapper).target;\n    }\n\n    if (isStringNumberKey(key)) {\n      return Reflect.has(target, key) ? convertToNumber(Reflect.get(target, key)) : undefined;\n    } else {\n      const ret = wrapper !== null && Reflect.has(wrapper, key) ? Reflect.get(wrapper, key) : Reflect.get(target, key);\n      if (typeof ret !== \"function\") return ret; // TypedArray methods can't be called by Proxy Object\n\n      let proxy = _(ret).proxy;\n\n      if (proxy === undefined) {\n        proxy = _(ret).proxy = new Proxy(ret, applyHandler);\n      }\n\n      return proxy;\n    }\n  },\n\n  set(target, key, value) {\n    let wrapper = null;\n\n    if (!isTypedArrayIndexedPropertyWritable) {\n      wrapper = target;\n      target = _(wrapper).target;\n    }\n\n    if (isStringNumberKey(key)) {\n      return Reflect.set(target, key, roundToFloat16Bits(value));\n    } else {\n      // frozen object can't change prototype property\n      if (wrapper !== null && (!Reflect.has(target, key) || Object.isFrozen(wrapper))) {\n        return Reflect.set(wrapper, key, value);\n      } else {\n        return Reflect.set(target, key, value);\n      }\n    }\n  }\n\n};\n\nif (!isTypedArrayIndexedPropertyWritable) {\n  handler.getPrototypeOf = wrapper => Reflect.getPrototypeOf(_(wrapper).target);\n\n  handler.setPrototypeOf = (wrapper, prototype) => Reflect.setPrototypeOf(_(wrapper).target, prototype);\n\n  handler.defineProperty = (wrapper, key, descriptor) => {\n    const target = _(wrapper).target;\n\n    return !Reflect.has(target, key) || Object.isFrozen(wrapper) ? Reflect.defineProperty(wrapper, key, descriptor) : Reflect.defineProperty(target, key, descriptor);\n  };\n\n  handler.deleteProperty = (wrapper, key) => {\n    const target = _(wrapper).target;\n\n    return Reflect.has(wrapper, key) ? Reflect.deleteProperty(wrapper, key) : Reflect.deleteProperty(target, key);\n  };\n\n  handler.has = (wrapper, key) => Reflect.has(wrapper, key) || Reflect.has(_(wrapper).target, key);\n\n  handler.isExtensible = wrapper => Reflect.isExtensible(wrapper);\n\n  handler.preventExtensions = wrapper => Reflect.preventExtensions(wrapper);\n\n  handler.getOwnPropertyDescriptor = (wrapper, key) => Reflect.getOwnPropertyDescriptor(wrapper, key);\n\n  handler.ownKeys = wrapper => Reflect.ownKeys(wrapper);\n}\n\nexport default class Float16Array extends Uint16Array {\n  constructor(input, byteOffset, length) {\n    // input Float16Array\n    if (isFloat16Array(input)) {\n      super(_(input).target); // 22.2.1.3, 22.2.1.4 TypedArray, Array, ArrayLike, Iterable\n    } else if (input !== null && typeof input === \"object\" && !isArrayBuffer(input)) {\n      // if input is not ArrayLike and Iterable, get Array\n      const arrayLike = !Reflect.has(input, \"length\") && input[Symbol.iterator] !== undefined ? [...input] : input;\n      const length = arrayLike.length;\n      super(length);\n\n      for (let i = 0; i < length; ++i) {\n        // super (Uint16Array)\n        this[i] = roundToFloat16Bits(arrayLike[i]);\n      } // 22.2.1.2, 22.2.1.5 primitive, ArrayBuffer\n\n    } else {\n      switch (arguments.length) {\n        case 0:\n          super();\n          break;\n\n        case 1:\n          super(input);\n          break;\n\n        case 2:\n          super(input, byteOffset);\n          break;\n\n        case 3:\n          super(input, byteOffset, length);\n          break;\n\n        default:\n          super(...arguments);\n      }\n    }\n\n    let proxy;\n\n    if (isTypedArrayIndexedPropertyWritable) {\n      proxy = new Proxy(this, handler);\n    } else {\n      const wrapper = Object.create(null);\n      _(wrapper).target = this;\n      proxy = new Proxy(wrapper, handler);\n    } // proxy private storage\n\n\n    _(proxy).target = this; // this private storage\n\n    _(this).proxy = proxy;\n    return proxy;\n  } // static methods\n\n\n  static from(src, ...opts) {\n    if (opts.length === 0) return new Float16Array(Uint16Array.from(src, roundToFloat16Bits).buffer);\n    const mapFunc = opts[0];\n    const thisArg = opts[1];\n    return new Float16Array(Uint16Array.from(src, function (val, ...args) {\n      return roundToFloat16Bits(mapFunc.call(this, val, ...args));\n    }, thisArg).buffer);\n  }\n\n  static of(...args) {\n    return new Float16Array(args);\n  } // iterate methods\n\n\n  *[Symbol.iterator]() {\n    for (const val of super[Symbol.iterator]()) {\n      yield convertToNumber(val);\n    }\n  }\n\n  keys() {\n    return super.keys();\n  }\n\n  *values() {\n    for (const val of super.values()) {\n      yield convertToNumber(val);\n    }\n  }\n\n  *entries() {\n    for (const [i, val] of super.entries()) {\n      yield [i, convertToNumber(val)];\n    }\n  } // functional methods\n\n\n  map(callback, ...opts) {\n    assertFloat16Array(this);\n    const thisArg = opts[0];\n    const array = [];\n\n    for (let i = 0, l = this.length; i < l; ++i) {\n      const val = convertToNumber(this[i]);\n      array.push(callback.call(thisArg, val, i, _(this).proxy));\n    }\n\n    return new Float16Array(array);\n  }\n\n  filter(callback, ...opts) {\n    assertFloat16Array(this);\n    const thisArg = opts[0];\n    const array = [];\n\n    for (let i = 0, l = this.length; i < l; ++i) {\n      const val = convertToNumber(this[i]);\n\n      if (callback.call(thisArg, val, i, _(this).proxy)) {\n        array.push(val);\n      }\n    }\n\n    return new Float16Array(array);\n  }\n\n  reduce(callback, ...opts) {\n    assertFloat16Array(this);\n    let val, start;\n\n    if (opts.length === 0) {\n      val = convertToNumber(this[0]);\n      start = 1;\n    } else {\n      val = opts[0];\n      start = 0;\n    }\n\n    for (let i = start, l = this.length; i < l; ++i) {\n      val = callback(val, convertToNumber(this[i]), i, _(this).proxy);\n    }\n\n    return val;\n  }\n\n  reduceRight(callback, ...opts) {\n    assertFloat16Array(this);\n    let val, start;\n    const length = this.length;\n\n    if (opts.length === 0) {\n      val = convertToNumber(this[length - 1]);\n      start = length - 1;\n    } else {\n      val = opts[0];\n      start = length;\n    }\n\n    for (let i = start; i--;) {\n      val = callback(val, convertToNumber(this[i]), i, _(this).proxy);\n    }\n\n    return val;\n  }\n\n  forEach(callback, ...opts) {\n    assertFloat16Array(this);\n    const thisArg = opts[0];\n\n    for (let i = 0, l = this.length; i < l; ++i) {\n      callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy);\n    }\n  }\n\n  find(callback, ...opts) {\n    assertFloat16Array(this);\n    const thisArg = opts[0];\n\n    for (let i = 0, l = this.length; i < l; ++i) {\n      const value = convertToNumber(this[i]);\n      if (callback.call(thisArg, value, i, _(this).proxy)) return value;\n    }\n  }\n\n  findIndex(callback, ...opts) {\n    assertFloat16Array(this);\n    const thisArg = opts[0];\n\n    for (let i = 0, l = this.length; i < l; ++i) {\n      const value = convertToNumber(this[i]);\n      if (callback.call(thisArg, value, i, _(this).proxy)) return i;\n    }\n\n    return -1;\n  }\n\n  every(callback, ...opts) {\n    assertFloat16Array(this);\n    const thisArg = opts[0];\n\n    for (let i = 0, l = this.length; i < l; ++i) {\n      if (!callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy)) return false;\n    }\n\n    return true;\n  }\n\n  some(callback, ...opts) {\n    assertFloat16Array(this);\n    const thisArg = opts[0];\n\n    for (let i = 0, l = this.length; i < l; ++i) {\n      if (callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy)) return true;\n    }\n\n    return false;\n  } // change element methods\n\n\n  set(input, ...opts) {\n    assertFloat16Array(this);\n    const offset = opts[0];\n    let float16bits; // input Float16Array\n\n    if (isFloat16Array(input)) {\n      float16bits = _(input).target; // input others\n    } else {\n      const arrayLike = !Reflect.has(input, \"length\") && input[Symbol.iterator] !== undefined ? [...input] : input;\n      const length = arrayLike.length;\n      float16bits = new Uint16Array(length);\n\n      for (let i = 0, l = arrayLike.length; i < l; ++i) {\n        float16bits[i] = roundToFloat16Bits(arrayLike[i]);\n      }\n    }\n\n    super.set(float16bits, offset);\n  }\n\n  reverse() {\n    assertFloat16Array(this);\n    super.reverse();\n    return _(this).proxy;\n  }\n\n  fill(value, ...opts) {\n    assertFloat16Array(this);\n    super.fill(roundToFloat16Bits(value), ...opts);\n    return _(this).proxy;\n  }\n\n  copyWithin(target, start, ...opts) {\n    assertFloat16Array(this);\n    super.copyWithin(target, start, ...opts);\n    return _(this).proxy;\n  }\n\n  sort(...opts) {\n    assertFloat16Array(this);\n    let compareFunction = opts[0];\n\n    if (compareFunction === undefined) {\n      compareFunction = defaultCompareFunction;\n    }\n\n    const _convertToNumber = memoize(convertToNumber);\n\n    super.sort((x, y) => compareFunction(_convertToNumber(x), _convertToNumber(y)));\n    return _(this).proxy;\n  } // copy element methods\n\n\n  slice(...opts) {\n    assertFloat16Array(this);\n    let float16bits; // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError\n\n    try {\n      float16bits = super.slice(...opts);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);\n        float16bits = uint16.slice(...opts);\n      } else {\n        throw e;\n      }\n    }\n\n    return new Float16Array(float16bits.buffer);\n  }\n\n  subarray(...opts) {\n    assertFloat16Array(this);\n    let float16bits; // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError\n\n    try {\n      float16bits = super.subarray(...opts);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);\n        float16bits = uint16.subarray(...opts);\n      } else {\n        throw e;\n      }\n    }\n\n    return new Float16Array(float16bits.buffer, float16bits.byteOffset, float16bits.length);\n  } // contains methods\n\n\n  indexOf(element, ...opts) {\n    assertFloat16Array(this);\n    const length = this.length;\n    let from = ToInteger(opts[0]);\n\n    if (from < 0) {\n      from += length;\n      if (from < 0) from = 0;\n    }\n\n    for (let i = from, l = length; i < l; ++i) {\n      if (convertToNumber(this[i]) === element) return i;\n    }\n\n    return -1;\n  }\n\n  lastIndexOf(element, ...opts) {\n    assertFloat16Array(this);\n    const length = this.length;\n    let from = ToInteger(opts[0]);\n    from = from === 0 ? length : from + 1;\n\n    if (from >= 0) {\n      from = from < length ? from : length;\n    } else {\n      from += length;\n    }\n\n    for (let i = from; i--;) {\n      if (convertToNumber(this[i]) === element) return i;\n    }\n\n    return -1;\n  }\n\n  includes(element, ...opts) {\n    assertFloat16Array(this);\n    const length = this.length;\n    let from = ToInteger(opts[0]);\n\n    if (from < 0) {\n      from += length;\n      if (from < 0) from = 0;\n    }\n\n    const isNaN = Number.isNaN(element);\n\n    for (let i = from, l = length; i < l; ++i) {\n      const value = convertToNumber(this[i]);\n      if (isNaN && Number.isNaN(value)) return true;\n      if (value === element) return true;\n    }\n\n    return false;\n  } // string methods\n\n\n  join(...opts) {\n    assertFloat16Array(this);\n    const array = copyToArray(this);\n    return array.join(...opts);\n  }\n\n  toLocaleString(...opts) {\n    assertFloat16Array(this);\n    const array = copyToArray(this);\n    return array.toLocaleString(...opts);\n  }\n\n  get [Symbol.toStringTag]() {\n    if (isFloat16Array(this)) return \"Float16Array\";\n  }\n\n}\nconst Float16Array$prototype = Float16Array.prototype;\nconst defaultFloat16ArrayMethods = new WeakSet();\n\nfor (const key of Reflect.ownKeys(Float16Array$prototype)) {\n  const val = Float16Array$prototype[key];\n  if (typeof val === \"function\") defaultFloat16ArrayMethods.add(val);\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@petamoriken/float16/src/Float16Array.js"],"names":["ToInteger","defaultCompareFunction","isStringNumberKey","isArrayBuffer","createPrivateStorage","memoize","roundToFloat16Bits","convertToNumber","isTypedArrayIndexedPropertyWritable","_","isFloat16Array","target","Float16Array","assertFloat16Array","TypeError","isDefaultFloat16ArrayMethods","defaultFloat16ArrayMethods","has","copyToArray","float16bits","length","array","Array","i","applyHandler","apply","func","thisArg","args","Reflect","handler","get","key","wrapper","undefined","ret","proxy","Proxy","set","value","Object","isFrozen","getPrototypeOf","setPrototypeOf","prototype","defineProperty","descriptor","deleteProperty","isExtensible","preventExtensions","getOwnPropertyDescriptor","ownKeys","Uint16Array","constructor","input","byteOffset","arrayLike","Symbol","iterator","arguments","create","from","src","opts","buffer","mapFunc","val","call","of","keys","values","entries","map","callback","l","push","filter","reduce","start","reduceRight","forEach","find","findIndex","every","some","offset","reverse","fill","copyWithin","sort","compareFunction","_convertToNumber","x","y","slice","e","uint16","subarray","indexOf","element","lastIndexOf","includes","isNaN","Number","join","toLocaleString","toStringTag","Float16Array$prototype","WeakSet","add"],"mappings":"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","sourcesContent":["import { ToInteger, defaultCompareFunction } from \"./spec\";\nimport { isStringNumberKey, isArrayBuffer } from \"./is\";\nimport { createPrivateStorage } from \"./private\";\n\nimport memoize from \"lodash-es/memoize\";\n\nimport { roundToFloat16Bits, convertToNumber } from \"./lib\";\n\nimport { isTypedArrayIndexedPropertyWritable } from \"./bug\";\n\n\nconst _ = createPrivateStorage();\n\n\nfunction isFloat16Array(target) {\n    return target instanceof Float16Array;\n}\n\nfunction assertFloat16Array(target) {\n    if(!isFloat16Array(target)) {\n        throw new TypeError(\"This is not a Float16Array\");\n    }\n}\n\nfunction isDefaultFloat16ArrayMethods(target) {\n    return typeof target === \"function\" && defaultFloat16ArrayMethods.has(target);\n}\n\n\nfunction copyToArray(float16bits) {\n    const length = float16bits.length;\n\n    const array = new Array(length);\n    for(let i = 0; i < length; ++i) {\n        array[i] = convertToNumber(float16bits[i]);\n    }\n\n    return array;\n}\n\n// proxy handler\nconst applyHandler = {\n    apply(func, thisArg, args) {\n        // peel off proxy\n        if(isFloat16Array(thisArg) && isDefaultFloat16ArrayMethods(func))\n            return Reflect.apply(func, _(thisArg).target ,args);\n\n        return Reflect.apply(func, thisArg, args);\n    }\n};\n\nconst handler = {\n    get(target, key) {\n        let wrapper = null;\n        if(!isTypedArrayIndexedPropertyWritable) {\n            wrapper = target;\n            target = _(wrapper).target;\n        }\n\n        if(isStringNumberKey(key)) {\n            return Reflect.has(target, key) ? convertToNumber(Reflect.get(target, key)) : undefined;\n\n        } else {\n            const ret = wrapper !== null && Reflect.has(wrapper, key) ? Reflect.get(wrapper, key) : Reflect.get(target, key);\n\n            if(typeof ret !== \"function\")\n                return ret;\n\n            // TypedArray methods can't be called by Proxy Object\n            let proxy = _(ret).proxy;\n\n            if(proxy === undefined) {\n                proxy = _(ret).proxy = new Proxy(ret, applyHandler);\n            }\n\n            return proxy;\n        }\n    },\n\n    set(target, key, value) {\n        let wrapper = null;\n        if(!isTypedArrayIndexedPropertyWritable) {\n            wrapper = target;\n            target = _(wrapper).target;\n        }\n\n        if(isStringNumberKey(key)) {\n            return Reflect.set(target, key, roundToFloat16Bits(value));\n\n        } else {\n            // frozen object can't change prototype property\n            if(wrapper !== null && (!Reflect.has(target, key) || Object.isFrozen(wrapper))) {\n                return Reflect.set(wrapper, key, value);\n\n            } else {\n                return Reflect.set(target, key, value);\n            }\n        }\n    }\n};\n\nif(!isTypedArrayIndexedPropertyWritable) {\n    handler.getPrototypeOf = wrapper => Reflect.getPrototypeOf(_(wrapper).target);\n    handler.setPrototypeOf = (wrapper, prototype) => Reflect.setPrototypeOf(_(wrapper).target, prototype);\n\n    handler.defineProperty = (wrapper, key, descriptor) => {\n        const target = _(wrapper).target;\n        return !Reflect.has(target, key) || Object.isFrozen(wrapper) ? Reflect.defineProperty(wrapper, key, descriptor) : Reflect.defineProperty(target, key, descriptor);\n    };\n    handler.deleteProperty = (wrapper, key) => {\n        const target = _(wrapper).target;\n        return Reflect.has(wrapper, key) ? Reflect.deleteProperty(wrapper, key) : Reflect.deleteProperty(target, key);\n    };\n\n    handler.has = (wrapper, key) => Reflect.has(wrapper, key) || Reflect.has(_(wrapper).target, key);\n\n    handler.isExtensible = wrapper => Reflect.isExtensible(wrapper);\n    handler.preventExtensions = wrapper => Reflect.preventExtensions(wrapper);\n\n    handler.getOwnPropertyDescriptor = (wrapper, key) => Reflect.getOwnPropertyDescriptor(wrapper, key);\n    handler.ownKeys = wrapper => Reflect.ownKeys(wrapper);\n}\n\n\nexport default class Float16Array extends Uint16Array {\n\n    constructor(input, byteOffset, length) {\n\n        // input Float16Array\n        if(isFloat16Array(input)) {\n            super(_(input).target);\n\n        // 22.2.1.3, 22.2.1.4 TypedArray, Array, ArrayLike, Iterable\n        } else if(input !== null && typeof input === \"object\" && !isArrayBuffer(input)) {\n            // if input is not ArrayLike and Iterable, get Array\n            const arrayLike = !Reflect.has(input, \"length\") && input[Symbol.iterator] !== undefined ? [...input] : input;\n\n            const length = arrayLike.length;\n            super(length);\n\n            for(let i = 0; i < length; ++i) {\n                // super (Uint16Array)\n                this[i] = roundToFloat16Bits(arrayLike[i]);\n            }\n\n        // 22.2.1.2, 22.2.1.5 primitive, ArrayBuffer\n        } else {\n            switch(arguments.length) {\n                case 0:\n                    super();\n                    break;\n\n                case 1:\n                    super(input);\n                    break;\n\n                case 2:\n                    super(input, byteOffset);\n                    break;\n\n                case 3:\n                    super(input, byteOffset, length);\n                    break;\n\n                default:\n                    super(...arguments);\n            }\n        }\n\n        let proxy;\n\n        if(isTypedArrayIndexedPropertyWritable) {\n            proxy = new Proxy(this, handler);\n        } else {\n            const wrapper = Object.create(null);\n            _(wrapper).target = this;\n            proxy = new Proxy(wrapper, handler);\n        }\n\n        // proxy private storage\n        _(proxy).target = this;\n\n        // this private storage\n        _(this).proxy = proxy;\n\n        return proxy;\n    }\n\n    // static methods\n    static from(src, ...opts) {\n        if(opts.length === 0)\n            return new Float16Array(Uint16Array.from(src, roundToFloat16Bits).buffer);\n\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n\n        return new Float16Array(Uint16Array.from(src, function(val, ...args) {\n            return roundToFloat16Bits(mapFunc.call(this, val, ...args));\n        }, thisArg).buffer);\n    }\n\n    static of(...args) {\n        return new Float16Array(args);\n    }\n\n    // iterate methods\n    * [Symbol.iterator]() {\n        for(const val of super[Symbol.iterator]()) {\n            yield convertToNumber(val);\n        }\n    }\n\n    keys() {\n        return super.keys();\n    }\n\n    * values() {\n        for(const val of super.values()) {\n            yield convertToNumber(val);\n        }\n    }\n\n    * entries() {\n        for(const [i, val] of super.entries()) {\n            yield [i, convertToNumber(val)];\n        }\n    }\n\n    // functional methods\n    map(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        const array = [];\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const val = convertToNumber(this[i]);\n            array.push(callback.call(thisArg, val, i, _(this).proxy));\n        }\n\n        return new Float16Array(array);\n    }\n\n    filter(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        const array = [];\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const val = convertToNumber(this[i]);\n            if(callback.call(thisArg, val, i, _(this).proxy)) {\n                array.push(val);\n            }\n        }\n\n        return new Float16Array(array);\n    }\n\n    reduce(callback, ...opts) {\n        assertFloat16Array(this);\n\n        let val, start;\n\n        if(opts.length === 0) {\n            val = convertToNumber(this[0]);\n            start = 1;\n        } else {\n            val = opts[0];\n            start = 0;\n        }\n\n        for(let i = start, l = this.length; i < l; ++i) {\n            val = callback(val, convertToNumber(this[i]), i, _(this).proxy);\n        }\n\n        return val;\n    }\n\n    reduceRight(callback, ...opts) {\n        assertFloat16Array(this);\n\n        let val, start;\n\n        const length = this.length;\n        if(opts.length === 0) {\n            val = convertToNumber(this[length - 1]);\n            start = length - 1;\n        } else {\n            val = opts[0];\n            start = length;\n        }\n\n        for(let i = start; i--;) {\n            val = callback(val, convertToNumber(this[i]), i, _(this).proxy);\n        }\n\n        return val;\n    }\n\n    forEach(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy);\n        }\n    }\n\n    find(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const value = convertToNumber(this[i]);\n            if(callback.call(thisArg, value, i, _(this).proxy)) return value;\n        }\n    }\n\n    findIndex(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const value = convertToNumber(this[i]);\n            if(callback.call(thisArg, value, i, _(this).proxy)) return i;\n        }\n\n        return -1;\n    }\n\n    every(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            if(!callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy)) return false;\n        }\n\n        return true;\n    }\n\n    some(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            if(callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy)) return true;\n        }\n\n        return false;\n    }\n\n    // change element methods\n    set(input, ...opts) {\n        assertFloat16Array(this);\n\n        const offset = opts[0];\n\n        let float16bits;\n\n        // input Float16Array\n        if(isFloat16Array(input)) {\n            float16bits = _(input).target;\n\n        // input others\n        } else {\n            const arrayLike = !Reflect.has(input, \"length\") && input[Symbol.iterator] !== undefined ? [...input] : input;\n            const length = arrayLike.length;\n\n            float16bits = new Uint16Array(length);\n            for(let i = 0, l = arrayLike.length; i < l; ++i) {\n                float16bits[i] = roundToFloat16Bits(arrayLike[i]);\n            }\n        }\n\n        super.set(float16bits, offset);\n    }\n\n    reverse() {\n        assertFloat16Array(this);\n\n        super.reverse();\n\n        return _(this).proxy;\n    }\n\n    fill(value, ...opts) {\n        assertFloat16Array(this);\n\n        super.fill(roundToFloat16Bits(value), ...opts);\n\n        return _(this).proxy;\n    }\n\n    copyWithin(target, start, ...opts) {\n        assertFloat16Array(this);\n\n        super.copyWithin(target, start, ...opts);\n\n        return _(this).proxy;\n    }\n\n    sort(...opts) {\n        assertFloat16Array(this);\n\n        let compareFunction = opts[0];\n\n        if(compareFunction === undefined) {\n            compareFunction = defaultCompareFunction;\n        }\n\n        const _convertToNumber = memoize(convertToNumber);\n\n        super.sort((x, y) => compareFunction(_convertToNumber(x), _convertToNumber(y)));\n\n        return _(this).proxy;\n    }\n\n    // copy element methods\n    slice(...opts) {\n        assertFloat16Array(this);\n\n        let float16bits;\n\n        // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError\n        try {\n            float16bits = super.slice(...opts);\n        } catch(e) {\n            if(e instanceof TypeError) {\n                const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);\n                float16bits = uint16.slice(...opts);\n            } else {\n                throw e;\n            }\n        }\n\n        return new Float16Array(float16bits.buffer);\n    }\n\n    subarray(...opts) {\n        assertFloat16Array(this);\n\n        let float16bits;\n\n        // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError\n        try {\n            float16bits = super.subarray(...opts);\n        } catch(e) {\n            if(e instanceof TypeError) {\n                const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);\n                float16bits = uint16.subarray(...opts);\n            } else {\n                throw e;\n            }\n        }\n\n        return new Float16Array(float16bits.buffer, float16bits.byteOffset, float16bits.length);\n    }\n\n    // contains methods\n    indexOf(element, ...opts) {\n        assertFloat16Array(this);\n\n        const length = this.length;\n\n        let from = ToInteger(opts[0]);\n\n        if(from < 0) {\n            from += length;\n            if(from < 0)\n                from = 0;\n        }\n\n        for(let i = from, l = length; i < l; ++i) {\n            if(convertToNumber(this[i]) === element)\n                return i;\n        }\n\n        return -1;\n    }\n\n    lastIndexOf(element, ...opts) {\n        assertFloat16Array(this);\n\n        const length = this.length;\n\n        let from = ToInteger(opts[0]);\n\n        from = from === 0 ? length : from + 1;\n\n        if(from >= 0) {\n            from = from < length ? from : length;\n        } else {\n            from += length;\n        }\n\n        for(let i = from; i--;) {\n            if(convertToNumber(this[i]) === element)\n                return i;\n        }\n\n        return -1;\n    }\n\n    includes(element, ...opts) {\n        assertFloat16Array(this);\n\n        const length = this.length;\n\n        let from = ToInteger(opts[0]);\n\n        if(from < 0) {\n            from += length;\n            if(from < 0)\n                from = 0;\n        }\n\n        const isNaN = Number.isNaN(element);\n        for(let i = from, l = length; i < l; ++i) {\n            const value = convertToNumber(this[i]);\n\n            if(isNaN && Number.isNaN(value))\n                return true;\n\n            if(value === element)\n                return true;\n        }\n\n        return false;\n    }\n\n    // string methods\n    join(...opts) {\n        assertFloat16Array(this);\n\n        const array = copyToArray(this);\n\n        return array.join(...opts);\n    }\n\n    toLocaleString(...opts) {\n        assertFloat16Array(this);\n\n        const array = copyToArray(this);\n\n        return array.toLocaleString(...opts);\n    }\n\n    get [Symbol.toStringTag]() {\n        if(isFloat16Array(this))\n            return \"Float16Array\";\n    }\n}\n\nconst Float16Array$prototype = Float16Array.prototype;\n\nconst defaultFloat16ArrayMethods = new WeakSet();\nfor(const key of Reflect.ownKeys(Float16Array$prototype)) {\n    const val = Float16Array$prototype[key];\n    if(typeof val === \"function\")\n        defaultFloat16ArrayMethods.add(val);\n}\n"]},"metadata":{},"sourceType":"module"}