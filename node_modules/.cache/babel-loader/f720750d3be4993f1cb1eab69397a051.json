{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport isSomeObservable from \"is-observable\";\nimport { deserialize, serialize } from \"../common\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nimport Implementation from \"./implementation\";\nexport { registerSerializer } from \"../common\";\nexport { Transfer } from \"../transferable\";\n/** Returns `true` if this code is currently running in a worker. */\n\nexport var isWorkerRuntime = Implementation.isWorkerRuntime;\nvar exposeCalled = false;\nvar activeSubscriptions = new Map();\n\nvar isMasterJobCancelMessage = function isMasterJobCancelMessage(thing) {\n  return thing && thing.type === MasterMessageType.cancel;\n};\n\nvar isMasterJobRunMessage = function isMasterJobRunMessage(thing) {\n  return thing && thing.type === MasterMessageType.run;\n};\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\n\n\nvar isObservable = function isObservable(thing) {\n  return isSomeObservable(thing) || isZenObservable(thing);\n};\n\nfunction isZenObservable(thing) {\n  return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\n\nfunction deconstructTransfer(thing) {\n  return isTransferDescriptor(thing) ? {\n    payload: thing.send,\n    transferables: thing.transferables\n  } : {\n    payload: thing,\n    transferables: undefined\n  };\n}\n\nfunction postFunctionInitMessage() {\n  var initMessage = {\n    type: WorkerMessageType.init,\n    exposed: {\n      type: \"function\"\n    }\n  };\n  Implementation.postMessageToMaster(initMessage);\n}\n\nfunction postModuleInitMessage(methodNames) {\n  var initMessage = {\n    type: WorkerMessageType.init,\n    exposed: {\n      type: \"module\",\n      methods: methodNames\n    }\n  };\n  Implementation.postMessageToMaster(initMessage);\n}\n\nfunction postJobErrorMessage(uid, rawError) {\n  var _deconstructTransfer = deconstructTransfer(rawError),\n      error = _deconstructTransfer.payload,\n      transferables = _deconstructTransfer.transferables;\n\n  var errorMessage = {\n    type: WorkerMessageType.error,\n    uid: uid,\n    error: serialize(error)\n  };\n  Implementation.postMessageToMaster(errorMessage, transferables);\n}\n\nfunction postJobResultMessage(uid, completed, resultValue) {\n  var _deconstructTransfer2 = deconstructTransfer(resultValue),\n      payload = _deconstructTransfer2.payload,\n      transferables = _deconstructTransfer2.transferables;\n\n  var resultMessage = {\n    type: WorkerMessageType.result,\n    uid: uid,\n    complete: completed ? true : undefined,\n    payload: payload\n  };\n  Implementation.postMessageToMaster(resultMessage, transferables);\n}\n\nfunction postJobStartMessage(uid, resultType) {\n  var startMessage = {\n    type: WorkerMessageType.running,\n    uid: uid,\n    resultType: resultType\n  };\n  Implementation.postMessageToMaster(startMessage);\n}\n\nfunction postUncaughtErrorMessage(error) {\n  try {\n    var errorMessage = {\n      type: WorkerMessageType.uncaughtError,\n      error: serialize(error)\n    };\n    Implementation.postMessageToMaster(errorMessage);\n  } catch (subError) {\n    // tslint:disable-next-line no-console\n    console.error(\"Not reporting uncaught error back to master thread as it \" + \"occured while reporting an uncaught error already.\" + \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n  }\n}\n\nfunction runFunction(jobUID, fn, args) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var syncResult, resultType, subscription, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            syncResult = fn.apply(void 0, _toConsumableArray(args));\n            _context.next = 7;\n            break;\n\n          case 4:\n            _context.prev = 4;\n            _context.t0 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", postJobErrorMessage(jobUID, _context.t0));\n\n          case 7:\n            resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n            postJobStartMessage(jobUID, resultType);\n\n            if (!isObservable(syncResult)) {\n              _context.next = 14;\n              break;\n            }\n\n            subscription = syncResult.subscribe(function (value) {\n              return postJobResultMessage(jobUID, false, serialize(value));\n            }, function (error) {\n              postJobErrorMessage(jobUID, serialize(error));\n              activeSubscriptions.delete(jobUID);\n            }, function () {\n              postJobResultMessage(jobUID, true);\n              activeSubscriptions.delete(jobUID);\n            });\n            activeSubscriptions.set(jobUID, subscription);\n            _context.next = 24;\n            break;\n\n          case 14:\n            _context.prev = 14;\n            _context.next = 17;\n            return syncResult;\n\n          case 17:\n            result = _context.sent;\n            postJobResultMessage(jobUID, true, serialize(result));\n            _context.next = 24;\n            break;\n\n          case 21:\n            _context.prev = 21;\n            _context.t1 = _context[\"catch\"](14);\n            postJobErrorMessage(jobUID, serialize(_context.t1));\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 4], [14, 21]]);\n  }));\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\n\n\nexport function expose(exposed) {\n  if (!Implementation.isWorkerRuntime()) {\n    throw Error(\"expose() called in the master thread.\");\n  }\n\n  if (exposeCalled) {\n    throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n  }\n\n  exposeCalled = true;\n\n  if (typeof exposed === \"function\") {\n    Implementation.subscribeToMasterMessages(function (messageData) {\n      if (isMasterJobRunMessage(messageData) && !messageData.method) {\n        runFunction(messageData.uid, exposed, messageData.args.map(deserialize));\n      }\n    });\n    postFunctionInitMessage();\n  } else if (typeof exposed === \"object\" && exposed) {\n    Implementation.subscribeToMasterMessages(function (messageData) {\n      if (isMasterJobRunMessage(messageData) && messageData.method) {\n        runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(deserialize));\n      }\n    });\n    var methodNames = Object.keys(exposed).filter(function (key) {\n      return typeof exposed[key] === \"function\";\n    });\n    postModuleInitMessage(methodNames);\n  } else {\n    throw Error(\"Invalid argument passed to expose(). Expected a function or an object, got: \".concat(exposed));\n  }\n\n  Implementation.subscribeToMasterMessages(function (messageData) {\n    if (isMasterJobCancelMessage(messageData)) {\n      var jobUID = messageData.uid;\n      var subscription = activeSubscriptions.get(jobUID);\n\n      if (subscription) {\n        subscription.unsubscribe();\n        activeSubscriptions.delete(jobUID);\n      }\n    }\n  });\n}\n\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && Implementation.isWorkerRuntime()) {\n  self.addEventListener(\"error\", function (event) {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(function () {\n      return postUncaughtErrorMessage(event.error || event);\n    }, 250);\n  });\n  self.addEventListener(\"unhandledrejection\", function (event) {\n    var error = event.reason;\n\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(function () {\n        return postUncaughtErrorMessage(error);\n      }, 250);\n    }\n  });\n}\n\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && Implementation.isWorkerRuntime()) {\n  process.on(\"uncaughtException\", function (error) {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(function () {\n      return postUncaughtErrorMessage(error);\n    }, 250);\n  });\n  process.on(\"unhandledRejection\", function (error) {\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(function () {\n        return postUncaughtErrorMessage(error);\n      }, 250);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/worker/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","isSomeObservable","deserialize","serialize","isTransferDescriptor","MasterMessageType","WorkerMessageType","Implementation","registerSerializer","Transfer","isWorkerRuntime","exposeCalled","activeSubscriptions","Map","isMasterJobCancelMessage","thing","type","cancel","isMasterJobRunMessage","run","isObservable","isZenObservable","subscribe","deconstructTransfer","payload","send","transferables","undefined","postFunctionInitMessage","initMessage","init","exposed","postMessageToMaster","postModuleInitMessage","methodNames","methods","postJobErrorMessage","uid","rawError","error","errorMessage","postJobResultMessage","completed","resultValue","resultMessage","complete","postJobStartMessage","resultType","startMessage","running","postUncaughtErrorMessage","uncaughtError","subError","console","runFunction","jobUID","fn","args","syncResult","subscription","delete","set","expose","Error","subscribeToMasterMessages","messageData","method","map","Object","keys","filter","key","get","unsubscribe","self","addEventListener","event","setTimeout","reason","message","process","on"],"mappings":";;;AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASA,OAAOO,gBAAP,MAA6B,eAA7B;AACA,SAASC,WAAT,EAAsBC,SAAtB,QAAuC,WAAvC;AACA,SAASC,oBAAT,QAAqC,iBAArC;AACA,SAASC,iBAAT,EAA4BC,iBAA5B,QAAqD,mBAArD;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,SAASC,kBAAT,QAAmC,WAAnC;AACA,SAASC,QAAT,QAAyB,iBAAzB;AACA;;AACA,OAAO,IAAMC,eAAe,GAAGH,cAAc,CAACG,eAAvC;AACP,IAAIC,YAAY,GAAG,KAAnB;AACA,IAAMC,mBAAmB,GAAG,IAAIC,GAAJ,EAA5B;;AACA,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACC,KAAD;AAAA,SAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeX,iBAAiB,CAACY,MAArD;AAAA,CAAjC;;AACA,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACH,KAAD;AAAA,SAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeX,iBAAiB,CAACc,GAArD;AAAA,CAA9B;AACA;;;;;;AAIA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACL,KAAD;AAAA,SAAWd,gBAAgB,CAACc,KAAD,CAAhB,IAA2BM,eAAe,CAACN,KAAD,CAArD;AAAA,CAArB;;AACA,SAASM,eAAT,CAAyBN,KAAzB,EAAgC;AAC5B,SAAOA,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA1B,IAAsC,OAAOA,KAAK,CAACO,SAAb,KAA2B,UAAxE;AACH;;AACD,SAASC,mBAAT,CAA6BR,KAA7B,EAAoC;AAChC,SAAOX,oBAAoB,CAACW,KAAD,CAApB,GACD;AAAES,IAAAA,OAAO,EAAET,KAAK,CAACU,IAAjB;AAAuBC,IAAAA,aAAa,EAAEX,KAAK,CAACW;AAA5C,GADC,GAED;AAAEF,IAAAA,OAAO,EAAET,KAAX;AAAkBW,IAAAA,aAAa,EAAEC;AAAjC,GAFN;AAGH;;AACD,SAASC,uBAAT,GAAmC;AAC/B,MAAMC,WAAW,GAAG;AAChBb,IAAAA,IAAI,EAAEV,iBAAiB,CAACwB,IADR;AAEhBC,IAAAA,OAAO,EAAE;AACLf,MAAAA,IAAI,EAAE;AADD;AAFO,GAApB;AAMAT,EAAAA,cAAc,CAACyB,mBAAf,CAAmCH,WAAnC;AACH;;AACD,SAASI,qBAAT,CAA+BC,WAA/B,EAA4C;AACxC,MAAML,WAAW,GAAG;AAChBb,IAAAA,IAAI,EAAEV,iBAAiB,CAACwB,IADR;AAEhBC,IAAAA,OAAO,EAAE;AACLf,MAAAA,IAAI,EAAE,QADD;AAELmB,MAAAA,OAAO,EAAED;AAFJ;AAFO,GAApB;AAOA3B,EAAAA,cAAc,CAACyB,mBAAf,CAAmCH,WAAnC;AACH;;AACD,SAASO,mBAAT,CAA6BC,GAA7B,EAAkCC,QAAlC,EAA4C;AAAA,6BACEf,mBAAmB,CAACe,QAAD,CADrB;AAAA,MACvBC,KADuB,wBAChCf,OADgC;AAAA,MAChBE,aADgB,wBAChBA,aADgB;;AAExC,MAAMc,YAAY,GAAG;AACjBxB,IAAAA,IAAI,EAAEV,iBAAiB,CAACiC,KADP;AAEjBF,IAAAA,GAAG,EAAHA,GAFiB;AAGjBE,IAAAA,KAAK,EAAEpC,SAAS,CAACoC,KAAD;AAHC,GAArB;AAKAhC,EAAAA,cAAc,CAACyB,mBAAf,CAAmCQ,YAAnC,EAAiDd,aAAjD;AACH;;AACD,SAASe,oBAAT,CAA8BJ,GAA9B,EAAmCK,SAAnC,EAA8CC,WAA9C,EAA2D;AAAA,8BACpBpB,mBAAmB,CAACoB,WAAD,CADC;AAAA,MAC/CnB,OAD+C,yBAC/CA,OAD+C;AAAA,MACtCE,aADsC,yBACtCA,aADsC;;AAEvD,MAAMkB,aAAa,GAAG;AAClB5B,IAAAA,IAAI,EAAEV,iBAAiB,CAACT,MADN;AAElBwC,IAAAA,GAAG,EAAHA,GAFkB;AAGlBQ,IAAAA,QAAQ,EAAEH,SAAS,GAAG,IAAH,GAAUf,SAHX;AAIlBH,IAAAA,OAAO,EAAPA;AAJkB,GAAtB;AAMAjB,EAAAA,cAAc,CAACyB,mBAAf,CAAmCY,aAAnC,EAAkDlB,aAAlD;AACH;;AACD,SAASoB,mBAAT,CAA6BT,GAA7B,EAAkCU,UAAlC,EAA8C;AAC1C,MAAMC,YAAY,GAAG;AACjBhC,IAAAA,IAAI,EAAEV,iBAAiB,CAAC2C,OADP;AAEjBZ,IAAAA,GAAG,EAAHA,GAFiB;AAGjBU,IAAAA,UAAU,EAAVA;AAHiB,GAArB;AAKAxC,EAAAA,cAAc,CAACyB,mBAAf,CAAmCgB,YAAnC;AACH;;AACD,SAASE,wBAAT,CAAkCX,KAAlC,EAAyC;AACrC,MAAI;AACA,QAAMC,YAAY,GAAG;AACjBxB,MAAAA,IAAI,EAAEV,iBAAiB,CAAC6C,aADP;AAEjBZ,MAAAA,KAAK,EAAEpC,SAAS,CAACoC,KAAD;AAFC,KAArB;AAIAhC,IAAAA,cAAc,CAACyB,mBAAf,CAAmCQ,YAAnC;AACH,GAND,CAOA,OAAOY,QAAP,EAAiB;AACb;AACAC,IAAAA,OAAO,CAACd,KAAR,CAAc,8DACV,oDADU,GAEV,iBAFJ,EAEuBa,QAFvB,EAEiC,mBAFjC,EAEsDb,KAFtD;AAGH;AACJ;;AACD,SAASe,WAAT,CAAqBC,MAArB,EAA6BC,EAA7B,EAAiCC,IAAjC,EAAuC;AACnC,SAAO3E,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAG/B4E,YAAAA,UAAU,GAAGF,EAAE,MAAF,4BAAMC,IAAN,EAAb;AAH+B;AAAA;;AAAA;AAAA;AAAA;AAAA,6CAMxBrB,mBAAmB,CAACmB,MAAD,cANK;;AAAA;AAQ7BR,YAAAA,UAR6B,GAQhB3B,YAAY,CAACsC,UAAD,CAAZ,GAA2B,YAA3B,GAA0C,SAR1B;AASnCZ,YAAAA,mBAAmB,CAACS,MAAD,EAASR,UAAT,CAAnB;;AATmC,iBAU/B3B,YAAY,CAACsC,UAAD,CAVmB;AAAA;AAAA;AAAA;;AAWzBC,YAAAA,YAXyB,GAWVD,UAAU,CAACpC,SAAX,CAAqB,UAAAlC,KAAK;AAAA,qBAAIqD,oBAAoB,CAACc,MAAD,EAAS,KAAT,EAAgBpD,SAAS,CAACf,KAAD,CAAzB,CAAxB;AAAA,aAA1B,EAAqF,UAAAmD,KAAK,EAAI;AAC/GH,cAAAA,mBAAmB,CAACmB,MAAD,EAASpD,SAAS,CAACoC,KAAD,CAAlB,CAAnB;AACA3B,cAAAA,mBAAmB,CAACgD,MAApB,CAA2BL,MAA3B;AACH,aAHoB,EAGlB,YAAM;AACLd,cAAAA,oBAAoB,CAACc,MAAD,EAAS,IAAT,CAApB;AACA3C,cAAAA,mBAAmB,CAACgD,MAApB,CAA2BL,MAA3B;AACH,aANoB,CAXU;AAkB/B3C,YAAAA,mBAAmB,CAACiD,GAApB,CAAwBN,MAAxB,EAAgCI,YAAhC;AAlB+B;AAAA;;AAAA;AAAA;AAAA;AAsBZ,mBAAMD,UAAN;;AAtBY;AAsBrB7D,YAAAA,MAtBqB;AAuB3B4C,YAAAA,oBAAoB,CAACc,MAAD,EAAS,IAAT,EAAepD,SAAS,CAACN,MAAD,CAAxB,CAApB;AAvB2B;AAAA;;AAAA;AAAA;AAAA;AA0B3BuC,YAAAA,mBAAmB,CAACmB,MAAD,EAASpD,SAAS,aAAlB,CAAnB;;AA1B2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAvB,EAAhB;AA8BH;AACD;;;;;;;;;AAOA,OAAO,SAAS2D,MAAT,CAAgB/B,OAAhB,EAAyB;AAC5B,MAAI,CAACxB,cAAc,CAACG,eAAf,EAAL,EAAuC;AACnC,UAAMqD,KAAK,CAAC,uCAAD,CAAX;AACH;;AACD,MAAIpD,YAAJ,EAAkB;AACd,UAAMoD,KAAK,CAAC,4HAAD,CAAX;AACH;;AACDpD,EAAAA,YAAY,GAAG,IAAf;;AACA,MAAI,OAAOoB,OAAP,KAAmB,UAAvB,EAAmC;AAC/BxB,IAAAA,cAAc,CAACyD,yBAAf,CAAyC,UAAAC,WAAW,EAAI;AACpD,UAAI/C,qBAAqB,CAAC+C,WAAD,CAArB,IAAsC,CAACA,WAAW,CAACC,MAAvD,EAA+D;AAC3DZ,QAAAA,WAAW,CAACW,WAAW,CAAC5B,GAAb,EAAkBN,OAAlB,EAA2BkC,WAAW,CAACR,IAAZ,CAAiBU,GAAjB,CAAqBjE,WAArB,CAA3B,CAAX;AACH;AACJ,KAJD;AAKA0B,IAAAA,uBAAuB;AAC1B,GAPD,MAQK,IAAI,OAAOG,OAAP,KAAmB,QAAnB,IAA+BA,OAAnC,EAA4C;AAC7CxB,IAAAA,cAAc,CAACyD,yBAAf,CAAyC,UAAAC,WAAW,EAAI;AACpD,UAAI/C,qBAAqB,CAAC+C,WAAD,CAArB,IAAsCA,WAAW,CAACC,MAAtD,EAA8D;AAC1DZ,QAAAA,WAAW,CAACW,WAAW,CAAC5B,GAAb,EAAkBN,OAAO,CAACkC,WAAW,CAACC,MAAb,CAAzB,EAA+CD,WAAW,CAACR,IAAZ,CAAiBU,GAAjB,CAAqBjE,WAArB,CAA/C,CAAX;AACH;AACJ,KAJD;AAKA,QAAMgC,WAAW,GAAGkC,MAAM,CAACC,IAAP,CAAYtC,OAAZ,EAAqBuC,MAArB,CAA4B,UAAAC,GAAG;AAAA,aAAI,OAAOxC,OAAO,CAACwC,GAAD,CAAd,KAAwB,UAA5B;AAAA,KAA/B,CAApB;AACAtC,IAAAA,qBAAqB,CAACC,WAAD,CAArB;AACH,GARI,MASA;AACD,UAAM6B,KAAK,uFAAgFhC,OAAhF,EAAX;AACH;;AACDxB,EAAAA,cAAc,CAACyD,yBAAf,CAAyC,UAAAC,WAAW,EAAI;AACpD,QAAInD,wBAAwB,CAACmD,WAAD,CAA5B,EAA2C;AACvC,UAAMV,MAAM,GAAGU,WAAW,CAAC5B,GAA3B;AACA,UAAMsB,YAAY,GAAG/C,mBAAmB,CAAC4D,GAApB,CAAwBjB,MAAxB,CAArB;;AACA,UAAII,YAAJ,EAAkB;AACdA,QAAAA,YAAY,CAACc,WAAb;AACA7D,QAAAA,mBAAmB,CAACgD,MAApB,CAA2BL,MAA3B;AACH;AACJ;AACJ,GATD;AAUH;;AACD,IAAI,OAAOmB,IAAP,KAAgB,WAAhB,IAA+B,OAAOA,IAAI,CAACC,gBAAZ,KAAiC,UAAhE,IAA8EpE,cAAc,CAACG,eAAf,EAAlF,EAAoH;AAChHgE,EAAAA,IAAI,CAACC,gBAAL,CAAsB,OAAtB,EAA+B,UAAAC,KAAK,EAAI;AACpC;AACAC,IAAAA,UAAU,CAAC;AAAA,aAAM3B,wBAAwB,CAAC0B,KAAK,CAACrC,KAAN,IAAeqC,KAAhB,CAA9B;AAAA,KAAD,EAAuD,GAAvD,CAAV;AACH,GAHD;AAIAF,EAAAA,IAAI,CAACC,gBAAL,CAAsB,oBAAtB,EAA4C,UAAAC,KAAK,EAAI;AACjD,QAAMrC,KAAK,GAAGqC,KAAK,CAACE,MAApB;;AACA,QAAIvC,KAAK,IAAI,OAAOA,KAAK,CAACwC,OAAb,KAAyB,QAAtC,EAAgD;AAC5C;AACAF,MAAAA,UAAU,CAAC;AAAA,eAAM3B,wBAAwB,CAACX,KAAD,CAA9B;AAAA,OAAD,EAAwC,GAAxC,CAAV;AACH;AACJ,GAND;AAOH;;AACD,IAAI,OAAOyC,OAAP,KAAmB,WAAnB,IAAkC,OAAOA,OAAO,CAACC,EAAf,KAAsB,UAAxD,IAAsE1E,cAAc,CAACG,eAAf,EAA1E,EAA4G;AACxGsE,EAAAA,OAAO,CAACC,EAAR,CAAW,mBAAX,EAAgC,UAAC1C,KAAD,EAAW;AACvC;AACAsC,IAAAA,UAAU,CAAC;AAAA,aAAM3B,wBAAwB,CAACX,KAAD,CAA9B;AAAA,KAAD,EAAwC,GAAxC,CAAV;AACH,GAHD;AAIAyC,EAAAA,OAAO,CAACC,EAAR,CAAW,oBAAX,EAAiC,UAAC1C,KAAD,EAAW;AACxC,QAAIA,KAAK,IAAI,OAAOA,KAAK,CAACwC,OAAb,KAAyB,QAAtC,EAAgD;AAC5C;AACAF,MAAAA,UAAU,CAAC;AAAA,eAAM3B,wBAAwB,CAACX,KAAD,CAA9B;AAAA,OAAD,EAAwC,GAAxC,CAAV;AACH;AACJ,GALD;AAMH","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport isSomeObservable from \"is-observable\";\nimport { deserialize, serialize } from \"../common\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nimport Implementation from \"./implementation\";\nexport { registerSerializer } from \"../common\";\nexport { Transfer } from \"../transferable\";\n/** Returns `true` if this code is currently running in a worker. */\nexport const isWorkerRuntime = Implementation.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\nconst isMasterJobCancelMessage = (thing) => thing && thing.type === MasterMessageType.cancel;\nconst isMasterJobRunMessage = (thing) => thing && thing.type === MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\nconst isObservable = (thing) => isSomeObservable(thing) || isZenObservable(thing);\nfunction isZenObservable(thing) {\n    return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\nfunction deconstructTransfer(thing) {\n    return isTransferDescriptor(thing)\n        ? { payload: thing.send, transferables: thing.transferables }\n        : { payload: thing, transferables: undefined };\n}\nfunction postFunctionInitMessage() {\n    const initMessage = {\n        type: WorkerMessageType.init,\n        exposed: {\n            type: \"function\"\n        }\n    };\n    Implementation.postMessageToMaster(initMessage);\n}\nfunction postModuleInitMessage(methodNames) {\n    const initMessage = {\n        type: WorkerMessageType.init,\n        exposed: {\n            type: \"module\",\n            methods: methodNames\n        }\n    };\n    Implementation.postMessageToMaster(initMessage);\n}\nfunction postJobErrorMessage(uid, rawError) {\n    const { payload: error, transferables } = deconstructTransfer(rawError);\n    const errorMessage = {\n        type: WorkerMessageType.error,\n        uid,\n        error: serialize(error)\n    };\n    Implementation.postMessageToMaster(errorMessage, transferables);\n}\nfunction postJobResultMessage(uid, completed, resultValue) {\n    const { payload, transferables } = deconstructTransfer(resultValue);\n    const resultMessage = {\n        type: WorkerMessageType.result,\n        uid,\n        complete: completed ? true : undefined,\n        payload\n    };\n    Implementation.postMessageToMaster(resultMessage, transferables);\n}\nfunction postJobStartMessage(uid, resultType) {\n    const startMessage = {\n        type: WorkerMessageType.running,\n        uid,\n        resultType\n    };\n    Implementation.postMessageToMaster(startMessage);\n}\nfunction postUncaughtErrorMessage(error) {\n    try {\n        const errorMessage = {\n            type: WorkerMessageType.uncaughtError,\n            error: serialize(error)\n        };\n        Implementation.postMessageToMaster(errorMessage);\n    }\n    catch (subError) {\n        // tslint:disable-next-line no-console\n        console.error(\"Not reporting uncaught error back to master thread as it \" +\n            \"occured while reporting an uncaught error already.\" +\n            \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n    }\n}\nfunction runFunction(jobUID, fn, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let syncResult;\n        try {\n            syncResult = fn(...args);\n        }\n        catch (error) {\n            return postJobErrorMessage(jobUID, error);\n        }\n        const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n        postJobStartMessage(jobUID, resultType);\n        if (isObservable(syncResult)) {\n            const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, serialize(value)), error => {\n                postJobErrorMessage(jobUID, serialize(error));\n                activeSubscriptions.delete(jobUID);\n            }, () => {\n                postJobResultMessage(jobUID, true);\n                activeSubscriptions.delete(jobUID);\n            });\n            activeSubscriptions.set(jobUID, subscription);\n        }\n        else {\n            try {\n                const result = yield syncResult;\n                postJobResultMessage(jobUID, true, serialize(result));\n            }\n            catch (error) {\n                postJobErrorMessage(jobUID, serialize(error));\n            }\n        }\n    });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\nexport function expose(exposed) {\n    if (!Implementation.isWorkerRuntime()) {\n        throw Error(\"expose() called in the master thread.\");\n    }\n    if (exposeCalled) {\n        throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n    }\n    exposeCalled = true;\n    if (typeof exposed === \"function\") {\n        Implementation.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && !messageData.method) {\n                runFunction(messageData.uid, exposed, messageData.args.map(deserialize));\n            }\n        });\n        postFunctionInitMessage();\n    }\n    else if (typeof exposed === \"object\" && exposed) {\n        Implementation.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && messageData.method) {\n                runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(deserialize));\n            }\n        });\n        const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n        postModuleInitMessage(methodNames);\n    }\n    else {\n        throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n    }\n    Implementation.subscribeToMasterMessages(messageData => {\n        if (isMasterJobCancelMessage(messageData)) {\n            const jobUID = messageData.uid;\n            const subscription = activeSubscriptions.get(jobUID);\n            if (subscription) {\n                subscription.unsubscribe();\n                activeSubscriptions.delete(jobUID);\n            }\n        }\n    });\n}\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && Implementation.isWorkerRuntime()) {\n    self.addEventListener(\"error\", event => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n    });\n    self.addEventListener(\"unhandledrejection\", event => {\n        const error = event.reason;\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && Implementation.isWorkerRuntime()) {\n    process.on(\"uncaughtException\", (error) => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(error), 250);\n    });\n    process.on(\"unhandledRejection\", (error) => {\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\n"]},"metadata":{},"sourceType":"module"}