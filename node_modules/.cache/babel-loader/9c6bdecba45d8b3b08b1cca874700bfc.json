{"ast":null,"code":"import { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model, {\n  ignoreRange\n} = {}) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\n\nfunction parseUnitScaleCore(model) {\n  const {\n    encoding,\n    mark,\n    markDef\n  } = model;\n  return SCALE_CHANNELS.reduce((scaleComponents, channel) => {\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n    // Don't generate scale for shape of geoshape\n\n    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n\n    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : specifiedScale = {};\n      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\n\nfunction parseNonUnitScaleCore(model) {\n  var _a;\n\n  var _b;\n\n  const scaleComponents = model.component.scales = {};\n  const scaleTypeWithExplicitIndex = {};\n  const resolve = model.component.resolve; // Parse each child scale and determine if a particular channel can be merged.\n\n  for (const child of model.children) {\n    parseScaleCore(child); // Instead of always merging right away -- check if it is compatible to merge first!\n\n    for (const channel of keys(child.component.scales)) {\n      // if resolve is undefined, set default first\n      (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : _b[channel] = defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent'; // Remove from the index so they don't get merged\n\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    }\n  } // Merge each channel listed in the index\n\n\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit); // rename each child and mark them as merged\n\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n\n  return scaleComponents;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model, { ignoreRange } = {}) {\n    parseScaleCore(model);\n    parseScaleDomain(model);\n    for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n        parseScaleProperty(model, prop);\n    }\n    if (!ignoreRange) {\n        // range depends on zero\n        parseScaleRange(model);\n    }\n}\nexport function parseScaleCore(model) {\n    if (isUnitModel(model)) {\n        model.component.scales = parseUnitScaleCore(model);\n    }\n    else {\n        model.component.scales = parseNonUnitScaleCore(model);\n    }\n}\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model) {\n    const { encoding, mark, markDef } = model;\n    return SCALE_CHANNELS.reduce((scaleComponents, channel) => {\n        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n        // Don't generate scale for shape of geoshape\n        if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n            return scaleComponents;\n        }\n        let specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n        if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n            specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : (specifiedScale = {});\n            const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef);\n            scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n                value: sType,\n                explicit: specifiedScale.type === sType\n            });\n        }\n        return scaleComponents;\n    }, {});\n}\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\nfunction parseNonUnitScaleCore(model) {\n    var _a;\n    var _b;\n    const scaleComponents = (model.component.scales = {});\n    const scaleTypeWithExplicitIndex = {};\n    const resolve = model.component.resolve;\n    // Parse each child scale and determine if a particular channel can be merged.\n    for (const child of model.children) {\n        parseScaleCore(child);\n        // Instead of always merging right away -- check if it is compatible to merge first!\n        for (const channel of keys(child.component.scales)) {\n            // if resolve is undefined, set default first\n            (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : (_b[channel] = defaultScaleResolve(channel, model));\n            if (resolve.scale[channel] === 'shared') {\n                const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n                const childScaleType = child.component.scales[channel].getWithExplicit('type');\n                if (explicitScaleType) {\n                    if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n                        // merge scale component if type are compatible\n                        scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n                    }\n                    else {\n                        // Otherwise, update conflicting channel to be independent\n                        resolve.scale[channel] = 'independent';\n                        // Remove from the index so they don't get merged\n                        delete scaleTypeWithExplicitIndex[channel];\n                    }\n                }\n                else {\n                    scaleTypeWithExplicitIndex[channel] = childScaleType;\n                }\n            }\n        }\n    }\n    // Merge each channel listed in the index\n    for (const channel of keys(scaleTypeWithExplicitIndex)) {\n        // Create new merged scale component\n        const name = model.scaleName(channel, true);\n        const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n        scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n        // rename each child and mark them as merged\n        for (const child of model.children) {\n            const childScale = child.component.scales[channel];\n            if (childScale) {\n                child.renameScale(childScale.get('name'), name);\n                childScale.merged = true;\n            }\n        }\n    }\n    return scaleComponents;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}