{"ast":null,"code":"import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2 } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoPointNode extends DataFlowNode {\n  constructor(parent, projection, fields, as) {\n    super(parent);\n    this.projection = projection;\n    this.fields = fields;\n    this.as = as;\n  }\n\n  clone() {\n    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n  }\n\n  static parseAll(parent, model) {\n    if (!model.projectionName()) {\n      return parent;\n    }\n\n    for (const coordinates of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {\n      const pair = coordinates.map(channel => {\n        const def = getFieldOrDatumDef(model.encoding[channel]);\n        return isFieldDef(def) ? def.field : isDatumDef(def) ? {\n          expr: `${def.datum}`\n        } : isValueDef(def) ? {\n          expr: `${def['value']}`\n        } : undefined;\n      });\n      const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoPointNode(parent, model.projectionName(), pair, [model.getName(`x${suffix}`), model.getName(`y${suffix}`)]);\n      }\n    }\n\n    return parent;\n  }\n\n  dependentFields() {\n    return new Set(this.fields.filter(isString));\n  }\n\n  producedFields() {\n    return new Set(this.as);\n  }\n\n  hash() {\n    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;\n  }\n\n  assemble() {\n    return {\n      type: 'geopoint',\n      projection: this.projection,\n      fields: this.fields,\n      as: this.as\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/geopoint.ts"],"names":[],"mappings":"AACA,SAAQ,QAAR,QAAuB,WAAvB;AACA,SAA4B,QAA5B,EAAsC,SAAtC,EAAiD,SAAjD,EAA4D,UAA5D,QAA6E,eAA7E;AACA,SAAQ,kBAAR,EAA4B,UAA5B,EAAwC,UAAxC,EAAoD,UAApD,QAAqE,kBAArE;AACA,SAAQ,SAAR,EAAmB,IAAnB,QAA8B,YAA9B;AAGA,SAAQ,YAAR,QAA2B,YAA3B;AAEA,OAAM,MAAO,YAAP,SAA4B,YAA5B,CAAwC;AAK5C,EAAA,WAAA,CACE,MADF,EAEU,UAFV,EAGU,MAHV,EAIU,EAJV,EAI8B;AAE5B,UAAM,MAAN;AAJQ,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,EAAA,GAAA,EAAA;AAGT;;AAXM,EAAA,KAAK,GAAA;AACV,WAAO,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,KAAK,UAA5B,EAAwC,SAAS,CAAC,KAAK,MAAN,CAAjD,EAAgE,SAAS,CAAC,KAAK,EAAN,CAAzE,CAAP;AACD;;AAWM,SAAO,QAAP,CAAgB,MAAhB,EAAsC,KAAtC,EAAsD;AAC3D,QAAI,CAAC,KAAK,CAAC,cAAN,EAAL,EAA6B;AAC3B,aAAO,MAAP;AACD;;AAED,SAAK,MAAM,WAAX,IAA0B,CACxB,CAAC,SAAD,EAAY,QAAZ,CADwB,EAExB,CAAC,UAAD,EAAa,SAAb,CAFwB,CAA1B,EAGoC;AAClC,YAAM,IAAI,GAAG,WAAW,CAAC,GAAZ,CAAgB,OAAO,IAAG;AACrC,cAAM,GAAG,GAAG,kBAAkB,CAAC,KAAK,CAAC,QAAN,CAAe,OAAf,CAAD,CAA9B;AACA,eAAO,UAAU,CAAC,GAAD,CAAV,GACH,GAAG,CAAC,KADD,GAEH,UAAU,CAAC,GAAD,CAAV,GACA;AAAC,UAAA,IAAI,EAAE,GAAG,GAAG,CAAC,KAAK;AAAnB,SADA,GAEA,UAAU,CAAC,GAAD,CAAV,GACA;AAAC,UAAA,IAAI,EAAE,GAAG,GAAG,CAAC,OAAD,CAAS;AAAtB,SADA,GAEA,SANJ;AAOD,OATY,CAAb;AAWA,YAAM,MAAM,GAAG,WAAW,CAAC,CAAD,CAAX,KAAmB,UAAnB,GAAgC,GAAhC,GAAsC,EAArD;;AAEA,UAAI,IAAI,CAAC,CAAD,CAAJ,IAAW,IAAI,CAAC,CAAD,CAAnB,EAAwB;AACtB,QAAA,MAAM,GAAG,IAAI,YAAJ,CAAiB,MAAjB,EAAyB,KAAK,CAAC,cAAN,EAAzB,EAAiD,IAAjD,EAAuD,CAC9D,KAAK,CAAC,OAAN,CAAc,IAAI,MAAM,EAAxB,CAD8D,EAE9D,KAAK,CAAC,OAAN,CAAc,IAAI,MAAM,EAAxB,CAF8D,CAAvD,CAAT;AAID;AACF;;AAED,WAAO,MAAP;AACD;;AAEM,EAAA,eAAe,GAAA;AACpB,WAAO,IAAI,GAAJ,CAAQ,KAAK,MAAL,CAAY,MAAZ,CAAmB,QAAnB,CAAR,CAAP;AACD;;AAEM,EAAA,cAAc,GAAA;AACnB,WAAO,IAAI,GAAJ,CAAQ,KAAK,EAAb,CAAP;AACD;;AAEM,EAAA,IAAI,GAAA;AACT,WAAO,YAAY,KAAK,UAAU,IAAI,IAAI,CAAC,KAAK,MAAN,CAAa,IAAI,IAAI,CAAC,KAAK,EAAN,CAAS,EAAxE;AACD;;AAEM,EAAA,QAAQ,GAAA;AACb,WAAO;AACL,MAAA,IAAI,EAAE,UADD;AAEL,MAAA,UAAU,EAAE,KAAK,UAFZ;AAGL,MAAA,MAAM,EAAE,KAAK,MAHR;AAIL,MAAA,EAAE,EAAE,KAAK;AAJJ,KAAP;AAMD;;AAlE2C","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2 } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoPointNode extends DataFlowNode {\n    constructor(parent, projection, fields, as) {\n        super(parent);\n        this.projection = projection;\n        this.fields = fields;\n        this.as = as;\n    }\n    clone() {\n        return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n    }\n    static parseAll(parent, model) {\n        if (!model.projectionName()) {\n            return parent;\n        }\n        for (const coordinates of [\n            [LONGITUDE, LATITUDE],\n            [LONGITUDE2, LATITUDE2]\n        ]) {\n            const pair = coordinates.map(channel => {\n                const def = getFieldOrDatumDef(model.encoding[channel]);\n                return isFieldDef(def)\n                    ? def.field\n                    : isDatumDef(def)\n                        ? { expr: `${def.datum}` }\n                        : isValueDef(def)\n                            ? { expr: `${def['value']}` }\n                            : undefined;\n            });\n            const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n            if (pair[0] || pair[1]) {\n                parent = new GeoPointNode(parent, model.projectionName(), pair, [\n                    model.getName(`x${suffix}`),\n                    model.getName(`y${suffix}`)\n                ]);\n            }\n        }\n        return parent;\n    }\n    dependentFields() {\n        return new Set(this.fields.filter(isString));\n    }\n    producedFields() {\n        return new Set(this.as);\n    }\n    hash() {\n        return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;\n    }\n    assemble() {\n        return {\n            type: 'geopoint',\n            projection: this.projection,\n            fields: this.fields,\n            as: this.as\n        };\n    }\n}\n//# sourceMappingURL=geopoint.js.map"]},"metadata":{},"sourceType":"module"}