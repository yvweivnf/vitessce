{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nimport { openArray } from 'zarr';\nimport range from 'lodash/range';\nimport ZarrDataSource from './ZarrDataSource';\n\nconst readFloat32FromUint8 = bytes => {\n  if (bytes.length !== 4) {\n    throw new Error('readFloat32 only takes in length 4 byte buffers');\n  }\n\n  return new Int32Array(bytes.buffer)[0];\n};\n\nconst HEADER_LENGTH = 4;\n\nfunction dirname(path) {\n  const arr = path.split('/');\n  arr.pop();\n  return arr.join('/');\n}\n/**\n   * Method for decoding text arrays from zarr.\n   * Largerly a port of https://github.com/zarr-developers/numcodecs/blob/2c1aff98e965c3c4747d9881d8b8d4aad91adb3a/numcodecs/vlen.pyx#L135-L178\n   * @returns {string[]} An array of strings.\n   */\n\n\nfunction parseVlenUtf8(buffer) {\n  const decoder = new TextDecoder();\n  let data = 0;\n  const dataEnd = data + buffer.length;\n  const length = readFloat32FromUint8(buffer.slice(data, HEADER_LENGTH));\n\n  if (buffer.length < HEADER_LENGTH) {\n    throw new Error('corrupt buffer, missing or truncated header');\n  }\n\n  data += HEADER_LENGTH;\n  const output = new Array(length);\n\n  for (let i = 0; i < length; i += 1) {\n    if (data + 4 > dataEnd) {\n      throw new Error('corrupt buffer, data seem truncated');\n    }\n\n    const l = readFloat32FromUint8(buffer.slice(data, data + 4));\n    data += 4;\n\n    if (data + l > dataEnd) {\n      throw new Error('corrupt buffer, data seem truncated');\n    }\n\n    output[i] = decoder.decode(buffer.slice(data, data + l));\n    data += l;\n  }\n\n  return output;\n}\n/**\n * A base AnnData loader which has all shared methods for more comlpex laoders,\n * like loading cell names and ids. It inherits from AbstractLoader.\n */\n\n\nexport default class AnnDataSource extends ZarrDataSource {\n  constructor(...args) {\n    super(...args);\n    /** @type {Map<string, Promise<string[]>} */\n\n    this.promises = new Map();\n  }\n\n  loadObsColumns(paths) {\n    return this._loadColumns(paths);\n  }\n\n  loadVarColumns(paths) {\n    return this._loadColumns(paths);\n  }\n  /**\n   * Class method for loading obs variables.\n   * Takes the location as an argument because this is shared across objects,\n   * which have different ways of specifying location.\n   * @param {string[]} paths An array of strings like \"obs/leiden\" or \"obs/bulk_labels.\"\n   * @returns {Promise} A promise for an array of ids with one per cell.\n   */\n\n\n  _loadColumns(paths) {\n    const promises = paths.map(path => {\n      const getCol = col => {\n        if (!this.promises.has(col)) {\n          const obsPromise = this._loadColumn(col).catch(err => {\n            // clear from cache if promise rejects\n            this.promises.delete(col); // propagate error\n\n            throw err;\n          });\n\n          this.promises.set(col, obsPromise);\n        }\n\n        return this.promises.get(col);\n      };\n\n      if (!path) {\n        return Promise.resolve(undefined);\n      }\n\n      if (Array.isArray(path)) {\n        return Promise.resolve(Promise.all(path.map(getCol)));\n      }\n\n      return getCol(path);\n    });\n    return Promise.all(promises);\n  }\n\n  async _loadColumn(path) {\n    const {\n      store\n    } = this;\n    const prefix = dirname(path);\n    const {\n      categories,\n      'encoding-type': encodingType\n    } = await this.getJson(`${path}/.zattrs`);\n    let categoriesValues;\n    let codes;\n\n    if (categories) {\n      const {\n        dtype\n      } = await this.getJson(`/${prefix}/${categories}/.zarray`);\n\n      if (dtype === '|O') {\n        categoriesValues = await this.getFlatArrDecompressed(`/${prefix}/${categories}`);\n      }\n    } else if (encodingType === 'categorical') {\n      const {\n        dtype\n      } = await this.getJson(`/${path}/categories/.zarray`);\n\n      if (dtype === '|O') {\n        categoriesValues = await this.getFlatArrDecompressed(`/${path}/categories`);\n      }\n\n      codes = `/${path}/codes`;\n    } else {\n      const {\n        dtype\n      } = await this.getJson(`/${path}/.zarray`);\n\n      if (dtype === '|O') {\n        return this.getFlatArrDecompressed(path);\n      }\n    }\n\n    const arr = await openArray({\n      store,\n      path: codes || path,\n      mode: 'r'\n    });\n    const values = await arr.get();\n    const {\n      data\n    } = values;\n    const mappedValues = Array.from(data).map(i => !categoriesValues ? String(i) : categoriesValues[i]);\n    return mappedValues;\n  }\n  /**\n   * Class method for loading general numeric arrays.\n   * @param {string} path A string like obsm.X_pca.\n   * @returns {Promise} A promise for a zarr array containing the data.\n   */\n\n\n  loadNumeric(path) {\n    const {\n      store\n    } = this;\n    return openArray({\n      store,\n      path,\n      mode: 'r'\n    }).then(arr => arr.get());\n  }\n  /**\n   * A common method for loading flattened data\n   * i.e that which has shape [n] where n is a natural number.\n   * @param {string} path A path to a flat array location, like obs/_index\n   * @returns {Array} The data from the zarr array.\n   */\n\n\n  getFlatArrDecompressed(path) {\n    const {\n      store\n    } = this;\n    return openArray({\n      store,\n      path,\n      mode: 'r'\n    }).then(async z => {\n      let data;\n\n      const parseAndMergeTextBytes = dbytes => {\n        const text = parseVlenUtf8(dbytes);\n\n        if (!data) {\n          data = text;\n        } else {\n          data = data.concat(text);\n        }\n      };\n\n      const mergeBytes = dbytes => {\n        if (!data) {\n          data = dbytes;\n        } else {\n          const tmp = new Uint8Array(dbytes.buffer.byteLength + data.buffer.byteLength);\n          tmp.set(new Uint8Array(data.buffer), 0);\n          tmp.set(dbytes, data.buffer.byteLength);\n          data = tmp;\n        }\n      };\n\n      const numRequests = Math.ceil(z.meta.shape[0] / z.meta.chunks[0]);\n      const requests = range(numRequests).map(async item => store.getItem(`${z.keyPrefix}${String(item)}`).then(buf => z.compressor.then(compressor => compressor.decode(buf))));\n      const dbytesArr = await Promise.all(requests);\n      dbytesArr.forEach(dbytes => {\n        // Use vlenutf-8 decoding if necessary and merge `data` as a normal array.\n        if (Array.isArray(z.meta.filters) && z.meta.filters[0].id === 'vlen-utf8') {\n          parseAndMergeTextBytes(dbytes); // Otherwise just merge the bytes as a typed array.\n        } else {\n          mergeBytes(dbytes);\n        }\n      });\n      const {\n        meta: {\n          shape: [length]\n        }\n      } = z; // truncate the filled in values\n\n      return data.slice(0, length);\n    });\n  }\n  /**\n   * Class method for loading the obs index.\n   * @returns {Promise} An promise for a zarr array containing the indices.\n   */\n\n\n  loadObsIndex() {\n    if (this.obsIndex) {\n      return this.obsIndex;\n    }\n\n    this.obsIndex = this.getJson('obs/.zattrs').then(({\n      _index\n    }) => this.getFlatArrDecompressed(`/obs/${_index}`));\n    return this.obsIndex;\n  }\n  /**\n   * Class method for loading the var index.\n   * @returns {Promise} An promise for a zarr array containing the indices.\n   */\n\n\n  loadVarIndex() {\n    if (this.varIndex) {\n      return this.varIndex;\n    }\n\n    this.varIndex = this.getJson('var/.zattrs').then(({\n      _index\n    }) => this.getFlatArrDecompressed(`/var/${_index}`));\n    return this.varIndex;\n  }\n  /**\n   * Class method for loading the var alias.\n   * @returns {Promise} An promise for a zarr array containing the aliased names.\n   */\n\n\n  async loadVarAlias(varPath) {\n    if (this.varAlias) {\n      return this.varAlias;\n    }\n\n    [this.varAlias] = await this.loadVarColumns([varPath]);\n    const index = await this.loadVarIndex();\n    this.varAlias = this.varAlias.map((val, ind) => val ? val.concat(` (${index[ind]})`) : index[ind]);\n    return this.varAlias;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/data-sources/AnnDataSource.js"],"names":["openArray","range","ZarrDataSource","readFloat32FromUint8","bytes","length","Error","Int32Array","buffer","HEADER_LENGTH","dirname","path","arr","split","pop","join","parseVlenUtf8","decoder","TextDecoder","data","dataEnd","slice","output","Array","i","l","decode","AnnDataSource","constructor","args","promises","Map","loadObsColumns","paths","_loadColumns","loadVarColumns","map","getCol","col","has","obsPromise","_loadColumn","catch","err","delete","set","get","Promise","resolve","undefined","isArray","all","store","prefix","categories","encodingType","getJson","categoriesValues","codes","dtype","getFlatArrDecompressed","mode","values","mappedValues","from","String","loadNumeric","then","z","parseAndMergeTextBytes","dbytes","text","concat","mergeBytes","tmp","Uint8Array","byteLength","numRequests","Math","ceil","meta","shape","chunks","requests","item","getItem","keyPrefix","buf","compressor","dbytesArr","forEach","filters","id","loadObsIndex","obsIndex","_index","loadVarIndex","varIndex","loadVarAlias","varPath","varAlias","index","val","ind"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { openArray } from 'zarr';\nimport range from 'lodash/range';\nimport ZarrDataSource from './ZarrDataSource';\n\nconst readFloat32FromUint8 = (bytes) => {\n  if (bytes.length !== 4) {\n    throw new Error('readFloat32 only takes in length 4 byte buffers');\n  }\n  return new Int32Array(bytes.buffer)[0];\n};\n\nconst HEADER_LENGTH = 4;\n\nfunction dirname(path) {\n  const arr = path.split('/');\n  arr.pop();\n  return arr.join('/');\n}\n\n/**\n   * Method for decoding text arrays from zarr.\n   * Largerly a port of https://github.com/zarr-developers/numcodecs/blob/2c1aff98e965c3c4747d9881d8b8d4aad91adb3a/numcodecs/vlen.pyx#L135-L178\n   * @returns {string[]} An array of strings.\n   */\nfunction parseVlenUtf8(buffer) {\n  const decoder = new TextDecoder();\n  let data = 0;\n  const dataEnd = data + buffer.length;\n  const length = readFloat32FromUint8(buffer.slice(data, HEADER_LENGTH));\n  if (buffer.length < HEADER_LENGTH) {\n    throw new Error('corrupt buffer, missing or truncated header');\n  }\n  data += HEADER_LENGTH;\n  const output = new Array(length);\n  for (let i = 0; i < length; i += 1) {\n    if (data + 4 > dataEnd) {\n      throw new Error('corrupt buffer, data seem truncated');\n    }\n    const l = readFloat32FromUint8(buffer.slice(data, data + 4));\n    data += 4;\n    if (data + l > dataEnd) {\n      throw new Error('corrupt buffer, data seem truncated');\n    }\n    output[i] = decoder.decode(buffer.slice(data, data + l));\n    data += l;\n  }\n  return output;\n}\n\n/**\n * A base AnnData loader which has all shared methods for more comlpex laoders,\n * like loading cell names and ids. It inherits from AbstractLoader.\n */\nexport default class AnnDataSource extends ZarrDataSource {\n  constructor(...args) {\n    super(...args);\n    /** @type {Map<string, Promise<string[]>} */\n    this.promises = new Map();\n  }\n\n  loadObsColumns(paths) {\n    return this._loadColumns(paths);\n  }\n\n  loadVarColumns(paths) {\n    return this._loadColumns(paths);\n  }\n\n  /**\n   * Class method for loading obs variables.\n   * Takes the location as an argument because this is shared across objects,\n   * which have different ways of specifying location.\n   * @param {string[]} paths An array of strings like \"obs/leiden\" or \"obs/bulk_labels.\"\n   * @returns {Promise} A promise for an array of ids with one per cell.\n   */\n  _loadColumns(paths) {\n    const promises = paths.map((path) => {\n      const getCol = (col) => {\n        if (!this.promises.has(col)) {\n          const obsPromise = this._loadColumn(col).catch((err) => {\n            // clear from cache if promise rejects\n            this.promises.delete(col);\n            // propagate error\n            throw err;\n          });\n          this.promises.set(col, obsPromise);\n        }\n        return this.promises.get(col);\n      };\n      if (!path) {\n        return Promise.resolve(undefined);\n      }\n      if (Array.isArray(path)) {\n        return Promise.resolve(Promise.all(path.map(getCol)));\n      }\n      return getCol(path);\n    });\n    return Promise.all(promises);\n  }\n\n  async _loadColumn(path) {\n    const { store } = this;\n    const prefix = dirname(path);\n    const { categories, 'encoding-type': encodingType } = await this.getJson(`${path}/.zattrs`);\n    let categoriesValues;\n    let codes;\n    if (categories) {\n      const { dtype } = await this.getJson(`/${prefix}/${categories}/.zarray`);\n      if (dtype === '|O') {\n        categoriesValues = await this.getFlatArrDecompressed(\n          `/${prefix}/${categories}`,\n        );\n      }\n    } else if (encodingType === 'categorical') {\n      const { dtype } = await this.getJson(`/${path}/categories/.zarray`);\n      if (dtype === '|O') {\n        categoriesValues = await this.getFlatArrDecompressed(\n          `/${path}/categories`,\n        );\n      }\n      codes = `/${path}/codes`;\n    } else {\n      const { dtype } = await this.getJson(`/${path}/.zarray`);\n      if (dtype === '|O') {\n        return this.getFlatArrDecompressed(path);\n      }\n    }\n    const arr = await openArray({ store, path: codes || path, mode: 'r' });\n    const values = await arr.get();\n    const { data } = values;\n    const mappedValues = Array.from(data).map(\n      i => (!categoriesValues ? String(i) : categoriesValues[i]),\n    );\n    return mappedValues;\n  }\n\n  /**\n   * Class method for loading general numeric arrays.\n   * @param {string} path A string like obsm.X_pca.\n   * @returns {Promise} A promise for a zarr array containing the data.\n   */\n  loadNumeric(path) {\n    const { store } = this;\n    return openArray({\n      store,\n      path,\n      mode: 'r',\n    }).then(arr => arr.get());\n  }\n\n  /**\n   * A common method for loading flattened data\n   * i.e that which has shape [n] where n is a natural number.\n   * @param {string} path A path to a flat array location, like obs/_index\n   * @returns {Array} The data from the zarr array.\n   */\n  getFlatArrDecompressed(path) {\n    const { store } = this;\n    return openArray({\n      store,\n      path,\n      mode: 'r',\n    }).then(async (z) => {\n      let data;\n      const parseAndMergeTextBytes = (dbytes) => {\n        const text = parseVlenUtf8(dbytes);\n        if (!data) {\n          data = text;\n        } else {\n          data = data.concat(text);\n        }\n      };\n      const mergeBytes = (dbytes) => {\n        if (!data) {\n          data = dbytes;\n        } else {\n          const tmp = new Uint8Array(\n            dbytes.buffer.byteLength + data.buffer.byteLength,\n          );\n          tmp.set(new Uint8Array(data.buffer), 0);\n          tmp.set(dbytes, data.buffer.byteLength);\n          data = tmp;\n        }\n      };\n      const numRequests = Math.ceil(z.meta.shape[0] / z.meta.chunks[0]);\n      const requests = range(numRequests).map(async item => store\n        .getItem(`${z.keyPrefix}${String(item)}`)\n        .then(buf => z.compressor.then(compressor => compressor.decode(buf))));\n      const dbytesArr = await Promise.all(requests);\n      dbytesArr.forEach((dbytes) => {\n        // Use vlenutf-8 decoding if necessary and merge `data` as a normal array.\n        if (\n          Array.isArray(z.meta.filters)\n          && z.meta.filters[0].id === 'vlen-utf8'\n        ) {\n          parseAndMergeTextBytes(dbytes);\n          // Otherwise just merge the bytes as a typed array.\n        } else {\n          mergeBytes(dbytes);\n        }\n      });\n      const {\n        meta: {\n          shape: [length],\n        },\n      } = z;\n      // truncate the filled in values\n      return data.slice(0, length);\n    });\n  }\n\n  /**\n   * Class method for loading the obs index.\n   * @returns {Promise} An promise for a zarr array containing the indices.\n   */\n  loadObsIndex() {\n    if (this.obsIndex) {\n      return this.obsIndex;\n    }\n    this.obsIndex = this.getJson('obs/.zattrs').then(({ _index }) => this.getFlatArrDecompressed(`/obs/${_index}`));\n    return this.obsIndex;\n  }\n\n  /**\n   * Class method for loading the var index.\n   * @returns {Promise} An promise for a zarr array containing the indices.\n   */\n  loadVarIndex() {\n    if (this.varIndex) {\n      return this.varIndex;\n    }\n    this.varIndex = this.getJson('var/.zattrs').then(({ _index }) => this.getFlatArrDecompressed(`/var/${_index}`));\n    return this.varIndex;\n  }\n\n  /**\n   * Class method for loading the var alias.\n   * @returns {Promise} An promise for a zarr array containing the aliased names.\n   */\n  async loadVarAlias(varPath) {\n    if (this.varAlias) {\n      return this.varAlias;\n    }\n    [this.varAlias] = await this.loadVarColumns([varPath]);\n    const index = await this.loadVarIndex();\n    this.varAlias = this.varAlias.map(\n      (val, ind) => (val ? val.concat(` (${index[ind]})`) : index[ind]),\n    );\n    return this.varAlias;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}