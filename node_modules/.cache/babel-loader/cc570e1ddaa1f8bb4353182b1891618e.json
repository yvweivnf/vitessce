{"ast":null,"code":"import { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n  const {\n    config,\n    markDef\n  } = model;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid) {\n    const signal = allFieldsInvalidPredicate(model, {\n      channels: POSITION_SCALE_CHANNELS\n    });\n\n    if (signal) {\n      return {\n        defined: {\n          signal\n        }\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction allFieldsInvalidPredicate(model, {\n  invalid = false,\n  channels\n}) {\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n\n  return undefined;\n}\n\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return {\n      [prop]: signalOrValueRef(value)\n    };\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/defined.ts"],"names":[],"mappings":"AAAA,SAAQ,uBAAR,QAAsC,kBAAtC;AAGA,SAAQ,mBAAR,QAAkC,gBAAlC;AACA,SAAc,IAAd,QAAyB,eAAzB;AAEA,SAAQ,mBAAR,EAA6B,gBAA7B,QAAoD,cAApD;AAEA,SAAQ,qBAAR,QAAoC,YAApC;AAEA,OAAM,SAAU,OAAV,CAAkB,KAAlB,EAAkC;AACtC,QAAM;AAAC,IAAA,MAAD;AAAS,IAAA;AAAT,MAAoB,KAA1B;AAEA,QAAM,OAAO,GAAG,mBAAmB,CAAC,SAAD,EAAY,OAAZ,EAAqB,MAArB,CAAnC;;AACA,MAAI,OAAJ,EAAa;AACX,UAAM,MAAM,GAAG,yBAAyB,CAAC,KAAD,EAAQ;AAAC,MAAA,QAAQ,EAAE;AAAX,KAAR,CAAxC;;AAEA,QAAI,MAAJ,EAAY;AACV,aAAO;AAAC,QAAA,OAAO,EAAE;AAAC,UAAA;AAAD;AAAV,OAAP;AACD;AACF;;AACD,SAAO,EAAP;AACD;;AAED,SAAS,yBAAT,CACE,KADF,EAEE;AAAC,EAAA,OAAO,GAAG,KAAX;AAAkB,EAAA;AAAlB,CAFF,EAE4E;AAE1E,QAAM,WAAW,GAAG,QAAQ,CAAC,MAAT,CAAgB,CAAC,UAAD,EAAyB,OAAzB,KAAoC;AACtE,UAAM,cAAc,GAAG,KAAK,CAAC,iBAAN,CAAwB,OAAxB,CAAvB;;AACA,QAAI,cAAJ,EAAoB;AAClB,YAAM,SAAS,GAAG,cAAc,CAAC,GAAf,CAAmB,MAAnB,CAAlB;AACA,YAAM,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB;AAAC,QAAA,IAAI,EAAE;AAAP,OAAvB,CAAd,CAFkB,CAIlB;;AACA,UAAI,KAAK,IAAI,mBAAmB,CAAC,SAAD,CAAhC,EAA6C;AAC3C,QAAA,UAAU,CAAC,KAAD,CAAV,GAAoB,IAApB;AACD;AACF;;AACD,WAAO,UAAP;AACD,GAZmB,EAYjB,EAZiB,CAApB;AAcA,QAAM,MAAM,GAAG,IAAI,CAAC,WAAD,CAAnB;;AACA,MAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AACrB,UAAM,EAAE,GAAG,OAAO,GAAG,IAAH,GAAU,IAA5B;AACA,WAAO,MAAM,CAAC,GAAP,CAAW,KAAK,IAAI,qBAAqB,CAAC,KAAD,EAAQ,OAAR,CAAzC,EAA2D,IAA3D,CAAgE,IAAI,EAAE,GAAtE,CAAP;AACD;;AACD,SAAO,SAAP;AACD;;AAED,OAAM,SAAU,cAAV,CAAyB,IAAzB,EAAuC,KAAvC,EAAmD;AACvD,MAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,WAAO;AAAC,OAAC,IAAD,GAAQ,gBAAgB,CAAC,KAAD;AAAzB,KAAP;AACD;;AACD,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["import { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n    const { config, markDef } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid) {\n        const signal = allFieldsInvalidPredicate(model, { channels: POSITION_SCALE_CHANNELS });\n        if (signal) {\n            return { defined: { signal } };\n        }\n    }\n    return {};\n}\nfunction allFieldsInvalidPredicate(model, { invalid = false, channels }) {\n    const filterIndex = channels.reduce((aggregator, channel) => {\n        const scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n            const scaleType = scaleComponent.get('type');\n            const field = model.vgField(channel, { expr: 'datum' });\n            // While discrete domain scales can handle invalid values, continuous scales can't.\n            if (field && hasContinuousDomain(scaleType)) {\n                aggregator[field] = true;\n            }\n        }\n        return aggregator;\n    }, {});\n    const fields = keys(filterIndex);\n    if (fields.length > 0) {\n        const op = invalid ? '||' : '&&';\n        return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n    }\n    return undefined;\n}\nexport function valueIfDefined(prop, value) {\n    if (value !== undefined) {\n        return { [prop]: signalOrValueRef(value) };\n    }\n    return undefined;\n}\n//# sourceMappingURL=defined.js.map"]},"metadata":{},"sourceType":"module"}