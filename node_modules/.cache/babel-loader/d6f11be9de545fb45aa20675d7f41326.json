{"ast":null,"code":"import { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nconst defaultProps = { ...ScreenGridCellLayer.defaultProps,\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {\n          id: \"\".concat(this.id, \"-max-texture\")\n        })\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true,\n      weights,\n      subLayerData: {\n        attributes: {}\n      },\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n\n    const {\n      maxTexture,\n      numRow,\n      numCol,\n      weights\n    } = this.state;\n    const {\n      updateTriggers\n    } = this.props;\n    const {\n      aggregationBuffer\n    } = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer',\n      updateTriggers\n    }), {\n      data: {\n        attributes: {\n          instanceCounts: aggregationBuffer\n        }\n      },\n      maxTexture,\n      numInstances: numRow * numCol\n    });\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    const {\n      aggregationBuffer,\n      maxBuffer,\n      maxTexture\n    } = this.state;\n    aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n    maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n  }\n\n  getPickingInfo(_ref2) {\n    let {\n      info,\n      mode\n    } = _ref2;\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator,\n        gpuAggregation,\n        weights\n      } = this.state;\n      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  updateResults(_ref3) {\n    let {\n      aggregationData,\n      maxData\n    } = _ref3;\n    const {\n      count\n    } = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({\n      data: aggregationData\n    });\n    count.maxData = maxData;\n    count.maxTexture.setImageData({\n      data: maxData\n    });\n  }\n\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {\n      viewportChanged\n    } = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      dimensions\n    } = this.state;\n    const {\n      data,\n      weights\n    } = dimensions;\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n      compareAll: gpuAggregation,\n      dimension: data\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n    const {\n      viewport\n    } = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {\n        width,\n        height\n      } = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        scaling: [width / 2, -height / 2, 1],\n        gridOffset: {\n          xOffset: cellSize,\n          yOffset: cellSize\n        },\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n}\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/screen-grid-layer/screen-grid-layer.js"],"names":["defaultProps","ScreenGridCellLayer","getPosition","type","value","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","initializeState","gl","supported","log","dimensions","getCellSize","cellSizePixels","count","size","operation","AGGREGATION_OPERATION","needMax","maxTexture","getFloatTexture","id","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","accessor","fp64","shouldUpdateState","changeFlags","updateState","renderLayers","updateTriggers","aggregationBuffer","CellLayerClass","instanceCounts","numInstances","numRow","numCol","finalizeState","maxBuffer","getPickingInfo","mode","index","aggregationResults","gpuGridAggregator","info","pixelIndex","updateResults","maxData","aggregationData","updateAggregationState","cellSize","opts","cellSizeChanged","viewportChanged","GPUGridAggregator","gpuAggregationChanged","positionsChanged","aggregationDataDirty","compareAll","dimension","aggregationWeightsDirty","viewport","height","Math","width","scaling","gridOffset","xOffset","yOffset","_updateAccessors","getValue","getValueFunc","_resetResults","ScreenGridLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    aggregationBuffer?.delete();\n    maxBuffer?.delete();\n    maxTexture?.delete();\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator, gpuAggregation, weights} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuAggregation\n        ? gpuGridAggregator.getData('count')\n        : weights.count;\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}