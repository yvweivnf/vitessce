{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\n\nfunction makeWalkTree(data) {\n  // to name datasources\n  var datasetIndex = 0;\n  /**\n   * Recursively walk down the tree.\n   */\n\n  function walkTree(node, dataSource) {\n    var _a;\n\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        var newData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        var _dataSource$transform;\n\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format) !== null && _a !== void 0 ? _a : {}), {\n          parse: node.assembleFormatParse()\n        }); // add calculates for all nested fields\n\n        (_dataSource$transform = dataSource.transform).push.apply(_dataSource$transform, _toConsumableArray(node.assembleTransforms(true)));\n      } else {\n        var _dataSource$transform2;\n\n        // Otherwise use Vega expression to parse\n        (_dataSource$transform2 = dataSource.transform).push.apply(_dataSource$transform2, _toConsumableArray(node.assembleTransforms()));\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = \"data_\".concat(datasetIndex++);\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      data.push.apply(data, _toConsumableArray(node.assemble())); // break here because the rest of the tree has to be taken care of by the facet.\n\n      return;\n    }\n\n    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {\n      var _dataSource$transform3;\n\n      (_dataSource$transform3 = dataSource.transform).push.apply(_dataSource$transform3, _toConsumableArray(node.assemble()));\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = \"data_\".concat(datasetIndex++);\n        } // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n\n\n        node.setSource(dataSource.name); // if this node has more than one child, we will add a datasource automatically\n\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          var _newData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = _newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n\n        break;\n\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n\n      default:\n        {\n          if (!dataSource.name) {\n            dataSource.name = \"data_\".concat(datasetIndex++);\n          }\n\n          var source = dataSource.name;\n\n          if (!dataSource.source || dataSource.transform.length > 0) {\n            data.push(dataSource);\n          } else {\n            source = dataSource.source;\n          }\n\n          var _iterator = _createForOfIteratorHelper(node.children),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var child = _step.value;\n              var _newData2 = {\n                name: null,\n                source: source,\n                transform: []\n              };\n              walkTree(child, _newData2);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          break;\n        }\n    }\n  }\n\n  return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\n\n\nexport function assembleFacetData(root) {\n  var data = [];\n  var walkTree = makeWalkTree(data);\n\n  var _iterator2 = _createForOfIteratorHelper(root.children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      walkTree(child, {\n        source: root.name,\n        name: null,\n        transform: []\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\n\nexport function assembleRootData(dataComponent, datasets) {\n  var _a, _b;\n\n  var data = []; // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n\n  var walkTree = makeWalkTree(data);\n  var sourceIndex = 0;\n\n  var _iterator3 = _createForOfIteratorHelper(dataComponent.sources),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var root = _step3.value;\n\n      // assign a name if the source does not have a name yet\n      if (!root.hasName()) {\n        root.dataName = \"source_\".concat(sourceIndex++);\n      }\n\n      var newData = root.assemble();\n      walkTree(root, newData);\n    } // remove empty transform arrays for cleaner output\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  for (var _i = 0, _data = data; _i < _data.length; _i++) {\n    var d = _data[_i];\n\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  } // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n\n\n  var whereTo = 0;\n\n  var _iterator4 = _createForOfIteratorHelper(data.entries()),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n          i = _step4$value[0],\n          _d3 = _step4$value[1];\n\n      if (((_a = _d3.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !_d3.source) {\n        data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n      }\n    } // now fix the from references in lookup transforms\n\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  for (var _i2 = 0, _data2 = data; _i2 < _data2.length; _i2++) {\n    var _d = _data2[_i2];\n\n    var _iterator5 = _createForOfIteratorHelper((_b = _d.transform) !== null && _b !== void 0 ? _b : []),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var t = _step5.value;\n\n        if (t.type === 'lookup') {\n          t.from = dataComponent.outputNodes[t.from].getSource();\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  } // inline values for datasets that are in the datastore\n\n\n  for (var _i3 = 0, _data3 = data; _i3 < _data3.length; _i3++) {\n    var _d2 = _data3[_i3];\n\n    if (_d2.name in datasets) {\n      _d2.values = datasets[_d2.name];\n    }\n  }\n\n  return data;\n}","map":{"version":3,"sources":["../../../../src/compile/data/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nfunction makeWalkTree(data) {\n    // to name datasources\n    let datasetIndex = 0;\n    /**\n     * Recursively walk down the tree.\n     */\n    function walkTree(node, dataSource) {\n        var _a;\n        if (node instanceof SourceNode) {\n            // If the source is a named data source or a data source with values, we need\n            // to put it in a different data source. Otherwise, Vega may override the data.\n            if (!node.isGenerator && !isUrlData(node.data)) {\n                data.push(dataSource);\n                const newData = {\n                    name: null,\n                    source: dataSource.name,\n                    transform: []\n                };\n                dataSource = newData;\n            }\n        }\n        if (node instanceof ParseNode) {\n            if (node.parent instanceof SourceNode && !dataSource.source) {\n                // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n                dataSource.format = Object.assign(Object.assign({}, ((_a = dataSource.format) !== null && _a !== void 0 ? _a : {})), { parse: node.assembleFormatParse() });\n                // add calculates for all nested fields\n                dataSource.transform.push(...node.assembleTransforms(true));\n            }\n            else {\n                // Otherwise use Vega expression to parse\n                dataSource.transform.push(...node.assembleTransforms());\n            }\n        }\n        if (node instanceof FacetNode) {\n            if (!dataSource.name) {\n                dataSource.name = `data_${datasetIndex++}`;\n            }\n            if (!dataSource.source || dataSource.transform.length > 0) {\n                data.push(dataSource);\n                node.data = dataSource.name;\n            }\n            else {\n                node.data = dataSource.source;\n            }\n            data.push(...node.assemble());\n            // break here because the rest of the tree has to be taken care of by the facet.\n            return;\n        }\n        if (node instanceof GraticuleNode ||\n            node instanceof SequenceNode ||\n            node instanceof FilterInvalidNode ||\n            node instanceof FilterNode ||\n            node instanceof CalculateNode ||\n            node instanceof GeoPointNode ||\n            node instanceof AggregateNode ||\n            node instanceof LookupNode ||\n            node instanceof WindowTransformNode ||\n            node instanceof JoinAggregateTransformNode ||\n            node instanceof FoldTransformNode ||\n            node instanceof FlattenTransformNode ||\n            node instanceof DensityTransformNode ||\n            node instanceof LoessTransformNode ||\n            node instanceof QuantileTransformNode ||\n            node instanceof RegressionTransformNode ||\n            node instanceof IdentifierNode ||\n            node instanceof SampleTransformNode ||\n            node instanceof PivotTransformNode) {\n            dataSource.transform.push(node.assemble());\n        }\n        if (node instanceof BinNode ||\n            node instanceof TimeUnitNode ||\n            node instanceof ImputeNode ||\n            node instanceof StackNode ||\n            node instanceof GeoJSONNode) {\n            dataSource.transform.push(...node.assemble());\n        }\n        if (node instanceof OutputNode) {\n            if (dataSource.source && dataSource.transform.length === 0) {\n                node.setSource(dataSource.source);\n            }\n            else if (node.parent instanceof OutputNode) {\n                // Note that an output node may be required but we still do not assemble a\n                // separate data source for it.\n                node.setSource(dataSource.name);\n            }\n            else {\n                if (!dataSource.name) {\n                    dataSource.name = `data_${datasetIndex++}`;\n                }\n                // Here we set the name of the datasource we generated. From now on\n                // other assemblers can use it.\n                node.setSource(dataSource.name);\n                // if this node has more than one child, we will add a datasource automatically\n                if (node.numChildren() === 1) {\n                    data.push(dataSource);\n                    const newData = {\n                        name: null,\n                        source: dataSource.name,\n                        transform: []\n                    };\n                    dataSource = newData;\n                }\n            }\n        }\n        switch (node.numChildren()) {\n            case 0:\n                // done\n                if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n                    // do not push empty datasources that are simply references\n                    data.push(dataSource);\n                }\n                break;\n            case 1:\n                walkTree(node.children[0], dataSource);\n                break;\n            default: {\n                if (!dataSource.name) {\n                    dataSource.name = `data_${datasetIndex++}`;\n                }\n                let source = dataSource.name;\n                if (!dataSource.source || dataSource.transform.length > 0) {\n                    data.push(dataSource);\n                }\n                else {\n                    source = dataSource.source;\n                }\n                for (const child of node.children) {\n                    const newData = {\n                        name: null,\n                        source: source,\n                        transform: []\n                    };\n                    walkTree(child, newData);\n                }\n                break;\n            }\n        }\n    }\n    return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root) {\n    const data = [];\n    const walkTree = makeWalkTree(data);\n    for (const child of root.children) {\n        walkTree(child, {\n            source: root.name,\n            name: null,\n            transform: []\n        });\n    }\n    return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent, datasets) {\n    var _a, _b;\n    const data = [];\n    // dataComponent.sources.forEach(debug);\n    // draw(dataComponent.sources);\n    const walkTree = makeWalkTree(data);\n    let sourceIndex = 0;\n    for (const root of dataComponent.sources) {\n        // assign a name if the source does not have a name yet\n        if (!root.hasName()) {\n            root.dataName = `source_${sourceIndex++}`;\n        }\n        const newData = root.assemble();\n        walkTree(root, newData);\n    }\n    // remove empty transform arrays for cleaner output\n    for (const d of data) {\n        if (d.transform.length === 0) {\n            delete d.transform;\n        }\n    }\n    // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n    let whereTo = 0;\n    for (const [i, d] of data.entries()) {\n        if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {\n            data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n        }\n    }\n    // now fix the from references in lookup transforms\n    for (const d of data) {\n        for (const t of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {\n            if (t.type === 'lookup') {\n                t.from = dataComponent.outputNodes[t.from].getSource();\n            }\n        }\n    }\n    // inline values for datasets that are in the datastore\n    for (const d of data) {\n        if (d.name in datasets) {\n            d.values = datasets[d.name];\n        }\n    }\n    return data;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}