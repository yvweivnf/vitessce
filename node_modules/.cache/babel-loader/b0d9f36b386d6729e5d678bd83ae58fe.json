{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nvar QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\n\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  var position = 0;\n  var header = {};\n\n  var _iterator = _createForOfIteratorHelper(QUANTIZED_MESH_HEADER),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          key = _step$value[0],\n          bytesCount = _step$value[1];\n\n      var getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n      header[key] = getter.call(dataView, position, true);\n      position += bytesCount;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    header: header,\n    headerEndPosition: position\n  };\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  var position = headerEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = dataView.getUint32(position, true);\n  var vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  var elementArrayLength = vertexCount * bytesPerArrayElement;\n  var uArrayStartPosition = position;\n  var vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  var heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n  return {\n    vertexData: vertexData,\n    vertexDataEndPosition: position\n  };\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex) {\n  var encoded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  var highest = 0;\n\n  for (var i = 0; i < indices.length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  var position = vertexDataEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n\n  var triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var triangleIndicesCount = triangleCount * 3;\n  var triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices: triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  var position = triangleIndicesEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  var westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  var southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  var eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  var northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  var extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions: extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n\n  var position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    var extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    var extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n\n      default:\n        {}\n    }\n\n    position += extensionLength;\n  }\n\n  return {\n    extensions: extensions,\n    extensionsEndPosition: position\n  };\n}\n\nexport var DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nvar DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  var options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  var view = new DataView(data);\n\n  var _decodeHeader = decodeHeader(view),\n      header = _decodeHeader.header,\n      headerEndPosition = _decodeHeader.headerEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header: header\n    };\n  }\n\n  var _decodeVertexData = decodeVertexData(view, headerEndPosition),\n      vertexData = _decodeVertexData.vertexData,\n      vertexDataEndPosition = _decodeVertexData.vertexDataEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header: header,\n      vertexData: vertexData\n    };\n  }\n\n  var _decodeTriangleIndice = decodeTriangleIndices(view, vertexData, vertexDataEndPosition),\n      triangleIndices = _decodeTriangleIndice.triangleIndices,\n      triangleIndicesEndPosition = _decodeTriangleIndice.triangleIndicesEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices\n    };\n  }\n\n  var _decodeEdgeIndices = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition),\n      westIndices = _decodeEdgeIndices.westIndices,\n      southIndices = _decodeEdgeIndices.southIndices,\n      eastIndices = _decodeEdgeIndices.eastIndices,\n      northIndices = _decodeEdgeIndices.northIndices,\n      edgeIndicesEndPosition = _decodeEdgeIndices.edgeIndicesEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices,\n      westIndices: westIndices,\n      northIndices: northIndices,\n      eastIndices: eastIndices,\n      southIndices: southIndices\n    };\n  }\n\n  var _decodeExtensions = decodeExtensions(view, edgeIndicesEndPosition),\n      extensions = _decodeExtensions.extensions;\n\n  return {\n    header: header,\n    vertexData: vertexData,\n    triangleIndices: triangleIndices,\n    westIndices: westIndices,\n    northIndices: northIndices,\n    eastIndices: eastIndices,\n    southIndices: southIndices,\n    extensions: extensions\n  };\n}","map":{"version":3,"sources":["../../../src/lib/decode-quantized-mesh.ts"],"names":["QUANTIZED_MESH_HEADER","Float64Array","Float32Array","value","position","header","getter","bytesCount","dataView","headerEndPosition","elementsPerVertex","vertexCount","vertexData","Uint32Array","bytesPerArrayElement","Uint16Array","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","decodeZigZag","vertexDataEndPosition","encoded","bytesPerIndex","indices","highest","code","triangleCount","triangleIndicesCount","triangleIndices","decodeIndex","triangleIndicesEndPosition","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","extensionDataView","extensions","extensionsEndPosition","indicesEndPosition","extensionId","Uint8Array","extensionLength","extensionView","decodeVertexNormalsExtension","decodeWaterMaskExtension","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","options","Object","view","decodeHeader","decodeVertexData","decodeTriangleIndices","decodeEdgeIndices","decodeExtensions"],"mappings":"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","sourcesContent":["// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\ntype Extensions = {\n  vertexNormals?: any;\n  waterMask?: any;\n};\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions: Extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition} =\n    decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n"]},"metadata":{},"sourceType":"module"}