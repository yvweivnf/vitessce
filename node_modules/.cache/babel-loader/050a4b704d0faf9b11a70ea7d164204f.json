{"ast":null,"code":"import { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\n\nfunction addDimension(dims, channel, fieldDef, model) {\n  var _a;\n\n  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {\n      suffix: 'end'\n    }));\n\n    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {\n        binSuffix: 'range'\n      }));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    const posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n\n  if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {\n    dims.add(fieldDef.scale.range.field);\n  }\n\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures, childMeasures) {\n  var _a;\n\n  for (const field of keys(childMeasures)) {\n    // when we merge a measure, we either have to add an aggregation operator or even a new field\n    const ops = childMeasures[field];\n\n    for (const op of keys(ops)) {\n      if (field in parentMeasures) {\n        // add operator to existing measure field\n        parentMeasures[field][op] = new Set([...((_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : []), ...ops[op]]);\n      } else {\n        parentMeasures[field] = {\n          [op]: ops[op]\n        };\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent, dimensions, measures) {\n    super(parent);\n    this.dimensions = dimensions;\n    this.measures = measures;\n  }\n\n  clone() {\n    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n  }\n\n  get groupBy() {\n    return this.dimensions;\n  }\n\n  static makeFromEncoding(parent, model) {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n    const meas = {};\n    const dims = new Set();\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      var _a, _b, _c, _d;\n\n      const {\n        aggregate,\n        field\n      } = fieldDef;\n\n      if (aggregate) {\n        if (aggregate === 'count') {\n          (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n          meas['*']['count'] = new Set([vgField(fieldDef, {\n            forAs: true\n          })]);\n        } else {\n          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n            const argField = aggregate[op];\n            (_b = meas[argField]) !== null && _b !== void 0 ? _b : meas[argField] = {};\n            meas[argField][op] = new Set([vgField({\n              op,\n              field: argField\n            }, {\n              forAs: true\n            })]);\n          } else {\n            (_c = meas[field]) !== null && _c !== void 0 ? _c : meas[field] = {};\n            meas[field][aggregate] = new Set([vgField(fieldDef, {\n              forAs: true\n            })]);\n          } // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n\n\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            (_d = meas[field]) !== null && _d !== void 0 ? _d : meas[field] = {};\n            meas[field]['min'] = new Set([vgField({\n              field,\n              aggregate: 'min'\n            }, {\n              forAs: true\n            })]);\n            meas[field]['max'] = new Set([vgField({\n              field,\n              aggregate: 'max'\n            }, {\n              forAs: true\n            })]);\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef, model);\n      }\n    });\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  static makeFromTransform(parent, t) {\n    var _a, _b, _c;\n\n    const dims = new Set();\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const {\n        op,\n        field,\n        as\n      } = s;\n\n      if (op) {\n        if (op === 'count') {\n          (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n          meas['*']['count'] = new Set([as ? as : vgField(s, {\n            forAs: true\n          })]);\n        } else {\n          (_b = meas[field]) !== null && _b !== void 0 ? _b : meas[field] = {};\n          meas[field][op] = new Set([as ? as : vgField(s, {\n            forAs: true\n          })]);\n        }\n      }\n    }\n\n    for (const s of (_c = t.groupby) !== null && _c !== void 0 ? _c : []) {\n      dims.add(s);\n    }\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  merge(other) {\n    if (setEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    } else {\n      log.debug('different dimensions, cannot merge');\n      return false;\n    }\n  }\n\n  addDimensions(fields) {\n    fields.forEach(this.dimensions.add, this.dimensions);\n  }\n\n  dependentFields() {\n    return new Set([...this.dimensions, ...keys(this.measures)]);\n  }\n\n  producedFields() {\n    const out = new Set();\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        const m = this.measures[field][op];\n\n        if (m.size === 0) {\n          out.add(`${op}_${field}`);\n        } else {\n          m.forEach(out.add, out);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  hash() {\n    return `Aggregate ${hash({\n      dimensions: this.dimensions,\n      measures: this.measures\n    })}`;\n  }\n\n  assemble() {\n    const ops = [];\n    const fields = [];\n    const as = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of this.measures[field][op]) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(field === '*' ? null : replacePathInField(field));\n        }\n      }\n    }\n\n    const result = {\n      type: 'aggregate',\n      groupby: [...this.dimensions].map(replacePathInField),\n      ops,\n      fields,\n      as\n    };\n    return result;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nfunction addDimension(dims, channel, fieldDef, model) {\n    var _a;\n    const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n    if (isTypedFieldDef(fieldDef) &&\n        isUnitModel(model) &&\n        hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n        dims.add(vgField(fieldDef, {}));\n        dims.add(vgField(fieldDef, { suffix: 'end' }));\n        if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n            dims.add(vgField(fieldDef, { binSuffix: 'range' }));\n        }\n    }\n    else if (isGeoPositionChannel(channel)) {\n        const posChannel = getPositionChannelFromLatLong(channel);\n        dims.add(model.getName(posChannel));\n    }\n    else {\n        dims.add(vgField(fieldDef));\n    }\n    if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {\n        dims.add(fieldDef.scale.range.field);\n    }\n    return dims;\n}\nfunction mergeMeasures(parentMeasures, childMeasures) {\n    var _a;\n    for (const field of keys(childMeasures)) {\n        // when we merge a measure, we either have to add an aggregation operator or even a new field\n        const ops = childMeasures[field];\n        for (const op of keys(ops)) {\n            if (field in parentMeasures) {\n                // add operator to existing measure field\n                parentMeasures[field][op] = new Set([...((_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : []), ...ops[op]]);\n            }\n            else {\n                parentMeasures[field] = { [op]: ops[op] };\n            }\n        }\n    }\n}\nexport class AggregateNode extends DataFlowNode {\n    /**\n     * @param dimensions string set for dimensions\n     * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n     */\n    constructor(parent, dimensions, measures) {\n        super(parent);\n        this.dimensions = dimensions;\n        this.measures = measures;\n    }\n    clone() {\n        return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n    }\n    get groupBy() {\n        return this.dimensions;\n    }\n    static makeFromEncoding(parent, model) {\n        let isAggregate = false;\n        model.forEachFieldDef(fd => {\n            if (fd.aggregate) {\n                isAggregate = true;\n            }\n        });\n        const meas = {};\n        const dims = new Set();\n        if (!isAggregate) {\n            // no need to create this node if the model has no aggregation\n            return null;\n        }\n        model.forEachFieldDef((fieldDef, channel) => {\n            var _a, _b, _c, _d;\n            const { aggregate, field } = fieldDef;\n            if (aggregate) {\n                if (aggregate === 'count') {\n                    (_a = meas['*']) !== null && _a !== void 0 ? _a : (meas['*'] = {});\n                    meas['*']['count'] = new Set([vgField(fieldDef, { forAs: true })]);\n                }\n                else {\n                    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n                        const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n                        const argField = aggregate[op];\n                        (_b = meas[argField]) !== null && _b !== void 0 ? _b : (meas[argField] = {});\n                        meas[argField][op] = new Set([vgField({ op, field: argField }, { forAs: true })]);\n                    }\n                    else {\n                        (_c = meas[field]) !== null && _c !== void 0 ? _c : (meas[field] = {});\n                        meas[field][aggregate] = new Set([vgField(fieldDef, { forAs: true })]);\n                    }\n                    // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n                    if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n                        (_d = meas[field]) !== null && _d !== void 0 ? _d : (meas[field] = {});\n                        meas[field]['min'] = new Set([vgField({ field, aggregate: 'min' }, { forAs: true })]);\n                        meas[field]['max'] = new Set([vgField({ field, aggregate: 'max' }, { forAs: true })]);\n                    }\n                }\n            }\n            else {\n                addDimension(dims, channel, fieldDef, model);\n            }\n        });\n        if (dims.size + keys(meas).length === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    }\n    static makeFromTransform(parent, t) {\n        var _a, _b, _c;\n        const dims = new Set();\n        const meas = {};\n        for (const s of t.aggregate) {\n            const { op, field, as } = s;\n            if (op) {\n                if (op === 'count') {\n                    (_a = meas['*']) !== null && _a !== void 0 ? _a : (meas['*'] = {});\n                    meas['*']['count'] = new Set([as ? as : vgField(s, { forAs: true })]);\n                }\n                else {\n                    (_b = meas[field]) !== null && _b !== void 0 ? _b : (meas[field] = {});\n                    meas[field][op] = new Set([as ? as : vgField(s, { forAs: true })]);\n                }\n            }\n        }\n        for (const s of (_c = t.groupby) !== null && _c !== void 0 ? _c : []) {\n            dims.add(s);\n        }\n        if (dims.size + keys(meas).length === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    }\n    merge(other) {\n        if (setEqual(this.dimensions, other.dimensions)) {\n            mergeMeasures(this.measures, other.measures);\n            return true;\n        }\n        else {\n            log.debug('different dimensions, cannot merge');\n            return false;\n        }\n    }\n    addDimensions(fields) {\n        fields.forEach(this.dimensions.add, this.dimensions);\n    }\n    dependentFields() {\n        return new Set([...this.dimensions, ...keys(this.measures)]);\n    }\n    producedFields() {\n        const out = new Set();\n        for (const field of keys(this.measures)) {\n            for (const op of keys(this.measures[field])) {\n                const m = this.measures[field][op];\n                if (m.size === 0) {\n                    out.add(`${op}_${field}`);\n                }\n                else {\n                    m.forEach(out.add, out);\n                }\n            }\n        }\n        return out;\n    }\n    hash() {\n        return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;\n    }\n    assemble() {\n        const ops = [];\n        const fields = [];\n        const as = [];\n        for (const field of keys(this.measures)) {\n            for (const op of keys(this.measures[field])) {\n                for (const alias of this.measures[field][op]) {\n                    as.push(alias);\n                    ops.push(op);\n                    fields.push(field === '*' ? null : replacePathInField(field));\n                }\n            }\n        }\n        const result = {\n            type: 'aggregate',\n            groupby: [...this.dimensions].map(replacePathInField),\n            ops,\n            fields,\n            as\n        };\n        return result;\n    }\n}\n//# sourceMappingURL=aggregate.js.map"]},"metadata":{},"sourceType":"module"}