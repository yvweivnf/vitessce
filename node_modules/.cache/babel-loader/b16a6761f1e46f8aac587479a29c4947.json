{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nexport default function fetchProgress(_x, _x2) {\n  return _fetchProgress.apply(this, arguments);\n}\n\nfunction _fetchProgress() {\n  _fetchProgress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(response, onProgress) {\n    var onDone,\n        onError,\n        body,\n        contentLength,\n        totalBytes,\n        progressStream,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            onDone = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : function () {};\n            onError = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : function () {};\n            _context2.next = 4;\n            return response;\n\n          case 4:\n            response = _context2.sent;\n\n            if (response.ok) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 7:\n            body = response.body;\n\n            if (body) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 10:\n            contentLength = response.headers.get('content-length') || 0;\n            totalBytes = contentLength && parseInt(contentLength);\n\n            if (contentLength > 0) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 14:\n            if (!(typeof ReadableStream === 'undefined' || !body.getReader)) {\n              _context2.next = 16;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 16:\n            progressStream = new ReadableStream({\n              start: function start(controller) {\n                return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  var reader;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          reader = body.getReader();\n                          _context.next = 3;\n                          return read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n\n                        case 3:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }))();\n              }\n            });\n            return _context2.abrupt(\"return\", new Response(progressStream));\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fetchProgress.apply(this, arguments);\n}\n\nfunction read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n  return _read.apply(this, arguments);\n}\n\nfunction _read() {\n  _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n    var _yield$reader$read, done, value, percent;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return reader.read();\n\n          case 3:\n            _yield$reader$read = _context3.sent;\n            done = _yield$reader$read.done;\n            value = _yield$reader$read.value;\n\n            if (!done) {\n              _context3.next = 10;\n              break;\n            }\n\n            onDone();\n            controller.close();\n            return _context3.abrupt(\"return\");\n\n          case 10:\n            loadedBytes += value.byteLength;\n            percent = Math.round(loadedBytes / totalBytes * 100);\n            onProgress(percent, {\n              loadedBytes: loadedBytes,\n              totalBytes: totalBytes\n            });\n            controller.enqueue(value);\n            _context3.next = 16;\n            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n\n          case 16:\n            _context3.next = 22;\n            break;\n\n          case 18:\n            _context3.prev = 18;\n            _context3.t0 = _context3[\"catch\"](0);\n            controller.error(_context3.t0);\n            onError(_context3.t0);\n\n          case 22:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 18]]);\n  }));\n  return _read.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/progress/fetch-progress.ts"],"names":["onDone","onError","response","body","contentLength","totalBytes","parseInt","progressStream","reader","read","value","controller","loadedBytes","percent","Math","onProgress"],"mappings":";;AAKA,wBAAe,aAAf;AAAA;AAAA;;;4EAAe,kBAAA,QAAA,EAAA,UAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGbA,YAAAA,MAHa,8DAGJ,YAAM,CAHF,CAAA;AAIbC,YAAAA,OAJa,8DAIH,YAAM,CAJH,CAAA;AAAA;AAAA,mBAMbC,QANa;;AAAA;AAMbA,YAAAA,QANa;;AAAA,gBAORA,QAAQ,CAAb,EAPa;AAAA;AAAA;AAAA;;AAAA,8CASX,QATW;;AAAA;AAWPC,YAAAA,IAXO,GAWAD,QAAQ,CAArB,IAXa;;AAAA,gBAYb,IAZa;AAAA;AAAA;AAAA;;AAAA,8CAcX,QAdW;;AAAA;AAgBPE,YAAAA,aAhBO,GAgBSF,QAAQ,CAARA,OAAAA,CAAAA,GAAAA,CAAAA,gBAAAA,KAAtB,CAhBa;AAiBPG,YAAAA,UAjBO,GAiBMD,aAAa,IAAIE,QAAQ,CAA5C,aAA4C,CAjB/B;;AAAA,gBAkBPF,aAAa,GAAnB,CAlBa;AAAA;AAAA;AAAA;;AAAA,8CAmBX,QAnBW;;AAAA;AAAA,kBAsBT,OAAA,cAAA,KAAA,WAAA,IAAyC,CAACD,IAAI,CAAlD,SAtBa;AAAA;AAAA;AAAA;;AAAA,8CAuBX,QAvBW;;AAAA;AA2BPI,YAAAA,cA3BO,GA2BU,IAAA,cAAA,CAAmB;AACxC,cAAA,KADwC,iBACxC,UADwC,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAChBC,0BAAAA,MADgB,GACPL,IAAI,CAAnB,SAAeA,EADO;AAAA;AAAA,iCAEhBM,IAAI,CAAA,UAAA,EAAA,MAAA,EAAA,CAAA,EAAA,UAAA,EAAA,UAAA,EAAA,MAAA,EAAV,OAAU,CAFY;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGvB;AAJuC,aAAnB,CA3BV;AAAA,8CAkCN,IAAA,QAAA,CAAP,cAAO,CAlCM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAwCf,I;;;;;mEAAA,kBAAA,UAAA,EAAA,MAAA,EAAA,WAAA,EAAA,UAAA,EAAA,UAAA,EAAA,MAAA,EAAA,OAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAEgCD,MAAM,CAAlC,IAA4BA,EAFhC;;AAAA;AAAA;AAEU,YAAA,IAFV,sBAEU,IAFV;AAEiBE,YAAAA,KAFjB,sBAEiBA,KAFjB;;AAAA,iBAGI,IAHJ;AAAA;AAAA;AAAA;;AAIMV,YAAAA,MAAM;AACNW,YAAAA,UAAU,CAAVA,KAAAA;AALN;;AAAA;AAQIC,YAAAA,WAAW,IAAIF,KAAK,CAApBE,UAAAA;AACMC,YAAAA,OATV,GASoBC,IAAI,CAAJA,KAAAA,CAAYF,WAAW,GAAZ,UAACA,GAA5B,GAAgBE,CATpB;AAUIC,YAAAA,UAAU,CAAA,OAAA,EAAU;AAACH,cAAAA,WAAD,EAACA,WAAD;AAAcP,cAAAA,UAAAA,EAAAA;AAAd,aAAV,CAAVU;AACAJ,YAAAA,UAAU,CAAVA,OAAAA,CAAAA,KAAAA;AAXJ;AAAA,mBAYUF,IAAI,CAAA,UAAA,EAAA,MAAA,EAAA,WAAA,EAAA,UAAA,EAAA,UAAA,EAAA,MAAA,EAAV,OAAU,CAZd;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAcIE,YAAAA,UAAU,CAAVA,KAAAA;AACAV,YAAAA,OAAAA,cAAAA;;AAfJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n\n/**\n * Intercepts the Response stream and creates a new Response\n */\nexport default async function fetchProgress(\n  response: Response | Promise<Response>,\n  onProgress: any, // TODO better callback types\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  const body = response.body;\n  if (!body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length') || 0;\n  const totalBytes = contentLength && parseInt(contentLength);\n  if (!(contentLength > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    async start(controller) {\n      const reader = body.getReader();\n      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}