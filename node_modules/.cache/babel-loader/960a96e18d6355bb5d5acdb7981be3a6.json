{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport var Split = /*#__PURE__*/function () {\n  function Split() {\n    var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var implicit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Split);\n\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n\n  _createClass(Split, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Split(duplicate(this.explicit), duplicate(this.implicit));\n    }\n  }, {\n    key: \"combine\",\n    value: function combine() {\n      return Object.assign(Object.assign({}, this.explicit), this.implicit);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      // Explicit has higher precedence\n      return getFirstDefined(this.explicit[key], this.implicit[key]);\n    }\n  }, {\n    key: \"getWithExplicit\",\n    value: function getWithExplicit(key) {\n      // Explicit has higher precedence\n      if (this.explicit[key] !== undefined) {\n        return {\n          explicit: true,\n          value: this.explicit[key]\n        };\n      } else if (this.implicit[key] !== undefined) {\n        return {\n          explicit: false,\n          value: this.implicit[key]\n        };\n      }\n\n      return {\n        explicit: false,\n        value: undefined\n      };\n    }\n  }, {\n    key: \"setWithExplicit\",\n    value: function setWithExplicit(key, _ref) {\n      var value = _ref.value,\n          explicit = _ref.explicit;\n\n      if (value !== undefined) {\n        this.set(key, value, explicit);\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value, explicit) {\n      delete this[explicit ? 'implicit' : 'explicit'][key];\n      this[explicit ? 'explicit' : 'implicit'][key] = value;\n      return this;\n    }\n  }, {\n    key: \"copyKeyFromSplit\",\n    value: function copyKeyFromSplit(key, _ref2) {\n      var explicit = _ref2.explicit,\n          implicit = _ref2.implicit;\n\n      // Explicit has higher precedence\n      if (explicit[key] !== undefined) {\n        this.set(key, explicit[key], true);\n      } else if (implicit[key] !== undefined) {\n        this.set(key, implicit[key], false);\n      }\n    }\n  }, {\n    key: \"copyKeyFromObject\",\n    value: function copyKeyFromObject(key, s) {\n      // Explicit has higher precedence\n      if (s[key] !== undefined) {\n        this.set(key, s[key], true);\n      }\n    }\n    /**\n     * Merge split object into this split object. Properties from the other split\n     * overwrite properties from this split.\n     */\n\n  }, {\n    key: \"copyAll\",\n    value: function copyAll(other) {\n      var _iterator = _createForOfIteratorHelper(keys(other.combine())),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var val = other.getWithExplicit(key);\n          this.setWithExplicit(key, val);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return Split;\n}();\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value: value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value: value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return function (v1, v2, property, propertyOf) {\n    var diff = compare(v1.value, v2.value);\n\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, prefer v1.\n\n\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf) {\n  var tieBreaker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultTieBreaker;\n\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":{"version":3,"sources":["../../../src/compile/split.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split {\n    constructor(explicit = {}, implicit = {}) {\n        this.explicit = explicit;\n        this.implicit = implicit;\n    }\n    clone() {\n        return new Split(duplicate(this.explicit), duplicate(this.implicit));\n    }\n    combine() {\n        return Object.assign(Object.assign({}, this.explicit), this.implicit);\n    }\n    get(key) {\n        // Explicit has higher precedence\n        return getFirstDefined(this.explicit[key], this.implicit[key]);\n    }\n    getWithExplicit(key) {\n        // Explicit has higher precedence\n        if (this.explicit[key] !== undefined) {\n            return { explicit: true, value: this.explicit[key] };\n        }\n        else if (this.implicit[key] !== undefined) {\n            return { explicit: false, value: this.implicit[key] };\n        }\n        return { explicit: false, value: undefined };\n    }\n    setWithExplicit(key, { value, explicit }) {\n        if (value !== undefined) {\n            this.set(key, value, explicit);\n        }\n    }\n    set(key, value, explicit) {\n        delete this[explicit ? 'implicit' : 'explicit'][key];\n        this[explicit ? 'explicit' : 'implicit'][key] = value;\n        return this;\n    }\n    copyKeyFromSplit(key, { explicit, implicit }) {\n        // Explicit has higher precedence\n        if (explicit[key] !== undefined) {\n            this.set(key, explicit[key], true);\n        }\n        else if (implicit[key] !== undefined) {\n            this.set(key, implicit[key], false);\n        }\n    }\n    copyKeyFromObject(key, s) {\n        // Explicit has higher precedence\n        if (s[key] !== undefined) {\n            this.set(key, s[key], true);\n        }\n    }\n    /**\n     * Merge split object into this split object. Properties from the other split\n     * overwrite properties from this split.\n     */\n    copyAll(other) {\n        for (const key of keys(other.combine())) {\n            const val = other.getWithExplicit(key);\n            this.setWithExplicit(key, val);\n        }\n    }\n}\nexport function makeExplicit(value) {\n    return {\n        explicit: true,\n        value\n    };\n}\nexport function makeImplicit(value) {\n    return {\n        explicit: false,\n        value\n    };\n}\nexport function tieBreakByComparing(compare) {\n    return (v1, v2, property, propertyOf) => {\n        const diff = compare(v1.value, v2.value);\n        if (diff > 0) {\n            return v1;\n        }\n        else if (diff < 0) {\n            return v2;\n        }\n        return defaultTieBreaker(v1, v2, property, propertyOf);\n    };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n    if (v1.explicit && v2.explicit) {\n        log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n    }\n    // If equal score, prefer v1.\n    return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {\n    if (v1 === undefined || v1.value === undefined) {\n        // For first run\n        return v2;\n    }\n    if (v1.explicit && !v2.explicit) {\n        return v1;\n    }\n    else if (v2.explicit && !v1.explicit) {\n        return v2;\n    }\n    else if (deepEqual(v1.value, v2.value)) {\n        return v1;\n    }\n    else {\n        return tieBreaker(v1, v2, property, propertyOf);\n    }\n}\n//# sourceMappingURL=split.js.map"]},"metadata":{},"sourceType":"module"}