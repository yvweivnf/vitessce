{"ast":null,"code":"import { vgField } from '../../channeldef';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { facetSortFieldName } from '../facet';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nexport function makeJoinAggregateFromFacet(parent, facet) {\n  const {\n    row,\n    column\n  } = facet;\n\n  if (row && column) {\n    let newParent = null; // only need to make one for crossed facet\n\n    for (const fieldDef of [row, column]) {\n      if (isSortField(fieldDef.sort)) {\n        const {\n          field,\n          op = DEFAULT_SORT_OP\n        } = fieldDef.sort;\n        parent = newParent = new JoinAggregateTransformNode(parent, {\n          joinaggregate: [{\n            op,\n            field,\n            as: facetSortFieldName(fieldDef, fieldDef.sort, {\n              forAs: true\n            })\n          }],\n          groupby: [vgField(fieldDef)]\n        });\n      }\n    }\n\n    return newParent;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../../../src/compile/data/joinaggregatefacet.ts"],"names":[],"mappings":"AAAA,SAAQ,OAAR,QAAsB,kBAAtB;AACA,SAAQ,eAAR,EAAyB,WAAzB,QAA2C,YAA3C;AAEA,SAAQ,kBAAR,QAAiC,UAAjC;AAEA,SAAQ,0BAAR,QAAyC,iBAAzC;AAEA,OAAM,SAAU,0BAAV,CACJ,MADI,EAEJ,KAFI,EAEuB;AAE3B,QAAM;AAAC,IAAA,GAAD;AAAM,IAAA;AAAN,MAAgB,KAAtB;;AACA,MAAI,GAAG,IAAI,MAAX,EAAmB;AACjB,QAAI,SAAS,GAAG,IAAhB,CADiB,CAEjB;;AACA,SAAK,MAAM,QAAX,IAAuB,CAAC,GAAD,EAAM,MAAN,CAAvB,EAAsC;AACpC,UAAI,WAAW,CAAC,QAAQ,CAAC,IAAV,CAAf,EAAgC;AAC9B,cAAM;AAAC,UAAA,KAAD;AAAQ,UAAA,EAAE,GAAG;AAAb,YAAgC,QAAQ,CAAC,IAA/C;AACA,QAAA,MAAM,GAAG,SAAS,GAAG,IAAI,0BAAJ,CAA+B,MAA/B,EAAuC;AAC1D,UAAA,aAAa,EAAE,CACb;AACE,YAAA,EADF;AAEE,YAAA,KAFF;AAGE,YAAA,EAAE,EAAE,kBAAkB,CAAC,QAAD,EAAW,QAAQ,CAAC,IAApB,EAA0B;AAAC,cAAA,KAAK,EAAE;AAAR,aAA1B;AAHxB,WADa,CAD2C;AAQ1D,UAAA,OAAO,EAAE,CAAC,OAAO,CAAC,QAAD,CAAR;AARiD,SAAvC,CAArB;AAUD;AACF;;AACD,WAAO,SAAP;AACD;;AACD,SAAO,IAAP;AACD","sourceRoot":"","sourcesContent":["import { vgField } from '../../channeldef';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { facetSortFieldName } from '../facet';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nexport function makeJoinAggregateFromFacet(parent, facet) {\n    const { row, column } = facet;\n    if (row && column) {\n        let newParent = null;\n        // only need to make one for crossed facet\n        for (const fieldDef of [row, column]) {\n            if (isSortField(fieldDef.sort)) {\n                const { field, op = DEFAULT_SORT_OP } = fieldDef.sort;\n                parent = newParent = new JoinAggregateTransformNode(parent, {\n                    joinaggregate: [\n                        {\n                            op,\n                            field,\n                            as: facetSortFieldName(fieldDef, fieldDef.sort, { forAs: true })\n                        }\n                    ],\n                    groupby: [vgField(fieldDef)]\n                });\n            }\n        }\n        return newParent;\n    }\n    return null;\n}\n//# sourceMappingURL=joinaggregatefacet.js.map"]},"metadata":{},"sourceType":"module"}