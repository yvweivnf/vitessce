{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { h3ToGeoBoundary, h3GetResolution, h3ToGeo, geoToH3, h3IsPentagon, h3Distance, edgeLength, UNITS } from 'h3-js';\nimport { lerp } from 'math.gl';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nvar UPDATE_THRESHOLD_KM = 10;\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n\n  var _iterator = _createForOfIteratorHelper(vertices),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pt = _step.value;\n      var deltaLng = pt[0] - refLng;\n\n      if (deltaLng > 180) {\n        pt[0] -= 360;\n      } else if (deltaLng < -180) {\n        pt[0] += 360;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport function scalePolygon(hexId, vertices, factor) {\n  var _h3ToGeo = h3ToGeo(hexId),\n      _h3ToGeo2 = _slicedToArray(_h3ToGeo, 2),\n      lat = _h3ToGeo2[0],\n      lng = _h3ToGeo2[1];\n\n  var actualCount = vertices.length;\n  normalizeLongitudes(vertices, lng);\n  var vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n\n  for (var i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  var hexagonId = getHexagon(object, objectInfo);\n\n  var _h3ToGeo3 = h3ToGeo(hexagonId),\n      _h3ToGeo4 = _slicedToArray(_h3ToGeo3, 2),\n      lat = _h3ToGeo4[0],\n      lng = _h3ToGeo4[1];\n\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId) {\n  var coverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var flatten = arguments.length > 2 ? arguments[2] : undefined;\n  var vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    var positions = new Float64Array(vertices.length * 2);\n    var i = 0;\n\n    var _iterator2 = _createForOfIteratorHelper(vertices),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var pt = _step2.value;\n        positions[i++] = pt[0];\n        positions[i++] = pt[1];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  var trigger;\n\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = _objectSpread({}, getHexagon, {\n      coverage: coverage\n    });\n  } else {\n    trigger = {\n      getHexagon: getHexagon,\n      coverage: coverage\n    };\n  }\n\n  return trigger;\n}\n\nvar defaultProps = _objectSpread({}, PolygonLayer.defaultProps, {\n  highPrecision: 'auto',\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.hexagon;\n    }\n  },\n  extruded: true\n});\n\ndelete defaultProps.getLineDashArray;\n\nvar H3HexagonLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(H3HexagonLayer, _CompositeLayer);\n\n  var _super = _createSuper(H3HexagonLayer);\n\n  function H3HexagonLayer() {\n    _classCallCheck(this, H3HexagonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(H3HexagonLayer, [{\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon)) {\n        var dataProps = this._calculateH3DataProps(props);\n\n        this.setState(dataProps);\n      }\n\n      this._updateVertices(this.context.viewport);\n    }\n  }, {\n    key: \"_calculateH3DataProps\",\n    value: function _calculateH3DataProps(props) {\n      var resolution = -1;\n      var hasPentagon = false;\n      var hasMultipleRes = false;\n\n      var _createIterable = createIterable(props.data),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iterator3 = _createForOfIteratorHelper(iterable),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var object = _step3.value;\n          objectInfo.index++;\n          var hexId = props.getHexagon(object, objectInfo);\n          var hexResolution = h3GetResolution(hexId);\n\n          if (resolution < 0) {\n            resolution = hexResolution;\n            if (!props.highPrecision) break;\n          } else if (resolution !== hexResolution) {\n            hasMultipleRes = true;\n            break;\n          }\n\n          if (h3IsPentagon(hexId)) {\n            hasPentagon = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return {\n        resolution: resolution,\n        edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n        hasMultipleRes: hasMultipleRes,\n        hasPentagon: hasPentagon\n      };\n    }\n  }, {\n    key: \"_shouldUseHighPrecision\",\n    value: function _shouldUseHighPrecision() {\n      if (this.props.highPrecision === 'auto') {\n        var _this$state = this.state,\n            resolution = _this$state.resolution,\n            hasPentagon = _this$state.hasPentagon,\n            hasMultipleRes = _this$state.hasMultipleRes;\n        var viewport = this.context.viewport;\n        return viewport.resolution || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n      }\n\n      return this.props.highPrecision;\n    }\n  }, {\n    key: \"_updateVertices\",\n    value: function _updateVertices(viewport) {\n      if (this._shouldUseHighPrecision()) {\n        return;\n      }\n\n      var _this$state2 = this.state,\n          resolution = _this$state2.resolution,\n          edgeLengthKM = _this$state2.edgeLengthKM,\n          centerHex = _this$state2.centerHex;\n\n      if (resolution < 0) {\n        return;\n      }\n\n      var hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n\n      if (centerHex === hex) {\n        return;\n      }\n\n      if (centerHex) {\n        var distance = h3Distance(centerHex, hex);\n\n        if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      }\n\n      var unitsPerMeter = viewport.distanceScales.unitsPerMeter;\n      var vertices = h3ToPolygon(hex);\n\n      var _h3ToGeo5 = h3ToGeo(hex),\n          _h3ToGeo6 = _slicedToArray(_h3ToGeo5, 2),\n          centerLat = _h3ToGeo6[0],\n          centerLng = _h3ToGeo6[1];\n\n      var _viewport$projectFlat = viewport.projectFlat([centerLng, centerLat]),\n          _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),\n          centerX = _viewport$projectFlat2[0],\n          centerY = _viewport$projectFlat2[1];\n\n      vertices = vertices.map(function (p) {\n        var worldPosition = viewport.projectFlat(p);\n        return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];\n      });\n      this.setState({\n        centerHex: hex,\n        vertices: vertices\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n    }\n  }, {\n    key: \"_getForwardProps\",\n    value: function _getForwardProps() {\n      var _this$props = this.props,\n          elevationScale = _this$props.elevationScale,\n          material = _this$props.material,\n          coverage = _this$props.coverage,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe,\n          stroked = _this$props.stroked,\n          filled = _this$props.filled,\n          lineWidthUnits = _this$props.lineWidthUnits,\n          lineWidthScale = _this$props.lineWidthScale,\n          lineWidthMinPixels = _this$props.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props.lineWidthMaxPixels,\n          getFillColor = _this$props.getFillColor,\n          getElevation = _this$props.getElevation,\n          getLineColor = _this$props.getLineColor,\n          getLineWidth = _this$props.getLineWidth,\n          transitions = _this$props.transitions,\n          updateTriggers = _this$props.updateTriggers;\n      return {\n        elevationScale: elevationScale,\n        extruded: extruded,\n        coverage: coverage,\n        wireframe: wireframe,\n        stroked: stroked,\n        filled: filled,\n        lineWidthUnits: lineWidthUnits,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        material: material,\n        getElevation: getElevation,\n        getFillColor: getFillColor,\n        getLineColor: getLineColor,\n        getLineWidth: getLineWidth,\n        transitions: transitions,\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getElevation: updateTriggers.getElevation,\n          getLineColor: updateTriggers.getLineColor,\n          getLineWidth: updateTriggers.getLineWidth\n        }\n      };\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getHexagon = _this$props2.getHexagon,\n          updateTriggers = _this$props2.updateTriggers,\n          coverage = _this$props2.coverage;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n\n      var forwardProps = this._getForwardProps();\n\n      forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: function getPolygon(object, objectInfo) {\n          var hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      });\n    }\n  }, {\n    key: \"_renderColumnLayer\",\n    value: function _renderColumnLayer() {\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          getHexagon = _this$props3.getHexagon,\n          updateTriggers = _this$props3.updateTriggers;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n\n      var forwardProps = this._getForwardProps();\n\n      forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        diskResolution: 6,\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      });\n    }\n  }]);\n\n  return H3HexagonLayer;\n}(CompositeLayer);\n\nexport { H3HexagonLayer as default };\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';","map":{"version":3,"sources":["../../../src/h3-layers/h3-hexagon-layer.js"],"names":["UPDATE_THRESHOLD_KM","refLng","vertices","deltaLng","pt","h3ToGeo","actualCount","normalizeLongitudes","vertexCount","i","lerp","hexagonId","getHexagon","coverage","flatten","h3ToGeoBoundary","scalePolygon","positions","trigger","defaultProps","PolygonLayer","highPrecision","type","min","max","value","centerHexagon","x","hexagon","extruded","changeFlags","props","dataProps","resolution","hasPentagon","hasMultipleRes","objectInfo","createIterable","hexId","hexResolution","h3GetResolution","h3IsPentagon","edgeLengthKM","edgeLength","UNITS","viewport","centerHex","hex","geoToH3","distance","h3Distance","unitsPerMeter","h3ToPolygon","p","worldPosition","updateTriggers","elevationScale","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","material","getElevation","getFillColor","getLineColor","getLineWidth","transitions","SubLayerClass","forwardProps","mergeTriggers","id","data","_normalize","_windingOrder","positionFormat","getPolygon","diskResolution","radius","getPosition","getHexagonCentroid","H3HexagonLayer"],"mappings":"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","sourcesContent":["import {\n  h3ToGeoBoundary,\n  h3GetResolution,\n  h3ToGeo,\n  geoToH3,\n  h3IsPentagon,\n  h3Distance,\n  edgeLength,\n  UNITS\n} from 'h3-js';\nimport {lerp} from 'math.gl';\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer} from '@deck.gl/layers';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId, vertices, factor) {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `h3ToGeoBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId, coverage = 1, flatten) {\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    const positions = new Float64Array(vertices.length * 2);\n    let i = 0;\n    for (const pt of vertices) {\n      positions[i++] = pt[0];\n      positions[i++] = pt[1];\n    }\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {...getHexagon, coverage};\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: x => x.hexagon},\n  extruded: true\n};\n\n// not supported\ndelete defaultProps.getLineDashArray;\n\n/**\n * A subclass of HexagonLayer that uses H3 hexagonIds in data objects\n * rather than centroid lat/longs. The shape of each hexagon is determined\n * based on a single \"center\" hexagon, which can be selected by passing in\n * a center lat/lon pair. If not provided, the map center will be used.\n *\n * Also sets the `hexagonId` field in the onHover/onClick callback's info\n * objects. Since this is calculated using math, hexagonId will be present\n * even when no corresponding hexagon is in the data set. You can check\n * index !== -1 to see if picking matches an actual object.\n */\nexport default class H3HexagonLayer extends CompositeLayer {\n  shouldUpdateState({changeFlags}) {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (\n      props.highPrecision !== true &&\n      (changeFlags.dataChanged ||\n        (changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon))\n    ) {\n      const dataProps = this._calculateH3DataProps(props);\n      this.setState(dataProps);\n    }\n\n    this._updateVertices(this.context.viewport);\n  }\n\n  _calculateH3DataProps(props) {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n\n    const {iterable, objectInfo} = createIterable(props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = h3GetResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (h3IsPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n\n  _shouldUseHighPrecision() {\n    if (this.props.highPrecision === 'auto') {\n      const {resolution, hasPentagon, hasMultipleRes} = this.state;\n      const {viewport} = this.context;\n      return (\n        viewport.resolution || hasMultipleRes || hasPentagon || (resolution >= 0 && resolution <= 5)\n      );\n    }\n\n    return this.props.highPrecision;\n  }\n\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n      // h3Distance returns a negative number if the distance could not be computed\n      // due to the two indexes very far apart or on opposite sides of a pentagon.\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [\n        (worldPosition[0] - centerX) / unitsPerMeter[0],\n        (worldPosition[1] - centerY) / unitsPerMeter[1]\n      ];\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n\n  _renderPolygonLayer() {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      }\n    );\n  }\n\n  _renderColumnLayer() {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';\n"]},"metadata":{},"sourceType":"module"}