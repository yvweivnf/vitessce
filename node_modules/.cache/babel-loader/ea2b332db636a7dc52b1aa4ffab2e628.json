{"ast":null,"code":"import { isObject, isNumber, degreesToRadians, polygon } from '@turf/helpers';\nimport rhumbDestination from '@turf/rhumb-destination';\nimport transformRotate from '@turf/transform-rotate';\nimport { getCoord } from '@turf/invariant';\n/**\n * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.\n *\n * @param {Coord} center center point\n * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis\n * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.angle=0] angle of rotation in decimal degrees, positive clockwise\n * @param {Coord} [options.pivot='origin'] point around which the rotation will be performed\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] unit of measurement for axes\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} ellipse polygon\n * @example\n * var center = [-75, 40];\n * var xSemiAxis = 5;\n * var ySemiAxis = 2;\n * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);\n *\n * //addToMap\n * var addToMap = [turf.point(center), ellipse]\n */\n\nfunction ellipse(center, xSemiAxis, ySemiAxis, options) {\n  // Optional params\n  options = options || {};\n  var steps = options.steps || 64;\n  var units = options.units || \"kilometers\";\n  var angle = options.angle || 0;\n  var pivot = options.pivot || center;\n  var properties = options.properties || center.properties || {}; // validation\n\n  if (!center) throw new Error(\"center is required\");\n  if (!xSemiAxis) throw new Error(\"xSemiAxis is required\");\n  if (!ySemiAxis) throw new Error(\"ySemiAxis is required\");\n  if (!isObject(options)) throw new Error(\"options must be an object\");\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isNumber(angle)) throw new Error(\"angle must be a number\");\n  var centerCoords = getCoord(center);\n\n  if (units === \"degrees\") {\n    var angleRad = degreesToRadians(angle);\n  } else {\n    xSemiAxis = rhumbDestination(center, xSemiAxis, 90, {\n      units: units\n    });\n    ySemiAxis = rhumbDestination(center, ySemiAxis, 0, {\n      units: units\n    });\n    xSemiAxis = getCoord(xSemiAxis)[0] - centerCoords[0];\n    ySemiAxis = getCoord(ySemiAxis)[1] - centerCoords[1];\n  }\n\n  var coordinates = [];\n\n  for (var i = 0; i < steps; i += 1) {\n    var stepAngle = i * -360 / steps;\n    var x = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2));\n    var y = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2));\n    if (stepAngle < -90 && stepAngle >= -270) x = -x;\n    if (stepAngle < -180 && stepAngle >= -360) y = -y;\n\n    if (units === \"degrees\") {\n      var newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);\n      var newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);\n      x = newx;\n      y = newy;\n    }\n\n    coordinates.push([x + centerCoords[0], y + centerCoords[1]]);\n  }\n\n  coordinates.push(coordinates[0]);\n\n  if (units === \"degrees\") {\n    return polygon([coordinates], properties);\n  } else {\n    return transformRotate(polygon([coordinates], properties), angle, {\n      pivot: pivot\n    });\n  }\n}\n/**\n * Get Tan Degrees\n *\n * @private\n * @param {number} deg Degrees\n * @returns {number} Tan Degrees\n */\n\n\nfunction getTanDeg(deg) {\n  var rad = deg * Math.PI / 180;\n  return Math.tan(rad);\n}\n\nexport default ellipse;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/ellipse/dist/es/index.js"],"names":["isObject","isNumber","degreesToRadians","polygon","rhumbDestination","transformRotate","getCoord","ellipse","center","xSemiAxis","ySemiAxis","options","steps","units","angle","pivot","properties","Error","centerCoords","angleRad","coordinates","i","stepAngle","x","Math","sqrt","pow","getTanDeg","y","newx","cos","sin","newy","push","deg","rad","PI","tan"],"mappings":"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","sourcesContent":["import { isObject, isNumber, degreesToRadians, polygon } from '@turf/helpers';\nimport rhumbDestination from '@turf/rhumb-destination';\nimport transformRotate from '@turf/transform-rotate';\nimport { getCoord } from '@turf/invariant';\n\n/**\n * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.\n *\n * @param {Coord} center center point\n * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis\n * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.angle=0] angle of rotation in decimal degrees, positive clockwise\n * @param {Coord} [options.pivot='origin'] point around which the rotation will be performed\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] unit of measurement for axes\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} ellipse polygon\n * @example\n * var center = [-75, 40];\n * var xSemiAxis = 5;\n * var ySemiAxis = 2;\n * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);\n *\n * //addToMap\n * var addToMap = [turf.point(center), ellipse]\n */\nfunction ellipse(center, xSemiAxis, ySemiAxis, options) {\n  // Optional params\n  options = options || {};\n  var steps = options.steps || 64;\n  var units = options.units || \"kilometers\";\n  var angle = options.angle || 0;\n  var pivot = options.pivot || center;\n  var properties = options.properties || center.properties || {};\n\n  // validation\n  if (!center) throw new Error(\"center is required\");\n  if (!xSemiAxis) throw new Error(\"xSemiAxis is required\");\n  if (!ySemiAxis) throw new Error(\"ySemiAxis is required\");\n  if (!isObject(options)) throw new Error(\"options must be an object\");\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isNumber(angle)) throw new Error(\"angle must be a number\");\n\n  var centerCoords = getCoord(center);\n  if (units === \"degrees\") {\n    var angleRad = degreesToRadians(angle);\n  } else {\n    xSemiAxis = rhumbDestination(center, xSemiAxis, 90, { units: units });\n    ySemiAxis = rhumbDestination(center, ySemiAxis, 0, { units: units });\n    xSemiAxis = getCoord(xSemiAxis)[0] - centerCoords[0];\n    ySemiAxis = getCoord(ySemiAxis)[1] - centerCoords[1];\n  }\n\n  var coordinates = [];\n  for (var i = 0; i < steps; i += 1) {\n    var stepAngle = (i * -360) / steps;\n    var x =\n      (xSemiAxis * ySemiAxis) /\n      Math.sqrt(\n        Math.pow(ySemiAxis, 2) +\n          Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)\n      );\n    var y =\n      (xSemiAxis * ySemiAxis) /\n      Math.sqrt(\n        Math.pow(xSemiAxis, 2) +\n          Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)\n      );\n\n    if (stepAngle < -90 && stepAngle >= -270) x = -x;\n    if (stepAngle < -180 && stepAngle >= -360) y = -y;\n    if (units === \"degrees\") {\n      var newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);\n      var newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);\n      x = newx;\n      y = newy;\n    }\n\n    coordinates.push([x + centerCoords[0], y + centerCoords[1]]);\n  }\n  coordinates.push(coordinates[0]);\n  if (units === \"degrees\") {\n    return polygon([coordinates], properties);\n  } else {\n    return transformRotate(polygon([coordinates], properties), angle, {\n      pivot: pivot,\n    });\n  }\n}\n\n/**\n * Get Tan Degrees\n *\n * @private\n * @param {number} deg Degrees\n * @returns {number} Tan Degrees\n */\nfunction getTanDeg(deg) {\n  var rad = (deg * Math.PI) / 180;\n  return Math.tan(rad);\n}\n\nexport default ellipse;\n"]},"metadata":{},"sourceType":"module"}