{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var GeoJSONNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(GeoJSONNode, _DataFlowNode);\n\n  var _super = _createSuper(GeoJSONNode);\n\n  function GeoJSONNode(parent, fields, geojson, signal) {\n    var _this;\n\n    _classCallCheck(this, GeoJSONNode);\n\n    _this = _super.call(this, parent);\n    _this.fields = fields;\n    _this.geojson = geojson;\n    _this.signal = signal;\n    return _this;\n  }\n\n  _createClass(GeoJSONNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var _a;\n\n      var fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString);\n      return new Set([].concat(_toConsumableArray(this.geojson ? [this.geojson] : []), _toConsumableArray(fields)));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set();\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"GeoJSON \".concat(this.geojson, \" \").concat(this.signal, \" \").concat(_hash(this.fields));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return [].concat(_toConsumableArray(this.geojson ? [{\n        type: 'filter',\n        expr: \"isValid(datum[\\\"\".concat(this.geojson, \"\\\"])\")\n      }] : []), [Object.assign(Object.assign(Object.assign({\n        type: 'geojson'\n      }, this.fields ? {\n        fields: this.fields\n      } : {}), this.geojson ? {\n        geojson: this.geojson\n      } : {}), {\n        signal: this.signal\n      })]);\n    }\n  }], [{\n    key: \"parseAll\",\n    value: function parseAll(parent, model) {\n      if (model.component.projection && !model.component.projection.isFit) {\n        return parent;\n      }\n\n      var geoJsonCounter = 0;\n\n      for (var _i = 0, _arr = [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]; _i < _arr.length; _i++) {\n        var coordinates = _arr[_i];\n        var pair = coordinates.map(function (channel) {\n          var def = getFieldOrDatumDef(model.encoding[channel]);\n          return isFieldDef(def) ? def.field : isDatumDef(def) ? {\n            expr: \"\".concat(def.datum)\n          } : isValueDef(def) ? {\n            expr: \"\".concat(def['value'])\n          } : undefined;\n        });\n\n        if (pair[0] || pair[1]) {\n          parent = new GeoJSONNode(parent, pair, null, model.getName(\"geojson_\".concat(geoJsonCounter++)));\n        }\n      }\n\n      if (model.channelHasField(SHAPE)) {\n        var fieldDef = model.typedFieldDef(SHAPE);\n\n        if (fieldDef.type === GEOJSON) {\n          parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(\"geojson_\".concat(geoJsonCounter++)));\n        }\n      }\n\n      return parent;\n    }\n  }]);\n\n  return GeoJSONNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/geojson.ts"],"names":[],"mappings":";;;;;AACA,SAAQ,QAAR,QAAuB,WAAvB;AACA,SAA4B,QAA5B,EAAsC,SAAtC,EAAiD,SAAjD,EAA4D,UAA5D,EAAwE,KAAxE,QAAoF,eAApF;AACA,SAAQ,kBAAR,EAA4B,UAA5B,EAAwC,UAAxC,EAAoD,UAApD,QAAqE,kBAArE;AACA,SAAQ,OAAR,QAAsB,YAAtB;AACA,SAAQ,SAAR,EAAmB,IAAI,IAAJ,KAAnB,QAA8B,YAA9B;AAGA,SAAQ,YAAR,QAA2B,YAA3B;AAEA,WAAa,WAAb;AAAA;;AAAA;;AA0CE,uBACE,MADF,EAEU,MAFV,EAGU,OAHV,EAIU,MAJV,EAIyB;AAAA;;AAAA;;AAEvB,8BAAM,MAAN;AAJQ,UAAA,MAAA,GAAA,MAAA;AACA,UAAA,OAAA,GAAA,OAAA;AACA,UAAA,MAAA,GAAA,MAAA;AAAe;AAGxB;;AAjDH;AAAA;AAAA,4BACc;AACV,aAAO,IAAI,WAAJ,CAAgB,IAAhB,EAAsB,SAAS,CAAC,KAAK,MAAN,CAA/B,EAA8C,KAAK,OAAnD,EAA4D,KAAK,MAAjE,CAAP;AACD;AAHH;AAAA;AAAA,sCAmDwB;;;AACpB,UAAM,MAAM,GAAG,CAAC,CAAA,EAAA,GAAA,KAAK,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,EAAX,GAAe,EAAhB,EAAoB,MAApB,CAA2B,QAA3B,CAAf;AACA,aAAO,IAAI,GAAJ,8BAAa,KAAK,OAAL,GAAe,CAAC,KAAK,OAAN,CAAf,GAAgC,EAA7C,sBAAqD,MAArD,GAAP;AACD;AAtDH;AAAA;AAAA,qCAwDuB;AACnB,aAAO,IAAI,GAAJ,EAAP;AACD;AA1DH;AAAA;AAAA,2BA4Da;AACT,+BAAkB,KAAK,OAAvB,cAAkC,KAAK,MAAvC,cAAiD,KAAI,CAAC,KAAK,MAAN,CAArD;AACD;AA9DH;AAAA;AAAA,+BAgEiB;AACb,0CACM,KAAK,OAAL,GACA,CACE;AACE,QAAA,IAAI,EAAE,QADR;AAEE,QAAA,IAAI,4BAAoB,KAAK,OAAzB;AAFN,OADF,CADA,GAOA,EARN,I;AAUI,QAAA,IAAI,EAAE;SACF,KAAK,MAAL,GAAc;AAAC,QAAA,MAAM,EAAE,KAAK;AAAd,OAAd,GAAsC,E,GACtC,KAAK,OAAL,GAAe;AAAC,QAAA,OAAO,EAAE,KAAK;AAAf,OAAf,GAAyC,E,GAAG;AAChD,QAAA,MAAM,EAAE,KAAK;AADmC,O,CAZpD;AAgBD;AAjFH;AAAA;AAAA,6BAKyB,MALzB,EAK+C,KAL/C,EAK+D;AAC3D,UAAI,KAAK,CAAC,SAAN,CAAgB,UAAhB,IAA8B,CAAC,KAAK,CAAC,SAAN,CAAgB,UAAhB,CAA2B,KAA9D,EAAqE;AACnE,eAAO,MAAP;AACD;;AAED,UAAI,cAAc,GAAG,CAArB;;AAEA,8BAA0B,CACxB,CAAC,SAAD,EAAY,QAAZ,CADwB,EAExB,CAAC,UAAD,EAAa,SAAb,CAFwB,CAA1B,0BAGoC;AAH/B,YAAM,WAAW,WAAjB;AAIH,YAAM,IAAI,GAAG,WAAW,CAAC,GAAZ,CAAgB,UAAA,OAAO,EAAG;AACrC,cAAM,GAAG,GAAG,kBAAkB,CAAC,KAAK,CAAC,QAAN,CAAe,OAAf,CAAD,CAA9B;AACA,iBAAO,UAAU,CAAC,GAAD,CAAV,GACH,GAAG,CAAC,KADD,GAEH,UAAU,CAAC,GAAD,CAAV,GACA;AAAC,YAAA,IAAI,YAAK,GAAG,CAAC,KAAT;AAAL,WADA,GAEA,UAAU,CAAC,GAAD,CAAV,GACA;AAAC,YAAA,IAAI,YAAK,GAAG,CAAC,OAAD,CAAR;AAAL,WADA,GAEA,SANJ;AAOD,SATY,CAAb;;AAWA,YAAI,IAAI,CAAC,CAAD,CAAJ,IAAW,IAAI,CAAC,CAAD,CAAnB,EAAwB;AACtB,UAAA,MAAM,GAAG,IAAI,WAAJ,CAAgB,MAAhB,EAAwB,IAAxB,EAA8B,IAA9B,EAAoC,KAAK,CAAC,OAAN,mBAAyB,cAAc,EAAvC,EAApC,CAAT;AACD;AACF;;AAED,UAAI,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAAJ,EAAkC;AAChC,YAAM,QAAQ,GAAG,KAAK,CAAC,aAAN,CAAoB,KAApB,CAAjB;;AACA,YAAI,QAAQ,CAAC,IAAT,KAAkB,OAAtB,EAA+B;AAC7B,UAAA,MAAM,GAAG,IAAI,WAAJ,CAAgB,MAAhB,EAAwB,IAAxB,EAA8B,QAAQ,CAAC,KAAvC,EAA8C,KAAK,CAAC,OAAN,mBAAyB,cAAc,EAAvC,EAA9C,CAAT;AACD;AACF;;AAED,aAAO,MAAP;AACD;AAxCH;;AAAA;AAAA,EAAiC,YAAjC","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoJSONNode extends DataFlowNode {\n    constructor(parent, fields, geojson, signal) {\n        super(parent);\n        this.fields = fields;\n        this.geojson = geojson;\n        this.signal = signal;\n    }\n    clone() {\n        return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n    }\n    static parseAll(parent, model) {\n        if (model.component.projection && !model.component.projection.isFit) {\n            return parent;\n        }\n        let geoJsonCounter = 0;\n        for (const coordinates of [\n            [LONGITUDE, LATITUDE],\n            [LONGITUDE2, LATITUDE2]\n        ]) {\n            const pair = coordinates.map(channel => {\n                const def = getFieldOrDatumDef(model.encoding[channel]);\n                return isFieldDef(def)\n                    ? def.field\n                    : isDatumDef(def)\n                        ? { expr: `${def.datum}` }\n                        : isValueDef(def)\n                            ? { expr: `${def['value']}` }\n                            : undefined;\n            });\n            if (pair[0] || pair[1]) {\n                parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n            }\n        }\n        if (model.channelHasField(SHAPE)) {\n            const fieldDef = model.typedFieldDef(SHAPE);\n            if (fieldDef.type === GEOJSON) {\n                parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n            }\n        }\n        return parent;\n    }\n    dependentFields() {\n        var _a;\n        const fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString);\n        return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);\n    }\n    producedFields() {\n        return new Set();\n    }\n    hash() {\n        return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;\n    }\n    assemble() {\n        return [\n            ...(this.geojson\n                ? [\n                    {\n                        type: 'filter',\n                        expr: `isValid(datum[\"${this.geojson}\"])`\n                    }\n                ]\n                : []),\n            Object.assign(Object.assign(Object.assign({ type: 'geojson' }, (this.fields ? { fields: this.fields } : {})), (this.geojson ? { geojson: this.geojson } : {})), { signal: this.signal })\n        ];\n    }\n}\n//# sourceMappingURL=geojson.js.map"]},"metadata":{},"sourceType":"module"}