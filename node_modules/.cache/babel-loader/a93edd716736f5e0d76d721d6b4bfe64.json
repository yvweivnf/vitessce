{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport var SpecMapper = /*#__PURE__*/function () {\n  function SpecMapper() {\n    _classCallCheck(this, SpecMapper);\n  }\n\n  _createClass(SpecMapper, [{\n    key: \"map\",\n    value: function map(spec, params) {\n      if (isFacetSpec(spec)) {\n        return this.mapFacet(spec, params);\n      } else if (isRepeatSpec(spec)) {\n        return this.mapRepeat(spec, params);\n      } else if (isHConcatSpec(spec)) {\n        return this.mapHConcat(spec, params);\n      } else if (isVConcatSpec(spec)) {\n        return this.mapVConcat(spec, params);\n      } else if (isConcatSpec(spec)) {\n        return this.mapConcat(spec, params);\n      } else {\n        return this.mapLayerOrUnit(spec, params);\n      }\n    }\n  }, {\n    key: \"mapLayerOrUnit\",\n    value: function mapLayerOrUnit(spec, params) {\n      if (isLayerSpec(spec)) {\n        return this.mapLayer(spec, params);\n      } else if (isUnitSpec(spec)) {\n        return this.mapUnit(spec, params);\n      }\n\n      throw new Error(log.message.invalidSpec(spec));\n    }\n  }, {\n    key: \"mapLayer\",\n    value: function mapLayer(spec, params) {\n      var _this = this;\n\n      return Object.assign(Object.assign({}, spec), {\n        layer: spec.layer.map(function (subspec) {\n          return _this.mapLayerOrUnit(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapHConcat\",\n    value: function mapHConcat(spec, params) {\n      var _this2 = this;\n\n      return Object.assign(Object.assign({}, spec), {\n        hconcat: spec.hconcat.map(function (subspec) {\n          return _this2.map(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapVConcat\",\n    value: function mapVConcat(spec, params) {\n      var _this3 = this;\n\n      return Object.assign(Object.assign({}, spec), {\n        vconcat: spec.vconcat.map(function (subspec) {\n          return _this3.map(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapConcat\",\n    value: function mapConcat(spec, params) {\n      var _this4 = this;\n\n      var concat = spec.concat,\n          rest = __rest(spec, [\"concat\"]);\n\n      return Object.assign(Object.assign({}, rest), {\n        concat: concat.map(function (subspec) {\n          return _this4.map(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapFacet\",\n    value: function mapFacet(spec, params) {\n      return Object.assign(Object.assign({}, spec), {\n        // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n        spec: this.map(spec.spec, params)\n      });\n    }\n  }, {\n    key: \"mapRepeat\",\n    value: function mapRepeat(spec, params) {\n      return Object.assign(Object.assign({}, spec), {\n        // as any is required here since TS cannot infer that the output type satisfies the input type\n        spec: this.map(spec.spec, params)\n      });\n    }\n  }]);\n\n  return SpecMapper;\n}();","map":{"version":3,"sources":["../../../src/spec/map.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport class SpecMapper {\n    map(spec, params) {\n        if (isFacetSpec(spec)) {\n            return this.mapFacet(spec, params);\n        }\n        else if (isRepeatSpec(spec)) {\n            return this.mapRepeat(spec, params);\n        }\n        else if (isHConcatSpec(spec)) {\n            return this.mapHConcat(spec, params);\n        }\n        else if (isVConcatSpec(spec)) {\n            return this.mapVConcat(spec, params);\n        }\n        else if (isConcatSpec(spec)) {\n            return this.mapConcat(spec, params);\n        }\n        else {\n            return this.mapLayerOrUnit(spec, params);\n        }\n    }\n    mapLayerOrUnit(spec, params) {\n        if (isLayerSpec(spec)) {\n            return this.mapLayer(spec, params);\n        }\n        else if (isUnitSpec(spec)) {\n            return this.mapUnit(spec, params);\n        }\n        throw new Error(log.message.invalidSpec(spec));\n    }\n    mapLayer(spec, params) {\n        return Object.assign(Object.assign({}, spec), { layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params)) });\n    }\n    mapHConcat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { hconcat: spec.hconcat.map(subspec => this.map(subspec, params)) });\n    }\n    mapVConcat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { vconcat: spec.vconcat.map(subspec => this.map(subspec, params)) });\n    }\n    mapConcat(spec, params) {\n        const { concat } = spec, rest = __rest(spec, [\"concat\"]);\n        return Object.assign(Object.assign({}, rest), { concat: concat.map(subspec => this.map(subspec, params)) });\n    }\n    mapFacet(spec, params) {\n        return Object.assign(Object.assign({}, spec), { \n            // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n            spec: this.map(spec.spec, params) });\n    }\n    mapRepeat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { \n            // as any is required here since TS cannot infer that the output type satisfies the input type\n            spec: this.map(spec.spec, params) });\n    }\n}\n//# sourceMappingURL=map.js.map"]},"metadata":{},"sourceType":"module"}