{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar BrowserFileSystem = /*#__PURE__*/function () {\n  function BrowserFileSystem(files, options) {\n    _classCallCheck(this, BrowserFileSystem);\n\n    _defineProperty(this, \"_fetch\", void 0);\n\n    _defineProperty(this, \"files\", {});\n\n    _defineProperty(this, \"lowerCaseFiles\", {});\n\n    _defineProperty(this, \"usedFiles\", {});\n\n    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;\n\n    for (var i = 0; i < files.length; ++i) {\n      var file = files[i];\n      this.files[file.name] = file;\n      this.lowerCaseFiles[file.name.toLowerCase()] = file;\n      this.usedFiles[file.name] = false;\n    }\n\n    this.fetch = this.fetch.bind(this);\n  }\n\n  _createClass(BrowserFileSystem, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, options) {\n        var file, headers, range, bytes, start, end, data, _response, response;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!path.includes('://')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this._fetch(path, options));\n\n              case 2:\n                file = this.files[path];\n\n                if (file) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", new Response(path, {\n                  status: 400,\n                  statusText: 'NOT FOUND'\n                }));\n\n              case 5:\n                headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);\n                range = headers.get('Range');\n                bytes = range && /bytes=($1)-($2)/.exec(range);\n\n                if (!bytes) {\n                  _context.next = 17;\n                  break;\n                }\n\n                start = parseInt(bytes[1]);\n                end = parseInt(bytes[2]);\n                _context.next = 13;\n                return file.slice(start, end).arrayBuffer();\n\n              case 13:\n                data = _context.sent;\n                _response = new Response(data);\n                Object.defineProperty(_response, 'url', {\n                  value: path\n                });\n                return _context.abrupt(\"return\", _response);\n\n              case 17:\n                response = new Response(file);\n                Object.defineProperty(response, 'url', {\n                  value: path\n                });\n                return _context.abrupt(\"return\", response);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetch(_x, _x2) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n  }, {\n    key: \"readdir\",\n    value: function () {\n      var _readdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(dirname) {\n        var files, path;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                files = [];\n\n                for (path in this.files) {\n                  files.push(path);\n                }\n\n                return _context2.abrupt(\"return\", files);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function readdir(_x3) {\n        return _readdir.apply(this, arguments);\n      }\n\n      return readdir;\n    }()\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path, options) {\n        var file;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                file = this.files[path];\n\n                if (file) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(path);\n\n              case 3:\n                return _context3.abrupt(\"return\", {\n                  size: file.size\n                });\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function stat(_x4, _x5) {\n        return _stat.apply(this, arguments);\n      }\n\n      return stat;\n    }()\n  }, {\n    key: \"unlink\",\n    value: function () {\n      var _unlink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                delete this.files[path];\n                delete this.lowerCaseFiles[path];\n                this.usedFiles[path] = true;\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function unlink(_x6) {\n        return _unlink.apply(this, arguments);\n      }\n\n      return unlink;\n    }()\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(pathname, flags, mode) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.files[pathname]);\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function open(_x7, _x8, _x9) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(fd, buffer) {\n        var offset,\n            length,\n            position,\n            file,\n            startPosition,\n            arrayBuffer,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                offset = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 0;\n                length = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : buffer.byteLength;\n                position = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : null;\n                file = fd;\n                startPosition = 0;\n                _context6.next = 7;\n                return file.slice(startPosition, startPosition + length).arrayBuffer();\n\n              case 7:\n                arrayBuffer = _context6.sent;\n                return _context6.abrupt(\"return\", {\n                  bytesRead: length,\n                  buffer: arrayBuffer\n                });\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function read(_x10, _x11) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(fd) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function close(_x12) {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"_getFile\",\n    value: function _getFile(path, used) {\n      var file = this.files[path] || this.lowerCaseFiles[path];\n\n      if (file && used) {\n        this.usedFiles[path] = true;\n      }\n\n      return file;\n    }\n  }]);\n\n  return BrowserFileSystem;\n}();\n\nexport { BrowserFileSystem as default };","map":{"version":3,"sources":["../../../../src/lib/filesystems/browser-filesystem.ts"],"names":["constructor","i","files","file","path","status","statusText","headers","options","range","bytes","start","parseInt","end","data","response","Object","value","size","offset","length","buffer","position","startPosition","arrayBuffer","bytesRead"],"mappings":"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","sourcesContent":["import type {FileSystem} from './filesystem';\n\ntype BrowserFileSystemOptions = {\n  fetch?: typeof fetch;\n};\n\n/**\n * FileSystem adapter for a browser FileList.\n * Holds a list of browser 'File' objects.\n */\nexport default class BrowserFileSystem implements FileSystem {\n  private _fetch: typeof fetch;\n  private files: {[filename: string]: File} = {};\n  private lowerCaseFiles: {[filename: string]: File} = {};\n  private usedFiles: {[filename: string]: boolean} = {};\n\n  /**\n   * A FileSystem API wrapper around a list of browser 'File' objects\n   * @param files\n   * @param options\n   */\n  constructor(files: FileList | File[], options?: BrowserFileSystemOptions) {\n    this._fetch = options?.fetch || fetch;\n\n    for (let i = 0; i < files.length; ++i) {\n      const file = files[i];\n      this.files[file.name] = file;\n      this.lowerCaseFiles[file.name.toLowerCase()] = file;\n      this.usedFiles[file.name] = false;\n    }\n\n    this.fetch = this.fetch.bind(this);\n  }\n\n  // implements IFileSystem\n\n  /**\n   * Implementation of fetch against this file system\n   * Delegates to global fetch for http{s}:// or data://\n   */\n  async fetch(path: string, options?: RequestInit): Promise<Response> {\n    // Fallback to handle https:/http:/data: etc fetches\n    if (path.includes('://')) {\n      return this._fetch(path, options);\n    }\n\n    // Local fetches are served from the list of files\n    const file = this.files[path];\n    if (!file) {\n      return new Response(path, {status: 400, statusText: 'NOT FOUND'});\n    }\n\n    const headers = new Headers(options?.headers);\n    const range = headers.get('Range');\n    const bytes = range && /bytes=($1)-($2)/.exec(range);\n\n    if (bytes) {\n      const start = parseInt(bytes[1]);\n      const end = parseInt(bytes[2]);\n      // The trick when reading File objects is to read successive \"slices\" of the File\n      // Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n      // Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\n      const data = await file.slice(start, end).arrayBuffer();\n      const response = new Response(data);\n      Object.defineProperty(response, 'url', {value: path});\n      return response;\n    }\n\n    // return makeResponse()\n    const response = new Response(file);\n    Object.defineProperty(response, 'url', {value: path});\n    return response;\n  }\n\n  /**\n   * List filenames in this filesystem\n   * @param dirname\n   * @returns\n   */\n  async readdir(dirname?: string): Promise<string[]> {\n    const files: string[] = [];\n    for (const path in this.files) {\n      files.push(path);\n    }\n    // TODO filter by dirname\n    return files;\n  }\n\n  /**\n   * Return information (size) about files in this file system\n   */\n  async stat(path: string, options?: object): Promise<{size: number}> {\n    const file = this.files[path];\n    if (!file) {\n      throw new Error(path);\n    }\n    return {size: file.size};\n  }\n\n  /**\n   * Just removes the file from the list\n   */\n  async unlink(path: string): Promise<void> {\n    delete this.files[path];\n    delete this.lowerCaseFiles[path];\n    this.usedFiles[path] = true;\n  }\n\n  // implements IRandomAccessFileSystem\n\n  // RANDOM ACCESS\n  async open(pathname: string, flags, mode?): Promise<any> {\n    return this.files[pathname];\n  }\n\n  /**\n   * Read a range into a buffer\n   * @todo - handle position memory\n   * @param buffer is the buffer that the data (read from the fd) will be written to.\n   * @param offset is the offset in the buffer to start writing at.\n   * @param length is an integer specifying the number of bytes to read.\n   * @param position is an argument specifying where to begin reading from in the file. If position is null, data will be read from the current file position, and the file position will be updated. If position is an integer, the file position will remain unchanged.\n   */\n  async read(\n    fd: any,\n    buffer: ArrayBuffer,\n    offset: number = 0,\n    length: number = buffer.byteLength,\n    position: number | null = null\n  ): Promise<{bytesRead: number; buffer: ArrayBuffer}> {\n    const file = fd as File;\n    const startPosition = 0; // position\n    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();\n    // copy into target buffer\n    return {bytesRead: length, buffer: arrayBuffer};\n  }\n\n  async close(fd: number): Promise<void> {\n    // NO OP\n  }\n\n  // fstat(fd: number): Promise<object>; // Stat\n\n  // PRIVATE\n\n  // Supports case independent paths, and file usage tracking\n  _getFile(path, used) {\n    // Prefer case match, but fall back to case indepent.\n    const file = this.files[path] || this.lowerCaseFiles[path];\n    if (file && used) {\n      this.usedFiles[path] = true;\n    }\n    return file;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}