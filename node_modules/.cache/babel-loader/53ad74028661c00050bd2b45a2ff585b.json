{"ast":null,"code":"import { extend, identity, field, hasOwnProperty, extentIndex, inherits, array, accessorName, error, accessorFields, accessor, toNumber, merge, compare, truthy, extent, span, fastmap, isArray, key, ascending, peek, zero, constant } from 'vega-util';\nimport { tupleid, Transform, replace, ingest, stableCompare, Operator, derive, rederive } from 'vega-dataflow';\nimport { quartiles, bootstrapCI, bin, randomKDE, randomMixture, randomNormal, randomLogNormal, randomUniform, sampleCurve, dotbin, quantiles, random } from 'vega-statistics';\nimport { median, mean, min, max, range, bisector } from 'd3-array';\nimport { TIME_UNITS, utcInterval, timeInterval, timeBin, timeUnits, utcFloor, timeFloor } from 'vega-time';\n\nfunction multikey(f) {\n  return x => {\n    const n = f.length;\n    let i = 1,\n        k = String(f[0](x));\n\n    for (; i < n; ++i) {\n      k += '|' + f[i](x);\n    }\n\n    return k;\n  };\n}\n\nfunction groupkey(fields) {\n  return !fields || !fields.length ? function () {\n    return '';\n  } : fields.length === 1 ? fields[0] : multikey(fields);\n}\n\nfunction measureName(op, field, as) {\n  return as || op + (!field ? '' : '_' + field);\n}\n\nconst noop = () => {};\n\nconst base_op = {\n  init: noop,\n  add: noop,\n  rem: noop,\n  idx: 0\n};\nconst AggregateOps = {\n  values: {\n    init: m => m.cell.store = true,\n    value: m => m.cell.data.values(),\n    idx: -1\n  },\n  count: {\n    value: m => m.cell.num\n  },\n  __count__: {\n    value: m => m.missing + m.valid\n  },\n  missing: {\n    value: m => m.missing\n  },\n  valid: {\n    value: m => m.valid\n  },\n  sum: {\n    init: m => m.sum = 0,\n    value: m => m.sum,\n    add: (m, v) => m.sum += +v,\n    rem: (m, v) => m.sum -= v\n  },\n  product: {\n    init: m => m.product = 1,\n    value: m => m.valid ? m.product : undefined,\n    add: (m, v) => m.product *= v,\n    rem: (m, v) => m.product /= v\n  },\n  mean: {\n    init: m => m.mean = 0,\n    value: m => m.valid ? m.mean : undefined,\n    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),\n    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)\n  },\n  average: {\n    value: m => m.valid ? m.mean : undefined,\n    req: ['mean'],\n    idx: 1\n  },\n  variance: {\n    init: m => m.dev = 0,\n    value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,\n    add: (m, v) => m.dev += m.mean_d * (v - m.mean),\n    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),\n    req: ['mean'],\n    idx: 1\n  },\n  variancep: {\n    value: m => m.valid > 1 ? m.dev / m.valid : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  stdev: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  stdevp: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  stderr: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  distinct: {\n    value: m => m.cell.data.distinct(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  ci0: {\n    value: m => m.cell.data.ci0(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  ci1: {\n    value: m => m.cell.data.ci1(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  median: {\n    value: m => m.cell.data.q2(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  q1: {\n    value: m => m.cell.data.q1(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  q3: {\n    value: m => m.cell.data.q3(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  min: {\n    init: m => m.min = undefined,\n    value: m => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,\n    add: (m, v) => {\n      if (v < m.min || m.min === undefined) m.min = v;\n    },\n    rem: (m, v) => {\n      if (v <= m.min) m.min = NaN;\n    },\n    req: ['values'],\n    idx: 4\n  },\n  max: {\n    init: m => m.max = undefined,\n    value: m => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,\n    add: (m, v) => {\n      if (v > m.max || m.max === undefined) m.max = v;\n    },\n    rem: (m, v) => {\n      if (v >= m.max) m.max = NaN;\n    },\n    req: ['values'],\n    idx: 4\n  },\n  argmin: {\n    init: m => m.argmin = undefined,\n    value: m => m.argmin || m.cell.data.argmin(m.get),\n    add: (m, v, t) => {\n      if (v < m.min) m.argmin = t;\n    },\n    rem: (m, v) => {\n      if (v <= m.min) m.argmin = undefined;\n    },\n    req: ['min', 'values'],\n    idx: 3\n  },\n  argmax: {\n    init: m => m.argmax = undefined,\n    value: m => m.argmax || m.cell.data.argmax(m.get),\n    add: (m, v, t) => {\n      if (v > m.max) m.argmax = t;\n    },\n    rem: (m, v) => {\n      if (v >= m.max) m.argmax = undefined;\n    },\n    req: ['max', 'values'],\n    idx: 3\n  }\n};\nconst ValidAggregateOps = Object.keys(AggregateOps);\n\nfunction measure(key, value) {\n  return out => extend({\n    name: key,\n    out: out || key\n  }, base_op, value);\n}\n\nValidAggregateOps.forEach(key => {\n  AggregateOps[key] = measure(key, AggregateOps[key]);\n});\n\nfunction createMeasure(op, name) {\n  return AggregateOps[op](name);\n}\n\nfunction compareIndex(a, b) {\n  return a.idx - b.idx;\n}\n\nfunction resolve(agg) {\n  const map = {};\n  agg.forEach(a => map[a.name] = a);\n\n  const getreqs = a => {\n    if (!a.req) return;\n    a.req.forEach(key => {\n      if (!map[key]) getreqs(map[key] = AggregateOps[key]());\n    });\n  };\n\n  agg.forEach(getreqs);\n  return Object.values(map).sort(compareIndex);\n}\n\nfunction init() {\n  this.valid = 0;\n  this.missing = 0;\n\n  this._ops.forEach(op => op.init(this));\n}\n\nfunction add(v, t) {\n  if (v == null || v === '') {\n    ++this.missing;\n    return;\n  }\n\n  if (v !== v) return;\n  ++this.valid;\n\n  this._ops.forEach(op => op.add(this, v, t));\n}\n\nfunction rem(v, t) {\n  if (v == null || v === '') {\n    --this.missing;\n    return;\n  }\n\n  if (v !== v) return;\n  --this.valid;\n\n  this._ops.forEach(op => op.rem(this, v, t));\n}\n\nfunction set(t) {\n  this._out.forEach(op => t[op.out] = op.value(this));\n\n  return t;\n}\n\nfunction compileMeasures(agg, field) {\n  const get = field || identity,\n        ops = resolve(agg),\n        out = agg.slice().sort(compareIndex);\n\n  function ctr(cell) {\n    this._ops = ops;\n    this._out = out;\n    this.cell = cell;\n    this.init();\n  }\n\n  ctr.prototype.init = init;\n  ctr.prototype.add = add;\n  ctr.prototype.rem = rem;\n  ctr.prototype.set = set;\n  ctr.prototype.get = get;\n  ctr.fields = agg.map(op => op.out);\n  return ctr;\n}\n\nfunction TupleStore(key) {\n  this._key = key ? field(key) : tupleid;\n  this.reset();\n}\n\nconst prototype$1 = TupleStore.prototype;\n\nprototype$1.reset = function () {\n  this._add = [];\n  this._rem = [];\n  this._ext = null;\n  this._get = null;\n  this._q = null;\n};\n\nprototype$1.add = function (v) {\n  this._add.push(v);\n};\n\nprototype$1.rem = function (v) {\n  this._rem.push(v);\n};\n\nprototype$1.values = function () {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n  const a = this._add,\n        r = this._rem,\n        k = this._key,\n        n = a.length,\n        m = r.length,\n        x = Array(n - m),\n        map = {};\n  let i, j, v; // use unique key field to clear removed values\n\n  for (i = 0; i < m; ++i) {\n    map[k(r[i])] = 1;\n  }\n\n  for (i = 0, j = 0; i < n; ++i) {\n    if (map[k(v = a[i])]) {\n      map[k(v)] = 0;\n    } else {\n      x[j++] = v;\n    }\n  }\n\n  this._rem = [];\n  return this._add = x;\n}; // memoizing statistics methods\n\n\nprototype$1.distinct = function (get) {\n  const v = this.values(),\n        map = {};\n  let n = v.length,\n      count = 0,\n      s;\n\n  while (--n >= 0) {\n    s = get(v[n]) + '';\n\n    if (!hasOwnProperty(map, s)) {\n      map[s] = 1;\n      ++count;\n    }\n  }\n\n  return count;\n};\n\nprototype$1.extent = function (get) {\n  if (this._get !== get || !this._ext) {\n    const v = this.values(),\n          i = extentIndex(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;\n  }\n\n  return this._ext;\n};\n\nprototype$1.argmin = function (get) {\n  return this.extent(get)[0] || {};\n};\n\nprototype$1.argmax = function (get) {\n  return this.extent(get)[1] || {};\n};\n\nprototype$1.min = function (get) {\n  const m = this.extent(get)[0];\n  return m != null ? get(m) : undefined;\n};\n\nprototype$1.max = function (get) {\n  const m = this.extent(get)[1];\n  return m != null ? get(m) : undefined;\n};\n\nprototype$1.quartile = function (get) {\n  if (this._get !== get || !this._q) {\n    this._q = quartiles(this.values(), get);\n    this._get = get;\n  }\n\n  return this._q;\n};\n\nprototype$1.q1 = function (get) {\n  return this.quartile(get)[0];\n};\n\nprototype$1.q2 = function (get) {\n  return this.quartile(get)[1];\n};\n\nprototype$1.q3 = function (get) {\n  return this.quartile(get)[2];\n};\n\nprototype$1.ci = function (get) {\n  if (this._get !== get || !this._ci) {\n    this._ci = bootstrapCI(this.values(), 1000, 0.05, get);\n    this._get = get;\n  }\n\n  return this._ci;\n};\n\nprototype$1.ci0 = function (get) {\n  return this.ci(get)[0];\n};\n\nprototype$1.ci1 = function (get) {\n  return this.ci(get)[1];\n};\n/**\n * Group-by aggregation operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n * @param {boolean} [params.cross=false] - A flag indicating that the full\n *   cross-product of groupby values should be generated, including empty cells.\n *   If true, the drop parameter is ignored and empty cells are retained.\n * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n */\n\n\nfunction Aggregate(params) {\n  Transform.call(this, null, params);\n  this._adds = []; // array of added output tuples\n\n  this._mods = []; // array of modified output tuples\n\n  this._alen = 0; // number of active added tuples\n\n  this._mlen = 0; // number of active modified tuples\n\n  this._drop = true; // should empty aggregation cells be removed\n\n  this._cross = false; // produce full cross-product of group-by values\n\n  this._dims = []; // group-by dimension accessors\n\n  this._dnames = []; // group-by dimension names\n\n  this._measures = []; // collection of aggregation monoids\n\n  this._countOnly = false; // flag indicating only count aggregation\n\n  this._counts = null; // collection of count fields\n\n  this._prev = null; // previous aggregation cells\n\n  this._inputs = null; // array of dependent input tuple field names\n\n  this._outputs = null; // array of output tuple field names\n}\n\nAggregate.Definition = {\n  'type': 'Aggregate',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'ops',\n    'type': 'enum',\n    'array': true,\n    'values': ValidAggregateOps\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'drop',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'cross',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'key',\n    'type': 'field'\n  }]\n};\ninherits(Aggregate, Transform, {\n  transform(_, pulse) {\n    const aggr = this,\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          mod = _.modified();\n\n    aggr.stamp = out.stamp;\n\n    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n      aggr._prev = aggr.value;\n      aggr.value = mod ? aggr.init(_) : {};\n      pulse.visit(pulse.SOURCE, t => aggr.add(t));\n    } else {\n      aggr.value = aggr.value || aggr.init(_);\n      pulse.visit(pulse.REM, t => aggr.rem(t));\n      pulse.visit(pulse.ADD, t => aggr.add(t));\n    } // Indicate output fields and return aggregate tuples.\n\n\n    out.modifies(aggr._outputs); // Should empty cells be dropped?\n\n    aggr._drop = _.drop !== false; // If domain cross-product requested, generate empty cells as needed\n    // and ensure that empty cells are not dropped\n\n    if (_.cross && aggr._dims.length > 1) {\n      aggr._drop = false;\n      aggr.cross();\n    }\n\n    if (pulse.clean() && aggr._drop) {\n      out.clean(true).runAfter(() => this.clean());\n    }\n\n    return aggr.changes(out);\n  },\n\n  cross() {\n    const aggr = this,\n          curr = aggr.value,\n          dims = aggr._dnames,\n          vals = dims.map(() => ({})),\n          n = dims.length; // collect all group-by domain values\n\n    function collect(cells) {\n      let key, i, t, v;\n\n      for (key in cells) {\n        t = cells[key].tuple;\n\n        for (i = 0; i < n; ++i) {\n          vals[i][v = t[dims[i]]] = v;\n        }\n      }\n    }\n\n    collect(aggr._prev);\n    collect(curr); // iterate over key cross-product, create cells as needed\n\n    function generate(base, tuple, index) {\n      const name = dims[index],\n            v = vals[index++];\n\n      for (const k in v) {\n        const key = base ? base + '|' + k : k;\n        tuple[name] = v[k];\n        if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);\n      }\n    }\n\n    generate('', {}, 0);\n  },\n\n  init(_) {\n    // initialize input and output fields\n    const inputs = this._inputs = [],\n          outputs = this._outputs = [],\n          inputMap = {};\n\n    function inputVisit(get) {\n      const fields = array(accessorFields(get)),\n            n = fields.length;\n      let i = 0,\n          f;\n\n      for (; i < n; ++i) {\n        if (!inputMap[f = fields[i]]) {\n          inputMap[f] = 1;\n          inputs.push(f);\n        }\n      }\n    } // initialize group-by dimensions\n\n\n    this._dims = array(_.groupby);\n    this._dnames = this._dims.map(d => {\n      const dname = accessorName(d);\n      inputVisit(d);\n      outputs.push(dname);\n      return dname;\n    });\n    this.cellkey = _.key ? _.key : groupkey(this._dims); // initialize aggregate measures\n\n    this._countOnly = true;\n    this._counts = [];\n    this._measures = [];\n    const fields = _.fields || [null],\n          ops = _.ops || ['count'],\n          as = _.as || [],\n          n = fields.length,\n          map = {};\n    let field, op, m, mname, outname, i;\n\n    if (n !== ops.length) {\n      error('Unmatched number of fields and aggregate ops.');\n    }\n\n    for (i = 0; i < n; ++i) {\n      field = fields[i];\n      op = ops[i];\n\n      if (field == null && op !== 'count') {\n        error('Null aggregate field specified.');\n      }\n\n      mname = accessorName(field);\n      outname = measureName(op, mname, as[i]);\n      outputs.push(outname);\n\n      if (op === 'count') {\n        this._counts.push(outname);\n\n        continue;\n      }\n\n      m = map[mname];\n\n      if (!m) {\n        inputVisit(field);\n        m = map[mname] = [];\n        m.field = field;\n\n        this._measures.push(m);\n      }\n\n      if (op !== 'count') this._countOnly = false;\n      m.push(createMeasure(op, outname));\n    }\n\n    this._measures = this._measures.map(m => compileMeasures(m, m.field));\n    return {}; // aggregation cells (this.value)\n  },\n\n  // -- Cell Management -----\n  cellkey: groupkey(),\n\n  cell(key, t) {\n    let cell = this.value[key];\n\n    if (!cell) {\n      cell = this.value[key] = this.newcell(key, t);\n      this._adds[this._alen++] = cell;\n    } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n      cell.stamp = this.stamp;\n      this._adds[this._alen++] = cell;\n    } else if (cell.stamp < this.stamp) {\n      cell.stamp = this.stamp;\n      this._mods[this._mlen++] = cell;\n    }\n\n    return cell;\n  },\n\n  newcell(key, t) {\n    const cell = {\n      key: key,\n      num: 0,\n      agg: null,\n      tuple: this.newtuple(t, this._prev && this._prev[key]),\n      stamp: this.stamp,\n      store: false\n    };\n\n    if (!this._countOnly) {\n      const measures = this._measures,\n            n = measures.length;\n      cell.agg = Array(n);\n\n      for (let i = 0; i < n; ++i) {\n        cell.agg[i] = new measures[i](cell);\n      }\n    }\n\n    if (cell.store) {\n      cell.data = new TupleStore();\n    }\n\n    return cell;\n  },\n\n  newtuple(t, p) {\n    const names = this._dnames,\n          dims = this._dims,\n          n = dims.length,\n          x = {};\n\n    for (let i = 0; i < n; ++i) {\n      x[names[i]] = dims[i](t);\n    }\n\n    return p ? replace(p.tuple, x) : ingest(x);\n  },\n\n  clean() {\n    const cells = this.value;\n\n    for (const key in cells) {\n      if (cells[key].num === 0) {\n        delete cells[key];\n      }\n    }\n  },\n\n  // -- Process Tuples -----\n  add(t) {\n    const key = this.cellkey(t),\n          cell = this.cell(key, t);\n    cell.num += 1;\n    if (this._countOnly) return;\n    if (cell.store) cell.data.add(t);\n    const agg = cell.agg;\n\n    for (let i = 0, n = agg.length; i < n; ++i) {\n      agg[i].add(agg[i].get(t), t);\n    }\n  },\n\n  rem(t) {\n    const key = this.cellkey(t),\n          cell = this.cell(key, t);\n    cell.num -= 1;\n    if (this._countOnly) return;\n    if (cell.store) cell.data.rem(t);\n    const agg = cell.agg;\n\n    for (let i = 0, n = agg.length; i < n; ++i) {\n      agg[i].rem(agg[i].get(t), t);\n    }\n  },\n\n  celltuple(cell) {\n    const tuple = cell.tuple,\n          counts = this._counts; // consolidate stored values\n\n    if (cell.store) {\n      cell.data.values();\n    } // update tuple properties\n\n\n    for (let i = 0, n = counts.length; i < n; ++i) {\n      tuple[counts[i]] = cell.num;\n    }\n\n    if (!this._countOnly) {\n      const agg = cell.agg;\n\n      for (let i = 0, n = agg.length; i < n; ++i) {\n        agg[i].set(tuple);\n      }\n    }\n\n    return tuple;\n  },\n\n  changes(out) {\n    const adds = this._adds,\n          mods = this._mods,\n          prev = this._prev,\n          drop = this._drop,\n          add = out.add,\n          rem = out.rem,\n          mod = out.mod;\n    let cell, key, i, n;\n    if (prev) for (key in prev) {\n      cell = prev[key];\n      if (!drop || cell.num) rem.push(cell.tuple);\n    }\n\n    for (i = 0, n = this._alen; i < n; ++i) {\n      add.push(this.celltuple(adds[i]));\n      adds[i] = null; // for garbage collection\n    }\n\n    for (i = 0, n = this._mlen; i < n; ++i) {\n      cell = mods[i];\n      (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n      mods[i] = null; // for garbage collection\n    }\n\n    this._alen = this._mlen = 0; // reset list of active cells\n\n    this._prev = null;\n    return out;\n  }\n\n});\nconst EPSILON$1 = 1e-14;\n/**\n * Generates a binning function for discretizing data.\n * @constructor\n * @param {object} params - The parameters for this operator. The\n *   provided values should be valid options for the {@link bin} function.\n * @param {function(object): *} params.field - The data field to bin.\n */\n\nfunction Bin(params) {\n  Transform.call(this, null, params);\n}\n\nBin.Definition = {\n  'type': 'Bin',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'interval',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'anchor',\n    'type': 'number'\n  }, {\n    'name': 'maxbins',\n    'type': 'number',\n    'default': 20\n  }, {\n    'name': 'base',\n    'type': 'number',\n    'default': 10\n  }, {\n    'name': 'divide',\n    'type': 'number',\n    'array': true,\n    'default': [5, 2]\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'span',\n    'type': 'number'\n  }, {\n    'name': 'step',\n    'type': 'number'\n  }, {\n    'name': 'steps',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'minstep',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'name',\n    'type': 'string'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['bin0', 'bin1']\n  }]\n};\ninherits(Bin, Transform, {\n  transform(_, pulse) {\n    const band = _.interval !== false,\n          bins = this._bins(_),\n          start = bins.start,\n          step = bins.step,\n          as = _.as || ['bin0', 'bin1'],\n          b0 = as[0],\n          b1 = as[1];\n\n    let flag;\n\n    if (_.modified()) {\n      pulse = pulse.reflow(true);\n      flag = pulse.SOURCE;\n    } else {\n      flag = pulse.modified(accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;\n    }\n\n    pulse.visit(flag, band ? t => {\n      const v = bins(t); // minimum bin value (inclusive)\n\n      t[b0] = v; // maximum bin value (exclusive)\n      // use convoluted math for better floating point agreement\n      // see https://github.com/vega/vega/issues/830\n      // infinite values propagate through this formula! #2227\n\n      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\n    } : t => t[b0] = bins(t));\n    return pulse.modifies(band ? as : b0);\n  },\n\n  _bins(_) {\n    if (this.value && !_.modified()) {\n      return this.value;\n    }\n\n    const field = _.field,\n          bins = bin(_),\n          step = bins.step;\n    let start = bins.start,\n        stop = start + Math.ceil((bins.stop - start) / step) * step,\n        a,\n        d;\n\n    if ((a = _.anchor) != null) {\n      d = a - (start + step * Math.floor((a - start) / step));\n      start += d;\n      stop += d;\n    }\n\n    const f = function (t) {\n      let v = toNumber(field(t));\n      return v == null ? null : v < start ? -Infinity : v > stop ? +Infinity : (v = Math.max(start, Math.min(v, stop - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));\n    };\n\n    f.start = start;\n    f.stop = bins.stop;\n    f.step = step;\n    return this.value = accessor(f, accessorFields(field), _.name || 'bin_' + accessorName(field));\n  }\n\n});\n\nfunction SortedList(idFunc, source, input) {\n  const $ = idFunc;\n  let data = source || [],\n      add = input || [],\n      rem = {},\n      cnt = 0;\n  return {\n    add: t => add.push(t),\n    remove: t => rem[$(t)] = ++cnt,\n    size: () => data.length,\n    data: (compare, resort) => {\n      if (cnt) {\n        data = data.filter(t => !rem[$(t)]);\n        rem = {};\n        cnt = 0;\n      }\n\n      if (resort && compare) {\n        data.sort(compare);\n      }\n\n      if (add.length) {\n        data = compare ? merge(compare, data, add.sort(compare)) : data.concat(add);\n        add = [];\n      }\n\n      return data;\n    }\n  };\n}\n/**\n * Collects all data tuples that pass through this operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for additionally sorting the collected tuples.\n */\n\n\nfunction Collect(params) {\n  Transform.call(this, [], params);\n}\n\nCollect.Definition = {\n  'type': 'Collect',\n  'metadata': {\n    'source': true\n  },\n  'params': [{\n    'name': 'sort',\n    'type': 'compare'\n  }]\n};\ninherits(Collect, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.ALL),\n          list = SortedList(tupleid, this.value, out.materialize(out.ADD).add),\n          sort = _.sort,\n          mod = pulse.changed() || sort && (_.modified('sort') || pulse.modified(sort.fields));\n    out.visit(out.REM, list.remove);\n    this.modified(mod);\n    this.value = out.source = list.data(stableCompare(sort), mod); // propagate tree root if defined\n\n    if (pulse.source && pulse.source.root) {\n      this.value.root = pulse.source.root;\n    }\n\n    return out;\n  }\n\n});\n/**\n * Generates a comparator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string|function>} params.fields - The fields to compare.\n * @param {Array<string>} [params.orders] - The sort orders.\n *   Each entry should be one of \"ascending\" (default) or \"descending\".\n */\n\nfunction Compare(params) {\n  Operator.call(this, null, update$5, params);\n}\n\ninherits(Compare, Operator);\n\nfunction update$5(_) {\n  return this.value && !_.modified() ? this.value : compare(_.fields, _.orders);\n}\n/**\n * Count regexp-defined pattern occurrences in a text field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the text field.\n * @param {string} [params.pattern] - RegExp string defining the text pattern.\n * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.\n * @param {string} [params.stopwords] - RegExp string of words to ignore.\n */\n\n\nfunction CountPattern(params) {\n  Transform.call(this, null, params);\n}\n\nCountPattern.Definition = {\n  'type': 'CountPattern',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'case',\n    'type': 'enum',\n    'values': ['upper', 'lower', 'mixed'],\n    'default': 'mixed'\n  }, {\n    'name': 'pattern',\n    'type': 'string',\n    'default': '[\\\\w\"]+'\n  }, {\n    'name': 'stopwords',\n    'type': 'string',\n    'default': ''\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['text', 'count']\n  }]\n};\n\nfunction tokenize(text, tcase, match) {\n  switch (tcase) {\n    case 'upper':\n      text = text.toUpperCase();\n      break;\n\n    case 'lower':\n      text = text.toLowerCase();\n      break;\n  }\n\n  return text.match(match);\n}\n\ninherits(CountPattern, Transform, {\n  transform(_, pulse) {\n    const process = update => tuple => {\n      var tokens = tokenize(get(tuple), _.case, match) || [],\n          t;\n\n      for (var i = 0, n = tokens.length; i < n; ++i) {\n        if (!stop.test(t = tokens[i])) update(t);\n      }\n    };\n\n    const init = this._parameterCheck(_, pulse),\n          counts = this._counts,\n          match = this._match,\n          stop = this._stop,\n          get = _.field,\n          as = _.as || ['text', 'count'],\n          add = process(t => counts[t] = 1 + (counts[t] || 0)),\n          rem = process(t => counts[t] -= 1);\n\n    if (init) {\n      pulse.visit(pulse.SOURCE, add);\n    } else {\n      pulse.visit(pulse.ADD, add);\n      pulse.visit(pulse.REM, rem);\n    }\n\n    return this._finish(pulse, as); // generate output tuples\n  },\n\n  _parameterCheck(_, pulse) {\n    let init = false;\n\n    if (_.modified('stopwords') || !this._stop) {\n      this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');\n      init = true;\n    }\n\n    if (_.modified('pattern') || !this._match) {\n      this._match = new RegExp(_.pattern || '[\\\\w\\']+', 'g');\n      init = true;\n    }\n\n    if (_.modified('field') || pulse.modified(_.field.fields)) {\n      init = true;\n    }\n\n    if (init) this._counts = {};\n    return init;\n  },\n\n  _finish(pulse, as) {\n    const counts = this._counts,\n          tuples = this._tuples || (this._tuples = {}),\n          text = as[0],\n          count = as[1],\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    let w, t, c;\n\n    for (w in counts) {\n      t = tuples[w];\n      c = counts[w] || 0;\n\n      if (!t && c) {\n        tuples[w] = t = ingest({});\n        t[text] = w;\n        t[count] = c;\n        out.add.push(t);\n      } else if (c === 0) {\n        if (t) out.rem.push(t);\n        counts[w] = null;\n        tuples[w] = null;\n      } else if (t[count] !== c) {\n        t[count] = c;\n        out.mod.push(t);\n      }\n    }\n\n    return out.modifies(as);\n  }\n\n});\n/**\n * Perform a cross-product of a tuple stream with itself.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object):boolean} [params.filter] - An optional filter\n *   function for selectively including tuples in the cross product.\n * @param {Array<string>} [params.as] - The names of the output fields.\n */\n\nfunction Cross(params) {\n  Transform.call(this, null, params);\n}\n\nCross.Definition = {\n  'type': 'Cross',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'filter',\n    'type': 'expr'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['a', 'b']\n  }]\n};\ninherits(Cross, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          as = _.as || ['a', 'b'],\n          a = as[0],\n          b = as[1],\n          reset = !this.value || pulse.changed(pulse.ADD_REM) || _.modified('as') || _.modified('filter');\n\n    let data = this.value;\n\n    if (reset) {\n      if (data) out.rem = data;\n      data = pulse.materialize(pulse.SOURCE).source;\n      out.add = this.value = cross(data, a, b, _.filter || truthy);\n    } else {\n      out.mod = data;\n    }\n\n    out.source = this.value;\n    return out.modifies(as);\n  }\n\n});\n\nfunction cross(input, a, b, filter) {\n  var data = [],\n      t = {},\n      n = input.length,\n      i = 0,\n      j,\n      left;\n\n  for (; i < n; ++i) {\n    t[a] = left = input[i];\n\n    for (j = 0; j < n; ++j) {\n      t[b] = input[j];\n\n      if (filter(t)) {\n        data.push(ingest(t));\n        t = {};\n        t[a] = left;\n      }\n    }\n  }\n\n  return data;\n}\n\nconst Distributions = {\n  kde: randomKDE,\n  mixture: randomMixture,\n  normal: randomNormal,\n  lognormal: randomLogNormal,\n  uniform: randomUniform\n};\nconst DISTRIBUTIONS = 'distributions',\n      FUNCTION = 'function',\n      FIELD = 'field';\n/**\n * Parse a parameter object for a probability distribution.\n * @param {object} def - The distribution parameter object.\n * @param {function():Array<object>} - A method for requesting\n *   source data. Used for distributions (such as KDE) that\n *   require sample data points. This method will only be\n *   invoked if the 'from' parameter for a target data source\n *   is not provided. Typically this method returns backing\n *   source data for a Pulse object.\n * @return {object} - The output distribution object.\n */\n\nfunction parse(def, data) {\n  const func = def[FUNCTION];\n\n  if (!hasOwnProperty(Distributions, func)) {\n    error('Unknown distribution function: ' + func);\n  }\n\n  const d = Distributions[func]();\n\n  for (const name in def) {\n    // if data field, extract values\n    if (name === FIELD) {\n      d.data((def.from || data()).map(def[name]));\n    } // if distribution mixture, recurse to parse each definition\n    else if (name === DISTRIBUTIONS) {\n      d[name](def[name].map(_ => parse(_, data)));\n    } // otherwise, simply set the parameter\n    else if (typeof d[name] === FUNCTION) {\n      d[name](def[name]);\n    }\n  }\n\n  return d;\n}\n/**\n * Grid sample points for a probability density. Given a distribution and\n * a sampling extent, will generate points suitable for plotting either\n * PDF (probability density function) or CDF (cumulative distribution\n * function) curves.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.distribution - The probability distribution. This\n *   is an object parameter dependent on the distribution type.\n * @param {string} [params.method='pdf'] - The distribution method to sample.\n *   One of 'pdf' or 'cdf'.\n * @param {Array<number>} [params.extent] - The [min, max] extent over which\n *   to sample the distribution. This argument is required in most cases, but\n *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\n *   that returns numerical sample points from which the extent can be deduced.\n * @param {number} [params.minsteps=25] - The minimum number of curve samples\n *   for plotting the density.\n * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n *   for plotting the density.\n * @param {number} [params.steps] - The exact number of curve samples for\n *   plotting the density. If specified, overrides both minsteps and maxsteps\n *   to set an exact number of uniform samples. Useful in conjunction with\n *   a fixed extent to ensure consistent sample points for stacked densities.\n */\n\n\nfunction Density(params) {\n  Transform.call(this, null, params);\n}\n\nconst distributions = [{\n  'key': {\n    'function': 'normal'\n  },\n  'params': [{\n    'name': 'mean',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'stdev',\n    'type': 'number',\n    'default': 1\n  }]\n}, {\n  'key': {\n    'function': 'lognormal'\n  },\n  'params': [{\n    'name': 'mean',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'stdev',\n    'type': 'number',\n    'default': 1\n  }]\n}, {\n  'key': {\n    'function': 'uniform'\n  },\n  'params': [{\n    'name': 'min',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'max',\n    'type': 'number',\n    'default': 1\n  }]\n}, {\n  'key': {\n    'function': 'kde'\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'from',\n    'type': 'data'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0\n  }]\n}];\nconst mixture = {\n  'key': {\n    'function': 'mixture'\n  },\n  'params': [{\n    'name': 'distributions',\n    'type': 'param',\n    'array': true,\n    'params': distributions\n  }, {\n    'name': 'weights',\n    'type': 'number',\n    'array': true\n  }]\n};\nDensity.Definition = {\n  'type': 'Density',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'steps',\n    'type': 'number'\n  }, {\n    'name': 'minsteps',\n    'type': 'number',\n    'default': 25\n  }, {\n    'name': 'maxsteps',\n    'type': 'number',\n    'default': 200\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'pdf',\n    'values': ['pdf', 'cdf']\n  }, {\n    'name': 'distribution',\n    'type': 'param',\n    'params': distributions.concat(mixture)\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'default': ['value', 'density']\n  }]\n};\ninherits(Density, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const dist = parse(_.distribution, source(pulse)),\n            minsteps = _.steps || _.minsteps || 25,\n            maxsteps = _.steps || _.maxsteps || 200;\n      let method = _.method || 'pdf';\n\n      if (method !== 'pdf' && method !== 'cdf') {\n        error('Invalid density method: ' + method);\n      }\n\n      if (!_.extent && !dist.data) {\n        error('Missing density extent parameter.');\n      }\n\n      method = dist[method];\n      const as = _.as || ['value', 'density'],\n            domain = _.extent || extent(dist.data()),\n            values = sampleCurve(method, domain, minsteps, maxsteps).map(v => {\n        const tuple = {};\n        tuple[as[0]] = v[0];\n        tuple[as[1]] = v[1];\n        return ingest(tuple);\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nfunction source(pulse) {\n  return () => pulse.materialize(pulse.SOURCE).source;\n}\n\nfunction fieldNames(fields, as) {\n  if (!fields) return null;\n  return fields.map((f, i) => as[i] || accessorName(f));\n}\n\nfunction partition$1(data, groupby, field) {\n  const groups = [],\n        get = f => f(t);\n\n  let map, i, n, t, k, g; // partition data points into groups\n\n  if (groupby == null) {\n    groups.push(data.map(field));\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(field(t));\n    }\n  }\n\n  return groups;\n}\n\nconst Output = 'bin';\n/**\n * Dot density binning for dot plot construction.\n * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.\n * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to bin.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.step] - The step size (bin width) within which dots should be\n *   stacked. Defaults to 1/30 of the extent of the data *field*.\n * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density\n *   stacks should be smoothed to reduce variance.\n */\n\nfunction DotBin(params) {\n  Transform.call(this, null, params);\n}\n\nDotBin.Definition = {\n  'type': 'DotBin',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'step',\n    'type': 'number'\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': Output\n  }]\n};\n\nconst autostep = (data, field) => span(extent(data, field)) / 30;\n\ninherits(DotBin, Transform, {\n  transform(_, pulse) {\n    if (this.value && !(_.modified() || pulse.changed())) {\n      return pulse; // early exit\n    }\n\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition$1(pulse.source, _.groupby, identity),\n          smooth = _.smooth || false,\n          field = _.field,\n          step = _.step || autostep(source, field),\n          sort = stableCompare((a, b) => field(a) - field(b)),\n          as = _.as || Output,\n          n = groups.length; // compute dotplot bins per group\n\n    let min = Infinity,\n        max = -Infinity,\n        i = 0,\n        j;\n\n    for (; i < n; ++i) {\n      const g = groups[i].sort(sort);\n      j = -1;\n\n      for (const v of dotbin(g, step, smooth, field)) {\n        if (v < min) min = v;\n        if (v > max) max = v;\n        g[++j][as] = v;\n      }\n    }\n\n    this.value = {\n      start: min,\n      stop: max,\n      step: step\n    };\n    return pulse.reflow(true).modifies(as);\n  }\n\n});\n/**\n * Wraps an expression function with access to external parameters.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function} params.expr - The expression function. The\n *  function should accept both a datum and a parameter object.\n *  This operator's value will be a new function that wraps the\n *  expression function with access to this operator's parameters.\n */\n\nfunction Expression(params) {\n  Operator.call(this, null, update$4, params);\n  this.modified(true);\n}\n\ninherits(Expression, Operator);\n\nfunction update$4(_) {\n  const expr = _.expr;\n  return this.value && !_.modified('expr') ? this.value : accessor(datum => expr(datum, _), accessorFields(expr), accessorName(expr));\n}\n/**\n * Computes extents (min/max) for a data field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field over which to compute extends.\n */\n\n\nfunction Extent(params) {\n  Transform.call(this, [undefined, undefined], params);\n}\n\nExtent.Definition = {\n  'type': 'Extent',\n  'metadata': {},\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Extent, Transform, {\n  transform(_, pulse) {\n    const extent = this.value,\n          field = _.field,\n          mod = pulse.changed() || pulse.modified(field.fields) || _.modified('field');\n\n    let min = extent[0],\n        max = extent[1];\n\n    if (mod || min == null) {\n      min = +Infinity;\n      max = -Infinity;\n    }\n\n    pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {\n      const v = toNumber(field(t));\n\n      if (v != null) {\n        // NaNs will fail all comparisons!\n        if (v < min) min = v;\n        if (v > max) max = v;\n      }\n    });\n\n    if (!Number.isFinite(min) || !Number.isFinite(max)) {\n      let name = accessorName(field);\n      if (name) name = ` for field \"${name}\"`;\n      pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);\n      min = max = undefined;\n    }\n\n    this.value = [min, max];\n  }\n\n});\n/**\n * Provides a bridge between a parent transform and a target subflow that\n * consumes only a subset of the tuples that pass through the parent.\n * @constructor\n * @param {Pulse} pulse - A pulse to use as the value of this operator.\n * @param {Transform} parent - The parent transform (typically a Facet instance).\n */\n\nfunction Subflow(pulse, parent) {\n  Operator.call(this, pulse);\n  this.parent = parent;\n  this.count = 0;\n}\n\ninherits(Subflow, Operator, {\n  /**\n   * Routes pulses from this subflow to a target transform.\n   * @param {Transform} target - A transform that receives the subflow of tuples.\n   */\n  connect(target) {\n    this.detachSubflow = target.detachSubflow;\n    this.targets().add(target);\n    return target.source = this;\n  },\n\n  /**\n   * Add an 'add' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being added.\n   */\n  add(t) {\n    this.count += 1;\n    this.value.add.push(t);\n  },\n\n  /**\n   * Add a 'rem' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being removed.\n   */\n  rem(t) {\n    this.count -= 1;\n    this.value.rem.push(t);\n  },\n\n  /**\n   * Add a 'mod' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being modified.\n   */\n  mod(t) {\n    this.value.mod.push(t);\n  },\n\n  /**\n   * Re-initialize this operator's pulse value.\n   * @param {Pulse} pulse - The pulse to copy from.\n   * @see Pulse.init\n   */\n  init(pulse) {\n    this.value.init(pulse, pulse.NO_SOURCE);\n  },\n\n  /**\n   * Evaluate this operator. This method overrides the\n   * default behavior to simply return the contained pulse value.\n   * @return {Pulse}\n   */\n  evaluate() {\n    // assert: this.value.stamp === pulse.stamp\n    return this.value;\n  }\n\n});\n/**\n * Facets a dataflow into a set of subflows based on a key.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): *} params.key - The key field to facet by.\n */\n\nfunction Facet(params) {\n  Transform.call(this, {}, params);\n  this._keys = fastmap(); // cache previously calculated key values\n  // keep track of active subflows, use as targets array for listeners\n  // this allows us to limit propagation to only updated subflows\n\n  const a = this._targets = [];\n  a.active = 0;\n\n  a.forEach = f => {\n    for (let i = 0, n = a.active; i < n; ++i) {\n      f(a[i], i, a);\n    }\n  };\n}\n\ninherits(Facet, Transform, {\n  activate(flow) {\n    this._targets[this._targets.active++] = flow;\n  },\n\n  // parent argument provided by PreFacet subclass\n  subflow(key, flow, pulse, parent) {\n    const flows = this.value;\n    let sf = hasOwnProperty(flows, key) && flows[key],\n        df,\n        p;\n\n    if (!sf) {\n      p = parent || (p = this._group[key]) && p.tuple;\n      df = pulse.dataflow;\n      sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);\n      df.add(sf).connect(flow(df, key, p));\n      flows[key] = sf;\n      this.activate(sf);\n    } else if (sf.value.stamp < pulse.stamp) {\n      sf.init(pulse);\n      this.activate(sf);\n    }\n\n    return sf;\n  },\n\n  clean() {\n    const flows = this.value;\n    let detached = 0;\n\n    for (const key in flows) {\n      if (flows[key].count === 0) {\n        const detach = flows[key].detachSubflow;\n        if (detach) detach();\n        delete flows[key];\n        ++detached;\n      }\n    } // remove inactive targets from the active targets array\n\n\n    if (detached) {\n      const active = this._targets.filter(sf => sf && sf.count > 0);\n\n      this.initTargets(active);\n    }\n  },\n\n  initTargets(act) {\n    const a = this._targets,\n          n = a.length,\n          m = act ? act.length : 0;\n    let i = 0;\n\n    for (; i < m; ++i) {\n      a[i] = act[i];\n    }\n\n    for (; i < n && a[i] != null; ++i) {\n      a[i] = null; // ensure old flows can be garbage collected\n    }\n\n    a.active = m;\n  },\n\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          key = _.key,\n          flow = _.subflow,\n          cache = this._keys,\n          rekey = _.modified('key'),\n          subflow = key => this.subflow(key, flow, pulse);\n\n    this._group = _.group || {};\n    this.initTargets(); // reset list of active subflows\n\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t),\n            k = cache.get(id);\n\n      if (k !== undefined) {\n        cache.delete(id);\n        subflow(k).rem(t);\n      }\n    });\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      cache.set(tupleid(t), k);\n      subflow(k).add(t);\n    });\n\n    if (rekey || pulse.modified(key.fields)) {\n      pulse.visit(pulse.MOD, t => {\n        const id = tupleid(t),\n              k0 = cache.get(id),\n              k1 = key(t);\n\n        if (k0 === k1) {\n          subflow(k1).mod(t);\n        } else {\n          cache.set(id, k1);\n          subflow(k0).rem(t);\n          subflow(k1).add(t);\n        }\n      });\n    } else if (pulse.changed(pulse.MOD)) {\n      pulse.visit(pulse.MOD, t => {\n        subflow(cache.get(tupleid(t))).mod(t);\n      });\n    }\n\n    if (rekey) {\n      pulse.visit(pulse.REFLOW, t => {\n        const id = tupleid(t),\n              k0 = cache.get(id),\n              k1 = key(t);\n\n        if (k0 !== k1) {\n          cache.set(id, k1);\n          subflow(k0).rem(t);\n          subflow(k1).add(t);\n        }\n      });\n    }\n\n    if (pulse.clean()) {\n      df.runAfter(() => {\n        this.clean();\n        cache.clean();\n      });\n    } else if (cache.empty > df.cleanThreshold) {\n      df.runAfter(cache.clean);\n    }\n\n    return pulse;\n  }\n\n});\n/**\n * Generates one or more field accessor functions.\n * If the 'name' parameter is an array, an array of field accessors\n * will be created and the 'as' parameter will be ignored.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.name - The field name(s) to access.\n * @param {string} params.as - The accessor function name.\n */\n\nfunction Field(params) {\n  Operator.call(this, null, update$3, params);\n}\n\ninherits(Field, Operator);\n\nfunction update$3(_) {\n  return this.value && !_.modified() ? this.value : isArray(_.name) ? array(_.name).map(f => field(f)) : field(_.name, _.as);\n}\n/**\n * Filters data tuples according to a predicate function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The predicate expression function\n *   that determines a tuple's filter status. Truthy values pass the filter.\n */\n\n\nfunction Filter(params) {\n  Transform.call(this, fastmap(), params);\n}\n\nFilter.Definition = {\n  'type': 'Filter',\n  'metadata': {\n    'changes': true\n  },\n  'params': [{\n    'name': 'expr',\n    'type': 'expr',\n    'required': true\n  }]\n};\ninherits(Filter, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          cache = this.value,\n          // cache ids of filtered tuples\n    output = pulse.fork(),\n          add = output.add,\n          rem = output.rem,\n          mod = output.mod,\n          test = _.expr;\n    let isMod = true;\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t);\n      if (!cache.has(id)) rem.push(t);else cache.delete(id);\n    });\n    pulse.visit(pulse.ADD, t => {\n      if (test(t, _)) add.push(t);else cache.set(tupleid(t), 1);\n    });\n\n    function revisit(t) {\n      const id = tupleid(t),\n            b = test(t, _),\n            s = cache.get(id);\n\n      if (b && s) {\n        cache.delete(id);\n        add.push(t);\n      } else if (!b && !s) {\n        cache.set(id, 1);\n        rem.push(t);\n      } else if (isMod && b && !s) {\n        mod.push(t);\n      }\n    }\n\n    pulse.visit(pulse.MOD, revisit);\n\n    if (_.modified()) {\n      isMod = false;\n      pulse.visit(pulse.REFLOW, revisit);\n    }\n\n    if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);\n    return output;\n  }\n\n});\n/**\n * Flattens array-typed field values into new data objects.\n * If multiple fields are specified, they are treated as parallel arrays,\n * with output values included for each matching index (or null if missing).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of field\n *   accessors for the tuple fields that should be flattened.\n * @param {string} [params.index] - Optional output field name for index\n *   value. If unspecified, no index field is included in the output.\n * @param {Array<string>} [params.as] - Output field names for flattened\n *   array fields. Any unspecified fields will use the field name provided\n *   by the fields accessors.\n */\n\nfunction Flatten(params) {\n  Transform.call(this, [], params);\n}\n\nFlatten.Definition = {\n  'type': 'Flatten',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'index',\n    'type': 'string'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Flatten, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          as = fieldNames(fields, _.as || []),\n          index = _.index || null,\n          m = as.length; // remove any previous results\n\n    out.rem = this.value; // generate flattened tuples\n\n    pulse.visit(pulse.SOURCE, t => {\n      const arrays = fields.map(f => f(t)),\n            maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);\n      let i = 0,\n          j,\n          d,\n          v;\n\n      for (; i < maxlen; ++i) {\n        d = derive(t);\n\n        for (j = 0; j < m; ++j) {\n          d[as[j]] = (v = arrays[j][i]) == null ? null : v;\n        }\n\n        if (index) {\n          d[index] = i;\n        }\n\n        out.add.push(d);\n      }\n    });\n    this.value = out.source = out.add;\n    if (index) out.modifies(index);\n    return out.modifies(as);\n  }\n\n});\n/**\n * Folds one more tuple fields into multiple tuples in which the field\n * name and values are available under new 'key' and 'value' fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.fields - An array of field accessors\n *   for the tuple fields that should be folded.\n * @param {Array<string>} [params.as] - Output field names for folded key\n *   and value fields, defaults to ['key', 'value'].\n */\n\nfunction Fold(params) {\n  Transform.call(this, [], params);\n}\n\nFold.Definition = {\n  'type': 'Fold',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['key', 'value']\n  }]\n};\ninherits(Fold, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          fnames = fields.map(accessorName),\n          as = _.as || ['key', 'value'],\n          k = as[0],\n          v = as[1],\n          n = fields.length;\n    out.rem = this.value;\n    pulse.visit(pulse.SOURCE, t => {\n      for (let i = 0, d; i < n; ++i) {\n        d = derive(t);\n        d[k] = fnames[i];\n        d[v] = fields[i](t);\n        out.add.push(d);\n      }\n    });\n    this.value = out.source = out.add;\n    return out.modifies(as);\n  }\n\n});\n/**\n * Invokes a function for each data tuple and saves the results as a new field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The formula function to invoke for each tuple.\n * @param {string} params.as - The field name under which to save the result.\n * @param {boolean} [params.initonly=false] - If true, the formula is applied to\n *   added tuples only, and does not update in response to modifications.\n */\n\nfunction Formula(params) {\n  Transform.call(this, null, params);\n}\n\nFormula.Definition = {\n  'type': 'Formula',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'expr',\n    'type': 'expr',\n    'required': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }, {\n    'name': 'initonly',\n    'type': 'boolean'\n  }]\n};\ninherits(Formula, Transform, {\n  transform(_, pulse) {\n    const func = _.expr,\n          as = _.as,\n          mod = _.modified(),\n          flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;\n\n    if (mod) {\n      // parameters updated, need to reflow\n      pulse = pulse.materialize().reflow(true);\n    }\n\n    if (!_.initonly) {\n      pulse.modifies(as);\n    }\n\n    return pulse.visit(flag, t => t[as] = func(t, _));\n  }\n\n});\n/**\n * Generates data tuples using a provided generator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Parameters): object} params.generator - A tuple generator\n *   function. This function is given the operator parameters as input.\n *   Changes to any additional parameters will not trigger re-calculation\n *   of previously generated tuples. Only future tuples are affected.\n * @param {number} params.size - The number of tuples to produce.\n */\n\nfunction Generate(params) {\n  Transform.call(this, [], params);\n}\n\ninherits(Generate, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.ALL),\n          gen = _.generator;\n    let data = this.value,\n        num = _.size - data.length,\n        add,\n        rem,\n        t;\n\n    if (num > 0) {\n      // need more tuples, generate and add\n      for (add = []; --num >= 0;) {\n        add.push(t = ingest(gen(_)));\n        data.push(t);\n      }\n\n      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add) : add;\n    } else {\n      // need fewer tuples, remove\n      rem = data.slice(0, -num);\n      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem) : rem;\n      data = data.slice(-num);\n    }\n\n    out.source = this.value = data;\n    return out;\n  }\n\n});\nconst Methods = {\n  value: 'value',\n  median: median,\n  mean: mean,\n  min: min,\n  max: max\n};\nconst Empty = [];\n/**\n * Impute missing values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to impute.\n * @param {Array<function(object): *>} [params.groupby] - An array of\n *   accessors to determine series within which to perform imputation.\n * @param {function(object): *} params.key - An accessor for a key value.\n *   Each key value should be unique within a group. New tuples will be\n *   imputed for any key values that are not found within a group.\n * @param {Array<*>} [params.keyvals] - Optional array of required key\n *   values. New tuples will be imputed for any key values that are not\n *   found within a group. In addition, these values will be automatically\n *   augmented with the key values observed in the input data.\n * @param {string} [method='value'] - The imputation method to use. One of\n *   'value', 'mean', 'median', 'max', 'min'.\n * @param {*} [value=0] - The constant value to use for imputation\n *   when using method 'value'.\n */\n\nfunction Impute(params) {\n  Transform.call(this, [], params);\n}\n\nImpute.Definition = {\n  'type': 'Impute',\n  'metadata': {\n    'changes': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'keyvals',\n    'array': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'value',\n    'values': ['value', 'mean', 'median', 'max', 'min']\n  }, {\n    'name': 'value',\n    'default': 0\n  }]\n};\n\nfunction getValue(_) {\n  var m = _.method || Methods.value,\n      v;\n\n  if (Methods[m] == null) {\n    error('Unrecognized imputation method: ' + m);\n  } else if (m === Methods.value) {\n    v = _.value !== undefined ? _.value : 0;\n    return () => v;\n  } else {\n    return Methods[m];\n  }\n}\n\nfunction getField(_) {\n  const f = _.field;\n  return t => t ? f(t) : NaN;\n}\n\ninherits(Impute, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        impute = getValue(_),\n        field = getField(_),\n        fName = accessorName(_.field),\n        kName = accessorName(_.key),\n        gNames = (_.groupby || []).map(accessorName),\n        groups = partition(pulse.source, _.groupby, _.key, _.keyvals),\n        curr = [],\n        prev = this.value,\n        m = groups.domain.length,\n        group,\n        value,\n        gVals,\n        kVal,\n        g,\n        i,\n        j,\n        l,\n        n,\n        t;\n\n    for (g = 0, l = groups.length; g < l; ++g) {\n      group = groups[g];\n      gVals = group.values;\n      value = NaN; // add tuples for missing values\n\n      for (j = 0; j < m; ++j) {\n        if (group[j] != null) continue;\n        kVal = groups.domain[j];\n        t = {\n          _impute: true\n        };\n\n        for (i = 0, n = gVals.length; i < n; ++i) t[gNames[i]] = gVals[i];\n\n        t[kName] = kVal;\n        t[fName] = Number.isNaN(value) ? value = impute(group, field) : value;\n        curr.push(ingest(t));\n      }\n    } // update pulse with imputed tuples\n\n\n    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);\n    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);\n    this.value = curr;\n    return out;\n  }\n\n});\n\nfunction partition(data, groupby, key, keyvals) {\n  var get = f => f(t),\n      groups = [],\n      domain = keyvals ? keyvals.slice() : [],\n      kMap = {},\n      gMap = {},\n      gVals,\n      gKey,\n      group,\n      i,\n      j,\n      k,\n      n,\n      t;\n\n  domain.forEach((k, i) => kMap[k] = i + 1);\n\n  for (i = 0, n = data.length; i < n; ++i) {\n    t = data[i];\n    k = key(t);\n    j = kMap[k] || (kMap[k] = domain.push(k));\n    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';\n\n    if (!(group = gMap[gKey])) {\n      group = gMap[gKey] = [];\n      groups.push(group);\n      group.values = gVals;\n    }\n\n    group[j - 1] = t;\n  }\n\n  groups.domain = domain;\n  return groups;\n}\n/**\n * Extend input tuples with aggregate values.\n * Calcuates aggregate values and joins them with the input stream.\n * @constructor\n */\n\n\nfunction JoinAggregate(params) {\n  Aggregate.call(this, params);\n}\n\nJoinAggregate.Definition = {\n  'type': 'JoinAggregate',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'ops',\n    'type': 'enum',\n    'array': true,\n    'values': ValidAggregateOps\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'key',\n    'type': 'field'\n  }]\n};\ninherits(JoinAggregate, Aggregate, {\n  transform(_, pulse) {\n    const aggr = this,\n          mod = _.modified();\n\n    let cells; // process all input tuples to calculate aggregates\n\n    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n      cells = aggr.value = mod ? aggr.init(_) : {};\n      pulse.visit(pulse.SOURCE, t => aggr.add(t));\n    } else {\n      cells = aggr.value = aggr.value || this.init(_);\n      pulse.visit(pulse.REM, t => aggr.rem(t));\n      pulse.visit(pulse.ADD, t => aggr.add(t));\n    } // update aggregation cells\n\n\n    aggr.changes(); // write aggregate values to input tuples\n\n    pulse.visit(pulse.SOURCE, t => {\n      extend(t, cells[aggr.cellkey(t)].tuple);\n    });\n    return pulse.reflow(mod).modifies(this._outputs);\n  },\n\n  changes() {\n    const adds = this._adds,\n          mods = this._mods;\n    let i, n;\n\n    for (i = 0, n = this._alen; i < n; ++i) {\n      this.celltuple(adds[i]);\n      adds[i] = null; // for garbage collection\n    }\n\n    for (i = 0, n = this._mlen; i < n; ++i) {\n      this.celltuple(mods[i]);\n      mods[i] = null; // for garbage collection\n    }\n\n    this._alen = this._mlen = 0; // reset list of active cells\n  }\n\n});\n/**\n * Compute kernel density estimates (KDE) for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {function(object): *} params.field - An accessor for the data field\n *   to estimate.\n * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.\n *   If zero or unspecified, the bandwidth is automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.cumulative=false] - A boolean flag indicating if a\n *   density (false) or cumulative distribution (true) should be generated.\n * @param {Array<number>} [params.extent] - The domain extent over which to\n *   plot the density. If unspecified, the [min, max] data extent is used.\n * @param {string} [params.resolve='independent'] - Indicates how parameters for\n *   multiple densities should be resolved. If \"independent\" (the default), each\n *   density may have its own domain extent and dynamic number of curve sample\n *   steps. If \"shared\", the KDE transform will ensure that all densities are\n *   defined over a shared domain and curve steps, enabling stacking.\n * @param {number} [params.minsteps=25] - The minimum number of curve samples\n *   for plotting the density.\n * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n *   for plotting the density.\n * @param {number} [params.steps] - The exact number of curve samples for\n *   plotting the density. If specified, overrides both minsteps and maxsteps\n *   to set an exact number of uniform samples. Useful in conjunction with\n *   a fixed extent to ensure consistent sample points for stacked densities.\n */\n\nfunction KDE(params) {\n  Transform.call(this, null, params);\n}\n\nKDE.Definition = {\n  'type': 'KDE',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'cumulative',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'steps',\n    'type': 'number'\n  }, {\n    'name': 'minsteps',\n    'type': 'number',\n    'default': 25\n  }, {\n    'name': 'maxsteps',\n    'type': 'number',\n    'default': 200\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'default': ['value', 'density']\n  }]\n};\ninherits(KDE, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition$1(source, _.groupby, _.field),\n            names = (_.groupby || []).map(accessorName),\n            bandwidth = _.bandwidth,\n            method = _.cumulative ? 'cdf' : 'pdf',\n            as = _.as || ['value', 'density'],\n            values = [];\n      let domain = _.extent,\n          minsteps = _.steps || _.minsteps || 25,\n          maxsteps = _.steps || _.maxsteps || 200;\n\n      if (method !== 'pdf' && method !== 'cdf') {\n        error('Invalid density method: ' + method);\n      }\n\n      if (_.resolve === 'shared') {\n        if (!domain) domain = extent(source, _.field);\n        minsteps = maxsteps = _.steps || maxsteps;\n      }\n\n      groups.forEach(g => {\n        const density = randomKDE(g, bandwidth)[method],\n              scale = _.counts ? g.length : 1,\n              local = domain || extent(g);\n        sampleCurve(density, local, minsteps, maxsteps).forEach(v => {\n          const t = {};\n\n          for (let i = 0; i < names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = v[0];\n          t[as[1]] = v[1] * scale;\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n/**\n * Generates a key function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string>} params.fields - The field name(s) for the key function.\n * @param {boolean} params.flat - A boolean flag indicating if the field names\n *  should be treated as flat property names, side-stepping nested field\n *  lookups normally indicated by dot or bracket notation.\n */\n\nfunction Key(params) {\n  Operator.call(this, null, update$2, params);\n}\n\ninherits(Key, Operator);\n\nfunction update$2(_) {\n  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);\n}\n/**\n * Load and parse data from an external source. Marshalls parameter\n * values and then invokes the Dataflow request method.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.url - The URL to load from.\n * @param {object} params.format - The data format options.\n */\n\n\nfunction Load(params) {\n  Transform.call(this, [], params);\n  this._pending = null;\n}\n\ninherits(Load, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow;\n\n    if (this._pending) {\n      // update state and return pulse\n      return output(this, pulse, this._pending);\n    }\n\n    if (stop(_)) return pulse.StopPropagation;\n\n    if (_.values) {\n      // parse and ingest values, return output pulse\n      return output(this, pulse, df.parse(_.values, _.format));\n    } else if (_.async) {\n      // return promise for non-blocking async loading\n      const p = df.request(_.url, _.format).then(res => {\n        this._pending = array(res.data);\n        return df => df.touch(this);\n      });\n      return {\n        async: p\n      };\n    } else {\n      // return promise for synchronous loading\n      return df.request(_.url, _.format).then(res => output(this, pulse, array(res.data)));\n    }\n  }\n\n});\n\nfunction stop(_) {\n  return _.modified('async') && !(_.modified('values') || _.modified('url') || _.modified('format'));\n}\n\nfunction output(op, pulse, data) {\n  data.forEach(ingest);\n  const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);\n  out.rem = op.value;\n  op.value = out.source = out.add = data;\n  op._pending = null;\n  if (out.rem.length) out.clean(true);\n  return out;\n}\n/**\n * Extend tuples by joining them with values from a lookup table.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Map} params.index - The lookup table map.\n * @param {Array<function(object): *} params.fields - The fields to lookup.\n * @param {Array<string>} params.as - Output field names for each lookup value.\n * @param {*} [params.default] - A default value to use if lookup fails.\n */\n\n\nfunction Lookup(params) {\n  Transform.call(this, {}, params);\n}\n\nLookup.Definition = {\n  'type': 'Lookup',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'index',\n    'type': 'index',\n    'params': [{\n      'name': 'from',\n      'type': 'data',\n      'required': true\n    }, {\n      'name': 'key',\n      'type': 'field',\n      'required': true\n    }]\n  }, {\n    'name': 'values',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }, {\n    'name': 'default',\n    'default': null\n  }]\n};\ninherits(Lookup, Transform, {\n  transform(_, pulse) {\n    const keys = _.fields,\n          index = _.index,\n          values = _.values,\n          defaultValue = _.default == null ? null : _.default,\n          reset = _.modified(),\n          n = keys.length;\n\n    let flag = reset ? pulse.SOURCE : pulse.ADD,\n        out = pulse,\n        as = _.as,\n        set,\n        m,\n        mods;\n\n    if (values) {\n      m = values.length;\n\n      if (n > 1 && !as) {\n        error('Multi-field lookup requires explicit \"as\" parameter.');\n      }\n\n      if (as && as.length !== n * m) {\n        error('The \"as\" parameter has too few output field names.');\n      }\n\n      as = as || values.map(accessorName);\n\n      set = function (t) {\n        for (var i = 0, k = 0, j, v; i < n; ++i) {\n          v = index.get(keys[i](t));\n          if (v == null) for (j = 0; j < m; ++j, ++k) t[as[k]] = defaultValue;else for (j = 0; j < m; ++j, ++k) t[as[k]] = values[j](v);\n        }\n      };\n    } else {\n      if (!as) {\n        error('Missing output field names.');\n      }\n\n      set = function (t) {\n        for (var i = 0, v; i < n; ++i) {\n          v = index.get(keys[i](t));\n          t[as[i]] = v == null ? defaultValue : v;\n        }\n      };\n    }\n\n    if (reset) {\n      out = pulse.reflow(true);\n    } else {\n      mods = keys.some(k => pulse.modified(k.fields));\n      flag |= mods ? pulse.MOD : 0;\n    }\n\n    pulse.visit(flag, set);\n    return out.modifies(as);\n  }\n\n});\n/**\n * Computes global min/max extents over a collection of extents.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<number>>} params.extents - The input extents.\n */\n\nfunction MultiExtent(params) {\n  Operator.call(this, null, update$1, params);\n}\n\ninherits(MultiExtent, Operator);\n\nfunction update$1(_) {\n  if (this.value && !_.modified()) {\n    return this.value;\n  }\n\n  const ext = _.extents,\n        n = ext.length;\n  let min = +Infinity,\n      max = -Infinity,\n      i,\n      e;\n\n  for (i = 0; i < n; ++i) {\n    e = ext[i];\n    if (e[0] < min) min = e[0];\n    if (e[1] > max) max = e[1];\n  }\n\n  return [min, max];\n}\n/**\n * Merge a collection of value arrays.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<*>>} params.values - The input value arrrays.\n */\n\n\nfunction MultiValues(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(MultiValues, Operator);\n\nfunction update(_) {\n  return this.value && !_.modified() ? this.value : _.values.reduce((data, _) => data.concat(_), []);\n}\n/**\n * Operator whose value is simply its parameter hash. This operator is\n * useful for enabling reactive updates to values of nested objects.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction Params(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Params, Transform, {\n  transform(_, pulse) {\n    this.modified(_.modified());\n    this.value = _;\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples\n  }\n\n});\n/**\n * Aggregate and pivot selected field values to become new fields.\n * This operator is useful to construction cross-tabulations.\n * @constructor\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *  to groupby. These fields act just like groupby fields of an Aggregate transform.\n * @param {function(object): *} params.field - The field to pivot on. The unique\n *  values of this field become new field names in the output stream.\n * @param {function(object): *} params.value - The field to populate pivoted fields.\n *  The aggregate values of this field become the values of the new pivoted fields.\n * @param {string} [params.op] - The aggregation operation for the value field,\n *  applied per cell in the output stream. The default is \"sum\".\n * @param {number} [params.limit] - An optional parameter indicating the maximum\n *  number of pivoted fields to generate. The pivoted field names are sorted in\n *  ascending order prior to enforcing the limit.\n */\n\nfunction Pivot(params) {\n  Aggregate.call(this, params);\n}\n\nPivot.Definition = {\n  'type': 'Pivot',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'value',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'op',\n    'type': 'enum',\n    'values': ValidAggregateOps,\n    'default': 'sum'\n  }, {\n    'name': 'limit',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'key',\n    'type': 'field'\n  }]\n};\ninherits(Pivot, Aggregate, {\n  _transform: Aggregate.prototype.transform,\n\n  transform(_, pulse) {\n    return this._transform(aggregateParams(_, pulse), pulse);\n  }\n\n}); // Shoehorn a pivot transform into an aggregate transform!\n// First collect all unique pivot field values.\n// Then generate aggregate fields for each output pivot field.\n\nfunction aggregateParams(_, pulse) {\n  const key = _.field,\n        value = _.value,\n        op = (_.op === 'count' ? '__count__' : _.op) || 'sum',\n        fields = accessorFields(key).concat(accessorFields(value)),\n        keys = pivotKeys(key, _.limit || 0, pulse); // if data stream content changes, pivot fields may change\n  // flag parameter modification to ensure re-initialization\n\n  if (pulse.changed()) _.set('__pivot__', null, null, true);\n  return {\n    key: _.key,\n    groupby: _.groupby,\n    ops: keys.map(() => op),\n    fields: keys.map(k => get(k, key, value, fields)),\n    as: keys.map(k => k + ''),\n    modified: _.modified.bind(_)\n  };\n} // Generate aggregate field accessor.\n// Output NaN for non-existent values; aggregator will ignore!\n\n\nfunction get(k, key, value, fields) {\n  return accessor(d => key(d) === k ? value(d) : NaN, fields, k + '');\n} // Collect (and optionally limit) all unique pivot values.\n\n\nfunction pivotKeys(key, limit, pulse) {\n  const map = {},\n        list = [];\n  pulse.visit(pulse.SOURCE, t => {\n    const k = key(t);\n\n    if (!map[k]) {\n      map[k] = 1;\n      list.push(k);\n    }\n  });\n  list.sort(ascending);\n  return limit ? list.slice(0, limit) : list;\n}\n/**\n * Partitions pre-faceted data into tuple subflows.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): Array<object>} params.field - The field\n *   accessor for an array of subflow tuple objects.\n */\n\n\nfunction PreFacet(params) {\n  Facet.call(this, params);\n}\n\ninherits(PreFacet, Facet, {\n  transform(_, pulse) {\n    const flow = _.subflow,\n          field = _.field,\n          subflow = t => this.subflow(tupleid(t), flow, pulse, t);\n\n    if (_.modified('field') || field && pulse.modified(accessorFields(field))) {\n      error('PreFacet does not support field modification.');\n    }\n\n    this.initTargets(); // reset list of active subflows\n\n    if (field) {\n      pulse.visit(pulse.MOD, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.mod(_));\n      });\n      pulse.visit(pulse.ADD, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.add(ingest(_)));\n      });\n      pulse.visit(pulse.REM, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.rem(_));\n      });\n    } else {\n      pulse.visit(pulse.MOD, t => subflow(t).mod(t));\n      pulse.visit(pulse.ADD, t => subflow(t).add(t));\n      pulse.visit(pulse.REM, t => subflow(t).rem(t));\n    }\n\n    if (pulse.clean()) {\n      pulse.runAfter(() => this.clean());\n    }\n\n    return pulse;\n  }\n\n});\n/**\n * Performs a relational projection, copying selected fields from source\n * tuples to a new set of derived tuples.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *} params.fields - The fields to project,\n *   as an array of field accessors. If unspecified, all fields will be\n *   copied with names unchanged.\n * @param {Array<string>} [params.as] - Output field names for each projected\n *   field. Any unspecified fields will use the field name provided by\n *   the field accessor.\n */\n\nfunction Project(params) {\n  Transform.call(this, null, params);\n}\n\nProject.Definition = {\n  'type': 'Project',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }]\n};\ninherits(Project, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          as = fieldNames(_.fields, _.as || []),\n          derive = fields ? (s, t) => project(s, t, fields, as) : rederive;\n    let lut;\n\n    if (this.value) {\n      lut = this.value;\n    } else {\n      pulse = pulse.addAll();\n      lut = this.value = {};\n    }\n\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t);\n      out.rem.push(lut[id]);\n      lut[id] = null;\n    });\n    pulse.visit(pulse.ADD, t => {\n      const dt = derive(t, ingest({}));\n      lut[tupleid(t)] = dt;\n      out.add.push(dt);\n    });\n    pulse.visit(pulse.MOD, t => {\n      out.mod.push(derive(t, lut[tupleid(t)]));\n    });\n    return out;\n  }\n\n});\n\nfunction project(s, t, fields, as) {\n  for (let i = 0, n = fields.length; i < n; ++i) {\n    t[as[i]] = fields[i](s);\n  }\n\n  return t;\n}\n/**\n * Proxy the value of another operator as a pure signal value.\n * Ensures no tuples are propagated.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {*} params.value - The value to proxy, becomes the value of this operator.\n */\n\n\nfunction Proxy(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Proxy, Transform, {\n  transform(_, pulse) {\n    this.value = _.value;\n    return _.modified('value') ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;\n  }\n\n});\n/**\n * Generates sample quantile values from an input data stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the data field\n *   over which to calculate quantile values.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {Array<number>} [params.probs] - An array of probabilities in\n *   the range (0, 1) for which to compute quantile values. If not specified,\n *   the *step* parameter will be used.\n * @param {Array<number>} [params.step=0.01] - A probability step size for\n *   sampling quantile values. All values from one-half the step size up to\n *   1 (exclusive) will be sampled. This parameter is only used if the\n *   *quantiles* parameter is not provided.\n */\n\nfunction Quantile(params) {\n  Transform.call(this, null, params);\n}\n\nQuantile.Definition = {\n  'type': 'Quantile',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'probs',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'default': 0.01\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'default': ['prob', 'value']\n  }]\n};\nconst EPSILON = 1e-14;\ninherits(Quantile, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          as = _.as || ['prob', 'value'];\n\n    if (this.value && !_.modified() && !pulse.changed()) {\n      out.source = this.value;\n      return out;\n    }\n\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition$1(source, _.groupby, _.field),\n          names = (_.groupby || []).map(accessorName),\n          values = [],\n          step = _.step || 0.01,\n          p = _.probs || range(step / 2, 1 - EPSILON, step),\n          n = p.length;\n    groups.forEach(g => {\n      const q = quantiles(g, p);\n\n      for (let i = 0; i < n; ++i) {\n        const t = {};\n\n        for (let i = 0; i < names.length; ++i) {\n          t[names[i]] = g.dims[i];\n        }\n\n        t[as[0]] = p[i];\n        t[as[1]] = q[i];\n        values.push(ingest(t));\n      }\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n    return out;\n  }\n\n});\n/**\n * Relays a data stream between data processing pipelines.\n * If the derive parameter is set, this transform will create derived\n * copies of observed tuples. This provides derived data streams in which\n * modifications to the tuples do not pollute an upstream data source.\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.derive=false] - Boolean flag indicating if\n *   the transform should make derived copies of incoming tuples.\n * @constructor\n */\n\nfunction Relay(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Relay, Transform, {\n  transform(_, pulse) {\n    let out, lut;\n\n    if (this.value) {\n      lut = this.value;\n    } else {\n      out = pulse = pulse.addAll();\n      lut = this.value = {};\n    }\n\n    if (_.derive) {\n      out = pulse.fork(pulse.NO_SOURCE);\n      pulse.visit(pulse.REM, t => {\n        const id = tupleid(t);\n        out.rem.push(lut[id]);\n        lut[id] = null;\n      });\n      pulse.visit(pulse.ADD, t => {\n        const dt = derive(t);\n        lut[tupleid(t)] = dt;\n        out.add.push(dt);\n      });\n      pulse.visit(pulse.MOD, t => {\n        const dt = lut[tupleid(t)];\n\n        for (const k in t) {\n          dt[k] = t[k]; // down stream writes may overwrite re-derived tuples\n          // conservatively mark all source fields as modified\n\n          out.modifies(k);\n        }\n\n        out.mod.push(dt);\n      });\n    }\n\n    return out;\n  }\n\n});\n/**\n * Samples tuples passing through this operator.\n * Uses reservoir sampling to maintain a representative sample.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.size=1000] - The maximum number of samples.\n */\n\nfunction Sample(params) {\n  Transform.call(this, [], params);\n  this.count = 0;\n}\n\nSample.Definition = {\n  'type': 'Sample',\n  'metadata': {},\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'default': 1000\n  }]\n};\ninherits(Sample, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          mod = _.modified('size'),\n          num = _.size,\n          map = this.value.reduce((m, t) => (m[tupleid(t)] = 1, m), {});\n\n    let res = this.value,\n        cnt = this.count,\n        cap = 0; // sample reservoir update function\n\n    function update(t) {\n      let p, idx;\n\n      if (res.length < num) {\n        res.push(t);\n      } else {\n        idx = ~~((cnt + 1) * random());\n\n        if (idx < res.length && idx >= cap) {\n          p = res[idx];\n          if (map[tupleid(p)]) out.rem.push(p); // eviction\n\n          res[idx] = t;\n        }\n      }\n\n      ++cnt;\n    }\n\n    if (pulse.rem.length) {\n      // find all tuples that should be removed, add to output\n      pulse.visit(pulse.REM, t => {\n        const id = tupleid(t);\n\n        if (map[id]) {\n          map[id] = -1;\n          out.rem.push(t);\n        }\n\n        --cnt;\n      }); // filter removed tuples out of the sample reservoir\n\n      res = res.filter(t => map[tupleid(t)] !== -1);\n    }\n\n    if ((pulse.rem.length || mod) && res.length < num && pulse.source) {\n      // replenish sample if backing data source is available\n      cap = cnt = res.length;\n      pulse.visit(pulse.SOURCE, t => {\n        // update, but skip previously sampled tuples\n        if (!map[tupleid(t)]) update(t);\n      });\n      cap = -1;\n    }\n\n    if (mod && res.length > num) {\n      const n = res.length - num;\n\n      for (let i = 0; i < n; ++i) {\n        map[tupleid(res[i])] = -1;\n        out.rem.push(res[i]);\n      }\n\n      res = res.slice(n);\n    }\n\n    if (pulse.mod.length) {\n      // propagate modified tuples in the sample reservoir\n      pulse.visit(pulse.MOD, t => {\n        if (map[tupleid(t)]) out.mod.push(t);\n      });\n    }\n\n    if (pulse.add.length) {\n      // update sample reservoir\n      pulse.visit(pulse.ADD, update);\n    }\n\n    if (pulse.add.length || cap < 0) {\n      // output newly added tuples\n      out.add = res.filter(t => !map[tupleid(t)]);\n    }\n\n    this.count = cnt;\n    this.value = out.source = res;\n    return out;\n  }\n\n});\n/**\n * Generates data tuples for a specified sequence range of numbers.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} params.start - The first number in the sequence.\n * @param {number} params.stop - The last number (exclusive) in the sequence.\n * @param {number} [params.step=1] - The step size between numbers in the sequence.\n */\n\nfunction Sequence(params) {\n  Transform.call(this, null, params);\n}\n\nSequence.Definition = {\n  'type': 'Sequence',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'start',\n    'type': 'number',\n    'required': true\n  }, {\n    'name': 'stop',\n    'type': 'number',\n    'required': true\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'default': 1\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'data'\n  }]\n};\ninherits(Sequence, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) return;\n    const out = pulse.materialize().fork(pulse.MOD),\n          as = _.as || 'data';\n    out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;\n    this.value = range(_.start, _.stop, _.step || 1).map(v => {\n      const t = {};\n      t[as] = v;\n      return ingest(t);\n    });\n    out.add = pulse.add.concat(this.value);\n    return out;\n  }\n\n});\n/**\n * Propagates a new pulse without any tuples so long as the input\n * pulse contains some added, removed or modified tuples.\n * @param {object} params - The parameters for this operator.\n * @constructor\n */\n\nfunction Sieve(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\ninherits(Sieve, Transform, {\n  transform(_, pulse) {\n    this.value = pulse.source;\n    return pulse.changed() ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;\n  }\n\n});\n/**\n * Discretize dates to specific time units.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The data field containing date/time values.\n */\n\nfunction TimeUnit(params) {\n  Transform.call(this, null, params);\n}\n\nconst OUTPUT = ['unit0', 'unit1'];\nTimeUnit.Definition = {\n  'type': 'TimeUnit',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'interval',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'units',\n    'type': 'enum',\n    'values': TIME_UNITS,\n    'array': true\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'default': 1\n  }, {\n    'name': 'maxbins',\n    'type': 'number',\n    'default': 40\n  }, {\n    'name': 'extent',\n    'type': 'date',\n    'array': true\n  }, {\n    'name': 'timezone',\n    'type': 'enum',\n    'default': 'local',\n    'values': ['local', 'utc']\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': OUTPUT\n  }]\n};\ninherits(TimeUnit, Transform, {\n  transform(_, pulse) {\n    const field = _.field,\n          band = _.interval !== false,\n          utc = _.timezone === 'utc',\n          floor = this._floor(_, pulse),\n          offset = (utc ? utcInterval : timeInterval)(floor.unit).offset,\n          as = _.as || OUTPUT,\n          u0 = as[0],\n          u1 = as[1],\n          step = floor.step;\n\n    let min = floor.start || Infinity,\n        max = floor.stop || -Infinity,\n        flag = pulse.ADD;\n\n    if (_.modified() || pulse.modified(accessorFields(field))) {\n      pulse = pulse.reflow(true);\n      flag = pulse.SOURCE;\n      min = Infinity;\n      max = -Infinity;\n    }\n\n    pulse.visit(flag, t => {\n      const v = field(t);\n      let a, b;\n\n      if (v == null) {\n        t[u0] = null;\n        if (band) t[u1] = null;\n      } else {\n        t[u0] = a = b = floor(v);\n        if (band) t[u1] = b = offset(a, step);\n        if (a < min) min = a;\n        if (b > max) max = b;\n      }\n    });\n    floor.start = min;\n    floor.stop = max;\n    return pulse.modifies(band ? as : u0);\n  },\n\n  _floor(_, pulse) {\n    const utc = _.timezone === 'utc'; // get parameters\n\n    const {\n      units,\n      step\n    } = _.units ? {\n      units: _.units,\n      step: _.step || 1\n    } : timeBin({\n      extent: _.extent || extent(pulse.materialize(pulse.SOURCE).source, _.field),\n      maxbins: _.maxbins\n    }); // check / standardize time units\n\n    const tunits = timeUnits(units),\n          prev = this.value || {},\n          floor = (utc ? utcFloor : timeFloor)(tunits, step);\n    floor.unit = peek(tunits);\n    floor.units = tunits;\n    floor.step = step;\n    floor.start = prev.start;\n    floor.stop = prev.stop;\n    return this.value = floor;\n  }\n\n});\n/**\n * An index that maps from unique, string-coerced, field values to tuples.\n * Assumes that the field serves as a unique key with no duplicate values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field accessor to index.\n */\n\nfunction TupleIndex(params) {\n  Transform.call(this, fastmap(), params);\n}\n\ninherits(TupleIndex, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          field = _.field,\n          index = this.value,\n          set = t => index.set(field(t), t);\n\n    let mod = true;\n\n    if (_.modified('field') || pulse.modified(field.fields)) {\n      index.clear();\n      pulse.visit(pulse.SOURCE, set);\n    } else if (pulse.changed()) {\n      pulse.visit(pulse.REM, t => index.delete(field(t)));\n      pulse.visit(pulse.ADD, set);\n    } else {\n      mod = false;\n    }\n\n    this.modified(mod);\n    if (index.empty > df.cleanThreshold) df.runAfter(index.clean);\n    return pulse.fork();\n  }\n\n});\n/**\n * Extracts an array of values. Assumes the source data has already been\n * reduced as needed (e.g., by an upstream Aggregate transform).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The domain field to extract.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting the values. The comparator will be\n *   applied to backing tuples prior to value extraction.\n */\n\nfunction Values(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Values, Transform, {\n  transform(_, pulse) {\n    const run = !this.value || _.modified('field') || _.modified('sort') || pulse.changed() || _.sort && pulse.modified(_.sort.fields);\n\n    if (run) {\n      this.value = (_.sort ? pulse.source.slice().sort(stableCompare(_.sort)) : pulse.source).map(_.field);\n    }\n  }\n\n});\n\nfunction WindowOp(op, field, param, as) {\n  const fn = WindowOps[op](field, param);\n  return {\n    init: fn.init || zero,\n    update: function (w, t) {\n      t[as] = fn.next(w);\n    }\n  };\n}\n\nconst WindowOps = {\n  row_number: function () {\n    return {\n      next: w => w.index + 1\n    };\n  },\n  rank: function () {\n    let rank;\n    return {\n      init: () => rank = 1,\n      next: w => {\n        const i = w.index,\n              data = w.data;\n        return i && w.compare(data[i - 1], data[i]) ? rank = i + 1 : rank;\n      }\n    };\n  },\n  dense_rank: function () {\n    let drank;\n    return {\n      init: () => drank = 1,\n      next: w => {\n        const i = w.index,\n              d = w.data;\n        return i && w.compare(d[i - 1], d[i]) ? ++drank : drank;\n      }\n    };\n  },\n  percent_rank: function () {\n    const rank = WindowOps.rank(),\n          next = rank.next;\n    return {\n      init: rank.init,\n      next: w => (next(w) - 1) / (w.data.length - 1)\n    };\n  },\n  cume_dist: function () {\n    let cume;\n    return {\n      init: () => cume = 0,\n      next: w => {\n        const d = w.data,\n              c = w.compare;\n        let i = w.index;\n\n        if (cume < i) {\n          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;\n\n          cume = i;\n        }\n\n        return (1 + cume) / d.length;\n      }\n    };\n  },\n  ntile: function (field, num) {\n    num = +num;\n    if (!(num > 0)) error('ntile num must be greater than zero.');\n    const cume = WindowOps.cume_dist(),\n          next = cume.next;\n    return {\n      init: cume.init,\n      next: w => Math.ceil(num * next(w))\n    };\n  },\n  lag: function (field, offset) {\n    offset = +offset || 1;\n    return {\n      next: w => {\n        const i = w.index - offset;\n        return i >= 0 ? field(w.data[i]) : null;\n      }\n    };\n  },\n  lead: function (field, offset) {\n    offset = +offset || 1;\n    return {\n      next: w => {\n        const i = w.index + offset,\n              d = w.data;\n        return i < d.length ? field(d[i]) : null;\n      }\n    };\n  },\n  first_value: function (field) {\n    return {\n      next: w => field(w.data[w.i0])\n    };\n  },\n  last_value: function (field) {\n    return {\n      next: w => field(w.data[w.i1 - 1])\n    };\n  },\n  nth_value: function (field, nth) {\n    nth = +nth;\n    if (!(nth > 0)) error('nth_value nth must be greater than zero.');\n    return {\n      next: w => {\n        const i = w.i0 + (nth - 1);\n        return i < w.i1 ? field(w.data[i]) : null;\n      }\n    };\n  },\n  prev_value: function (field) {\n    let prev;\n    return {\n      init: () => prev = null,\n      next: w => {\n        const v = field(w.data[w.index]);\n        return v != null ? prev = v : prev;\n      }\n    };\n  },\n  next_value: function (field) {\n    let v, i;\n    return {\n      init: () => (v = null, i = -1),\n      next: w => {\n        const d = w.data;\n        return w.index <= i ? v : (i = find(field, d, w.index)) < 0 ? (i = d.length, v = null) : v = field(d[i]);\n      }\n    };\n  }\n};\n\nfunction find(field, data, index) {\n  for (let n = data.length; index < n; ++index) {\n    const v = field(data[index]);\n    if (v != null) return index;\n  }\n\n  return -1;\n}\n\nconst ValidWindowOps = Object.keys(WindowOps);\n\nfunction WindowState(_) {\n  const ops = array(_.ops),\n        fields = array(_.fields),\n        params = array(_.params),\n        as = array(_.as),\n        outputs = this.outputs = [],\n        windows = this.windows = [],\n        inputs = {},\n        map = {},\n        counts = [],\n        measures = [];\n  let countOnly = true;\n\n  function visitInputs(f) {\n    array(accessorFields(f)).forEach(_ => inputs[_] = 1);\n  }\n\n  visitInputs(_.sort);\n  ops.forEach((op, i) => {\n    const field = fields[i],\n          mname = accessorName(field),\n          name = measureName(op, mname, as[i]);\n    visitInputs(field);\n    outputs.push(name); // Window operation\n\n    if (hasOwnProperty(WindowOps, op)) {\n      windows.push(WindowOp(op, fields[i], params[i], name));\n    } // Aggregate operation\n    else {\n      if (field == null && op !== 'count') {\n        error('Null aggregate field specified.');\n      }\n\n      if (op === 'count') {\n        counts.push(name);\n        return;\n      }\n\n      countOnly = false;\n      let m = map[mname];\n\n      if (!m) {\n        m = map[mname] = [];\n        m.field = field;\n        measures.push(m);\n      }\n\n      m.push(createMeasure(op, name));\n    }\n  });\n\n  if (counts.length || measures.length) {\n    this.cell = cell(measures, counts, countOnly);\n  }\n\n  this.inputs = Object.keys(inputs);\n}\n\nconst prototype = WindowState.prototype;\n\nprototype.init = function () {\n  this.windows.forEach(_ => _.init());\n  if (this.cell) this.cell.init();\n};\n\nprototype.update = function (w, t) {\n  const cell = this.cell,\n        wind = this.windows,\n        data = w.data,\n        m = wind && wind.length;\n  let j;\n\n  if (cell) {\n    for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);\n\n    for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);\n\n    cell.set(t);\n  }\n\n  for (j = 0; j < m; ++j) wind[j].update(w, t);\n};\n\nfunction cell(measures, counts, countOnly) {\n  measures = measures.map(m => compileMeasures(m, m.field));\n  const cell = {\n    num: 0,\n    agg: null,\n    store: false,\n    count: counts\n  };\n\n  if (!countOnly) {\n    var n = measures.length,\n        a = cell.agg = Array(n),\n        i = 0;\n\n    for (; i < n; ++i) a[i] = new measures[i](cell);\n  }\n\n  if (cell.store) {\n    var store = cell.data = new TupleStore();\n  }\n\n  cell.add = function (t) {\n    cell.num += 1;\n    if (countOnly) return;\n    if (store) store.add(t);\n\n    for (let i = 0; i < n; ++i) {\n      a[i].add(a[i].get(t), t);\n    }\n  };\n\n  cell.rem = function (t) {\n    cell.num -= 1;\n    if (countOnly) return;\n    if (store) store.rem(t);\n\n    for (let i = 0; i < n; ++i) {\n      a[i].rem(a[i].get(t), t);\n    }\n  };\n\n  cell.set = function (t) {\n    let i, n; // consolidate stored values\n\n    if (store) store.values(); // update tuple properties\n\n    for (i = 0, n = counts.length; i < n; ++i) t[counts[i]] = cell.num;\n\n    if (!countOnly) for (i = 0, n = a.length; i < n; ++i) a[i].set(t);\n  };\n\n  cell.init = function () {\n    cell.num = 0;\n    if (store) store.reset();\n\n    for (let i = 0; i < n; ++i) a[i].init();\n  };\n\n  return cell;\n}\n/**\n * Perform window calculations and write results to the input stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\n * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors\n *   for data fields to use as inputs to window operations.\n * @param {Array<*>} [params.params] - An array of parameter values for window operations.\n * @param {Array<string>} [params.as] - An array of output field names for window operations.\n * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\n * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\n *   number alone, ignoring peers with identical sort values. If false (default),\n *   the window boundaries will be adjusted to include peer values.\n */\n\n\nfunction Window(params) {\n  Transform.call(this, {}, params);\n  this._mlen = 0;\n  this._mods = [];\n}\n\nWindow.Definition = {\n  'type': 'Window',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'ops',\n    'type': 'enum',\n    'array': true,\n    'values': ValidWindowOps.concat(ValidAggregateOps)\n  }, {\n    'name': 'params',\n    'type': 'number',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'frame',\n    'type': 'number',\n    'null': true,\n    'array': true,\n    'length': 2,\n    'default': [null, 0]\n  }, {\n    'name': 'ignorePeers',\n    'type': 'boolean',\n    'default': false\n  }]\n};\ninherits(Window, Transform, {\n  transform(_, pulse) {\n    this.stamp = pulse.stamp;\n\n    const mod = _.modified(),\n          cmp = stableCompare(_.sort),\n          key = groupkey(_.groupby),\n          group = t => this.group(key(t)); // initialize window state\n\n\n    let state = this.state;\n\n    if (!state || mod) {\n      state = this.state = new WindowState(_);\n    } // partition input tuples\n\n\n    if (mod || pulse.modified(state.inputs)) {\n      this.value = {};\n      pulse.visit(pulse.SOURCE, t => group(t).add(t));\n    } else {\n      pulse.visit(pulse.REM, t => group(t).remove(t));\n      pulse.visit(pulse.ADD, t => group(t).add(t));\n    } // perform window calculations for each modified partition\n\n\n    for (let i = 0, n = this._mlen; i < n; ++i) {\n      processPartition(this._mods[i], state, cmp, _);\n    }\n\n    this._mlen = 0;\n    this._mods = []; // TODO don't reflow everything?\n\n    return pulse.reflow(mod).modifies(state.outputs);\n  },\n\n  group(key) {\n    let group = this.value[key];\n\n    if (!group) {\n      group = this.value[key] = SortedList(tupleid);\n      group.stamp = -1;\n    }\n\n    if (group.stamp < this.stamp) {\n      group.stamp = this.stamp;\n      this._mods[this._mlen++] = group;\n    }\n\n    return group;\n  }\n\n});\n\nfunction processPartition(list, state, cmp, _) {\n  const sort = _.sort,\n        range = sort && !_.ignorePeers,\n        frame = _.frame || [null, 0],\n        data = list.data(cmp),\n        // use cmp for stable sort\n  n = data.length,\n        b = range ? bisector(sort) : null,\n        w = {\n    i0: 0,\n    i1: 0,\n    p0: 0,\n    p1: 0,\n    index: 0,\n    data: data,\n    compare: sort || constant(-1)\n  };\n  state.init();\n\n  for (let i = 0; i < n; ++i) {\n    setWindow(w, frame, i, n);\n    if (range) adjustRange(w, b);\n    state.update(w, data[i]);\n  }\n}\n\nfunction setWindow(w, f, i, n) {\n  w.p0 = w.i0;\n  w.p1 = w.i1;\n  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\n  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\n  w.index = i;\n} // if frame type is 'range', adjust window for peer values\n\n\nfunction adjustRange(w, bisect) {\n  const r0 = w.i0,\n        r1 = w.i1 - 1,\n        c = w.compare,\n        d = w.data,\n        n = d.length - 1;\n  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);\n  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);\n}\n\nexport { Aggregate as aggregate, Bin as bin, Collect as collect, Compare as compare, CountPattern as countpattern, Cross as cross, Density as density, DotBin as dotbin, Expression as expression, Extent as extent, Facet as facet, Field as field, Filter as filter, Flatten as flatten, Fold as fold, Formula as formula, Generate as generate, Impute as impute, JoinAggregate as joinaggregate, KDE as kde, Key as key, Load as load, Lookup as lookup, MultiExtent as multiextent, MultiValues as multivalues, Params as params, Pivot as pivot, PreFacet as prefacet, Project as project, Proxy as proxy, Quantile as quantile, Relay as relay, Sample as sample, Sequence as sequence, Sieve as sieve, Subflow as subflow, TimeUnit as timeunit, TupleIndex as tupleindex, Values as values, Window as window };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-transforms/build/vega-transforms.module.js"],"names":["extend","identity","field","hasOwnProperty","extentIndex","inherits","array","accessorName","error","accessorFields","accessor","toNumber","merge","compare","truthy","extent","span","fastmap","isArray","key","ascending","peek","zero","constant","tupleid","Transform","replace","ingest","stableCompare","Operator","derive","rederive","quartiles","bootstrapCI","bin","randomKDE","randomMixture","randomNormal","randomLogNormal","randomUniform","sampleCurve","dotbin","quantiles","random","median","mean","min","max","range","bisector","TIME_UNITS","utcInterval","timeInterval","timeBin","timeUnits","utcFloor","timeFloor","multikey","f","x","n","length","i","k","String","groupkey","fields","measureName","op","as","noop","base_op","init","add","rem","idx","AggregateOps","values","m","cell","store","value","data","count","num","__count__","missing","valid","sum","v","product","undefined","mean_d","average","req","variance","dev","variancep","stdev","Math","sqrt","stdevp","stderr","distinct","get","ci0","ci1","q2","q1","q3","Number","isNaN","NaN","argmin","t","argmax","ValidAggregateOps","Object","keys","measure","out","name","forEach","createMeasure","compareIndex","a","b","resolve","agg","map","getreqs","sort","_ops","set","_out","compileMeasures","ops","slice","ctr","prototype","TupleStore","_key","reset","prototype$1","_add","_rem","_ext","_get","_q","push","r","Array","j","s","quartile","ci","_ci","Aggregate","params","call","_adds","_mods","_alen","_mlen","_drop","_cross","_dims","_dnames","_measures","_countOnly","_counts","_prev","_inputs","_outputs","Definition","transform","_","pulse","aggr","fork","NO_SOURCE","NO_FIELDS","mod","modified","stamp","visit","SOURCE","REM","ADD","modifies","drop","cross","clean","runAfter","changes","curr","dims","vals","collect","cells","tuple","generate","base","index","inputs","outputs","inputMap","inputVisit","groupby","d","dname","cellkey","mname","outname","newcell","newtuple","measures","p","names","celltuple","counts","adds","mods","prev","EPSILON$1","Bin","band","interval","bins","_bins","start","step","b0","b1","flag","reflow","ADD_MOD","stop","ceil","anchor","floor","Infinity","SortedList","idFunc","source","input","$","cnt","remove","size","resort","filter","concat","Collect","ALL","list","materialize","changed","root","Compare","update$5","orders","CountPattern","tokenize","text","tcase","match","toUpperCase","toLowerCase","process","update","tokens","case","test","_parameterCheck","_match","_stop","_finish","RegExp","stopwords","pattern","tuples","_tuples","w","c","Cross","ADD_REM","left","Distributions","kde","mixture","normal","lognormal","uniform","DISTRIBUTIONS","FUNCTION","FIELD","parse","def","func","from","Density","distributions","dist","distribution","minsteps","steps","maxsteps","method","domain","fieldNames","partition$1","groups","g","Output","DotBin","autostep","smooth","Expression","update$4","expr","datum","Extent","isFinite","dataflow","warn","Subflow","parent","connect","target","detachSubflow","targets","evaluate","Facet","_keys","_targets","active","activate","flow","subflow","flows","sf","df","_group","detached","detach","initTargets","act","cache","rekey","group","id","delete","MOD","k0","k1","REFLOW","empty","cleanThreshold","Field","update$3","Filter","output","isMod","has","revisit","Flatten","arrays","maxlen","reduce","l","Fold","fnames","Formula","initonly","Generate","gen","generator","Methods","Empty","Impute","getValue","getField","impute","fName","kName","gNames","partition","keyvals","gVals","kVal","_impute","kMap","gMap","gKey","JoinAggregate","KDE","bandwidth","cumulative","density","scale","local","Key","update$2","flat","Load","_pending","StopPropagation","format","async","request","url","then","res","touch","Lookup","defaultValue","default","some","MultiExtent","update$1","ext","extents","e","MultiValues","Params","Pivot","_transform","aggregateParams","pivotKeys","limit","bind","PreFacet","Project","project","lut","addAll","dt","Proxy","Quantile","EPSILON","probs","q","Relay","Sample","cap","Sequence","Sieve","TimeUnit","OUTPUT","utc","timezone","_floor","offset","unit","u0","u1","units","maxbins","tunits","TupleIndex","clear","Values","run","WindowOp","param","fn","WindowOps","next","row_number","rank","dense_rank","drank","percent_rank","cume_dist","cume","ntile","lag","lead","first_value","i0","last_value","i1","nth_value","nth","prev_value","next_value","find","ValidWindowOps","WindowState","windows","countOnly","visitInputs","wind","p0","p1","Window","cmp","state","processPartition","ignorePeers","frame","setWindow","adjustRange","abs","bisect","r0","r1","right","aggregate","countpattern","expression","facet","flatten","fold","formula","joinaggregate","load","lookup","multiextent","multivalues","pivot","prefacet","proxy","quantile","relay","sample","sequence","sieve","timeunit","tupleindex","window"],"mappings":"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","sourcesContent":["import { extend, identity, field, hasOwnProperty, extentIndex, inherits, array, accessorName, error, accessorFields, accessor, toNumber, merge, compare, truthy, extent, span, fastmap, isArray, key, ascending, peek, zero, constant } from 'vega-util';\nimport { tupleid, Transform, replace, ingest, stableCompare, Operator, derive, rederive } from 'vega-dataflow';\nimport { quartiles, bootstrapCI, bin, randomKDE, randomMixture, randomNormal, randomLogNormal, randomUniform, sampleCurve, dotbin, quantiles, random } from 'vega-statistics';\nimport { median, mean, min, max, range, bisector } from 'd3-array';\nimport { TIME_UNITS, utcInterval, timeInterval, timeBin, timeUnits, utcFloor, timeFloor } from 'vega-time';\n\nfunction multikey(f) {\n  return x => {\n    const n = f.length;\n    let i = 1,\n        k = String(f[0](x));\n\n    for (; i < n; ++i) {\n      k += '|' + f[i](x);\n    }\n\n    return k;\n  };\n}\nfunction groupkey(fields) {\n  return !fields || !fields.length ? function () {\n    return '';\n  } : fields.length === 1 ? fields[0] : multikey(fields);\n}\n\nfunction measureName(op, field, as) {\n  return as || op + (!field ? '' : '_' + field);\n}\n\nconst noop = () => {};\n\nconst base_op = {\n  init: noop,\n  add: noop,\n  rem: noop,\n  idx: 0\n};\nconst AggregateOps = {\n  values: {\n    init: m => m.cell.store = true,\n    value: m => m.cell.data.values(),\n    idx: -1\n  },\n  count: {\n    value: m => m.cell.num\n  },\n  __count__: {\n    value: m => m.missing + m.valid\n  },\n  missing: {\n    value: m => m.missing\n  },\n  valid: {\n    value: m => m.valid\n  },\n  sum: {\n    init: m => m.sum = 0,\n    value: m => m.sum,\n    add: (m, v) => m.sum += +v,\n    rem: (m, v) => m.sum -= v\n  },\n  product: {\n    init: m => m.product = 1,\n    value: m => m.valid ? m.product : undefined,\n    add: (m, v) => m.product *= v,\n    rem: (m, v) => m.product /= v\n  },\n  mean: {\n    init: m => m.mean = 0,\n    value: m => m.valid ? m.mean : undefined,\n    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),\n    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)\n  },\n  average: {\n    value: m => m.valid ? m.mean : undefined,\n    req: ['mean'],\n    idx: 1\n  },\n  variance: {\n    init: m => m.dev = 0,\n    value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,\n    add: (m, v) => m.dev += m.mean_d * (v - m.mean),\n    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),\n    req: ['mean'],\n    idx: 1\n  },\n  variancep: {\n    value: m => m.valid > 1 ? m.dev / m.valid : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  stdev: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  stdevp: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  stderr: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,\n    req: ['variance'],\n    idx: 2\n  },\n  distinct: {\n    value: m => m.cell.data.distinct(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  ci0: {\n    value: m => m.cell.data.ci0(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  ci1: {\n    value: m => m.cell.data.ci1(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  median: {\n    value: m => m.cell.data.q2(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  q1: {\n    value: m => m.cell.data.q1(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  q3: {\n    value: m => m.cell.data.q3(m.get),\n    req: ['values'],\n    idx: 3\n  },\n  min: {\n    init: m => m.min = undefined,\n    value: m => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,\n    add: (m, v) => {\n      if (v < m.min || m.min === undefined) m.min = v;\n    },\n    rem: (m, v) => {\n      if (v <= m.min) m.min = NaN;\n    },\n    req: ['values'],\n    idx: 4\n  },\n  max: {\n    init: m => m.max = undefined,\n    value: m => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,\n    add: (m, v) => {\n      if (v > m.max || m.max === undefined) m.max = v;\n    },\n    rem: (m, v) => {\n      if (v >= m.max) m.max = NaN;\n    },\n    req: ['values'],\n    idx: 4\n  },\n  argmin: {\n    init: m => m.argmin = undefined,\n    value: m => m.argmin || m.cell.data.argmin(m.get),\n    add: (m, v, t) => {\n      if (v < m.min) m.argmin = t;\n    },\n    rem: (m, v) => {\n      if (v <= m.min) m.argmin = undefined;\n    },\n    req: ['min', 'values'],\n    idx: 3\n  },\n  argmax: {\n    init: m => m.argmax = undefined,\n    value: m => m.argmax || m.cell.data.argmax(m.get),\n    add: (m, v, t) => {\n      if (v > m.max) m.argmax = t;\n    },\n    rem: (m, v) => {\n      if (v >= m.max) m.argmax = undefined;\n    },\n    req: ['max', 'values'],\n    idx: 3\n  }\n};\nconst ValidAggregateOps = Object.keys(AggregateOps);\n\nfunction measure(key, value) {\n  return out => extend({\n    name: key,\n    out: out || key\n  }, base_op, value);\n}\n\nValidAggregateOps.forEach(key => {\n  AggregateOps[key] = measure(key, AggregateOps[key]);\n});\nfunction createMeasure(op, name) {\n  return AggregateOps[op](name);\n}\n\nfunction compareIndex(a, b) {\n  return a.idx - b.idx;\n}\n\nfunction resolve(agg) {\n  const map = {};\n  agg.forEach(a => map[a.name] = a);\n\n  const getreqs = a => {\n    if (!a.req) return;\n    a.req.forEach(key => {\n      if (!map[key]) getreqs(map[key] = AggregateOps[key]());\n    });\n  };\n\n  agg.forEach(getreqs);\n  return Object.values(map).sort(compareIndex);\n}\n\nfunction init() {\n  this.valid = 0;\n  this.missing = 0;\n\n  this._ops.forEach(op => op.init(this));\n}\n\nfunction add(v, t) {\n  if (v == null || v === '') {\n    ++this.missing;\n    return;\n  }\n\n  if (v !== v) return;\n  ++this.valid;\n\n  this._ops.forEach(op => op.add(this, v, t));\n}\n\nfunction rem(v, t) {\n  if (v == null || v === '') {\n    --this.missing;\n    return;\n  }\n\n  if (v !== v) return;\n  --this.valid;\n\n  this._ops.forEach(op => op.rem(this, v, t));\n}\n\nfunction set(t) {\n  this._out.forEach(op => t[op.out] = op.value(this));\n\n  return t;\n}\n\nfunction compileMeasures(agg, field) {\n  const get = field || identity,\n        ops = resolve(agg),\n        out = agg.slice().sort(compareIndex);\n\n  function ctr(cell) {\n    this._ops = ops;\n    this._out = out;\n    this.cell = cell;\n    this.init();\n  }\n\n  ctr.prototype.init = init;\n  ctr.prototype.add = add;\n  ctr.prototype.rem = rem;\n  ctr.prototype.set = set;\n  ctr.prototype.get = get;\n  ctr.fields = agg.map(op => op.out);\n  return ctr;\n}\n\nfunction TupleStore(key) {\n  this._key = key ? field(key) : tupleid;\n  this.reset();\n}\nconst prototype$1 = TupleStore.prototype;\n\nprototype$1.reset = function () {\n  this._add = [];\n  this._rem = [];\n  this._ext = null;\n  this._get = null;\n  this._q = null;\n};\n\nprototype$1.add = function (v) {\n  this._add.push(v);\n};\n\nprototype$1.rem = function (v) {\n  this._rem.push(v);\n};\n\nprototype$1.values = function () {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n  const a = this._add,\n        r = this._rem,\n        k = this._key,\n        n = a.length,\n        m = r.length,\n        x = Array(n - m),\n        map = {};\n  let i, j, v; // use unique key field to clear removed values\n\n  for (i = 0; i < m; ++i) {\n    map[k(r[i])] = 1;\n  }\n\n  for (i = 0, j = 0; i < n; ++i) {\n    if (map[k(v = a[i])]) {\n      map[k(v)] = 0;\n    } else {\n      x[j++] = v;\n    }\n  }\n\n  this._rem = [];\n  return this._add = x;\n}; // memoizing statistics methods\n\n\nprototype$1.distinct = function (get) {\n  const v = this.values(),\n        map = {};\n  let n = v.length,\n      count = 0,\n      s;\n\n  while (--n >= 0) {\n    s = get(v[n]) + '';\n\n    if (!hasOwnProperty(map, s)) {\n      map[s] = 1;\n      ++count;\n    }\n  }\n\n  return count;\n};\n\nprototype$1.extent = function (get) {\n  if (this._get !== get || !this._ext) {\n    const v = this.values(),\n          i = extentIndex(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;\n  }\n\n  return this._ext;\n};\n\nprototype$1.argmin = function (get) {\n  return this.extent(get)[0] || {};\n};\n\nprototype$1.argmax = function (get) {\n  return this.extent(get)[1] || {};\n};\n\nprototype$1.min = function (get) {\n  const m = this.extent(get)[0];\n  return m != null ? get(m) : undefined;\n};\n\nprototype$1.max = function (get) {\n  const m = this.extent(get)[1];\n  return m != null ? get(m) : undefined;\n};\n\nprototype$1.quartile = function (get) {\n  if (this._get !== get || !this._q) {\n    this._q = quartiles(this.values(), get);\n    this._get = get;\n  }\n\n  return this._q;\n};\n\nprototype$1.q1 = function (get) {\n  return this.quartile(get)[0];\n};\n\nprototype$1.q2 = function (get) {\n  return this.quartile(get)[1];\n};\n\nprototype$1.q3 = function (get) {\n  return this.quartile(get)[2];\n};\n\nprototype$1.ci = function (get) {\n  if (this._get !== get || !this._ci) {\n    this._ci = bootstrapCI(this.values(), 1000, 0.05, get);\n    this._get = get;\n  }\n\n  return this._ci;\n};\n\nprototype$1.ci0 = function (get) {\n  return this.ci(get)[0];\n};\n\nprototype$1.ci1 = function (get) {\n  return this.ci(get)[1];\n};\n\n/**\n * Group-by aggregation operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n * @param {boolean} [params.cross=false] - A flag indicating that the full\n *   cross-product of groupby values should be generated, including empty cells.\n *   If true, the drop parameter is ignored and empty cells are retained.\n * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n */\n\nfunction Aggregate(params) {\n  Transform.call(this, null, params);\n  this._adds = []; // array of added output tuples\n\n  this._mods = []; // array of modified output tuples\n\n  this._alen = 0; // number of active added tuples\n\n  this._mlen = 0; // number of active modified tuples\n\n  this._drop = true; // should empty aggregation cells be removed\n\n  this._cross = false; // produce full cross-product of group-by values\n\n  this._dims = []; // group-by dimension accessors\n\n  this._dnames = []; // group-by dimension names\n\n  this._measures = []; // collection of aggregation monoids\n\n  this._countOnly = false; // flag indicating only count aggregation\n\n  this._counts = null; // collection of count fields\n\n  this._prev = null; // previous aggregation cells\n\n  this._inputs = null; // array of dependent input tuple field names\n\n  this._outputs = null; // array of output tuple field names\n}\nAggregate.Definition = {\n  'type': 'Aggregate',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'ops',\n    'type': 'enum',\n    'array': true,\n    'values': ValidAggregateOps\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'drop',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'cross',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'key',\n    'type': 'field'\n  }]\n};\ninherits(Aggregate, Transform, {\n  transform(_, pulse) {\n    const aggr = this,\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          mod = _.modified();\n\n    aggr.stamp = out.stamp;\n\n    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n      aggr._prev = aggr.value;\n      aggr.value = mod ? aggr.init(_) : {};\n      pulse.visit(pulse.SOURCE, t => aggr.add(t));\n    } else {\n      aggr.value = aggr.value || aggr.init(_);\n      pulse.visit(pulse.REM, t => aggr.rem(t));\n      pulse.visit(pulse.ADD, t => aggr.add(t));\n    } // Indicate output fields and return aggregate tuples.\n\n\n    out.modifies(aggr._outputs); // Should empty cells be dropped?\n\n    aggr._drop = _.drop !== false; // If domain cross-product requested, generate empty cells as needed\n    // and ensure that empty cells are not dropped\n\n    if (_.cross && aggr._dims.length > 1) {\n      aggr._drop = false;\n      aggr.cross();\n    }\n\n    if (pulse.clean() && aggr._drop) {\n      out.clean(true).runAfter(() => this.clean());\n    }\n\n    return aggr.changes(out);\n  },\n\n  cross() {\n    const aggr = this,\n          curr = aggr.value,\n          dims = aggr._dnames,\n          vals = dims.map(() => ({})),\n          n = dims.length; // collect all group-by domain values\n\n    function collect(cells) {\n      let key, i, t, v;\n\n      for (key in cells) {\n        t = cells[key].tuple;\n\n        for (i = 0; i < n; ++i) {\n          vals[i][v = t[dims[i]]] = v;\n        }\n      }\n    }\n\n    collect(aggr._prev);\n    collect(curr); // iterate over key cross-product, create cells as needed\n\n    function generate(base, tuple, index) {\n      const name = dims[index],\n            v = vals[index++];\n\n      for (const k in v) {\n        const key = base ? base + '|' + k : k;\n        tuple[name] = v[k];\n        if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);\n      }\n    }\n\n    generate('', {}, 0);\n  },\n\n  init(_) {\n    // initialize input and output fields\n    const inputs = this._inputs = [],\n          outputs = this._outputs = [],\n          inputMap = {};\n\n    function inputVisit(get) {\n      const fields = array(accessorFields(get)),\n            n = fields.length;\n      let i = 0,\n          f;\n\n      for (; i < n; ++i) {\n        if (!inputMap[f = fields[i]]) {\n          inputMap[f] = 1;\n          inputs.push(f);\n        }\n      }\n    } // initialize group-by dimensions\n\n\n    this._dims = array(_.groupby);\n    this._dnames = this._dims.map(d => {\n      const dname = accessorName(d);\n      inputVisit(d);\n      outputs.push(dname);\n      return dname;\n    });\n    this.cellkey = _.key ? _.key : groupkey(this._dims); // initialize aggregate measures\n\n    this._countOnly = true;\n    this._counts = [];\n    this._measures = [];\n    const fields = _.fields || [null],\n          ops = _.ops || ['count'],\n          as = _.as || [],\n          n = fields.length,\n          map = {};\n    let field, op, m, mname, outname, i;\n\n    if (n !== ops.length) {\n      error('Unmatched number of fields and aggregate ops.');\n    }\n\n    for (i = 0; i < n; ++i) {\n      field = fields[i];\n      op = ops[i];\n\n      if (field == null && op !== 'count') {\n        error('Null aggregate field specified.');\n      }\n\n      mname = accessorName(field);\n      outname = measureName(op, mname, as[i]);\n      outputs.push(outname);\n\n      if (op === 'count') {\n        this._counts.push(outname);\n\n        continue;\n      }\n\n      m = map[mname];\n\n      if (!m) {\n        inputVisit(field);\n        m = map[mname] = [];\n        m.field = field;\n\n        this._measures.push(m);\n      }\n\n      if (op !== 'count') this._countOnly = false;\n      m.push(createMeasure(op, outname));\n    }\n\n    this._measures = this._measures.map(m => compileMeasures(m, m.field));\n    return {}; // aggregation cells (this.value)\n  },\n\n  // -- Cell Management -----\n  cellkey: groupkey(),\n\n  cell(key, t) {\n    let cell = this.value[key];\n\n    if (!cell) {\n      cell = this.value[key] = this.newcell(key, t);\n      this._adds[this._alen++] = cell;\n    } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n      cell.stamp = this.stamp;\n      this._adds[this._alen++] = cell;\n    } else if (cell.stamp < this.stamp) {\n      cell.stamp = this.stamp;\n      this._mods[this._mlen++] = cell;\n    }\n\n    return cell;\n  },\n\n  newcell(key, t) {\n    const cell = {\n      key: key,\n      num: 0,\n      agg: null,\n      tuple: this.newtuple(t, this._prev && this._prev[key]),\n      stamp: this.stamp,\n      store: false\n    };\n\n    if (!this._countOnly) {\n      const measures = this._measures,\n            n = measures.length;\n      cell.agg = Array(n);\n\n      for (let i = 0; i < n; ++i) {\n        cell.agg[i] = new measures[i](cell);\n      }\n    }\n\n    if (cell.store) {\n      cell.data = new TupleStore();\n    }\n\n    return cell;\n  },\n\n  newtuple(t, p) {\n    const names = this._dnames,\n          dims = this._dims,\n          n = dims.length,\n          x = {};\n\n    for (let i = 0; i < n; ++i) {\n      x[names[i]] = dims[i](t);\n    }\n\n    return p ? replace(p.tuple, x) : ingest(x);\n  },\n\n  clean() {\n    const cells = this.value;\n\n    for (const key in cells) {\n      if (cells[key].num === 0) {\n        delete cells[key];\n      }\n    }\n  },\n\n  // -- Process Tuples -----\n  add(t) {\n    const key = this.cellkey(t),\n          cell = this.cell(key, t);\n    cell.num += 1;\n    if (this._countOnly) return;\n    if (cell.store) cell.data.add(t);\n    const agg = cell.agg;\n\n    for (let i = 0, n = agg.length; i < n; ++i) {\n      agg[i].add(agg[i].get(t), t);\n    }\n  },\n\n  rem(t) {\n    const key = this.cellkey(t),\n          cell = this.cell(key, t);\n    cell.num -= 1;\n    if (this._countOnly) return;\n    if (cell.store) cell.data.rem(t);\n    const agg = cell.agg;\n\n    for (let i = 0, n = agg.length; i < n; ++i) {\n      agg[i].rem(agg[i].get(t), t);\n    }\n  },\n\n  celltuple(cell) {\n    const tuple = cell.tuple,\n          counts = this._counts; // consolidate stored values\n\n    if (cell.store) {\n      cell.data.values();\n    } // update tuple properties\n\n\n    for (let i = 0, n = counts.length; i < n; ++i) {\n      tuple[counts[i]] = cell.num;\n    }\n\n    if (!this._countOnly) {\n      const agg = cell.agg;\n\n      for (let i = 0, n = agg.length; i < n; ++i) {\n        agg[i].set(tuple);\n      }\n    }\n\n    return tuple;\n  },\n\n  changes(out) {\n    const adds = this._adds,\n          mods = this._mods,\n          prev = this._prev,\n          drop = this._drop,\n          add = out.add,\n          rem = out.rem,\n          mod = out.mod;\n    let cell, key, i, n;\n    if (prev) for (key in prev) {\n      cell = prev[key];\n      if (!drop || cell.num) rem.push(cell.tuple);\n    }\n\n    for (i = 0, n = this._alen; i < n; ++i) {\n      add.push(this.celltuple(adds[i]));\n      adds[i] = null; // for garbage collection\n    }\n\n    for (i = 0, n = this._mlen; i < n; ++i) {\n      cell = mods[i];\n      (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n      mods[i] = null; // for garbage collection\n    }\n\n    this._alen = this._mlen = 0; // reset list of active cells\n\n    this._prev = null;\n    return out;\n  }\n\n});\n\nconst EPSILON$1 = 1e-14;\n/**\n * Generates a binning function for discretizing data.\n * @constructor\n * @param {object} params - The parameters for this operator. The\n *   provided values should be valid options for the {@link bin} function.\n * @param {function(object): *} params.field - The data field to bin.\n */\n\nfunction Bin(params) {\n  Transform.call(this, null, params);\n}\nBin.Definition = {\n  'type': 'Bin',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'interval',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'anchor',\n    'type': 'number'\n  }, {\n    'name': 'maxbins',\n    'type': 'number',\n    'default': 20\n  }, {\n    'name': 'base',\n    'type': 'number',\n    'default': 10\n  }, {\n    'name': 'divide',\n    'type': 'number',\n    'array': true,\n    'default': [5, 2]\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'span',\n    'type': 'number'\n  }, {\n    'name': 'step',\n    'type': 'number'\n  }, {\n    'name': 'steps',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'minstep',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'name',\n    'type': 'string'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['bin0', 'bin1']\n  }]\n};\ninherits(Bin, Transform, {\n  transform(_, pulse) {\n    const band = _.interval !== false,\n          bins = this._bins(_),\n          start = bins.start,\n          step = bins.step,\n          as = _.as || ['bin0', 'bin1'],\n          b0 = as[0],\n          b1 = as[1];\n\n    let flag;\n\n    if (_.modified()) {\n      pulse = pulse.reflow(true);\n      flag = pulse.SOURCE;\n    } else {\n      flag = pulse.modified(accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;\n    }\n\n    pulse.visit(flag, band ? t => {\n      const v = bins(t); // minimum bin value (inclusive)\n\n      t[b0] = v; // maximum bin value (exclusive)\n      // use convoluted math for better floating point agreement\n      // see https://github.com/vega/vega/issues/830\n      // infinite values propagate through this formula! #2227\n\n      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\n    } : t => t[b0] = bins(t));\n    return pulse.modifies(band ? as : b0);\n  },\n\n  _bins(_) {\n    if (this.value && !_.modified()) {\n      return this.value;\n    }\n\n    const field = _.field,\n          bins = bin(_),\n          step = bins.step;\n    let start = bins.start,\n        stop = start + Math.ceil((bins.stop - start) / step) * step,\n        a,\n        d;\n\n    if ((a = _.anchor) != null) {\n      d = a - (start + step * Math.floor((a - start) / step));\n      start += d;\n      stop += d;\n    }\n\n    const f = function (t) {\n      let v = toNumber(field(t));\n      return v == null ? null : v < start ? -Infinity : v > stop ? +Infinity : (v = Math.max(start, Math.min(v, stop - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));\n    };\n\n    f.start = start;\n    f.stop = bins.stop;\n    f.step = step;\n    return this.value = accessor(f, accessorFields(field), _.name || 'bin_' + accessorName(field));\n  }\n\n});\n\nfunction SortedList (idFunc, source, input) {\n  const $ = idFunc;\n  let data = source || [],\n      add = input || [],\n      rem = {},\n      cnt = 0;\n  return {\n    add: t => add.push(t),\n    remove: t => rem[$(t)] = ++cnt,\n    size: () => data.length,\n    data: (compare, resort) => {\n      if (cnt) {\n        data = data.filter(t => !rem[$(t)]);\n        rem = {};\n        cnt = 0;\n      }\n\n      if (resort && compare) {\n        data.sort(compare);\n      }\n\n      if (add.length) {\n        data = compare ? merge(compare, data, add.sort(compare)) : data.concat(add);\n        add = [];\n      }\n\n      return data;\n    }\n  };\n}\n\n/**\n * Collects all data tuples that pass through this operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for additionally sorting the collected tuples.\n */\n\nfunction Collect(params) {\n  Transform.call(this, [], params);\n}\nCollect.Definition = {\n  'type': 'Collect',\n  'metadata': {\n    'source': true\n  },\n  'params': [{\n    'name': 'sort',\n    'type': 'compare'\n  }]\n};\ninherits(Collect, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.ALL),\n          list = SortedList(tupleid, this.value, out.materialize(out.ADD).add),\n          sort = _.sort,\n          mod = pulse.changed() || sort && (_.modified('sort') || pulse.modified(sort.fields));\n    out.visit(out.REM, list.remove);\n    this.modified(mod);\n    this.value = out.source = list.data(stableCompare(sort), mod); // propagate tree root if defined\n\n    if (pulse.source && pulse.source.root) {\n      this.value.root = pulse.source.root;\n    }\n\n    return out;\n  }\n\n});\n\n/**\n * Generates a comparator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string|function>} params.fields - The fields to compare.\n * @param {Array<string>} [params.orders] - The sort orders.\n *   Each entry should be one of \"ascending\" (default) or \"descending\".\n */\n\nfunction Compare(params) {\n  Operator.call(this, null, update$5, params);\n}\ninherits(Compare, Operator);\n\nfunction update$5(_) {\n  return this.value && !_.modified() ? this.value : compare(_.fields, _.orders);\n}\n\n/**\n * Count regexp-defined pattern occurrences in a text field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the text field.\n * @param {string} [params.pattern] - RegExp string defining the text pattern.\n * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.\n * @param {string} [params.stopwords] - RegExp string of words to ignore.\n */\n\nfunction CountPattern(params) {\n  Transform.call(this, null, params);\n}\nCountPattern.Definition = {\n  'type': 'CountPattern',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'case',\n    'type': 'enum',\n    'values': ['upper', 'lower', 'mixed'],\n    'default': 'mixed'\n  }, {\n    'name': 'pattern',\n    'type': 'string',\n    'default': '[\\\\w\"]+'\n  }, {\n    'name': 'stopwords',\n    'type': 'string',\n    'default': ''\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['text', 'count']\n  }]\n};\n\nfunction tokenize(text, tcase, match) {\n  switch (tcase) {\n    case 'upper':\n      text = text.toUpperCase();\n      break;\n\n    case 'lower':\n      text = text.toLowerCase();\n      break;\n  }\n\n  return text.match(match);\n}\n\ninherits(CountPattern, Transform, {\n  transform(_, pulse) {\n    const process = update => tuple => {\n      var tokens = tokenize(get(tuple), _.case, match) || [],\n          t;\n\n      for (var i = 0, n = tokens.length; i < n; ++i) {\n        if (!stop.test(t = tokens[i])) update(t);\n      }\n    };\n\n    const init = this._parameterCheck(_, pulse),\n          counts = this._counts,\n          match = this._match,\n          stop = this._stop,\n          get = _.field,\n          as = _.as || ['text', 'count'],\n          add = process(t => counts[t] = 1 + (counts[t] || 0)),\n          rem = process(t => counts[t] -= 1);\n\n    if (init) {\n      pulse.visit(pulse.SOURCE, add);\n    } else {\n      pulse.visit(pulse.ADD, add);\n      pulse.visit(pulse.REM, rem);\n    }\n\n    return this._finish(pulse, as); // generate output tuples\n  },\n\n  _parameterCheck(_, pulse) {\n    let init = false;\n\n    if (_.modified('stopwords') || !this._stop) {\n      this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');\n      init = true;\n    }\n\n    if (_.modified('pattern') || !this._match) {\n      this._match = new RegExp(_.pattern || '[\\\\w\\']+', 'g');\n      init = true;\n    }\n\n    if (_.modified('field') || pulse.modified(_.field.fields)) {\n      init = true;\n    }\n\n    if (init) this._counts = {};\n    return init;\n  },\n\n  _finish(pulse, as) {\n    const counts = this._counts,\n          tuples = this._tuples || (this._tuples = {}),\n          text = as[0],\n          count = as[1],\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    let w, t, c;\n\n    for (w in counts) {\n      t = tuples[w];\n      c = counts[w] || 0;\n\n      if (!t && c) {\n        tuples[w] = t = ingest({});\n        t[text] = w;\n        t[count] = c;\n        out.add.push(t);\n      } else if (c === 0) {\n        if (t) out.rem.push(t);\n        counts[w] = null;\n        tuples[w] = null;\n      } else if (t[count] !== c) {\n        t[count] = c;\n        out.mod.push(t);\n      }\n    }\n\n    return out.modifies(as);\n  }\n\n});\n\n/**\n * Perform a cross-product of a tuple stream with itself.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object):boolean} [params.filter] - An optional filter\n *   function for selectively including tuples in the cross product.\n * @param {Array<string>} [params.as] - The names of the output fields.\n */\n\nfunction Cross(params) {\n  Transform.call(this, null, params);\n}\nCross.Definition = {\n  'type': 'Cross',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'filter',\n    'type': 'expr'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['a', 'b']\n  }]\n};\ninherits(Cross, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          as = _.as || ['a', 'b'],\n          a = as[0],\n          b = as[1],\n          reset = !this.value || pulse.changed(pulse.ADD_REM) || _.modified('as') || _.modified('filter');\n\n    let data = this.value;\n\n    if (reset) {\n      if (data) out.rem = data;\n      data = pulse.materialize(pulse.SOURCE).source;\n      out.add = this.value = cross(data, a, b, _.filter || truthy);\n    } else {\n      out.mod = data;\n    }\n\n    out.source = this.value;\n    return out.modifies(as);\n  }\n\n});\n\nfunction cross(input, a, b, filter) {\n  var data = [],\n      t = {},\n      n = input.length,\n      i = 0,\n      j,\n      left;\n\n  for (; i < n; ++i) {\n    t[a] = left = input[i];\n\n    for (j = 0; j < n; ++j) {\n      t[b] = input[j];\n\n      if (filter(t)) {\n        data.push(ingest(t));\n        t = {};\n        t[a] = left;\n      }\n    }\n  }\n\n  return data;\n}\n\nconst Distributions = {\n  kde: randomKDE,\n  mixture: randomMixture,\n  normal: randomNormal,\n  lognormal: randomLogNormal,\n  uniform: randomUniform\n};\nconst DISTRIBUTIONS = 'distributions',\n      FUNCTION = 'function',\n      FIELD = 'field';\n/**\n * Parse a parameter object for a probability distribution.\n * @param {object} def - The distribution parameter object.\n * @param {function():Array<object>} - A method for requesting\n *   source data. Used for distributions (such as KDE) that\n *   require sample data points. This method will only be\n *   invoked if the 'from' parameter for a target data source\n *   is not provided. Typically this method returns backing\n *   source data for a Pulse object.\n * @return {object} - The output distribution object.\n */\n\nfunction parse(def, data) {\n  const func = def[FUNCTION];\n\n  if (!hasOwnProperty(Distributions, func)) {\n    error('Unknown distribution function: ' + func);\n  }\n\n  const d = Distributions[func]();\n\n  for (const name in def) {\n    // if data field, extract values\n    if (name === FIELD) {\n      d.data((def.from || data()).map(def[name]));\n    } // if distribution mixture, recurse to parse each definition\n    else if (name === DISTRIBUTIONS) {\n        d[name](def[name].map(_ => parse(_, data)));\n      } // otherwise, simply set the parameter\n      else if (typeof d[name] === FUNCTION) {\n          d[name](def[name]);\n        }\n  }\n\n  return d;\n}\n\n/**\n * Grid sample points for a probability density. Given a distribution and\n * a sampling extent, will generate points suitable for plotting either\n * PDF (probability density function) or CDF (cumulative distribution\n * function) curves.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.distribution - The probability distribution. This\n *   is an object parameter dependent on the distribution type.\n * @param {string} [params.method='pdf'] - The distribution method to sample.\n *   One of 'pdf' or 'cdf'.\n * @param {Array<number>} [params.extent] - The [min, max] extent over which\n *   to sample the distribution. This argument is required in most cases, but\n *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\n *   that returns numerical sample points from which the extent can be deduced.\n * @param {number} [params.minsteps=25] - The minimum number of curve samples\n *   for plotting the density.\n * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n *   for plotting the density.\n * @param {number} [params.steps] - The exact number of curve samples for\n *   plotting the density. If specified, overrides both minsteps and maxsteps\n *   to set an exact number of uniform samples. Useful in conjunction with\n *   a fixed extent to ensure consistent sample points for stacked densities.\n */\n\nfunction Density(params) {\n  Transform.call(this, null, params);\n}\nconst distributions = [{\n  'key': {\n    'function': 'normal'\n  },\n  'params': [{\n    'name': 'mean',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'stdev',\n    'type': 'number',\n    'default': 1\n  }]\n}, {\n  'key': {\n    'function': 'lognormal'\n  },\n  'params': [{\n    'name': 'mean',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'stdev',\n    'type': 'number',\n    'default': 1\n  }]\n}, {\n  'key': {\n    'function': 'uniform'\n  },\n  'params': [{\n    'name': 'min',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'max',\n    'type': 'number',\n    'default': 1\n  }]\n}, {\n  'key': {\n    'function': 'kde'\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'from',\n    'type': 'data'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0\n  }]\n}];\nconst mixture = {\n  'key': {\n    'function': 'mixture'\n  },\n  'params': [{\n    'name': 'distributions',\n    'type': 'param',\n    'array': true,\n    'params': distributions\n  }, {\n    'name': 'weights',\n    'type': 'number',\n    'array': true\n  }]\n};\nDensity.Definition = {\n  'type': 'Density',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'steps',\n    'type': 'number'\n  }, {\n    'name': 'minsteps',\n    'type': 'number',\n    'default': 25\n  }, {\n    'name': 'maxsteps',\n    'type': 'number',\n    'default': 200\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'pdf',\n    'values': ['pdf', 'cdf']\n  }, {\n    'name': 'distribution',\n    'type': 'param',\n    'params': distributions.concat(mixture)\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'default': ['value', 'density']\n  }]\n};\ninherits(Density, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const dist = parse(_.distribution, source(pulse)),\n            minsteps = _.steps || _.minsteps || 25,\n            maxsteps = _.steps || _.maxsteps || 200;\n      let method = _.method || 'pdf';\n\n      if (method !== 'pdf' && method !== 'cdf') {\n        error('Invalid density method: ' + method);\n      }\n\n      if (!_.extent && !dist.data) {\n        error('Missing density extent parameter.');\n      }\n\n      method = dist[method];\n      const as = _.as || ['value', 'density'],\n            domain = _.extent || extent(dist.data()),\n            values = sampleCurve(method, domain, minsteps, maxsteps).map(v => {\n        const tuple = {};\n        tuple[as[0]] = v[0];\n        tuple[as[1]] = v[1];\n        return ingest(tuple);\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nfunction source(pulse) {\n  return () => pulse.materialize(pulse.SOURCE).source;\n}\n\nfunction fieldNames(fields, as) {\n  if (!fields) return null;\n  return fields.map((f, i) => as[i] || accessorName(f));\n}\nfunction partition$1(data, groupby, field) {\n  const groups = [],\n        get = f => f(t);\n\n  let map, i, n, t, k, g; // partition data points into groups\n\n  if (groupby == null) {\n    groups.push(data.map(field));\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(field(t));\n    }\n  }\n\n  return groups;\n}\n\nconst Output = 'bin';\n/**\n * Dot density binning for dot plot construction.\n * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.\n * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to bin.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.step] - The step size (bin width) within which dots should be\n *   stacked. Defaults to 1/30 of the extent of the data *field*.\n * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density\n *   stacks should be smoothed to reduce variance.\n */\n\nfunction DotBin(params) {\n  Transform.call(this, null, params);\n}\nDotBin.Definition = {\n  'type': 'DotBin',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'step',\n    'type': 'number'\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': Output\n  }]\n};\n\nconst autostep = (data, field) => span(extent(data, field)) / 30;\n\ninherits(DotBin, Transform, {\n  transform(_, pulse) {\n    if (this.value && !(_.modified() || pulse.changed())) {\n      return pulse; // early exit\n    }\n\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition$1(pulse.source, _.groupby, identity),\n          smooth = _.smooth || false,\n          field = _.field,\n          step = _.step || autostep(source, field),\n          sort = stableCompare((a, b) => field(a) - field(b)),\n          as = _.as || Output,\n          n = groups.length; // compute dotplot bins per group\n\n    let min = Infinity,\n        max = -Infinity,\n        i = 0,\n        j;\n\n    for (; i < n; ++i) {\n      const g = groups[i].sort(sort);\n      j = -1;\n\n      for (const v of dotbin(g, step, smooth, field)) {\n        if (v < min) min = v;\n        if (v > max) max = v;\n        g[++j][as] = v;\n      }\n    }\n\n    this.value = {\n      start: min,\n      stop: max,\n      step: step\n    };\n    return pulse.reflow(true).modifies(as);\n  }\n\n});\n\n/**\n * Wraps an expression function with access to external parameters.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function} params.expr - The expression function. The\n *  function should accept both a datum and a parameter object.\n *  This operator's value will be a new function that wraps the\n *  expression function with access to this operator's parameters.\n */\n\nfunction Expression(params) {\n  Operator.call(this, null, update$4, params);\n  this.modified(true);\n}\ninherits(Expression, Operator);\n\nfunction update$4(_) {\n  const expr = _.expr;\n  return this.value && !_.modified('expr') ? this.value : accessor(datum => expr(datum, _), accessorFields(expr), accessorName(expr));\n}\n\n/**\n * Computes extents (min/max) for a data field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field over which to compute extends.\n */\n\nfunction Extent(params) {\n  Transform.call(this, [undefined, undefined], params);\n}\nExtent.Definition = {\n  'type': 'Extent',\n  'metadata': {},\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Extent, Transform, {\n  transform(_, pulse) {\n    const extent = this.value,\n          field = _.field,\n          mod = pulse.changed() || pulse.modified(field.fields) || _.modified('field');\n\n    let min = extent[0],\n        max = extent[1];\n\n    if (mod || min == null) {\n      min = +Infinity;\n      max = -Infinity;\n    }\n\n    pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {\n      const v = toNumber(field(t));\n\n      if (v != null) {\n        // NaNs will fail all comparisons!\n        if (v < min) min = v;\n        if (v > max) max = v;\n      }\n    });\n\n    if (!Number.isFinite(min) || !Number.isFinite(max)) {\n      let name = accessorName(field);\n      if (name) name = ` for field \"${name}\"`;\n      pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);\n      min = max = undefined;\n    }\n\n    this.value = [min, max];\n  }\n\n});\n\n/**\n * Provides a bridge between a parent transform and a target subflow that\n * consumes only a subset of the tuples that pass through the parent.\n * @constructor\n * @param {Pulse} pulse - A pulse to use as the value of this operator.\n * @param {Transform} parent - The parent transform (typically a Facet instance).\n */\n\nfunction Subflow(pulse, parent) {\n  Operator.call(this, pulse);\n  this.parent = parent;\n  this.count = 0;\n}\ninherits(Subflow, Operator, {\n  /**\n   * Routes pulses from this subflow to a target transform.\n   * @param {Transform} target - A transform that receives the subflow of tuples.\n   */\n  connect(target) {\n    this.detachSubflow = target.detachSubflow;\n    this.targets().add(target);\n    return target.source = this;\n  },\n\n  /**\n   * Add an 'add' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being added.\n   */\n  add(t) {\n    this.count += 1;\n    this.value.add.push(t);\n  },\n\n  /**\n   * Add a 'rem' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being removed.\n   */\n  rem(t) {\n    this.count -= 1;\n    this.value.rem.push(t);\n  },\n\n  /**\n   * Add a 'mod' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being modified.\n   */\n  mod(t) {\n    this.value.mod.push(t);\n  },\n\n  /**\n   * Re-initialize this operator's pulse value.\n   * @param {Pulse} pulse - The pulse to copy from.\n   * @see Pulse.init\n   */\n  init(pulse) {\n    this.value.init(pulse, pulse.NO_SOURCE);\n  },\n\n  /**\n   * Evaluate this operator. This method overrides the\n   * default behavior to simply return the contained pulse value.\n   * @return {Pulse}\n   */\n  evaluate() {\n    // assert: this.value.stamp === pulse.stamp\n    return this.value;\n  }\n\n});\n\n/**\n * Facets a dataflow into a set of subflows based on a key.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): *} params.key - The key field to facet by.\n */\n\nfunction Facet(params) {\n  Transform.call(this, {}, params);\n  this._keys = fastmap(); // cache previously calculated key values\n  // keep track of active subflows, use as targets array for listeners\n  // this allows us to limit propagation to only updated subflows\n\n  const a = this._targets = [];\n  a.active = 0;\n\n  a.forEach = f => {\n    for (let i = 0, n = a.active; i < n; ++i) {\n      f(a[i], i, a);\n    }\n  };\n}\ninherits(Facet, Transform, {\n  activate(flow) {\n    this._targets[this._targets.active++] = flow;\n  },\n\n  // parent argument provided by PreFacet subclass\n  subflow(key, flow, pulse, parent) {\n    const flows = this.value;\n    let sf = hasOwnProperty(flows, key) && flows[key],\n        df,\n        p;\n\n    if (!sf) {\n      p = parent || (p = this._group[key]) && p.tuple;\n      df = pulse.dataflow;\n      sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);\n      df.add(sf).connect(flow(df, key, p));\n      flows[key] = sf;\n      this.activate(sf);\n    } else if (sf.value.stamp < pulse.stamp) {\n      sf.init(pulse);\n      this.activate(sf);\n    }\n\n    return sf;\n  },\n\n  clean() {\n    const flows = this.value;\n    let detached = 0;\n\n    for (const key in flows) {\n      if (flows[key].count === 0) {\n        const detach = flows[key].detachSubflow;\n        if (detach) detach();\n        delete flows[key];\n        ++detached;\n      }\n    } // remove inactive targets from the active targets array\n\n\n    if (detached) {\n      const active = this._targets.filter(sf => sf && sf.count > 0);\n\n      this.initTargets(active);\n    }\n  },\n\n  initTargets(act) {\n    const a = this._targets,\n          n = a.length,\n          m = act ? act.length : 0;\n    let i = 0;\n\n    for (; i < m; ++i) {\n      a[i] = act[i];\n    }\n\n    for (; i < n && a[i] != null; ++i) {\n      a[i] = null; // ensure old flows can be garbage collected\n    }\n\n    a.active = m;\n  },\n\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          key = _.key,\n          flow = _.subflow,\n          cache = this._keys,\n          rekey = _.modified('key'),\n          subflow = key => this.subflow(key, flow, pulse);\n\n    this._group = _.group || {};\n    this.initTargets(); // reset list of active subflows\n\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t),\n            k = cache.get(id);\n\n      if (k !== undefined) {\n        cache.delete(id);\n        subflow(k).rem(t);\n      }\n    });\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      cache.set(tupleid(t), k);\n      subflow(k).add(t);\n    });\n\n    if (rekey || pulse.modified(key.fields)) {\n      pulse.visit(pulse.MOD, t => {\n        const id = tupleid(t),\n              k0 = cache.get(id),\n              k1 = key(t);\n\n        if (k0 === k1) {\n          subflow(k1).mod(t);\n        } else {\n          cache.set(id, k1);\n          subflow(k0).rem(t);\n          subflow(k1).add(t);\n        }\n      });\n    } else if (pulse.changed(pulse.MOD)) {\n      pulse.visit(pulse.MOD, t => {\n        subflow(cache.get(tupleid(t))).mod(t);\n      });\n    }\n\n    if (rekey) {\n      pulse.visit(pulse.REFLOW, t => {\n        const id = tupleid(t),\n              k0 = cache.get(id),\n              k1 = key(t);\n\n        if (k0 !== k1) {\n          cache.set(id, k1);\n          subflow(k0).rem(t);\n          subflow(k1).add(t);\n        }\n      });\n    }\n\n    if (pulse.clean()) {\n      df.runAfter(() => {\n        this.clean();\n        cache.clean();\n      });\n    } else if (cache.empty > df.cleanThreshold) {\n      df.runAfter(cache.clean);\n    }\n\n    return pulse;\n  }\n\n});\n\n/**\n * Generates one or more field accessor functions.\n * If the 'name' parameter is an array, an array of field accessors\n * will be created and the 'as' parameter will be ignored.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.name - The field name(s) to access.\n * @param {string} params.as - The accessor function name.\n */\n\nfunction Field(params) {\n  Operator.call(this, null, update$3, params);\n}\ninherits(Field, Operator);\n\nfunction update$3(_) {\n  return this.value && !_.modified() ? this.value : isArray(_.name) ? array(_.name).map(f => field(f)) : field(_.name, _.as);\n}\n\n/**\n * Filters data tuples according to a predicate function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The predicate expression function\n *   that determines a tuple's filter status. Truthy values pass the filter.\n */\n\nfunction Filter(params) {\n  Transform.call(this, fastmap(), params);\n}\nFilter.Definition = {\n  'type': 'Filter',\n  'metadata': {\n    'changes': true\n  },\n  'params': [{\n    'name': 'expr',\n    'type': 'expr',\n    'required': true\n  }]\n};\ninherits(Filter, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          cache = this.value,\n          // cache ids of filtered tuples\n    output = pulse.fork(),\n          add = output.add,\n          rem = output.rem,\n          mod = output.mod,\n          test = _.expr;\n    let isMod = true;\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t);\n      if (!cache.has(id)) rem.push(t);else cache.delete(id);\n    });\n    pulse.visit(pulse.ADD, t => {\n      if (test(t, _)) add.push(t);else cache.set(tupleid(t), 1);\n    });\n\n    function revisit(t) {\n      const id = tupleid(t),\n            b = test(t, _),\n            s = cache.get(id);\n\n      if (b && s) {\n        cache.delete(id);\n        add.push(t);\n      } else if (!b && !s) {\n        cache.set(id, 1);\n        rem.push(t);\n      } else if (isMod && b && !s) {\n        mod.push(t);\n      }\n    }\n\n    pulse.visit(pulse.MOD, revisit);\n\n    if (_.modified()) {\n      isMod = false;\n      pulse.visit(pulse.REFLOW, revisit);\n    }\n\n    if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);\n    return output;\n  }\n\n});\n\n/**\n * Flattens array-typed field values into new data objects.\n * If multiple fields are specified, they are treated as parallel arrays,\n * with output values included for each matching index (or null if missing).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of field\n *   accessors for the tuple fields that should be flattened.\n * @param {string} [params.index] - Optional output field name for index\n *   value. If unspecified, no index field is included in the output.\n * @param {Array<string>} [params.as] - Output field names for flattened\n *   array fields. Any unspecified fields will use the field name provided\n *   by the fields accessors.\n */\n\nfunction Flatten(params) {\n  Transform.call(this, [], params);\n}\nFlatten.Definition = {\n  'type': 'Flatten',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'index',\n    'type': 'string'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Flatten, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          as = fieldNames(fields, _.as || []),\n          index = _.index || null,\n          m = as.length; // remove any previous results\n\n    out.rem = this.value; // generate flattened tuples\n\n    pulse.visit(pulse.SOURCE, t => {\n      const arrays = fields.map(f => f(t)),\n            maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);\n      let i = 0,\n          j,\n          d,\n          v;\n\n      for (; i < maxlen; ++i) {\n        d = derive(t);\n\n        for (j = 0; j < m; ++j) {\n          d[as[j]] = (v = arrays[j][i]) == null ? null : v;\n        }\n\n        if (index) {\n          d[index] = i;\n        }\n\n        out.add.push(d);\n      }\n    });\n    this.value = out.source = out.add;\n    if (index) out.modifies(index);\n    return out.modifies(as);\n  }\n\n});\n\n/**\n * Folds one more tuple fields into multiple tuples in which the field\n * name and values are available under new 'key' and 'value' fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.fields - An array of field accessors\n *   for the tuple fields that should be folded.\n * @param {Array<string>} [params.as] - Output field names for folded key\n *   and value fields, defaults to ['key', 'value'].\n */\n\nfunction Fold(params) {\n  Transform.call(this, [], params);\n}\nFold.Definition = {\n  'type': 'Fold',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['key', 'value']\n  }]\n};\ninherits(Fold, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          fnames = fields.map(accessorName),\n          as = _.as || ['key', 'value'],\n          k = as[0],\n          v = as[1],\n          n = fields.length;\n    out.rem = this.value;\n    pulse.visit(pulse.SOURCE, t => {\n      for (let i = 0, d; i < n; ++i) {\n        d = derive(t);\n        d[k] = fnames[i];\n        d[v] = fields[i](t);\n        out.add.push(d);\n      }\n    });\n    this.value = out.source = out.add;\n    return out.modifies(as);\n  }\n\n});\n\n/**\n * Invokes a function for each data tuple and saves the results as a new field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The formula function to invoke for each tuple.\n * @param {string} params.as - The field name under which to save the result.\n * @param {boolean} [params.initonly=false] - If true, the formula is applied to\n *   added tuples only, and does not update in response to modifications.\n */\n\nfunction Formula(params) {\n  Transform.call(this, null, params);\n}\nFormula.Definition = {\n  'type': 'Formula',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'expr',\n    'type': 'expr',\n    'required': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }, {\n    'name': 'initonly',\n    'type': 'boolean'\n  }]\n};\ninherits(Formula, Transform, {\n  transform(_, pulse) {\n    const func = _.expr,\n          as = _.as,\n          mod = _.modified(),\n          flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;\n\n    if (mod) {\n      // parameters updated, need to reflow\n      pulse = pulse.materialize().reflow(true);\n    }\n\n    if (!_.initonly) {\n      pulse.modifies(as);\n    }\n\n    return pulse.visit(flag, t => t[as] = func(t, _));\n  }\n\n});\n\n/**\n * Generates data tuples using a provided generator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Parameters): object} params.generator - A tuple generator\n *   function. This function is given the operator parameters as input.\n *   Changes to any additional parameters will not trigger re-calculation\n *   of previously generated tuples. Only future tuples are affected.\n * @param {number} params.size - The number of tuples to produce.\n */\n\nfunction Generate(params) {\n  Transform.call(this, [], params);\n}\ninherits(Generate, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.ALL),\n          gen = _.generator;\n    let data = this.value,\n        num = _.size - data.length,\n        add,\n        rem,\n        t;\n\n    if (num > 0) {\n      // need more tuples, generate and add\n      for (add = []; --num >= 0;) {\n        add.push(t = ingest(gen(_)));\n        data.push(t);\n      }\n\n      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add) : add;\n    } else {\n      // need fewer tuples, remove\n      rem = data.slice(0, -num);\n      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem) : rem;\n      data = data.slice(-num);\n    }\n\n    out.source = this.value = data;\n    return out;\n  }\n\n});\n\nconst Methods = {\n  value: 'value',\n  median: median,\n  mean: mean,\n  min: min,\n  max: max\n};\nconst Empty = [];\n/**\n * Impute missing values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to impute.\n * @param {Array<function(object): *>} [params.groupby] - An array of\n *   accessors to determine series within which to perform imputation.\n * @param {function(object): *} params.key - An accessor for a key value.\n *   Each key value should be unique within a group. New tuples will be\n *   imputed for any key values that are not found within a group.\n * @param {Array<*>} [params.keyvals] - Optional array of required key\n *   values. New tuples will be imputed for any key values that are not\n *   found within a group. In addition, these values will be automatically\n *   augmented with the key values observed in the input data.\n * @param {string} [method='value'] - The imputation method to use. One of\n *   'value', 'mean', 'median', 'max', 'min'.\n * @param {*} [value=0] - The constant value to use for imputation\n *   when using method 'value'.\n */\n\nfunction Impute(params) {\n  Transform.call(this, [], params);\n}\nImpute.Definition = {\n  'type': 'Impute',\n  'metadata': {\n    'changes': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'keyvals',\n    'array': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'value',\n    'values': ['value', 'mean', 'median', 'max', 'min']\n  }, {\n    'name': 'value',\n    'default': 0\n  }]\n};\n\nfunction getValue(_) {\n  var m = _.method || Methods.value,\n      v;\n\n  if (Methods[m] == null) {\n    error('Unrecognized imputation method: ' + m);\n  } else if (m === Methods.value) {\n    v = _.value !== undefined ? _.value : 0;\n    return () => v;\n  } else {\n    return Methods[m];\n  }\n}\n\nfunction getField(_) {\n  const f = _.field;\n  return t => t ? f(t) : NaN;\n}\n\ninherits(Impute, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        impute = getValue(_),\n        field = getField(_),\n        fName = accessorName(_.field),\n        kName = accessorName(_.key),\n        gNames = (_.groupby || []).map(accessorName),\n        groups = partition(pulse.source, _.groupby, _.key, _.keyvals),\n        curr = [],\n        prev = this.value,\n        m = groups.domain.length,\n        group,\n        value,\n        gVals,\n        kVal,\n        g,\n        i,\n        j,\n        l,\n        n,\n        t;\n\n    for (g = 0, l = groups.length; g < l; ++g) {\n      group = groups[g];\n      gVals = group.values;\n      value = NaN; // add tuples for missing values\n\n      for (j = 0; j < m; ++j) {\n        if (group[j] != null) continue;\n        kVal = groups.domain[j];\n        t = {\n          _impute: true\n        };\n\n        for (i = 0, n = gVals.length; i < n; ++i) t[gNames[i]] = gVals[i];\n\n        t[kName] = kVal;\n        t[fName] = Number.isNaN(value) ? value = impute(group, field) : value;\n        curr.push(ingest(t));\n      }\n    } // update pulse with imputed tuples\n\n\n    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);\n    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);\n    this.value = curr;\n    return out;\n  }\n\n});\n\nfunction partition(data, groupby, key, keyvals) {\n  var get = f => f(t),\n      groups = [],\n      domain = keyvals ? keyvals.slice() : [],\n      kMap = {},\n      gMap = {},\n      gVals,\n      gKey,\n      group,\n      i,\n      j,\n      k,\n      n,\n      t;\n\n  domain.forEach((k, i) => kMap[k] = i + 1);\n\n  for (i = 0, n = data.length; i < n; ++i) {\n    t = data[i];\n    k = key(t);\n    j = kMap[k] || (kMap[k] = domain.push(k));\n    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';\n\n    if (!(group = gMap[gKey])) {\n      group = gMap[gKey] = [];\n      groups.push(group);\n      group.values = gVals;\n    }\n\n    group[j - 1] = t;\n  }\n\n  groups.domain = domain;\n  return groups;\n}\n\n/**\n * Extend input tuples with aggregate values.\n * Calcuates aggregate values and joins them with the input stream.\n * @constructor\n */\n\nfunction JoinAggregate(params) {\n  Aggregate.call(this, params);\n}\nJoinAggregate.Definition = {\n  'type': 'JoinAggregate',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'ops',\n    'type': 'enum',\n    'array': true,\n    'values': ValidAggregateOps\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'key',\n    'type': 'field'\n  }]\n};\ninherits(JoinAggregate, Aggregate, {\n  transform(_, pulse) {\n    const aggr = this,\n          mod = _.modified();\n\n    let cells; // process all input tuples to calculate aggregates\n\n    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n      cells = aggr.value = mod ? aggr.init(_) : {};\n      pulse.visit(pulse.SOURCE, t => aggr.add(t));\n    } else {\n      cells = aggr.value = aggr.value || this.init(_);\n      pulse.visit(pulse.REM, t => aggr.rem(t));\n      pulse.visit(pulse.ADD, t => aggr.add(t));\n    } // update aggregation cells\n\n\n    aggr.changes(); // write aggregate values to input tuples\n\n    pulse.visit(pulse.SOURCE, t => {\n      extend(t, cells[aggr.cellkey(t)].tuple);\n    });\n    return pulse.reflow(mod).modifies(this._outputs);\n  },\n\n  changes() {\n    const adds = this._adds,\n          mods = this._mods;\n    let i, n;\n\n    for (i = 0, n = this._alen; i < n; ++i) {\n      this.celltuple(adds[i]);\n      adds[i] = null; // for garbage collection\n    }\n\n    for (i = 0, n = this._mlen; i < n; ++i) {\n      this.celltuple(mods[i]);\n      mods[i] = null; // for garbage collection\n    }\n\n    this._alen = this._mlen = 0; // reset list of active cells\n  }\n\n});\n\n/**\n * Compute kernel density estimates (KDE) for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {function(object): *} params.field - An accessor for the data field\n *   to estimate.\n * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.\n *   If zero or unspecified, the bandwidth is automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.cumulative=false] - A boolean flag indicating if a\n *   density (false) or cumulative distribution (true) should be generated.\n * @param {Array<number>} [params.extent] - The domain extent over which to\n *   plot the density. If unspecified, the [min, max] data extent is used.\n * @param {string} [params.resolve='independent'] - Indicates how parameters for\n *   multiple densities should be resolved. If \"independent\" (the default), each\n *   density may have its own domain extent and dynamic number of curve sample\n *   steps. If \"shared\", the KDE transform will ensure that all densities are\n *   defined over a shared domain and curve steps, enabling stacking.\n * @param {number} [params.minsteps=25] - The minimum number of curve samples\n *   for plotting the density.\n * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n *   for plotting the density.\n * @param {number} [params.steps] - The exact number of curve samples for\n *   plotting the density. If specified, overrides both minsteps and maxsteps\n *   to set an exact number of uniform samples. Useful in conjunction with\n *   a fixed extent to ensure consistent sample points for stacked densities.\n */\n\nfunction KDE(params) {\n  Transform.call(this, null, params);\n}\nKDE.Definition = {\n  'type': 'KDE',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'cumulative',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'steps',\n    'type': 'number'\n  }, {\n    'name': 'minsteps',\n    'type': 'number',\n    'default': 25\n  }, {\n    'name': 'maxsteps',\n    'type': 'number',\n    'default': 200\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'default': ['value', 'density']\n  }]\n};\ninherits(KDE, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition$1(source, _.groupby, _.field),\n            names = (_.groupby || []).map(accessorName),\n            bandwidth = _.bandwidth,\n            method = _.cumulative ? 'cdf' : 'pdf',\n            as = _.as || ['value', 'density'],\n            values = [];\n      let domain = _.extent,\n          minsteps = _.steps || _.minsteps || 25,\n          maxsteps = _.steps || _.maxsteps || 200;\n\n      if (method !== 'pdf' && method !== 'cdf') {\n        error('Invalid density method: ' + method);\n      }\n\n      if (_.resolve === 'shared') {\n        if (!domain) domain = extent(source, _.field);\n        minsteps = maxsteps = _.steps || maxsteps;\n      }\n\n      groups.forEach(g => {\n        const density = randomKDE(g, bandwidth)[method],\n              scale = _.counts ? g.length : 1,\n              local = domain || extent(g);\n        sampleCurve(density, local, minsteps, maxsteps).forEach(v => {\n          const t = {};\n\n          for (let i = 0; i < names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = v[0];\n          t[as[1]] = v[1] * scale;\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\n/**\n * Generates a key function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string>} params.fields - The field name(s) for the key function.\n * @param {boolean} params.flat - A boolean flag indicating if the field names\n *  should be treated as flat property names, side-stepping nested field\n *  lookups normally indicated by dot or bracket notation.\n */\n\nfunction Key(params) {\n  Operator.call(this, null, update$2, params);\n}\ninherits(Key, Operator);\n\nfunction update$2(_) {\n  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);\n}\n\n/**\n * Load and parse data from an external source. Marshalls parameter\n * values and then invokes the Dataflow request method.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.url - The URL to load from.\n * @param {object} params.format - The data format options.\n */\n\nfunction Load(params) {\n  Transform.call(this, [], params);\n  this._pending = null;\n}\ninherits(Load, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow;\n\n    if (this._pending) {\n      // update state and return pulse\n      return output(this, pulse, this._pending);\n    }\n\n    if (stop(_)) return pulse.StopPropagation;\n\n    if (_.values) {\n      // parse and ingest values, return output pulse\n      return output(this, pulse, df.parse(_.values, _.format));\n    } else if (_.async) {\n      // return promise for non-blocking async loading\n      const p = df.request(_.url, _.format).then(res => {\n        this._pending = array(res.data);\n        return df => df.touch(this);\n      });\n      return {\n        async: p\n      };\n    } else {\n      // return promise for synchronous loading\n      return df.request(_.url, _.format).then(res => output(this, pulse, array(res.data)));\n    }\n  }\n\n});\n\nfunction stop(_) {\n  return _.modified('async') && !(_.modified('values') || _.modified('url') || _.modified('format'));\n}\n\nfunction output(op, pulse, data) {\n  data.forEach(ingest);\n  const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);\n  out.rem = op.value;\n  op.value = out.source = out.add = data;\n  op._pending = null;\n  if (out.rem.length) out.clean(true);\n  return out;\n}\n\n/**\n * Extend tuples by joining them with values from a lookup table.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Map} params.index - The lookup table map.\n * @param {Array<function(object): *} params.fields - The fields to lookup.\n * @param {Array<string>} params.as - Output field names for each lookup value.\n * @param {*} [params.default] - A default value to use if lookup fails.\n */\n\nfunction Lookup(params) {\n  Transform.call(this, {}, params);\n}\nLookup.Definition = {\n  'type': 'Lookup',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'index',\n    'type': 'index',\n    'params': [{\n      'name': 'from',\n      'type': 'data',\n      'required': true\n    }, {\n      'name': 'key',\n      'type': 'field',\n      'required': true\n    }]\n  }, {\n    'name': 'values',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }, {\n    'name': 'default',\n    'default': null\n  }]\n};\ninherits(Lookup, Transform, {\n  transform(_, pulse) {\n    const keys = _.fields,\n          index = _.index,\n          values = _.values,\n          defaultValue = _.default == null ? null : _.default,\n          reset = _.modified(),\n          n = keys.length;\n\n    let flag = reset ? pulse.SOURCE : pulse.ADD,\n        out = pulse,\n        as = _.as,\n        set,\n        m,\n        mods;\n\n    if (values) {\n      m = values.length;\n\n      if (n > 1 && !as) {\n        error('Multi-field lookup requires explicit \"as\" parameter.');\n      }\n\n      if (as && as.length !== n * m) {\n        error('The \"as\" parameter has too few output field names.');\n      }\n\n      as = as || values.map(accessorName);\n\n      set = function (t) {\n        for (var i = 0, k = 0, j, v; i < n; ++i) {\n          v = index.get(keys[i](t));\n          if (v == null) for (j = 0; j < m; ++j, ++k) t[as[k]] = defaultValue;else for (j = 0; j < m; ++j, ++k) t[as[k]] = values[j](v);\n        }\n      };\n    } else {\n      if (!as) {\n        error('Missing output field names.');\n      }\n\n      set = function (t) {\n        for (var i = 0, v; i < n; ++i) {\n          v = index.get(keys[i](t));\n          t[as[i]] = v == null ? defaultValue : v;\n        }\n      };\n    }\n\n    if (reset) {\n      out = pulse.reflow(true);\n    } else {\n      mods = keys.some(k => pulse.modified(k.fields));\n      flag |= mods ? pulse.MOD : 0;\n    }\n\n    pulse.visit(flag, set);\n    return out.modifies(as);\n  }\n\n});\n\n/**\n * Computes global min/max extents over a collection of extents.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<number>>} params.extents - The input extents.\n */\n\nfunction MultiExtent(params) {\n  Operator.call(this, null, update$1, params);\n}\ninherits(MultiExtent, Operator);\n\nfunction update$1(_) {\n  if (this.value && !_.modified()) {\n    return this.value;\n  }\n\n  const ext = _.extents,\n        n = ext.length;\n  let min = +Infinity,\n      max = -Infinity,\n      i,\n      e;\n\n  for (i = 0; i < n; ++i) {\n    e = ext[i];\n    if (e[0] < min) min = e[0];\n    if (e[1] > max) max = e[1];\n  }\n\n  return [min, max];\n}\n\n/**\n * Merge a collection of value arrays.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<*>>} params.values - The input value arrrays.\n */\n\nfunction MultiValues(params) {\n  Operator.call(this, null, update, params);\n}\ninherits(MultiValues, Operator);\n\nfunction update(_) {\n  return this.value && !_.modified() ? this.value : _.values.reduce((data, _) => data.concat(_), []);\n}\n\n/**\n * Operator whose value is simply its parameter hash. This operator is\n * useful for enabling reactive updates to values of nested objects.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Params(params) {\n  Transform.call(this, null, params);\n}\ninherits(Params, Transform, {\n  transform(_, pulse) {\n    this.modified(_.modified());\n    this.value = _;\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples\n  }\n\n});\n\n/**\n * Aggregate and pivot selected field values to become new fields.\n * This operator is useful to construction cross-tabulations.\n * @constructor\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *  to groupby. These fields act just like groupby fields of an Aggregate transform.\n * @param {function(object): *} params.field - The field to pivot on. The unique\n *  values of this field become new field names in the output stream.\n * @param {function(object): *} params.value - The field to populate pivoted fields.\n *  The aggregate values of this field become the values of the new pivoted fields.\n * @param {string} [params.op] - The aggregation operation for the value field,\n *  applied per cell in the output stream. The default is \"sum\".\n * @param {number} [params.limit] - An optional parameter indicating the maximum\n *  number of pivoted fields to generate. The pivoted field names are sorted in\n *  ascending order prior to enforcing the limit.\n */\n\nfunction Pivot(params) {\n  Aggregate.call(this, params);\n}\nPivot.Definition = {\n  'type': 'Pivot',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'value',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'op',\n    'type': 'enum',\n    'values': ValidAggregateOps,\n    'default': 'sum'\n  }, {\n    'name': 'limit',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'key',\n    'type': 'field'\n  }]\n};\ninherits(Pivot, Aggregate, {\n  _transform: Aggregate.prototype.transform,\n\n  transform(_, pulse) {\n    return this._transform(aggregateParams(_, pulse), pulse);\n  }\n\n}); // Shoehorn a pivot transform into an aggregate transform!\n// First collect all unique pivot field values.\n// Then generate aggregate fields for each output pivot field.\n\nfunction aggregateParams(_, pulse) {\n  const key = _.field,\n        value = _.value,\n        op = (_.op === 'count' ? '__count__' : _.op) || 'sum',\n        fields = accessorFields(key).concat(accessorFields(value)),\n        keys = pivotKeys(key, _.limit || 0, pulse); // if data stream content changes, pivot fields may change\n  // flag parameter modification to ensure re-initialization\n\n  if (pulse.changed()) _.set('__pivot__', null, null, true);\n  return {\n    key: _.key,\n    groupby: _.groupby,\n    ops: keys.map(() => op),\n    fields: keys.map(k => get(k, key, value, fields)),\n    as: keys.map(k => k + ''),\n    modified: _.modified.bind(_)\n  };\n} // Generate aggregate field accessor.\n// Output NaN for non-existent values; aggregator will ignore!\n\n\nfunction get(k, key, value, fields) {\n  return accessor(d => key(d) === k ? value(d) : NaN, fields, k + '');\n} // Collect (and optionally limit) all unique pivot values.\n\n\nfunction pivotKeys(key, limit, pulse) {\n  const map = {},\n        list = [];\n  pulse.visit(pulse.SOURCE, t => {\n    const k = key(t);\n\n    if (!map[k]) {\n      map[k] = 1;\n      list.push(k);\n    }\n  });\n  list.sort(ascending);\n  return limit ? list.slice(0, limit) : list;\n}\n\n/**\n * Partitions pre-faceted data into tuple subflows.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): Array<object>} params.field - The field\n *   accessor for an array of subflow tuple objects.\n */\n\nfunction PreFacet(params) {\n  Facet.call(this, params);\n}\ninherits(PreFacet, Facet, {\n  transform(_, pulse) {\n    const flow = _.subflow,\n          field = _.field,\n          subflow = t => this.subflow(tupleid(t), flow, pulse, t);\n\n    if (_.modified('field') || field && pulse.modified(accessorFields(field))) {\n      error('PreFacet does not support field modification.');\n    }\n\n    this.initTargets(); // reset list of active subflows\n\n    if (field) {\n      pulse.visit(pulse.MOD, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.mod(_));\n      });\n      pulse.visit(pulse.ADD, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.add(ingest(_)));\n      });\n      pulse.visit(pulse.REM, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.rem(_));\n      });\n    } else {\n      pulse.visit(pulse.MOD, t => subflow(t).mod(t));\n      pulse.visit(pulse.ADD, t => subflow(t).add(t));\n      pulse.visit(pulse.REM, t => subflow(t).rem(t));\n    }\n\n    if (pulse.clean()) {\n      pulse.runAfter(() => this.clean());\n    }\n\n    return pulse;\n  }\n\n});\n\n/**\n * Performs a relational projection, copying selected fields from source\n * tuples to a new set of derived tuples.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *} params.fields - The fields to project,\n *   as an array of field accessors. If unspecified, all fields will be\n *   copied with names unchanged.\n * @param {Array<string>} [params.as] - Output field names for each projected\n *   field. Any unspecified fields will use the field name provided by\n *   the field accessor.\n */\n\nfunction Project(params) {\n  Transform.call(this, null, params);\n}\nProject.Definition = {\n  'type': 'Project',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }]\n};\ninherits(Project, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          as = fieldNames(_.fields, _.as || []),\n          derive = fields ? (s, t) => project(s, t, fields, as) : rederive;\n    let lut;\n\n    if (this.value) {\n      lut = this.value;\n    } else {\n      pulse = pulse.addAll();\n      lut = this.value = {};\n    }\n\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t);\n      out.rem.push(lut[id]);\n      lut[id] = null;\n    });\n    pulse.visit(pulse.ADD, t => {\n      const dt = derive(t, ingest({}));\n      lut[tupleid(t)] = dt;\n      out.add.push(dt);\n    });\n    pulse.visit(pulse.MOD, t => {\n      out.mod.push(derive(t, lut[tupleid(t)]));\n    });\n    return out;\n  }\n\n});\n\nfunction project(s, t, fields, as) {\n  for (let i = 0, n = fields.length; i < n; ++i) {\n    t[as[i]] = fields[i](s);\n  }\n\n  return t;\n}\n\n/**\n * Proxy the value of another operator as a pure signal value.\n * Ensures no tuples are propagated.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {*} params.value - The value to proxy, becomes the value of this operator.\n */\n\nfunction Proxy(params) {\n  Transform.call(this, null, params);\n}\ninherits(Proxy, Transform, {\n  transform(_, pulse) {\n    this.value = _.value;\n    return _.modified('value') ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;\n  }\n\n});\n\n/**\n * Generates sample quantile values from an input data stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the data field\n *   over which to calculate quantile values.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {Array<number>} [params.probs] - An array of probabilities in\n *   the range (0, 1) for which to compute quantile values. If not specified,\n *   the *step* parameter will be used.\n * @param {Array<number>} [params.step=0.01] - A probability step size for\n *   sampling quantile values. All values from one-half the step size up to\n *   1 (exclusive) will be sampled. This parameter is only used if the\n *   *quantiles* parameter is not provided.\n */\n\nfunction Quantile(params) {\n  Transform.call(this, null, params);\n}\nQuantile.Definition = {\n  'type': 'Quantile',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'probs',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'default': 0.01\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'default': ['prob', 'value']\n  }]\n};\nconst EPSILON = 1e-14;\ninherits(Quantile, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          as = _.as || ['prob', 'value'];\n\n    if (this.value && !_.modified() && !pulse.changed()) {\n      out.source = this.value;\n      return out;\n    }\n\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition$1(source, _.groupby, _.field),\n          names = (_.groupby || []).map(accessorName),\n          values = [],\n          step = _.step || 0.01,\n          p = _.probs || range(step / 2, 1 - EPSILON, step),\n          n = p.length;\n    groups.forEach(g => {\n      const q = quantiles(g, p);\n\n      for (let i = 0; i < n; ++i) {\n        const t = {};\n\n        for (let i = 0; i < names.length; ++i) {\n          t[names[i]] = g.dims[i];\n        }\n\n        t[as[0]] = p[i];\n        t[as[1]] = q[i];\n        values.push(ingest(t));\n      }\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n    return out;\n  }\n\n});\n\n/**\n * Relays a data stream between data processing pipelines.\n * If the derive parameter is set, this transform will create derived\n * copies of observed tuples. This provides derived data streams in which\n * modifications to the tuples do not pollute an upstream data source.\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.derive=false] - Boolean flag indicating if\n *   the transform should make derived copies of incoming tuples.\n * @constructor\n */\n\nfunction Relay(params) {\n  Transform.call(this, null, params);\n}\ninherits(Relay, Transform, {\n  transform(_, pulse) {\n    let out, lut;\n\n    if (this.value) {\n      lut = this.value;\n    } else {\n      out = pulse = pulse.addAll();\n      lut = this.value = {};\n    }\n\n    if (_.derive) {\n      out = pulse.fork(pulse.NO_SOURCE);\n      pulse.visit(pulse.REM, t => {\n        const id = tupleid(t);\n        out.rem.push(lut[id]);\n        lut[id] = null;\n      });\n      pulse.visit(pulse.ADD, t => {\n        const dt = derive(t);\n        lut[tupleid(t)] = dt;\n        out.add.push(dt);\n      });\n      pulse.visit(pulse.MOD, t => {\n        const dt = lut[tupleid(t)];\n\n        for (const k in t) {\n          dt[k] = t[k]; // down stream writes may overwrite re-derived tuples\n          // conservatively mark all source fields as modified\n\n          out.modifies(k);\n        }\n\n        out.mod.push(dt);\n      });\n    }\n\n    return out;\n  }\n\n});\n\n/**\n * Samples tuples passing through this operator.\n * Uses reservoir sampling to maintain a representative sample.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.size=1000] - The maximum number of samples.\n */\n\nfunction Sample(params) {\n  Transform.call(this, [], params);\n  this.count = 0;\n}\nSample.Definition = {\n  'type': 'Sample',\n  'metadata': {},\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'default': 1000\n  }]\n};\ninherits(Sample, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          mod = _.modified('size'),\n          num = _.size,\n          map = this.value.reduce((m, t) => (m[tupleid(t)] = 1, m), {});\n\n    let res = this.value,\n        cnt = this.count,\n        cap = 0; // sample reservoir update function\n\n    function update(t) {\n      let p, idx;\n\n      if (res.length < num) {\n        res.push(t);\n      } else {\n        idx = ~~((cnt + 1) * random());\n\n        if (idx < res.length && idx >= cap) {\n          p = res[idx];\n          if (map[tupleid(p)]) out.rem.push(p); // eviction\n\n          res[idx] = t;\n        }\n      }\n\n      ++cnt;\n    }\n\n    if (pulse.rem.length) {\n      // find all tuples that should be removed, add to output\n      pulse.visit(pulse.REM, t => {\n        const id = tupleid(t);\n\n        if (map[id]) {\n          map[id] = -1;\n          out.rem.push(t);\n        }\n\n        --cnt;\n      }); // filter removed tuples out of the sample reservoir\n\n      res = res.filter(t => map[tupleid(t)] !== -1);\n    }\n\n    if ((pulse.rem.length || mod) && res.length < num && pulse.source) {\n      // replenish sample if backing data source is available\n      cap = cnt = res.length;\n      pulse.visit(pulse.SOURCE, t => {\n        // update, but skip previously sampled tuples\n        if (!map[tupleid(t)]) update(t);\n      });\n      cap = -1;\n    }\n\n    if (mod && res.length > num) {\n      const n = res.length - num;\n\n      for (let i = 0; i < n; ++i) {\n        map[tupleid(res[i])] = -1;\n        out.rem.push(res[i]);\n      }\n\n      res = res.slice(n);\n    }\n\n    if (pulse.mod.length) {\n      // propagate modified tuples in the sample reservoir\n      pulse.visit(pulse.MOD, t => {\n        if (map[tupleid(t)]) out.mod.push(t);\n      });\n    }\n\n    if (pulse.add.length) {\n      // update sample reservoir\n      pulse.visit(pulse.ADD, update);\n    }\n\n    if (pulse.add.length || cap < 0) {\n      // output newly added tuples\n      out.add = res.filter(t => !map[tupleid(t)]);\n    }\n\n    this.count = cnt;\n    this.value = out.source = res;\n    return out;\n  }\n\n});\n\n/**\n * Generates data tuples for a specified sequence range of numbers.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} params.start - The first number in the sequence.\n * @param {number} params.stop - The last number (exclusive) in the sequence.\n * @param {number} [params.step=1] - The step size between numbers in the sequence.\n */\n\nfunction Sequence(params) {\n  Transform.call(this, null, params);\n}\nSequence.Definition = {\n  'type': 'Sequence',\n  'metadata': {\n    'generates': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'start',\n    'type': 'number',\n    'required': true\n  }, {\n    'name': 'stop',\n    'type': 'number',\n    'required': true\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'default': 1\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'data'\n  }]\n};\ninherits(Sequence, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) return;\n    const out = pulse.materialize().fork(pulse.MOD),\n          as = _.as || 'data';\n    out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;\n    this.value = range(_.start, _.stop, _.step || 1).map(v => {\n      const t = {};\n      t[as] = v;\n      return ingest(t);\n    });\n    out.add = pulse.add.concat(this.value);\n    return out;\n  }\n\n});\n\n/**\n * Propagates a new pulse without any tuples so long as the input\n * pulse contains some added, removed or modified tuples.\n * @param {object} params - The parameters for this operator.\n * @constructor\n */\n\nfunction Sieve(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Sieve, Transform, {\n  transform(_, pulse) {\n    this.value = pulse.source;\n    return pulse.changed() ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;\n  }\n\n});\n\n/**\n * Discretize dates to specific time units.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The data field containing date/time values.\n */\n\nfunction TimeUnit(params) {\n  Transform.call(this, null, params);\n}\nconst OUTPUT = ['unit0', 'unit1'];\nTimeUnit.Definition = {\n  'type': 'TimeUnit',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'interval',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'units',\n    'type': 'enum',\n    'values': TIME_UNITS,\n    'array': true\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'default': 1\n  }, {\n    'name': 'maxbins',\n    'type': 'number',\n    'default': 40\n  }, {\n    'name': 'extent',\n    'type': 'date',\n    'array': true\n  }, {\n    'name': 'timezone',\n    'type': 'enum',\n    'default': 'local',\n    'values': ['local', 'utc']\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': OUTPUT\n  }]\n};\ninherits(TimeUnit, Transform, {\n  transform(_, pulse) {\n    const field = _.field,\n          band = _.interval !== false,\n          utc = _.timezone === 'utc',\n          floor = this._floor(_, pulse),\n          offset = (utc ? utcInterval : timeInterval)(floor.unit).offset,\n          as = _.as || OUTPUT,\n          u0 = as[0],\n          u1 = as[1],\n          step = floor.step;\n\n    let min = floor.start || Infinity,\n        max = floor.stop || -Infinity,\n        flag = pulse.ADD;\n\n    if (_.modified() || pulse.modified(accessorFields(field))) {\n      pulse = pulse.reflow(true);\n      flag = pulse.SOURCE;\n      min = Infinity;\n      max = -Infinity;\n    }\n\n    pulse.visit(flag, t => {\n      const v = field(t);\n      let a, b;\n\n      if (v == null) {\n        t[u0] = null;\n        if (band) t[u1] = null;\n      } else {\n        t[u0] = a = b = floor(v);\n        if (band) t[u1] = b = offset(a, step);\n        if (a < min) min = a;\n        if (b > max) max = b;\n      }\n    });\n    floor.start = min;\n    floor.stop = max;\n    return pulse.modifies(band ? as : u0);\n  },\n\n  _floor(_, pulse) {\n    const utc = _.timezone === 'utc'; // get parameters\n\n    const {\n      units,\n      step\n    } = _.units ? {\n      units: _.units,\n      step: _.step || 1\n    } : timeBin({\n      extent: _.extent || extent(pulse.materialize(pulse.SOURCE).source, _.field),\n      maxbins: _.maxbins\n    }); // check / standardize time units\n\n    const tunits = timeUnits(units),\n          prev = this.value || {},\n          floor = (utc ? utcFloor : timeFloor)(tunits, step);\n    floor.unit = peek(tunits);\n    floor.units = tunits;\n    floor.step = step;\n    floor.start = prev.start;\n    floor.stop = prev.stop;\n    return this.value = floor;\n  }\n\n});\n\n/**\n * An index that maps from unique, string-coerced, field values to tuples.\n * Assumes that the field serves as a unique key with no duplicate values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field accessor to index.\n */\n\nfunction TupleIndex(params) {\n  Transform.call(this, fastmap(), params);\n}\ninherits(TupleIndex, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          field = _.field,\n          index = this.value,\n          set = t => index.set(field(t), t);\n\n    let mod = true;\n\n    if (_.modified('field') || pulse.modified(field.fields)) {\n      index.clear();\n      pulse.visit(pulse.SOURCE, set);\n    } else if (pulse.changed()) {\n      pulse.visit(pulse.REM, t => index.delete(field(t)));\n      pulse.visit(pulse.ADD, set);\n    } else {\n      mod = false;\n    }\n\n    this.modified(mod);\n    if (index.empty > df.cleanThreshold) df.runAfter(index.clean);\n    return pulse.fork();\n  }\n\n});\n\n/**\n * Extracts an array of values. Assumes the source data has already been\n * reduced as needed (e.g., by an upstream Aggregate transform).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The domain field to extract.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting the values. The comparator will be\n *   applied to backing tuples prior to value extraction.\n */\n\nfunction Values(params) {\n  Transform.call(this, null, params);\n}\ninherits(Values, Transform, {\n  transform(_, pulse) {\n    const run = !this.value || _.modified('field') || _.modified('sort') || pulse.changed() || _.sort && pulse.modified(_.sort.fields);\n\n    if (run) {\n      this.value = (_.sort ? pulse.source.slice().sort(stableCompare(_.sort)) : pulse.source).map(_.field);\n    }\n  }\n\n});\n\nfunction WindowOp(op, field, param, as) {\n  const fn = WindowOps[op](field, param);\n  return {\n    init: fn.init || zero,\n    update: function (w, t) {\n      t[as] = fn.next(w);\n    }\n  };\n}\nconst WindowOps = {\n  row_number: function () {\n    return {\n      next: w => w.index + 1\n    };\n  },\n  rank: function () {\n    let rank;\n    return {\n      init: () => rank = 1,\n      next: w => {\n        const i = w.index,\n              data = w.data;\n        return i && w.compare(data[i - 1], data[i]) ? rank = i + 1 : rank;\n      }\n    };\n  },\n  dense_rank: function () {\n    let drank;\n    return {\n      init: () => drank = 1,\n      next: w => {\n        const i = w.index,\n              d = w.data;\n        return i && w.compare(d[i - 1], d[i]) ? ++drank : drank;\n      }\n    };\n  },\n  percent_rank: function () {\n    const rank = WindowOps.rank(),\n          next = rank.next;\n    return {\n      init: rank.init,\n      next: w => (next(w) - 1) / (w.data.length - 1)\n    };\n  },\n  cume_dist: function () {\n    let cume;\n    return {\n      init: () => cume = 0,\n      next: w => {\n        const d = w.data,\n              c = w.compare;\n        let i = w.index;\n\n        if (cume < i) {\n          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;\n\n          cume = i;\n        }\n\n        return (1 + cume) / d.length;\n      }\n    };\n  },\n  ntile: function (field, num) {\n    num = +num;\n    if (!(num > 0)) error('ntile num must be greater than zero.');\n    const cume = WindowOps.cume_dist(),\n          next = cume.next;\n    return {\n      init: cume.init,\n      next: w => Math.ceil(num * next(w))\n    };\n  },\n  lag: function (field, offset) {\n    offset = +offset || 1;\n    return {\n      next: w => {\n        const i = w.index - offset;\n        return i >= 0 ? field(w.data[i]) : null;\n      }\n    };\n  },\n  lead: function (field, offset) {\n    offset = +offset || 1;\n    return {\n      next: w => {\n        const i = w.index + offset,\n              d = w.data;\n        return i < d.length ? field(d[i]) : null;\n      }\n    };\n  },\n  first_value: function (field) {\n    return {\n      next: w => field(w.data[w.i0])\n    };\n  },\n  last_value: function (field) {\n    return {\n      next: w => field(w.data[w.i1 - 1])\n    };\n  },\n  nth_value: function (field, nth) {\n    nth = +nth;\n    if (!(nth > 0)) error('nth_value nth must be greater than zero.');\n    return {\n      next: w => {\n        const i = w.i0 + (nth - 1);\n        return i < w.i1 ? field(w.data[i]) : null;\n      }\n    };\n  },\n  prev_value: function (field) {\n    let prev;\n    return {\n      init: () => prev = null,\n      next: w => {\n        const v = field(w.data[w.index]);\n        return v != null ? prev = v : prev;\n      }\n    };\n  },\n  next_value: function (field) {\n    let v, i;\n    return {\n      init: () => (v = null, i = -1),\n      next: w => {\n        const d = w.data;\n        return w.index <= i ? v : (i = find(field, d, w.index)) < 0 ? (i = d.length, v = null) : v = field(d[i]);\n      }\n    };\n  }\n};\n\nfunction find(field, data, index) {\n  for (let n = data.length; index < n; ++index) {\n    const v = field(data[index]);\n    if (v != null) return index;\n  }\n\n  return -1;\n}\n\nconst ValidWindowOps = Object.keys(WindowOps);\n\nfunction WindowState(_) {\n  const ops = array(_.ops),\n        fields = array(_.fields),\n        params = array(_.params),\n        as = array(_.as),\n        outputs = this.outputs = [],\n        windows = this.windows = [],\n        inputs = {},\n        map = {},\n        counts = [],\n        measures = [];\n  let countOnly = true;\n\n  function visitInputs(f) {\n    array(accessorFields(f)).forEach(_ => inputs[_] = 1);\n  }\n\n  visitInputs(_.sort);\n  ops.forEach((op, i) => {\n    const field = fields[i],\n          mname = accessorName(field),\n          name = measureName(op, mname, as[i]);\n    visitInputs(field);\n    outputs.push(name); // Window operation\n\n    if (hasOwnProperty(WindowOps, op)) {\n      windows.push(WindowOp(op, fields[i], params[i], name));\n    } // Aggregate operation\n    else {\n        if (field == null && op !== 'count') {\n          error('Null aggregate field specified.');\n        }\n\n        if (op === 'count') {\n          counts.push(name);\n          return;\n        }\n\n        countOnly = false;\n        let m = map[mname];\n\n        if (!m) {\n          m = map[mname] = [];\n          m.field = field;\n          measures.push(m);\n        }\n\n        m.push(createMeasure(op, name));\n      }\n  });\n\n  if (counts.length || measures.length) {\n    this.cell = cell(measures, counts, countOnly);\n  }\n\n  this.inputs = Object.keys(inputs);\n}\nconst prototype = WindowState.prototype;\n\nprototype.init = function () {\n  this.windows.forEach(_ => _.init());\n  if (this.cell) this.cell.init();\n};\n\nprototype.update = function (w, t) {\n  const cell = this.cell,\n        wind = this.windows,\n        data = w.data,\n        m = wind && wind.length;\n  let j;\n\n  if (cell) {\n    for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);\n\n    for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);\n\n    cell.set(t);\n  }\n\n  for (j = 0; j < m; ++j) wind[j].update(w, t);\n};\n\nfunction cell(measures, counts, countOnly) {\n  measures = measures.map(m => compileMeasures(m, m.field));\n  const cell = {\n    num: 0,\n    agg: null,\n    store: false,\n    count: counts\n  };\n\n  if (!countOnly) {\n    var n = measures.length,\n        a = cell.agg = Array(n),\n        i = 0;\n\n    for (; i < n; ++i) a[i] = new measures[i](cell);\n  }\n\n  if (cell.store) {\n    var store = cell.data = new TupleStore();\n  }\n\n  cell.add = function (t) {\n    cell.num += 1;\n    if (countOnly) return;\n    if (store) store.add(t);\n\n    for (let i = 0; i < n; ++i) {\n      a[i].add(a[i].get(t), t);\n    }\n  };\n\n  cell.rem = function (t) {\n    cell.num -= 1;\n    if (countOnly) return;\n    if (store) store.rem(t);\n\n    for (let i = 0; i < n; ++i) {\n      a[i].rem(a[i].get(t), t);\n    }\n  };\n\n  cell.set = function (t) {\n    let i, n; // consolidate stored values\n\n    if (store) store.values(); // update tuple properties\n\n    for (i = 0, n = counts.length; i < n; ++i) t[counts[i]] = cell.num;\n\n    if (!countOnly) for (i = 0, n = a.length; i < n; ++i) a[i].set(t);\n  };\n\n  cell.init = function () {\n    cell.num = 0;\n    if (store) store.reset();\n\n    for (let i = 0; i < n; ++i) a[i].init();\n  };\n\n  return cell;\n}\n\n/**\n * Perform window calculations and write results to the input stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\n * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors\n *   for data fields to use as inputs to window operations.\n * @param {Array<*>} [params.params] - An array of parameter values for window operations.\n * @param {Array<string>} [params.as] - An array of output field names for window operations.\n * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\n * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\n *   number alone, ignoring peers with identical sort values. If false (default),\n *   the window boundaries will be adjusted to include peer values.\n */\n\nfunction Window(params) {\n  Transform.call(this, {}, params);\n  this._mlen = 0;\n  this._mods = [];\n}\nWindow.Definition = {\n  'type': 'Window',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'ops',\n    'type': 'enum',\n    'array': true,\n    'values': ValidWindowOps.concat(ValidAggregateOps)\n  }, {\n    'name': 'params',\n    'type': 'number',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'array': true\n  }, {\n    'name': 'frame',\n    'type': 'number',\n    'null': true,\n    'array': true,\n    'length': 2,\n    'default': [null, 0]\n  }, {\n    'name': 'ignorePeers',\n    'type': 'boolean',\n    'default': false\n  }]\n};\ninherits(Window, Transform, {\n  transform(_, pulse) {\n    this.stamp = pulse.stamp;\n\n    const mod = _.modified(),\n          cmp = stableCompare(_.sort),\n          key = groupkey(_.groupby),\n          group = t => this.group(key(t)); // initialize window state\n\n\n    let state = this.state;\n\n    if (!state || mod) {\n      state = this.state = new WindowState(_);\n    } // partition input tuples\n\n\n    if (mod || pulse.modified(state.inputs)) {\n      this.value = {};\n      pulse.visit(pulse.SOURCE, t => group(t).add(t));\n    } else {\n      pulse.visit(pulse.REM, t => group(t).remove(t));\n      pulse.visit(pulse.ADD, t => group(t).add(t));\n    } // perform window calculations for each modified partition\n\n\n    for (let i = 0, n = this._mlen; i < n; ++i) {\n      processPartition(this._mods[i], state, cmp, _);\n    }\n\n    this._mlen = 0;\n    this._mods = []; // TODO don't reflow everything?\n\n    return pulse.reflow(mod).modifies(state.outputs);\n  },\n\n  group(key) {\n    let group = this.value[key];\n\n    if (!group) {\n      group = this.value[key] = SortedList(tupleid);\n      group.stamp = -1;\n    }\n\n    if (group.stamp < this.stamp) {\n      group.stamp = this.stamp;\n      this._mods[this._mlen++] = group;\n    }\n\n    return group;\n  }\n\n});\n\nfunction processPartition(list, state, cmp, _) {\n  const sort = _.sort,\n        range = sort && !_.ignorePeers,\n        frame = _.frame || [null, 0],\n        data = list.data(cmp),\n        // use cmp for stable sort\n  n = data.length,\n        b = range ? bisector(sort) : null,\n        w = {\n    i0: 0,\n    i1: 0,\n    p0: 0,\n    p1: 0,\n    index: 0,\n    data: data,\n    compare: sort || constant(-1)\n  };\n  state.init();\n\n  for (let i = 0; i < n; ++i) {\n    setWindow(w, frame, i, n);\n    if (range) adjustRange(w, b);\n    state.update(w, data[i]);\n  }\n}\n\nfunction setWindow(w, f, i, n) {\n  w.p0 = w.i0;\n  w.p1 = w.i1;\n  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\n  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\n  w.index = i;\n} // if frame type is 'range', adjust window for peer values\n\n\nfunction adjustRange(w, bisect) {\n  const r0 = w.i0,\n        r1 = w.i1 - 1,\n        c = w.compare,\n        d = w.data,\n        n = d.length - 1;\n  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);\n  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);\n}\n\nexport { Aggregate as aggregate, Bin as bin, Collect as collect, Compare as compare, CountPattern as countpattern, Cross as cross, Density as density, DotBin as dotbin, Expression as expression, Extent as extent, Facet as facet, Field as field, Filter as filter, Flatten as flatten, Fold as fold, Formula as formula, Generate as generate, Impute as impute, JoinAggregate as joinaggregate, KDE as kde, Key as key, Load as load, Lookup as lookup, MultiExtent as multiextent, MultiValues as multivalues, Params as params, Pivot as pivot, PreFacet as prefacet, Project as project, Proxy as proxy, Quantile as quantile, Relay as relay, Sample as sample, Sequence as sequence, Sieve as sieve, Subflow as subflow, TimeUnit as timeunit, TupleIndex as tupleindex, Values as values, Window as window };\n"]},"metadata":{},"sourceType":"module"}