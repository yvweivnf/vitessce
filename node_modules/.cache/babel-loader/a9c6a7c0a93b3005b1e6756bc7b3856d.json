{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash as _hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\n\nfunction getStackByFields(model) {\n  return model.stack.stackBy.reduce(function (fields, by) {\n    var fieldDef = by.fieldDef;\n\n    var _field = vgField(fieldDef);\n\n    if (_field) {\n      fields.push(_field);\n    }\n\n    return fields;\n  }, []);\n}\n\nfunction isValidAsArray(as) {\n  return isArray(as) && as.every(function (s) {\n    return isString(s);\n  }) && as.length > 1;\n}\n\nexport var StackNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(StackNode, _DataFlowNode);\n\n  var _super = _createSuper(StackNode);\n\n  function StackNode(parent, stack) {\n    var _this;\n\n    _classCallCheck(this, StackNode);\n\n    _this = _super.call(this, parent);\n    _this._stack = stack;\n    return _this;\n  }\n\n  _createClass(StackNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new StackNode(null, duplicate(this._stack));\n    }\n  }, {\n    key: \"addDimensions\",\n    value: function addDimensions(fields) {\n      var _this$_stack$facetby;\n\n      (_this$_stack$facetby = this._stack.facetby).push.apply(_this$_stack$facetby, _toConsumableArray(fields));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var out = new Set();\n      out.add(this._stack.stackField);\n      this.getGroupbyFields().forEach(out.add, out);\n\n      this._stack.facetby.forEach(out.add, out);\n\n      this._stack.sort.field.forEach(out.add, out);\n\n      return out;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this._stack.as);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Stack \".concat(_hash(this._stack));\n    }\n  }, {\n    key: \"getGroupbyFields\",\n    value: function getGroupbyFields() {\n      var _this$_stack = this._stack,\n          dimensionFieldDef = _this$_stack.dimensionFieldDef,\n          impute = _this$_stack.impute,\n          groupby = _this$_stack.groupby;\n\n      if (dimensionFieldDef) {\n        if (dimensionFieldDef.bin) {\n          if (impute) {\n            // For binned group by field with impute, we calculate bin_mid\n            // as we cannot impute two fields simultaneously\n            return [vgField(dimensionFieldDef, {\n              binSuffix: 'mid'\n            })];\n          }\n\n          return [// For binned group by field without impute, we need both bin (start) and bin_end\n          vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {\n            binSuffix: 'end'\n          })];\n        }\n\n        return [vgField(dimensionFieldDef)];\n      }\n\n      return groupby !== null && groupby !== void 0 ? groupby : [];\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var transform = [];\n      var _this$_stack2 = this._stack,\n          facetby = _this$_stack2.facetby,\n          dimensionFieldDef = _this$_stack2.dimensionFieldDef,\n          field = _this$_stack2.stackField,\n          stackby = _this$_stack2.stackby,\n          sort = _this$_stack2.sort,\n          offset = _this$_stack2.offset,\n          impute = _this$_stack2.impute,\n          as = _this$_stack2.as; // Impute\n\n      if (impute && dimensionFieldDef) {\n        var _dimensionFieldDef$ba = dimensionFieldDef.bandPosition,\n            bandPosition = _dimensionFieldDef$ba === void 0 ? 0.5 : _dimensionFieldDef$ba,\n            bin = dimensionFieldDef.bin;\n\n        if (bin) {\n          // As we can only impute one field at a time, we need to calculate\n          // mid point for a binned field\n          transform.push({\n            type: 'formula',\n            expr: \"\".concat(bandPosition, \"*\") + vgField(dimensionFieldDef, {\n              expr: 'datum'\n            }) + \"+\".concat(1 - bandPosition, \"*\") + vgField(dimensionFieldDef, {\n              expr: 'datum',\n              binSuffix: 'end'\n            }),\n            as: vgField(dimensionFieldDef, {\n              binSuffix: 'mid',\n              forAs: true\n            })\n          });\n        }\n\n        transform.push({\n          type: 'impute',\n          field: field,\n          groupby: [].concat(_toConsumableArray(stackby), _toConsumableArray(facetby)),\n          key: vgField(dimensionFieldDef, {\n            binSuffix: 'mid'\n          }),\n          method: 'value',\n          value: 0\n        });\n      } // Stack\n\n\n      transform.push({\n        type: 'stack',\n        groupby: [].concat(_toConsumableArray(this.getGroupbyFields()), _toConsumableArray(facetby)),\n        field: field,\n        sort: sort,\n        as: as,\n        offset: offset\n      });\n      return transform;\n    }\n  }, {\n    key: \"stack\",\n    get: function get() {\n      return this._stack;\n    }\n  }], [{\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, stackTransform) {\n      var stack = stackTransform.stack,\n          groupby = stackTransform.groupby,\n          as = stackTransform.as,\n          _stackTransform$offse = stackTransform.offset,\n          offset = _stackTransform$offse === void 0 ? 'zero' : _stackTransform$offse;\n      var sortFields = [];\n      var sortOrder = [];\n\n      if (stackTransform.sort !== undefined) {\n        var _iterator = _createForOfIteratorHelper(stackTransform.sort),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var sortField = _step.value;\n            sortFields.push(sortField.field);\n            sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      var sort = {\n        field: sortFields,\n        order: sortOrder\n      };\n      var normalizedAs;\n\n      if (isValidAsArray(as)) {\n        normalizedAs = as;\n      } else if (isString(as)) {\n        normalizedAs = [as, \"\".concat(as, \"_end\")];\n      } else {\n        normalizedAs = [\"\".concat(stackTransform.stack, \"_start\"), \"\".concat(stackTransform.stack, \"_end\")];\n      }\n\n      return new StackNode(parent, {\n        stackField: stack,\n        groupby: groupby,\n        offset: offset,\n        sort: sort,\n        facetby: [],\n        as: normalizedAs\n      });\n    }\n  }, {\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var stackProperties = model.stack;\n      var encoding = model.encoding;\n\n      if (!stackProperties) {\n        return null;\n      }\n\n      var groupbyChannel = stackProperties.groupbyChannel,\n          fieldChannel = stackProperties.fieldChannel,\n          offset = stackProperties.offset,\n          impute = stackProperties.impute;\n      var dimensionFieldDef;\n\n      if (groupbyChannel) {\n        var cDef = encoding[groupbyChannel];\n        dimensionFieldDef = getFieldDef(cDef); // Fair to cast as groupByChannel is always either x or y\n      }\n\n      var stackby = getStackByFields(model);\n      var orderDef = model.encoding.order;\n      var sort;\n\n      if (isArray(orderDef) || isFieldDef(orderDef)) {\n        sort = sortParams(orderDef);\n      } else {\n        // default = descending by stackFields\n        // FIXME is the default here correct for binned fields?\n        sort = stackby.reduce(function (s, field) {\n          s.field.push(field);\n          s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n          return s;\n        }, {\n          field: [],\n          order: []\n        });\n      }\n\n      return new StackNode(parent, {\n        dimensionFieldDef: dimensionFieldDef,\n        stackField: model.vgField(fieldChannel),\n        facetby: [],\n        stackby: stackby,\n        sort: sort,\n        offset: offset,\n        impute: impute,\n        as: [model.vgField(fieldChannel, {\n          suffix: 'start',\n          forAs: true\n        }), model.vgField(fieldChannel, {\n          suffix: 'end',\n          forAs: true\n        })]\n      });\n    }\n  }]);\n\n  return StackNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/stack.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\nfunction getStackByFields(model) {\n    return model.stack.stackBy.reduce((fields, by) => {\n        const fieldDef = by.fieldDef;\n        const _field = vgField(fieldDef);\n        if (_field) {\n            fields.push(_field);\n        }\n        return fields;\n    }, []);\n}\nfunction isValidAsArray(as) {\n    return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\nexport class StackNode extends DataFlowNode {\n    constructor(parent, stack) {\n        super(parent);\n        this._stack = stack;\n    }\n    clone() {\n        return new StackNode(null, duplicate(this._stack));\n    }\n    static makeFromTransform(parent, stackTransform) {\n        const { stack, groupby, as, offset = 'zero' } = stackTransform;\n        const sortFields = [];\n        const sortOrder = [];\n        if (stackTransform.sort !== undefined) {\n            for (const sortField of stackTransform.sort) {\n                sortFields.push(sortField.field);\n                sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n            }\n        }\n        const sort = {\n            field: sortFields,\n            order: sortOrder\n        };\n        let normalizedAs;\n        if (isValidAsArray(as)) {\n            normalizedAs = as;\n        }\n        else if (isString(as)) {\n            normalizedAs = [as, `${as}_end`];\n        }\n        else {\n            normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n        }\n        return new StackNode(parent, {\n            stackField: stack,\n            groupby,\n            offset,\n            sort,\n            facetby: [],\n            as: normalizedAs\n        });\n    }\n    static makeFromEncoding(parent, model) {\n        const stackProperties = model.stack;\n        const { encoding } = model;\n        if (!stackProperties) {\n            return null;\n        }\n        const { groupbyChannel, fieldChannel, offset, impute } = stackProperties;\n        let dimensionFieldDef;\n        if (groupbyChannel) {\n            const cDef = encoding[groupbyChannel];\n            dimensionFieldDef = getFieldDef(cDef); // Fair to cast as groupByChannel is always either x or y\n        }\n        const stackby = getStackByFields(model);\n        const orderDef = model.encoding.order;\n        let sort;\n        if (isArray(orderDef) || isFieldDef(orderDef)) {\n            sort = sortParams(orderDef);\n        }\n        else {\n            // default = descending by stackFields\n            // FIXME is the default here correct for binned fields?\n            sort = stackby.reduce((s, field) => {\n                s.field.push(field);\n                s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n                return s;\n            }, { field: [], order: [] });\n        }\n        return new StackNode(parent, {\n            dimensionFieldDef,\n            stackField: model.vgField(fieldChannel),\n            facetby: [],\n            stackby,\n            sort,\n            offset,\n            impute,\n            as: [\n                model.vgField(fieldChannel, { suffix: 'start', forAs: true }),\n                model.vgField(fieldChannel, { suffix: 'end', forAs: true })\n            ]\n        });\n    }\n    get stack() {\n        return this._stack;\n    }\n    addDimensions(fields) {\n        this._stack.facetby.push(...fields);\n    }\n    dependentFields() {\n        const out = new Set();\n        out.add(this._stack.stackField);\n        this.getGroupbyFields().forEach(out.add, out);\n        this._stack.facetby.forEach(out.add, out);\n        this._stack.sort.field.forEach(out.add, out);\n        return out;\n    }\n    producedFields() {\n        return new Set(this._stack.as);\n    }\n    hash() {\n        return `Stack ${hash(this._stack)}`;\n    }\n    getGroupbyFields() {\n        const { dimensionFieldDef, impute, groupby } = this._stack;\n        if (dimensionFieldDef) {\n            if (dimensionFieldDef.bin) {\n                if (impute) {\n                    // For binned group by field with impute, we calculate bin_mid\n                    // as we cannot impute two fields simultaneously\n                    return [vgField(dimensionFieldDef, { binSuffix: 'mid' })];\n                }\n                return [\n                    // For binned group by field without impute, we need both bin (start) and bin_end\n                    vgField(dimensionFieldDef, {}),\n                    vgField(dimensionFieldDef, { binSuffix: 'end' })\n                ];\n            }\n            return [vgField(dimensionFieldDef)];\n        }\n        return groupby !== null && groupby !== void 0 ? groupby : [];\n    }\n    assemble() {\n        const transform = [];\n        const { facetby, dimensionFieldDef, stackField: field, stackby, sort, offset, impute, as } = this._stack;\n        // Impute\n        if (impute && dimensionFieldDef) {\n            const { bandPosition = 0.5, bin } = dimensionFieldDef;\n            if (bin) {\n                // As we can only impute one field at a time, we need to calculate\n                // mid point for a binned field\n                transform.push({\n                    type: 'formula',\n                    expr: `${bandPosition}*` +\n                        vgField(dimensionFieldDef, { expr: 'datum' }) +\n                        `+${1 - bandPosition}*` +\n                        vgField(dimensionFieldDef, { expr: 'datum', binSuffix: 'end' }),\n                    as: vgField(dimensionFieldDef, { binSuffix: 'mid', forAs: true })\n                });\n            }\n            transform.push({\n                type: 'impute',\n                field,\n                groupby: [...stackby, ...facetby],\n                key: vgField(dimensionFieldDef, { binSuffix: 'mid' }),\n                method: 'value',\n                value: 0\n            });\n        }\n        // Stack\n        transform.push({\n            type: 'stack',\n            groupby: [...this.getGroupbyFields(), ...facetby],\n            field,\n            sort,\n            as,\n            offset\n        });\n        return transform;\n    }\n}\n//# sourceMappingURL=stack.js.map"]},"metadata":{},"sourceType":"module"}