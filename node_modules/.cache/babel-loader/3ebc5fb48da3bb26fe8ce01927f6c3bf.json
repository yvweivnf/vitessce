{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.SELECTION_TYPE = void 0;\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _bbox = _interopRequireDefault(require(\"@turf/bbox\"));\n\nvar _bboxPolygon = _interopRequireDefault(require(\"@turf/bbox-polygon\"));\n\nvar _buffer = _interopRequireDefault(require(\"@turf/buffer\"));\n\nvar _difference = _interopRequireDefault(require(\"@turf/difference\"));\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar POLYGON_LINE_COLOR = [0, 255, 0, 255];\nvar POLYGON_FILL_COLOR = [255, 255, 255, 90];\nvar POLYGON_LINE_WIDTH = 2;\nvar POLYGON_DASHES = [20, 20];\nvar POLYGON_THRESHOLD = 0.01;\nvar EXPANSION_KM = 10;\nvar LAYER_ID_VIEW = 'DeckDrawerView';\nvar LAYER_ID_PICK = 'DeckDrawerPick';\nvar SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\nexports.SELECTION_TYPE = SELECTION_TYPE;\n\nvar DeckDrawer = /*#__PURE__*/function () {\n  function DeckDrawer(nebula) {\n    _classCallCheck(this, DeckDrawer);\n\n    _defineProperty(this, \"nebula\", void 0);\n\n    _defineProperty(this, \"usePolygon\", void 0);\n\n    _defineProperty(this, \"validPolygon\", void 0);\n\n    _defineProperty(this, \"landPoints\", void 0);\n\n    _defineProperty(this, \"mousePoints\", void 0);\n\n    this.nebula = nebula;\n    this.usePolygon = false;\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _createClass(DeckDrawer, [{\n    key: \"_getLayerIds\",\n    value: function _getLayerIds() {\n      // TODO: sort by mouse priority\n      return this.nebula.deckgl.props.layers.filter(function (l) {\n        return l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enableSelection;\n      }).map(function (l) {\n        return l.id;\n      });\n    }\n  }, {\n    key: \"_selectFromPickingInfos\",\n    value: function _selectFromPickingInfos(pickingInfos) {\n      var objects = pickingInfos.map(function (_ref) {\n        var layer = _ref.layer,\n            index = _ref.index,\n            object = _ref.object;\n        return object.original || layer.props.nebulaLayer.deckCache.originals[index];\n      });\n      this.nebula.props.onSelection(objects);\n    }\n  }, {\n    key: \"_getBoundingBox\",\n    value: function _getBoundingBox() {\n      var mousePoints = this.mousePoints;\n      var allX = mousePoints.map(function (mousePoint) {\n        return mousePoint[0];\n      });\n      var allY = mousePoints.map(function (mousePoint) {\n        return mousePoint[1];\n      });\n      var x = Math.min.apply(Math, _toConsumableArray(allX));\n      var y = Math.min.apply(Math, _toConsumableArray(allY));\n      var maxX = Math.max.apply(Math, _toConsumableArray(allX));\n      var maxY = Math.max.apply(Math, _toConsumableArray(allY));\n      return {\n        x: x,\n        y: y,\n        width: maxX - x,\n        height: maxY - y\n      };\n    }\n  }, {\n    key: \"_selectRectangleObjects\",\n    value: function _selectRectangleObjects() {\n      if (this.landPoints.length !== 2) return;\n\n      var _this$mousePoints$ = _slicedToArray(this.mousePoints[0], 2),\n          x1 = _this$mousePoints$[0],\n          y1 = _this$mousePoints$[1];\n\n      var _this$mousePoints$2 = _slicedToArray(this.mousePoints[1], 2),\n          x2 = _this$mousePoints$2[0],\n          y2 = _this$mousePoints$2[1];\n\n      var pickingInfos = this.nebula.deckgl.pickObjects({\n        x: Math.min(x1, x2),\n        y: Math.min(y1, y2),\n        width: Math.abs(x2 - x1),\n        height: Math.abs(y2 - y1),\n        layerIds: this._getLayerIds()\n      });\n\n      this._selectFromPickingInfos(pickingInfos);\n    }\n  }, {\n    key: \"_selectPolygonObjects\",\n    value: function _selectPolygonObjects() {\n      var pickingInfos = this.nebula.deckgl.pickObjects(_objectSpread({}, this._getBoundingBox(), {\n        layerIds: [LAYER_ID_PICK].concat(_toConsumableArray(this._getLayerIds()))\n      }));\n\n      this._selectFromPickingInfos(pickingInfos.filter(function (item) {\n        return item.layer.id !== LAYER_ID_PICK;\n      }));\n    }\n  }, {\n    key: \"_getMousePosFromEvent\",\n    value: function _getMousePosFromEvent(event) {\n      var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n      return [offsetX, offsetY];\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event, lngLat, selectionType) {\n      // capture all events (mouse-up is needed to prevent us stuck in moving map)\n      if (event.type !== 'mouseup') event.stopPropagation(); // @ts-ignore\n\n      this.usePolygon = selectionType === SELECTION_TYPE.POLYGON;\n      var redraw = false;\n      var deactivate = false;\n      var usePolygon = this.usePolygon,\n          landPoints = this.landPoints,\n          mousePoints = this.mousePoints;\n\n      if (event.type === 'mousedown') {\n        if (usePolygon && landPoints.length) {\n          // if landPoints.length is zero we want to insert two points (so we let it run the else)\n          // also don't insert if polygon is invalid\n          if (this.landPoints.length < 3 || this.validPolygon) {\n            landPoints.push(lngLat);\n            mousePoints.push(this._getMousePosFromEvent(event));\n          }\n        } else {\n          this.landPoints = [lngLat, lngLat];\n\n          var m = this._getMousePosFromEvent(event);\n\n          this.mousePoints = [m, m];\n        }\n\n        redraw = true;\n      } else if (event.type === 'mousemove' && landPoints.length) {\n        // update last point\n        landPoints[landPoints.length - 1] = lngLat;\n        mousePoints[mousePoints.length - 1] = this._getMousePosFromEvent(event);\n        redraw = true;\n      } else if (event.type === 'mouseup') {\n        if (usePolygon) {\n          // check to see if completed\n          // TODO: Maybe double-click to finish?\n          if (landPoints.length > 4 && (0, _distance[\"default\"])(landPoints[0], landPoints[landPoints.length - 1]) < POLYGON_THRESHOLD && this.validPolygon) {\n            this._selectPolygonObjects();\n\n            this.reset();\n            redraw = true;\n            deactivate = true;\n          }\n        } else {\n          this._selectRectangleObjects();\n\n          this.reset();\n          redraw = true;\n          deactivate = true;\n        }\n      }\n\n      return {\n        redraw: redraw,\n        deactivate: deactivate\n      };\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.landPoints = [];\n      this.mousePoints = [];\n    }\n  }, {\n    key: \"_makeStartPointHighlight\",\n    value: function _makeStartPointHighlight(center) {\n      var buffer = (0, _buffer[\"default\"])((0, _helpers.point)(center), POLYGON_THRESHOLD / 4.0); // @ts-ignore\n\n      return (0, _bboxPolygon[\"default\"])((0, _bbox[\"default\"])(buffer)).geometry.coordinates;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      var data = [];\n      var dataPick = [];\n\n      if (!this.usePolygon && this.landPoints.length === 2) {\n        // Use mouse points instead of land points so we get the right shape\n        // no matter what bearing is.\n        var _this$mousePoints = _slicedToArray(this.mousePoints, 2),\n            _this$mousePoints$3 = _slicedToArray(_this$mousePoints[0], 2),\n            x1 = _this$mousePoints$3[0],\n            y1 = _this$mousePoints$3[1],\n            _this$mousePoints$4 = _slicedToArray(_this$mousePoints[1], 2),\n            x2 = _this$mousePoints$4[0],\n            y2 = _this$mousePoints$4[1];\n\n        var selPolygon = [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]].map(function (mousePos) {\n          return _this.nebula.unprojectMousePosition(mousePos);\n        });\n        data.push({\n          polygon: selPolygon,\n          lineColor: POLYGON_LINE_COLOR,\n          fillColor: POLYGON_FILL_COLOR\n        });\n      } else if (this.usePolygon && this.landPoints.length) {\n        data.push({\n          polygon: this.landPoints,\n          lineColor: POLYGON_LINE_COLOR,\n          fillColor: POLYGON_FILL_COLOR\n        }); // Hack: use a polygon to hide the outside, because pickObjects()\n        // does not support polygons\n\n        if (this.landPoints.length >= 3) {\n          var landPointsPoly = (0, _helpers.polygon)([[].concat(_toConsumableArray(this.landPoints), [this.landPoints[0]])]);\n          var bigBuffer = (0, _buffer[\"default\"])((0, _helpers.point)(this.landPoints[0]), EXPANSION_KM);\n          var bigPolygon;\n\n          try {\n            // turfDifference throws an exception if the polygon\n            // intersects with itself\n            bigPolygon = (0, _difference[\"default\"])(bigBuffer, landPointsPoly);\n            dataPick.push({\n              polygon: bigPolygon.geometry.coordinates,\n              fillColor: [0, 0, 0, 1]\n            });\n            this.validPolygon = true;\n          } catch (e) {\n            // invalid selection polygon\n            this.validPolygon = false;\n          }\n        }\n      }\n\n      if (this.landPoints.length) {\n        // highlight start point\n        data.push({\n          polygon: this._makeStartPointHighlight(this.landPoints[0]),\n          lineColor: [0, 0, 0, 0],\n          fillColor: POLYGON_LINE_COLOR\n        });\n      } // Hack to make the PolygonLayer() stay active,\n      // otherwise it takes 3 seconds (!) to init!\n      // TODO: fix this\n\n\n      data.push({\n        polygon: [[0, 0]]\n      });\n      dataPick.push({\n        polygon: [[0, 0]]\n      });\n      return [new _layers.PolygonLayer({\n        id: LAYER_ID_VIEW,\n        data: data,\n        // @ts-ignore\n        fp64: false,\n        opacity: 1.0,\n        pickable: false,\n        lineWidthMinPixels: POLYGON_LINE_WIDTH,\n        lineWidthMaxPixels: POLYGON_LINE_WIDTH,\n        lineDashJustified: true,\n        getLineDashArray: function getLineDashArray(x) {\n          return POLYGON_DASHES;\n        },\n        // @ts-ignore\n        getLineColor: function getLineColor(obj) {\n          return obj.lineColor || [0, 0, 0, 255];\n        },\n        // @ts-ignore\n        getFillColor: function getFillColor(obj) {\n          return obj.fillColor || [0, 0, 0, 255];\n        },\n        // @ts-ignore\n        getPolygon: function getPolygon(o) {\n          return o.polygon;\n        }\n      }), new _layers.PolygonLayer({\n        id: LAYER_ID_PICK,\n        data: dataPick,\n        // @ts-ignore\n        getLineColor: function getLineColor(obj) {\n          return obj.lineColor || [0, 0, 0, 255];\n        },\n        // @ts-ignore\n        getFillColor: function getFillColor(obj) {\n          return obj.fillColor || [0, 0, 0, 255];\n        },\n        // @ts-ignore\n        fp64: false,\n        opacity: 1.0,\n        stroked: false,\n        pickable: true,\n        // @ts-ignore\n        getPolygon: function getPolygon(o) {\n          return o.polygon;\n        }\n      })];\n    }\n  }]);\n\n  return DeckDrawer;\n}();\n\nexports[\"default\"] = DeckDrawer;","map":{"version":3,"sources":["../../../src/lib/deck-renderer/deck-drawer.ts"],"names":["POLYGON_LINE_COLOR","POLYGON_FILL_COLOR","POLYGON_LINE_WIDTH","POLYGON_DASHES","POLYGON_THRESHOLD","EXPANSION_KM","LAYER_ID_VIEW","LAYER_ID_PICK","SELECTION_TYPE","NONE","RECTANGLE","POLYGON","DeckDrawer","l","pickingInfos","objects","layer","index","object","mousePoints","allX","mousePoint","allY","x","Math","y","maxX","maxY","width","height","x1","y1","x2","y2","layerIds","item","event","offsetX","offsetY","lngLat","selectionType","redraw","deactivate","usePolygon","landPoints","m","center","buffer","data","dataPick","selPolygon","polygon","lineColor","fillColor","landPointsPoly","bigBuffer","bigPolygon","PolygonLayer","id","fp64","opacity","pickable","lineWidthMinPixels","lineWidthMaxPixels","lineDashJustified","getLineDashArray","getLineColor","obj","getFillColor","getPolygon","o","stroked"],"mappings":"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","sourcesContent":["import { PolygonLayer } from '@deck.gl/layers';\nimport { point, polygon } from '@turf/helpers';\nimport turfBbox from '@turf/bbox';\nimport turfBboxPolygon from '@turf/bbox-polygon';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\nimport turfDistance from '@turf/distance';\n\nconst POLYGON_LINE_COLOR = [0, 255, 0, 255];\nconst POLYGON_FILL_COLOR = [255, 255, 255, 90];\nconst POLYGON_LINE_WIDTH = 2;\nconst POLYGON_DASHES = [20, 20];\nconst POLYGON_THRESHOLD = 0.01;\nconst EXPANSION_KM = 10;\nconst LAYER_ID_VIEW = 'DeckDrawerView';\nconst LAYER_ID_PICK = 'DeckDrawerPick';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon',\n};\n\nexport default class DeckDrawer {\n  nebula: Record<string, any>;\n  usePolygon: boolean;\n  validPolygon: boolean;\n  landPoints: [number, number][];\n  mousePoints: [number, number][];\n\n  constructor(nebula: Record<string, any>) {\n    this.nebula = nebula;\n    this.usePolygon = false;\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _getLayerIds() {\n    // TODO: sort by mouse priority\n    return this.nebula.deckgl.props.layers\n      .filter((l) => l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enableSelection)\n      .map((l) => l.id);\n  }\n\n  _selectFromPickingInfos(pickingInfos: Record<string, any>[]) {\n    const objects = pickingInfos.map(\n      ({ layer, index, object }) =>\n        object.original || layer.props.nebulaLayer.deckCache.originals[index]\n    );\n    this.nebula.props.onSelection(objects);\n  }\n\n  _getBoundingBox(): Record<string, any> {\n    const { mousePoints } = this;\n    const allX = mousePoints.map((mousePoint) => mousePoint[0]);\n    const allY = mousePoints.map((mousePoint) => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    return { x, y, width: maxX - x, height: maxY - y };\n  }\n\n  _selectRectangleObjects() {\n    if (this.landPoints.length !== 2) return;\n\n    const [x1, y1] = this.mousePoints[0];\n    const [x2, y2] = this.mousePoints[1];\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds: this._getLayerIds(),\n    });\n\n    this._selectFromPickingInfos(pickingInfos);\n  }\n\n  _selectPolygonObjects() {\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      ...this._getBoundingBox(),\n      layerIds: [LAYER_ID_PICK, ...this._getLayerIds()],\n    });\n\n    this._selectFromPickingInfos(pickingInfos.filter((item) => item.layer.id !== LAYER_ID_PICK));\n  }\n\n  _getMousePosFromEvent(event: Record<string, any>): [number, number] {\n    const { offsetX, offsetY } = event;\n    return [offsetX, offsetY];\n  }\n\n  handleEvent(\n    event: Record<string, any>,\n    lngLat: [number, number],\n    selectionType: number\n  ): { redraw: boolean; deactivate: boolean } {\n    // capture all events (mouse-up is needed to prevent us stuck in moving map)\n    if (event.type !== 'mouseup') event.stopPropagation();\n    // @ts-ignore\n    this.usePolygon = selectionType === SELECTION_TYPE.POLYGON;\n\n    let redraw = false;\n    let deactivate = false;\n\n    const { usePolygon, landPoints, mousePoints } = this;\n\n    if (event.type === 'mousedown') {\n      if (usePolygon && landPoints.length) {\n        // if landPoints.length is zero we want to insert two points (so we let it run the else)\n        // also don't insert if polygon is invalid\n        if (this.landPoints.length < 3 || this.validPolygon) {\n          landPoints.push(lngLat);\n          mousePoints.push(this._getMousePosFromEvent(event));\n        }\n      } else {\n        this.landPoints = [lngLat, lngLat];\n        const m = this._getMousePosFromEvent(event);\n        this.mousePoints = [m, m];\n      }\n      redraw = true;\n    } else if (event.type === 'mousemove' && landPoints.length) {\n      // update last point\n      landPoints[landPoints.length - 1] = lngLat;\n      mousePoints[mousePoints.length - 1] = this._getMousePosFromEvent(event);\n      redraw = true;\n    } else if (event.type === 'mouseup') {\n      if (usePolygon) {\n        // check to see if completed\n        // TODO: Maybe double-click to finish?\n        if (\n          landPoints.length > 4 &&\n          turfDistance(landPoints[0], landPoints[landPoints.length - 1]) < POLYGON_THRESHOLD &&\n          this.validPolygon\n        ) {\n          this._selectPolygonObjects();\n          this.reset();\n          redraw = true;\n          deactivate = true;\n        }\n      } else {\n        this._selectRectangleObjects();\n        this.reset();\n        redraw = true;\n        deactivate = true;\n      }\n    }\n\n    return { redraw, deactivate };\n  }\n\n  reset() {\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _makeStartPointHighlight(center: [number, number]): number[] {\n    const buffer = turfBuffer(point(center), POLYGON_THRESHOLD / 4.0);\n    // @ts-ignore\n    return turfBboxPolygon(turfBbox(buffer)).geometry.coordinates;\n  }\n\n  render() {\n    const data = [];\n    const dataPick = [];\n\n    if (!this.usePolygon && this.landPoints.length === 2) {\n      // Use mouse points instead of land points so we get the right shape\n      // no matter what bearing is.\n      const [[x1, y1], [x2, y2]] = this.mousePoints;\n      const selPolygon = [\n        [x1, y1],\n        [x1, y2],\n        [x2, y2],\n        [x2, y1],\n        [x1, y1],\n      ].map((mousePos) => this.nebula.unprojectMousePosition(mousePos));\n      data.push({\n        polygon: selPolygon,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR,\n      });\n    } else if (this.usePolygon && this.landPoints.length) {\n      data.push({\n        polygon: this.landPoints,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR,\n      });\n\n      // Hack: use a polygon to hide the outside, because pickObjects()\n      // does not support polygons\n      if (this.landPoints.length >= 3) {\n        const landPointsPoly = polygon([[...this.landPoints, this.landPoints[0]]]);\n        const bigBuffer = turfBuffer(point(this.landPoints[0]), EXPANSION_KM);\n        let bigPolygon;\n        try {\n          // turfDifference throws an exception if the polygon\n          // intersects with itself\n          bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n          dataPick.push({\n            polygon: bigPolygon.geometry.coordinates,\n            fillColor: [0, 0, 0, 1],\n          });\n          this.validPolygon = true;\n        } catch (e) {\n          // invalid selection polygon\n          this.validPolygon = false;\n        }\n      }\n    }\n\n    if (this.landPoints.length) {\n      // highlight start point\n      data.push({\n        polygon: this._makeStartPointHighlight(this.landPoints[0]),\n        lineColor: [0, 0, 0, 0],\n        fillColor: POLYGON_LINE_COLOR,\n      });\n    }\n\n    // Hack to make the PolygonLayer() stay active,\n    // otherwise it takes 3 seconds (!) to init!\n    // TODO: fix this\n    data.push({ polygon: [[0, 0]] });\n    dataPick.push({ polygon: [[0, 0]] });\n\n    return [\n      new PolygonLayer({\n        id: LAYER_ID_VIEW,\n        data,\n        // @ts-ignore\n        fp64: false,\n        opacity: 1.0,\n        pickable: false,\n        lineWidthMinPixels: POLYGON_LINE_WIDTH,\n        lineWidthMaxPixels: POLYGON_LINE_WIDTH,\n        lineDashJustified: true,\n        getLineDashArray: (x) => POLYGON_DASHES,\n        // @ts-ignore\n        getLineColor: (obj) => obj.lineColor || [0, 0, 0, 255],\n        // @ts-ignore\n        getFillColor: (obj) => obj.fillColor || [0, 0, 0, 255],\n        // @ts-ignore\n        getPolygon: (o) => o.polygon,\n      }),\n      new PolygonLayer({\n        id: LAYER_ID_PICK,\n        data: dataPick,\n        // @ts-ignore\n        getLineColor: (obj) => obj.lineColor || [0, 0, 0, 255],\n        // @ts-ignore\n        getFillColor: (obj) => obj.fillColor || [0, 0, 0, 255],\n        // @ts-ignore\n        fp64: false,\n        opacity: 1.0,\n        stroked: false,\n        pickable: true,\n        // @ts-ignore\n        getPolygon: (o) => o.polygon,\n      }),\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}