{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport LayersPass from './layers-pass';\nimport { withParameters } from '@luma.gl/core';\nimport log from '../utils/log';\nvar PICKING_PARAMETERS = {\n  blendFunc: [1, 0, 32771, 0],\n  blendEquation: 32774\n};\n\nvar PickLayersPass = /*#__PURE__*/function (_LayersPass) {\n  _inherits(PickLayersPass, _LayersPass);\n\n  var _super = _createSuper(PickLayersPass);\n\n  function PickLayersPass() {\n    _classCallCheck(this, PickLayersPass);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PickLayersPass, [{\n    key: \"render\",\n    value: function render(props) {\n      if (props.pickingFBO) {\n        return this._drawPickingBuffer(props);\n      }\n\n      return _get(_getPrototypeOf(PickLayersPass.prototype), \"render\", this).call(this, props);\n    }\n  }, {\n    key: \"_drawPickingBuffer\",\n    value: function _drawPickingBuffer(_ref) {\n      var _this = this;\n\n      var layers = _ref.layers,\n          layerFilter = _ref.layerFilter,\n          views = _ref.views,\n          viewports = _ref.viewports,\n          onViewportActive = _ref.onViewportActive,\n          pickingFBO = _ref.pickingFBO,\n          _ref$deviceRect = _ref.deviceRect,\n          x = _ref$deviceRect.x,\n          y = _ref$deviceRect.y,\n          width = _ref$deviceRect.width,\n          height = _ref$deviceRect.height,\n          _ref$pass = _ref.pass,\n          pass = _ref$pass === void 0 ? 'picking' : _ref$pass,\n          redrawReason = _ref.redrawReason,\n          pickZ = _ref.pickZ;\n      var gl = this.gl;\n      this.pickZ = pickZ;\n      var encodedColors = !pickZ && {\n        byLayer: new Map(),\n        byAlpha: []\n      };\n      this._colors = encodedColors;\n      var renderStatus = withParameters(gl, _objectSpread({\n        scissorTest: true,\n        scissor: [x, y, width, height],\n        clearColor: [0, 0, 0, 0],\n        depthMask: true,\n        depthTest: true,\n        depthRange: [0, 1],\n        colorMask: [true, true, true, true]\n      }, PICKING_PARAMETERS, {\n        blend: !pickZ\n      }), function () {\n        return _get(_getPrototypeOf(PickLayersPass.prototype), \"render\", _this).call(_this, {\n          target: pickingFBO,\n          layers: layers,\n          layerFilter: layerFilter,\n          views: views,\n          viewports: viewports,\n          onViewportActive: onViewportActive,\n          pass: pass,\n          redrawReason: redrawReason\n        });\n      });\n      this._colors = null;\n      var decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);\n      return {\n        decodePickingColor: decodePickingColor,\n        stats: renderStatus\n      };\n    }\n  }, {\n    key: \"shouldDrawLayer\",\n    value: function shouldDrawLayer(layer) {\n      return layer.props.pickable;\n    }\n  }, {\n    key: \"getModuleParameters\",\n    value: function getModuleParameters() {\n      return {\n        pickingActive: 1,\n        pickingAttribute: this.pickZ,\n        lightSources: {}\n      };\n    }\n  }, {\n    key: \"getLayerParameters\",\n    value: function getLayerParameters(layer, layerIndex, viewport) {\n      var pickParameters = _objectSpread({}, layer.props.parameters);\n\n      if (this.pickZ) {\n        pickParameters.blend = false;\n      } else {\n        Object.assign(pickParameters, PICKING_PARAMETERS);\n        pickParameters.blend = true;\n        pickParameters.blendColor = encodeColor(this._colors, layer, viewport);\n      }\n\n      return pickParameters;\n    }\n  }]);\n\n  return PickLayersPass;\n}(LayersPass);\n\nexport { PickLayersPass as default };\n\nfunction encodeColor(encoded, layer, viewport) {\n  var byLayer = encoded.byLayer,\n      byAlpha = encoded.byAlpha;\n  var a;\n\n  if (byLayer.has(layer)) {\n    var entry = byLayer.get(layer);\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n\n    if (a <= 255) {\n      var _entry = {\n        a: a,\n        layer: layer,\n        viewports: [viewport]\n      };\n      byLayer.set(layer, _entry);\n      byAlpha[a] = _entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n\n  return [0, 0, 0, a / 255];\n}\n\nfunction decodeColor(encoded, pickedColor) {\n  var entry = encoded.byAlpha[pickedColor[3]];\n  return entry && {\n    pickedLayer: entry.layer,\n    pickedViewports: entry.viewports,\n    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n  };\n}","map":{"version":3,"sources":["../../../src/passes/pick-layers-pass.js"],"names":["PICKING_PARAMETERS","blendFunc","blendEquation","props","deviceRect","height","pass","pickZ","gl","encodedColors","byLayer","byAlpha","renderStatus","withParameters","scissorTest","scissor","clearColor","depthMask","depthTest","depthRange","colorMask","blend","target","layers","layerFilter","views","viewports","onViewportActive","redrawReason","decodePickingColor","decodeColor","stats","layer","pickingActive","pickingAttribute","lightSources","pickParameters","parameters","Object","encodeColor","entry","a","log","encoded","pickedColor","pickedLayer","pickedViewports","pickedObjectIndex"],"mappings":";;;;;;;AAAA,OAAA,UAAA,MAAA,eAAA;AACA,SAAA,cAAA,QAAA,eAAA;AAEA,OAAA,GAAA,MAAA,cAAA;AAEA,IAAMA,kBAAkB,GAAG;AACzBC,EAAAA,SAAS,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EADc,CACd,CADc;AAEzBC,EAAAA,aAAa,EAAA;AAFY,CAA3B;;IAKe,c;;;;;;;;;;;;;2BACP,K,EAAQ;AACZ,UAAIC,KAAK,CAAT,UAAA,EAAsB;AAEpB,eAAO,KAAA,kBAAA,CAAP,KAAO,CAAP;AACD;;AAED,wFAAA,KAAA;AACD;;;uCAKiB,I,EAWf;AAAA;;AAAA,UAXgB,MAWhB,GAAA,IAAA,CAXgB,MAWhB;AAAA,UAXgB,WAWhB,GAAA,IAAA,CAXgB,WAWhB;AAAA,UAXgB,KAWhB,GAAA,IAAA,CAXgB,KAWhB;AAAA,UAXgB,SAWhB,GAAA,IAAA,CAXgB,SAWhB;AAAA,UAXgB,gBAWhB,GAAA,IAAA,CAXgB,gBAWhB;AAAA,UAXgB,UAWhB,GAAA,IAAA,CAXgB,UAWhB;AAAA,4BAAA,IAAA,CAJDC,UAIC;AAAA,UAJW,CAIX,mBAJW,CAIX;AAAA,UAJW,CAIX,mBAJW,CAIX;AAAA,UAJW,KAIX,mBAJW,KAIX;AAAA,UAJyBC,MAIzB,mBAJyBA,MAIzB;AAAA,sBAAA,IAAA,CAHDC,IAGC;AAAA,UAHDA,IAGC,0BAXgB,SAWhB;AAAA,UAXgB,YAWhB,GAAA,IAAA,CAXgB,YAWhB;AAAA,UADDC,KACC,GAAA,IAAA,CADDA,KACC;AACD,UAAMC,EAAE,GAAG,KAAX,EAAA;AACA,WAAA,KAAA,GAAA,KAAA;AAGA,UAAMC,aAAa,GAAG,CAAA,KAAA,IAAU;AAC9BC,QAAAA,OAAO,EAAE,IADqB,GACrB,EADqB;AAE9BC,QAAAA,OAAO,EAAE;AAFqB,OAAhC;AAKA,WAAA,OAAA,GAAA,aAAA;AAOA,UAAMC,YAAY,GAAGC,cAAc,CAAA,EAAA;AAG/BC,QAAAA,WAAW,EADb,IAFiC;AAI/BC,QAAAA,OAAO,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EAFX,MAEW,CAJsB;AAK/BC,QAAAA,UAAU,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAHd,CAGc,CALmB;AAS/BC,QAAAA,SAAS,EAPX,IAFiC;AAU/BC,QAAAA,SAAS,EARX,IAFiC;AAW/BC,QAAAA,UAAU,EAAE,CAAA,CAAA,EATd,CASc,CAXmB;AAY/BC,QAAAA,SAAS,EAAE,CAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAVb,IAUa;AAZoB,SAEjC,kBAFiC;AAe/BC,QAAAA,KAAK,EAAE,CAACd;AAfuB,UAiBjC;AAAA,4FACe;AACXe,UAAAA,MAAM,EADK,UAAA;AAEXC,UAAAA,MAFW,EAEXA,MAFW;AAGXC,UAAAA,WAHW,EAGXA,WAHW;AAIXC,UAAAA,KAJW,EAIXA,KAJW;AAKXC,UAAAA,SALW,EAKXA,SALW;AAMXC,UAAAA,gBANW,EAMXA,gBANW;AAOXrB,UAAAA,IAPW,EAOXA,IAPW;AAQXsB,UAAAA,YAAAA,EAAAA;AARW,SADf;AAAA,OAjBiC,CAAnC;AA+BA,WAAA,OAAA,GAAA,IAAA;AACA,UAAMC,kBAAkB,GAAGpB,aAAa,IAAIqB,WAAW,CAAXA,IAAAA,CAAAA,IAAAA,EAA5C,aAA4CA,CAA5C;AACA,aAAO;AAACD,QAAAA,kBAAD,EAACA,kBAAD;AAAqBE,QAAAA,KAAK,EAAEnB;AAA5B,OAAP;AACD;;;oCAGc,K,EAAQ;AACrB,aAAOoB,KAAK,CAALA,KAAAA,CAAP,QAAA;AACD;;;0CAEqB;AACpB,aAAO;AACLC,QAAAA,aAAa,EADR,CAAA;AAELC,QAAAA,gBAAgB,EAAE,KAFb,KAAA;AAKLC,QAAAA,YAAY,EAAE;AALT,OAAP;AAOD;;;uCAEiB,K,EAAA,U,EAAA,Q,EAA8B;AAC9C,UAAMC,cAAc,qBAAOJ,KAAK,CAALA,KAAAA,CAAYK,UAAnB,CAApB;;AAEA,UAAI,KAAJ,KAAA,EAAgB;AACdD,QAAAA,cAAc,CAAdA,KAAAA,GAAAA,KAAAA;AADF,OAAA,MAEO;AACLE,QAAAA,MAAM,CAANA,MAAAA,CAAAA,cAAAA,EAAAA,kBAAAA;AACAF,QAAAA,cAAc,CAAdA,KAAAA,GAAAA,IAAAA;AACAA,QAAAA,cAAc,CAAdA,UAAAA,GAA4BG,WAAW,CAAC,KAAD,OAAA,EAAA,KAAA,EAAvCH,QAAuC,CAAvCA;AACD;;AAED,aAAA,cAAA;AACD;;;;EAxGY,U;;SAAA,c;;AA6Gf,SAAA,WAAA,CAAA,OAAA,EAAA,KAAA,EAAA,QAAA,EAA+C;AAAA,MACvC,OADuC,GAC7C,OAD6C,CACvC,OADuC;AAAA,MAC7BzB,OAD6B,GAC7C,OAD6C,CAC7BA,OAD6B;AAE7C,MAAA,CAAA;;AAIA,MAAID,OAAO,CAAPA,GAAAA,CAAJ,KAAIA,CAAJ,EAAwB;AACtB,QAAM8B,KAAK,GAAG9B,OAAO,CAAPA,GAAAA,CAAd,KAAcA,CAAd;AACA8B,IAAAA,KAAK,CAALA,SAAAA,CAAAA,IAAAA,CAAAA,QAAAA;AACAC,IAAAA,CAAC,GAAGD,KAAK,CAATC,CAAAA;AAHF,GAAA,MAIO;AACLA,IAAAA,CAAC,GAAG/B,OAAO,CAAPA,IAAAA,GAAJ+B,CAAAA;;AACA,QAAIA,CAAC,IAAL,GAAA,EAAc;AACZ,UAAMD,MAAK,GAAG;AAACC,QAAAA,CAAD,EAACA,CAAD;AAAIT,QAAAA,KAAJ,EAAIA,KAAJ;AAAWN,QAAAA,SAAS,EAAE,CAAA,QAAA;AAAtB,OAAd;AACAhB,MAAAA,OAAO,CAAPA,GAAAA,CAAAA,KAAAA,EAAAA,MAAAA;AACAC,MAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAAA,MAAAA;AAHF,KAAA,MAIO;AACL+B,MAAAA,GAAG,CAAHA,IAAAA,CAAAA,sDAAAA;AACAD,MAAAA,CAAC,GAADA,CAAAA;AACD;AACF;;AACD,SAAO,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAUA,CAAC,GAAlB,GAAO,CAAP;AACD;;AAGD,SAAA,WAAA,CAAA,OAAA,EAAA,WAAA,EAA2C;AACzC,MAAMD,KAAK,GAAGG,OAAO,CAAPA,OAAAA,CAAgBC,WAAW,CAAzC,CAAyC,CAA3BD,CAAd;AACA,SACEH,KAAK,IAAI;AACPK,IAAAA,WAAW,EAAEL,KAAK,CADX,KAAA;AAEPM,IAAAA,eAAe,EAAEN,KAAK,CAFf,SAAA;AAGPO,IAAAA,iBAAiB,EAAEP,KAAK,CAALA,KAAAA,CAAAA,kBAAAA,CAAAA,WAAAA;AAHZ,GADX;AAOD","sourcesContent":["import LayersPass from './layers-pass';\nimport {withParameters} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport log from '../utils/log';\n\nconst PICKING_PARAMETERS = {\n  blendFunc: [GL.ONE, GL.ZERO, GL.CONSTANT_ALPHA, GL.ZERO],\n  blendEquation: GL.FUNC_ADD\n};\n\nexport default class PickLayersPass extends LayersPass {\n  render(props) {\n    if (props.pickingFBO) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {x, y, width, height},\n    pass = 'picking',\n    redrawReason,\n    pickZ\n  }) {\n    const gl = this.gl;\n    this.pickZ = pickZ;\n\n    // Track encoded layer indices\n    const encodedColors = !pickZ && {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    this._colors = encodedColors;\n\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = withParameters(\n      gl,\n      {\n        scissorTest: true,\n        scissor: [x, y, width, height],\n        clearColor: [0, 0, 0, 0],\n        // When used as Mapbox custom layer, the context state may be dirty\n        // TODO - Remove when mapbox fixes this issue\n        // https://github.com/mapbox/mapbox-gl-js/issues/7801\n        depthMask: true,\n        depthTest: true,\n        depthRange: [0, 1],\n        colorMask: [true, true, true, true],\n        // Blending\n        ...PICKING_PARAMETERS,\n        blend: !pickZ\n      },\n      () =>\n        super.render({\n          target: pickingFBO,\n          layers,\n          layerFilter,\n          views,\n          viewports,\n          onViewportActive,\n          pass,\n          redrawReason\n        })\n    );\n\n    // Clear the temp field\n    this._colors = null;\n    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);\n    return {decodePickingColor, stats: renderStatus};\n  }\n\n  // PRIVATE\n  shouldDrawLayer(layer) {\n    return layer.props.pickable;\n  }\n\n  getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      // turn off lighting by adding empty light source object\n      // lights shader module relies on the `lightSources` to turn on/off lighting\n      lightSources: {}\n    };\n  }\n\n  getLayerParameters(layer, layerIndex, viewport) {\n    const pickParameters = {...layer.props.parameters};\n\n    if (this.pickZ) {\n      pickParameters.blend = false;\n    } else {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);\n    }\n\n    return pickParameters;\n  }\n}\n\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n  const {byLayer, byAlpha} = encoded;\n  let a;\n\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  if (byLayer.has(layer)) {\n    const entry = byLayer.get(layer);\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      const entry = {a, layer, viewports: [viewport]};\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return (\n    entry && {\n      pickedLayer: entry.layer,\n      pickedViewports: entry.viewports,\n      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    }\n  );\n}\n"]},"metadata":{},"sourceType":"module"}