{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject } from 'vega-util';\nimport { isXorY } from '../../channel';\nimport { keys } from '../../util';\nimport { isDataRefDomain, isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    // For concat and layer, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\nexport function assembleScalesForModel(model) {\n  return keys(model.component.scales).reduce((scales, channel) => {\n    const scaleComponent = model.component.scales[channel];\n\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    const scale = scaleComponent.combine();\n\n    const {\n      name,\n      type,\n      selectionExtent,\n      domains: _d,\n      range: _r,\n      reverse\n    } = scale,\n          otherScaleProps = __rest(scale, [\"name\", \"type\", \"selectionExtent\", \"domains\", \"range\", \"reverse\"]);\n\n    const range = assembleScaleRange(scale.range, name, channel, model);\n    const domain = assembleDomain(model, channel);\n    const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain) : null;\n    scales.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      name,\n      type\n    }, domain ? {\n      domain\n    } : {}), domainRaw ? {\n      domainRaw\n    } : {}), {\n      range\n    }), reverse !== undefined ? {\n      reverse: reverse\n    } : {}), otherScaleProps));\n    return scales;\n  }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel, model) {\n  // add signals to x/y range\n  if (isXorY(channel)) {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {\n          signal: `${scaleName}_step`\n        }\n      };\n    }\n  } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n    return Object.assign(Object.assign({}, scaleRange), {\n      data: model.lookupDataSource(scaleRange.data)\n    });\n  }\n\n  return scaleRange;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject } from 'vega-util';\nimport { isXorY } from '../../channel';\nimport { keys } from '../../util';\nimport { isDataRefDomain, isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n    if (isLayerModel(model) || isConcatModel(model)) {\n        // For concat and layer, include scales of children too\n        return model.children.reduce((scales, child) => {\n            return scales.concat(assembleScales(child));\n        }, assembleScalesForModel(model));\n    }\n    else {\n        // For facet, child scales would not be included in the parent's scope.\n        // For unit, there is no child.\n        return assembleScalesForModel(model);\n    }\n}\nexport function assembleScalesForModel(model) {\n    return keys(model.component.scales).reduce((scales, channel) => {\n        const scaleComponent = model.component.scales[channel];\n        if (scaleComponent.merged) {\n            // Skipped merged scales\n            return scales;\n        }\n        const scale = scaleComponent.combine();\n        const { name, type, selectionExtent, domains: _d, range: _r, reverse } = scale, otherScaleProps = __rest(scale, [\"name\", \"type\", \"selectionExtent\", \"domains\", \"range\", \"reverse\"]);\n        const range = assembleScaleRange(scale.range, name, channel, model);\n        const domain = assembleDomain(model, channel);\n        const domainRaw = selectionExtent\n            ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain)\n            : null;\n        scales.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name,\n            type }, (domain ? { domain } : {})), (domainRaw ? { domainRaw } : {})), { range }), (reverse !== undefined ? { reverse: reverse } : {})), otherScaleProps));\n        return scales;\n    }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel, model) {\n    // add signals to x/y range\n    if (isXorY(channel)) {\n        if (isVgRangeStep(scaleRange)) {\n            // For width/height step, use a signal created in layout assemble instead of a constant step.\n            return {\n                step: { signal: `${scaleName}_step` }\n            };\n        }\n    }\n    else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n        return Object.assign(Object.assign({}, scaleRange), { data: model.lookupDataSource(scaleRange.data) });\n    }\n    return scaleRange;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}