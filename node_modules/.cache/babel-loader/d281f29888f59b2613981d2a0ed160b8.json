{"ast":null,"code":"import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model, opt = {}) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.tooltip;\n\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, stack, config, opt)\n    };\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {\n            signal: datum\n          };\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\nexport function tooltipData(encoding, stack, config, {\n  reactiveGeom\n} = {}) {\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples = [];\n\n  function add(fDef, channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n\n    });\n    const title = fieldDef.title || defaultTitle(fieldDef, config);\n    const key = array(title).join(', ');\n    let value;\n\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {\n          expr\n        });\n        const endField = vgField(fieldDef2, {\n          expr\n        });\n        const {\n          format,\n          formatType\n        } = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, config);\n        toSkip[channel2] = true;\n      } else if (stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n        const {\n          format,\n          formatType\n        } = getFormatMixins(fieldDef);\n        value = formatSignalRef({\n          fieldOrDatumDef: fieldDef,\n          format,\n          formatType,\n          expr,\n          config,\n          normalizeStack: true\n        }).signal;\n      }\n    }\n\n    value !== null && value !== void 0 ? value : value = textRef(fieldDef, config, expr).signal;\n    tuples.push({\n      channel,\n      key,\n      value\n    });\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  const out = {};\n\n  for (const {\n    channel,\n    key,\n    value\n  } of tuples) {\n    if (!toSkip[channel] && !out[key]) {\n      out[key] = value;\n    }\n  }\n\n  return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config, {\n  reactiveGeom\n} = {}) {\n  const data = tooltipData(encoding, stack, config, {\n    reactiveGeom\n  });\n  const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n  return keyValues.length > 0 ? {\n    signal: `{${keyValues.join(', ')}}`\n  } : undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/tooltip.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model, opt = {}) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding.tooltip;\n    if (isArray(channelDef)) {\n        return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack, config, opt) };\n    }\n    else {\n        const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n        return wrapCondition(model, channelDef, 'tooltip', cDef => {\n            // use valueRef based on channelDef first\n            const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n            if (tooltipRefFromChannelDef) {\n                return tooltipRefFromChannelDef;\n            }\n            if (cDef === null) {\n                // Allow using encoding.tooltip = null to disable tooltip\n                return undefined;\n            }\n            let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n            if (markTooltip === true) {\n                markTooltip = { content: 'encoding' };\n            }\n            if (isString(markTooltip)) {\n                return { value: markTooltip };\n            }\n            else if (isObject(markTooltip)) {\n                // `tooltip` is `{fields: 'encodings' | 'fields'}`\n                if (isSignalRef(markTooltip)) {\n                    return markTooltip;\n                }\n                else if (markTooltip.content === 'encoding') {\n                    return tooltipRefForEncoding(encoding, stack, config, opt);\n                }\n                else {\n                    return { signal: datum };\n                }\n            }\n            return undefined;\n        });\n    }\n}\nexport function tooltipData(encoding, stack, config, { reactiveGeom } = {}) {\n    const toSkip = {};\n    const expr = reactiveGeom ? 'datum.datum' : 'datum';\n    const tuples = [];\n    function add(fDef, channel) {\n        const mainChannel = getMainRangeChannel(channel);\n        const fieldDef = isTypedFieldDef(fDef)\n            ? fDef\n            : Object.assign(Object.assign({}, fDef), { type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n             });\n        const title = fieldDef.title || defaultTitle(fieldDef, config);\n        const key = array(title).join(', ');\n        let value;\n        if (isXorY(channel)) {\n            const channel2 = channel === 'x' ? 'x2' : 'y2';\n            const fieldDef2 = getFieldDef(encoding[channel2]);\n            if (isBinned(fieldDef.bin) && fieldDef2) {\n                const startField = vgField(fieldDef, { expr });\n                const endField = vgField(fieldDef2, { expr });\n                const { format, formatType } = getFormatMixins(fieldDef);\n                value = binFormatExpression(startField, endField, format, formatType, config);\n                toSkip[channel2] = true;\n            }\n            else if (stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n                const { format, formatType } = getFormatMixins(fieldDef);\n                value = formatSignalRef({\n                    fieldOrDatumDef: fieldDef,\n                    format,\n                    formatType,\n                    expr,\n                    config,\n                    normalizeStack: true\n                }).signal;\n            }\n        }\n        value !== null && value !== void 0 ? value : (value = textRef(fieldDef, config, expr).signal);\n        tuples.push({ channel, key, value });\n    }\n    forEach(encoding, (channelDef, channel) => {\n        if (isFieldDef(channelDef)) {\n            add(channelDef, channel);\n        }\n        else if (hasConditionalFieldDef(channelDef)) {\n            add(channelDef.condition, channel);\n        }\n    });\n    const out = {};\n    for (const { channel, key, value } of tuples) {\n        if (!toSkip[channel] && !out[key]) {\n            out[key] = value;\n        }\n    }\n    return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config, { reactiveGeom } = {}) {\n    const data = tooltipData(encoding, stack, config, { reactiveGeom });\n    const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n    return keyValues.length > 0 ? { signal: `{${keyValues.join(', ')}}` } : undefined;\n}\n//# sourceMappingURL=tooltip.js.map"]},"metadata":{},"sourceType":"module"}