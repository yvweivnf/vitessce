{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { Buffer, TransformFeedback } from '@luma.gl/webgl';\nimport { assert } from '@luma.gl/webgl';\n\nvar BufferTransform = /*#__PURE__*/function () {\n  function BufferTransform(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, BufferTransform);\n\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null;\n    this.bindings = [];\n    this.resources = {};\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  _createClass(BufferTransform, [{\n    key: \"setupResources\",\n    value: function setupResources(opts) {\n      var _iterator = _createForOfIteratorHelper(this.bindings),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var binding = _step.value;\n\n          this._setupTransformFeedback(binding, opts);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"updateModelProps\",\n    value: function updateModelProps() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var varyings = this.varyings;\n\n      if (varyings.length > 0) {\n        props = Object.assign({}, props, {\n          varyings: varyings\n        });\n      }\n\n      return props;\n    }\n  }, {\n    key: \"getDrawOptions\",\n    value: function getDrawOptions() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var binding = this.bindings[this.currentIndex];\n      var sourceBuffers = binding.sourceBuffers,\n          transformFeedback = binding.transformFeedback;\n      var attributes = Object.assign({}, sourceBuffers, opts.attributes);\n      return {\n        attributes: attributes,\n        transformFeedback: transformFeedback\n      };\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      if (this.feedbackMap) {\n        this.currentIndex = this._getNextIndex();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._setupBuffers(opts);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(varyingName) {\n      var feedbackBuffers = this.bindings[this.currentIndex].feedbackBuffers;\n      var bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n\n      if (!bufferOrParams) {\n        return null;\n      }\n\n      return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var varyingName = options.varyingName;\n      var buffer = this.getBuffer(varyingName);\n\n      if (buffer) {\n        return buffer.getData();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var name in this.resources) {\n        this.resources[name].delete();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._setupBuffers(props);\n\n      this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n\n      if (this.varyings.length > 0) {\n        assert(isWebGL2(this.gl));\n      }\n    }\n  }, {\n    key: \"_getFeedbackBuffers\",\n    value: function _getFeedbackBuffers(props) {\n      var _props$sourceBuffers = props.sourceBuffers,\n          sourceBuffers = _props$sourceBuffers === void 0 ? {} : _props$sourceBuffers;\n      var feedbackBuffers = {};\n\n      if (this.bindings[this.currentIndex]) {\n        Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n      }\n\n      if (this.feedbackMap) {\n        for (var sourceName in this.feedbackMap) {\n          var feedbackName = this.feedbackMap[sourceName];\n\n          if (sourceName in sourceBuffers) {\n            feedbackBuffers[feedbackName] = sourceName;\n          }\n        }\n      }\n\n      Object.assign(feedbackBuffers, props.feedbackBuffers);\n\n      for (var bufferName in feedbackBuffers) {\n        var bufferOrRef = feedbackBuffers[bufferName];\n\n        if (typeof bufferOrRef === 'string') {\n          var sourceBuffer = sourceBuffers[bufferOrRef];\n          var byteLength = sourceBuffer.byteLength,\n              usage = sourceBuffer.usage,\n              accessor = sourceBuffer.accessor;\n          feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n            byteLength: byteLength,\n            usage: usage,\n            accessor: accessor\n          });\n        }\n      }\n\n      return feedbackBuffers;\n    }\n  }, {\n    key: \"_setupBuffers\",\n    value: function _setupBuffers() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _props$sourceBuffers2 = props.sourceBuffers,\n          sourceBuffers = _props$sourceBuffers2 === void 0 ? null : _props$sourceBuffers2;\n      Object.assign(this.feedbackMap, props.feedbackMap);\n\n      var feedbackBuffers = this._getFeedbackBuffers(props);\n\n      this._updateBindings({\n        sourceBuffers: sourceBuffers,\n        feedbackBuffers: feedbackBuffers\n      });\n    }\n  }, {\n    key: \"_setupTransformFeedback\",\n    value: function _setupTransformFeedback(binding, _ref) {\n      var model = _ref.model;\n      var program = model.program;\n      binding.transformFeedback = new TransformFeedback(this.gl, {\n        program: program,\n        buffers: binding.feedbackBuffers\n      });\n    }\n  }, {\n    key: \"_updateBindings\",\n    value: function _updateBindings(opts) {\n      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n\n      if (this.feedbackMap) {\n        var _this$_swapBuffers = this._swapBuffers(this.bindings[this.currentIndex]),\n            sourceBuffers = _this$_swapBuffers.sourceBuffers,\n            feedbackBuffers = _this$_swapBuffers.feedbackBuffers;\n\n        var nextIndex = this._getNextIndex();\n\n        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n          sourceBuffers: sourceBuffers,\n          feedbackBuffers: feedbackBuffers\n        });\n      }\n    }\n  }, {\n    key: \"_updateBinding\",\n    value: function _updateBinding(binding, opts) {\n      if (!binding) {\n        return {\n          sourceBuffers: Object.assign({}, opts.sourceBuffers),\n          feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n        };\n      }\n\n      Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n      Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n\n      if (binding.transformFeedback) {\n        binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n      }\n\n      return binding;\n    }\n  }, {\n    key: \"_swapBuffers\",\n    value: function _swapBuffers(opts) {\n      if (!this.feedbackMap) {\n        return null;\n      }\n\n      var sourceBuffers = Object.assign({}, opts.sourceBuffers);\n      var feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n\n      for (var srcName in this.feedbackMap) {\n        var dstName = this.feedbackMap[srcName];\n        sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n        feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n        assert(feedbackBuffers[dstName] instanceof Buffer);\n      }\n\n      return {\n        sourceBuffers: sourceBuffers,\n        feedbackBuffers: feedbackBuffers\n      };\n    }\n  }, {\n    key: \"_createNewBuffer\",\n    value: function _createNewBuffer(name, opts) {\n      var buffer = new Buffer(this.gl, opts);\n\n      if (this.resources[name]) {\n        this.resources[name].delete();\n      }\n\n      this.resources[name] = buffer;\n      return buffer;\n    }\n  }, {\n    key: \"_getNextIndex\",\n    value: function _getNextIndex() {\n      return (this.currentIndex + 1) % 2;\n    }\n  }]);\n\n  return BufferTransform;\n}();\n\nexport { BufferTransform as default };","map":{"version":3,"sources":["../../../src/transform/buffer-transform.js"],"names":["constructor","props","Object","varyings","opts","binding","transformFeedback","attributes","feedbackBuffers","bufferOrParams","varyingName","options","buffer","assert","isWebGL2","sourceBuffers","feedbackName","sourceName","bufferOrRef","sourceBuffer","accessor","byteLength","usage","model","program","buffers","nextIndex","dstName"],"mappings":";;;AAAA,SAAA,QAAA,QAAA,kBAAA;AACA,SAAA,MAAA,EAAA,iBAAA,QAAA,gBAAA;AACA,SAAA,MAAA,QAAA,gBAAA;;IAEe,e;AACbA,2BAAW,EAAXA,EAA4B;AAAA,QAAZC,KAAY,uEAAjB,EAAiB;;AAAA;;AAC1B,SAAA,EAAA,GAAA,EAAA;AACA,SAAA,YAAA,GAAA,CAAA;AACA,SAAA,WAAA,GAAA,EAAA;AACA,SAAA,QAAA,GAAA,IAAA;AACA,SAAA,QAAA,GAAA,EAAA;AAEA,SAAA,SAAA,GAAA,EAAA;;AAEA,SAAA,WAAA,CAAA,KAAA;;AACAC,IAAAA,MAAM,CAANA,IAAAA,CAAAA,IAAAA;AACD;;;;mCAEa,I,EAAO;AAAA,iDACG,KAAtB,QADmB;AAAA;;AAAA;AACnB,4DAAqC;AAAA,cAArC,OAAqC;;AACnC,eAAA,uBAAA,CAAA,OAAA,EAAA,IAAA;AACD;AAHkB;AAAA;AAAA;AAAA;AAAA;AAIpB;;;uCAE4B;AAAA,UAAZD,KAAY,uEAAb,EAAa;AAAA,UACpBE,QADoB,GAC3B,IAD2B,CACpBA,QADoB;;AAE3B,UAAIA,QAAQ,CAARA,MAAAA,GAAJ,CAAA,EAAyB;AACvBF,QAAAA,KAAK,GAAG,MAAM,CAAN,MAAA,CAAA,EAAA,EAAA,KAAA,EAAyB;AAACE,UAAAA,QAAAA,EAAAA;AAAD,SAAzB,CAARF;AACD;;AACD,aAAA,KAAA;AACD;;;qCAEyB;AAAA,UAAXG,IAAW,uEAAZ,EAAY;AACxB,UAAMC,OAAO,GAAG,KAAA,QAAA,CAAc,KAA9B,YAAgB,CAAhB;AADwB,UAElB,aAFkB,GAExB,OAFwB,CAElB,aAFkB;AAAA,UAEFC,iBAFE,GAExB,OAFwB,CAEFA,iBAFE;AAGxB,UAAMC,UAAU,GAAGL,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAAA,aAAAA,EAAiCE,IAAI,CAAxD,UAAmBF,CAAnB;AAEA,aAAO;AAACK,QAAAA,UAAD,EAACA,UAAD;AAAaD,QAAAA,iBAAAA,EAAAA;AAAb,OAAP;AACD;;;2BAEM;AACL,UAAI,KAAJ,WAAA,EAAsB;AACpB,aAAA,YAAA,GAAoB,KAApB,aAAoB,EAApB;AACA,eAAA,IAAA;AACD;;AACD,aAAA,KAAA;AACD;;;6BAGiB;AAAA,UAAXF,IAAW,uEAAZ,EAAY;;AAChB,WAAA,aAAA,CAAA,IAAA;AACD;;;8BAGQ,W,EAAc;AAAA,UACdI,eADc,GACK,KAAA,QAAA,CAAc,KAAxC,YAA0B,CADL,CACdA,eADc;AAErB,UAAMC,cAAc,GAAGC,WAAW,GAAGF,eAAe,CAAlB,WAAkB,CAAlB,GAAlC,IAAA;;AACA,UAAI,CAAJ,cAAA,EAAqB;AACnB,eAAA,IAAA;AACD;;AACD,aAAOC,cAAc,YAAdA,MAAAA,GAAAA,cAAAA,GAAoDA,cAAc,CAAzE,MAAA;AACD;;;8BAEqB;AAAA,UAAdE,OAAc,uEAAf,EAAe;AAAA,UACbD,WADa,GACpB,OADoB,CACbA,WADa;AAEpB,UAAME,MAAM,GAAG,KAAA,SAAA,CAAf,WAAe,CAAf;;AACA,UAAA,MAAA,EAAY;AACV,eAAOA,MAAM,CAAb,OAAOA,EAAP;AACD;;AACD,aAAA,IAAA;AACD;;;8BAGQ;AACP,WAAK,IAAL,IAAA,IAAmB,KAAnB,SAAA,EAAmC;AACjC,aAAA,SAAA,CAAA,IAAA,EAAA,MAAA;AACD;AACF;;;kCAIuB;AAAA,UAAZX,KAAY,uEAAb,EAAa;;AACtB,WAAA,aAAA,CAAA,KAAA;;AACA,WAAA,QAAA,GAAgBA,KAAK,CAALA,QAAAA,IAAkBC,MAAM,CAANA,IAAAA,CAAY,KAAA,QAAA,CAAc,KAAd,YAAA,EAA9C,eAAkCA,CAAlC;;AACA,UAAI,KAAA,QAAA,CAAA,MAAA,GAAJ,CAAA,EAA8B;AAE5BW,QAAAA,MAAM,CAACC,QAAQ,CAAC,KAAhBD,EAAe,CAAT,CAANA;AACD;AACF;;;wCAGkB,K,EAAQ;AAAA,iCACzB,KADyB,CAClBE,aADkB;AAAA,UAClBA,aADkB,qCACF,EADE;AAEzB,UAAMP,eAAe,GAArB,EAAA;;AACA,UAAI,KAAA,QAAA,CAAc,KAAlB,YAAI,CAAJ,EAAsC;AAGpCN,QAAAA,MAAM,CAANA,MAAAA,CAAAA,eAAAA,EAA+B,KAAA,QAAA,CAAc,KAAd,YAAA,EAA/BA,eAAAA;AACD;;AACD,UAAI,KAAJ,WAAA,EAAsB;AAEpB,aAAK,IAAL,UAAA,IAAyB,KAAzB,WAAA,EAA2C;AACzC,cAAMc,YAAY,GAAG,KAAA,WAAA,CAArB,UAAqB,CAArB;;AACA,cAAIC,UAAU,IAAd,aAAA,EAAiC;AAC/BT,YAAAA,eAAe,CAAfA,YAAe,CAAfA,GAAAA,UAAAA;AACD;AACF;AACF;;AACDN,MAAAA,MAAM,CAANA,MAAAA,CAAAA,eAAAA,EAA+BD,KAAK,CAApCC,eAAAA;;AACA,WAAK,IAAL,UAAA,IAAA,eAAA,EAA0C;AACxC,YAAMgB,WAAW,GAAGV,eAAe,CAAnC,UAAmC,CAAnC;;AACA,YAAI,OAAA,WAAA,KAAJ,QAAA,EAAqC;AAEnC,cAAMW,YAAY,GAAGJ,aAAa,CAAlC,WAAkC,CAAlC;AAFmC,cAG7B,UAH6B,GAGnC,YAHmC,CAG7B,UAH6B;AAAA,cAG7B,KAH6B,GAGnC,YAHmC,CAG7B,KAH6B;AAAA,cAGTK,QAHS,GAGnC,YAHmC,CAGTA,QAHS;AAInCZ,UAAAA,eAAe,CAAfA,UAAe,CAAfA,GAA8B,KAAA,gBAAA,CAAA,UAAA,EAAkC;AAC9Da,YAAAA,UAD8D,EAC9DA,UAD8D;AAE9DC,YAAAA,KAF8D,EAE9DA,KAF8D;AAG9DF,YAAAA,QAAAA,EAAAA;AAH8D,WAAlC,CAA9BZ;AAKD;AACF;;AAED,aAAA,eAAA;AACD;;;oCAEyB;AAAA,UAAZP,KAAY,uEAAb,EAAa;AAAA,kCACxB,KADwB,CACjBc,aADiB;AAAA,UACjBA,aADiB,sCACD,IADC;AAExBb,MAAAA,MAAM,CAANA,MAAAA,CAAc,KAAdA,WAAAA,EAAgCD,KAAK,CAArCC,WAAAA;;AACA,UAAMM,eAAe,GAAG,KAAA,mBAAA,CAAxB,KAAwB,CAAxB;;AACA,WAAA,eAAA,CAAqB;AAACO,QAAAA,aAAD,EAACA,aAAD;AAAgBP,QAAAA,eAAAA,EAAAA;AAAhB,OAArB;AACD;;;4CAEsB,O,QAAmB;AAAA,UAARe,KAAQ,QAARA,KAAQ;AAAA,UACjCC,OADiC,GACxC,KADwC,CACjCA,OADiC;AAExCnB,MAAAA,OAAO,CAAPA,iBAAAA,GAA4B,IAAA,iBAAA,CAAsB,KAAtB,EAAA,EAA+B;AACzDmB,QAAAA,OADyD,EACzDA,OADyD;AAEzDC,QAAAA,OAAO,EAAEpB,OAAO,CAACG;AAFwC,OAA/B,CAA5BH;AAID;;;oCAEc,I,EAAO;AACpB,WAAA,QAAA,CAAc,KAAd,YAAA,IAAmC,KAAA,cAAA,CAAoB,KAAA,QAAA,CAAc,KAAlC,YAAoB,CAApB,EAAnC,IAAmC,CAAnC;;AACA,UAAI,KAAJ,WAAA,EAAsB;AAAA,iCACqB,KAAA,YAAA,CAAkB,KAAA,QAAA,CAAc,KAAzE,YAA2D,CAAlB,CADrB;AAAA,YACd,aADc,sBACd,aADc;AAAA,YACEG,eADF,sBACEA,eADF;;AAEpB,YAAMkB,SAAS,GAAG,KAAlB,aAAkB,EAAlB;;AACA,aAAA,QAAA,CAAA,SAAA,IAA2B,KAAA,cAAA,CAAoB,KAAA,QAAA,CAApB,SAAoB,CAApB,EAA8C;AACvEX,UAAAA,aADuE,EACvEA,aADuE;AAEvEP,UAAAA,eAAAA,EAAAA;AAFuE,SAA9C,CAA3B;AAID;AACF;;;mCAEa,O,EAAA,I,EAAgB;AAC5B,UAAI,CAAJ,OAAA,EAAc;AACZ,eAAO;AACLO,UAAAA,aAAa,EAAEb,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkBE,IAAI,CADhC,aACUF,CADV;AAELM,UAAAA,eAAe,EAAEN,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkBE,IAAI,CAAtBF,eAAAA;AAFZ,SAAP;AAID;;AACDA,MAAAA,MAAM,CAANA,MAAAA,CAAcG,OAAO,CAArBH,aAAAA,EAAqCE,IAAI,CAAzCF,aAAAA;AACAA,MAAAA,MAAM,CAANA,MAAAA,CAAcG,OAAO,CAArBH,eAAAA,EAAuCE,IAAI,CAA3CF,eAAAA;;AACA,UAAIG,OAAO,CAAX,iBAAA,EAA+B;AAC7BA,QAAAA,OAAO,CAAPA,iBAAAA,CAAAA,UAAAA,CAAqCA,OAAO,CAA5CA,eAAAA;AACD;;AACD,aAAA,OAAA;AACD;;;iCAEW,I,EAAO;AACjB,UAAI,CAAC,KAAL,WAAA,EAAuB;AACrB,eAAA,IAAA;AACD;;AACD,UAAMU,aAAa,GAAGb,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkBE,IAAI,CAA5C,aAAsBF,CAAtB;AACA,UAAMM,eAAe,GAAGN,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkBE,IAAI,CAA9C,eAAwBF,CAAxB;;AACA,WAAK,IAAL,OAAA,IAAsB,KAAtB,WAAA,EAAwC;AACtC,YAAMyB,OAAO,GAAG,KAAA,WAAA,CAAhB,OAAgB,CAAhB;AACAZ,QAAAA,aAAa,CAAbA,OAAa,CAAbA,GAAyBX,IAAI,CAAJA,eAAAA,CAAzBW,OAAyBX,CAAzBW;AACAP,QAAAA,eAAe,CAAfA,OAAe,CAAfA,GAA2BJ,IAAI,CAAJA,aAAAA,CAA3BI,OAA2BJ,CAA3BI;AAGAK,QAAAA,MAAM,CAACL,eAAe,CAAfA,OAAe,CAAfA,YAAPK,MAAM,CAANA;AACD;;AACD,aAAO;AAACE,QAAAA,aAAD,EAACA,aAAD;AAAgBP,QAAAA,eAAAA,EAAAA;AAAhB,OAAP;AACD;;;qCAGe,I,EAAA,I,EAAa;AAC3B,UAAMI,MAAM,GAAG,IAAA,MAAA,CAAW,KAAX,EAAA,EAAf,IAAe,CAAf;;AACA,UAAI,KAAA,SAAA,CAAJ,IAAI,CAAJ,EAA0B;AACxB,aAAA,SAAA,CAAA,IAAA,EAAA,MAAA;AACD;;AACD,WAAA,SAAA,CAAA,IAAA,IAAA,MAAA;AACA,aAAA,MAAA;AACD;;;oCAEe;AACd,aAAO,CAAC,KAAA,YAAA,GAAD,CAAA,IAAP,CAAA;AACD;;;;;;SAjMY,e","sourcesContent":["import {isWebGL2} from '@luma.gl/gltools';\nimport {Buffer, TransformFeedback} from '@luma.gl/webgl';\nimport {assert} from '@luma.gl/webgl';\n\nexport default class BufferTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null; // varyings array\n    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps(props = {}) {\n    const {varyings} = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {varyings});\n    }\n    return props;\n  }\n\n  getDrawOptions(opts = {}) {\n    const binding = this.bindings[this.currentIndex];\n    const {sourceBuffers, transformFeedback} = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n\n    return {attributes, transformFeedback};\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupBuffers(opts);\n  }\n\n  // returns current feedbackBuffer of given name\n  getBuffer(varyingName) {\n    const {feedbackBuffers} = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData(options = {}) {\n    const {varyingName} = options;\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      // if writting to buffers make sure it is WebGL2\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  // auto create feedback buffers if requested\n  _getFeedbackBuffers(props) {\n    const {sourceBuffers = {}} = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      // this gurantees a partial feedback buffer set doesn't update\n      // previously set buffers during auto creation mode.\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string') {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers(props = {}) {\n    const {sourceBuffers = null} = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({sourceBuffers, feedbackBuffers});\n  }\n\n  _setupTransformFeedback(binding, {model}) {\n    const {program} = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n\n      // make sure the new destination buffer is a Buffer object\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {sourceBuffers, feedbackBuffers};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}