{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport class SpecMapper {\n  map(spec, params) {\n    if (isFacetSpec(spec)) {\n      return this.mapFacet(spec, params);\n    } else if (isRepeatSpec(spec)) {\n      return this.mapRepeat(spec, params);\n    } else if (isHConcatSpec(spec)) {\n      return this.mapHConcat(spec, params);\n    } else if (isVConcatSpec(spec)) {\n      return this.mapVConcat(spec, params);\n    } else if (isConcatSpec(spec)) {\n      return this.mapConcat(spec, params);\n    } else {\n      return this.mapLayerOrUnit(spec, params);\n    }\n  }\n\n  mapLayerOrUnit(spec, params) {\n    if (isLayerSpec(spec)) {\n      return this.mapLayer(spec, params);\n    } else if (isUnitSpec(spec)) {\n      return this.mapUnit(spec, params);\n    }\n\n    throw new Error(log.message.invalidSpec(spec));\n  }\n\n  mapLayer(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params))\n    });\n  }\n\n  mapHConcat(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      hconcat: spec.hconcat.map(subspec => this.map(subspec, params))\n    });\n  }\n\n  mapVConcat(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      vconcat: spec.vconcat.map(subspec => this.map(subspec, params))\n    });\n  }\n\n  mapConcat(spec, params) {\n    const {\n      concat\n    } = spec,\n          rest = __rest(spec, [\"concat\"]);\n\n    return Object.assign(Object.assign({}, rest), {\n      concat: concat.map(subspec => this.map(subspec, params))\n    });\n  }\n\n  mapFacet(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n      spec: this.map(spec.spec, params)\n    });\n  }\n\n  mapRepeat(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      // as any is required here since TS cannot infer that the output type satisfies the input type\n      spec: this.map(spec.spec, params)\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/spec/map.ts"],"names":[],"mappings":";;;;;;;;;;;AACA,OAAO,KAAK,GAAZ,MAAqB,QAArB;AAEA,SAIE,YAJF,EAKE,aALF,EAME,aANF,QAOO,UAPP;AAQA,SAA0B,WAA1B,QAA4C,SAA5C;AACA,SAA0B,WAA1B,QAA4C,SAA5C;AACA,SAAQ,YAAR,QAAuC,UAAvC;AACA,SAAyB,UAAzB,QAA8D,QAA9D;AAEA,OAAM,MAAgB,UAAhB,CAA0B;AAQvB,EAAA,GAAG,CAAC,IAAD,EAA+C,MAA/C,EAAwD;AAChE,QAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AACrB,aAAO,KAAK,QAAL,CAAc,IAAd,EAAoB,MAApB,CAAP;AACD,KAFD,MAEO,IAAI,YAAY,CAAC,IAAD,CAAhB,EAAwB;AAC7B,aAAO,KAAK,SAAL,CAAe,IAAf,EAAqB,MAArB,CAAP;AACD,KAFM,MAEA,IAAI,aAAa,CAAC,IAAD,CAAjB,EAAyB;AAC9B,aAAO,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CAAP;AACD,KAFM,MAEA,IAAI,aAAa,CAAC,IAAD,CAAjB,EAAyB;AAC9B,aAAO,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CAAP;AACD,KAFM,MAEA,IAAI,YAAY,CAAC,IAAD,CAAhB,EAAwB;AAC7B,aAAO,KAAK,SAAL,CAAe,IAAf,EAAqB,MAArB,CAAP;AACD,KAFM,MAEA;AACL,aAAO,KAAK,cAAL,CAAoB,IAApB,EAA0B,MAA1B,CAAP;AACD;AACF;;AAEM,EAAA,cAAc,CAAC,IAAD,EAAgB,MAAhB,EAAyB;AAC5C,QAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AACrB,aAAO,KAAK,QAAL,CAAc,IAAd,EAAoB,MAApB,CAAP;AACD,KAFD,MAEO,IAAI,UAAU,CAAC,IAAD,CAAd,EAAsB;AAC3B,aAAO,KAAK,OAAL,CAAa,IAAb,EAAmB,MAAnB,CAAP;AACD;;AACD,UAAM,IAAI,KAAJ,CAAU,GAAG,CAAC,OAAJ,CAAY,WAAZ,CAAwB,IAAxB,CAAV,CAAN;AACD;;AAIS,EAAA,QAAQ,CAAC,IAAD,EAAW,MAAX,EAAoB;AACpC,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,IADL,CAAA,EACS;AACP,MAAA,KAAK,EAAE,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,OAAO,IAAI,KAAK,cAAL,CAAoB,OAApB,EAA6B,MAA7B,CAA1B;AADA,KADT,CAAA;AAID;;AAES,EAAA,UAAU,CAClB,IADkB,EAElB,MAFkB,EAET;AAET,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,IADL,CAAA,EACS;AACP,MAAA,OAAO,EAAE,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAO,IAAI,KAAK,GAAL,CAAS,OAAT,EAAkB,MAAlB,CAA5B;AADF,KADT,CAAA;AAID;;AAES,EAAA,UAAU,CAClB,IADkB,EAElB,MAFkB,EAET;AAET,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,IADL,CAAA,EACS;AACP,MAAA,OAAO,EAAE,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAO,IAAI,KAAK,GAAL,CAAS,OAAT,EAAkB,MAAlB,CAA5B;AADF,KADT,CAAA;AAID;;AAES,EAAA,SAAS,CACjB,IADiB,EAEjB,MAFiB,EAER;AAET,UAAM;AAAC,MAAA;AAAD,QAAoB,IAA1B;AAAA,UAAkB,IAAI,GAAA,MAAA,CAAI,IAAJ,EAAhB,CAAA,QAAA,CAAgB,CAAtB;;AAEA,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,IADL,CAAA,EACS;AACP,MAAA,MAAM,EAAE,MAAM,CAAC,GAAP,CAAW,OAAO,IAAI,KAAK,GAAL,CAAS,OAAT,EAAkB,MAAlB,CAAtB;AADD,KADT,CAAA;AAID;;AAES,EAAA,QAAQ,CAAC,IAAD,EAAwC,MAAxC,EAAiD;AACjE,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAEM,IAFN,CAAA,EAEkB;AAChB;AACA,MAAA,IAAI,EAAE,KAAK,GAAL,CAAS,IAAI,CAAC,IAAd,EAAoB,MAApB;AAFU,KAFlB,CAAA;AAMD;;AAES,EAAA,SAAS,CAAC,IAAD,EAAmB,MAAnB,EAA4B;AAC7C,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,IADL,CAAA,EACS;AACP;AACA,MAAA,IAAI,EAAE,KAAK,GAAL,CAAS,IAAI,CAAC,IAAd,EAA2B,MAA3B;AAFC,KADT,CAAA;AAKD;;AAzF6B","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport class SpecMapper {\n    map(spec, params) {\n        if (isFacetSpec(spec)) {\n            return this.mapFacet(spec, params);\n        }\n        else if (isRepeatSpec(spec)) {\n            return this.mapRepeat(spec, params);\n        }\n        else if (isHConcatSpec(spec)) {\n            return this.mapHConcat(spec, params);\n        }\n        else if (isVConcatSpec(spec)) {\n            return this.mapVConcat(spec, params);\n        }\n        else if (isConcatSpec(spec)) {\n            return this.mapConcat(spec, params);\n        }\n        else {\n            return this.mapLayerOrUnit(spec, params);\n        }\n    }\n    mapLayerOrUnit(spec, params) {\n        if (isLayerSpec(spec)) {\n            return this.mapLayer(spec, params);\n        }\n        else if (isUnitSpec(spec)) {\n            return this.mapUnit(spec, params);\n        }\n        throw new Error(log.message.invalidSpec(spec));\n    }\n    mapLayer(spec, params) {\n        return Object.assign(Object.assign({}, spec), { layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params)) });\n    }\n    mapHConcat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { hconcat: spec.hconcat.map(subspec => this.map(subspec, params)) });\n    }\n    mapVConcat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { vconcat: spec.vconcat.map(subspec => this.map(subspec, params)) });\n    }\n    mapConcat(spec, params) {\n        const { concat } = spec, rest = __rest(spec, [\"concat\"]);\n        return Object.assign(Object.assign({}, rest), { concat: concat.map(subspec => this.map(subspec, params)) });\n    }\n    mapFacet(spec, params) {\n        return Object.assign(Object.assign({}, spec), { \n            // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n            spec: this.map(spec.spec, params) });\n    }\n    mapRepeat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { \n            // as any is required here since TS cannot infer that the output type satisfies the input type\n            spec: this.map(spec.spec, params) });\n    }\n}\n//# sourceMappingURL=map.js.map"]},"metadata":{},"sourceType":"module"}