{"ast":null,"code":"\"use strict\"; // Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\n\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,]/g;\n\nmodule.exports = function stringify(passedObj, options) {\n  var indent, maxLength, replacer;\n  options = options || {};\n  indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);\n  maxLength = indent === \"\" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;\n  replacer = options.replacer;\n  return function _stringify(obj, currentIndent, reserved) {\n    // prettier-ignore\n    var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;\n\n    if (obj && typeof obj.toJSON === \"function\") {\n      obj = obj.toJSON();\n    }\n\n    string = JSON.stringify(obj, replacer);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      prettified = string.replace(stringOrChar, function (match, stringLiteral) {\n        return stringLiteral || match + \" \";\n      });\n\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n\n    if (typeof obj === \"object\" && obj !== null) {\n      nextIndent = currentIndent + indent;\n      items = [];\n      index = 0;\n\n      if (Array.isArray(obj)) {\n        start = \"[\";\n        end = \"]\";\n        length = obj.length;\n\n        for (; index < length; index++) {\n          items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || \"null\");\n        }\n      } else {\n        start = \"{\";\n        end = \"}\";\n        keys = Object.keys(obj);\n        length = keys.length;\n\n        for (; index < length; index++) {\n          key = keys[index];\n          keyPart = JSON.stringify(key) + \": \";\n          value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));\n\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n\n      if (items.length > 0) {\n        return [start, indent + items.join(\",\\n\" + nextIndent), end].join(\"\\n\" + currentIndent);\n      }\n    }\n\n    return string;\n  }(passedObj, \"\", 0);\n};","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/json-stringify-pretty-compact/index.js"],"names":["stringOrChar","module","exports","stringify","passedObj","options","indent","maxLength","replacer","JSON","undefined","slice","Infinity","_stringify","obj","currentIndent","reserved","end","index","items","key","keyPart","keys","length","nextIndent","prettified","start","string","value","toJSON","replace","match","stringLiteral","parse","Array","isArray","push","Object","join"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,]/g;\n\nmodule.exports = function stringify(passedObj, options) {\n  var indent, maxLength, replacer;\n\n  options = options || {};\n  indent = JSON.stringify(\n    [1],\n    undefined,\n    options.indent === undefined ? 2 : options.indent\n  ).slice(2, -3);\n  maxLength =\n    indent === \"\"\n      ? Infinity\n      : options.maxLength === undefined\n      ? 80\n      : options.maxLength;\n  replacer = options.replacer;\n\n  return (function _stringify(obj, currentIndent, reserved) {\n    // prettier-ignore\n    var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;\n\n    if (obj && typeof obj.toJSON === \"function\") {\n      obj = obj.toJSON();\n    }\n\n    string = JSON.stringify(obj, replacer);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      prettified = string.replace(\n        stringOrChar,\n        function (match, stringLiteral) {\n          return stringLiteral || match + \" \";\n        }\n      );\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n\n    if (typeof obj === \"object\" && obj !== null) {\n      nextIndent = currentIndent + indent;\n      items = [];\n      index = 0;\n\n      if (Array.isArray(obj)) {\n        start = \"[\";\n        end = \"]\";\n        length = obj.length;\n        for (; index < length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) ||\n              \"null\"\n          );\n        }\n      } else {\n        start = \"{\";\n        end = \"}\";\n        keys = Object.keys(obj);\n        length = keys.length;\n        for (; index < length; index++) {\n          key = keys[index];\n          keyPart = JSON.stringify(key) + \": \";\n          value = _stringify(\n            obj[key],\n            nextIndent,\n            keyPart.length + (index === length - 1 ? 0 : 1)\n          );\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n\n      if (items.length > 0) {\n        return [start, indent + items.join(\",\\n\" + nextIndent), end].join(\n          \"\\n\" + currentIndent\n        );\n      }\n    }\n\n    return string;\n  })(passedObj, \"\", 0);\n};\n"]},"metadata":{},"sourceType":"script"}