{"ast":null,"code":"import _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\n\nexport var DataFlowNode = /*#__PURE__*/function () {\n  function DataFlowNode(parent, debugName) {\n    _classCallCheck(this, DataFlowNode);\n\n    this.debugName = debugName;\n    this._children = [];\n    this._parent = null;\n\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n\n\n  _createClass(DataFlowNode, [{\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Cannot clone node');\n    }\n  }, {\n    key: \"numChildren\",\n    value: function numChildren() {\n      return this._children.length;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child, loc) {\n      // do not add the same child twice\n      if (this._children.includes(child)) {\n        log.warn(log.message.ADD_SAME_CHILD_TWICE);\n        return;\n      }\n\n      if (loc !== undefined) {\n        this._children.splice(loc, 0, child);\n      } else {\n        this._children.push(child);\n      }\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(oldChild) {\n      var loc = this._children.indexOf(oldChild);\n\n      this._children.splice(loc, 1);\n\n      return loc;\n    }\n    /**\n     * Remove node from the dataflow.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var loc = this._parent.removeChild(this);\n\n      var _iterator = _createForOfIteratorHelper(this._children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          // do not use the set method because we want to insert at a particular location\n          child._parent = this._parent;\n\n          this._parent.addChild(child, loc++);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Insert another node as a parent of this node.\n     */\n\n  }, {\n    key: \"insertAsParentOf\",\n    value: function insertAsParentOf(other) {\n      var parent = other.parent;\n      parent.removeChild(this);\n      this.parent = parent;\n      other.parent = this;\n    }\n  }, {\n    key: \"swapWithParent\",\n    value: function swapWithParent() {\n      var parent = this._parent;\n      var newParent = parent.parent; // reconnect the children\n\n      var _iterator2 = _createForOfIteratorHelper(this._children),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          child.parent = parent;\n        } // remove old links\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._children = []; // equivalent to removing every child link one by one\n\n      parent.removeChild(this);\n      parent.parent.removeChild(parent); // swap two nodes\n\n      this.parent = newParent;\n      parent.parent = this;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n    /**\n     * Set the parent of the node and also add this node to the parent's children.\n     */\n    ,\n    set: function set(parent) {\n      this._parent = parent;\n\n      if (parent) {\n        parent.addChild(this);\n      }\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children;\n    }\n  }]);\n\n  return DataFlowNode;\n}();\nexport var OutputNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(OutputNode, _DataFlowNode);\n\n  var _super = _createSuper(OutputNode);\n\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  function OutputNode(parent, source, type, refCounts) {\n    var _this;\n\n    _classCallCheck(this, OutputNode);\n\n    _this = _super.call(this, parent, source);\n    _this.type = type;\n    _this.refCounts = refCounts;\n    _this._source = _this._name = source;\n\n    if (_this.refCounts && !(_this._name in _this.refCounts)) {\n      _this.refCounts[_this._name] = 0;\n    }\n\n    return _this;\n  }\n\n  _createClass(OutputNode, [{\n    key: \"clone\",\n    value: function clone() {\n      var cloneObj = new this.constructor();\n      cloneObj.debugName = \"clone_\".concat(this.debugName);\n      cloneObj._source = this._source;\n      cloneObj._name = \"clone_\".concat(this._name);\n      cloneObj.type = this.type;\n      cloneObj.refCounts = this.refCounts;\n      cloneObj.refCounts[cloneObj._name] = 0;\n      return cloneObj;\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set();\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      if (this._hash === undefined) {\n        this._hash = \"Output \".concat(uniqueId());\n      }\n\n      return this._hash;\n    }\n    /**\n     * Request the datasource name and increase the ref counter.\n     *\n     * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n     * It is crucial to request the name from an output node to mark it as a required node.\n     * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n     *\n     * In the assemble phase, this will return the correct name.\n     */\n\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      this.refCounts[this._name]++;\n      return this._source;\n    }\n  }, {\n    key: \"isRequired\",\n    value: function isRequired() {\n      return !!this.refCounts[this._name];\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(source) {\n      this._source = source;\n    }\n  }]);\n\n  return OutputNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/dataflow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\nexport class DataFlowNode {\n    constructor(parent, debugName) {\n        this.debugName = debugName;\n        this._children = [];\n        this._parent = null;\n        if (parent) {\n            this.parent = parent;\n        }\n    }\n    /**\n     * Clone this node with a deep copy but don't clone links to children or parents.\n     */\n    clone() {\n        throw new Error('Cannot clone node');\n    }\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Set the parent of the node and also add this node to the parent's children.\n     */\n    set parent(parent) {\n        this._parent = parent;\n        if (parent) {\n            parent.addChild(this);\n        }\n    }\n    get children() {\n        return this._children;\n    }\n    numChildren() {\n        return this._children.length;\n    }\n    addChild(child, loc) {\n        // do not add the same child twice\n        if (this._children.includes(child)) {\n            log.warn(log.message.ADD_SAME_CHILD_TWICE);\n            return;\n        }\n        if (loc !== undefined) {\n            this._children.splice(loc, 0, child);\n        }\n        else {\n            this._children.push(child);\n        }\n    }\n    removeChild(oldChild) {\n        const loc = this._children.indexOf(oldChild);\n        this._children.splice(loc, 1);\n        return loc;\n    }\n    /**\n     * Remove node from the dataflow.\n     */\n    remove() {\n        let loc = this._parent.removeChild(this);\n        for (const child of this._children) {\n            // do not use the set method because we want to insert at a particular location\n            child._parent = this._parent;\n            this._parent.addChild(child, loc++);\n        }\n    }\n    /**\n     * Insert another node as a parent of this node.\n     */\n    insertAsParentOf(other) {\n        const parent = other.parent;\n        parent.removeChild(this);\n        this.parent = parent;\n        other.parent = this;\n    }\n    swapWithParent() {\n        const parent = this._parent;\n        const newParent = parent.parent;\n        // reconnect the children\n        for (const child of this._children) {\n            child.parent = parent;\n        }\n        // remove old links\n        this._children = []; // equivalent to removing every child link one by one\n        parent.removeChild(this);\n        parent.parent.removeChild(parent);\n        // swap two nodes\n        this.parent = newParent;\n        parent.parent = this;\n    }\n}\nexport class OutputNode extends DataFlowNode {\n    /**\n     * @param source The name of the source. Will change in assemble.\n     * @param type The type of the output node.\n     * @param refCounts A global ref counter map.\n     */\n    constructor(parent, source, type, refCounts) {\n        super(parent, source);\n        this.type = type;\n        this.refCounts = refCounts;\n        this._source = this._name = source;\n        if (this.refCounts && !(this._name in this.refCounts)) {\n            this.refCounts[this._name] = 0;\n        }\n    }\n    clone() {\n        const cloneObj = new this.constructor();\n        cloneObj.debugName = `clone_${this.debugName}`;\n        cloneObj._source = this._source;\n        cloneObj._name = `clone_${this._name}`;\n        cloneObj.type = this.type;\n        cloneObj.refCounts = this.refCounts;\n        cloneObj.refCounts[cloneObj._name] = 0;\n        return cloneObj;\n    }\n    dependentFields() {\n        return new Set();\n    }\n    producedFields() {\n        return new Set();\n    }\n    hash() {\n        if (this._hash === undefined) {\n            this._hash = `Output ${uniqueId()}`;\n        }\n        return this._hash;\n    }\n    /**\n     * Request the datasource name and increase the ref counter.\n     *\n     * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n     * It is crucial to request the name from an output node to mark it as a required node.\n     * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n     *\n     * In the assemble phase, this will return the correct name.\n     */\n    getSource() {\n        this.refCounts[this._name]++;\n        return this._source;\n    }\n    isRequired() {\n        return !!this.refCounts[this._name];\n    }\n    setSource(source) {\n        this._source = source;\n    }\n}\n//# sourceMappingURL=dataflow.js.map"]},"metadata":{},"sourceType":"module"}