{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n\n  return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  var _a;\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const name = selCmpt.name;\n    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n\n    for (const c of selectionCompilers) {\n      if (!c.defined(selCmpt)) continue;\n      if (c.signals) signals = c.signals(model, selCmpt, signals);\n      if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n    }\n\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {\n          signal: selCmpt.name + TUPLE\n        },\n        update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: `isTuple(facet) ? facet : group(${name}).datum`\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  var _a;\n\n  let hasSelections = false;\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n      });\n    }\n\n    hasSelections = true;\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.topLevelSignals) {\n        signals = c.topLevelSignals(model, selCmpt, signals);\n      }\n    }\n  }\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  var _a;\n\n  const dataCopy = [...data];\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const init = {\n      name: selCmpt.name + STORE\n    };\n\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(proj => {\n        const {\n          signals\n        } = proj,\n              rest = __rest(proj, [\"signals\"]);\n\n        return rest;\n      });\n      init.values = selCmpt.init.map(i => ({\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields,\n        values: assembleInit(i, false)\n      }));\n    }\n\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  }\n\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  var _a;\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.marks) {\n        marks = c.marks(model, selCmpt, marks);\n      }\n    }\n  }\n\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n  const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n  return {\n    signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent\n  };\n}\n\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n    if (isArray(init)) {\n        const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n        return isExpr ? `[${assembled.join(', ')}]` : assembled;\n    }\n    else if (isDateTime(init)) {\n        if (isExpr) {\n            return wrap(dateTimeToExpr(init));\n        }\n        else {\n            return wrap(dateTimeToTimestamp(init));\n        }\n    }\n    return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n    var _a;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const name = selCmpt.name;\n        let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n        for (const c of selectionCompilers) {\n            if (!c.defined(selCmpt))\n                continue;\n            if (c.signals)\n                signals = c.signals(model, selCmpt, signals);\n            if (c.modifyExpr)\n                modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n        }\n        signals.push({\n            name: name + MODIFY,\n            on: [\n                {\n                    events: { signal: selCmpt.name + TUPLE },\n                    update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n                }\n            ]\n        });\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n    if (model.component.selection && keys(model.component.selection).length) {\n        const name = stringValue(model.getName('cell'));\n        signals.unshift({\n            name: 'facet',\n            value: {},\n            on: [\n                {\n                    events: parseSelector('mousemove', 'scope'),\n                    update: `isTuple(facet) ? facet : group(${name}).datum`\n                }\n            ]\n        });\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n    var _a;\n    let hasSelections = false;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const name = selCmpt.name;\n        const store = stringValue(name + STORE);\n        const hasSg = signals.filter(s => s.name === name);\n        if (hasSg.length === 0) {\n            const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n            const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n            signals.push({\n                name: selCmpt.name,\n                update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n            });\n        }\n        hasSelections = true;\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.topLevelSignals) {\n                signals = c.topLevelSignals(model, selCmpt, signals);\n            }\n        }\n    }\n    if (hasSelections) {\n        const hasUnit = signals.filter(s => s.name === 'unit');\n        if (hasUnit.length === 0) {\n            signals.unshift({\n                name: 'unit',\n                value: {},\n                on: [{ events: 'mousemove', update: 'isTuple(group()) ? group() : unit' }]\n            });\n        }\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n    var _a;\n    const dataCopy = [...data];\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const init = { name: selCmpt.name + STORE };\n        if (selCmpt.init) {\n            const fields = selCmpt.project.items.map(proj => {\n                const { signals } = proj, rest = __rest(proj, [\"signals\"]);\n                return rest;\n            });\n            init.values = selCmpt.init.map(i => ({\n                unit: unitName(model, { escape: false }),\n                fields,\n                values: assembleInit(i, false)\n            }));\n        }\n        const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n        if (!contains.length) {\n            dataCopy.push(init);\n        }\n    }\n    return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n    var _a;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.marks) {\n                marks = c.marks(model, selCmpt, marks);\n            }\n        }\n    }\n    return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n    for (const child of model.children) {\n        if (isUnitModel(child)) {\n            marks = assembleUnitSelectionMarks(child, marks);\n        }\n    }\n    return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n    const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n    return {\n        signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1]\n            ? `isValid(${parsedExtent}) && reverse(${parsedExtent})`\n            : parsedExtent\n    };\n}\nfunction cleanupEmptyOnArray(signals) {\n    return signals.map(s => {\n        if (s.on && !s.on.length)\n            delete s.on;\n        return s;\n    });\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}