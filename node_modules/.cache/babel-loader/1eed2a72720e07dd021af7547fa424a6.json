{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nvar ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n  var _ref = ignore.color === 'include' ? color(model) : {},\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? undefined : _ref$fill,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === void 0 ? undefined : _ref$stroke;\n\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), nonPosition('strokeDash', model)), zindex(model)), tooltip(model)), text(model, 'href')), aria(model));\n} // TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\n\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  var config = model.config,\n      mark = model.mark,\n      markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    var test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n\n    if (test) {\n      return _defineProperty({}, channel, [// prepend the invalid case\n      // TODO: support custom value\n      {\n        test: test,\n        value: null\n      }].concat(_toConsumableArray(array(valueRef))));\n    }\n  }\n\n  return valueRef ? _defineProperty({}, channel, valueRef) : {};\n}\n\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce(function (m, prop) {\n    if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = signalOrValueRef(mark[prop]);\n    }\n\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(model, _ref4) {\n  var _ref4$invalid = _ref4.invalid,\n      invalid = _ref4$invalid === void 0 ? false : _ref4$invalid,\n      channels = _ref4.channels;\n  var filterIndex = channels.reduce(function (aggregator, channel) {\n    var scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      var scaleType = scaleComponent.get('type');\n      var field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  var fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    var op = invalid ? '||' : '&&';\n    return fields.map(function (field) {\n      return fieldInvalidPredicate(field, invalid);\n    }).join(\" \".concat(op, \" \"));\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nconst ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n    const { fill = undefined, stroke = undefined } = ignore.color === 'include' ? color(model) : {};\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), nonPosition('strokeDash', model)), zindex(model)), tooltip(model)), text(model, 'href')), aria(model));\n}\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n    const { config, mark, markDef } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n        // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n        // For path marks, we will use \"defined\" property and skip these values instead.\n        const test = allFieldsInvalidPredicate(model, { invalid: true, channels: SCALE_CHANNELS });\n        if (test) {\n            return {\n                [channel]: [\n                    // prepend the invalid case\n                    // TODO: support custom value\n                    { test, value: null },\n                    ...array(valueRef)\n                ]\n            };\n        }\n    }\n    return valueRef ? { [channel]: valueRef } : {};\n}\nfunction markDefProperties(mark, ignore) {\n    return VG_MARK_CONFIGS.reduce((m, prop) => {\n        if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n            m[prop] = signalOrValueRef(mark[prop]);\n        }\n        return m;\n    }, {});\n}\nfunction allFieldsInvalidPredicate(model, { invalid = false, channels }) {\n    const filterIndex = channels.reduce((aggregator, channel) => {\n        const scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n            const scaleType = scaleComponent.get('type');\n            const field = model.vgField(channel, { expr: 'datum' });\n            // While discrete domain scales can handle invalid values, continuous scales can't.\n            if (field && hasContinuousDomain(scaleType)) {\n                aggregator[field] = true;\n            }\n        }\n        return aggregator;\n    }, {});\n    const fields = keys(filterIndex);\n    if (fields.length > 0) {\n        const op = invalid ? '||' : '&&';\n        return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n    }\n    return undefined;\n}\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}