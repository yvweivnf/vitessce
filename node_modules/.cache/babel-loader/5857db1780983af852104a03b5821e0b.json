{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getImageSize } from '@loaders.gl/images';\nimport { generateUrl } from './generate-url';\nimport { deepLoad, shallowLoad } from './deep-load';\nexport async function loadImageTexture(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, ImageLoader.parse, options);\n}\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = options && options.image && options.image.mipLevels || 0;\n  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls = [];\n\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, { ...urlOptions,\n      lod: 0\n    });\n    const image = await shallowLoad(url, ImageLoader.parse, options);\n    const {\n      width,\n      height\n    } = getImageSize(image);\n    mipLevels = getMipLevels({\n      width,\n      height\n    });\n    urls.push(url);\n  }\n\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, { ...urlOptions,\n      lod: mipLevel\n    });\n    urls.push(url);\n  }\n\n  return urls;\n}\n\nexport function getMipLevels(size) {\n  return 1 + Math.floor(Math.log2(Math.max(size.width, size.height)));\n}","map":{"version":3,"sources":["../../../../src/lib/texture-api/load-image.ts"],"names":["options","imageUrls","getImageUrls","deepLoad","ImageLoader","urlOptions","mipLevels","getMipmappedImageUrls","generateUrl","urls","url","lod","image","shallowLoad","height","getImageSize","getMipLevels","assert","mipLevel","Math","size"],"mappings":"AAAA,SAAA,MAAA,QAAA,0BAAA;AACA,SAAA,WAAA,EAAA,YAAA,QAAA,oBAAA;AAEA,SAAA,WAAA,QAAA,gBAAA;AACA,SAAA,QAAA,EAAA,WAAA,QAAA,aAAA;AAEA,OAAO,eAAA,gBAAA,CAAA,MAAA,EAAyDA,OAAO,GAAhE,EAAA,EAAqF;AAC1F,QAAMC,SAAS,GAAG,MAAMC,YAAY,CAAA,MAAA,EAApC,OAAoC,CAApC;AACA,SAAO,MAAMC,QAAQ,CAAA,SAAA,EAAYC,WAAW,CAAvB,KAAA,EAArB,OAAqB,CAArB;AACD;AAED,OAAO,eAAA,YAAA,CAAA,MAAA,EAAA,OAAA,EAGLC,UAAsB,GAHjB,EAAA,EAIS;AACd,QAAMC,SAAS,GAAIN,OAAO,IAAIA,OAAO,CAAlBA,KAAAA,IAA4BA,OAAO,CAAPA,KAAAA,CAA7B,SAACA,IAAnB,CAAA;AACA,SAAOM,SAAS,KAATA,CAAAA,GACH,MAAMC,qBAAqB,CAAA,MAAA,EAAA,SAAA,EAAA,OAAA,EADxBD,UACwB,CADxBA,GAEHE,WAAW,CAAA,MAAA,EAAA,OAAA,EAFf,UAEe,CAFf;AAGD;;AAED,eAAA,qBAAA,CAAA,MAAA,EAAA,SAAA,EAAA,OAAA,EAAA,UAAA,EAKqB;AACnB,QAAMC,IAAc,GAApB,EAAA;;AAGA,MAAIH,SAAS,KAAb,MAAA,EAA0B;AACxB,UAAMI,GAAG,GAAGF,WAAW,CAAA,MAAA,EAAA,OAAA,EAAkB,EAAC,GAAD,UAAA;AAAgBG,MAAAA,GAAG,EAAE;AAArB,KAAlB,CAAvB;AACA,UAAMC,KAAK,GAAG,MAAMC,WAAW,CAAA,GAAA,EAAMT,WAAW,CAAjB,KAAA,EAA/B,OAA+B,CAA/B;AAEA,UAAM;AAAA,MAAA,KAAA;AAAQU,MAAAA;AAAR,QAAkBC,YAAY,CAApC,KAAoC,CAApC;AACAT,IAAAA,SAAS,GAAGU,YAAY,CAAC;AAAA,MAAA,KAAA;AAAQF,MAAAA;AAAR,KAAD,CAAxBR;AAGAG,IAAAA,IAAI,CAAJA,IAAAA,CAAAA,GAAAA;AACD;;AAGDQ,EAAAA,MAAM,CAACX,SAAS,GAAhBW,CAAM,CAANA;;AAEA,OAAK,IAAIC,QAAQ,GAAGT,IAAI,CAAxB,MAAA,EAAiCS,QAAQ,GAAzC,SAAA,EAAuD,EAAvD,QAAA,EAAmE;AACjE,UAAMR,GAAG,GAAGF,WAAW,CAAA,MAAA,EAAA,OAAA,EAAkB,EAAC,GAAD,UAAA;AAAgBG,MAAAA,GAAG,EAAEO;AAArB,KAAlB,CAAvB;AACAT,IAAAA,IAAI,CAAJA,IAAAA,CAAAA,GAAAA;AACD;;AAED,SAAA,IAAA;AACD;;AAGD,OAAO,SAAA,YAAA,CAAA,IAAA,EAAqE;AAC1E,SAAO,IAAIU,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,IAAAA,CAAUA,IAAI,CAAJA,GAAAA,CAASC,IAAI,CAAbD,KAAAA,EAAqBC,IAAI,CAAzD,MAAgCD,CAAVA,CAAXA,CAAX;AACD","sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport {ImageLoader, getImageSize} from '@loaders.gl/images';\nimport type {GetUrl, UrlOptions} from './texture-api-types';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImageTexture(getUrl: string | GetUrl, options = {}): Promise<any> {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, ImageLoader.parse, options);\n}\n\nexport async function getImageUrls(\n  getUrl: string | GetUrl,\n  options: any,\n  urlOptions: UrlOptions = {}\n): Promise<any> {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(\n  getUrl: string | GetUrl,\n  mipLevels: number | 'auto',\n  options: any,\n  urlOptions: UrlOptions\n): Promise<string[]> {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, ImageLoader.parse, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels(size: {width: number; height: number}): number {\n  return 1 + Math.floor(Math.log2(Math.max(size.width, size.height)));\n}\n"]},"metadata":{},"sourceType":"module"}