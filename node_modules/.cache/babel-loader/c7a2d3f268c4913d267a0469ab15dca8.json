{"ast":null,"code":"/* eslint-disable no-plusplus */\n\n/* eslint-disable camelcase */\nimport difference from 'lodash/difference';\nimport cloneDeep from 'lodash/cloneDeep';\nimport packageJson from '../../package.json';\nimport { getNextScope } from '../utils';\nimport { AUTO_INDEPENDENT_COORDINATION_TYPES } from './state/coordination';\nimport { getViewTypes } from './component-registry';\nimport { getComponentCoordinationTypes, getDefaultCoordinationValues, getCoordinationTypes, getFileTypes, getConvenienceFileTypes } from './plugins';\nimport { SCHEMA_HANDLERS } from './view-config-versions';\n/**\n * Get a list of all unique scope names for a\n * particular coordination type, which exist in\n * a particular view config.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @returns {string[]} Array of existing coordination scope names.\n */\n\nexport function getExistingScopesForCoordinationType(config, coordinationType) {\n  var _config$coordinationS;\n\n  const spaceScopes = Object.keys((config === null || config === void 0 ? void 0 : (_config$coordinationS = config.coordinationSpace) === null || _config$coordinationS === void 0 ? void 0 : _config$coordinationS[coordinationType]) || {});\n  const componentScopes = config.layout.map(c => {\n    var _c$coordinationScopes;\n\n    return (_c$coordinationScopes = c.coordinationScopes) === null || _c$coordinationScopes === void 0 ? void 0 : _c$coordinationScopes[coordinationType];\n  });\n  return Array.from(new Set([...spaceScopes, ...componentScopes]));\n}\n/**\n * Give each component the same scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */\n\nfunction coordinateComponentsTogether(config, coordinationType, scopeValue) {\n  var _config$coordinationS2;\n\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const scopeName = getNextScope(getExistingScopesForCoordinationType(config, coordinationType));\n  const newConfig = { ...config,\n    coordinationSpace: { ...config.coordinationSpace,\n      [coordinationType]: { ...(config === null || config === void 0 ? void 0 : (_config$coordinationS2 = config.coordinationSpace) === null || _config$coordinationS2 === void 0 ? void 0 : _config$coordinationS2[coordinationType]),\n        // Add the new scope name and value to the coordination space.\n        [scopeName]: scopeValue\n      }\n    },\n    layout: config.layout.map(component => {\n      var _component$coordinati;\n\n      return { ...component,\n        coordinationScopes: { ...component.coordinationScopes,\n          // Only set the coordination scope if this component uses this coordination type,\n          // and the component is missing a coordination scope for this coordination type.\n          ...(componentCoordinationTypes[component.component].includes(coordinationType) && !((_component$coordinati = component.coordinationScopes) === null || _component$coordinati === void 0 ? void 0 : _component$coordinati[coordinationType]) ? {\n            // Only set the new scope name if the scope name\n            // for this component and coordination type is currently undefined.\n            [coordinationType]: scopeName\n          } : {})\n        }\n      };\n    })\n  };\n  return newConfig;\n}\n/**\n * Give each component a different scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */\n\n\nfunction coordinateComponentsIndependent(config, coordinationType, scopeValue) {\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const newConfig = { ...config,\n    layout: [...config.layout]\n  };\n  const newScopes = {};\n  newConfig.layout.forEach((component, i) => {\n    var _component$coordinati2;\n\n    // Only set the coordination scope if this component uses this coordination type,\n    // and the component is missing a coordination scope for this coordination type.\n    if (componentCoordinationTypes[component.component].includes(coordinationType) && !((_component$coordinati2 = component.coordinationScopes) === null || _component$coordinati2 === void 0 ? void 0 : _component$coordinati2[coordinationType])) {\n      const scopeName = getNextScope([...getExistingScopesForCoordinationType(config, coordinationType), ...Object.keys(newScopes)]);\n      newScopes[scopeName] = scopeValue;\n      newConfig.layout[i] = { ...component,\n        coordinationScopes: { ...component.coordinationScopes,\n          [coordinationType]: scopeName\n        }\n      };\n    }\n  });\n  newConfig.coordinationSpace = { ...newConfig.coordinationSpace,\n    [coordinationType]: { ...newConfig.coordinationSpace[coordinationType],\n      // Add the new scope name and value to the coordination space.\n      ...newScopes\n    }\n  };\n  return newConfig;\n}\n\nfunction initializeAuto(config) {\n  let newConfig = config;\n  const {\n    layout,\n    datasets\n  } = newConfig;\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const defaultCoordinationValues = getDefaultCoordinationValues();\n  const coordinationTypes = getCoordinationTypes(); // For each coordination type, check whether it requires initialization.\n\n  coordinationTypes.forEach(coordinationType => {\n    // A coordination type requires coordination if at least one component is missing\n    // a (coordination type, coordination scope) tuple.\n    // Components may only use a subset of all coordination types.\n    const requiresCoordination = !layout.every(c => {\n      var _c$coordinationScopes2;\n\n      return !componentCoordinationTypes[c.component].includes(coordinationType) || ((_c$coordinationScopes2 = c.coordinationScopes) === null || _c$coordinationScopes2 === void 0 ? void 0 : _c$coordinationScopes2[coordinationType]);\n    });\n\n    if (requiresCoordination) {\n      // Note that the default value may be undefined.\n      let defaultValue = defaultCoordinationValues[coordinationType]; // Check whether this is the special 'dataset' coordination type.\n\n      if (coordinationType === 'dataset' && datasets.length >= 1) {\n        // Use the first dataset ID as the default\n        // if there is at least one dataset.\n        defaultValue = datasets[0].uid;\n      } // Use the list of \"independent\" coordination types\n      // to determine whether a particular coordination type\n      // should be initialized to\n      // a unique scope for every component (\"independent\")\n      // vs. the same scope for every component (\"together\").\n\n\n      if (AUTO_INDEPENDENT_COORDINATION_TYPES.includes(coordinationType)) {\n        newConfig = coordinateComponentsIndependent(newConfig, coordinationType, defaultValue);\n      } else {\n        newConfig = coordinateComponentsTogether(newConfig, coordinationType, defaultValue);\n      }\n    }\n  });\n  return newConfig;\n}\n\nexport function checkTypes(config) {\n  // Add a log message when there are additionalProperties in the coordination space that\n  // do not appear in the view config JSON schema,\n  // with a note that this indicates either a mistake or custom coordination type usage.\n  const coordinationTypesInConfig = Object.keys(config.coordinationSpace || {});\n  const allCoordinationTypes = getCoordinationTypes();\n  const unknownCoordinationTypes = difference(coordinationTypesInConfig, allCoordinationTypes);\n\n  if (unknownCoordinationTypes.length > 0) {\n    return [false, `The following coordination types are not recognized: [${unknownCoordinationTypes}].\\nIf these are plugin coordination types, ensure that they have been properly registered.`];\n  } // Add a log message when there are views in the layout that are neither\n  // core views nor registered plugin views.\n\n\n  const viewTypesInConfig = config.layout.map(c => c.component);\n  const allViewTypes = getViewTypes();\n  const unknownViewTypes = difference(viewTypesInConfig, allViewTypes);\n\n  if (unknownViewTypes.length > 0) {\n    return [false, `The following view types are not recognized: [${unknownViewTypes}].\\nIf these are plugin view types, ensure that they have been properly registered.`];\n  } // Add a log message when there are file definitions with neither\n  // core nor registered plugin file types.\n\n\n  const fileTypesInConfig = config.datasets.flatMap(d => d.files.map(f => f.fileType));\n  const allFileTypes = getFileTypes();\n  const unknownFileTypes = difference(fileTypesInConfig, allFileTypes);\n\n  if (unknownFileTypes.length > 0) {\n    return [false, `The following file types are not recognized: [${unknownFileTypes}].\\nIf these are plugin file types, ensure that they have been properly registered.`];\n  }\n\n  return [true, 'All view types, coordination types, and file types that appear in the view config are recognized.'];\n}\n/**\n * Assign unique ids for view definitions where\n * they are missing a value for the uid property\n * in layout[].uid.\n * @param {object} config The view config\n * @returns The updated view config.\n */\n\nfunction assignViewUids(config) {\n  const {\n    layout\n  } = config;\n  const usedIds = layout.map(view => view.uid);\n  layout.forEach((view, i) => {\n    // Assign uids for views where they are not present.\n    if (!view.uid) {\n      const nextUid = getNextScope(usedIds);\n      layout[i].uid = nextUid;\n      usedIds.push(nextUid);\n    }\n  });\n  return { ...config,\n    layout\n  };\n}\n/**\n * Expand convenience file definitions. Each convenience file\n * definition expansion function takes in one file definition and\n * returns an array of file definitions. Not performed recursively.\n * @param {object} config The view config containing collapsed\n * convenience file types.\n * @returns The view config containing expanded minimal file types.\n */\n\n\nfunction expandConvenienceFileDefs(config) {\n  const convenienceFileTypes = getConvenienceFileTypes();\n  const {\n    datasets: currDatasets\n  } = config;\n  const datasets = cloneDeep(currDatasets);\n  currDatasets.forEach((dataset, i) => {\n    const {\n      files = []\n    } = dataset;\n    let newFiles = [];\n    files.forEach(fileDef => {\n      const {\n        fileType\n      } = fileDef;\n      const expansionFunc = convenienceFileTypes[fileType];\n\n      if (expansionFunc && typeof expansionFunc === 'function') {\n        // This was a convenience file type, so expand it.\n        const expandedFileDefs = expansionFunc(fileDef);\n        newFiles = newFiles.concat(expandedFileDefs);\n      } else {\n        // This was not a convenience file type,\n        // so keep it in the files array as-is.\n        newFiles.push(fileDef);\n      }\n    });\n    datasets[i].files = newFiles;\n  });\n  return { ...config,\n    datasets\n  };\n}\n/**\n * Initialize the view config:\n * - Fill in missing coordination objects with default values.\n * - Fill in missing component coordination scope mappings.\n *   based on the `initStrategy` specified in the view config.\n * - Fill in missing view uid values.\n * - Expand convenience file types.\n * Should be \"stable\": if run on the same view config twice, the return value the second\n * time should be identical to the return value the first time.\n * @param {object} config The view config prop.\n * @returns The initialized view config.\n */\n\n\nexport function initialize(config) {\n  let newConfig = cloneDeep(config);\n\n  if (newConfig.initStrategy === 'auto') {\n    newConfig = initializeAuto(config);\n  }\n\n  newConfig = expandConvenienceFileDefs(newConfig);\n  return assignViewUids(newConfig);\n}\nexport function upgradeAndValidate(oldConfig) {\n  // oldConfig object must have a `version` property.\n  let nextConfig = oldConfig;\n  let fromVersion;\n  let upgradeFunction;\n  let validateFunction;\n\n  do {\n    fromVersion = nextConfig.version;\n\n    if (!Object.keys(SCHEMA_HANDLERS).includes(fromVersion)) {\n      return [{\n        title: 'Config validation failed',\n        preformatted: 'Unknown config version.'\n      }, false];\n    }\n\n    [validateFunction, upgradeFunction] = SCHEMA_HANDLERS[fromVersion]; // Validate under the legacy schema before upgrading.\n\n    const validLegacy = validateFunction(nextConfig);\n\n    if (!validLegacy) {\n      const failureReason = JSON.stringify(validateFunction.errors, null, 2);\n      return [{\n        title: 'Config validation failed',\n        preformatted: failureReason\n      }, false];\n    }\n\n    if (upgradeFunction) {\n      nextConfig = upgradeFunction(nextConfig);\n    }\n  } while (upgradeFunction); // NOTE: Remove when a view config viewer/editor is available in UI.\n\n\n  console.groupCollapsed(`ðŸš„ Vitessce (${packageJson.version}) view configuration`);\n  console.info(`data:,${JSON.stringify(nextConfig)}`);\n  console.info(JSON.stringify(nextConfig, null, 2));\n  console.groupEnd();\n  return [nextConfig, true];\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/app/view-config-utils.js"],"names":["difference","cloneDeep","packageJson","getNextScope","AUTO_INDEPENDENT_COORDINATION_TYPES","getViewTypes","getComponentCoordinationTypes","getDefaultCoordinationValues","getCoordinationTypes","getFileTypes","getConvenienceFileTypes","SCHEMA_HANDLERS","getExistingScopesForCoordinationType","config","coordinationType","spaceScopes","Object","keys","coordinationSpace","componentScopes","layout","map","c","coordinationScopes","Array","from","Set","coordinateComponentsTogether","scopeValue","componentCoordinationTypes","scopeName","newConfig","component","includes","coordinateComponentsIndependent","newScopes","forEach","i","initializeAuto","datasets","defaultCoordinationValues","coordinationTypes","requiresCoordination","every","defaultValue","length","uid","checkTypes","coordinationTypesInConfig","allCoordinationTypes","unknownCoordinationTypes","viewTypesInConfig","allViewTypes","unknownViewTypes","fileTypesInConfig","flatMap","d","files","f","fileType","allFileTypes","unknownFileTypes","assignViewUids","usedIds","view","nextUid","push","expandConvenienceFileDefs","convenienceFileTypes","currDatasets","dataset","newFiles","fileDef","expansionFunc","expandedFileDefs","concat","initialize","initStrategy","upgradeAndValidate","oldConfig","nextConfig","fromVersion","upgradeFunction","validateFunction","version","title","preformatted","validLegacy","failureReason","JSON","stringify","errors","console","groupCollapsed","info","groupEnd"],"mappings":"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","sourcesContent":["/* eslint-disable no-plusplus */\n/* eslint-disable camelcase */\nimport difference from 'lodash/difference';\nimport cloneDeep from 'lodash/cloneDeep';\nimport packageJson from '../../package.json';\nimport { getNextScope } from '../utils';\nimport {\n  AUTO_INDEPENDENT_COORDINATION_TYPES,\n} from './state/coordination';\nimport { getViewTypes } from './component-registry';\nimport {\n  getComponentCoordinationTypes,\n  getDefaultCoordinationValues,\n  getCoordinationTypes,\n  getFileTypes,\n  getConvenienceFileTypes,\n} from './plugins';\nimport { SCHEMA_HANDLERS } from './view-config-versions';\n\n/**\n * Get a list of all unique scope names for a\n * particular coordination type, which exist in\n * a particular view config.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @returns {string[]} Array of existing coordination scope names.\n */\nexport function getExistingScopesForCoordinationType(config, coordinationType) {\n  const spaceScopes = Object.keys(config?.coordinationSpace?.[coordinationType] || {});\n  const componentScopes = config.layout.map(c => c.coordinationScopes?.[coordinationType]);\n  return Array.from(new Set([...spaceScopes, ...componentScopes]));\n}\n\n/**\n * Give each component the same scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */\nfunction coordinateComponentsTogether(config, coordinationType, scopeValue) {\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const scopeName = getNextScope(getExistingScopesForCoordinationType(config, coordinationType));\n  const newConfig = {\n    ...config,\n    coordinationSpace: {\n      ...config.coordinationSpace,\n      [coordinationType]: {\n        ...config?.coordinationSpace?.[coordinationType],\n        // Add the new scope name and value to the coordination space.\n        [scopeName]: scopeValue,\n      },\n    },\n    layout: config.layout.map(component => ({\n      ...component,\n      coordinationScopes: {\n        ...component.coordinationScopes,\n        // Only set the coordination scope if this component uses this coordination type,\n        // and the component is missing a coordination scope for this coordination type.\n        ...((\n          componentCoordinationTypes[component.component].includes(coordinationType)\n          && !component.coordinationScopes?.[coordinationType]\n        ) ? {\n          // Only set the new scope name if the scope name\n          // for this component and coordination type is currently undefined.\n            [coordinationType]: scopeName,\n          } : {}),\n      },\n    })),\n  };\n  return newConfig;\n}\n\n/**\n * Give each component a different scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */\nfunction coordinateComponentsIndependent(config, coordinationType, scopeValue) {\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const newConfig = {\n    ...config,\n    layout: [...config.layout],\n  };\n  const newScopes = {};\n  newConfig.layout.forEach((component, i) => {\n    // Only set the coordination scope if this component uses this coordination type,\n    // and the component is missing a coordination scope for this coordination type.\n    if (componentCoordinationTypes[component.component].includes(coordinationType)\n      && !component.coordinationScopes?.[coordinationType]\n    ) {\n      const scopeName = getNextScope([\n        ...getExistingScopesForCoordinationType(config, coordinationType),\n        ...Object.keys(newScopes),\n      ]);\n      newScopes[scopeName] = scopeValue;\n      newConfig.layout[i] = {\n        ...component,\n        coordinationScopes: {\n          ...component.coordinationScopes,\n          [coordinationType]: scopeName,\n        },\n      };\n    }\n  });\n  newConfig.coordinationSpace = {\n    ...newConfig.coordinationSpace,\n    [coordinationType]: {\n      ...newConfig.coordinationSpace[coordinationType],\n      // Add the new scope name and value to the coordination space.\n      ...newScopes,\n    },\n  };\n  return newConfig;\n}\n\nfunction initializeAuto(config) {\n  let newConfig = config;\n  const { layout, datasets } = newConfig;\n\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const defaultCoordinationValues = getDefaultCoordinationValues();\n  const coordinationTypes = getCoordinationTypes();\n\n  // For each coordination type, check whether it requires initialization.\n  coordinationTypes.forEach((coordinationType) => {\n    // A coordination type requires coordination if at least one component is missing\n    // a (coordination type, coordination scope) tuple.\n    // Components may only use a subset of all coordination types.\n    const requiresCoordination = !layout\n      .every(c => (\n        (!componentCoordinationTypes[c.component].includes(coordinationType))\n                || c.coordinationScopes?.[coordinationType]\n      ));\n    if (requiresCoordination) {\n      // Note that the default value may be undefined.\n      let defaultValue = defaultCoordinationValues[coordinationType];\n      // Check whether this is the special 'dataset' coordination type.\n      if (coordinationType === 'dataset' && datasets.length >= 1) {\n        // Use the first dataset ID as the default\n        // if there is at least one dataset.\n        defaultValue = datasets[0].uid;\n      }\n      // Use the list of \"independent\" coordination types\n      // to determine whether a particular coordination type\n      // should be initialized to\n      // a unique scope for every component (\"independent\")\n      // vs. the same scope for every component (\"together\").\n      if (AUTO_INDEPENDENT_COORDINATION_TYPES.includes(coordinationType)) {\n        newConfig = coordinateComponentsIndependent(newConfig, coordinationType, defaultValue);\n      } else {\n        newConfig = coordinateComponentsTogether(newConfig, coordinationType, defaultValue);\n      }\n    }\n  });\n\n  return newConfig;\n}\n\nexport function checkTypes(config) {\n  // Add a log message when there are additionalProperties in the coordination space that\n  // do not appear in the view config JSON schema,\n  // with a note that this indicates either a mistake or custom coordination type usage.\n  const coordinationTypesInConfig = Object.keys(config.coordinationSpace || {});\n  const allCoordinationTypes = getCoordinationTypes();\n  const unknownCoordinationTypes = difference(coordinationTypesInConfig, allCoordinationTypes);\n  if (unknownCoordinationTypes.length > 0) {\n    return [false, `The following coordination types are not recognized: [${unknownCoordinationTypes}].\\nIf these are plugin coordination types, ensure that they have been properly registered.`];\n  }\n  // Add a log message when there are views in the layout that are neither\n  // core views nor registered plugin views.\n  const viewTypesInConfig = config.layout.map(c => c.component);\n  const allViewTypes = getViewTypes();\n  const unknownViewTypes = difference(viewTypesInConfig, allViewTypes);\n  if (unknownViewTypes.length > 0) {\n    return [false, `The following view types are not recognized: [${unknownViewTypes}].\\nIf these are plugin view types, ensure that they have been properly registered.`];\n  }\n  // Add a log message when there are file definitions with neither\n  // core nor registered plugin file types.\n  const fileTypesInConfig = config.datasets.flatMap(d => d.files.map(f => f.fileType));\n  const allFileTypes = getFileTypes();\n  const unknownFileTypes = difference(fileTypesInConfig, allFileTypes);\n  if (unknownFileTypes.length > 0) {\n    return [false, `The following file types are not recognized: [${unknownFileTypes}].\\nIf these are plugin file types, ensure that they have been properly registered.`];\n  }\n  return [true, 'All view types, coordination types, and file types that appear in the view config are recognized.'];\n}\n\n/**\n * Assign unique ids for view definitions where\n * they are missing a value for the uid property\n * in layout[].uid.\n * @param {object} config The view config\n * @returns The updated view config.\n */\nfunction assignViewUids(config) {\n  const { layout } = config;\n  const usedIds = layout.map(view => view.uid);\n  layout.forEach((view, i) => {\n    // Assign uids for views where they are not present.\n    if (!view.uid) {\n      const nextUid = getNextScope(usedIds);\n      layout[i].uid = nextUid;\n      usedIds.push(nextUid);\n    }\n  });\n  return {\n    ...config,\n    layout,\n  };\n}\n\n/**\n * Expand convenience file definitions. Each convenience file\n * definition expansion function takes in one file definition and\n * returns an array of file definitions. Not performed recursively.\n * @param {object} config The view config containing collapsed\n * convenience file types.\n * @returns The view config containing expanded minimal file types.\n */\nfunction expandConvenienceFileDefs(config) {\n  const convenienceFileTypes = getConvenienceFileTypes();\n  const { datasets: currDatasets } = config;\n  const datasets = cloneDeep(currDatasets);\n  currDatasets.forEach((dataset, i) => {\n    const { files = [] } = dataset;\n    let newFiles = [];\n    files.forEach((fileDef) => {\n      const { fileType } = fileDef;\n      const expansionFunc = convenienceFileTypes[fileType];\n      if (expansionFunc && typeof expansionFunc === 'function') {\n        // This was a convenience file type, so expand it.\n        const expandedFileDefs = expansionFunc(fileDef);\n        newFiles = newFiles.concat(expandedFileDefs);\n      } else {\n        // This was not a convenience file type,\n        // so keep it in the files array as-is.\n        newFiles.push(fileDef);\n      }\n    });\n    datasets[i].files = newFiles;\n  });\n  return {\n    ...config,\n    datasets,\n  };\n}\n\n/**\n * Initialize the view config:\n * - Fill in missing coordination objects with default values.\n * - Fill in missing component coordination scope mappings.\n *   based on the `initStrategy` specified in the view config.\n * - Fill in missing view uid values.\n * - Expand convenience file types.\n * Should be \"stable\": if run on the same view config twice, the return value the second\n * time should be identical to the return value the first time.\n * @param {object} config The view config prop.\n * @returns The initialized view config.\n */\nexport function initialize(config) {\n  let newConfig = cloneDeep(config);\n  if (newConfig.initStrategy === 'auto') {\n    newConfig = initializeAuto(config);\n  }\n  newConfig = expandConvenienceFileDefs(newConfig);\n  return assignViewUids(newConfig);\n}\n\nexport function upgradeAndValidate(oldConfig) {\n  // oldConfig object must have a `version` property.\n  let nextConfig = oldConfig;\n  let fromVersion;\n  let upgradeFunction; let\n    validateFunction;\n\n  do {\n    fromVersion = nextConfig.version;\n\n    if (!Object.keys(SCHEMA_HANDLERS).includes(fromVersion)) {\n      return [{\n        title: 'Config validation failed',\n        preformatted: 'Unknown config version.',\n      }, false];\n    }\n\n    [validateFunction, upgradeFunction] = SCHEMA_HANDLERS[fromVersion];\n\n    // Validate under the legacy schema before upgrading.\n    const validLegacy = validateFunction(nextConfig);\n    if (!validLegacy) {\n      const failureReason = JSON.stringify(validateFunction.errors, null, 2);\n      return [{\n        title: 'Config validation failed',\n        preformatted: failureReason,\n      }, false];\n    }\n\n    if (upgradeFunction) {\n      nextConfig = upgradeFunction(nextConfig);\n    }\n  } while (upgradeFunction);\n\n  // NOTE: Remove when a view config viewer/editor is available in UI.\n  console.groupCollapsed(`ðŸš„ Vitessce (${packageJson.version}) view configuration`);\n  console.info(`data:,${JSON.stringify(nextConfig)}`);\n  console.info(JSON.stringify(nextConfig, null, 2));\n  console.groupEnd();\n\n  return [nextConfig, true];\n}\n"]},"metadata":{},"sourceType":"module"}