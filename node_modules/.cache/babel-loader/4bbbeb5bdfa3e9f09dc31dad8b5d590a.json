{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport lightingShader from './lights.glsl';\nvar INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$color = _ref.color,\n      color = _ref$color === void 0 ? [0, 0, 0] : _ref$color,\n      _ref$intensity = _ref.intensity,\n      intensity = _ref$intensity === void 0 ? 1.0 : _ref$intensity;\n\n  return color.map(function (component) {\n    return component * intensity / 255.0;\n  });\n}\n\nfunction getLightSourceUniforms(_ref2) {\n  var ambientLight = _ref2.ambientLight,\n      _ref2$pointLights = _ref2.pointLights,\n      pointLights = _ref2$pointLights === void 0 ? [] : _ref2$pointLights,\n      _ref2$directionalLigh = _ref2.directionalLights,\n      directionalLights = _ref2$directionalLigh === void 0 ? [] : _ref2$directionalLigh;\n  var lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach(function (pointLight, index) {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach(function (directionalLight, index) {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    var _ref3 = opts.lightSources || {},\n        ambientLight = _ref3.ambientLight,\n        pointLights = _ref3.pointLights,\n        directionalLights = _ref3.directionalLights;\n\n    var hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight: ambientLight,\n      pointLights: pointLights,\n      directionalLights: directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    var lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    var _iterator = _createForOfIteratorHelper(opts.lights || []),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var light = _step.value;\n\n        switch (light.type) {\n          case 'ambient':\n            lightSources.ambientLight = light;\n            break;\n\n          case 'directional':\n            lightSources.directionalLights.push(light);\n            break;\n\n          case 'point':\n            lightSources.pointLights.push(light);\n            break;\n\n          default:\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return getUniforms({\n      lightSources: lightSources\n    });\n  }\n\n  return {};\n}\n\nexport var lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms: getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};","map":{"version":3,"sources":["../../../../src/modules/lights/lights.js"],"names":["INITIAL_MODULE_OPTIONS","lightSources","color","intensity","component","pointLights","directionalLights","lightSourceUniforms","convertColor","pointLight","directionalLight","opts","hasLights","ambientLight","lighting_uEnabled","getLightSourceUniforms","light","getUniforms","lights","name","vs","fs","defines","MAX_LIGHTS"],"mappings":"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","sourcesContent":["/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport lightingShader from './lights.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1,\n      0,\n      0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    // @ts-ignore\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/** @type {ShaderModule} */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n"]},"metadata":{},"sourceType":"module"}