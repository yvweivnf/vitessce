{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isNumber, isObject } from 'vega-util';\nimport { getMarkPropOrConfig } from '../compile/common';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isEmpty, omit } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport var BOXPLOT = 'boxplot';\nexport var BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'];\nexport var boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n  if (isNumber(extent)) {\n    return 'tukey';\n  } // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n\n\n  return extent;\n}\nexport function normalizeBoxPlot(spec, _ref) {\n  var config = _ref.config;\n\n  var _a, _b; // Need to initEncoding first so we can infer type\n\n\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n\n  var _spec = spec,\n      mark = _spec.mark,\n      _encoding = _spec.encoding,\n      params = _spec.params,\n      _p = _spec.projection,\n      outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n\n  var markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (params) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  var extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;\n  var sizeValue = getMarkPropOrConfig('size', markDef, // TODO: https://github.com/vega/vega-lite/issues/6245\n  config);\n  var boxPlotType = getBoxPlotType(extent);\n\n  var _boxParams = boxParams(spec, extent, config),\n      bins = _boxParams.bins,\n      timeUnits = _boxParams.timeUnits,\n      transform = _boxParams.transform,\n      continuousAxisChannelDef = _boxParams.continuousAxisChannelDef,\n      continuousAxis = _boxParams.continuousAxis,\n      groupby = _boxParams.groupby,\n      aggregate = _boxParams.aggregate,\n      encodingWithoutContinuousAxis = _boxParams.encodingWithoutContinuousAxis,\n      ticksOrient = _boxParams.ticksOrient,\n      boxOrient = _boxParams.boxOrient,\n      customTooltipWithoutAggregatedField = _boxParams.customTooltipWithoutAggregatedField;\n\n  var color = encodingWithoutContinuousAxis.color,\n      size = encodingWithoutContinuousAxis.size,\n      encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n\n  var makeBoxPlotPart = function makeBoxPlotPart(sharedEncoding) {\n    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n  };\n\n  var makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  var makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  var makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? {\n    size: size\n  } : {}));\n  var fiveSummaryTooltipEncoding = getCompositeMarkTooltip([{\n    fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_',\n    titlePrefix: 'Max'\n  }, {\n    fieldPrefix: 'upper_box_',\n    titlePrefix: 'Q3'\n  }, {\n    fieldPrefix: 'mid_box_',\n    titlePrefix: 'Median'\n  }, {\n    fieldPrefix: 'lower_box_',\n    titlePrefix: 'Q1'\n  }, {\n    fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_',\n    titlePrefix: 'Min'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis); // ## Whisker Layers\n\n  var endTick = {\n    type: 'tick',\n    color: 'black',\n    opacity: 1,\n    orient: ticksOrient,\n    invalid: null,\n    aria: false\n  };\n  var whiskerTooltipEncoding = boxPlotType === 'min-max' ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n  : // for tukey / k-IQR, just show upper/lower-whisker\n  getCompositeMarkTooltip([{\n    fieldPrefix: 'upper_whisker_',\n    titlePrefix: 'Upper Whisker'\n  }, {\n    fieldPrefix: 'lower_whisker_',\n    titlePrefix: 'Lower Whisker'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n  var whiskerLayers = [].concat(_toConsumableArray(makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null,\n      aria: false\n    },\n    positionPrefix: 'lower_whisker',\n    endPositionPrefix: 'lower_box',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null,\n      aria: false\n    },\n    positionPrefix: 'upper_box',\n    endPositionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'lower_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }))); // ## Box Layers\n  // TODO: support hiding certain mark parts\n\n  var boxLayers = [].concat(_toConsumableArray(boxPlotType !== 'tukey' ? whiskerLayers : []), _toConsumableArray(makeBoxPlotBox({\n    partName: 'box',\n    mark: Object.assign(Object.assign({\n      type: 'bar'\n    }, sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: boxOrient,\n      invalid: null,\n      ariaRoleDescription: 'box'\n    }),\n    positionPrefix: 'lower_box',\n    endPositionPrefix: 'upper_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotMidTick({\n    partName: 'median',\n    mark: Object.assign(Object.assign(Object.assign({\n      type: 'tick',\n      invalid: null\n    }, isObject(config.boxplot.median) && config.boxplot.median.color ? {\n      color: config.boxplot.median.color\n    } : {}), sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: ticksOrient,\n      aria: false\n    }),\n    positionPrefix: 'mid_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })));\n\n  if (boxPlotType === 'min-max') {\n    return Object.assign(Object.assign({}, outerSpec), {\n      transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform),\n      layer: boxLayers\n    });\n  } // Tukey Box Plot\n\n\n  var lowerBoxExpr = \"datum[\\\"lower_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n  var upperBoxExpr = \"datum[\\\"upper_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n  var iqrExpr = \"(\".concat(upperBoxExpr, \" - \").concat(lowerBoxExpr, \")\");\n  var lowerWhiskerExpr = \"\".concat(lowerBoxExpr, \" - \").concat(extent, \" * \").concat(iqrExpr);\n  var upperWhiskerExpr = \"\".concat(upperBoxExpr, \" + \").concat(extent, \" * \").concat(iqrExpr);\n  var fieldExpr = \"datum[\\\"\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n  var joinaggregateTransform = {\n    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n    groupby: groupby\n  };\n  var filteredWhiskerSpec = {\n    transform: [{\n      filter: \"(\".concat(lowerWhiskerExpr, \" <= \").concat(fieldExpr, \") && (\").concat(fieldExpr, \" <= \").concat(upperWhiskerExpr, \")\")\n    }, {\n      aggregate: [{\n        op: 'min',\n        field: continuousAxisChannelDef.field,\n        as: \"lower_whisker_\".concat(continuousAxisChannelDef.field)\n      }, {\n        op: 'max',\n        field: continuousAxisChannelDef.field,\n        as: \"upper_whisker_\".concat(continuousAxisChannelDef.field)\n      }, // preserve lower_box / upper_box\n      {\n        op: 'min',\n        field: \"lower_box_\".concat(continuousAxisChannelDef.field),\n        as: \"lower_box_\".concat(continuousAxisChannelDef.field)\n      }, {\n        op: 'max',\n        field: \"upper_box_\".concat(continuousAxisChannelDef.field),\n        as: \"upper_box_\".concat(continuousAxisChannelDef.field)\n      }].concat(_toConsumableArray(aggregate)),\n      groupby: groupby\n    }],\n    layer: whiskerLayers\n  };\n\n  var tooltip = encodingWithoutSizeColorAndContinuousAxis.tooltip,\n      encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n\n  var scale = continuousAxisChannelDef.scale,\n      axis = continuousAxisChannelDef.axis;\n  var title = getTitle(continuousAxisChannelDef);\n  var axisWithoutTitle = omit(axis, ['title']);\n  var outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n    transform: [{\n      filter: \"(\".concat(fieldExpr, \" < \").concat(lowerWhiskerExpr, \") || (\").concat(fieldExpr, \" > \").concat(upperWhiskerExpr, \")\")\n    }],\n    mark: 'point',\n    encoding: Object.assign(Object.assign(Object.assign(_defineProperty({}, continuousAxis, Object.assign(Object.assign(Object.assign({\n      field: continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type\n    }, title !== undefined ? {\n      title: title\n    } : {}), scale !== undefined ? {\n      scale: scale\n    } : {}), isEmpty(axisWithoutTitle) ? {} : {\n      axis: axisWithoutTitle\n    })), encodingWithoutSizeColorContinuousAxisAndTooltip), color ? {\n      color: color\n    } : {}), customTooltipWithoutAggregatedField ? {\n      tooltip: customTooltipWithoutAggregatedField\n    } : {})\n  })[0];\n  var filteredLayersMixins;\n  var filteredLayersMixinsTransforms = [].concat(_toConsumableArray(bins), _toConsumableArray(timeUnits), [joinaggregateTransform]);\n\n  if (outlierLayersMixins) {\n    filteredLayersMixins = {\n      transform: filteredLayersMixinsTransforms,\n      layer: [outlierLayersMixins, filteredWhiskerSpec]\n    };\n  } else {\n    var _filteredLayersMixins;\n\n    filteredLayersMixins = filteredWhiskerSpec;\n\n    (_filteredLayersMixins = filteredLayersMixins.transform).unshift.apply(_filteredLayersMixins, _toConsumableArray(filteredLayersMixinsTransforms));\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    layer: [filteredLayersMixins, {\n      // boxplot\n      transform: transform,\n      layer: boxLayers\n    }]\n  });\n}\n\nfunction boxParamsQuartiles(continousAxisField) {\n  return [{\n    op: 'q1',\n    field: continousAxisField,\n    as: \"lower_box_\".concat(continousAxisField)\n  }, {\n    op: 'q3',\n    field: continousAxisField,\n    as: \"upper_box_\".concat(continousAxisField)\n  }];\n}\n\nfunction boxParams(spec, extent, config) {\n  var orient = compositeMarkOrient(spec, BOXPLOT);\n\n  var _compositeMarkContinu = compositeMarkContinuousAxis(spec, orient, BOXPLOT),\n      continuousAxisChannelDef = _compositeMarkContinu.continuousAxisChannelDef,\n      continuousAxis = _compositeMarkContinu.continuousAxis;\n\n  var continuousFieldName = continuousAxisChannelDef.field;\n  var boxPlotType = getBoxPlotType(extent);\n  var boxplotSpecificAggregate = [].concat(_toConsumableArray(boxParamsQuartiles(continuousFieldName)), [{\n    op: 'median',\n    field: continuousFieldName,\n    as: \"mid_box_\".concat(continuousFieldName)\n  }, {\n    op: 'min',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n  }, {\n    op: 'max',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n  }]);\n  var postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey' ? [] : [// This is for the  original k-IQR, which we do not expose\n  {\n    calculate: \"datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"lower_box_\").concat(continuousFieldName, \"\\\"]\"),\n    as: \"iqr_\".concat(continuousFieldName)\n  }, {\n    calculate: \"min(datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] + datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"max_\").concat(continuousFieldName, \"\\\"])\"),\n    as: \"upper_whisker_\".concat(continuousFieldName)\n  }, {\n    calculate: \"max(datum[\\\"lower_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"min_\").concat(continuousFieldName, \"\\\"])\"),\n    as: \"lower_whisker_\".concat(continuousFieldName)\n  }];\n\n  var _a = spec.encoding,\n      _b = continuousAxis,\n      oldContinuousAxisChannelDef = _a[_b],\n      oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n  var _filterTooltipWithAgg = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis),\n      customTooltipWithoutAggregatedField = _filterTooltipWithAgg.customTooltipWithoutAggregatedField,\n      filteredEncoding = _filterTooltipWithAgg.filteredEncoding;\n\n  var _extractTransformsFro = extractTransformsFromEncoding(filteredEncoding, config),\n      bins = _extractTransformsFro.bins,\n      timeUnits = _extractTransformsFro.timeUnits,\n      aggregate = _extractTransformsFro.aggregate,\n      groupby = _extractTransformsFro.groupby,\n      encodingWithoutContinuousAxis = _extractTransformsFro.encoding;\n\n  var ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n  var boxOrient = orient;\n  var transform = [].concat(_toConsumableArray(bins), _toConsumableArray(timeUnits), [{\n    aggregate: [].concat(_toConsumableArray(aggregate), _toConsumableArray(boxplotSpecificAggregate)),\n    groupby: groupby\n  }], postAggregateCalculates);\n  return {\n    bins: bins,\n    timeUnits: timeUnits,\n    transform: transform,\n    groupby: groupby,\n    aggregate: aggregate,\n    continuousAxisChannelDef: continuousAxisChannelDef,\n    continuousAxis: continuousAxis,\n    encodingWithoutContinuousAxis: encodingWithoutContinuousAxis,\n    ticksOrient: ticksOrient,\n    boxOrient: boxOrient,\n    customTooltipWithoutAggregatedField: customTooltipWithoutAggregatedField\n  };\n}","map":{"version":3,"sources":["../../../src/compositemark/boxplot.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isNumber, isObject } from 'vega-util';\nimport { getMarkPropOrConfig } from '../compile/common';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isEmpty, omit } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport const BOXPLOT = 'boxplot';\nexport const BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'];\nexport const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n    if (isNumber(extent)) {\n        return 'tukey';\n    }\n    // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n    return extent;\n}\nexport function normalizeBoxPlot(spec, { config }) {\n    var _a, _b;\n    // Need to initEncoding first so we can infer type\n    spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });\n    const { mark, encoding: _encoding, params, projection: _p } = spec, outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n    const markDef = isMarkDef(mark) ? mark : { type: mark };\n    // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n    if (params) {\n        log.warn(log.message.selectionNotSupported('boxplot'));\n    }\n    const extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;\n    const sizeValue = getMarkPropOrConfig('size', markDef, // TODO: https://github.com/vega/vega-lite/issues/6245\n    config);\n    const boxPlotType = getBoxPlotType(extent);\n    const { bins, timeUnits, transform, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent, config);\n    const { color, size } = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n    const makeBoxPlotPart = (sharedEncoding) => {\n        return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n    };\n    const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n    const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n    const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), (size ? { size } : {})));\n    const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([\n        { fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_', titlePrefix: 'Max' },\n        { fieldPrefix: 'upper_box_', titlePrefix: 'Q3' },\n        { fieldPrefix: 'mid_box_', titlePrefix: 'Median' },\n        { fieldPrefix: 'lower_box_', titlePrefix: 'Q1' },\n        { fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_', titlePrefix: 'Min' }\n    ], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n    // ## Whisker Layers\n    const endTick = { type: 'tick', color: 'black', opacity: 1, orient: ticksOrient, invalid: null, aria: false };\n    const whiskerTooltipEncoding = boxPlotType === 'min-max'\n        ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n        : // for tukey / k-IQR, just show upper/lower-whisker\n            getCompositeMarkTooltip([\n                { fieldPrefix: 'upper_whisker_', titlePrefix: 'Upper Whisker' },\n                { fieldPrefix: 'lower_whisker_', titlePrefix: 'Lower Whisker' }\n            ], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n    const whiskerLayers = [\n        ...makeBoxPlotExtent({\n            partName: 'rule',\n            mark: { type: 'rule', invalid: null, aria: false },\n            positionPrefix: 'lower_whisker',\n            endPositionPrefix: 'lower_box',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'rule',\n            mark: { type: 'rule', invalid: null, aria: false },\n            positionPrefix: 'upper_box',\n            endPositionPrefix: 'upper_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'ticks',\n            mark: endTick,\n            positionPrefix: 'lower_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'ticks',\n            mark: endTick,\n            positionPrefix: 'upper_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        })\n    ];\n    // ## Box Layers\n    // TODO: support hiding certain mark parts\n    const boxLayers = [\n        ...(boxPlotType !== 'tukey' ? whiskerLayers : []),\n        ...makeBoxPlotBox({\n            partName: 'box',\n            mark: Object.assign(Object.assign({ type: 'bar' }, (sizeValue ? { size: sizeValue } : {})), { orient: boxOrient, invalid: null, ariaRoleDescription: 'box' }),\n            positionPrefix: 'lower_box',\n            endPositionPrefix: 'upper_box',\n            extraEncoding: fiveSummaryTooltipEncoding\n        }),\n        ...makeBoxPlotMidTick({\n            partName: 'median',\n            mark: Object.assign(Object.assign(Object.assign({ type: 'tick', invalid: null }, (isObject(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {})), (sizeValue ? { size: sizeValue } : {})), { orient: ticksOrient, aria: false }),\n            positionPrefix: 'mid_box',\n            extraEncoding: fiveSummaryTooltipEncoding\n        })\n    ];\n    if (boxPlotType === 'min-max') {\n        return Object.assign(Object.assign({}, outerSpec), { transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform), layer: boxLayers });\n    }\n    // Tukey Box Plot\n    const lowerBoxExpr = `datum[\"lower_box_${continuousAxisChannelDef.field}\"]`;\n    const upperBoxExpr = `datum[\"upper_box_${continuousAxisChannelDef.field}\"]`;\n    const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n    const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n    const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n    const fieldExpr = `datum[\"${continuousAxisChannelDef.field}\"]`;\n    const joinaggregateTransform = {\n        joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n        groupby\n    };\n    const filteredWhiskerSpec = {\n        transform: [\n            {\n                filter: `(${lowerWhiskerExpr} <= ${fieldExpr}) && (${fieldExpr} <= ${upperWhiskerExpr})`\n            },\n            {\n                aggregate: [\n                    {\n                        op: 'min',\n                        field: continuousAxisChannelDef.field,\n                        as: `lower_whisker_${continuousAxisChannelDef.field}`\n                    },\n                    {\n                        op: 'max',\n                        field: continuousAxisChannelDef.field,\n                        as: `upper_whisker_${continuousAxisChannelDef.field}`\n                    },\n                    // preserve lower_box / upper_box\n                    {\n                        op: 'min',\n                        field: `lower_box_${continuousAxisChannelDef.field}`,\n                        as: `lower_box_${continuousAxisChannelDef.field}`\n                    },\n                    {\n                        op: 'max',\n                        field: `upper_box_${continuousAxisChannelDef.field}`,\n                        as: `upper_box_${continuousAxisChannelDef.field}`\n                    },\n                    ...aggregate\n                ],\n                groupby\n            }\n        ],\n        layer: whiskerLayers\n    };\n    const { tooltip } = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n    const { scale, axis } = continuousAxisChannelDef;\n    const title = getTitle(continuousAxisChannelDef);\n    const axisWithoutTitle = omit(axis, ['title']);\n    const outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n        transform: [{ filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})` }],\n        mark: 'point',\n        encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, (title !== undefined ? { title } : {})), (scale !== undefined ? { scale } : {})), (isEmpty(axisWithoutTitle) ? {} : { axis: axisWithoutTitle })) }, encodingWithoutSizeColorContinuousAxisAndTooltip), (color ? { color } : {})), (customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {}))\n    })[0];\n    let filteredLayersMixins;\n    const filteredLayersMixinsTransforms = [...bins, ...timeUnits, joinaggregateTransform];\n    if (outlierLayersMixins) {\n        filteredLayersMixins = {\n            transform: filteredLayersMixinsTransforms,\n            layer: [outlierLayersMixins, filteredWhiskerSpec]\n        };\n    }\n    else {\n        filteredLayersMixins = filteredWhiskerSpec;\n        filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);\n    }\n    return Object.assign(Object.assign({}, outerSpec), { layer: [\n            filteredLayersMixins,\n            {\n                // boxplot\n                transform,\n                layer: boxLayers\n            }\n        ] });\n}\nfunction boxParamsQuartiles(continousAxisField) {\n    return [\n        {\n            op: 'q1',\n            field: continousAxisField,\n            as: `lower_box_${continousAxisField}`\n        },\n        {\n            op: 'q3',\n            field: continousAxisField,\n            as: `upper_box_${continousAxisField}`\n        }\n    ];\n}\nfunction boxParams(spec, extent, config) {\n    const orient = compositeMarkOrient(spec, BOXPLOT);\n    const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n    const continuousFieldName = continuousAxisChannelDef.field;\n    const boxPlotType = getBoxPlotType(extent);\n    const boxplotSpecificAggregate = [\n        ...boxParamsQuartiles(continuousFieldName),\n        {\n            op: 'median',\n            field: continuousFieldName,\n            as: `mid_box_${continuousFieldName}`\n        },\n        {\n            op: 'min',\n            field: continuousFieldName,\n            as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n        },\n        {\n            op: 'max',\n            field: continuousFieldName,\n            as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n        }\n    ];\n    const postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey'\n        ? []\n        : [\n            // This is for the  original k-IQR, which we do not expose\n            {\n                calculate: `datum[\"upper_box_${continuousFieldName}\"] - datum[\"lower_box_${continuousFieldName}\"]`,\n                as: `iqr_${continuousFieldName}`\n            },\n            {\n                calculate: `min(datum[\"upper_box_${continuousFieldName}\"] + datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"max_${continuousFieldName}\"])`,\n                as: `upper_whisker_${continuousFieldName}`\n            },\n            {\n                calculate: `max(datum[\"lower_box_${continuousFieldName}\"] - datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"min_${continuousFieldName}\"])`,\n                as: `lower_whisker_${continuousFieldName}`\n            }\n        ];\n    const _a = spec.encoding, _b = continuousAxis, oldContinuousAxisChannelDef = _a[_b], oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n    const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);\n    const { bins, timeUnits, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);\n    const ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n    const boxOrient = orient;\n    const transform = [\n        ...bins,\n        ...timeUnits,\n        {\n            aggregate: [...aggregate, ...boxplotSpecificAggregate],\n            groupby\n        },\n        ...postAggregateCalculates\n    ];\n    return {\n        bins,\n        timeUnits,\n        transform,\n        groupby,\n        aggregate,\n        continuousAxisChannelDef,\n        continuousAxis,\n        encodingWithoutContinuousAxis,\n        ticksOrient,\n        boxOrient,\n        customTooltipWithoutAggregatedField\n    };\n}\n//# sourceMappingURL=boxplot.js.map"]},"metadata":{},"sourceType":"module"}