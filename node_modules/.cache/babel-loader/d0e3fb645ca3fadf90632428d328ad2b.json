{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueOrSignalRef } from '../common';\nimport { expression } from '../predicate';\n\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n\n  if (isArray(title) && !isText(title)) {\n    return title.map(function (fieldDef) {\n      return defaultTitle(fieldDef, config);\n    }).join(', ');\n  }\n\n  return title;\n}\n\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  var _d, _e;\n\n  (_a = axis.encode) !== null && _a !== void 0 ? _a : axis.encode = {};\n  (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};\n  (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {}; // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  axis.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleAxis(axisCmpt, kind, config) {\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    header: false\n  };\n\n  var _a, _b;\n\n  var _c = axisCmpt.combine(),\n      disable = _c.disable,\n      orient = _c.orient,\n      scale = _c.scale,\n      labelExpr = _c.labelExpr,\n      title = _c.title,\n      zindex = _c.zindex,\n      axis = __rest(_c, [\"disable\", \"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]);\n\n  if (disable) {\n    return undefined;\n  }\n\n  for (var prop in axis) {\n    var propType = AXIS_PROPERTY_TYPE[prop];\n    var propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      var condition = propValue.condition,\n          valueOrSignalRef = __rest(propValue, [\"condition\"]);\n\n      var conditions = array(condition);\n      var propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n\n      if (propIndex) {\n        var vgProp = propIndex.vgProp,\n            part = propIndex.part; // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n\n        var vgRef = [].concat(_toConsumableArray(conditions.map(function (c) {\n          var test = c.test,\n              valueOrSignalCRef = __rest(c, [\"test\"]);\n\n          return Object.assign({\n            test: expression(null, test)\n          }, valueOrSignalCRef);\n        })), [valueOrSignalRef]);\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        var signalRef = {\n          signal: conditions.map(function (c) {\n            var test = c.test,\n                valueOrSignalCRef = __rest(c, [\"test\"]);\n\n            return \"\".concat(expression(null, test), \" ? \").concat(exprFromValueOrSignalRef(valueOrSignalCRef), \" : \");\n          }).join('') + exprFromValueOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      var _propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n\n      if (_propIndex) {\n        var _vgProp = _propIndex.vgProp,\n            _part = _propIndex.part;\n        setAxisEncode(axis, _part, _vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n\n    } // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n\n\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      var grid = axis.encode.grid;\n      axis.encode = Object.assign({}, grid ? {\n        grid: grid\n      } : {});\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    return Object.assign(Object.assign({\n      scale: scale,\n      orient: orient\n    }, axis), {\n      domain: false,\n      labels: false,\n      aria: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n\n    });\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      var expr = labelExpr;\n\n      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      var _iterator = _createForOfIteratorHelper(AXIS_PARTS),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _part2 = _step.value;\n\n          if (!axisCmpt.hasAxisPart(_part2)) {\n            delete axis.encode[_part2];\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    var titleString = assembleTitle(title, config);\n    return Object.assign(Object.assign(Object.assign(Object.assign({\n      scale: scale,\n      orient: orient,\n      grid: false\n    }, titleString ? {\n      title: titleString\n    } : {}), axis), config.aria === false ? {\n      aria: false\n    } : {}), {\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n\n    });\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\n\nexport function assembleAxisSignals(model) {\n  var axes = model.component.axes;\n  var signals = [];\n\n  var _iterator2 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var channel = _step2.value;\n\n      if (axes[channel]) {\n        var _iterator3 = _createForOfIteratorHelper(axes[channel]),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var axis = _step3.value;\n\n            if (!axis.get('disable') && !axis.get('gridScale')) {\n              // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n              var sizeType = channel === 'x' ? 'height' : 'width';\n              var update = model.getSizeSignalRef(sizeType).signal;\n\n              if (sizeType !== update) {\n                signals.push({\n                  name: sizeType,\n                  update: update\n                });\n              }\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  var _axisComponents$x = axisComponents.x,\n      x = _axisComponents$x === void 0 ? [] : _axisComponents$x,\n      _axisComponents$y = axisComponents.y,\n      y = _axisComponents$y === void 0 ? [] : _axisComponents$y;\n  return [].concat(_toConsumableArray(x.map(function (a) {\n    return assembleAxis(a, 'grid', config);\n  })), _toConsumableArray(y.map(function (a) {\n    return assembleAxis(a, 'grid', config);\n  })), _toConsumableArray(x.map(function (a) {\n    return assembleAxis(a, 'main', config);\n  })), _toConsumableArray(y.map(function (a) {\n    return assembleAxis(a, 'main', config);\n  }))).filter(function (a) {\n    return a;\n  }); // filter undefined\n}","map":{"version":3,"sources":["../../../../src/compile/axis/assemble.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AACA,SAAQ,KAAR,EAAe,OAAf,QAA6B,WAA7B;AACA,SAAQ,UAAR,EAAoB,kBAApB,EAAwC,2BAAxC,EAAqE,sBAArE,QAAkG,YAAlG;AACA,SAAQ,uBAAR,QAAsC,eAAtC;AACA,SAAQ,YAAR,QAAyC,kBAAzC;AAEA,SAAQ,MAAR,QAAqB,aAArB;AACA,SAAQ,QAAR,EAAkB,eAAlB,EAAmC,OAAnC,EAA4C,UAA5C,QAA6D,YAA7D;AACA,SAAQ,WAAR,QAAuD,mBAAvD;AACA,SAAQ,wBAAR,QAAuC,WAAvC;AAEA,SAAQ,UAAR,QAAyB,cAAzB;;AAGA,SAAS,aAAT,CAAuB,KAAvB,EAAyE,MAAzE,EAAuF;AACrF,MAAI,CAAC,KAAL,EAAY;AACV,WAAO,SAAP;AACD;;AACD,MAAI,OAAO,CAAC,KAAD,CAAP,IAAkB,CAAC,MAAM,CAAC,KAAD,CAA7B,EAAsC;AACpC,WAAO,KAAK,CAAC,GAAN,CAAU,UAAA,QAAQ;AAAA,aAAI,YAAY,CAAC,QAAD,EAAW,MAAX,CAAhB;AAAA,KAAlB,EAAsD,IAAtD,CAA2D,IAA3D,CAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAED,SAAS,aAAT,CACE,IADF,EAEE,IAFF,EAGE,MAHF,EAIE,KAJF,EAI2C;;;;;AAEzC,GAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,EAAX,GAAA,IAAI,CAAC,MAAL,GAAgB,EAAhB;AACA,GAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,EAAY,IAAZ,CAAA,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,EAAhB,GAAgB,EAAA,CAAJ,IAAI,CAAA,GAAM,EAAtB;AACA,GAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAA,EAAkB,MAAlB,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,EAAxB,GAAwB,EAAA,CAAN,MAAM,GAAK,EAA7B,CAJyC,CAKzC;;AACC,EAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,EAAkB,MAAlB,CAAyB,MAAzB,IAA2C,KAA3C;AACF;;AAED,OAAM,SAAU,YAAV,CACJ,QADI,EAEJ,IAFI,EAGJ,MAHI,EAMe;AAAA,MAFnB,GAEmB,uEAAf;AAAC,IAAA,MAAM,EAAE;AAAT,GAAe;;;;AAEb,MAAA,EAAA,GAA8D,QAAQ,CAAtE,OAA8D,EAA9D;AAAA,MAAC,OAAD,GAAiD,EAAjD,CAAC,OAAD;AAAA,MAAU,MAAV,GAAiD,EAAjD,CAAU,MAAV;AAAA,MAAkB,KAAlB,GAAiD,EAAjD,CAAkB,KAAlB;AAAA,MAAyB,SAAzB,GAAiD,EAAjD,CAAyB,SAAzB;AAAA,MAAoC,KAApC,GAAiD,EAAjD,CAAoC,KAApC;AAAA,MAA2C,MAA3C,GAAiD,EAAjD,CAA2C,MAA3C;AAAA,MAAsD,IAAtD,GAA0D,MAAA,CAAA,EAAA,EAA1D,CAAA,SAAA,EAAA,QAAA,EAAA,OAAA,EAAA,WAAA,EAAA,OAAA,EAAA,QAAA,CAA0D,CAA1D;;AAEN,MAAI,OAAJ,EAAa;AACX,WAAO,SAAP;AACD;;AAED,OAAK,IAAM,IAAX,IAAmB,IAAnB,EAAyB;AACvB,QAAM,QAAQ,GAAG,kBAAkB,CAAC,IAAD,CAAnC;AACA,QAAM,SAAS,GAAG,IAAI,CAAC,IAAD,CAAtB;;AAEA,QAAI,QAAQ,IAAI,QAAQ,KAAK,IAAzB,IAAiC,QAAQ,KAAK,MAAlD,EAA0D;AACxD;AACA,aAAO,IAAI,CAAC,IAAD,CAAX;AACD,KAHD,MAGO,IAAI,sBAAsB,CAAiB,SAAjB,CAA1B,EAAuD;AAC5D;AAEM,UAAC,SAAD,GAAmC,SAAnC,CAAC,SAAD;AAAA,UAAe,gBAAf,GAA+B,MAAA,CAAI,SAAJ,EAA/B,CAAA,WAAA,CAA+B,CAA/B;;AACN,UAAM,UAAU,GAAG,KAAK,CAAC,SAAD,CAAxB;AAEA,UAAM,SAAS,GAAG,2BAA2B,CAAC,IAAD,CAA7C;;AACA,UAAI,SAAJ,EAAe;AAAA,YACN,MADM,GACU,SADV,CACN,MADM;AAAA,YACE,IADF,GACU,SADV,CACE,IADF,EAEb;AACA;;AAEA,YAAM,KAAK,gCACN,UAAU,CAAC,GAAX,CAAe,UAAA,CAAC,EAAG;AACd,cAAC,IAAD,GAA+B,CAA/B,CAAC,IAAD;AAAA,cAAU,iBAAV,GAA2B,MAAA,CAAI,CAAJ,EAA3B,CAAA,MAAA,CAA2B,CAA3B;;AACN,iBAAA,MAAA,CAAA,MAAA,CAAA;AACE,YAAA,IAAI,EAAE,UAAU,CAAC,IAAD,EAAO,IAAP;AADlB,WAAA,EAEK,iBAFL,CAAA;AAID,SANE,CADM,IAQT,gBARS,EAAX;AAUA,QAAA,aAAa,CAAC,IAAD,EAAO,IAAP,EAAa,MAAb,EAAqB,KAArB,CAAb;AACA,eAAO,IAAI,CAAC,IAAD,CAAX;AACD,OAjBD,MAiBO,IAAI,SAAS,KAAK,IAAlB,EAAwB;AAC7B;AACA,YAAM,SAAS,GAAc;AAC3B,UAAA,MAAM,EACJ,UAAU,CACP,GADH,CACO,UAAA,CAAC,EAAG;AACD,gBAAC,IAAD,GAA+B,CAA/B,CAAC,IAAD;AAAA,gBAAU,iBAAV,GAA2B,MAAA,CAAI,CAAJ,EAA3B,CAAA,MAAA,CAA2B,CAA3B;;AACN,6BAAU,UAAU,CAAC,IAAD,EAAO,IAAP,CAApB,gBAAsC,wBAAwB,CAAC,iBAAD,CAA9D;AACD,WAJH,EAKG,IALH,CAKQ,EALR,IAKc,wBAAwB,CAAC,gBAAD;AAPb,SAA7B;AASA,QAAA,IAAI,CAAC,IAAD,CAAJ,GAAa,SAAb;AACD;AACF,KArCM,MAqCA,IAAI,WAAW,CAAC,SAAD,CAAf,EAA4B;AACjC,UAAM,UAAS,GAAG,2BAA2B,CAAC,IAAD,CAA7C;;AACA,UAAI,UAAJ,EAAe;AAAA,YACN,OADM,GACU,UADV,CACN,MADM;AAAA,YACE,KADF,GACU,UADV,CACE,IADF;AAEb,QAAA,aAAa,CAAC,IAAD,EAAO,KAAP,EAAa,OAAb,EAAqB,SAArB,CAAb;AACA,eAAO,IAAI,CAAC,IAAD,CAAX;AACD,OANgC,CAM/B;;AACH,KAnDsB,CAqDvB;AACA;;;AACA,QAAI,QAAQ,CAAC,CAAC,YAAD,EAAe,eAAf,CAAD,EAAkC,IAAlC,CAAR,IAAmD,IAAI,CAAC,IAAD,CAAJ,KAAe,IAAtE,EAA4E;AAC1E,aAAO,IAAI,CAAC,IAAD,CAAX;AACD;AACF;;AAED,MAAI,IAAI,KAAK,MAAb,EAAqB;AACnB,QAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;AACd,aAAO,SAAP;AACD,KAHkB,CAKnB;;;AACA,QAAI,IAAI,CAAC,MAAT,EAAiB;AACf;AADe,UAER,IAFQ,GAEA,IAAI,CAAC,MAFL,CAER,IAFQ;AAGf,MAAA,IAAI,CAAC,MAAL,GAAW,MAAA,CAAA,MAAA,CAAA,EAAA,EACL,IAAI,GAAG;AAAC,QAAA,IAAI,EAAJ;AAAD,OAAH,GAAY,EADX,CAAX;;AAIA,UAAI,OAAO,CAAC,IAAI,CAAC,MAAN,CAAX,EAA0B;AACxB,eAAO,IAAI,CAAC,MAAZ;AACD;AACF;;AAED,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACE,MAAA,KAAK,EAAL,KADF;AAEE,MAAA,MAAM,EAAN;AAFF,KAAA,EAGK,IAHL,CAAA,EAGS;AACP,MAAA,MAAM,EAAE,KADD;AAEP,MAAA,MAAM,EAAE,KAFD;AAGP,MAAA,IAAI,EAAE,KAHC;AAKP;AACA;AACA,MAAA,SAAS,EAAE,CAPJ;AAQP,MAAA,SAAS,EAAE,CARJ;AASP,MAAA,KAAK,EAAE,KATA;AAUP,MAAA,MAAM,EAAE,eAAe,CAAC,MAAD,EAAS,CAAT,CAVhB,CAU4B;;AAV5B,KAHT,CAAA;AAeD,GAjCD,MAiCO;AACL;AAEA,QAAI,CAAC,GAAG,CAAC,MAAL,IAAe,QAAQ,CAAC,aAA5B,EAA2C;AACzC;AACA,aAAO,SAAP;AACD;;AAED,QAAI,SAAS,KAAK,SAAlB,EAA6B;AAC3B,UAAI,IAAI,GAAG,SAAX;;AACA,UAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,MAAb,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,KAAA,CAAnB,GAAmB,EAAA,CAAE,MAArB,KAA+B,WAAW,CAAC,IAAI,CAAC,MAAL,CAAY,MAAZ,CAAmB,MAAnB,CAA0B,IAA3B,CAA9C,EAAgF;AAC9E,QAAA,IAAI,GAAG,UAAU,CAAC,SAAD,EAAY,aAAZ,EAA2B,IAAI,CAAC,MAAL,CAAY,MAAZ,CAAmB,MAAnB,CAA0B,IAA1B,CAA+B,MAA1D,CAAjB;AACD;;AACD,MAAA,aAAa,CAAC,IAAD,EAAO,QAAP,EAAiB,MAAjB,EAAyB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAzB,CAAb;AACD;;AAED,QAAI,IAAI,CAAC,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,aAAO,IAAI,CAAC,UAAZ;AACD,KAlBI,CAoBL;;;AACA,QAAI,IAAI,CAAC,MAAT,EAAiB;AAAA,iDACI,UADJ;AAAA;;AAAA;AACf,4DAA+B;AAAA,cAApB,MAAoB;;AAC7B,cAAI,CAAC,QAAQ,CAAC,WAAT,CAAqB,MAArB,CAAL,EAAiC;AAC/B,mBAAO,IAAI,CAAC,MAAL,CAAY,MAAZ,CAAP;AACD;AACF;AALc;AAAA;AAAA;AAAA;AAAA;;AAMf,UAAI,OAAO,CAAC,IAAI,CAAC,MAAN,CAAX,EAA0B;AACxB,eAAO,IAAI,CAAC,MAAZ;AACD;AACF;;AAED,QAAM,WAAW,GAAG,aAAa,CAAC,KAAD,EAAQ,MAAR,CAAjC;AAEA,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACE,MAAA,KAAK,EAAL,KADF;AAEE,MAAA,MAAM,EAAN,MAFF;AAGE,MAAA,IAAI,EAAE;AAHR,KAAA,EAIM,WAAW,GAAG;AAAC,MAAA,KAAK,EAAE;AAAR,KAAH,GAA0B,EAJ3C,CAAA,EAKK,IALL,CAAA,EAMM,MAAM,CAAC,IAAP,KAAgB,KAAhB,GAAwB;AAAC,MAAA,IAAI,EAAE;AAAP,KAAxB,GAAwC,EAN9C,CAAA,EAMiD;AAC/C,MAAA,MAAM,EAAE,eAAe,CAAC,MAAD,EAAS,CAAT,CADwB,CACZ;;AADY,KANjD,CAAA;AASD;AACF;AAED;;;;;AAIA,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAA0C;AAAA,MACvC,IADuC,GAC/B,KAAK,CAAC,SADyB,CACvC,IADuC;AAE9C,MAAM,OAAO,GAAgB,EAA7B;;AAF8C,8CAIxB,uBAJwB;AAAA;;AAAA;AAI9C,2DAA+C;AAAA,UAApC,OAAoC;;AAC7C,UAAI,IAAI,CAAC,OAAD,CAAR,EAAmB;AAAA,oDACE,IAAI,CAAC,OAAD,CADN;AAAA;;AAAA;AACjB,iEAAkC;AAAA,gBAAvB,IAAuB;;AAChC,gBAAI,CAAC,IAAI,CAAC,GAAL,CAAS,SAAT,CAAD,IAAwB,CAAC,IAAI,CAAC,GAAL,CAAS,WAAT,CAA7B,EAAoD;AAClD;AAEA,kBAAM,QAAQ,GAAG,OAAO,KAAK,GAAZ,GAAkB,QAAlB,GAA6B,OAA9C;AACA,kBAAM,MAAM,GAAG,KAAK,CAAC,gBAAN,CAAuB,QAAvB,EAAiC,MAAhD;;AAEA,kBAAI,QAAQ,KAAK,MAAjB,EAAyB;AACvB,gBAAA,OAAO,CAAC,IAAR,CAAa;AACX,kBAAA,IAAI,EAAE,QADK;AAEX,kBAAA,MAAM,EAAE;AAFG,iBAAb;AAID;AACF;AACF;AAfgB;AAAA;AAAA;AAAA;AAAA;AAgBlB;AACF;AAtB6C;AAAA;AAAA;AAAA;AAAA;;AAuB9C,SAAO,OAAP;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,cAAvB,EAA2D,MAA3D,EAAoF;AAAA,0BAC/D,cAD+D,CACjF,CADiF;AAAA,MACjF,CADiF,kCAC7E,EAD6E;AAAA,0BAC/D,cAD+D,CACzE,CADyE;AAAA,MACzE,CADyE,kCACrE,EADqE;AAExF,SAAO,6BACF,CAAC,CAAC,GAAF,CAAM,UAAA,CAAC;AAAA,WAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAhB;AAAA,GAAP,CADE,sBAEF,CAAC,CAAC,GAAF,CAAM,UAAA,CAAC;AAAA,WAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAhB;AAAA,GAAP,CAFE,sBAGF,CAAC,CAAC,GAAF,CAAM,UAAA,CAAC;AAAA,WAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAhB;AAAA,GAAP,CAHE,sBAIF,CAAC,CAAC,GAAF,CAAM,UAAA,CAAC;AAAA,WAAI,YAAY,CAAC,CAAD,EAAI,MAAJ,EAAY,MAAZ,CAAhB;AAAA,GAAP,CAJE,GAKL,MALK,CAKE,UAAA,CAAC;AAAA,WAAI,CAAJ;AAAA,GALH,CAAP,CAFwF,CAOtE;AACnB","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n    if (!title) {\n        return undefined;\n    }\n    if (isArray(title) && !isText(title)) {\n        return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n    }\n    return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n    var _a, _b, _c;\n    var _d, _e;\n    (_a = axis.encode) !== null && _a !== void 0 ? _a : (axis.encode = {});\n    (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : (_d[part] = {});\n    (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : (_e.update = {});\n    // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n    axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {\n    var _a, _b;\n    const _c = axisCmpt.combine(), { disable, orient, scale, labelExpr, title, zindex } = _c, axis = __rest(_c, [\"disable\", \"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]);\n    if (disable) {\n        return undefined;\n    }\n    for (const prop in axis) {\n        const propType = AXIS_PROPERTY_TYPE[prop];\n        const propValue = axis[prop];\n        if (propType && propType !== kind && propType !== 'both') {\n            // Remove properties that are not valid for this kind of axis\n            delete axis[prop];\n        }\n        else if (isConditionalAxisValue(propValue)) {\n            // deal with conditional axis value\n            const { condition } = propValue, valueOrSignalRef = __rest(propValue, [\"condition\"]);\n            const conditions = array(condition);\n            const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n            if (propIndex) {\n                const { vgProp, part } = propIndex;\n                // If there is a corresponding Vega property for the channel,\n                // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n                const vgRef = [\n                    ...conditions.map(c => {\n                        const { test } = c, valueOrSignalCRef = __rest(c, [\"test\"]);\n                        return Object.assign({ test: expression(null, test) }, valueOrSignalCRef);\n                    }),\n                    valueOrSignalRef\n                ];\n                setAxisEncode(axis, part, vgProp, vgRef);\n                delete axis[prop];\n            }\n            else if (propIndex === null) {\n                // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n                const signalRef = {\n                    signal: conditions\n                        .map(c => {\n                        const { test } = c, valueOrSignalCRef = __rest(c, [\"test\"]);\n                        return `${expression(null, test)} ? ${exprFromValueOrSignalRef(valueOrSignalCRef)} : `;\n                    })\n                        .join('') + exprFromValueOrSignalRef(valueOrSignalRef)\n                };\n                axis[prop] = signalRef;\n            }\n        }\n        else if (isSignalRef(propValue)) {\n            const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n            if (propIndex) {\n                const { vgProp, part } = propIndex;\n                setAxisEncode(axis, part, vgProp, propValue);\n                delete axis[prop];\n            } // else do nothing since the property already supports signal\n        }\n        // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n        // Note that we need to use null so the default labelAlign is preserved.\n        if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n            delete axis[prop];\n        }\n    }\n    if (kind === 'grid') {\n        if (!axis.grid) {\n            return undefined;\n        }\n        // Remove unnecessary encode block\n        if (axis.encode) {\n            // Only need to keep encode block for grid\n            const { grid } = axis.encode;\n            axis.encode = Object.assign({}, (grid ? { grid } : {}));\n            if (isEmpty(axis.encode)) {\n                delete axis.encode;\n            }\n        }\n        return Object.assign(Object.assign({ scale,\n            orient }, axis), { domain: false, labels: false, aria: false, \n            // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n            // would not affect gridAxis\n            maxExtent: 0, minExtent: 0, ticks: false, zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n         });\n    }\n    else {\n        // kind === 'main'\n        if (!opt.header && axisCmpt.mainExtracted) {\n            // if mainExtracted has been extracted to a separate facet\n            return undefined;\n        }\n        if (labelExpr !== undefined) {\n            let expr = labelExpr;\n            if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n                expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n            }\n            setAxisEncode(axis, 'labels', 'text', { signal: expr });\n        }\n        if (axis.labelAlign === null) {\n            delete axis.labelAlign;\n        }\n        // Remove unnecessary encode block\n        if (axis.encode) {\n            for (const part of AXIS_PARTS) {\n                if (!axisCmpt.hasAxisPart(part)) {\n                    delete axis.encode[part];\n                }\n            }\n            if (isEmpty(axis.encode)) {\n                delete axis.encode;\n            }\n        }\n        const titleString = assembleTitle(title, config);\n        return Object.assign(Object.assign(Object.assign(Object.assign({ scale,\n            orient, grid: false }, (titleString ? { title: titleString } : {})), axis), (config.aria === false ? { aria: false } : {})), { zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n         });\n    }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model) {\n    const { axes } = model.component;\n    const signals = [];\n    for (const channel of POSITION_SCALE_CHANNELS) {\n        if (axes[channel]) {\n            for (const axis of axes[channel]) {\n                if (!axis.get('disable') && !axis.get('gridScale')) {\n                    // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n                    const sizeType = channel === 'x' ? 'height' : 'width';\n                    const update = model.getSizeSignalRef(sizeType).signal;\n                    if (sizeType !== update) {\n                        signals.push({\n                            name: sizeType,\n                            update: update\n                        });\n                    }\n                }\n            }\n        }\n    }\n    return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n    const { x = [], y = [] } = axisComponents;\n    return [\n        ...x.map(a => assembleAxis(a, 'grid', config)),\n        ...y.map(a => assembleAxis(a, 'grid', config)),\n        ...x.map(a => assembleAxis(a, 'main', config)),\n        ...y.map(a => assembleAxis(a, 'main', config))\n    ].filter(a => a); // filter undefined\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}