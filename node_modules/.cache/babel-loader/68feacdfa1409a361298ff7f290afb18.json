{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData as _parseData } from './data/parse';\nimport { assembleLabelTitle as _assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n  return vgField(sort, Object.assign({\n    suffix: \"by_\".concat(vgField(fieldDef))\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}\nexport var FacetModel = /*#__PURE__*/function (_ModelWithField) {\n  _inherits(FacetModel, _ModelWithField);\n\n  var _super = _createSuper(FacetModel);\n\n  function FacetModel(spec, parent, parentGivenName, config) {\n    var _this;\n\n    _classCallCheck(this, FacetModel);\n\n    _this = _super.call(this, spec, 'facet', parent, parentGivenName, config, spec.resolve);\n    _this.child = buildModel(spec.spec, _assertThisInitialized(_this), _this.getName('child'), undefined, config);\n    _this.children = [_this.child];\n    _this.facet = _this.initFacet(spec.facet);\n    return _this;\n  }\n\n  _createClass(FacetModel, [{\n    key: \"initFacet\",\n    value: function initFacet(facet) {\n      // clone to prevent side effect to the original spec\n      if (!isFacetMapping(facet)) {\n        return {\n          facet: this.initFacetFieldDef(facet, 'facet')\n        };\n      }\n\n      var channels = keys(facet);\n      var normalizedFacet = {};\n\n      var _iterator = _createForOfIteratorHelper(channels),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var channel = _step.value;\n\n          if (![ROW, COLUMN].includes(channel)) {\n            // Drop unsupported channel\n            log.warn(log.message.incompatibleChannel(channel, 'facet'));\n            break;\n          }\n\n          var fieldDef = facet[channel];\n\n          if (fieldDef.field === undefined) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            break;\n          }\n\n          normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return normalizedFacet;\n    }\n  }, {\n    key: \"initFacetFieldDef\",\n    value: function initFacetFieldDef(fieldDef, channel) {\n      // Cast because we call initFieldDef, which assumes general FieldDef.\n      // However, FacetFieldDef is a bit more constrained than the general FieldDef\n      var facetFieldDef = initFieldDef(fieldDef, channel);\n\n      if (facetFieldDef.header) {\n        facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n      } else if (facetFieldDef.header === null) {\n        facetFieldDef.header = null;\n      }\n\n      return facetFieldDef;\n    }\n  }, {\n    key: \"channelHasField\",\n    value: function channelHasField(channel) {\n      return !!this.facet[channel];\n    }\n  }, {\n    key: \"fieldDef\",\n    value: function fieldDef(channel) {\n      return this.facet[channel];\n    }\n  }, {\n    key: \"parseData\",\n    value: function parseData() {\n      this.component.data = _parseData(this);\n      this.child.parseData();\n    }\n  }, {\n    key: \"parseLayoutSize\",\n    value: function parseLayoutSize() {\n      parseChildrenLayoutSize(this);\n    }\n  }, {\n    key: \"parseSelections\",\n    value: function parseSelections() {\n      // As a facet has a single child, the selection components are the same.\n      // The child maintains its selections to assemble signals, which remain\n      // within its unit.\n      this.child.parseSelections();\n      this.component.selection = this.child.component.selection;\n    }\n  }, {\n    key: \"parseMarkGroup\",\n    value: function parseMarkGroup() {\n      this.child.parseMarkGroup();\n    }\n  }, {\n    key: \"parseAxesAndHeaders\",\n    value: function parseAxesAndHeaders() {\n      this.child.parseAxesAndHeaders();\n      parseFacetHeaders(this);\n    }\n  }, {\n    key: \"assembleSelectionTopLevelSignals\",\n    value: function assembleSelectionTopLevelSignals(signals) {\n      return this.child.assembleSelectionTopLevelSignals(signals);\n    }\n  }, {\n    key: \"assembleSignals\",\n    value: function assembleSignals() {\n      this.child.assembleSignals();\n      return [];\n    }\n  }, {\n    key: \"assembleSelectionData\",\n    value: function assembleSelectionData(data) {\n      return this.child.assembleSelectionData(data);\n    }\n  }, {\n    key: \"getHeaderLayoutMixins\",\n    value: function getHeaderLayoutMixins() {\n      var _a, _b, _c;\n\n      var layoutMixins = {};\n\n      var _iterator2 = _createForOfIteratorHelper(FACET_CHANNELS),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var channel = _step2.value;\n\n          var _iterator3 = _createForOfIteratorHelper(HEADER_TYPES),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var headerType = _step3.value;\n              var layoutHeaderComponent = this.component.layoutHeaders[channel];\n              var headerComponent = layoutHeaderComponent[headerType];\n              var facetFieldDef = layoutHeaderComponent.facetFieldDef;\n\n              if (facetFieldDef) {\n                var titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n\n                if (['right', 'bottom'].includes(titleOrient)) {\n                  var headerChannel = getHeaderChannel(channel, titleOrient);\n                  (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : layoutMixins.titleAnchor = {};\n                  layoutMixins.titleAnchor[headerChannel] = 'end';\n                }\n              }\n\n              if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {\n                // set header/footerBand\n                var sizeType = channel === 'row' ? 'height' : 'width';\n                var bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n\n                if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n                  // If facet child does not have size signal, then apply headerBand\n                  (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : layoutMixins[bandType] = {};\n                  layoutMixins[bandType][channel] = 0.5;\n                }\n\n                if (layoutHeaderComponent.title) {\n                  (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : layoutMixins.offset = {};\n                  layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return layoutMixins;\n    }\n  }, {\n    key: \"assembleDefaultLayout\",\n    value: function assembleDefaultLayout() {\n      var _this$facet = this.facet,\n          column = _this$facet.column,\n          row = _this$facet.row;\n      var columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n      var align = 'all'; // Do not align the cells if the scale corresponding to the direction is indepent.\n      // We always align when we facet into both row and column.\n\n      if (!row && this.component.resolve.scale.x === 'independent') {\n        align = 'none';\n      } else if (!column && this.component.resolve.scale.y === 'independent') {\n        align = 'none';\n      }\n\n      return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? {\n        columns: columns\n      } : {}), {\n        bounds: 'full',\n        align: align\n      });\n    }\n  }, {\n    key: \"assembleLayoutSignals\",\n    value: function assembleLayoutSignals() {\n      // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n      return this.child.assembleLayoutSignals();\n    }\n  }, {\n    key: \"columnDistinctSignal\",\n    value: function columnDistinctSignal() {\n      if (this.parent && this.parent instanceof FacetModel) {\n        // For nested facet, we will add columns to group mark instead\n        // See discussion in https://github.com/vega/vega/issues/952\n        // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n        return undefined;\n      } else {\n        // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n        var facetLayoutDataName = this.getName('column_domain');\n        return {\n          signal: \"length(data('\".concat(facetLayoutDataName, \"'))\")\n        };\n      }\n    }\n  }, {\n    key: \"assembleGroupStyle\",\n    value: function assembleGroupStyle() {\n      return undefined;\n    }\n  }, {\n    key: \"assembleGroup\",\n    value: function assembleGroup(signals) {\n      if (this.parent && this.parent instanceof FacetModel) {\n        // Provide number of columns for layout.\n        // See discussion in https://github.com/vega/vega/issues/952\n        // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n        return Object.assign(Object.assign({}, this.channelHasField('column') ? {\n          encode: {\n            update: {\n              // TODO(https://github.com/vega/vega-lite/issues/2759):\n              // Correct the signal for facet of concat of facet_column\n              columns: {\n                field: vgField(this.facet.column, {\n                  prefix: 'distinct'\n                })\n              }\n            }\n          }\n        } : {}), _get(_getPrototypeOf(FacetModel.prototype), \"assembleGroup\", this).call(this, signals));\n      }\n\n      return _get(_getPrototypeOf(FacetModel.prototype), \"assembleGroup\", this).call(this, signals);\n    }\n    /**\n     * Aggregate cardinality for calculating size\n     */\n\n  }, {\n    key: \"getCardinalityAggregateForChild\",\n    value: function getCardinalityAggregateForChild() {\n      var fields = [];\n      var ops = [];\n      var as = [];\n\n      if (this.child instanceof FacetModel) {\n        if (this.child.channelHasField('column')) {\n          var field = vgField(this.child.facet.column);\n          fields.push(field);\n          ops.push('distinct');\n          as.push(\"distinct_\".concat(field));\n        }\n      } else {\n        var _iterator4 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var channel = _step4.value;\n            var childScaleComponent = this.child.component.scales[channel];\n\n            if (childScaleComponent && !childScaleComponent.merged) {\n              var type = childScaleComponent.get('type');\n              var range = childScaleComponent.get('range');\n\n              if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                var domain = assembleDomain(this.child, channel);\n\n                var _field = getFieldFromDomain(domain);\n\n                if (_field) {\n                  fields.push(_field);\n                  ops.push('distinct');\n                  as.push(\"distinct_\".concat(_field));\n                } else {\n                  log.warn(log.message.unknownField(channel));\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      return {\n        fields: fields,\n        ops: ops,\n        as: as\n      };\n    }\n  }, {\n    key: \"assembleFacet\",\n    value: function assembleFacet() {\n      var _this$component$data$ = this.component.data.facetRoot,\n          name = _this$component$data$.name,\n          data = _this$component$data$.data;\n      var _this$facet2 = this.facet,\n          row = _this$facet2.row,\n          column = _this$facet2.column;\n\n      var _this$getCardinalityA = this.getCardinalityAggregateForChild(),\n          fields = _this$getCardinalityA.fields,\n          ops = _this$getCardinalityA.ops,\n          as = _this$getCardinalityA.as;\n\n      var groupby = [];\n\n      var _iterator5 = _createForOfIteratorHelper(FACET_CHANNELS),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var channel = _step5.value;\n          var fieldDef = this.facet[channel];\n\n          if (fieldDef) {\n            groupby.push(vgField(fieldDef));\n            var bin = fieldDef.bin,\n                sort = fieldDef.sort;\n\n            if (isBinning(bin)) {\n              groupby.push(vgField(fieldDef, {\n                binSuffix: 'end'\n              }));\n            }\n\n            if (isSortField(sort)) {\n              var field = sort.field,\n                  _sort$op = sort.op,\n                  op = _sort$op === void 0 ? DEFAULT_SORT_OP : _sort$op;\n              var outputName = facetSortFieldName(fieldDef, sort);\n\n              if (row && column) {\n                // For crossed facet, use pre-calculate field as it requires a different groupby\n                // For each calculated field, apply max and assign them to the same name as\n                // all values of the same group should be the same anyway.\n                fields.push(outputName);\n                ops.push('max');\n                as.push(outputName);\n              } else {\n                fields.push(field);\n                ops.push(op);\n                as.push(outputName);\n              }\n            } else if (isArray(sort)) {\n              var _outputName = sortArrayIndexField(fieldDef, channel);\n\n              fields.push(_outputName);\n              ops.push('max');\n              as.push(_outputName);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var cross = !!row && !!column;\n      return Object.assign({\n        name: name,\n        data: data,\n        groupby: groupby\n      }, cross || fields.length > 0 ? {\n        aggregate: Object.assign(Object.assign({}, cross ? {\n          cross: cross\n        } : {}), fields.length ? {\n          fields: fields,\n          ops: ops,\n          as: as\n        } : {})\n      } : {});\n    }\n  }, {\n    key: \"facetSortFields\",\n    value: function facetSortFields(channel) {\n      var facet = this.facet;\n      var fieldDef = facet[channel];\n\n      if (fieldDef) {\n        if (isSortField(fieldDef.sort)) {\n          return [facetSortFieldName(fieldDef, fieldDef.sort, {\n            expr: 'datum'\n          })];\n        } else if (isArray(fieldDef.sort)) {\n          return [sortArrayIndexField(fieldDef, channel, {\n            expr: 'datum'\n          })];\n        }\n\n        return [vgField(fieldDef, {\n          expr: 'datum'\n        })];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"facetSortOrder\",\n    value: function facetSortOrder(channel) {\n      var facet = this.facet;\n      var fieldDef = facet[channel];\n\n      if (fieldDef) {\n        var sort = fieldDef.sort;\n        var order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n        return [order];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"assembleLabelTitle\",\n    value: function assembleLabelTitle() {\n      var _a;\n\n      var facet = this.facet,\n          config = this.config;\n\n      if (facet.facet) {\n        // Facet always uses title to display labels\n        return _assembleLabelTitle(facet.facet, 'facet', config);\n      }\n\n      var ORTHOGONAL_ORIENT = {\n        row: ['top', 'bottom'],\n        column: ['left', 'right']\n      };\n\n      var _iterator6 = _createForOfIteratorHelper(HEADER_CHANNELS),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var channel = _step6.value;\n\n          if (facet[channel]) {\n            var labelOrient = getHeaderProperty('labelOrient', (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);\n\n            if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n              // Row/Column with orthogonal labelOrient must use title to display labels\n              return _assembleLabelTitle(facet[channel], channel, config);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"assembleMarks\",\n    value: function assembleMarks() {\n      var _this2 = this;\n\n      var child = this.child; // If we facet by two dimensions, we need to add a cross operator to the aggregation\n      // so that we create all groups\n\n      var facetRoot = this.component.data.facetRoot;\n      var data = assembleFacetData(facetRoot);\n      var encodeEntry = child.assembleGroupEncodeEntry(false);\n      var title = this.assembleLabelTitle() || child.assembleTitle();\n      var style = child.assembleGroupStyle();\n      var markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        name: this.getName('cell'),\n        type: 'group'\n      }, title ? {\n        title: title\n      } : {}), style ? {\n        style: style\n      } : {}), {\n        from: {\n          facet: this.assembleFacet()\n        },\n        // TODO: move this to after data\n        sort: {\n          field: FACET_CHANNELS.map(function (c) {\n            return _this2.facetSortFields(c);\n          }).flat(),\n          order: FACET_CHANNELS.map(function (c) {\n            return _this2.facetSortOrder(c);\n          }).flat()\n        }\n      }), data.length > 0 ? {\n        data: data\n      } : {}), encodeEntry ? {\n        encode: {\n          update: encodeEntry\n        }\n      } : {}), child.assembleGroup(assembleFacetSignals(this, [])));\n      return [markGroup];\n    }\n  }, {\n    key: \"getMapping\",\n    value: function getMapping() {\n      return this.facet;\n    }\n  }]);\n\n  return FacetModel;\n}(ModelWithField);","map":{"version":3,"sources":["../../../src/compile/facet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData } from './data/parse';\nimport { assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n    return vgField(sort, Object.assign({ suffix: `by_${vgField(fieldDef)}` }, (opt !== null && opt !== void 0 ? opt : {})));\n}\nexport class FacetModel extends ModelWithField {\n    constructor(spec, parent, parentGivenName, config) {\n        super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n        this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n        this.children = [this.child];\n        this.facet = this.initFacet(spec.facet);\n    }\n    initFacet(facet) {\n        // clone to prevent side effect to the original spec\n        if (!isFacetMapping(facet)) {\n            return { facet: this.initFacetFieldDef(facet, 'facet') };\n        }\n        const channels = keys(facet);\n        const normalizedFacet = {};\n        for (const channel of channels) {\n            if (![ROW, COLUMN].includes(channel)) {\n                // Drop unsupported channel\n                log.warn(log.message.incompatibleChannel(channel, 'facet'));\n                break;\n            }\n            const fieldDef = facet[channel];\n            if (fieldDef.field === undefined) {\n                log.warn(log.message.emptyFieldDef(fieldDef, channel));\n                break;\n            }\n            normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n        }\n        return normalizedFacet;\n    }\n    initFacetFieldDef(fieldDef, channel) {\n        // Cast because we call initFieldDef, which assumes general FieldDef.\n        // However, FacetFieldDef is a bit more constrained than the general FieldDef\n        const facetFieldDef = initFieldDef(fieldDef, channel);\n        if (facetFieldDef.header) {\n            facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n        }\n        else if (facetFieldDef.header === null) {\n            facetFieldDef.header = null;\n        }\n        return facetFieldDef;\n    }\n    channelHasField(channel) {\n        return !!this.facet[channel];\n    }\n    fieldDef(channel) {\n        return this.facet[channel];\n    }\n    parseData() {\n        this.component.data = parseData(this);\n        this.child.parseData();\n    }\n    parseLayoutSize() {\n        parseChildrenLayoutSize(this);\n    }\n    parseSelections() {\n        // As a facet has a single child, the selection components are the same.\n        // The child maintains its selections to assemble signals, which remain\n        // within its unit.\n        this.child.parseSelections();\n        this.component.selection = this.child.component.selection;\n    }\n    parseMarkGroup() {\n        this.child.parseMarkGroup();\n    }\n    parseAxesAndHeaders() {\n        this.child.parseAxesAndHeaders();\n        parseFacetHeaders(this);\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return this.child.assembleSelectionTopLevelSignals(signals);\n    }\n    assembleSignals() {\n        this.child.assembleSignals();\n        return [];\n    }\n    assembleSelectionData(data) {\n        return this.child.assembleSelectionData(data);\n    }\n    getHeaderLayoutMixins() {\n        var _a, _b, _c;\n        const layoutMixins = {};\n        for (const channel of FACET_CHANNELS) {\n            for (const headerType of HEADER_TYPES) {\n                const layoutHeaderComponent = this.component.layoutHeaders[channel];\n                const headerComponent = layoutHeaderComponent[headerType];\n                const { facetFieldDef } = layoutHeaderComponent;\n                if (facetFieldDef) {\n                    const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n                    if (['right', 'bottom'].includes(titleOrient)) {\n                        const headerChannel = getHeaderChannel(channel, titleOrient);\n                        (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : (layoutMixins.titleAnchor = {});\n                        layoutMixins.titleAnchor[headerChannel] = 'end';\n                    }\n                }\n                if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {\n                    // set header/footerBand\n                    const sizeType = channel === 'row' ? 'height' : 'width';\n                    const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n                    if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n                        // If facet child does not have size signal, then apply headerBand\n                        (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : (layoutMixins[bandType] = {});\n                        layoutMixins[bandType][channel] = 0.5;\n                    }\n                    if (layoutHeaderComponent.title) {\n                        (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : (layoutMixins.offset = {});\n                        layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n                    }\n                }\n            }\n        }\n        return layoutMixins;\n    }\n    assembleDefaultLayout() {\n        const { column, row } = this.facet;\n        const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n        let align = 'all';\n        // Do not align the cells if the scale corresponding to the direction is indepent.\n        // We always align when we facet into both row and column.\n        if (!row && this.component.resolve.scale.x === 'independent') {\n            align = 'none';\n        }\n        else if (!column && this.component.resolve.scale.y === 'independent') {\n            align = 'none';\n        }\n        return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), (columns ? { columns } : {})), { bounds: 'full', align });\n    }\n    assembleLayoutSignals() {\n        // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n        return this.child.assembleLayoutSignals();\n    }\n    columnDistinctSignal() {\n        if (this.parent && this.parent instanceof FacetModel) {\n            // For nested facet, we will add columns to group mark instead\n            // See discussion in https://github.com/vega/vega/issues/952\n            // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n            return undefined;\n        }\n        else {\n            // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n            const facetLayoutDataName = this.getName('column_domain');\n            return { signal: `length(data('${facetLayoutDataName}'))` };\n        }\n    }\n    assembleGroupStyle() {\n        return undefined;\n    }\n    assembleGroup(signals) {\n        if (this.parent && this.parent instanceof FacetModel) {\n            // Provide number of columns for layout.\n            // See discussion in https://github.com/vega/vega/issues/952\n            // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n            return Object.assign(Object.assign({}, (this.channelHasField('column')\n                ? {\n                    encode: {\n                        update: {\n                            // TODO(https://github.com/vega/vega-lite/issues/2759):\n                            // Correct the signal for facet of concat of facet_column\n                            columns: { field: vgField(this.facet.column, { prefix: 'distinct' }) }\n                        }\n                    }\n                }\n                : {})), super.assembleGroup(signals));\n        }\n        return super.assembleGroup(signals);\n    }\n    /**\n     * Aggregate cardinality for calculating size\n     */\n    getCardinalityAggregateForChild() {\n        const fields = [];\n        const ops = [];\n        const as = [];\n        if (this.child instanceof FacetModel) {\n            if (this.child.channelHasField('column')) {\n                const field = vgField(this.child.facet.column);\n                fields.push(field);\n                ops.push('distinct');\n                as.push(`distinct_${field}`);\n            }\n        }\n        else {\n            for (const channel of POSITION_SCALE_CHANNELS) {\n                const childScaleComponent = this.child.component.scales[channel];\n                if (childScaleComponent && !childScaleComponent.merged) {\n                    const type = childScaleComponent.get('type');\n                    const range = childScaleComponent.get('range');\n                    if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                        const domain = assembleDomain(this.child, channel);\n                        const field = getFieldFromDomain(domain);\n                        if (field) {\n                            fields.push(field);\n                            ops.push('distinct');\n                            as.push(`distinct_${field}`);\n                        }\n                        else {\n                            log.warn(log.message.unknownField(channel));\n                        }\n                    }\n                }\n            }\n        }\n        return { fields, ops, as };\n    }\n    assembleFacet() {\n        const { name, data } = this.component.data.facetRoot;\n        const { row, column } = this.facet;\n        const { fields, ops, as } = this.getCardinalityAggregateForChild();\n        const groupby = [];\n        for (const channel of FACET_CHANNELS) {\n            const fieldDef = this.facet[channel];\n            if (fieldDef) {\n                groupby.push(vgField(fieldDef));\n                const { bin, sort } = fieldDef;\n                if (isBinning(bin)) {\n                    groupby.push(vgField(fieldDef, { binSuffix: 'end' }));\n                }\n                if (isSortField(sort)) {\n                    const { field, op = DEFAULT_SORT_OP } = sort;\n                    const outputName = facetSortFieldName(fieldDef, sort);\n                    if (row && column) {\n                        // For crossed facet, use pre-calculate field as it requires a different groupby\n                        // For each calculated field, apply max and assign them to the same name as\n                        // all values of the same group should be the same anyway.\n                        fields.push(outputName);\n                        ops.push('max');\n                        as.push(outputName);\n                    }\n                    else {\n                        fields.push(field);\n                        ops.push(op);\n                        as.push(outputName);\n                    }\n                }\n                else if (isArray(sort)) {\n                    const outputName = sortArrayIndexField(fieldDef, channel);\n                    fields.push(outputName);\n                    ops.push('max');\n                    as.push(outputName);\n                }\n            }\n        }\n        const cross = !!row && !!column;\n        return Object.assign({ name,\n            data,\n            groupby }, (cross || fields.length > 0\n            ? {\n                aggregate: Object.assign(Object.assign({}, (cross ? { cross } : {})), (fields.length ? { fields, ops, as } : {}))\n            }\n            : {}));\n    }\n    facetSortFields(channel) {\n        const { facet } = this;\n        const fieldDef = facet[channel];\n        if (fieldDef) {\n            if (isSortField(fieldDef.sort)) {\n                return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: 'datum' })];\n            }\n            else if (isArray(fieldDef.sort)) {\n                return [sortArrayIndexField(fieldDef, channel, { expr: 'datum' })];\n            }\n            return [vgField(fieldDef, { expr: 'datum' })];\n        }\n        return [];\n    }\n    facetSortOrder(channel) {\n        const { facet } = this;\n        const fieldDef = facet[channel];\n        if (fieldDef) {\n            const { sort } = fieldDef;\n            const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n            return [order];\n        }\n        return [];\n    }\n    assembleLabelTitle() {\n        var _a;\n        const { facet, config } = this;\n        if (facet.facet) {\n            // Facet always uses title to display labels\n            return assembleLabelTitle(facet.facet, 'facet', config);\n        }\n        const ORTHOGONAL_ORIENT = {\n            row: ['top', 'bottom'],\n            column: ['left', 'right']\n        };\n        for (const channel of HEADER_CHANNELS) {\n            if (facet[channel]) {\n                const labelOrient = getHeaderProperty('labelOrient', (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);\n                if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n                    // Row/Column with orthogonal labelOrient must use title to display labels\n                    return assembleLabelTitle(facet[channel], channel, config);\n                }\n            }\n        }\n        return undefined;\n    }\n    assembleMarks() {\n        const { child } = this;\n        // If we facet by two dimensions, we need to add a cross operator to the aggregation\n        // so that we create all groups\n        const facetRoot = this.component.data.facetRoot;\n        const data = assembleFacetData(facetRoot);\n        const encodeEntry = child.assembleGroupEncodeEntry(false);\n        const title = this.assembleLabelTitle() || child.assembleTitle();\n        const style = child.assembleGroupStyle();\n        const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: this.getName('cell'), type: 'group' }, (title ? { title } : {})), (style ? { style } : {})), { from: {\n                facet: this.assembleFacet()\n            }, \n            // TODO: move this to after data\n            sort: {\n                field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n                order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n            } }), (data.length > 0 ? { data: data } : {})), (encodeEntry ? { encode: { update: encodeEntry } } : {})), child.assembleGroup(assembleFacetSignals(this, [])));\n        return [markGroup];\n    }\n    getMapping() {\n        return this.facet;\n    }\n}\n//# sourceMappingURL=facet.js.map"]},"metadata":{},"sourceType":"module"}