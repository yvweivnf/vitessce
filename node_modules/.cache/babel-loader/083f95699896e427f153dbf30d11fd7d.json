{"ast":null,"code":"export const AGGREGATION_OPERATION = {\n  SUM: 1,\n  MEAN: 2,\n  MIN: 3,\n  MAX: 4\n};\n\nfunction sumReducer(accu, cur) {\n  return accu + cur;\n}\n\nfunction maxReducer(accu, cur) {\n  return cur > accu ? cur : accu;\n}\n\nfunction minReducer(accu, cur) {\n  return cur < accu ? cur : accu;\n}\n\nexport function getMean(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;\n}\nexport function getSum(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? pts.length * accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(sumReducer, 0) : null;\n}\nexport function getMax(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;\n}\nexport function getMin(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(minReducer, Infinity) : null;\n}\nexport function getValueFunc(aggregation, accessor, context) {\n  const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;\n  accessor = wrapAccessor(accessor, context);\n\n  switch (op) {\n    case AGGREGATION_OPERATION.MIN:\n      return pts => getMin(pts, accessor);\n\n    case AGGREGATION_OPERATION.SUM:\n      return pts => getSum(pts, accessor);\n\n    case AGGREGATION_OPERATION.MEAN:\n      return pts => getMean(pts, accessor);\n\n    case AGGREGATION_OPERATION.MAX:\n      return pts => getMax(pts, accessor);\n\n    default:\n      return null;\n  }\n}\n\nfunction wrapAccessor(accessor) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (Number.isFinite(accessor)) {\n    return accessor;\n  }\n\n  return pt => {\n    context.index = pt.index;\n    return accessor(pt.source, context);\n  };\n}\n\nexport function wrapGetValueFunc(getValue) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return pts => {\n    context.indices = pts.map(pt => pt.index);\n    return getValue(pts.map(pt => pt.source), context);\n  };\n}","map":{"version":3,"sources":["../../../src/utils/aggregation-operation-utils.js"],"names":["AGGREGATION_OPERATION","SUM","MEAN","MIN","MAX","accu","cur","Number","pts","filtered","op","accessor","wrapAccessor","getMin","getSum","getMean","getMax","context","pt","getValue"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport const AGGREGATION_OPERATION = {\n  SUM: 1,\n  MEAN: 2,\n  MIN: 3,\n  MAX: 4\n};\n\nfunction sumReducer(accu, cur) {\n  return accu + cur;\n}\n\nfunction maxReducer(accu, cur) {\n  return cur > accu ? cur : accu;\n}\n\nfunction minReducer(accu, cur) {\n  return cur < accu ? cur : accu;\n}\n\nexport function getMean(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;\n}\n\nexport function getSum(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? pts.length * accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(sumReducer, 0) : null;\n}\n\nexport function getMax(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;\n}\n\nexport function getMin(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(minReducer, Infinity) : null;\n}\n\n// Function to convert from aggregation/accessor props (like colorAggregation and getColorWeight) to getValue prop (like getColorValue)\nexport function getValueFunc(aggregation, accessor, context) {\n  const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;\n  accessor = wrapAccessor(accessor, context);\n  switch (op) {\n    case AGGREGATION_OPERATION.MIN:\n      return pts => getMin(pts, accessor);\n    case AGGREGATION_OPERATION.SUM:\n      return pts => getSum(pts, accessor);\n    case AGGREGATION_OPERATION.MEAN:\n      return pts => getMean(pts, accessor);\n    case AGGREGATION_OPERATION.MAX:\n      return pts => getMax(pts, accessor);\n    default:\n      return null;\n  }\n}\n\nfunction wrapAccessor(accessor, context = {}) {\n  if (Number.isFinite(accessor)) {\n    return accessor;\n  }\n  return pt => {\n    context.index = pt.index;\n    return accessor(pt.source, context);\n  };\n}\n\nexport function wrapGetValueFunc(getValue, context = {}) {\n  return pts => {\n    context.indices = pts.map(pt => pt.index);\n    return getValue(pts.map(pt => pt.source), context);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}