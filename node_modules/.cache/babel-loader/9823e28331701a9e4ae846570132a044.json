{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport { CompositeLayer, log } from '@deck.gl/core';\nimport { replaceInRange } from '../utils';\nimport { binaryToFeatureForAccesor } from './geojson-binary';\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from './sub-layer-map';\nimport { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from './geojson-layer-props';\nvar FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nvar defaultProps = _objectSpread({}, getDefaultProps(POINT_LAYER.circle), {}, getDefaultProps(POINT_LAYER.icon), {}, getDefaultProps(POINT_LAYER.text), {}, getDefaultProps(LINE_LAYER), {}, getDefaultProps(POLYGON_LAYER), {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.properties.icon;\n    }\n  },\n  getText: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.properties.text;\n    }\n  },\n  pointType: 'circle',\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n});\n\nvar GeoJsonLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(GeoJsonLayer, _CompositeLayer);\n\n  var _super = _createSuper(GeoJsonLayer);\n\n  function GeoJsonLayer() {\n    _classCallCheck(this, GeoJsonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GeoJsonLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        layerProps: {},\n        features: {}\n      };\n\n      if (this.props.getLineDashArray) {\n        log.removed('getLineDashArray', 'PathStyleExtension')();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      if (!changeFlags.dataChanged) {\n        return;\n      }\n\n      var data = this.props.data;\n      var binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n      this.setState({\n        binary: binary\n      });\n\n      if (binary) {\n        this._updateStateBinary({\n          props: props,\n          changeFlags: changeFlags\n        });\n      } else {\n        this._updateStateJSON({\n          props: props,\n          changeFlags: changeFlags\n        });\n      }\n    }\n  }, {\n    key: \"_updateStateBinary\",\n    value: function _updateStateBinary(_ref2) {\n      var props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n      var layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n      this.setState({\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"_updateStateJSON\",\n    value: function _updateStateJSON(_ref3) {\n      var props = _ref3.props,\n          changeFlags = _ref3.changeFlags;\n      var features = getGeojsonFeatures(props.data);\n      var wrapFeature = this.getSubLayerRow.bind(this);\n      var newFeatures = {};\n      var featuresDiff = {};\n\n      if (Array.isArray(changeFlags.dataChanged)) {\n        var oldFeatures = this.state.features;\n\n        for (var key in oldFeatures) {\n          newFeatures[key] = oldFeatures[key].slice();\n          featuresDiff[key] = [];\n        }\n\n        var _iterator = _createForOfIteratorHelper(changeFlags.dataChanged),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dataRange = _step.value;\n            var partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n\n            for (var _key in oldFeatures) {\n              featuresDiff[_key].push(replaceInRange({\n                data: newFeatures[_key],\n                getIndex: function getIndex(f) {\n                  return f.__source.index;\n                },\n                dataRange: dataRange,\n                replace: partialFeatures[_key]\n              }));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        newFeatures = separateGeojsonFeatures(features, wrapFeature);\n      }\n\n      var layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n      this.setState({\n        features: newFeatures,\n        featuresDiff: featuresDiff,\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(params) {\n      var _this = this;\n\n      var info = _get(_getPrototypeOf(GeoJsonLayer.prototype), \"getPickingInfo\", this).call(this, params);\n\n      var sourceLayer = info.sourceLayer;\n      info.featureType = FEATURE_TYPES.find(function (ft) {\n        return sourceLayer.id.startsWith(\"\".concat(_this.id, \"-\").concat(ft, \"-\"));\n      });\n      return info;\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      var pointLayerIdPrefix = \"\".concat(this.id, \"-points-\");\n      var sourceIsPoints = info.featureType === 'points';\n\n      var _iterator2 = _createForOfIteratorHelper(this.getSubLayers()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n\n          if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n            layer.updateAutoHighlight(info);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props = this.props,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe;\n      var layerProps = this.state.layerProps;\n      var id = 'polygons-fill';\n      var PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n      if (PolygonFillLayer) {\n        var forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n        var useLineColor = extruded && wireframe;\n\n        if (!useLineColor) {\n          delete forwardedProps.getLineColor;\n        }\n\n        forwardedProps.updateTriggers.lineColors = useLineColor;\n        return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n          id: id,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.polygons);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_renderLineLayers\",\n    value: function _renderLineLayers() {\n      var _this$props2 = this.props,\n          extruded = _this$props2.extruded,\n          stroked = _this$props2.stroked;\n      var layerProps = this.state.layerProps;\n      var polygonStrokeLayerId = 'polygons-stroke';\n      var lineStringsLayerId = 'linestrings';\n      var PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n      var LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n      if (PolygonStrokeLayer || LineStringsLayer) {\n        var forwardedProps = forwardProps(this, LINE_LAYER.props);\n        return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n          id: polygonStrokeLayerId,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n          id: lineStringsLayerId,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.lines)];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_renderPointLayers\",\n    value: function _renderPointLayers() {\n      var pointType = this.props.pointType;\n      var _this$state = this.state,\n          layerProps = _this$state.layerProps,\n          binary = _this$state.binary;\n      var highlightedObjectIndex = this.props.highlightedObjectIndex;\n\n      if (!binary && Number.isFinite(highlightedObjectIndex)) {\n        highlightedObjectIndex = layerProps.points.data.findIndex(function (d) {\n          return d.__source.index === highlightedObjectIndex;\n        });\n      }\n\n      var types = new Set(pointType.split('+'));\n      var pointLayers = [];\n\n      var _iterator3 = _createForOfIteratorHelper(types),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var type = _step3.value;\n          var id = \"points-\".concat(type);\n          var PointLayerMapping = POINT_LAYER[type];\n          var PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n\n          if (PointsLayer) {\n            var forwardedProps = forwardProps(this, PointLayerMapping.props);\n            pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n              id: id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex: highlightedObjectIndex\n            }), layerProps.points));\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return pointLayers;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var extruded = this.props.extruded;\n\n      var polygonFillLayer = this._renderPolygonLayer();\n\n      var lineLayers = this._renderLineLayers();\n\n      var pointLayers = this._renderPointLayers();\n\n      return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];\n    }\n  }, {\n    key: \"getSubLayerAccessor\",\n    value: function getSubLayerAccessor(accessor) {\n      var binary = this.state.binary;\n\n      if (!binary || typeof accessor !== 'function') {\n        return _get(_getPrototypeOf(GeoJsonLayer.prototype), \"getSubLayerAccessor\", this).call(this, accessor);\n      }\n\n      return function (object, info) {\n        var data = info.data,\n            index = info.index;\n        var feature = binaryToFeatureForAccesor(data, index);\n        return accessor(feature, info);\n      };\n    }\n  }]);\n\n  return GeoJsonLayer;\n}(CompositeLayer);\n\nexport { GeoJsonLayer as default };\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/geojson-layer/geojson-layer.js"],"names":["FEATURE_TYPES","defaultProps","getDefaultProps","POINT_LAYER","stroked","filled","extruded","wireframe","iconAtlas","type","value","iconMapping","getIcon","f","icon","getText","text","pointType","getRadius","deprecatedFor","layerProps","features","log","changeFlags","data","binary","props","createLayerPropsFromBinary","getGeojsonFeatures","wrapFeature","newFeatures","featuresDiff","Array","oldFeatures","partialFeatures","separateGeojsonFeatures","replaceInRange","getIndex","dataRange","replace","createLayerPropsFromFeatures","info","sourceLayer","ft","pointLayerIdPrefix","sourceIsPoints","layer","id","PolygonFillLayer","POLYGON_LAYER","forwardedProps","forwardProps","useLineColor","updateTriggers","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","LINE_LAYER","LineStringsLayer","highlightedObjectIndex","Number","d","types","pointLayers","PointLayerMapping","PointsLayer","polygonFillLayer","lineLayers","index","feature","binaryToFeatureForAccesor","accessor","GeoJsonLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, log} from '@deck.gl/core';\nimport {replaceInRange} from '../utils';\nimport {binaryToFeatureForAccesor} from './geojson-binary';\nimport {\n  POINT_LAYER,\n  LINE_LAYER,\n  POLYGON_LAYER,\n  getDefaultProps,\n  forwardProps\n} from './sub-layer-map';\n\nimport {getGeojsonFeatures, separateGeojsonFeatures} from './geojson';\nimport {createLayerPropsFromFeatures, createLayerPropsFromBinary} from './geojson-layer-props';\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nconst defaultProps = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {type: 'object', value: null},\n  iconMapping: {type: 'object', value: {}},\n  getIcon: {type: 'accessor', value: f => f.properties.icon},\n  getText: {type: 'accessor', value: f => f.properties.text},\n\n  // Self props\n  pointType: 'circle',\n\n  // TODO: deprecated, remove in v9\n  getRadius: {deprecatedFor: 'getPointRadius'}\n};\n\nexport default class GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({props, changeFlags}) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  _updateStateBinary({props, changeFlags}) {\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  _updateStateJSON({props, changeFlags}) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {sourceLayer} = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(`${this.id}-${ft}-`));\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  _renderPolygonLayer() {\n    const {extruded, wireframe} = this.props;\n    const {layerProps} = this.state;\n    const id = 'polygons-fill';\n\n    const PolygonFillLayer =\n      this.shouldRenderSubLayer(id, layerProps.polygons.data) &&\n      this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n\n      return new PolygonFillLayer(\n        forwardedProps,\n        this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers\n        }),\n        layerProps.polygons\n      );\n    }\n    return null;\n  }\n\n  _renderLineLayers() {\n    const {extruded, stroked} = this.props;\n    const {layerProps} = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.lines\n          )\n      ];\n    }\n    return null;\n  }\n\n  _renderPointLayers() {\n    const {pointType} = this.props;\n    const {layerProps, binary} = this.state;\n    let {highlightedObjectIndex} = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(\n        d => d.__source.index === highlightedObjectIndex\n      );\n    }\n\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer =\n        PointLayerMapping &&\n        this.shouldRenderSubLayer(id, layerProps.points.data) &&\n        this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n\n        pointLayers.push(\n          new PointsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex\n            }),\n            layerProps.points\n          )\n        );\n      }\n    }\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {extruded} = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      lineLayers,\n      pointLayers,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n\n  getSubLayerAccessor(accessor) {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      return accessor(feature, info);\n    };\n  }\n}\n\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}