{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty2 from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\n\nvar _DEFAULT_SAMPLER;\n\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../utils/assert';\nimport { getAccessorArrayTypeAndLength } from '../gltf-utils/gltf-utils';\nvar COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nvar BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nvar GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nvar SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\nvar DEFAULT_SAMPLER = (_DEFAULT_SAMPLER = {}, _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MAG_FILTER, GL_SAMPLER.LINEAR), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MIN_FILTER, GL_SAMPLER.NEAREST_MIPMAP_LINEAR), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_S, GL_SAMPLER.REPEAT), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_T, GL_SAMPLER.REPEAT), _DEFAULT_SAMPLER);\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nvar GLTFPostProcessor = /*#__PURE__*/function () {\n  function GLTFPostProcessor() {\n    _classCallCheck(this, GLTFPostProcessor);\n\n    _defineProperty(this, \"baseUri\", '');\n\n    _defineProperty(this, \"json\", {});\n\n    _defineProperty(this, \"buffers\", []);\n\n    _defineProperty(this, \"images\", []);\n  }\n\n  _createClass(GLTFPostProcessor, [{\n    key: \"postProcess\",\n    value: function postProcess(gltf) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var json = gltf.json,\n          _gltf$buffers = gltf.buffers,\n          buffers = _gltf$buffers === void 0 ? [] : _gltf$buffers,\n          _gltf$images = gltf.images,\n          images = _gltf$images === void 0 ? [] : _gltf$images,\n          _gltf$baseUri = gltf.baseUri,\n          baseUri = _gltf$baseUri === void 0 ? '' : _gltf$baseUri;\n      assert(json);\n      this.baseUri = baseUri;\n      this.json = json;\n      this.buffers = buffers;\n      this.images = images;\n\n      this._resolveTree(this.json, options);\n\n      return this.json;\n    }\n  }, {\n    key: \"_resolveTree\",\n    value: function _resolveTree(json) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (json.bufferViews) {\n        json.bufferViews = json.bufferViews.map(function (bufView, i) {\n          return _this._resolveBufferView(bufView, i);\n        });\n      }\n\n      if (json.images) {\n        json.images = json.images.map(function (image, i) {\n          return _this._resolveImage(image, i);\n        });\n      }\n\n      if (json.samplers) {\n        json.samplers = json.samplers.map(function (sampler, i) {\n          return _this._resolveSampler(sampler, i);\n        });\n      }\n\n      if (json.textures) {\n        json.textures = json.textures.map(function (texture, i) {\n          return _this._resolveTexture(texture, i);\n        });\n      }\n\n      if (json.accessors) {\n        json.accessors = json.accessors.map(function (accessor, i) {\n          return _this._resolveAccessor(accessor, i);\n        });\n      }\n\n      if (json.materials) {\n        json.materials = json.materials.map(function (material, i) {\n          return _this._resolveMaterial(material, i);\n        });\n      }\n\n      if (json.meshes) {\n        json.meshes = json.meshes.map(function (mesh, i) {\n          return _this._resolveMesh(mesh, i);\n        });\n      }\n\n      if (json.nodes) {\n        json.nodes = json.nodes.map(function (node, i) {\n          return _this._resolveNode(node, i);\n        });\n      }\n\n      if (json.skins) {\n        json.skins = json.skins.map(function (skin, i) {\n          return _this._resolveSkin(skin, i);\n        });\n      }\n\n      if (json.scenes) {\n        json.scenes = json.scenes.map(function (scene, i) {\n          return _this._resolveScene(scene, i);\n        });\n      }\n\n      if (json.scene !== undefined) {\n        json.scene = json.scenes[this.json.scene];\n      }\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(index) {\n      return this._get('scenes', index);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this._get('nodes', index);\n    }\n  }, {\n    key: \"getSkin\",\n    value: function getSkin(index) {\n      return this._get('skins', index);\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh(index) {\n      return this._get('meshes', index);\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(index) {\n      return this._get('materials', index);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(index) {\n      return this._get('accessors', index);\n    }\n  }, {\n    key: \"getCamera\",\n    value: function getCamera(index) {\n      return null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(index) {\n      return this._get('textures', index);\n    }\n  }, {\n    key: \"getSampler\",\n    value: function getSampler(index) {\n      return this._get('samplers', index);\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage(index) {\n      return this._get('images', index);\n    }\n  }, {\n    key: \"getBufferView\",\n    value: function getBufferView(index) {\n      return this._get('bufferViews', index);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(index) {\n      return this._get('buffers', index);\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(array, index) {\n      if (typeof index === 'object') {\n        return index;\n      }\n\n      var object = this.json[array] && this.json[array][index];\n\n      if (!object) {\n        console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n      }\n\n      return object;\n    }\n  }, {\n    key: \"_resolveScene\",\n    value: function _resolveScene(scene, index) {\n      var _this2 = this;\n\n      scene.id = scene.id || \"scene-\".concat(index);\n      scene.nodes = (scene.nodes || []).map(function (node) {\n        return _this2.getNode(node);\n      });\n      return scene;\n    }\n  }, {\n    key: \"_resolveNode\",\n    value: function _resolveNode(node, index) {\n      var _this3 = this;\n\n      node.id = node.id || \"node-\".concat(index);\n\n      if (node.children) {\n        node.children = node.children.map(function (child) {\n          return _this3.getNode(child);\n        });\n      }\n\n      if (node.mesh !== undefined) {\n        node.mesh = this.getMesh(node.mesh);\n      } else if (node.meshes !== undefined && node.meshes.length) {\n        node.mesh = node.meshes.reduce(function (accum, meshIndex) {\n          var mesh = _this3.getMesh(meshIndex);\n\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        }, {\n          primitives: []\n        });\n      }\n\n      if (node.camera !== undefined) {\n        node.camera = this.getCamera(node.camera);\n      }\n\n      if (node.skin !== undefined) {\n        node.skin = this.getSkin(node.skin);\n      }\n\n      return node;\n    }\n  }, {\n    key: \"_resolveSkin\",\n    value: function _resolveSkin(skin, index) {\n      skin.id = skin.id || \"skin-\".concat(index);\n      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n      return skin;\n    }\n  }, {\n    key: \"_resolveMesh\",\n    value: function _resolveMesh(mesh, index) {\n      var _this4 = this;\n\n      mesh.id = mesh.id || \"mesh-\".concat(index);\n\n      if (mesh.primitives) {\n        mesh.primitives = mesh.primitives.map(function (primitive) {\n          primitive = _objectSpread({}, primitive);\n          var attributes = primitive.attributes;\n          primitive.attributes = {};\n\n          for (var attribute in attributes) {\n            primitive.attributes[attribute] = _this4.getAccessor(attributes[attribute]);\n          }\n\n          if (primitive.indices !== undefined) {\n            primitive.indices = _this4.getAccessor(primitive.indices);\n          }\n\n          if (primitive.material !== undefined) {\n            primitive.material = _this4.getMaterial(primitive.material);\n          }\n\n          return primitive;\n        });\n      }\n\n      return mesh;\n    }\n  }, {\n    key: \"_resolveMaterial\",\n    value: function _resolveMaterial(material, index) {\n      material.id = material.id || \"material-\".concat(index);\n\n      if (material.normalTexture) {\n        material.normalTexture = _objectSpread({}, material.normalTexture);\n        material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n      }\n\n      if (material.occlusionTexture) {\n        material.occlustionTexture = _objectSpread({}, material.occlustionTexture);\n        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n      }\n\n      if (material.emissiveTexture) {\n        material.emmisiveTexture = _objectSpread({}, material.emmisiveTexture);\n        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n      }\n\n      if (!material.emissiveFactor) {\n        material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n      }\n\n      if (material.pbrMetallicRoughness) {\n        material.pbrMetallicRoughness = _objectSpread({}, material.pbrMetallicRoughness);\n        var mr = material.pbrMetallicRoughness;\n\n        if (mr.baseColorTexture) {\n          mr.baseColorTexture = _objectSpread({}, mr.baseColorTexture);\n          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n        }\n\n        if (mr.metallicRoughnessTexture) {\n          mr.metallicRoughnessTexture = _objectSpread({}, mr.metallicRoughnessTexture);\n          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n        }\n      }\n\n      return material;\n    }\n  }, {\n    key: \"_resolveAccessor\",\n    value: function _resolveAccessor(accessor, index) {\n      accessor.id = accessor.id || \"accessor-\".concat(index);\n\n      if (accessor.bufferView !== undefined) {\n        accessor.bufferView = this.getBufferView(accessor.bufferView);\n      }\n\n      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n      accessor.components = getSizeFromAccessorType(accessor.type);\n      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n      if (accessor.bufferView) {\n        var buffer = accessor.bufferView.buffer;\n\n        var _getAccessorArrayType = getAccessorArrayTypeAndLength(accessor, accessor.bufferView),\n            ArrayType = _getAccessorArrayType.ArrayType,\n            byteLength = _getAccessorArrayType.byteLength;\n\n        var byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n        var cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n\n        if (accessor.bufferView.byteStride) {\n          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n        }\n\n        accessor.value = new ArrayType(cutBuffer);\n      }\n\n      return accessor;\n    }\n  }, {\n    key: \"_getValueFromInterleavedBuffer\",\n    value: function _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n      var result = new Uint8Array(count * bytesPerElement);\n\n      for (var i = 0; i < count; i++) {\n        var elementOffset = byteOffset + i * byteStride;\n        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n      }\n\n      return result.buffer;\n    }\n  }, {\n    key: \"_resolveTexture\",\n    value: function _resolveTexture(texture, index) {\n      texture.id = texture.id || \"texture-\".concat(index);\n      texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n      texture.source = this.getImage(texture.source);\n      return texture;\n    }\n  }, {\n    key: \"_resolveSampler\",\n    value: function _resolveSampler(sampler, index) {\n      sampler.id = sampler.id || \"sampler-\".concat(index);\n      sampler.parameters = {};\n\n      for (var key in sampler) {\n        var glEnum = this._enumSamplerParameter(key);\n\n        if (glEnum !== undefined) {\n          sampler.parameters[glEnum] = sampler[key];\n        }\n      }\n\n      return sampler;\n    }\n  }, {\n    key: \"_enumSamplerParameter\",\n    value: function _enumSamplerParameter(key) {\n      return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n    }\n  }, {\n    key: \"_resolveImage\",\n    value: function _resolveImage(image, index) {\n      image.id = image.id || \"image-\".concat(index);\n\n      if (image.bufferView !== undefined) {\n        image.bufferView = this.getBufferView(image.bufferView);\n      }\n\n      var preloadedImage = this.images[index];\n\n      if (preloadedImage) {\n        image.image = preloadedImage;\n      }\n\n      return image;\n    }\n  }, {\n    key: \"_resolveBufferView\",\n    value: function _resolveBufferView(bufferView, index) {\n      var bufferIndex = bufferView.buffer;\n\n      var result = _objectSpread({\n        id: \"bufferView-\".concat(index)\n      }, bufferView, {\n        buffer: this.buffers[bufferIndex]\n      });\n\n      var arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n      var byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n      if ('byteOffset' in bufferView) {\n        byteOffset += bufferView.byteOffset;\n      }\n\n      result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n      return result;\n    }\n  }, {\n    key: \"_resolveCamera\",\n    value: function _resolveCamera(camera, index) {\n      camera.id = camera.id || \"camera-\".concat(index);\n\n      if (camera.perspective) {}\n\n      if (camera.orthographic) {}\n\n      return camera;\n    }\n  }]);\n\n  return GLTFPostProcessor;\n}();\n\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}","map":{"version":3,"sources":["../../../../src/lib/api/post-process-gltf.ts"],"names":["COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTES","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","DEFAULT_SAMPLER","options","buffers","images","baseUri","assert","json","object","console","scene","node","child","mesh","accum","primitives","skin","primitive","attributes","material","normalTexture","occlustionTexture","emmisiveTexture","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","accessor","getBytesFromComponentType","getSizeFromAccessorType","buffer","byteLength","getAccessorArrayTypeAndLength","byteOffset","cutBuffer","result","count","i","elementOffset","texture","sampler","glEnum","image","preloadedImage","bufferIndex","bufferView","id","arrayBuffer","camera"],"mappings":"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","sourcesContent":["import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BufferView} from '../types/gltf-json-schema';\nimport {BufferView as BufferViewPostprocessed} from '../types/gltf-postprocessed-schema';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  baseUri: string = '';\n  json: Record<string, any> = {};\n  buffers: [] = [];\n  images: [] = [];\n\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(\n          buffer,\n          byteOffset,\n          accessor.bufferView.byteStride,\n          accessor.bytesPerElement,\n          accessor.count\n        );\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(\n        new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)),\n        i * bytesPerElement\n      );\n    }\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView: BufferView, index: number): BufferViewPostprocessed {\n    // bufferView = {...bufferView};\n    const bufferIndex = bufferView.buffer;\n    const result: BufferViewPostprocessed = {\n      id: `bufferView-${index}`,\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    // @ts-expect-error\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // @ts-expect-error\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options?) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n"]},"metadata":{},"sourceType":"module"}