{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isNumber, isObject } from 'vega-util';\nimport { getMarkPropOrConfig } from '../compile/common';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isEmpty, omit } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport const BOXPLOT = 'boxplot';\nexport const BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'];\nexport const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n  if (isNumber(extent)) {\n    return 'tukey';\n  } // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n\n\n  return extent;\n}\nexport function normalizeBoxPlot(spec, {\n  config\n}) {\n  var _a, _b; // Need to initEncoding first so we can infer type\n\n\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n\n  const {\n    mark,\n    encoding: _encoding,\n    params,\n    projection: _p\n  } = spec,\n        outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n\n  const markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (params) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  const extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;\n  const sizeValue = getMarkPropOrConfig('size', markDef, // TODO: https://github.com/vega/vega-lite/issues/6245\n  config);\n  const boxPlotType = getBoxPlotType(extent);\n  const {\n    bins,\n    timeUnits,\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    groupby,\n    aggregate,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    boxOrient,\n    customTooltipWithoutAggregatedField\n  } = boxParams(spec, extent, config);\n\n  const {\n    color,\n    size\n  } = encodingWithoutContinuousAxis,\n        encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n\n  const makeBoxPlotPart = sharedEncoding => {\n    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n  };\n\n  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? {\n    size\n  } : {}));\n  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([{\n    fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_',\n    titlePrefix: 'Max'\n  }, {\n    fieldPrefix: 'upper_box_',\n    titlePrefix: 'Q3'\n  }, {\n    fieldPrefix: 'mid_box_',\n    titlePrefix: 'Median'\n  }, {\n    fieldPrefix: 'lower_box_',\n    titlePrefix: 'Q1'\n  }, {\n    fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_',\n    titlePrefix: 'Min'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis); // ## Whisker Layers\n\n  const endTick = {\n    type: 'tick',\n    color: 'black',\n    opacity: 1,\n    orient: ticksOrient,\n    invalid: null,\n    aria: false\n  };\n  const whiskerTooltipEncoding = boxPlotType === 'min-max' ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n  : // for tukey / k-IQR, just show upper/lower-whisker\n  getCompositeMarkTooltip([{\n    fieldPrefix: 'upper_whisker_',\n    titlePrefix: 'Upper Whisker'\n  }, {\n    fieldPrefix: 'lower_whisker_',\n    titlePrefix: 'Lower Whisker'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n  const whiskerLayers = [...makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null,\n      aria: false\n    },\n    positionPrefix: 'lower_whisker',\n    endPositionPrefix: 'lower_box',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null,\n      aria: false\n    },\n    positionPrefix: 'upper_box',\n    endPositionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'lower_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })]; // ## Box Layers\n  // TODO: support hiding certain mark parts\n\n  const boxLayers = [...(boxPlotType !== 'tukey' ? whiskerLayers : []), ...makeBoxPlotBox({\n    partName: 'box',\n    mark: Object.assign(Object.assign({\n      type: 'bar'\n    }, sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: boxOrient,\n      invalid: null,\n      ariaRoleDescription: 'box'\n    }),\n    positionPrefix: 'lower_box',\n    endPositionPrefix: 'upper_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  }), ...makeBoxPlotMidTick({\n    partName: 'median',\n    mark: Object.assign(Object.assign(Object.assign({\n      type: 'tick',\n      invalid: null\n    }, isObject(config.boxplot.median) && config.boxplot.median.color ? {\n      color: config.boxplot.median.color\n    } : {}), sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: ticksOrient,\n      aria: false\n    }),\n    positionPrefix: 'mid_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })];\n\n  if (boxPlotType === 'min-max') {\n    return Object.assign(Object.assign({}, outerSpec), {\n      transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform),\n      layer: boxLayers\n    });\n  } // Tukey Box Plot\n\n\n  const lowerBoxExpr = `datum[\"lower_box_${continuousAxisChannelDef.field}\"]`;\n  const upperBoxExpr = `datum[\"upper_box_${continuousAxisChannelDef.field}\"]`;\n  const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n  const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n  const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n  const fieldExpr = `datum[\"${continuousAxisChannelDef.field}\"]`;\n  const joinaggregateTransform = {\n    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n    groupby\n  };\n  const filteredWhiskerSpec = {\n    transform: [{\n      filter: `(${lowerWhiskerExpr} <= ${fieldExpr}) && (${fieldExpr} <= ${upperWhiskerExpr})`\n    }, {\n      aggregate: [{\n        op: 'min',\n        field: continuousAxisChannelDef.field,\n        as: `lower_whisker_${continuousAxisChannelDef.field}`\n      }, {\n        op: 'max',\n        field: continuousAxisChannelDef.field,\n        as: `upper_whisker_${continuousAxisChannelDef.field}`\n      }, // preserve lower_box / upper_box\n      {\n        op: 'min',\n        field: `lower_box_${continuousAxisChannelDef.field}`,\n        as: `lower_box_${continuousAxisChannelDef.field}`\n      }, {\n        op: 'max',\n        field: `upper_box_${continuousAxisChannelDef.field}`,\n        as: `upper_box_${continuousAxisChannelDef.field}`\n      }, ...aggregate],\n      groupby\n    }],\n    layer: whiskerLayers\n  };\n\n  const {\n    tooltip\n  } = encodingWithoutSizeColorAndContinuousAxis,\n        encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n\n  const {\n    scale,\n    axis\n  } = continuousAxisChannelDef;\n  const title = getTitle(continuousAxisChannelDef);\n  const axisWithoutTitle = omit(axis, ['title']);\n  const outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n    transform: [{\n      filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})`\n    }],\n    mark: 'point',\n    encoding: Object.assign(Object.assign(Object.assign({\n      [continuousAxis]: Object.assign(Object.assign(Object.assign({\n        field: continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type\n      }, title !== undefined ? {\n        title\n      } : {}), scale !== undefined ? {\n        scale\n      } : {}), isEmpty(axisWithoutTitle) ? {} : {\n        axis: axisWithoutTitle\n      })\n    }, encodingWithoutSizeColorContinuousAxisAndTooltip), color ? {\n      color\n    } : {}), customTooltipWithoutAggregatedField ? {\n      tooltip: customTooltipWithoutAggregatedField\n    } : {})\n  })[0];\n  let filteredLayersMixins;\n  const filteredLayersMixinsTransforms = [...bins, ...timeUnits, joinaggregateTransform];\n\n  if (outlierLayersMixins) {\n    filteredLayersMixins = {\n      transform: filteredLayersMixinsTransforms,\n      layer: [outlierLayersMixins, filteredWhiskerSpec]\n    };\n  } else {\n    filteredLayersMixins = filteredWhiskerSpec;\n    filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    layer: [filteredLayersMixins, {\n      // boxplot\n      transform,\n      layer: boxLayers\n    }]\n  });\n}\n\nfunction boxParamsQuartiles(continousAxisField) {\n  return [{\n    op: 'q1',\n    field: continousAxisField,\n    as: `lower_box_${continousAxisField}`\n  }, {\n    op: 'q3',\n    field: continousAxisField,\n    as: `upper_box_${continousAxisField}`\n  }];\n}\n\nfunction boxParams(spec, extent, config) {\n  const orient = compositeMarkOrient(spec, BOXPLOT);\n  const {\n    continuousAxisChannelDef,\n    continuousAxis\n  } = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n  const continuousFieldName = continuousAxisChannelDef.field;\n  const boxPlotType = getBoxPlotType(extent);\n  const boxplotSpecificAggregate = [...boxParamsQuartiles(continuousFieldName), {\n    op: 'median',\n    field: continuousFieldName,\n    as: `mid_box_${continuousFieldName}`\n  }, {\n    op: 'min',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n  }, {\n    op: 'max',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n  }];\n  const postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey' ? [] : [// This is for the  original k-IQR, which we do not expose\n  {\n    calculate: `datum[\"upper_box_${continuousFieldName}\"] - datum[\"lower_box_${continuousFieldName}\"]`,\n    as: `iqr_${continuousFieldName}`\n  }, {\n    calculate: `min(datum[\"upper_box_${continuousFieldName}\"] + datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"max_${continuousFieldName}\"])`,\n    as: `upper_whisker_${continuousFieldName}`\n  }, {\n    calculate: `max(datum[\"lower_box_${continuousFieldName}\"] - datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"min_${continuousFieldName}\"])`,\n    as: `lower_whisker_${continuousFieldName}`\n  }];\n\n  const _a = spec.encoding,\n        _b = continuousAxis,\n        oldContinuousAxisChannelDef = _a[_b],\n        oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n  const {\n    customTooltipWithoutAggregatedField,\n    filteredEncoding\n  } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);\n  const {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(filteredEncoding, config);\n  const ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n  const boxOrient = orient;\n  const transform = [...bins, ...timeUnits, {\n    aggregate: [...aggregate, ...boxplotSpecificAggregate],\n    groupby\n  }, ...postAggregateCalculates];\n  return {\n    bins,\n    timeUnits,\n    transform,\n    groupby,\n    aggregate,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    boxOrient,\n    customTooltipWithoutAggregatedField\n  };\n}","map":{"version":3,"sources":["../../../src/compositemark/boxplot.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isNumber, isObject } from 'vega-util';\nimport { getMarkPropOrConfig } from '../compile/common';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isEmpty, omit } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport const BOXPLOT = 'boxplot';\nexport const BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'];\nexport const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n    if (isNumber(extent)) {\n        return 'tukey';\n    }\n    // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n    return extent;\n}\nexport function normalizeBoxPlot(spec, { config }) {\n    var _a, _b;\n    // Need to initEncoding first so we can infer type\n    spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });\n    const { mark, encoding: _encoding, params, projection: _p } = spec, outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n    const markDef = isMarkDef(mark) ? mark : { type: mark };\n    // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n    if (params) {\n        log.warn(log.message.selectionNotSupported('boxplot'));\n    }\n    const extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;\n    const sizeValue = getMarkPropOrConfig('size', markDef, // TODO: https://github.com/vega/vega-lite/issues/6245\n    config);\n    const boxPlotType = getBoxPlotType(extent);\n    const { bins, timeUnits, transform, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent, config);\n    const { color, size } = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n    const makeBoxPlotPart = (sharedEncoding) => {\n        return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n    };\n    const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n    const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n    const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), (size ? { size } : {})));\n    const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([\n        { fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_', titlePrefix: 'Max' },\n        { fieldPrefix: 'upper_box_', titlePrefix: 'Q3' },\n        { fieldPrefix: 'mid_box_', titlePrefix: 'Median' },\n        { fieldPrefix: 'lower_box_', titlePrefix: 'Q1' },\n        { fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_', titlePrefix: 'Min' }\n    ], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n    // ## Whisker Layers\n    const endTick = { type: 'tick', color: 'black', opacity: 1, orient: ticksOrient, invalid: null, aria: false };\n    const whiskerTooltipEncoding = boxPlotType === 'min-max'\n        ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n        : // for tukey / k-IQR, just show upper/lower-whisker\n            getCompositeMarkTooltip([\n                { fieldPrefix: 'upper_whisker_', titlePrefix: 'Upper Whisker' },\n                { fieldPrefix: 'lower_whisker_', titlePrefix: 'Lower Whisker' }\n            ], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n    const whiskerLayers = [\n        ...makeBoxPlotExtent({\n            partName: 'rule',\n            mark: { type: 'rule', invalid: null, aria: false },\n            positionPrefix: 'lower_whisker',\n            endPositionPrefix: 'lower_box',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'rule',\n            mark: { type: 'rule', invalid: null, aria: false },\n            positionPrefix: 'upper_box',\n            endPositionPrefix: 'upper_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'ticks',\n            mark: endTick,\n            positionPrefix: 'lower_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'ticks',\n            mark: endTick,\n            positionPrefix: 'upper_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        })\n    ];\n    // ## Box Layers\n    // TODO: support hiding certain mark parts\n    const boxLayers = [\n        ...(boxPlotType !== 'tukey' ? whiskerLayers : []),\n        ...makeBoxPlotBox({\n            partName: 'box',\n            mark: Object.assign(Object.assign({ type: 'bar' }, (sizeValue ? { size: sizeValue } : {})), { orient: boxOrient, invalid: null, ariaRoleDescription: 'box' }),\n            positionPrefix: 'lower_box',\n            endPositionPrefix: 'upper_box',\n            extraEncoding: fiveSummaryTooltipEncoding\n        }),\n        ...makeBoxPlotMidTick({\n            partName: 'median',\n            mark: Object.assign(Object.assign(Object.assign({ type: 'tick', invalid: null }, (isObject(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {})), (sizeValue ? { size: sizeValue } : {})), { orient: ticksOrient, aria: false }),\n            positionPrefix: 'mid_box',\n            extraEncoding: fiveSummaryTooltipEncoding\n        })\n    ];\n    if (boxPlotType === 'min-max') {\n        return Object.assign(Object.assign({}, outerSpec), { transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform), layer: boxLayers });\n    }\n    // Tukey Box Plot\n    const lowerBoxExpr = `datum[\"lower_box_${continuousAxisChannelDef.field}\"]`;\n    const upperBoxExpr = `datum[\"upper_box_${continuousAxisChannelDef.field}\"]`;\n    const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n    const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n    const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n    const fieldExpr = `datum[\"${continuousAxisChannelDef.field}\"]`;\n    const joinaggregateTransform = {\n        joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n        groupby\n    };\n    const filteredWhiskerSpec = {\n        transform: [\n            {\n                filter: `(${lowerWhiskerExpr} <= ${fieldExpr}) && (${fieldExpr} <= ${upperWhiskerExpr})`\n            },\n            {\n                aggregate: [\n                    {\n                        op: 'min',\n                        field: continuousAxisChannelDef.field,\n                        as: `lower_whisker_${continuousAxisChannelDef.field}`\n                    },\n                    {\n                        op: 'max',\n                        field: continuousAxisChannelDef.field,\n                        as: `upper_whisker_${continuousAxisChannelDef.field}`\n                    },\n                    // preserve lower_box / upper_box\n                    {\n                        op: 'min',\n                        field: `lower_box_${continuousAxisChannelDef.field}`,\n                        as: `lower_box_${continuousAxisChannelDef.field}`\n                    },\n                    {\n                        op: 'max',\n                        field: `upper_box_${continuousAxisChannelDef.field}`,\n                        as: `upper_box_${continuousAxisChannelDef.field}`\n                    },\n                    ...aggregate\n                ],\n                groupby\n            }\n        ],\n        layer: whiskerLayers\n    };\n    const { tooltip } = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n    const { scale, axis } = continuousAxisChannelDef;\n    const title = getTitle(continuousAxisChannelDef);\n    const axisWithoutTitle = omit(axis, ['title']);\n    const outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n        transform: [{ filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})` }],\n        mark: 'point',\n        encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, (title !== undefined ? { title } : {})), (scale !== undefined ? { scale } : {})), (isEmpty(axisWithoutTitle) ? {} : { axis: axisWithoutTitle })) }, encodingWithoutSizeColorContinuousAxisAndTooltip), (color ? { color } : {})), (customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {}))\n    })[0];\n    let filteredLayersMixins;\n    const filteredLayersMixinsTransforms = [...bins, ...timeUnits, joinaggregateTransform];\n    if (outlierLayersMixins) {\n        filteredLayersMixins = {\n            transform: filteredLayersMixinsTransforms,\n            layer: [outlierLayersMixins, filteredWhiskerSpec]\n        };\n    }\n    else {\n        filteredLayersMixins = filteredWhiskerSpec;\n        filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);\n    }\n    return Object.assign(Object.assign({}, outerSpec), { layer: [\n            filteredLayersMixins,\n            {\n                // boxplot\n                transform,\n                layer: boxLayers\n            }\n        ] });\n}\nfunction boxParamsQuartiles(continousAxisField) {\n    return [\n        {\n            op: 'q1',\n            field: continousAxisField,\n            as: `lower_box_${continousAxisField}`\n        },\n        {\n            op: 'q3',\n            field: continousAxisField,\n            as: `upper_box_${continousAxisField}`\n        }\n    ];\n}\nfunction boxParams(spec, extent, config) {\n    const orient = compositeMarkOrient(spec, BOXPLOT);\n    const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n    const continuousFieldName = continuousAxisChannelDef.field;\n    const boxPlotType = getBoxPlotType(extent);\n    const boxplotSpecificAggregate = [\n        ...boxParamsQuartiles(continuousFieldName),\n        {\n            op: 'median',\n            field: continuousFieldName,\n            as: `mid_box_${continuousFieldName}`\n        },\n        {\n            op: 'min',\n            field: continuousFieldName,\n            as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n        },\n        {\n            op: 'max',\n            field: continuousFieldName,\n            as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n        }\n    ];\n    const postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey'\n        ? []\n        : [\n            // This is for the  original k-IQR, which we do not expose\n            {\n                calculate: `datum[\"upper_box_${continuousFieldName}\"] - datum[\"lower_box_${continuousFieldName}\"]`,\n                as: `iqr_${continuousFieldName}`\n            },\n            {\n                calculate: `min(datum[\"upper_box_${continuousFieldName}\"] + datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"max_${continuousFieldName}\"])`,\n                as: `upper_whisker_${continuousFieldName}`\n            },\n            {\n                calculate: `max(datum[\"lower_box_${continuousFieldName}\"] - datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"min_${continuousFieldName}\"])`,\n                as: `lower_whisker_${continuousFieldName}`\n            }\n        ];\n    const _a = spec.encoding, _b = continuousAxis, oldContinuousAxisChannelDef = _a[_b], oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n    const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);\n    const { bins, timeUnits, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);\n    const ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n    const boxOrient = orient;\n    const transform = [\n        ...bins,\n        ...timeUnits,\n        {\n            aggregate: [...aggregate, ...boxplotSpecificAggregate],\n            groupby\n        },\n        ...postAggregateCalculates\n    ];\n    return {\n        bins,\n        timeUnits,\n        transform,\n        groupby,\n        aggregate,\n        continuousAxisChannelDef,\n        continuousAxis,\n        encodingWithoutContinuousAxis,\n        ticksOrient,\n        boxOrient,\n        customTooltipWithoutAggregatedField\n    };\n}\n//# sourceMappingURL=boxplot.js.map"]},"metadata":{},"sourceType":"module"}