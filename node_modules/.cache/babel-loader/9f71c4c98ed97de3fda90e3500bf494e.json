{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncIterator\";\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\nvar requestId = 0;\nvar inputBatches;\nvar options;\nexport function createWorker(process, processInBatches) {\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  var context = {\n    process: processOnMainThread\n  };\n\n  WorkerBody.onmessage = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, payload) {\n      var result, resultIterator, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, message;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.t0 = type;\n              _context.next = _context.t0 === 'process' ? 4 : _context.t0 === 'process-in-batches' ? 11 : _context.t0 === 'input-batch' ? 51 : _context.t0 === 'input-done' ? 53 : 55;\n              break;\n\n            case 4:\n              if (process) {\n                _context.next = 6;\n                break;\n              }\n\n              throw new Error('Worker does not support atomic processing');\n\n            case 6:\n              _context.next = 8;\n              return process(payload.input, payload.options || {}, context);\n\n            case 8:\n              result = _context.sent;\n              WorkerBody.postMessage('done', {\n                result: result\n              });\n              return _context.abrupt(\"break\", 55);\n\n            case 11:\n              if (processInBatches) {\n                _context.next = 13;\n                break;\n              }\n\n              throw new Error('Worker does not support batched processing');\n\n            case 13:\n              inputBatches = new AsyncQueue();\n              options = payload.options || {};\n              resultIterator = processInBatches(inputBatches, options, context === null || context === void 0 ? void 0 : context.processInBatches);\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 18;\n              _iterator = _asyncIterator(resultIterator);\n\n            case 20:\n              _context.next = 22;\n              return _iterator.next();\n\n            case 22:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 26;\n              return _step.value;\n\n            case 26:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 33;\n                break;\n              }\n\n              batch = _value;\n              WorkerBody.postMessage('output-batch', {\n                result: batch\n              });\n\n            case 30:\n              _iteratorNormalCompletion = true;\n              _context.next = 20;\n              break;\n\n            case 33:\n              _context.next = 39;\n              break;\n\n            case 35:\n              _context.prev = 35;\n              _context.t1 = _context[\"catch\"](18);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 39:\n              _context.prev = 39;\n              _context.prev = 40;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 44;\n                break;\n              }\n\n              _context.next = 44;\n              return _iterator.return();\n\n            case 44:\n              _context.prev = 44;\n\n              if (!_didIteratorError) {\n                _context.next = 47;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 47:\n              return _context.finish(44);\n\n            case 48:\n              return _context.finish(39);\n\n            case 49:\n              WorkerBody.postMessage('done', {});\n              return _context.abrupt(\"break\", 55);\n\n            case 51:\n              inputBatches.push(payload.input);\n              return _context.abrupt(\"break\", 55);\n\n            case 53:\n              inputBatches.close();\n              return _context.abrupt(\"break\", 55);\n\n            case 55:\n              _context.next = 61;\n              break;\n\n            case 57:\n              _context.prev = 57;\n              _context.t2 = _context[\"catch\"](0);\n              message = _context.t2 instanceof Error ? _context.t2.message : '';\n              WorkerBody.postMessage('error', {\n                error: message\n              });\n\n            case 61:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 57], [18, 35, 39, 49], [40,, 44, 48]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction processOnMainThread(arrayBuffer) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(function (resolve, reject) {\n    var id = requestId++;\n\n    var onMessage = function onMessage(type, payload) {\n      if (payload.id !== id) {\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n    var payload = {\n      id: id,\n      input: arrayBuffer,\n      options: options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}","map":{"version":3,"sources":["../../../../src/lib/worker-api/create-worker.ts"],"names":["requestId","context","process","processOnMainThread","WorkerBody","result","payload","inputBatches","options","resultIterator","processInBatches","batch","message","error","id","onMessage","resolve","reject","input"],"mappings":"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","sourcesContent":["import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n\nexport type ProcessOnMainThread = (data: any, options?: {[key: string]: any}, context?) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context?.processInBatches);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}