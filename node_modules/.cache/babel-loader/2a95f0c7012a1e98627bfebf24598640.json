{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\n\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n  // TODO: add special casing to add conditional value based on orient signal\n  return Object.assign.apply(null, [{}].concat(_toConsumableArray(configTypes.map(function (configType) {\n    if (configType === 'axisOrient') {\n      var orient1 = channel === 'x' ? 'bottom' : 'left';\n      var orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n      var orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n      var props = new Set([].concat(_toConsumableArray(keys(orientConfig1)), _toConsumableArray(keys(orientConfig2))));\n      var conditionalOrientAxisConfig = {};\n\n      var _iterator = _createForOfIteratorHelper(props.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n          conditionalOrientAxisConfig[prop] = {\n            // orient is surely signal in this case\n            signal: \"\".concat(orient['signal'], \" === \\\"\").concat(orient1, \"\\\" ? \").concat(signalOrStringValue(orientConfig1[prop]), \" : \").concat(signalOrStringValue(orientConfig2[prop]))\n          };\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return conditionalOrientAxisConfig;\n    }\n\n    return config[configType];\n  }))));\n}\n\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n  var typeBasedConfigTypes = scaleType === 'band' ? ['axisDiscrete', 'axisBand'] : scaleType === 'point' ? ['axisDiscrete', 'axisPoint'] : isQuantitative(scaleType) ? ['axisQuantitative'] : scaleType === 'time' || scaleType === 'utc' ? ['axisTemporal'] : [];\n  var axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n  var axisOrient = isSignalRef(orient) ? 'axisOrient' : \"axis\".concat(titleCase(orient)); // axisTop, axisBottom, ...\n\n  var vlOnlyConfigTypes = [].concat(typeBasedConfigTypes, _toConsumableArray(typeBasedConfigTypes.map(function (c) {\n    return axisChannel + c.substr(4);\n  })));\n  var vgConfigTypes = ['axis', axisOrient, axisChannel];\n  return {\n    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n    axisConfigStyle: getAxisConfigStyle([].concat(vgConfigTypes, _toConsumableArray(vlOnlyConfigTypes)), config)\n  };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n  var _a;\n\n  var toMerge = [{}];\n\n  var _iterator2 = _createForOfIteratorHelper(axisConfigTypes),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var configType = _step2.value;\n      // TODO: add special casing to add conditional value based on orient signal\n      var style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;\n\n      if (style) {\n        style = array(style);\n\n        var _iterator3 = _createForOfIteratorHelper(style),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var s = _step3.value;\n            toMerge.push(config.style[s]);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style) {\n  var axisConfigs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var _a;\n\n  var styleConfig = getStyleConfig(property, style, styleConfigIndex);\n\n  if (styleConfig !== undefined) {\n    return {\n      configFrom: 'style',\n      configValue: styleConfig\n    };\n  }\n\n  for (var _i = 0, _arr = ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']; _i < _arr.length; _i++) {\n    var configFrom = _arr[_i];\n\n    if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {\n      return {\n        configFrom: configFrom,\n        configValue: axisConfigs[configFrom][property]\n      };\n    }\n  }\n\n  return {};\n}","map":{"version":3,"sources":["../../../../src/compile/axis/config.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n    // TODO: add special casing to add conditional value based on orient signal\n    return Object.assign.apply(null, [\n        {},\n        ...configTypes.map(configType => {\n            if (configType === 'axisOrient') {\n                const orient1 = channel === 'x' ? 'bottom' : 'left';\n                const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n                const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n                const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n                const conditionalOrientAxisConfig = {};\n                for (const prop of props.values()) {\n                    conditionalOrientAxisConfig[prop] = {\n                        // orient is surely signal in this case\n                        signal: `${orient['signal']} === \"${orient1}\" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`\n                    };\n                }\n                return conditionalOrientAxisConfig;\n            }\n            return config[configType];\n        })\n    ]);\n}\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n    const typeBasedConfigTypes = scaleType === 'band'\n        ? ['axisDiscrete', 'axisBand']\n        : scaleType === 'point'\n            ? ['axisDiscrete', 'axisPoint']\n            : isQuantitative(scaleType)\n                ? ['axisQuantitative']\n                : scaleType === 'time' || scaleType === 'utc'\n                    ? ['axisTemporal']\n                    : [];\n    const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n    const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n    const vlOnlyConfigTypes = [\n        // technically Vega does have axisBand, but if we make another separation here,\n        // it will further introduce complexity in the code\n        ...typeBasedConfigTypes,\n        ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))\n    ];\n    const vgConfigTypes = ['axis', axisOrient, axisChannel];\n    return {\n        vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n        vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n        axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n    };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n    var _a;\n    const toMerge = [{}];\n    for (const configType of axisConfigTypes) {\n        // TODO: add special casing to add conditional value based on orient signal\n        let style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;\n        if (style) {\n            style = array(style);\n            for (const s of style) {\n                toMerge.push(config.style[s]);\n            }\n        }\n    }\n    return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style, axisConfigs = {}) {\n    var _a;\n    const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n    if (styleConfig !== undefined) {\n        return {\n            configFrom: 'style',\n            configValue: styleConfig\n        };\n    }\n    for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {\n        if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {\n            return { configFrom, configValue: axisConfigs[configFrom][property] };\n        }\n    }\n    return {};\n}\n//# sourceMappingURL=config.js.map"]},"metadata":{},"sourceType":"module"}