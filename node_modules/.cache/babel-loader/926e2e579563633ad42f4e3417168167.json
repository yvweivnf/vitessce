{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash as _hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\n\nfunction addDimension(dims, channel, fieldDef, model) {\n  var _a;\n\n  var channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {\n      suffix: 'end'\n    }));\n\n    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {\n        binSuffix: 'range'\n      }));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    var posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n\n  if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {\n    dims.add(fieldDef.scale.range.field);\n  }\n\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures, childMeasures) {\n  var _a;\n\n  var _iterator = _createForOfIteratorHelper(keys(childMeasures)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var field = _step.value;\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      var ops = childMeasures[field];\n\n      var _iterator2 = _createForOfIteratorHelper(keys(ops)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var op = _step2.value;\n\n          if (field in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[field][op] = new Set([].concat(_toConsumableArray((_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : []), _toConsumableArray(ops[op])));\n          } else {\n            parentMeasures[field] = _defineProperty({}, op, ops[op]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nexport var AggregateNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(AggregateNode, _DataFlowNode);\n\n  var _super = _createSuper(AggregateNode);\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  function AggregateNode(parent, dimensions, measures) {\n    var _this;\n\n    _classCallCheck(this, AggregateNode);\n\n    _this = _super.call(this, parent);\n    _this.dimensions = dimensions;\n    _this.measures = measures;\n    return _this;\n  }\n\n  _createClass(AggregateNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (setEqual(this.dimensions, other.dimensions)) {\n        mergeMeasures(this.measures, other.measures);\n        return true;\n      } else {\n        log.debug('different dimensions, cannot merge');\n        return false;\n      }\n    }\n  }, {\n    key: \"addDimensions\",\n    value: function addDimensions(fields) {\n      fields.forEach(this.dimensions.add, this.dimensions);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set([].concat(_toConsumableArray(this.dimensions), _toConsumableArray(keys(this.measures))));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      var out = new Set();\n\n      var _iterator3 = _createForOfIteratorHelper(keys(this.measures)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var field = _step3.value;\n\n          var _iterator4 = _createForOfIteratorHelper(keys(this.measures[field])),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var op = _step4.value;\n              var m = this.measures[field][op];\n\n              if (m.size === 0) {\n                out.add(\"\".concat(op, \"_\").concat(field));\n              } else {\n                m.forEach(out.add, out);\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return out;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Aggregate \".concat(_hash({\n        dimensions: this.dimensions,\n        measures: this.measures\n      }));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var ops = [];\n      var fields = [];\n      var as = [];\n\n      var _iterator5 = _createForOfIteratorHelper(keys(this.measures)),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var field = _step5.value;\n\n          var _iterator6 = _createForOfIteratorHelper(keys(this.measures[field])),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var op = _step6.value;\n\n              var _iterator7 = _createForOfIteratorHelper(this.measures[field][op]),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var alias = _step7.value;\n                  as.push(alias);\n                  ops.push(op);\n                  fields.push(field === '*' ? null : replacePathInField(field));\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var result = {\n        type: 'aggregate',\n        groupby: _toConsumableArray(this.dimensions).map(replacePathInField),\n        ops: ops,\n        fields: fields,\n        as: as\n      };\n      return result;\n    }\n  }, {\n    key: \"groupBy\",\n    get: function get() {\n      return this.dimensions;\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var isAggregate = false;\n      model.forEachFieldDef(function (fd) {\n        if (fd.aggregate) {\n          isAggregate = true;\n        }\n      });\n      var meas = {};\n      var dims = new Set();\n\n      if (!isAggregate) {\n        // no need to create this node if the model has no aggregation\n        return null;\n      }\n\n      model.forEachFieldDef(function (fieldDef, channel) {\n        var _a, _b, _c, _d;\n\n        var aggregate = fieldDef.aggregate,\n            field = fieldDef.field;\n\n        if (aggregate) {\n          if (aggregate === 'count') {\n            (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n            meas['*']['count'] = new Set([vgField(fieldDef, {\n              forAs: true\n            })]);\n          } else {\n            if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n              var op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n              var argField = aggregate[op];\n              (_b = meas[argField]) !== null && _b !== void 0 ? _b : meas[argField] = {};\n              meas[argField][op] = new Set([vgField({\n                op: op,\n                field: argField\n              }, {\n                forAs: true\n              })]);\n            } else {\n              (_c = meas[field]) !== null && _c !== void 0 ? _c : meas[field] = {};\n              meas[field][aggregate] = new Set([vgField(fieldDef, {\n                forAs: true\n              })]);\n            } // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n\n\n            if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n              (_d = meas[field]) !== null && _d !== void 0 ? _d : meas[field] = {};\n              meas[field]['min'] = new Set([vgField({\n                field: field,\n                aggregate: 'min'\n              }, {\n                forAs: true\n              })]);\n              meas[field]['max'] = new Set([vgField({\n                field: field,\n                aggregate: 'max'\n              }, {\n                forAs: true\n              })]);\n            }\n          }\n        } else {\n          addDimension(dims, channel, fieldDef, model);\n        }\n      });\n\n      if (dims.size + keys(meas).length === 0) {\n        return null;\n      }\n\n      return new AggregateNode(parent, dims, meas);\n    }\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t) {\n      var _a, _b, _c;\n\n      var dims = new Set();\n      var meas = {};\n\n      var _iterator8 = _createForOfIteratorHelper(t.aggregate),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var s = _step8.value;\n          var op = s.op,\n              field = s.field,\n              as = s.as;\n\n          if (op) {\n            if (op === 'count') {\n              (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n              meas['*']['count'] = new Set([as ? as : vgField(s, {\n                forAs: true\n              })]);\n            } else {\n              (_b = meas[field]) !== null && _b !== void 0 ? _b : meas[field] = {};\n              meas[field][op] = new Set([as ? as : vgField(s, {\n                forAs: true\n              })]);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      var _iterator9 = _createForOfIteratorHelper((_c = t.groupby) !== null && _c !== void 0 ? _c : []),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _s = _step9.value;\n          dims.add(_s);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      if (dims.size + keys(meas).length === 0) {\n        return null;\n      }\n\n      return new AggregateNode(parent, dims, meas);\n    }\n  }]);\n\n  return AggregateNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nfunction addDimension(dims, channel, fieldDef, model) {\n    var _a;\n    const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n    if (isTypedFieldDef(fieldDef) &&\n        isUnitModel(model) &&\n        hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n        dims.add(vgField(fieldDef, {}));\n        dims.add(vgField(fieldDef, { suffix: 'end' }));\n        if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n            dims.add(vgField(fieldDef, { binSuffix: 'range' }));\n        }\n    }\n    else if (isGeoPositionChannel(channel)) {\n        const posChannel = getPositionChannelFromLatLong(channel);\n        dims.add(model.getName(posChannel));\n    }\n    else {\n        dims.add(vgField(fieldDef));\n    }\n    if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {\n        dims.add(fieldDef.scale.range.field);\n    }\n    return dims;\n}\nfunction mergeMeasures(parentMeasures, childMeasures) {\n    var _a;\n    for (const field of keys(childMeasures)) {\n        // when we merge a measure, we either have to add an aggregation operator or even a new field\n        const ops = childMeasures[field];\n        for (const op of keys(ops)) {\n            if (field in parentMeasures) {\n                // add operator to existing measure field\n                parentMeasures[field][op] = new Set([...((_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : []), ...ops[op]]);\n            }\n            else {\n                parentMeasures[field] = { [op]: ops[op] };\n            }\n        }\n    }\n}\nexport class AggregateNode extends DataFlowNode {\n    /**\n     * @param dimensions string set for dimensions\n     * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n     */\n    constructor(parent, dimensions, measures) {\n        super(parent);\n        this.dimensions = dimensions;\n        this.measures = measures;\n    }\n    clone() {\n        return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n    }\n    get groupBy() {\n        return this.dimensions;\n    }\n    static makeFromEncoding(parent, model) {\n        let isAggregate = false;\n        model.forEachFieldDef(fd => {\n            if (fd.aggregate) {\n                isAggregate = true;\n            }\n        });\n        const meas = {};\n        const dims = new Set();\n        if (!isAggregate) {\n            // no need to create this node if the model has no aggregation\n            return null;\n        }\n        model.forEachFieldDef((fieldDef, channel) => {\n            var _a, _b, _c, _d;\n            const { aggregate, field } = fieldDef;\n            if (aggregate) {\n                if (aggregate === 'count') {\n                    (_a = meas['*']) !== null && _a !== void 0 ? _a : (meas['*'] = {});\n                    meas['*']['count'] = new Set([vgField(fieldDef, { forAs: true })]);\n                }\n                else {\n                    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n                        const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n                        const argField = aggregate[op];\n                        (_b = meas[argField]) !== null && _b !== void 0 ? _b : (meas[argField] = {});\n                        meas[argField][op] = new Set([vgField({ op, field: argField }, { forAs: true })]);\n                    }\n                    else {\n                        (_c = meas[field]) !== null && _c !== void 0 ? _c : (meas[field] = {});\n                        meas[field][aggregate] = new Set([vgField(fieldDef, { forAs: true })]);\n                    }\n                    // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n                    if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n                        (_d = meas[field]) !== null && _d !== void 0 ? _d : (meas[field] = {});\n                        meas[field]['min'] = new Set([vgField({ field, aggregate: 'min' }, { forAs: true })]);\n                        meas[field]['max'] = new Set([vgField({ field, aggregate: 'max' }, { forAs: true })]);\n                    }\n                }\n            }\n            else {\n                addDimension(dims, channel, fieldDef, model);\n            }\n        });\n        if (dims.size + keys(meas).length === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    }\n    static makeFromTransform(parent, t) {\n        var _a, _b, _c;\n        const dims = new Set();\n        const meas = {};\n        for (const s of t.aggregate) {\n            const { op, field, as } = s;\n            if (op) {\n                if (op === 'count') {\n                    (_a = meas['*']) !== null && _a !== void 0 ? _a : (meas['*'] = {});\n                    meas['*']['count'] = new Set([as ? as : vgField(s, { forAs: true })]);\n                }\n                else {\n                    (_b = meas[field]) !== null && _b !== void 0 ? _b : (meas[field] = {});\n                    meas[field][op] = new Set([as ? as : vgField(s, { forAs: true })]);\n                }\n            }\n        }\n        for (const s of (_c = t.groupby) !== null && _c !== void 0 ? _c : []) {\n            dims.add(s);\n        }\n        if (dims.size + keys(meas).length === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    }\n    merge(other) {\n        if (setEqual(this.dimensions, other.dimensions)) {\n            mergeMeasures(this.measures, other.measures);\n            return true;\n        }\n        else {\n            log.debug('different dimensions, cannot merge');\n            return false;\n        }\n    }\n    addDimensions(fields) {\n        fields.forEach(this.dimensions.add, this.dimensions);\n    }\n    dependentFields() {\n        return new Set([...this.dimensions, ...keys(this.measures)]);\n    }\n    producedFields() {\n        const out = new Set();\n        for (const field of keys(this.measures)) {\n            for (const op of keys(this.measures[field])) {\n                const m = this.measures[field][op];\n                if (m.size === 0) {\n                    out.add(`${op}_${field}`);\n                }\n                else {\n                    m.forEach(out.add, out);\n                }\n            }\n        }\n        return out;\n    }\n    hash() {\n        return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;\n    }\n    assemble() {\n        const ops = [];\n        const fields = [];\n        const as = [];\n        for (const field of keys(this.measures)) {\n            for (const op of keys(this.measures[field])) {\n                for (const alias of this.measures[field][op]) {\n                    as.push(alias);\n                    ops.push(op);\n                    fields.push(field === '*' ? null : replacePathInField(field));\n                }\n            }\n        }\n        const result = {\n            type: 'aggregate',\n            groupby: [...this.dimensions].map(replacePathInField),\n            ops,\n            fields,\n            as\n        };\n        return result;\n    }\n}\n//# sourceMappingURL=aggregate.js.map"]},"metadata":{},"sourceType":"module"}