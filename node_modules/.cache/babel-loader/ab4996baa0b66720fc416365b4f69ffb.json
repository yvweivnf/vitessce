{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\nimport AttributeTransitionManager from './attribute-transition-manager';\nvar TRACE_INVALIDATE = 'attributeManager.invalidate';\nvar TRACE_UPDATE_START = 'attributeManager.updateStart';\nvar TRACE_UPDATE_END = 'attributeManager.updateEnd';\nvar TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nvar TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nvar TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nvar AttributeManager = /*#__PURE__*/function () {\n  function AttributeManager(gl) {\n    _classCallCheck(this, AttributeManager);\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$id = _ref.id,\n        id = _ref$id === void 0 ? 'attribute-manager' : _ref$id,\n        stats = _ref.stats,\n        timeline = _ref.timeline;\n\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\"),\n      timeline: timeline\n    });\n    Object.seal(this);\n  }\n\n  _createClass(AttributeManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].delete();\n      }\n\n      this.attributeTransitionManager.finalize();\n    }\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n      return redraw && this.id;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = true;\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(attributes, updaters) {\n      this._add(attributes, updaters);\n    }\n  }, {\n    key: \"addInstanced\",\n    value: function addInstanced(attributes, updaters) {\n      this._add(attributes, updaters, {\n        instanced: 1\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(attributeNameArray) {\n      for (var i = 0; i < attributeNameArray.length; i++) {\n        var name = attributeNameArray[i];\n\n        if (this.attributes[name] !== undefined) {\n          this.attributes[name].delete();\n          delete this.attributes[name];\n        }\n      }\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(triggerName, dataRange) {\n      var invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n\n      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n    }\n  }, {\n    key: \"invalidateAll\",\n    value: function invalidateAll(dataRange) {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n      }\n\n      debug(TRACE_INVALIDATE, this, 'all');\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          data = _ref2.data,\n          numInstances = _ref2.numInstances,\n          _ref2$startIndices = _ref2.startIndices,\n          startIndices = _ref2$startIndices === void 0 ? null : _ref2$startIndices,\n          transitions = _ref2.transitions,\n          _ref2$props = _ref2.props,\n          props = _ref2$props === void 0 ? {} : _ref2$props,\n          _ref2$buffers = _ref2.buffers,\n          buffers = _ref2$buffers === void 0 ? {} : _ref2$buffers,\n          _ref2$context = _ref2.context,\n          context = _ref2$context === void 0 ? {} : _ref2$context;\n\n      var updated = false;\n      debug(TRACE_UPDATE_START, this);\n\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeStart();\n      }\n\n      for (var attributeName in this.attributes) {\n        var attribute = this.attributes[attributeName];\n        var accessorName = attribute.settings.accessor;\n        attribute.startIndices = startIndices;\n\n        if (props[attributeName]) {\n          log.removed(\"props.\".concat(attributeName), \"data.attributes.\".concat(attributeName))();\n        }\n\n        if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {} else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {\n          updated = true;\n\n          this._updateAttribute({\n            attribute: attribute,\n            numInstances: numInstances,\n            data: data,\n            props: props,\n            context: context\n          });\n        }\n\n        this.needsRedraw |= attribute.needsRedraw();\n      }\n\n      if (updated) {\n        debug(TRACE_UPDATE_END, this, numInstances);\n      }\n\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeEnd();\n      }\n\n      this.attributeTransitionManager.update({\n        attributes: this.attributes,\n        numInstances: numInstances,\n        transitions: transitions\n      });\n    }\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition() {\n      var attributeTransitionManager = this.attributeTransitionManager;\n      var transitionUpdated = attributeTransitionManager.run();\n      this.needsRedraw = this.needsRedraw || transitionUpdated;\n      return transitionUpdated;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getChangedAttributes\",\n    value: function getChangedAttributes() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearChangedFlags: false\n      };\n      var attributes = this.attributes,\n          attributeTransitionManager = this.attributeTransitionManager;\n\n      var changedAttributes = _objectSpread({}, attributeTransitionManager.getAttributes());\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n          changedAttributes[attributeName] = attribute;\n        }\n      }\n\n      return changedAttributes;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes(attributes) {\n      var excludeAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!attributes) {\n        attributes = this.getAttributes();\n      }\n\n      var shaderAttributes = {};\n\n      for (var attributeName in attributes) {\n        if (!excludeAttributes[attributeName]) {\n          Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n        }\n      }\n\n      return shaderAttributes;\n    }\n  }, {\n    key: \"getAccessors\",\n    value: function getAccessors() {\n      return this.updateTriggers;\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(attributes, updaters) {\n      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (updaters) {\n        log.warn('AttributeManager.add({updaters}) - updater map no longer supported')();\n      }\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n      }\n\n      this._mapUpdateTriggersToAttributes();\n    }\n  }, {\n    key: \"_createAttribute\",\n    value: function _createAttribute(name, attribute, extraProps) {\n      var props = _objectSpread({}, attribute, {\n        id: name,\n        isIndexed: attribute.isIndexed || attribute.elements || false,\n        constant: attribute.constant || false,\n        size: attribute.elements && 1 || attribute.size || 1,\n        value: attribute.value || null,\n        divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor || 0\n      });\n\n      return new Attribute(this.gl, props);\n    }\n  }, {\n    key: \"_mapUpdateTriggersToAttributes\",\n    value: function _mapUpdateTriggersToAttributes() {\n      var _this = this;\n\n      var triggers = {};\n\n      var _loop = function _loop(attributeName) {\n        var attribute = _this.attributes[attributeName];\n        attribute.getUpdateTriggers().forEach(function (triggerName) {\n          if (!triggers[triggerName]) {\n            triggers[triggerName] = [];\n          }\n\n          triggers[triggerName].push(attributeName);\n        });\n      };\n\n      for (var attributeName in this.attributes) {\n        _loop(attributeName);\n      }\n\n      this.updateTriggers = triggers;\n    }\n  }, {\n    key: \"_invalidateTrigger\",\n    value: function _invalidateTrigger(triggerName, dataRange) {\n      var attributes = this.attributes,\n          updateTriggers = this.updateTriggers;\n      var invalidatedAttributes = updateTriggers[triggerName];\n\n      if (invalidatedAttributes) {\n        invalidatedAttributes.forEach(function (name) {\n          var attribute = attributes[name];\n\n          if (attribute) {\n            attribute.setNeedsUpdate(attribute.id, dataRange);\n          }\n        });\n      }\n\n      return invalidatedAttributes;\n    }\n  }, {\n    key: \"_updateAttribute\",\n    value: function _updateAttribute(opts) {\n      var attribute = opts.attribute,\n          numInstances = opts.numInstances;\n      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n      if (attribute.constant) {\n        attribute.setConstantValue(attribute.value);\n        return;\n      }\n\n      if (attribute.allocate(numInstances)) {\n        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n      }\n\n      var updated = attribute.updateBuffer(opts);\n\n      if (updated) {\n        this.needsRedraw = true;\n        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n      }\n    }\n  }]);\n\n  return AttributeManager;\n}();\n\nexport { AttributeManager as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-manager.js"],"names":["TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","constructor","id","timeline","Object","opts","clearRedrawFlags","redraw","instanced","i","attributeNameArray","name","invalidatedAttributes","debug","startIndices","props","buffers","context","updated","attribute","accessorName","log","data","numInstances","attributes","transitions","attributeTransitionManager","transitionUpdated","clearChangedFlags","changedAttributes","excludeAttributes","shaderAttributes","extraProps","isIndexed","constant","size","value","divisor","triggers","triggerName","updateTriggers"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  constructor(gl, {id = 'attribute-manager', stats, timeline} = {}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts = {clearRedrawFlags: false}) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  // @return {AttributeManager} - for chaining\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = true;\n    return this;\n  }\n\n  // Adds attributes\n  add(attributes, updaters) {\n    this._add(attributes, updaters);\n  }\n\n  // Adds attributes\n  addInstanced(attributes, updaters) {\n    this._add(attributes, updaters, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (let i = 0; i < attributeNameArray.length; i++) {\n      const name = attributeNameArray[i];\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  } = {}) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {\n        // Step 2: try set packed value from external typed array\n      } else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw |= attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts = {clearChangedFlags: false}) {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = {...attributeTransitionManager.getAttributes()};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  // Returns shader attributes\n  getShaderAttributes(attributes, excludeAttributes = {}) {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n\n  // PROTECTED METHODS - Only to be used by collaborating classes, not by apps\n\n  // Returns object containing all accessors as keys, with non-null values\n  // @return {Object} - accessors object\n  getAccessors() {\n    return this.updateTriggers;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  _add(attributes, updaters, extraProps = {}) {\n    if (updaters) {\n      log.warn('AttributeManager.add({updaters}) - updater map no longer supported')();\n    }\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  _createAttribute(name, attribute, extraProps) {\n    // For expected default values see:\n    // https://github.com/visgl/luma.gl/blob/1affe21352e289eeaccee2a876865138858a765c/modules/webgl/src/classes/accessor.js#L5-L13\n    // and https://deck.gl/docs/api-reference/core/attribute-manager#add\n    const props = {\n      ...attribute,\n      id: name,\n      isIndexed: attribute.isIndexed || attribute.elements || false,\n      // Luma fields\n      constant: attribute.constant || false,\n      size: (attribute.elements && 1) || attribute.size || 1,\n      value: attribute.value || null,\n      divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n\n    return new Attribute(this.gl, props);\n  }\n\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _invalidateTrigger(triggerName, dataRange) {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  _updateAttribute(opts) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}