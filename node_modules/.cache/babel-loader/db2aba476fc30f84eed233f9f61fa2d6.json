{"ast":null,"code":"import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoJSONNode extends DataFlowNode {\n  constructor(parent, fields, geojson, signal) {\n    super(parent);\n    this.fields = fields;\n    this.geojson = geojson;\n    this.signal = signal;\n  }\n\n  clone() {\n    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n  }\n\n  static parseAll(parent, model) {\n    if (model.component.projection && !model.component.projection.isFit) {\n      return parent;\n    }\n\n    let geoJsonCounter = 0;\n\n    for (const coordinates of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {\n      const pair = coordinates.map(channel => {\n        const def = getFieldOrDatumDef(model.encoding[channel]);\n        return isFieldDef(def) ? def.field : isDatumDef(def) ? {\n          expr: `${def.datum}`\n        } : isValueDef(def) ? {\n          expr: `${def['value']}`\n        } : undefined;\n      });\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    if (model.channelHasField(SHAPE)) {\n      const fieldDef = model.typedFieldDef(SHAPE);\n\n      if (fieldDef.type === GEOJSON) {\n        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    return parent;\n  }\n\n  dependentFields() {\n    var _a;\n\n    const fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString);\n    return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);\n  }\n\n  producedFields() {\n    return new Set();\n  }\n\n  hash() {\n    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;\n  }\n\n  assemble() {\n    return [...(this.geojson ? [{\n      type: 'filter',\n      expr: `isValid(datum[\"${this.geojson}\"])`\n    }] : []), Object.assign(Object.assign(Object.assign({\n      type: 'geojson'\n    }, this.fields ? {\n      fields: this.fields\n    } : {}), this.geojson ? {\n      geojson: this.geojson\n    } : {}), {\n      signal: this.signal\n    })];\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/geojson.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoJSONNode extends DataFlowNode {\n    constructor(parent, fields, geojson, signal) {\n        super(parent);\n        this.fields = fields;\n        this.geojson = geojson;\n        this.signal = signal;\n    }\n    clone() {\n        return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n    }\n    static parseAll(parent, model) {\n        if (model.component.projection && !model.component.projection.isFit) {\n            return parent;\n        }\n        let geoJsonCounter = 0;\n        for (const coordinates of [\n            [LONGITUDE, LATITUDE],\n            [LONGITUDE2, LATITUDE2]\n        ]) {\n            const pair = coordinates.map(channel => {\n                const def = getFieldOrDatumDef(model.encoding[channel]);\n                return isFieldDef(def)\n                    ? def.field\n                    : isDatumDef(def)\n                        ? { expr: `${def.datum}` }\n                        : isValueDef(def)\n                            ? { expr: `${def['value']}` }\n                            : undefined;\n            });\n            if (pair[0] || pair[1]) {\n                parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n            }\n        }\n        if (model.channelHasField(SHAPE)) {\n            const fieldDef = model.typedFieldDef(SHAPE);\n            if (fieldDef.type === GEOJSON) {\n                parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n            }\n        }\n        return parent;\n    }\n    dependentFields() {\n        var _a;\n        const fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString);\n        return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);\n    }\n    producedFields() {\n        return new Set();\n    }\n    hash() {\n        return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;\n    }\n    assemble() {\n        return [\n            ...(this.geojson\n                ? [\n                    {\n                        type: 'filter',\n                        expr: `isValid(datum[\"${this.geojson}\"])`\n                    }\n                ]\n                : []),\n            Object.assign(Object.assign(Object.assign({ type: 'geojson' }, (this.fields ? { fields: this.fields } : {})), (this.geojson ? { geojson: this.geojson } : {})), { signal: this.signal })\n        ];\n    }\n}\n//# sourceMappingURL=geojson.js.map"]},"metadata":{},"sourceType":"module"}