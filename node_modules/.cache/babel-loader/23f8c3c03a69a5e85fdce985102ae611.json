{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nexport function transformBinaryCoords(binaryFeatures, transformCoordinate) {\n  if (binaryFeatures.points) {\n    transformBinaryGeometryPositions(binaryFeatures.points, transformCoordinate);\n  }\n\n  if (binaryFeatures.lines) {\n    transformBinaryGeometryPositions(binaryFeatures.lines, transformCoordinate);\n  }\n\n  if (binaryFeatures.polygons) {\n    transformBinaryGeometryPositions(binaryFeatures.polygons, transformCoordinate);\n  }\n\n  return binaryFeatures;\n}\n\nfunction transformBinaryGeometryPositions(binaryGeometry, fn) {\n  var positions = binaryGeometry.positions;\n\n  for (var i = 0; i < positions.value.length; i += positions.size) {\n    var coord = Array.from(positions.value.subarray(i, i + positions.size));\n    var transformedCoord = fn(coord);\n    positions.value.set(transformedCoord, i);\n  }\n}\n\nexport function transformGeoJsonCoords(features, fn) {\n  var _iterator = _createForOfIteratorHelper(features),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var feature = _step.value;\n      feature.geometry.coordinates = coordMap(feature.geometry.coordinates, fn);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return features;\n}\n\nfunction coordMap(array, fn) {\n  if (isCoord(array)) {\n    return fn(array);\n  }\n\n  return array.map(function (item) {\n    return coordMap(item, fn);\n  });\n}\n\nfunction isCoord(array) {\n  return Number.isFinite(array[0]) && Number.isFinite(array[1]);\n}","map":{"version":3,"sources":["../../../src/lib/transform.ts"],"names":["binaryFeatures","transformBinaryGeometryPositions","positions","i","coord","Array","transformedCoord","fn","feature","coordMap","isCoord","item","Number","array"],"mappings":";AAUA,OAAO,SAAA,qBAAA,CAAA,cAAA,EAAA,mBAAA,EAGW;AAChB,MAAIA,cAAc,CAAlB,MAAA,EAA2B;AACzBC,IAAAA,gCAAgC,CAACD,cAAc,CAAf,MAAA,EAAhCC,mBAAgC,CAAhCA;AACD;;AACD,MAAID,cAAc,CAAlB,KAAA,EAA0B;AACxBC,IAAAA,gCAAgC,CAACD,cAAc,CAAf,KAAA,EAAhCC,mBAAgC,CAAhCA;AACD;;AACD,MAAID,cAAc,CAAlB,QAAA,EAA6B;AAC3BC,IAAAA,gCAAgC,CAACD,cAAc,CAAf,QAAA,EAAhCC,mBAAgC,CAAhCA;AACD;;AACD,SAAA,cAAA;AACD;;AAGD,SAAA,gCAAA,CAAA,cAAA,EAAA,EAAA,EAAmG;AAAA,MAC1FC,SAD0F,GACjG,cADiG,CAC1FA,SAD0F;;AAEjG,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,SAAS,CAATA,KAAAA,CAApB,MAAA,EAA4CC,CAAC,IAAID,SAAS,CAA1D,IAAA,EAAiE;AAE/D,QAAME,KAAoB,GAAGC,KAAK,CAALA,IAAAA,CAAWH,SAAS,CAATA,KAAAA,CAAAA,QAAAA,CAAAA,CAAAA,EAA4BC,CAAC,GAAGD,SAAS,CAAjF,IAAwCA,CAAXG,CAA7B;AACA,QAAMC,gBAAgB,GAAGC,EAAE,CAA3B,KAA2B,CAA3B;AAEAL,IAAAA,SAAS,CAATA,KAAAA,CAAAA,GAAAA,CAAAA,gBAAAA,EAAAA,CAAAA;AACD;AACF;;AASD,OAAO,SAAA,sBAAA,CAAA,QAAA,EAAA,EAAA,EAGK;AAAA,6CACV,QADU;AAAA;;AAAA;AACV,wDAAgC;AAAA,UAAhC,OAAgC;AAE9BM,MAAAA,OAAO,CAAPA,QAAAA,CAAAA,WAAAA,GAA+BC,QAAQ,CAACD,OAAO,CAAPA,QAAAA,CAAD,WAAA,EAAvCA,EAAuC,CAAvCA;AACD;AAJS;AAAA;AAAA;AAAA;AAAA;;AAKV,SAAA,QAAA;AACD;;AAED,SAAA,QAAA,CAAA,KAAA,EAAA,EAAA,EAA6B;AAC3B,MAAIE,OAAO,CAAX,KAAW,CAAX,EAAoB;AAClB,WAAOH,EAAE,CAAT,KAAS,CAAT;AACD;;AAED,SAAO,KAAK,CAAL,GAAA,CAAWI,UAAAA,IAAD,EAAU;AACzB,WAAOF,QAAQ,CAAA,IAAA,EAAf,EAAe,CAAf;AADF,GAAO,CAAP;AAGD;;AAED,SAAA,OAAA,CAAA,KAAA,EAAwB;AACtB,SAAOG,MAAM,CAANA,QAAAA,CAAgBC,KAAK,CAArBD,CAAqB,CAArBA,KAA6BA,MAAM,CAANA,QAAAA,CAAgBC,KAAK,CAAzD,CAAyD,CAArBD,CAApC;AACD","sourcesContent":["import type {BinaryFeatures, BinaryGeometry} from '@loaders.gl/schema';\n\ntype TransformCoordinate = (coord: number[]) => number[];\n\n/**\n * Apply transformation to every coordinate of binary features\n * @param  binaryFeatures binary features\n * @param  transformCoordinate Function to call on each coordinate\n * @return Transformed binary features\n */\nexport function transformBinaryCoords(\n  binaryFeatures: BinaryFeatures,\n  transformCoordinate: TransformCoordinate\n): BinaryFeatures {\n  if (binaryFeatures.points) {\n    transformBinaryGeometryPositions(binaryFeatures.points, transformCoordinate);\n  }\n  if (binaryFeatures.lines) {\n    transformBinaryGeometryPositions(binaryFeatures.lines, transformCoordinate);\n  }\n  if (binaryFeatures.polygons) {\n    transformBinaryGeometryPositions(binaryFeatures.polygons, transformCoordinate);\n  }\n  return binaryFeatures;\n}\n\n/** Transform one binary geometry */\nfunction transformBinaryGeometryPositions(binaryGeometry: BinaryGeometry, fn: TransformCoordinate) {\n  const {positions} = binaryGeometry;\n  for (let i = 0; i < positions.value.length; i += positions.size) {\n    // @ts-ignore inclusion of bigint causes problems\n    const coord: Array<number> = Array.from(positions.value.subarray(i, i + positions.size));\n    const transformedCoord = fn(coord);\n    // @ts-ignore typescript typing for .set seems to require bigint?\n    positions.value.set(transformedCoord, i);\n  }\n}\n\n/**\n * Apply transformation to every coordinate of GeoJSON features\n *\n * @param  features Array of GeoJSON features\n * @param  fn       Function to call on each coordinate\n * @return          Transformed GeoJSON features\n */\nexport function transformGeoJsonCoords(\n  features: object[],\n  fn: (coord: number[]) => number[]\n): object[] {\n  for (const feature of features) {\n    // @ts-ignore\n    feature.geometry.coordinates = coordMap(feature.geometry.coordinates, fn);\n  }\n  return features;\n}\n\nfunction coordMap(array, fn) {\n  if (isCoord(array)) {\n    return fn(array);\n  }\n\n  return array.map((item) => {\n    return coordMap(item, fn);\n  });\n}\n\nfunction isCoord(array) {\n  return Number.isFinite(array[0]) && Number.isFinite(array[1]);\n}\n"]},"metadata":{},"sourceType":"module"}