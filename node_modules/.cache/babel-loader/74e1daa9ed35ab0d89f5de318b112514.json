{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nvar scratchVector = new Vector3();\nvar scratchPosition = new Vector3();\nvar cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\nexport function getFrameState(viewport, frameNumber) {\n  var cameraDirection = viewport.cameraDirection,\n      cameraUp = viewport.cameraUp,\n      height = viewport.height;\n  var metersPerUnit = viewport.distanceScales.metersPerUnit;\n  var viewportCenterCartographic = viewport.unprojectPosition(viewport.center);\n  var viewportCenterCartesian = Ellipsoid.WGS84.cartographicToCartesian(viewportCenterCartographic, new Vector3());\n  var enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  var cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  var cameraDirectionCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n  var cameraUpCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n  commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport: viewport,\n    height: height,\n    cullingVolume: cullingVolume,\n    frameNumber: frameNumber,\n    sseDenominator: 1.15\n  };\n}\n\nfunction commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {\n  var frustumPlanes = viewport.getFrustumPlanes();\n  var i = 0;\n\n  for (var dir in frustumPlanes) {\n    var plane = frustumPlanes[dir];\n    var distanceToCenter = plane.normal.dot(viewport.center);\n    scratchPosition.copy(plane.normal).scale(plane.distance - distanceToCenter).add(viewport.center);\n    var cartographicPos = viewport.unprojectPosition(scratchPosition);\n    var cartesianPos = Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new Vector3());\n    cullingVolume.planes[i++].fromPointNormal(cartesianPos, scratchVector.copy(viewportCenterCartesian).subtract(cartesianPos));\n  }\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/frame-state.ts"],"names":["scratchVector","scratchPosition","cullingVolume","height","metersPerUnit","viewport","viewportCenterCartographic","viewportCenterCartesian","Ellipsoid","enuToFixedTransform","cameraPositionCartographic","cameraPositionCartesian","cameraDirectionCartesian","cameraUpCartesian","commonSpacePlanesToWGS84","camera","position","direction","up","frameNumber","sseDenominator","frustumPlanes","i","plane","distanceToCenter","cartographicPos","cartesianPos"],"mappings":"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","sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {CullingVolume, Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nexport type FrameState = {\n  camera: {\n    position: number[];\n    direction: number[];\n    up: number[];\n  };\n  viewport: {[key: string]: any};\n  height: number;\n  cullingVolume: CullingVolume;\n  frameNumber: number; // TODO: This can be the same between updates, what number is unique for between updates?\n  sseDenominator: number; // Assumes fovy = 60 degrees\n};\n\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane()\n]);\n\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport, frameNumber: number): FrameState {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {cameraDirection, cameraUp, height} = viewport;\n  const {metersPerUnit} = viewport.distanceScales;\n\n  const viewportCenterCartographic = viewport.unprojectPosition(viewport.center);\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    viewportCenterCartographic,\n    new Vector3()\n  );\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))\n  ).normalize();\n  const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))\n  ).normalize();\n\n  commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);\n\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    height,\n    cullingVolume,\n    frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n\nfunction commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n  let i = 0;\n  for (const dir in frustumPlanes) {\n    const plane = frustumPlanes[dir];\n    const distanceToCenter = plane.normal.dot(viewport.center);\n    scratchPosition\n      .copy(plane.normal)\n      .scale(plane.distance - distanceToCenter)\n      .add(viewport.center);\n    const cartographicPos = viewport.unprojectPosition(scratchPosition);\n\n    const cartesianPos = Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new Vector3());\n\n    cullingVolume.planes[i++].fromPointNormal(\n      cartesianPos,\n      // Want the normal to point into the frustum since that's what culling expects\n      scratchVector.copy(viewportCenterCartesian).subtract(cartesianPos)\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}