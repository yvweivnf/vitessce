{"ast":null,"code":"'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n  if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n  this._maxEntries = Math.max(4, maxEntries || 9);\n  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n  if (format) {\n    this._initFormat(format);\n  }\n\n  this.clear();\n}\n\nrbush.prototype = {\n  all: function () {\n    return this._all(this.data, []);\n  },\n  search: function (bbox) {\n    var node = this.data,\n        result = [],\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return result;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  collides: function (bbox) {\n    var node = this.data,\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return false;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) return true;\n          nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return false;\n  },\n  load: function (data) {\n    if (!(data && data.length)) return this;\n\n    if (data.length < this._minEntries) {\n      for (var i = 0, len = data.length; i < len; i++) {\n        this.insert(data[i]);\n      }\n\n      return this;\n    } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      } // insert the small tree into the large tree at appropriate level\n\n\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n  },\n  insert: function (item) {\n    if (item) this._insert(item, this.data.height - 1);\n    return this;\n  },\n  clear: function () {\n    this.data = createNode([]);\n    return this;\n  },\n  remove: function (item, equalsFn) {\n    if (!item) return this;\n    var node = this.data,\n        bbox = this.toBBox(item),\n        path = [],\n        indexes = [],\n        i,\n        parent,\n        index,\n        goingUp; // depth-first iterative tree traversal\n\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n\n      if (node.leaf) {\n        // check current node\n        index = findItem(item, node.children, equalsFn);\n\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n\n          this._condense(path);\n\n          return this;\n        }\n      }\n\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else node = null; // nothing found\n\n    }\n\n    return this;\n  },\n  toBBox: function (item) {\n    return item;\n  },\n  compareMinX: compareNodeMinX,\n  compareMinY: compareNodeMinY,\n  toJSON: function () {\n    return this.data;\n  },\n  fromJSON: function (data) {\n    this.data = data;\n    return this;\n  },\n  _all: function (node, result) {\n    var nodesToSearch = [];\n\n    while (node) {\n      if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  _build: function (items, left, right, height) {\n    var N = right - left + 1,\n        M = this._maxEntries,\n        node;\n\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height; // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M),\n        N1 = N2 * Math.ceil(Math.sqrt(M)),\n        i,\n        j,\n        right2,\n        right3;\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (i = left; i <= right; i += N1) {\n      right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n\n      for (j = i; j <= right2; j += N2) {\n        right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n\n    calcBBox(node, this.toBBox);\n    return node;\n  },\n  _chooseSubtree: function (bbox, node, level, path) {\n    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) break;\n      minArea = minEnlargement = Infinity;\n\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        area = bboxArea(child);\n        enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n\n      node = targetNode || node.children[0];\n    }\n\n    return node;\n  },\n  _insert: function (item, level, isNode) {\n    var toBBox = this.toBBox,\n        bbox = isNode ? item : toBBox(item),\n        insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n    node.children.push(item);\n    extend(node, bbox); // split on node overflow; propagate upwards if necessary\n\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n\n        level--;\n      } else break;\n    } // adjust bboxes along the insertion path\n\n\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  },\n  // split overflowed node into two\n  _split: function (insertPath, level) {\n    var node = insertPath[level],\n        M = node.children.length,\n        m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n  },\n  _splitRoot: function (node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  },\n  _chooseSplitIndex: function (node, m, M) {\n    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n    minOverlap = minArea = Infinity;\n\n    for (i = m; i <= M - m; i++) {\n      bbox1 = distBBox(node, 0, i, this.toBBox);\n      bbox2 = distBBox(node, i, M, this.toBBox);\n      overlap = intersectionArea(bbox1, bbox2);\n      area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n\n    return index;\n  },\n  // sorts node children by the best axis for split\n  _chooseSplitAxis: function (node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n        xMargin = this._allDistMargin(node, m, M, compareMinX),\n        yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n\n\n    if (xMargin < yMargin) node.children.sort(compareMinX);\n  },\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin: function (node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox,\n        leftBBox = distBBox(node, 0, m, toBBox),\n        rightBBox = distBBox(node, M - m, M, toBBox),\n        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n        i,\n        child;\n\n    for (i = m; i < M - m; i++) {\n      child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n\n    for (i = M - m - 1; i >= m; i--) {\n      child = node.children[i];\n      extend(rightBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n  },\n  _adjustParentBBoxes: function (bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  },\n  _condense: function (path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else this.clear();\n      } else calcBBox(path[i], this.toBBox);\n    }\n  },\n  _initFormat: function (format) {\n    // data format (minX, minY, maxX, maxY accessors)\n    // uses eval-type function compilation instead of just accepting a toBBox function\n    // because the algorithms are very sensitive to sorting functions performance,\n    // so they should be dead simple and without inner calls\n    var compareArr = ['return a', ' - b', ';'];\n    this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n    this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n    this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n  }\n};\n\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) return items.indexOf(item);\n\n  for (var i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) return i;\n  }\n\n  return -1;\n} // calculate node's bbox from bboxes of its children\n\n\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n} // min bounding rectangle of node children from k to p-1\n\n\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n\n  for (var i = k, child; i < p; i++) {\n    child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n\n  return destNode;\n}\n\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\n\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\n\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\n\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\n\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n  var minX = Math.max(a.minX, b.minX),\n      minY = Math.max(a.minY, b.minY),\n      maxX = Math.min(a.maxX, b.maxX),\n      maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n  return {\n    children: children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n} // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\n\nfunction multiSelect(arr, left, right, n, compare) {\n  var stack = [left, right],\n      mid;\n\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n) continue;\n    mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/rbush/index.js"],"names":["module","exports","rbush","default","quickselect","require","maxEntries","format","_maxEntries","Math","max","_minEntries","ceil","_initFormat","clear","prototype","all","_all","data","search","bbox","node","result","toBBox","intersects","nodesToSearch","i","len","child","childBBox","children","length","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","index","goingUp","findItem","splice","_condense","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","toJSON","fromJSON","apply","items","left","right","N","M","calcBBox","log","pow","N2","N1","sqrt","j","right2","right3","multiSelect","min","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","Infinity","bboxArea","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","distBBox","intersectionArea","xMargin","_allDistMargin","yMargin","sort","compare","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","compareArr","Function","join","k","p","destNode","minX","minY","maxX","maxY","a","b","arr","n","stack","mid"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}