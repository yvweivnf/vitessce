{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { getPolygonSignedArea } from '@math.gl/polygon';\nexport function geojsonToFlatGeojson(features) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    coordLength: 2,\n    fixRingWinding: true\n  };\n  return features.map(function (feature) {\n    return flattenFeature(feature, options);\n  });\n}\n\nfunction flattenPoint(coordinates, data, indices, options) {\n  indices.push(data.length);\n  data.push.apply(data, _toConsumableArray(coordinates));\n\n  for (var i = coordinates.length; i < options.coordLength; i++) {\n    data.push(0);\n  }\n}\n\nfunction flattenLineString(coordinates, data, indices, options) {\n  indices.push(data.length);\n\n  var _iterator = _createForOfIteratorHelper(coordinates),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var c = _step.value;\n      data.push.apply(data, _toConsumableArray(c));\n\n      for (var i = c.length; i < options.coordLength; i++) {\n        data.push(0);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction flattenPolygon(coordinates, data, indices, areas, options) {\n  var count = 0;\n  var ringAreas = [];\n  var polygons = [];\n\n  var _iterator2 = _createForOfIteratorHelper(coordinates),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var lineString = _step2.value;\n      var lineString2d = lineString.map(function (p) {\n        return p.slice(0, 2);\n      });\n      var area = getPolygonSignedArea(lineString2d.flat());\n      var ccw = area < 0;\n\n      if (options.fixRingWinding && (count === 0 && !ccw || count > 0 && ccw)) {\n        lineString.reverse();\n        area = -area;\n      }\n\n      ringAreas.push(area);\n      flattenLineString(lineString, data, polygons, options);\n      count++;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (count > 0) {\n    areas.push(ringAreas);\n    indices.push(polygons);\n  }\n}\n\nfunction flattenFeature(feature, options) {\n  var geometry = feature.geometry;\n\n  if (geometry.type === 'GeometryCollection') {\n    throw new Error('GeometryCollection type not supported');\n  }\n\n  var data = [];\n  var indices = [];\n  var areas;\n  var type;\n\n  switch (geometry.type) {\n    case 'Point':\n      type = 'Point';\n      flattenPoint(geometry.coordinates, data, indices, options);\n      break;\n\n    case 'MultiPoint':\n      type = 'Point';\n      geometry.coordinates.map(function (c) {\n        return flattenPoint(c, data, indices, options);\n      });\n      break;\n\n    case 'LineString':\n      type = 'LineString';\n      flattenLineString(geometry.coordinates, data, indices, options);\n      break;\n\n    case 'MultiLineString':\n      type = 'LineString';\n      geometry.coordinates.map(function (c) {\n        return flattenLineString(c, data, indices, options);\n      });\n      break;\n\n    case 'Polygon':\n      type = 'Polygon';\n      areas = [];\n      flattenPolygon(geometry.coordinates, data, indices, areas, options);\n      break;\n\n    case 'MultiPolygon':\n      type = 'Polygon';\n      areas = [];\n      geometry.coordinates.map(function (c) {\n        return flattenPolygon(c, data, indices, areas, options);\n      });\n      break;\n\n    default:\n      throw new Error(\"Unknown type: \".concat(type));\n  }\n\n  return _objectSpread({}, feature, {\n    geometry: {\n      type: type,\n      indices: indices,\n      data: data,\n      areas: areas\n    }\n  });\n}","map":{"version":3,"sources":["../../../src/lib/geojson-to-flat-geojson.ts"],"names":["options","coordLength","fixRingWinding","features","feature","flattenFeature","indices","data","i","coordinates","c","count","ringAreas","polygons","lineString2d","lineString","p","area","getPolygonSignedArea","ccw","flattenLineString","areas","geometry","type","flattenPoint","flattenPolygon"],"mappings":"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","sourcesContent":["import {getPolygonSignedArea} from '@math.gl/polygon';\n\nimport {Feature, Position, FlatFeature} from '@loaders.gl/schema';\n\n/**\n * Options for `geojsonToFlatGeojson`\n */\nexport type GeojsonToFlatGeojsonOptions = {\n  coordLength: number;\n  fixRingWinding: boolean;\n};\n\n// Coordinates defining a Point\ntype PointCoordinates = Position;\n// Coordinates defining a LineString\ntype LineStringCoordinates = Position[];\n// Coordinates defining a Polygon\ntype PolygonCoordinates = Position[][];\n\n/**\n * Convert GeoJSON features to Flat GeoJSON features\n *\n * @param features\n * @param options\n * @returns an Array of Flat GeoJSON features\n */\nexport function geojsonToFlatGeojson(\n  features: Feature[],\n  options: GeojsonToFlatGeojsonOptions = {coordLength: 2, fixRingWinding: true}\n): FlatFeature[] {\n  return features.map((feature) => flattenFeature(feature, options));\n}\n\n/**\n * Helper function to copy Point values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenPoint(\n  coordinates: PointCoordinates,\n  data: number[],\n  indices: number[],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  indices.push(data.length);\n  data.push(...coordinates);\n\n  // Pad up to coordLength\n  for (let i = coordinates.length; i < options.coordLength; i++) {\n    data.push(0);\n  }\n}\n\n/**\n * Helper function to copy LineString values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenLineString(\n  coordinates: LineStringCoordinates,\n  data: number[],\n  indices: number[],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  indices.push(data.length);\n  for (const c of coordinates) {\n    data.push(...c);\n\n    // Pad up to coordLength\n    for (let i = c.length; i < options.coordLength; i++) {\n      data.push(0);\n    }\n  }\n}\n\n/**\n * Helper function to copy Polygon values from `coordinates` into `data` & `indices` & `areas`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param areas\n * @param options\n */\nfunction flattenPolygon(\n  coordinates: PolygonCoordinates,\n  data: number[],\n  indices: number[][],\n  areas: number[][],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  let count = 0;\n  const ringAreas: number[] = [];\n  const polygons: number[] = [];\n  for (const lineString of coordinates) {\n    const lineString2d = lineString.map((p) => p.slice(0, 2));\n    let area = getPolygonSignedArea(lineString2d.flat());\n    const ccw = area < 0;\n\n    // Exterior ring must be CCW and interior rings CW\n    if (options.fixRingWinding && ((count === 0 && !ccw) || (count > 0 && ccw))) {\n      lineString.reverse();\n      area = -area;\n    }\n    ringAreas.push(area);\n    flattenLineString(lineString, data, polygons, options);\n    count++;\n  }\n\n  if (count > 0) {\n    areas.push(ringAreas);\n    indices.push(polygons);\n  }\n}\n\n/**\n * Flatten single GeoJSON feature into Flat GeoJSON\n *\n * @param feature\n * @param options\n * @returns A Flat GeoJSON feature\n */\nfunction flattenFeature(feature: Feature, options: GeojsonToFlatGeojsonOptions): FlatFeature {\n  const {geometry} = feature;\n  if (geometry.type === 'GeometryCollection') {\n    throw new Error('GeometryCollection type not supported');\n  }\n  const data = [];\n  const indices = [];\n  let areas;\n  let type;\n\n  switch (geometry.type) {\n    case 'Point':\n      type = 'Point';\n      flattenPoint(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiPoint':\n      type = 'Point';\n      geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));\n      break;\n    case 'LineString':\n      type = 'LineString';\n      flattenLineString(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiLineString':\n      type = 'LineString';\n      geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));\n      break;\n    case 'Polygon':\n      type = 'Polygon';\n      areas = [];\n      flattenPolygon(geometry.coordinates, data, indices, areas, options);\n      break;\n    case 'MultiPolygon':\n      type = 'Polygon';\n      areas = [];\n      geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));\n      break;\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n\n  return {...feature, geometry: {type, indices, data, areas}};\n}\n"]},"metadata":{},"sourceType":"module"}