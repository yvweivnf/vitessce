{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResizeCircleMode = void 0;\n\nvar _nearestPointOnLine = _interopRequireDefault(require(\"@turf/nearest-point-on-line\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _circle = _interopRequireDefault(require(\"@turf/circle\"));\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _center = _interopRequireDefault(require(\"@turf/center\"));\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ResizeCircleMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(ResizeCircleMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(ResizeCircleMode);\n\n  function ResizeCircleMode() {\n    var _this;\n\n    _classCallCheck(this, ResizeCircleMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_selectedEditHandle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isResizing\", false);\n\n    return _this;\n  }\n\n  _createClass(ResizeCircleMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var _this2 = this;\n\n      var handles = [];\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var lastPointerMoveEvent = props.lastPointerMoveEvent;\n      var picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n      var mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords; // intermediate edit handle\n\n      if (picks && picks.length && mapCoords && selectedFeatureIndexes.length === 1 && !this._isResizing) {\n        var featureAsPick = picks.find(function (pick) {\n          return !pick.isGuide;\n        }); // is the feature in the pick selected\n\n        if (featureAsPick && featureAsPick.object.properties.shape && featureAsPick.object.properties.shape.includes('Circle') && props.selectedIndexes.includes(featureAsPick.index)) {\n          var intermediatePoint = null;\n          var positionIndexPrefix = [];\n          var referencePoint = (0, _helpers.point)(mapCoords); // process all lines of the (single) feature\n\n          (0, _utils.recursivelyTraverseNestedArrays)(featureAsPick.object.geometry.coordinates, [], function (lineString, prefix) {\n            var lineStringFeature = (0, _helpers.lineString)(lineString);\n\n            var candidateIntermediatePoint = _this2.getNearestPoint( // @ts-ignore\n            lineStringFeature, referencePoint, props.modeConfig && props.modeConfig.viewport);\n\n            if (!intermediatePoint || candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }); // tack on the lone intermediate point to the set of handles\n\n          if (intermediatePoint) {\n            var _intermediatePoint = intermediatePoint,\n                position = _intermediatePoint.geometry.coordinates,\n                index = _intermediatePoint.properties.index;\n            handles.push({\n              type: 'Feature',\n              properties: {\n                guideType: 'editHandle',\n                editHandleType: 'intermediate',\n                featureIndex: featureAsPick.index,\n                positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [index + 1])\n              },\n              geometry: {\n                type: 'Point',\n                coordinates: position\n              }\n            });\n          }\n        }\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: handles\n      };\n    } // turf.js does not support elevation for nearestPointOnLine\n\n  }, {\n    key: \"getNearestPoint\",\n    value: function getNearestPoint(line, inPoint, viewport) {\n      var coordinates = line.geometry.coordinates;\n\n      if (coordinates.some(function (coord) {\n        return coord.length > 2;\n      })) {\n        if (viewport) {\n          // This line has elevation, we need to use alternative algorithm\n          return (0, _utils.nearestPointOnProjectedLine)(line, inPoint, viewport);\n        } // eslint-disable-next-line no-console,no-undef\n\n\n        console.log('Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.');\n      }\n\n      return (0, _nearestPointOnLine[\"default\"])(line, inPoint);\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (editHandle) {\n        // Cancel map panning if pointer went down on an edit handle\n        event.cancelPan();\n        var editHandleProperties = editHandle.properties;\n        var feature = this.getSelectedFeature(props);\n        var center = (0, _center[\"default\"])(feature).geometry.coordinates;\n        var numberOfSteps = Object.entries(feature.geometry.coordinates[0]).length - 1;\n        var radius = Math.max((0, _distance[\"default\"])(center, event.mapCoords), 0.001);\n        var _ref = {},\n            _ref$steps = _ref.steps,\n            steps = _ref$steps === void 0 ? numberOfSteps : _ref$steps;\n        var options = {\n          steps: steps\n        };\n        var updatedFeature = (0, _circle[\"default\"])(center, radius, options);\n        var geometry = updatedFeature.geometry;\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(editHandleProperties.featureIndex, geometry).getObject();\n        props.onEdit({\n          updatedData: updatedData,\n          editType: 'unionGeometry',\n          editContext: {\n            featureIndexes: [editHandleProperties.featureIndex]\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      if (!this._isResizing) {\n        var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);\n        this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === 'intermediate' ? selectedEditHandle : null;\n      }\n\n      var cursor = this.getCursor(event);\n      props.onUpdateCursor(cursor);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      if (this._selectedEditHandle) {\n        this._isResizing = true;\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      if (this._isResizing) {\n        this._selectedEditHandle = null;\n        this._isResizing = false;\n      }\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(event) {\n      var picks = event && event.picks || [];\n      var handlesPicked = (0, _utils.getPickedEditHandles)(picks);\n\n      if (handlesPicked.length) {\n        return 'cell';\n      }\n\n      return null;\n    }\n  }]);\n\n  return ResizeCircleMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.ResizeCircleMode = ResizeCircleMode;","map":{"version":3,"sources":["../../src/lib/resize-circle-mode.ts"],"names":["ResizeCircleMode","GeoJsonEditMode","props","handles","selectedFeatureIndexes","lastPointerMoveEvent","picks","mapCoords","featureAsPick","pick","intermediatePoint","positionIndexPrefix","referencePoint","lineStringFeature","candidateIntermediatePoint","position","index","type","properties","guideType","editHandleType","featureIndex","positionIndexes","geometry","coordinates","features","line","inPoint","viewport","coord","console","event","editHandle","editHandleProperties","feature","center","numberOfSteps","Object","radius","Math","steps","options","updatedFeature","updatedData","ImmutableFeatureCollection","editType","editContext","featureIndexes","selectedEditHandle","cursor","handlesPicked"],"mappings":"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","sourcesContent":["import nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { point, lineString as toLineString } from '@turf/helpers';\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport turfCenter from '@turf/center';\nimport {\n  recursivelyTraverseNestedArrays,\n  nearestPointOnProjectedLine,\n  getPickedEditHandles,\n  getPickedEditHandle,\n  NearestPointType,\n} from '../utils';\nimport { LineString, Point, FeatureCollection, FeatureOf } from '../geojson-types';\nimport {\n  ModeProps,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  Viewport,\n  EditHandleFeature,\n  GuideFeatureCollection,\n} from '../types';\nimport { GeoJsonEditMode } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ResizeCircleMode extends GeoJsonEditMode {\n  _selectedEditHandle: EditHandleFeature | null | undefined;\n  _isResizing = false;\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    const handles = [];\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const { lastPointerMoveEvent } = props;\n    const picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n    const mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;\n\n    // intermediate edit handle\n    if (\n      picks &&\n      picks.length &&\n      mapCoords &&\n      selectedFeatureIndexes.length === 1 &&\n      !this._isResizing\n    ) {\n      const featureAsPick = picks.find((pick) => !pick.isGuide);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        featureAsPick.object.properties.shape &&\n        featureAsPick.object.properties.shape.includes('Circle') &&\n        props.selectedIndexes.includes(featureAsPick.index)\n      ) {\n        let intermediatePoint: NearestPointType | null | undefined = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(mapCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.getNearestPoint(\n              // @ts-ignore\n              lineStringFeature,\n              referencePoint,\n              props.modeConfig && props.modeConfig.viewport\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index },\n          } = intermediatePoint;\n          handles.push({\n            type: 'Feature',\n            properties: {\n              guideType: 'editHandle',\n              editHandleType: 'intermediate',\n              featureIndex: featureAsPick.index,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n            },\n            geometry: {\n              type: 'Point',\n              coordinates: position,\n            },\n          });\n        }\n      }\n    }\n\n    return {\n      type: 'FeatureCollection',\n      features: handles,\n    };\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  getNearestPoint(\n    line: FeatureOf<LineString>,\n    inPoint: FeatureOf<Point>,\n    viewport: Viewport | null | undefined\n  ): NearestPointType {\n    const { coordinates } = line.geometry;\n    if (coordinates.some((coord) => coord.length > 2)) {\n      if (viewport) {\n        // This line has elevation, we need to use alternative algorithm\n        return nearestPointOnProjectedLine(line, inPoint, viewport);\n      }\n      // eslint-disable-next-line no-console,no-undef\n      console.log(\n        'Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.'\n      );\n    }\n\n    return nearestPointOnLine(line, inPoint);\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (editHandle) {\n      // Cancel map panning if pointer went down on an edit handle\n      event.cancelPan();\n\n      const editHandleProperties = editHandle.properties;\n\n      const feature = this.getSelectedFeature(props);\n      const center = turfCenter(feature).geometry.coordinates;\n      const numberOfSteps = Object.entries(feature.geometry.coordinates[0]).length - 1;\n      const radius = Math.max(distance(center, event.mapCoords), 0.001);\n\n      const { steps = numberOfSteps } = {};\n      const options = { steps };\n      const updatedFeature = circle(center, radius, options);\n      const geometry = updatedFeature.geometry;\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replaceGeometry(editHandleProperties.featureIndex, geometry)\n        .getObject();\n\n      props.onEdit({\n        updatedData,\n        editType: 'unionGeometry',\n        editContext: {\n          featureIndexes: [editHandleProperties.featureIndex],\n        },\n      });\n    }\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    if (!this._isResizing) {\n      const selectedEditHandle = getPickedEditHandle(event.picks);\n      this._selectedEditHandle =\n        selectedEditHandle && selectedEditHandle.properties.editHandleType === 'intermediate'\n          ? selectedEditHandle\n          : null;\n    }\n\n    const cursor = this.getCursor(event);\n    props.onUpdateCursor(cursor);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      this._isResizing = true;\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._isResizing) {\n      this._selectedEditHandle = null;\n      this._isResizing = false;\n    }\n  }\n\n  getCursor(event: PointerMoveEvent): string | null | undefined {\n    const picks = (event && event.picks) || [];\n\n    const handlesPicked = getPickedEditHandles(picks);\n    if (handlesPicked.length) {\n      return 'cell';\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}