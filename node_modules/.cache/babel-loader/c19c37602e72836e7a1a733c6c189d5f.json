{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2 } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var GeoPointNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(GeoPointNode, _DataFlowNode);\n\n  var _super = _createSuper(GeoPointNode);\n\n  function GeoPointNode(parent, projection, fields, as) {\n    var _this;\n\n    _classCallCheck(this, GeoPointNode);\n\n    _this = _super.call(this, parent);\n    _this.projection = projection;\n    _this.fields = fields;\n    _this.as = as;\n    return _this;\n  }\n\n  _createClass(GeoPointNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(this.fields.filter(isString));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this.as);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Geopoint \".concat(this.projection, \" \").concat(_hash(this.fields), \" \").concat(_hash(this.as));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return {\n        type: 'geopoint',\n        projection: this.projection,\n        fields: this.fields,\n        as: this.as\n      };\n    }\n  }], [{\n    key: \"parseAll\",\n    value: function parseAll(parent, model) {\n      if (!model.projectionName()) {\n        return parent;\n      }\n\n      for (var _i = 0, _arr = [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]; _i < _arr.length; _i++) {\n        var coordinates = _arr[_i];\n        var pair = coordinates.map(function (channel) {\n          var def = getFieldOrDatumDef(model.encoding[channel]);\n          return isFieldDef(def) ? def.field : isDatumDef(def) ? {\n            expr: \"\".concat(def.datum)\n          } : isValueDef(def) ? {\n            expr: \"\".concat(def['value'])\n          } : undefined;\n        });\n        var suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n\n        if (pair[0] || pair[1]) {\n          parent = new GeoPointNode(parent, model.projectionName(), pair, [model.getName(\"x\".concat(suffix)), model.getName(\"y\".concat(suffix))]);\n        }\n      }\n\n      return parent;\n    }\n  }]);\n\n  return GeoPointNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/geopoint.ts"],"names":[],"mappings":";;;;AACA,SAAQ,QAAR,QAAuB,WAAvB;AACA,SAA4B,QAA5B,EAAsC,SAAtC,EAAiD,SAAjD,EAA4D,UAA5D,QAA6E,eAA7E;AACA,SAAQ,kBAAR,EAA4B,UAA5B,EAAwC,UAAxC,EAAoD,UAApD,QAAqE,kBAArE;AACA,SAAQ,SAAR,EAAmB,IAAI,IAAJ,KAAnB,QAA8B,YAA9B;AAGA,SAAQ,YAAR,QAA2B,YAA3B;AAEA,WAAa,YAAb;AAAA;;AAAA;;AAKE,wBACE,MADF,EAEU,UAFV,EAGU,MAHV,EAIU,EAJV,EAI8B;AAAA;;AAAA;;AAE5B,8BAAM,MAAN;AAJQ,UAAA,UAAA,GAAA,UAAA;AACA,UAAA,MAAA,GAAA,MAAA;AACA,UAAA,EAAA,GAAA,EAAA;AAAoB;AAG7B;;AAZH;AAAA;AAAA,4BACc;AACV,aAAO,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,KAAK,UAA5B,EAAwC,SAAS,CAAC,KAAK,MAAN,CAAjD,EAAgE,SAAS,CAAC,KAAK,EAAN,CAAzE,CAAP;AACD;AAHH;AAAA;AAAA,sCA+CwB;AACpB,aAAO,IAAI,GAAJ,CAAQ,KAAK,MAAL,CAAY,MAAZ,CAAmB,QAAnB,CAAR,CAAP;AACD;AAjDH;AAAA;AAAA,qCAmDuB;AACnB,aAAO,IAAI,GAAJ,CAAQ,KAAK,EAAb,CAAP;AACD;AArDH;AAAA;AAAA,2BAuDa;AACT,gCAAmB,KAAK,UAAxB,cAAsC,KAAI,CAAC,KAAK,MAAN,CAA1C,cAA2D,KAAI,CAAC,KAAK,EAAN,CAA/D;AACD;AAzDH;AAAA;AAAA,+BA2DiB;AACb,aAAO;AACL,QAAA,IAAI,EAAE,UADD;AAEL,QAAA,UAAU,EAAE,KAAK,UAFZ;AAGL,QAAA,MAAM,EAAE,KAAK,MAHR;AAIL,QAAA,EAAE,EAAE,KAAK;AAJJ,OAAP;AAMD;AAlEH;AAAA;AAAA,6BAcyB,MAdzB,EAc+C,KAd/C,EAc+D;AAC3D,UAAI,CAAC,KAAK,CAAC,cAAN,EAAL,EAA6B;AAC3B,eAAO,MAAP;AACD;;AAED,8BAA0B,CACxB,CAAC,SAAD,EAAY,QAAZ,CADwB,EAExB,CAAC,UAAD,EAAa,SAAb,CAFwB,CAA1B,0BAGoC;AAH/B,YAAM,WAAW,WAAjB;AAIH,YAAM,IAAI,GAAG,WAAW,CAAC,GAAZ,CAAgB,UAAA,OAAO,EAAG;AACrC,cAAM,GAAG,GAAG,kBAAkB,CAAC,KAAK,CAAC,QAAN,CAAe,OAAf,CAAD,CAA9B;AACA,iBAAO,UAAU,CAAC,GAAD,CAAV,GACH,GAAG,CAAC,KADD,GAEH,UAAU,CAAC,GAAD,CAAV,GACA;AAAC,YAAA,IAAI,YAAK,GAAG,CAAC,KAAT;AAAL,WADA,GAEA,UAAU,CAAC,GAAD,CAAV,GACA;AAAC,YAAA,IAAI,YAAK,GAAG,CAAC,OAAD,CAAR;AAAL,WADA,GAEA,SANJ;AAOD,SATY,CAAb;AAWA,YAAM,MAAM,GAAG,WAAW,CAAC,CAAD,CAAX,KAAmB,UAAnB,GAAgC,GAAhC,GAAsC,EAArD;;AAEA,YAAI,IAAI,CAAC,CAAD,CAAJ,IAAW,IAAI,CAAC,CAAD,CAAnB,EAAwB;AACtB,UAAA,MAAM,GAAG,IAAI,YAAJ,CAAiB,MAAjB,EAAyB,KAAK,CAAC,cAAN,EAAzB,EAAiD,IAAjD,EAAuD,CAC9D,KAAK,CAAC,OAAN,YAAkB,MAAlB,EAD8D,EAE9D,KAAK,CAAC,OAAN,YAAkB,MAAlB,EAF8D,CAAvD,CAAT;AAID;AACF;;AAED,aAAO,MAAP;AACD;AA7CH;;AAAA;AAAA,EAAkC,YAAlC","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2 } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoPointNode extends DataFlowNode {\n    constructor(parent, projection, fields, as) {\n        super(parent);\n        this.projection = projection;\n        this.fields = fields;\n        this.as = as;\n    }\n    clone() {\n        return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n    }\n    static parseAll(parent, model) {\n        if (!model.projectionName()) {\n            return parent;\n        }\n        for (const coordinates of [\n            [LONGITUDE, LATITUDE],\n            [LONGITUDE2, LATITUDE2]\n        ]) {\n            const pair = coordinates.map(channel => {\n                const def = getFieldOrDatumDef(model.encoding[channel]);\n                return isFieldDef(def)\n                    ? def.field\n                    : isDatumDef(def)\n                        ? { expr: `${def.datum}` }\n                        : isValueDef(def)\n                            ? { expr: `${def['value']}` }\n                            : undefined;\n            });\n            const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n            if (pair[0] || pair[1]) {\n                parent = new GeoPointNode(parent, model.projectionName(), pair, [\n                    model.getName(`x${suffix}`),\n                    model.getName(`y${suffix}`)\n                ]);\n            }\n        }\n        return parent;\n    }\n    dependentFields() {\n        return new Set(this.fields.filter(isString));\n    }\n    producedFields() {\n        return new Set(this.as);\n    }\n    hash() {\n        return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;\n    }\n    assemble() {\n        return {\n            type: 'geopoint',\n            projection: this.projection,\n            fields: this.fields,\n            as: this.as\n        };\n    }\n}\n//# sourceMappingURL=geopoint.js.map"]},"metadata":{},"sourceType":"module"}