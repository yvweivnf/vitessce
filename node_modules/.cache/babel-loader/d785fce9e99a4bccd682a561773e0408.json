{"ast":null,"code":"import { Observable } from \"observable-fns\";\n\nconst doNothing = () => undefined;\n\nconst returnInput = input => input;\n\nconst runDeferred = fn => Promise.resolve().then(fn);\n\nfunction fail(error) {\n  throw error;\n}\n\nfunction isThenable(thing) {\n  return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\n\n\nexport class ObservablePromise extends Observable {\n  constructor(init) {\n    super(originalObserver => {\n      // tslint:disable-next-line no-this-assignment\n      const self = this;\n      const observer = Object.assign(Object.assign({}, originalObserver), {\n        complete() {\n          originalObserver.complete();\n          self.onCompletion();\n        },\n\n        error(error) {\n          originalObserver.error(error);\n          self.onError(error);\n        },\n\n        next(value) {\n          originalObserver.next(value);\n          self.onNext(value);\n        }\n\n      });\n\n      try {\n        this.initHasRun = true;\n        return init(observer);\n      } catch (error) {\n        observer.error(error);\n      }\n    });\n    this.initHasRun = false;\n    this.fulfillmentCallbacks = [];\n    this.rejectionCallbacks = [];\n    this.firstValueSet = false;\n    this.state = \"pending\";\n  }\n\n  onNext(value) {\n    if (!this.firstValueSet) {\n      this.firstValue = value;\n      this.firstValueSet = true;\n    }\n  }\n\n  onError(error) {\n    this.state = \"rejected\";\n    this.rejection = error;\n\n    for (const onRejected of this.rejectionCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onRejected(error));\n    }\n  }\n\n  onCompletion() {\n    this.state = \"fulfilled\";\n\n    for (const onFulfilled of this.fulfillmentCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onFulfilled(this.firstValue));\n    }\n  }\n\n  then(onFulfilledRaw, onRejectedRaw) {\n    const onFulfilled = onFulfilledRaw || returnInput;\n    const onRejected = onRejectedRaw || fail;\n    let onRejectedCalled = false;\n    return new Promise((resolve, reject) => {\n      const rejectionCallback = error => {\n        if (onRejectedCalled) return;\n        onRejectedCalled = true;\n\n        try {\n          resolve(onRejected(error));\n        } catch (anotherError) {\n          reject(anotherError);\n        }\n      };\n\n      const fulfillmentCallback = value => {\n        try {\n          resolve(onFulfilled(value));\n        } catch (error) {\n          rejectionCallback(error);\n        }\n      };\n\n      if (!this.initHasRun) {\n        this.subscribe({\n          error: rejectionCallback\n        });\n      }\n\n      if (this.state === \"fulfilled\") {\n        return resolve(onFulfilled(this.firstValue));\n      }\n\n      if (this.state === \"rejected\") {\n        onRejectedCalled = true;\n        return resolve(onRejected(this.rejection));\n      }\n\n      this.fulfillmentCallbacks.push(fulfillmentCallback);\n      this.rejectionCallbacks.push(rejectionCallback);\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(undefined, onRejected);\n  }\n\n  finally(onCompleted) {\n    const handler = onCompleted || doNothing;\n    return this.then(value => {\n      handler();\n      return value;\n    }, () => handler());\n  }\n\n  static from(thing) {\n    if (isThenable(thing)) {\n      return new ObservablePromise(observer => {\n        const onFulfilled = value => {\n          observer.next(value);\n          observer.complete();\n        };\n\n        const onRejected = error => {\n          observer.error(error);\n        };\n\n        thing.then(onFulfilled, onRejected);\n      });\n    } else {\n      return super.from(thing);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/observable-promise.js"],"names":["Observable","doNothing","undefined","returnInput","input","runDeferred","fn","Promise","resolve","then","fail","error","isThenable","thing","ObservablePromise","constructor","init","originalObserver","self","observer","Object","assign","complete","onCompletion","onError","next","value","onNext","initHasRun","fulfillmentCallbacks","rejectionCallbacks","firstValueSet","state","firstValue","rejection","onRejected","onFulfilled","onFulfilledRaw","onRejectedRaw","onRejectedCalled","reject","rejectionCallback","anotherError","fulfillmentCallback","subscribe","push","catch","finally","onCompleted","handler","from"],"mappings":"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","sourcesContent":["import { Observable } from \"observable-fns\";\nconst doNothing = () => undefined;\nconst returnInput = (input) => input;\nconst runDeferred = (fn) => Promise.resolve().then(fn);\nfunction fail(error) {\n    throw error;\n}\nfunction isThenable(thing) {\n    return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nexport class ObservablePromise extends Observable {\n    constructor(init) {\n        super((originalObserver) => {\n            // tslint:disable-next-line no-this-assignment\n            const self = this;\n            const observer = Object.assign(Object.assign({}, originalObserver), { complete() {\n                    originalObserver.complete();\n                    self.onCompletion();\n                }, error(error) {\n                    originalObserver.error(error);\n                    self.onError(error);\n                },\n                next(value) {\n                    originalObserver.next(value);\n                    self.onNext(value);\n                } });\n            try {\n                this.initHasRun = true;\n                return init(observer);\n            }\n            catch (error) {\n                observer.error(error);\n            }\n        });\n        this.initHasRun = false;\n        this.fulfillmentCallbacks = [];\n        this.rejectionCallbacks = [];\n        this.firstValueSet = false;\n        this.state = \"pending\";\n    }\n    onNext(value) {\n        if (!this.firstValueSet) {\n            this.firstValue = value;\n            this.firstValueSet = true;\n        }\n    }\n    onError(error) {\n        this.state = \"rejected\";\n        this.rejection = error;\n        for (const onRejected of this.rejectionCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onRejected(error));\n        }\n    }\n    onCompletion() {\n        this.state = \"fulfilled\";\n        for (const onFulfilled of this.fulfillmentCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onFulfilled(this.firstValue));\n        }\n    }\n    then(onFulfilledRaw, onRejectedRaw) {\n        const onFulfilled = onFulfilledRaw || returnInput;\n        const onRejected = onRejectedRaw || fail;\n        let onRejectedCalled = false;\n        return new Promise((resolve, reject) => {\n            const rejectionCallback = (error) => {\n                if (onRejectedCalled)\n                    return;\n                onRejectedCalled = true;\n                try {\n                    resolve(onRejected(error));\n                }\n                catch (anotherError) {\n                    reject(anotherError);\n                }\n            };\n            const fulfillmentCallback = (value) => {\n                try {\n                    resolve(onFulfilled(value));\n                }\n                catch (error) {\n                    rejectionCallback(error);\n                }\n            };\n            if (!this.initHasRun) {\n                this.subscribe({ error: rejectionCallback });\n            }\n            if (this.state === \"fulfilled\") {\n                return resolve(onFulfilled(this.firstValue));\n            }\n            if (this.state === \"rejected\") {\n                onRejectedCalled = true;\n                return resolve(onRejected(this.rejection));\n            }\n            this.fulfillmentCallbacks.push(fulfillmentCallback);\n            this.rejectionCallbacks.push(rejectionCallback);\n        });\n    }\n    catch(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n    finally(onCompleted) {\n        const handler = onCompleted || doNothing;\n        return this.then((value) => {\n            handler();\n            return value;\n        }, () => handler());\n    }\n    static from(thing) {\n        if (isThenable(thing)) {\n            return new ObservablePromise(observer => {\n                const onFulfilled = (value) => {\n                    observer.next(value);\n                    observer.complete();\n                };\n                const onRejected = (error) => {\n                    observer.error(error);\n                };\n                thing.then(onFulfilled, onRejected);\n            });\n        }\n        else {\n            return super.from(thing);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}