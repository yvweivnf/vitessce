{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\src\\\\components\\\\layer-controller\\\\LayerController.js\";\nimport React, { useState, useRef, useEffect } from 'react';\nimport { MAX_CHANNELS, getChannelStats } from '@hms-dbmi/viv';\nimport Grid from '@material-ui/core/Grid';\nimport Button from '@material-ui/core/Button';\nimport AddIcon from '@material-ui/icons/Add';\nimport Slider from '@material-ui/core/Slider';\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Accordion from '@material-ui/core/Accordion';\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\nimport VisibilityIcon from '@material-ui/icons/Visibility';\nimport VisibilityOffIcon from '@material-ui/icons/VisibilityOff';\nimport LayerOptions from './LayerOptions';\nimport VolumeOptions from './VolumeOptions';\nimport { useControllerSectionStyles, StyledAccordionDetails, StyledAccordionSummary, StyledInputLabel, OverflowEllipsisGrid } from './styles';\nimport { getMultiSelectionStats } from './utils';\nimport { GLOBAL_LABELS } from '../spatial/constants';\nimport { getSourceFromLoader, isRgb } from '../../utils';\nimport { canLoadResolution } from '../utils';\nimport { DOMAINS } from './constants';\n\nfunction TabPanel(props) {\n  const {\n    children,\n    value,\n    index,\n    ...other\n  } = props;\n  return /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    role: \"tabpanel\",\n    hidden: value !== index,\n    id: `simple-tabpanel-${index}`,\n    \"aria-labelledby\": `simple-tab-${index}`\n  }, other, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 5\n    }\n  }), value === index && children);\n} // Set the domain of the sliders based on either a full range or min/max.\n\n\nasync function getDomainsAndSliders(loader, selections, domainType, use3d) {\n  let domains;\n  const stats = await getMultiSelectionStats({\n    loader: loader.data,\n    selections,\n    use3d\n  });\n  const {\n    sliders\n  } = stats;\n\n  if (domainType === 'Min/Max') {\n    // eslint-disable-next-line prefer-destructuring\n    domains = stats.domains;\n  }\n\n  if (domainType === 'Full') {\n    const source = getSourceFromLoader(loader);\n    domains = selections.map(() => DOMAINS[source.dtype]);\n  }\n\n  return {\n    domains,\n    sliders\n  };\n}\n\nconst buttonStyles = {\n  borderStyle: 'dashed',\n  marginTop: '10px',\n  fontWeight: 400\n};\n/**\n * Controller for the various imaging options (color, opactiy, sliders etc.)\n * @prop {object} imageData Image config object, one of the `images` in the raster schema.\n * @prop {object} layerId Randomly generated id for the image layer that this controller handles.\n * @prop {function} handleLayerRemove Callback for handling the removal of a layer.\n * @prop {object} loader Loader object for the current imaging layer.\n * @prop {function} handleLayerChange Callback for handling the changing of layer properties.\n */\n\nexport default function LayerController(props) {\n  var _channels$;\n\n  const {\n    layer,\n    name,\n    loader,\n    theme,\n    handleLayerRemove,\n    handleLayerChange,\n    shouldShowTransparentColor,\n    shouldShowDomain,\n    shouldShowColormap,\n    ChannelController,\n    setViewState,\n    disable3d,\n    setRasterLayerCallback,\n    setAreLayerChannelsLoading,\n    areLayerChannelsLoading,\n    disabled,\n    spatialHeight,\n    spatialWidth,\n    disableChannelsIfRgbDetected,\n    shouldShowRemoveLayerButton\n  } = props;\n  const {\n    colormap,\n    opacity,\n    channels,\n    transparentColor,\n    renderingMode,\n    xSlice,\n    ySlice,\n    zSlice,\n    resolution,\n    use3d,\n    modelMatrix\n  } = layer; // Channels are used in a lot of callbacks and change handlers\n  // so ensuring they have an up to date copy of the data ensures consistency.\n  // See: https://github.com/vitessce/vitessce/issues/1036\n\n  const channelRef = useRef(channels);\n  useEffect(() => {\n    channelRef.current = channels;\n    return undefined;\n  }, [channels]);\n  const firstSelection = ((_channels$ = channels[0]) === null || _channels$ === void 0 ? void 0 : _channels$.selection) || {};\n  const {\n    data,\n    channels: channelOptions\n  } = loader;\n  const [tab, setTab] = useState(0);\n\n  const handleTabChange = (event, newTab) => {\n    setTab(newTab);\n  };\n\n  const {\n    labels,\n    shape\n  } = Array.isArray(data) ? data[data.length - 1] : data;\n  const [domainType, setDomainType] = useState(layer.domainType);\n  const [isExpanded, setIsExpanded] = useState(true);\n  const [globalLabelValues, setGlobalLabelValues] = useState(GLOBAL_LABELS.filter(field => typeof firstSelection[field] === 'number').reduce((o, key) => ({ ...o,\n    [key]: firstSelection[key]\n  }), {}));\n\n  function setVisible(v) {\n    handleLayerChange({ ...layer,\n      visible: v\n    });\n  }\n\n  function setColormap(v) {\n    handleLayerChange({ ...layer,\n      colormap: v\n    });\n  }\n\n  function setOpacity(v) {\n    handleLayerChange({ ...layer,\n      opacity: v\n    });\n  }\n\n  function setChannels(v) {\n    handleLayerChange({ ...layer,\n      channels: v\n    });\n  }\n\n  function setTransparentColor(v) {\n    handleLayerChange({ ...layer,\n      transparentColor: v\n    });\n  }\n\n  function setRenderingMode(v) {\n    handleLayerChange({ ...layer,\n      renderingMode: v\n    });\n  }\n\n  function handleMultiPropertyChange(obj) {\n    handleLayerChange({ ...layer,\n      ...obj\n    });\n  }\n\n  function handleSlicerSetting(slice, val) {\n    handleLayerChange({ ...layer,\n      [`${slice}Slice`]: val\n    });\n  }\n\n  function setChannelsAndDomainType(newChannels, newDomainType) {\n    handleLayerChange({ ...layer,\n      channels: newChannels,\n      domainType: newDomainType\n    });\n  }\n\n  function setChannel(v, i) {\n    const newChannels = [...channelRef.current];\n    newChannels[i] = v;\n    handleLayerChange({ ...layer,\n      channels: newChannels\n    });\n  }\n\n  function addChannel(v) {\n    const newChannels = [...channelRef.current, v];\n    handleLayerChange({ ...layer,\n      channels: newChannels\n    });\n  }\n\n  function removeChannel(i) {\n    const newChannels = [...channelRef.current];\n    newChannels.splice(i, 1);\n    handleLayerChange({ ...layer,\n      channels: newChannels\n    });\n  }\n\n  const setAreAllChannelsLoading = val => {\n    const newAreLayerChannelsLoading = channelRef.current.map(() => val);\n    setAreLayerChannelsLoading(newAreLayerChannelsLoading);\n  }; // Handles adding a channel, creating a default selection\n  // for the current global settings and domain type.\n\n\n  const handleChannelAdd = async () => {\n    const selection = {};\n    labels.forEach(label => {\n      // Set new image to default selection for non-global selections (0)\n      // and use current global selection otherwise.\n      selection[label] = GLOBAL_LABELS.includes(label) ? globalLabelValues[label] || 0 : 0;\n    });\n    const {\n      domains,\n      sliders\n    } = await getDomainsAndSliders(loader, [selection], domainType, use3d);\n    const domain = domains[0];\n    const slider = domain;\n    const color = [255, 255, 255];\n    const visible = true;\n    const newChannelId = channels.length;\n    const newAreLayerChannelsLoading = [...areLayerChannelsLoading];\n    newAreLayerChannelsLoading[newChannelId] = true;\n    setAreLayerChannelsLoading(newAreLayerChannelsLoading);\n    const channel = {\n      selection,\n      slider,\n      visible,\n      color\n    };\n    setRasterLayerCallback(() => {\n      setChannel({ ...channel,\n        slider: sliders[0]\n      }, newChannelId);\n      const areLayerChannelsLoadingCallback = [...newAreLayerChannelsLoading];\n      areLayerChannelsLoadingCallback[newChannelId] = false;\n      setAreLayerChannelsLoading(areLayerChannelsLoadingCallback);\n      setRasterLayerCallback(null);\n    });\n    addChannel(channel);\n  };\n\n  const handleDomainChange = async value => {\n    setDomainType(value);\n    const selections = channels.map(channel => channel.selection);\n    let sliders = channels.map(channel => channel.slider);\n    const {\n      domains\n    } = await getDomainsAndSliders(loader, selections, value, use3d); // If it's the right-most slider, we take the minimum of that and the new value.\n    // Otherwise, we use the maximum of the left-hand side and the new value.\n\n    sliders = sliders.map((slider, i) => {\n      const [left, right] = slider;\n      return [Math.max(left, domains[i][0]), Math.min(right, domains[i][1])];\n    });\n    const newChannels = channels.map((c, i) => ({ ...c,\n      slider: sliders[i]\n    }));\n    setChannelsAndDomainType(newChannels, value);\n  }; // This call updates all channel selections with new global selection from the UI.\n\n\n  const handleGlobalChannelsSelectionChange = async ({\n    selection,\n    event\n  }) => {\n    const selections = channels.map(channel => ({ ...channel.selection,\n      ...selection\n    }));\n    const canUpdateChannels = event.type === 'mouseup' || event.type === 'keydown'; // Only update domains on a mouseup event for the same reason as above.\n\n    if (canUpdateChannels) {\n      setAreAllChannelsLoading(true);\n      getDomainsAndSliders(loader, selections, domainType, use3d).then(({\n        sliders\n      }) => {\n        const newChannelsWithSelection = channels.map(c => ({ ...c,\n          selection: { ...c.selection,\n            ...selection\n          }\n        })); // Set the callback before changing the selection\n        // so the callback is used when the layer (re)loads its data.\n\n        setRasterLayerCallback(() => {\n          setRasterLayerCallback(null);\n          setAreAllChannelsLoading(false);\n          const newChannelsWithSliders = [...newChannelsWithSelection].map((c, i) => ({ ...c,\n            slider: sliders[i]\n          }));\n          setChannels(newChannelsWithSliders);\n        });\n        setChannels(newChannelsWithSelection);\n      });\n    }\n\n    setGlobalLabelValues(prev => ({ ...prev,\n      ...selection\n    }));\n  };\n\n  let channelControllers = [];\n\n  if (labels.length > 0) {\n    const channelLabel = labels.find(c => c === 'channel' || c === 'c') || labels[0]; // Create the channel controllers for each channel.\n\n    channelControllers = channels.map( // c is an object like { color, selection, slider, visible }.\n    (c, channelId) => {\n      // Update the auxiliary store with the current loading state of a channel.\n      const setIsLoading = val => {\n        const newAreLayerChannelsLoading = [...areLayerChannelsLoading];\n        newAreLayerChannelsLoading[channelId] = val;\n        setAreLayerChannelsLoading(newAreLayerChannelsLoading);\n      }; // Change one property of a channel (for now - soon\n      // nested structures allowing for multiple z/t selecitons at once, for example).\n\n\n      const handleChannelPropertyChange = (property, value) => {\n        // property is something like \"selection\" or \"slider.\"\n        // value is the actual change, like { channel: \"DAPI\" }.\n        const update = {\n          [property]: value\n        };\n\n        if (property === 'selection') {\n          // Channel is loading until the layer callback is called\n          // by the layer, which fetches the raster data.\n          setIsLoading(true);\n          update.selection = { ...globalLabelValues,\n            ...update.selection\n          };\n          setChannel({ ...c,\n            ...update\n          }, channelId); // Call back for raster layer handles update of UI\n          // like sliders and the loading state of the channel.\n\n          setRasterLayerCallback(async () => {\n            const selections = [{ ...channels[channelId][property],\n              ...value\n            }];\n            const {\n              sliders\n            } = await getDomainsAndSliders(loader, selections, domainType, use3d);\n            [update.slider] = sliders;\n            setChannel({ ...c,\n              ...update\n            }, channelId);\n            setRasterLayerCallback(null);\n            setIsLoading(false);\n          });\n        } else {\n          setChannel({ ...c,\n            ...update\n          }, channelId);\n        }\n      };\n\n      const handleChannelRemove = () => {\n        removeChannel(channelId);\n      };\n\n      const handleIQRUpdate = async () => {\n        const {\n          data: loaderData\n        } = loader;\n        const source = Array.isArray(loaderData) ? loaderData[loaderData.length - 1] : loaderData;\n        const raster = await source.getRaster({\n          selection: channels[channelId].selection\n        });\n        const stats = getChannelStats(raster.data);\n        const {\n          q1,\n          q3\n        } = stats;\n        setChannel({ ...c,\n          slider: [q1, q3]\n        }, channelId);\n      };\n\n      return /*#__PURE__*/React.createElement(ChannelController // eslint-disable-next-line react/no-array-index-key\n      , {\n        key: `channel-controller-${channelId}`,\n        dimName: channelLabel,\n        visibility: c.visible,\n        selectionIndex: c.selection[channelLabel],\n        slider: c.slider,\n        color: c.color,\n        channels: channels,\n        channelId: channelId,\n        domainType: domainType,\n        loader: loader,\n        globalLabelValues: globalLabelValues,\n        theme: theme,\n        channelOptions: channelOptions,\n        colormapOn: Boolean(colormap),\n        handlePropertyChange: handleChannelPropertyChange,\n        handleChannelRemove: handleChannelRemove,\n        handleIQRUpdate: handleIQRUpdate,\n        setRasterLayerCallback: setRasterLayerCallback,\n        isLoading: areLayerChannelsLoading[channelId],\n        use3d: use3d,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 371,\n          columnNumber: 11\n        }\n      });\n    });\n  }\n\n  const controllerSectionClasses = useControllerSectionStyles();\n  const {\n    visible\n  } = layer;\n  const visibleSetting = typeof visible === 'boolean' ? visible : true;\n  const Visibility = visibleSetting ? VisibilityIcon : VisibilityOffIcon; // Only show Volume tabs if 3D is available.\n\n  const hasViewableResolutions = Boolean(Array.from({\n    length: loader.data.length\n  }).filter((_, res) => canLoadResolution(loader.data, res)).length);\n  const useVolumeTabs = !disable3d && shape[labels.indexOf('z')] > 1 && hasViewableResolutions;\n  const FullController = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(LayerOptions, {\n    channels: channels,\n    opacity: opacity,\n    colormap: colormap,\n    transparentColor: transparentColor,\n    domainType: domainType // Only allow for global dimension controllers that\n    // exist in the `dimensions` part of the loader.\n    ,\n    globalControlLabels: labels.filter(label => GLOBAL_LABELS.includes(label)),\n    globalLabelValues: globalLabelValues,\n    handleOpacityChange: setOpacity,\n    handleColormapChange: setColormap,\n    handleGlobalChannelsSelectionChange: handleGlobalChannelsSelectionChange,\n    handleTransparentColorChange: setTransparentColor,\n    disableChannelsIfRgbDetected: isRgb(loader) && disableChannelsIfRgbDetected,\n    handleDomainChange: handleDomainChange,\n    shouldShowTransparentColor: shouldShowTransparentColor,\n    shouldShowDomain: shouldShowDomain,\n    shouldShowColormap: shouldShowColormap,\n    use3d: use3d,\n    loader: loader,\n    handleMultiPropertyChange: handleMultiPropertyChange,\n    resolution: resolution,\n    disable3d: disable3d,\n    setRasterLayerCallback: setRasterLayerCallback,\n    setAreAllChannelsLoading: setAreAllChannelsLoading,\n    setViewState: setViewState,\n    spatialHeight: spatialHeight,\n    spatialWidth: spatialWidth,\n    modelMatrix: modelMatrix,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 413,\n      columnNumber: 7\n    }\n  }), isRgb(loader) && disableChannelsIfRgbDetected ? null : channelControllers, isRgb(loader) && disableChannelsIfRgbDetected ? null : /*#__PURE__*/React.createElement(Button, {\n    disabled: channels.length === MAX_CHANNELS,\n    onClick: handleChannelAdd,\n    fullWidth: true,\n    variant: \"outlined\",\n    style: buttonStyles,\n    startIcon: /*#__PURE__*/React.createElement(AddIcon, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 458,\n        columnNumber: 22\n      }\n    }),\n    size: \"small\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 452,\n      columnNumber: 9\n    }\n  }, \"Add Channel\"));\n  return /*#__PURE__*/React.createElement(Accordion, {\n    className: controllerSectionClasses.root,\n    onChange: (e, expanded) => {\n      var _e$target, _e$target$attributes, _e$target$attributes$;\n\n      return !disabled && setIsExpanded(expanded && (e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : (_e$target$attributes = _e$target.attributes) === null || _e$target$attributes === void 0 ? void 0 : (_e$target$attributes$ = _e$target$attributes.role) === null || _e$target$attributes$ === void 0 ? void 0 : _e$target$attributes$.value) === 'presentation');\n    },\n    TransitionProps: {\n      enter: false\n    },\n    expanded: !disabled && isExpanded,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 467,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(StyledAccordionSummary, {\n    expandIcon: /*#__PURE__*/React.createElement(ExpandMoreIcon, {\n      role: \"presentation\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 478,\n        columnNumber: 21\n      }\n    }),\n    \"aria-controls\": `layer-${name}-controls`,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 477,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(Grid, {\n    container: true,\n    direction: \"column\",\n    m: 1,\n    justifyContent: \"center\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 481,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(OverflowEllipsisGrid, {\n    item: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 482,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(Button, {\n    onClick: e => {\n      if (!disabled) {\n        // Needed to prevent affecting the expansion panel from changing\n        e.stopPropagation();\n        const nextVisible = typeof visible === 'boolean' ? !visible : false;\n        setVisible(nextVisible);\n      }\n    },\n    style: {\n      marginRight: 8,\n      marginBottom: 2,\n      padding: 0,\n      minWidth: 0\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 483,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(Visibility, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 499,\n      columnNumber: 15\n    }\n  })), name), !disabled && !isExpanded && !use3d && /*#__PURE__*/React.createElement(Grid, {\n    container: true,\n    direction: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 504,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(Grid, {\n    item: true,\n    xs: 6,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 510,\n      columnNumber: 15\n    }\n  }, /*#__PURE__*/React.createElement(StyledInputLabel, {\n    htmlFor: `layer-${name}-opacity-closed`,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 511,\n      columnNumber: 17\n    }\n  }, \"Opacity:\")), /*#__PURE__*/React.createElement(Grid, {\n    item: true,\n    xs: 6,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 515,\n      columnNumber: 15\n    }\n  }, /*#__PURE__*/React.createElement(Slider, {\n    id: `layer-${name}-opacity-closed`,\n    value: opacity,\n    onChange: (e, v) => setOpacity(v),\n    valueLabelDisplay: \"auto\",\n    getAriaLabel: () => 'opacity slider',\n    min: 0,\n    max: 1,\n    step: 0.01,\n    orientation: \"horizontal\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 516,\n      columnNumber: 17\n    }\n  }))))), /*#__PURE__*/React.createElement(StyledAccordionDetails, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 532,\n      columnNumber: 7\n    }\n  }, useVolumeTabs ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Tabs, {\n    value: tab,\n    onChange: handleTabChange,\n    \"aria-label\": \"simple tabs example\",\n    style: {\n      height: '24px',\n      minHeight: '24px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 535,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(Tab, {\n    label: \"Channels\",\n    style: {\n      fontSize: '.75rem',\n      bottom: 12,\n      width: '50%',\n      minWidth: '50%'\n    },\n    disableRipple: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 541,\n      columnNumber: 15\n    }\n  }), /*#__PURE__*/React.createElement(Tab, {\n    label: \"Volume\",\n    style: {\n      fontSize: '.75rem',\n      bottom: 12,\n      width: '50%',\n      minWidth: '50%'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 551,\n      columnNumber: 15\n    }\n  })), /*#__PURE__*/React.createElement(TabPanel, {\n    value: tab,\n    index: 0,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 561,\n      columnNumber: 13\n    }\n  }, FullController), /*#__PURE__*/React.createElement(TabPanel, {\n    value: tab,\n    index: 1,\n    style: {\n      marginTop: 4\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 564,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(VolumeOptions, {\n    loader: loader,\n    handleSlicerSetting: handleSlicerSetting,\n    handleRenderingModeChange: setRenderingMode,\n    renderingMode: renderingMode,\n    xSlice: xSlice,\n    ySlice: ySlice,\n    zSlice: zSlice,\n    use3d: use3d,\n    setViewState: setViewState,\n    spatialHeight: spatialHeight,\n    spatialWidth: spatialWidth,\n    modelMatrix: modelMatrix,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 565,\n      columnNumber: 15\n    }\n  }))) : FullController, shouldShowRemoveLayerButton ? /*#__PURE__*/React.createElement(Button, {\n    onClick: handleLayerRemove,\n    fullWidth: true,\n    variant: \"outlined\",\n    style: buttonStyles,\n    size: \"small\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 585,\n      columnNumber: 11\n    }\n  }, \"Remove Image Layer\") : null));\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/layer-controller/LayerController.js"],"names":["React","useState","useRef","useEffect","MAX_CHANNELS","getChannelStats","Grid","Button","AddIcon","Slider","Tabs","Tab","Accordion","ExpandMoreIcon","VisibilityIcon","VisibilityOffIcon","LayerOptions","VolumeOptions","useControllerSectionStyles","StyledAccordionDetails","StyledAccordionSummary","StyledInputLabel","OverflowEllipsisGrid","getMultiSelectionStats","GLOBAL_LABELS","getSourceFromLoader","isRgb","canLoadResolution","DOMAINS","TabPanel","props","children","value","index","other","getDomainsAndSliders","loader","selections","domainType","use3d","domains","stats","data","sliders","source","map","dtype","buttonStyles","borderStyle","marginTop","fontWeight","LayerController","layer","name","theme","handleLayerRemove","handleLayerChange","shouldShowTransparentColor","shouldShowDomain","shouldShowColormap","ChannelController","setViewState","disable3d","setRasterLayerCallback","setAreLayerChannelsLoading","areLayerChannelsLoading","disabled","spatialHeight","spatialWidth","disableChannelsIfRgbDetected","shouldShowRemoveLayerButton","colormap","opacity","channels","transparentColor","renderingMode","xSlice","ySlice","zSlice","resolution","modelMatrix","channelRef","current","undefined","firstSelection","selection","channelOptions","tab","setTab","handleTabChange","event","newTab","labels","shape","Array","isArray","length","setDomainType","isExpanded","setIsExpanded","globalLabelValues","setGlobalLabelValues","filter","field","reduce","o","key","setVisible","v","visible","setColormap","setOpacity","setChannels","setTransparentColor","setRenderingMode","handleMultiPropertyChange","obj","handleSlicerSetting","slice","val","setChannelsAndDomainType","newChannels","newDomainType","setChannel","i","addChannel","removeChannel","splice","setAreAllChannelsLoading","newAreLayerChannelsLoading","handleChannelAdd","forEach","label","includes","domain","slider","color","newChannelId","channel","areLayerChannelsLoadingCallback","handleDomainChange","left","right","Math","max","min","c","handleGlobalChannelsSelectionChange","canUpdateChannels","type","then","newChannelsWithSelection","newChannelsWithSliders","prev","channelControllers","channelLabel","find","channelId","setIsLoading","handleChannelPropertyChange","property","update","handleChannelRemove","handleIQRUpdate","loaderData","raster","getRaster","q1","q3","Boolean","controllerSectionClasses","visibleSetting","Visibility","hasViewableResolutions","from","_","res","useVolumeTabs","indexOf","FullController","root","e","expanded","target","attributes","role","enter","stopPropagation","nextVisible","marginRight","marginBottom","padding","minWidth","height","minHeight","fontSize","bottom","width"],"mappings":"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","sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport { MAX_CHANNELS, getChannelStats } from '@hms-dbmi/viv';\n\nimport Grid from '@material-ui/core/Grid';\nimport Button from '@material-ui/core/Button';\nimport AddIcon from '@material-ui/icons/Add';\nimport Slider from '@material-ui/core/Slider';\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\n\nimport Accordion from '@material-ui/core/Accordion';\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\nimport VisibilityIcon from '@material-ui/icons/Visibility';\nimport VisibilityOffIcon from '@material-ui/icons/VisibilityOff';\n\nimport LayerOptions from './LayerOptions';\nimport VolumeOptions from './VolumeOptions';\nimport {\n  useControllerSectionStyles,\n  StyledAccordionDetails,\n  StyledAccordionSummary,\n  StyledInputLabel,\n  OverflowEllipsisGrid,\n} from './styles';\nimport { getMultiSelectionStats } from './utils';\n\nimport { GLOBAL_LABELS } from '../spatial/constants';\nimport { getSourceFromLoader, isRgb } from '../../utils';\nimport { canLoadResolution } from '../utils';\nimport { DOMAINS } from './constants';\n\nfunction TabPanel(props) {\n  const {\n    children, value, index, ...other\n  } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`simple-tabpanel-${index}`}\n      aria-labelledby={`simple-tab-${index}`}\n      {...other}\n    >\n      {value === index && children}\n    </div>\n  );\n}\n\n// Set the domain of the sliders based on either a full range or min/max.\nasync function getDomainsAndSliders(loader, selections, domainType, use3d) {\n  let domains;\n  const stats = await getMultiSelectionStats({\n    loader: loader.data,\n    selections,\n    use3d,\n  });\n  const { sliders } = stats;\n  if (domainType === 'Min/Max') {\n    // eslint-disable-next-line prefer-destructuring\n    domains = stats.domains;\n  }\n  if (domainType === 'Full') {\n    const source = getSourceFromLoader(loader);\n    domains = selections.map(() => DOMAINS[source.dtype]);\n  }\n  return { domains, sliders };\n}\n\nconst buttonStyles = {\n  borderStyle: 'dashed',\n  marginTop: '10px',\n  fontWeight: 400,\n};\n\n/**\n * Controller for the various imaging options (color, opactiy, sliders etc.)\n * @prop {object} imageData Image config object, one of the `images` in the raster schema.\n * @prop {object} layerId Randomly generated id for the image layer that this controller handles.\n * @prop {function} handleLayerRemove Callback for handling the removal of a layer.\n * @prop {object} loader Loader object for the current imaging layer.\n * @prop {function} handleLayerChange Callback for handling the changing of layer properties.\n */\nexport default function LayerController(props) {\n  const {\n    layer,\n    name,\n    loader,\n    theme,\n    handleLayerRemove,\n    handleLayerChange,\n    shouldShowTransparentColor,\n    shouldShowDomain,\n    shouldShowColormap,\n    ChannelController,\n    setViewState,\n    disable3d,\n    setRasterLayerCallback,\n    setAreLayerChannelsLoading,\n    areLayerChannelsLoading,\n    disabled,\n    spatialHeight,\n    spatialWidth,\n    disableChannelsIfRgbDetected,\n    shouldShowRemoveLayerButton,\n  } = props;\n\n  const {\n    colormap,\n    opacity,\n    channels,\n    transparentColor,\n    renderingMode,\n    xSlice,\n    ySlice,\n    zSlice,\n    resolution,\n    use3d,\n    modelMatrix,\n  } = layer;\n  // Channels are used in a lot of callbacks and change handlers\n  // so ensuring they have an up to date copy of the data ensures consistency.\n  // See: https://github.com/vitessce/vitessce/issues/1036\n  const channelRef = useRef(channels);\n  useEffect(() => {\n    channelRef.current = channels;\n    return undefined;\n  }, [channels]);\n\n  const firstSelection = channels[0]?.selection || {};\n\n  const { data, channels: channelOptions } = loader;\n  const [tab, setTab] = useState(0);\n\n  const handleTabChange = (event, newTab) => {\n    setTab(newTab);\n  };\n  const { labels, shape } = Array.isArray(data) ? data[data.length - 1] : data;\n  const [domainType, setDomainType] = useState(layer.domainType);\n  const [isExpanded, setIsExpanded] = useState(true);\n  const [globalLabelValues, setGlobalLabelValues] = useState(\n    GLOBAL_LABELS.filter(\n      field => typeof firstSelection[field] === 'number',\n    ).reduce((o, key) => ({ ...o, [key]: firstSelection[key] }), {}),\n  );\n\n  function setVisible(v) {\n    handleLayerChange({ ...layer, visible: v });\n  }\n\n  function setColormap(v) {\n    handleLayerChange({ ...layer, colormap: v });\n  }\n\n  function setOpacity(v) {\n    handleLayerChange({ ...layer, opacity: v });\n  }\n\n  function setChannels(v) {\n    handleLayerChange({ ...layer, channels: v });\n  }\n  function setTransparentColor(v) {\n    handleLayerChange({ ...layer, transparentColor: v });\n  }\n  function setRenderingMode(v) {\n    handleLayerChange({ ...layer, renderingMode: v });\n  }\n\n  function handleMultiPropertyChange(obj) {\n    handleLayerChange({ ...layer, ...obj });\n  }\n\n  function handleSlicerSetting(slice, val) {\n    handleLayerChange({ ...layer, [`${slice}Slice`]: val });\n  }\n\n  function setChannelsAndDomainType(newChannels, newDomainType) {\n    handleLayerChange({\n      ...layer,\n      channels: newChannels,\n      domainType: newDomainType,\n    });\n  }\n\n  function setChannel(v, i) {\n    const newChannels = [...channelRef.current];\n    newChannels[i] = v;\n    handleLayerChange({ ...layer, channels: newChannels });\n  }\n\n  function addChannel(v) {\n    const newChannels = [...channelRef.current, v];\n    handleLayerChange({ ...layer, channels: newChannels });\n  }\n\n  function removeChannel(i) {\n    const newChannels = [...channelRef.current];\n    newChannels.splice(i, 1);\n    handleLayerChange({ ...layer, channels: newChannels });\n  }\n\n  const setAreAllChannelsLoading = (val) => {\n    const newAreLayerChannelsLoading = channelRef.current.map(() => val);\n    setAreLayerChannelsLoading(newAreLayerChannelsLoading);\n  };\n\n  // Handles adding a channel, creating a default selection\n  // for the current global settings and domain type.\n  const handleChannelAdd = async () => {\n    const selection = {};\n    labels.forEach((label) => {\n      // Set new image to default selection for non-global selections (0)\n      // and use current global selection otherwise.\n      selection[label] = GLOBAL_LABELS.includes(label)\n        ? globalLabelValues[label] || 0\n        : 0;\n    });\n    const { domains, sliders } = await getDomainsAndSliders(\n      loader,\n      [selection],\n      domainType,\n      use3d,\n    );\n    const domain = domains[0];\n    const slider = domain;\n    const color = [255, 255, 255];\n    const visible = true;\n    const newChannelId = channels.length;\n    const newAreLayerChannelsLoading = [...areLayerChannelsLoading];\n    newAreLayerChannelsLoading[newChannelId] = true;\n    setAreLayerChannelsLoading(newAreLayerChannelsLoading);\n    const channel = {\n      selection,\n      slider,\n      visible,\n      color,\n    };\n    setRasterLayerCallback(() => {\n      setChannel({ ...channel, slider: sliders[0] }, newChannelId);\n      const areLayerChannelsLoadingCallback = [...newAreLayerChannelsLoading];\n      areLayerChannelsLoadingCallback[newChannelId] = false;\n      setAreLayerChannelsLoading(areLayerChannelsLoadingCallback);\n      setRasterLayerCallback(null);\n    });\n    addChannel(channel);\n  };\n\n  const handleDomainChange = async (value) => {\n    setDomainType(value);\n    const selections = channels.map(channel => channel.selection);\n    let sliders = channels.map(channel => channel.slider);\n    const { domains } = await getDomainsAndSliders(\n      loader,\n      selections,\n      value,\n      use3d,\n    );\n\n    // If it's the right-most slider, we take the minimum of that and the new value.\n    // Otherwise, we use the maximum of the left-hand side and the new value.\n    sliders = sliders.map((slider, i) => {\n      const [left, right] = slider;\n      return [Math.max(left, domains[i][0]), Math.min(right, domains[i][1])];\n    });\n\n    const newChannels = channels.map((c, i) => ({ ...c, slider: sliders[i] }));\n    setChannelsAndDomainType(newChannels, value);\n  };\n\n  // This call updates all channel selections with new global selection from the UI.\n  const handleGlobalChannelsSelectionChange = async ({ selection, event }) => {\n    const selections = channels.map(channel => ({\n      ...channel.selection,\n      ...selection,\n    }));\n    const canUpdateChannels = event.type === 'mouseup' || event.type === 'keydown';\n    // Only update domains on a mouseup event for the same reason as above.\n    if (canUpdateChannels) {\n      setAreAllChannelsLoading(true);\n      getDomainsAndSliders(loader, selections, domainType, use3d).then(\n        ({ sliders }) => {\n          const newChannelsWithSelection = channels.map(c => ({\n            ...c,\n            selection: { ...c.selection, ...selection },\n          }));\n          // Set the callback before changing the selection\n          // so the callback is used when the layer (re)loads its data.\n          setRasterLayerCallback(() => {\n            setRasterLayerCallback(null);\n            setAreAllChannelsLoading(false);\n            const newChannelsWithSliders = [...newChannelsWithSelection].map(\n              (c, i) => ({\n                ...c,\n                slider: sliders[i],\n              }),\n            );\n            setChannels(newChannelsWithSliders);\n          });\n          setChannels(newChannelsWithSelection);\n        },\n      );\n    }\n    setGlobalLabelValues(prev => ({ ...prev, ...selection }));\n  };\n\n  let channelControllers = [];\n  if (labels.length > 0) {\n    const channelLabel = labels.find(c => c === 'channel' || c === 'c') || labels[0];\n    // Create the channel controllers for each channel.\n    channelControllers = channels.map(\n      // c is an object like { color, selection, slider, visible }.\n      (c, channelId) => {\n        // Update the auxiliary store with the current loading state of a channel.\n        const setIsLoading = (val) => {\n          const newAreLayerChannelsLoading = [...areLayerChannelsLoading];\n          newAreLayerChannelsLoading[channelId] = val;\n          setAreLayerChannelsLoading(newAreLayerChannelsLoading);\n        };\n        // Change one property of a channel (for now - soon\n        // nested structures allowing for multiple z/t selecitons at once, for example).\n        const handleChannelPropertyChange = (property, value) => {\n          // property is something like \"selection\" or \"slider.\"\n          // value is the actual change, like { channel: \"DAPI\" }.\n          const update = { [property]: value };\n          if (property === 'selection') {\n            // Channel is loading until the layer callback is called\n            // by the layer, which fetches the raster data.\n            setIsLoading(true);\n            update.selection = {\n              ...globalLabelValues,\n              ...update.selection,\n            };\n            setChannel({ ...c, ...update }, channelId);\n            // Call back for raster layer handles update of UI\n            // like sliders and the loading state of the channel.\n            setRasterLayerCallback(async () => {\n              const selections = [\n                { ...channels[channelId][property], ...value },\n              ];\n              const { sliders } = await getDomainsAndSliders(\n                loader,\n                selections,\n                domainType,\n                use3d,\n              );\n              [update.slider] = sliders;\n              setChannel({ ...c, ...update }, channelId);\n              setRasterLayerCallback(null);\n              setIsLoading(false);\n            });\n          } else {\n            setChannel({ ...c, ...update }, channelId);\n          }\n        };\n        const handleChannelRemove = () => {\n          removeChannel(channelId);\n        };\n        const handleIQRUpdate = async () => {\n          const { data: loaderData } = loader;\n          const source = Array.isArray(loaderData)\n            ? loaderData[loaderData.length - 1]\n            : loaderData;\n          const raster = await source.getRaster({\n            selection: channels[channelId].selection,\n          });\n          const stats = getChannelStats(raster.data);\n          const { q1, q3 } = stats;\n          setChannel({ ...c, slider: [q1, q3] }, channelId);\n        };\n        return (\n          <ChannelController\n            // eslint-disable-next-line react/no-array-index-key\n            key={`channel-controller-${channelId}`}\n            dimName={channelLabel}\n            visibility={c.visible}\n            selectionIndex={c.selection[channelLabel]}\n            slider={c.slider}\n            color={c.color}\n            channels={channels}\n            channelId={channelId}\n            domainType={domainType}\n            loader={loader}\n            globalLabelValues={globalLabelValues}\n            theme={theme}\n            channelOptions={channelOptions}\n            colormapOn={Boolean(colormap)}\n            handlePropertyChange={handleChannelPropertyChange}\n            handleChannelRemove={handleChannelRemove}\n            handleIQRUpdate={handleIQRUpdate}\n            setRasterLayerCallback={setRasterLayerCallback}\n            isLoading={areLayerChannelsLoading[channelId]}\n            use3d={use3d}\n          />\n        );\n      },\n    );\n  }\n\n  const controllerSectionClasses = useControllerSectionStyles();\n\n  const { visible } = layer;\n  const visibleSetting = typeof visible === 'boolean' ? visible : true;\n  const Visibility = visibleSetting ? VisibilityIcon : VisibilityOffIcon;\n  // Only show Volume tabs if 3D is available.\n  const hasViewableResolutions = Boolean(\n    Array.from({\n      length: loader.data.length,\n    }).filter((_, res) => canLoadResolution(loader.data, res)).length,\n  );\n  const useVolumeTabs = !disable3d && shape[labels.indexOf('z')] > 1 && hasViewableResolutions;\n  const FullController = (\n    <>\n      <LayerOptions\n        channels={channels}\n        opacity={opacity}\n        colormap={colormap}\n        transparentColor={transparentColor}\n        domainType={domainType}\n        // Only allow for global dimension controllers that\n        // exist in the `dimensions` part of the loader.\n        globalControlLabels={labels.filter(label => GLOBAL_LABELS.includes(label))}\n        globalLabelValues={globalLabelValues}\n        handleOpacityChange={setOpacity}\n        handleColormapChange={setColormap}\n        handleGlobalChannelsSelectionChange={\n          handleGlobalChannelsSelectionChange\n        }\n        handleTransparentColorChange={setTransparentColor}\n        disableChannelsIfRgbDetected={\n          isRgb(loader) && disableChannelsIfRgbDetected\n        }\n        handleDomainChange={handleDomainChange}\n        shouldShowTransparentColor={shouldShowTransparentColor}\n        shouldShowDomain={shouldShowDomain}\n        shouldShowColormap={shouldShowColormap}\n        use3d={use3d}\n        loader={loader}\n        handleMultiPropertyChange={handleMultiPropertyChange}\n        resolution={resolution}\n        disable3d={disable3d}\n        setRasterLayerCallback={setRasterLayerCallback}\n        setAreAllChannelsLoading={setAreAllChannelsLoading}\n        setViewState={setViewState}\n        spatialHeight={spatialHeight}\n        spatialWidth={spatialWidth}\n        modelMatrix={modelMatrix}\n      />\n      {isRgb(loader) && disableChannelsIfRgbDetected\n        ? null\n        : channelControllers}\n      {isRgb(loader) && disableChannelsIfRgbDetected ? null : (\n        <Button\n          disabled={channels.length === MAX_CHANNELS}\n          onClick={handleChannelAdd}\n          fullWidth\n          variant=\"outlined\"\n          style={buttonStyles}\n          startIcon={<AddIcon />}\n          size=\"small\"\n        >\n          Add Channel\n        </Button>\n      )}\n    </>\n  );\n  return (\n    <Accordion\n      className={controllerSectionClasses.root}\n      onChange={(e, expanded) => !disabled\n        && setIsExpanded(\n          expanded && e?.target?.attributes?.role?.value === 'presentation',\n        )\n      }\n      TransitionProps={{ enter: false }}\n      expanded={!disabled && isExpanded}\n    >\n      <StyledAccordionSummary\n        expandIcon={<ExpandMoreIcon role=\"presentation\" />}\n        aria-controls={`layer-${name}-controls`}\n      >\n        <Grid container direction=\"column\" m={1} justifyContent=\"center\">\n          <OverflowEllipsisGrid item>\n            <Button\n              onClick={(e) => {\n                if (!disabled) {\n                  // Needed to prevent affecting the expansion panel from changing\n                  e.stopPropagation();\n                  const nextVisible = typeof visible === 'boolean' ? !visible : false;\n                  setVisible(nextVisible);\n                }\n              }}\n              style={{\n                marginRight: 8,\n                marginBottom: 2,\n                padding: 0,\n                minWidth: 0,\n              }}\n            >\n              <Visibility />\n            </Button>\n            {name}\n          </OverflowEllipsisGrid>\n          {!disabled && !isExpanded && !use3d && (\n            <Grid\n              container\n              direction=\"row\"\n              alignItems=\"center\"\n              justifyContent=\"center\"\n            >\n              <Grid item xs={6}>\n                <StyledInputLabel htmlFor={`layer-${name}-opacity-closed`}>\n                  Opacity:\n                </StyledInputLabel>\n              </Grid>\n              <Grid item xs={6}>\n                <Slider\n                  id={`layer-${name}-opacity-closed`}\n                  value={opacity}\n                  onChange={(e, v) => setOpacity(v)}\n                  valueLabelDisplay=\"auto\"\n                  getAriaLabel={() => 'opacity slider'}\n                  min={0}\n                  max={1}\n                  step={0.01}\n                  orientation=\"horizontal\"\n                />\n              </Grid>\n            </Grid>\n          )}\n        </Grid>\n      </StyledAccordionSummary>\n      <StyledAccordionDetails>\n        {useVolumeTabs ? (\n          <>\n            <Tabs\n              value={tab}\n              onChange={handleTabChange}\n              aria-label=\"simple tabs example\"\n              style={{ height: '24px', minHeight: '24px' }}\n            >\n              <Tab\n                label=\"Channels\"\n                style={{\n                  fontSize: '.75rem',\n                  bottom: 12,\n                  width: '50%',\n                  minWidth: '50%',\n                }}\n                disableRipple\n              />\n              <Tab\n                label=\"Volume\"\n                style={{\n                  fontSize: '.75rem',\n                  bottom: 12,\n                  width: '50%',\n                  minWidth: '50%',\n                }}\n              />\n            </Tabs>\n            <TabPanel value={tab} index={0}>\n              {FullController}\n            </TabPanel>\n            <TabPanel value={tab} index={1} style={{ marginTop: 4 }}>\n              <VolumeOptions\n                loader={loader}\n                handleSlicerSetting={handleSlicerSetting}\n                handleRenderingModeChange={setRenderingMode}\n                renderingMode={renderingMode}\n                xSlice={xSlice}\n                ySlice={ySlice}\n                zSlice={zSlice}\n                use3d={use3d}\n                setViewState={setViewState}\n                spatialHeight={spatialHeight}\n                spatialWidth={spatialWidth}\n                modelMatrix={modelMatrix}\n              />\n            </TabPanel>\n          </>\n        ) : (\n          FullController\n        )}\n        {shouldShowRemoveLayerButton ? (\n          <Button\n            onClick={handleLayerRemove}\n            fullWidth\n            variant=\"outlined\"\n            style={buttonStyles}\n            size=\"small\"\n          >\n            Remove Image Layer\n          </Button>\n        ) : null}\n      </StyledAccordionDetails>\n    </Accordion>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}