{"ast":null,"code":"import { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, isXorY, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, Y } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\n\nfunction getSizeChannel(channel) {\n  return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\n\nexport function parseUnitScaleRange(model) {\n  const localScaleComponents = model.component.scales; // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n\n  for (const channel of SCALE_CHANNELS) {\n    const localScaleCmpt = localScaleComponents[channel];\n\n    if (!localScaleCmpt) {\n      continue;\n    }\n\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  }\n}\n\nfunction getBinStepSignal(model, channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {\n    const {\n      bin,\n      field\n    } = fieldDef;\n    const sizeType = getSizeChannel(channel);\n    const sizeSignal = model.getName(sizeType);\n\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(() => {\n        const scaleName = model.scaleName(channel);\n        const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    } else if (isBinning(bin)) {\n      const binSignal = getBinSignalName(model, field, bin); // TODO: extract this to be range step signal\n\n      return new SignalRefWrapper(() => {\n        const updatedName = model.getSignalName(binSignal);\n        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    }\n  }\n\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\n\n\nexport function parseRangeForChannel(channel, model) {\n  const specifiedScale = model.specifiedScales[channel];\n  const {\n    size\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type'); // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            {\n              const range = specifiedScale.range;\n\n              if (isArray(range)) {\n                if (isXorY(channel)) {\n                  return makeExplicit(range.map(v => {\n                    if (v === 'width' || v === 'height') {\n                      // get signal for width/height\n                      // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                      const sizeSignal = model.getName(v);\n                      const getSignalName = model.getSignalName.bind(model);\n                      return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                    }\n\n                    return v;\n                  }));\n                }\n              } else if (isObject(range)) {\n                return makeExplicit({\n                  data: model.requestDataName(DataSourceType.Main),\n                  field: range.field,\n                  sort: {\n                    op: 'min',\n                    field: model.vgField(channel)\n                  }\n                });\n              }\n\n              return makeExplicit(range);\n            }\n\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n\n  if (channel === X || channel === Y) {\n    const sizeChannel = channel === X ? 'width' : 'height';\n    const sizeValue = size[sizeChannel];\n\n    if (isStep(sizeValue)) {\n      if (hasDiscreteDomain(scaleType)) {\n        return makeExplicit({\n          step: sizeValue.step\n        });\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    }\n  }\n\n  const {\n    rangeMin,\n    rangeMax\n  } = specifiedScale;\n  const d = defaultRange(channel, model);\n\n  if ((rangeMin !== undefined || rangeMax !== undefined) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n  scaleTypeSupportProperty(scaleType, 'rangeMin') && isArray(d) && d.length === 2) {\n    return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);\n  }\n\n  return makeImplicit(d);\n}\n\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return Object.assign({\n      scheme: scheme.name\n    }, util.omit(scheme, ['name']));\n  }\n\n  return {\n    scheme: scheme\n  };\n}\n\nfunction defaultRange(channel, model) {\n  const {\n    size,\n    config,\n    mark,\n    encoding\n  } = model;\n  const getSignalName = model.getSignalName.bind(model);\n  const {\n    type\n  } = getFieldOrDatumDef(encoding[channel]);\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n  const {\n    domain,\n    domainMid\n  } = model.specifiedScales[channel];\n\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          if (channel === X && !size.width) {\n            const w = getViewConfigDiscreteSize(config.view, 'width');\n\n            if (isStep(w)) {\n              return w;\n            }\n          } else if (channel === Y && !size.height) {\n            const h = getViewConfigDiscreteSize(config.view, 'height');\n\n            if (isStep(h)) {\n              return h;\n            }\n          }\n        } // If step is null, use zero to width or height.\n        // Note that we use SignalRefWrapper to account for potential merges and renames.\n\n\n        const sizeType = getSizeChannel(channel);\n        const sizeSignal = model.getName(sizeType);\n\n        if (channel === Y && hasContinuousDomain(scaleType)) {\n          // For y continuous scale, we have to start from the height as the bottom part has the max value.\n          return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n        } else {\n          return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n        }\n      }\n\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        const zero = model.component.scales[channel].get('zero');\n        const rangeMin = sizeRangeMin(mark, zero, config);\n        const rangeMax = sizeRangeMax(mark, size, model, config);\n\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n\n    case THETA:\n      return [0, Math.PI * 2];\n\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n\n    case RADIUS:\n      {\n        // max radius = half od min(width,height)\n        return [0, new SignalRefWrapper(() => {\n          const w = model.getSignalName('width');\n          const h = model.getSignalName('height');\n          return `min(${w},${h})/2`;\n        })];\n      }\n\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n\n    case STROKEDASH:\n      return [// TODO: add this to Vega's config.range?\n      [1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];\n\n    case SHAPE:\n      return 'symbol';\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n\n\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n\n    case 'quantize':\n      return config.scale.quantizeCount;\n\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel)); // default threshold boundaries for threshold scale since domain has cardinality of 2\n\n        return 3;\n      }\n\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\n\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = signalOrStringValue(rangeMax);\n    const rMin = signalOrStringValue(rangeMin);\n    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n  };\n\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\n\nfunction sizeRangeMin(mark, zero, config) {\n  if (zero) {\n    if (isSignalRef(zero)) {\n      return {\n        signal: `${zero.signal} ? 0 : ${sizeRangeMin(mark, false, config)}`\n      };\n    } else {\n      return 0;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n\n    case 'text':\n      return config.scale.minFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark, size, model, config) {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n\n        const min = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(() => `${min.signal} - 1`);\n        }\n      }\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n\n    case 'text':\n      return config.scale.maxFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n\n        const pointStep = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\n\n\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}","map":{"version":3,"sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, isXorY, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, Y } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\nfunction getSizeChannel(channel) {\n    return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\nexport function parseUnitScaleRange(model) {\n    const localScaleComponents = model.component.scales;\n    // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n    for (const channel of SCALE_CHANNELS) {\n        const localScaleCmpt = localScaleComponents[channel];\n        if (!localScaleCmpt) {\n            continue;\n        }\n        const rangeWithExplicit = parseRangeForChannel(channel, model);\n        localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n    }\n}\nfunction getBinStepSignal(model, channel) {\n    const fieldDef = model.fieldDef(channel);\n    if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {\n        const { bin, field } = fieldDef;\n        const sizeType = getSizeChannel(channel);\n        const sizeSignal = model.getName(sizeType);\n        if (isObject(bin) && bin.binned && bin.step !== undefined) {\n            return new SignalRefWrapper(() => {\n                const scaleName = model.scaleName(channel);\n                const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n                return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n            });\n        }\n        else if (isBinning(bin)) {\n            const binSignal = getBinSignalName(model, field, bin);\n            // TODO: extract this to be range step signal\n            return new SignalRefWrapper(() => {\n                const updatedName = model.getSignalName(binSignal);\n                const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n                return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n            });\n        }\n    }\n    return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel, model) {\n    const specifiedScale = model.specifiedScales[channel];\n    const { size } = model;\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const scaleType = mergedScaleCmpt.get('type');\n    // Check if any of the range properties is specified.\n    // If so, check if it is compatible and make sure that we only output one of the properties\n    for (const property of RANGE_PROPERTIES) {\n        if (specifiedScale[property] !== undefined) {\n            const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n            const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n            if (!supportedByScaleType) {\n                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n            }\n            else if (channelIncompatability) {\n                // channel\n                log.warn(channelIncompatability);\n            }\n            else {\n                switch (property) {\n                    case 'range': {\n                        const range = specifiedScale.range;\n                        if (isArray(range)) {\n                            if (isXorY(channel)) {\n                                return makeExplicit(range.map(v => {\n                                    if (v === 'width' || v === 'height') {\n                                        // get signal for width/height\n                                        // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                                        const sizeSignal = model.getName(v);\n                                        const getSignalName = model.getSignalName.bind(model);\n                                        return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                                    }\n                                    return v;\n                                }));\n                            }\n                        }\n                        else if (isObject(range)) {\n                            return makeExplicit({\n                                data: model.requestDataName(DataSourceType.Main),\n                                field: range.field,\n                                sort: { op: 'min', field: model.vgField(channel) }\n                            });\n                        }\n                        return makeExplicit(range);\n                    }\n                    case 'scheme':\n                        return makeExplicit(parseScheme(specifiedScale[property]));\n                }\n            }\n        }\n    }\n    if (channel === X || channel === Y) {\n        const sizeChannel = channel === X ? 'width' : 'height';\n        const sizeValue = size[sizeChannel];\n        if (isStep(sizeValue)) {\n            if (hasDiscreteDomain(scaleType)) {\n                return makeExplicit({ step: sizeValue.step });\n            }\n            else {\n                log.warn(log.message.stepDropped(sizeChannel));\n            }\n        }\n    }\n    const { rangeMin, rangeMax } = specifiedScale;\n    const d = defaultRange(channel, model);\n    if ((rangeMin !== undefined || rangeMax !== undefined) &&\n        // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n        scaleTypeSupportProperty(scaleType, 'rangeMin') &&\n        isArray(d) &&\n        d.length === 2) {\n        return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);\n    }\n    return makeImplicit(d);\n}\nfunction parseScheme(scheme) {\n    if (isExtendedScheme(scheme)) {\n        return Object.assign({ scheme: scheme.name }, util.omit(scheme, ['name']));\n    }\n    return { scheme: scheme };\n}\nfunction defaultRange(channel, model) {\n    const { size, config, mark, encoding } = model;\n    const getSignalName = model.getSignalName.bind(model);\n    const { type } = getFieldOrDatumDef(encoding[channel]);\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const scaleType = mergedScaleCmpt.get('type');\n    const { domain, domainMid } = model.specifiedScales[channel];\n    switch (channel) {\n        case X:\n        case Y: {\n            // If there is no explicit width/height for discrete x/y scales\n            if (util.contains(['point', 'band'], scaleType)) {\n                if (channel === X && !size.width) {\n                    const w = getViewConfigDiscreteSize(config.view, 'width');\n                    if (isStep(w)) {\n                        return w;\n                    }\n                }\n                else if (channel === Y && !size.height) {\n                    const h = getViewConfigDiscreteSize(config.view, 'height');\n                    if (isStep(h)) {\n                        return h;\n                    }\n                }\n            }\n            // If step is null, use zero to width or height.\n            // Note that we use SignalRefWrapper to account for potential merges and renames.\n            const sizeType = getSizeChannel(channel);\n            const sizeSignal = model.getName(sizeType);\n            if (channel === Y && hasContinuousDomain(scaleType)) {\n                // For y continuous scale, we have to start from the height as the bottom part has the max value.\n                return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n            }\n            else {\n                return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n            }\n        }\n        case SIZE: {\n            // TODO: support custom rangeMin, rangeMax\n            const zero = model.component.scales[channel].get('zero');\n            const rangeMin = sizeRangeMin(mark, zero, config);\n            const rangeMax = sizeRangeMax(mark, size, model, config);\n            if (isContinuousToDiscrete(scaleType)) {\n                return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n            }\n            else {\n                return [rangeMin, rangeMax];\n            }\n        }\n        case THETA:\n            return [0, Math.PI * 2];\n        case ANGLE:\n            // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n            // (It's weird to add just config.scale.min/maxAngleDegree for now)\n            return [0, 360];\n        case RADIUS: {\n            // max radius = half od min(width,height)\n            return [\n                0,\n                new SignalRefWrapper(() => {\n                    const w = model.getSignalName('width');\n                    const h = model.getSignalName('height');\n                    return `min(${w},${h})/2`;\n                })\n            ];\n        }\n        case STROKEWIDTH:\n            // TODO: support custom rangeMin, rangeMax\n            return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n        case STROKEDASH:\n            return [\n                // TODO: add this to Vega's config.range?\n                [1, 0],\n                [4, 2],\n                [2, 1],\n                [1, 1],\n                [1, 2, 4, 2]\n            ];\n        case SHAPE:\n            return 'symbol';\n        case COLOR:\n        case FILL:\n        case STROKE:\n            if (scaleType === 'ordinal') {\n                // Only nominal data uses ordinal scale by default\n                return type === 'nominal' ? 'category' : 'ordinal';\n            }\n            else {\n                if (domainMid !== undefined) {\n                    return 'diverging';\n                }\n                else {\n                    return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n                }\n            }\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n            // TODO: support custom rangeMin, rangeMax\n            return [config.scale.minOpacity, config.scale.maxOpacity];\n    }\n    /* istanbul ignore next: should never reach here */\n    throw new Error(`Scale range undefined for channel ${channel}`);\n}\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n    switch (scaleType) {\n        case 'quantile':\n            return config.scale.quantileCount;\n        case 'quantize':\n            return config.scale.quantizeCount;\n        case 'threshold':\n            if (domain !== undefined && isArray(domain)) {\n                return domain.length + 1;\n            }\n            else {\n                log.warn(log.message.domainRequiredForThresholdScale(channel));\n                // default threshold boundaries for threshold scale since domain has cardinality of 2\n                return 3;\n            }\n    }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n    // always return a signal since it's better to compute the sequence in Vega later\n    const f = () => {\n        const rMax = signalOrStringValue(rangeMax);\n        const rMin = signalOrStringValue(rangeMin);\n        const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n        return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n    };\n    if (isSignalRef(rangeMax)) {\n        return new SignalRefWrapper(f);\n    }\n    else {\n        return { signal: f() };\n    }\n}\nfunction sizeRangeMin(mark, zero, config) {\n    if (zero) {\n        if (isSignalRef(zero)) {\n            return { signal: `${zero.signal} ? 0 : ${sizeRangeMin(mark, false, config)}` };\n        }\n        else {\n            return 0;\n        }\n    }\n    switch (mark) {\n        case 'bar':\n        case 'tick':\n            return config.scale.minBandSize;\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return config.scale.minStrokeWidth;\n        case 'text':\n            return config.scale.minFontSize;\n        case 'point':\n        case 'square':\n        case 'circle':\n            return config.scale.minSize;\n    }\n    /* istanbul ignore next: should never reach here */\n    // sizeRangeMin not implemented for the mark\n    throw new Error(log.message.incompatibleChannel('size', mark));\n}\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\nfunction sizeRangeMax(mark, size, model, config) {\n    const xyStepSignals = {\n        x: getBinStepSignal(model, 'x'),\n        y: getBinStepSignal(model, 'y')\n    };\n    switch (mark) {\n        case 'bar':\n        case 'tick': {\n            if (config.scale.maxBandSize !== undefined) {\n                return config.scale.maxBandSize;\n            }\n            const min = minXYStep(size, xyStepSignals, config.view);\n            if (isNumber(min)) {\n                return min - 1;\n            }\n            else {\n                return new SignalRefWrapper(() => `${min.signal} - 1`);\n            }\n        }\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return config.scale.maxStrokeWidth;\n        case 'text':\n            return config.scale.maxFontSize;\n        case 'point':\n        case 'square':\n        case 'circle': {\n            if (config.scale.maxSize) {\n                return config.scale.maxSize;\n            }\n            const pointStep = minXYStep(size, xyStepSignals, config.view);\n            if (isNumber(pointStep)) {\n                return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n            }\n            else {\n                return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n            }\n        }\n    }\n    /* istanbul ignore next: should never reach here */\n    // sizeRangeMax not implemented for the mark\n    throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n    const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n    const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n    if (xyStepSignals.x || xyStepSignals.y) {\n        return new SignalRefWrapper(() => {\n            const exprs = [\n                xyStepSignals.x ? xyStepSignals.x.signal : widthStep,\n                xyStepSignals.y ? xyStepSignals.y.signal : heightStep\n            ];\n            return `min(${exprs.join(', ')})`;\n        });\n    }\n    return Math.min(widthStep, heightStep);\n}\n//# sourceMappingURL=range.js.map"]},"metadata":{},"sourceType":"module"}