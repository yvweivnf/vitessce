{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isObject } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nexport var TUPLE_FIELDS = '_tuple_fields';\nexport var SelectionProjectionComponent = function SelectionProjectionComponent() {\n  _classCallCheck(this, SelectionProjectionComponent);\n\n  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n    items[_key] = arguments[_key];\n  }\n\n  this.items = items;\n  this.hasChannel = {};\n  this.hasField = {};\n};\nvar project = {\n  defined: function defined() {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: function parse(model, selCmpt, selDef) {\n    var _a;\n\n    var name = selCmpt.name;\n    var proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();\n    var parsed = {};\n    var timeUnits = {};\n    var signals = new Set();\n\n    var signalName = function signalName(p, range) {\n      var suffix = range === 'visual' ? p.channel : p.field;\n      var sg = varName(\"\".concat(name, \"_\").concat(suffix));\n\n      for (var counter = 1; signals.has(sg); counter++) {\n        sg = varName(\"\".concat(name, \"_\").concat(suffix, \"_\").concat(counter));\n      }\n\n      signals.add(sg);\n      return _defineProperty({}, range, sg);\n    };\n\n    var type = selCmpt.type;\n    var cfg = model.config.selection[type];\n    var init = selDef.value !== undefined ? array(selDef.value) : null; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n\n    var _ref2 = isObject(selDef.select) ? selDef.select : {},\n        fields = _ref2.fields,\n        encodings = _ref2.encodings;\n\n    if (!fields && !encodings && init) {\n      var _iterator = _createForOfIteratorHelper(init),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var initVal = _step.value;\n\n          // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n          if (!isObject(initVal)) {\n            continue;\n          }\n\n          var _iterator2 = _createForOfIteratorHelper(keys(initVal)),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var key = _step2.value;\n\n              if (isSingleDefUnitChannel(key)) {\n                (encodings || (encodings = [])).push(key);\n              } else {\n                if (type === 'interval') {\n                  log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                  encodings = cfg.encodings;\n                } else {\n                  (fields || (fields = [])).push(key);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // If no initial value is specified, use the default configuration.\n    // We break this out as a separate if block (instead of an else condition)\n    // to account for unprojected point selections that have scalar initial values\n\n\n    if (!fields && !encodings) {\n      encodings = cfg.encodings;\n\n      if ('fields' in cfg) {\n        fields = cfg.fields;\n      }\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(encodings !== null && encodings !== void 0 ? encodings : []),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var channel = _step3.value;\n        var fieldDef = model.fieldDef(channel);\n\n        if (fieldDef) {\n          var field = fieldDef.field;\n\n          if (fieldDef.aggregate) {\n            log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n            continue;\n          } else if (!field) {\n            log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            continue;\n          }\n\n          if (fieldDef.timeUnit) {\n            field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n            // TimeUnitNode. This node may need to be inserted into the\n            // dataflow if the selection is used across views that do not\n            // have these time units defined.\n\n            var component = {\n              timeUnit: fieldDef.timeUnit,\n              as: field,\n              field: fieldDef.field\n            };\n            timeUnits[hash(component)] = component;\n          } // Prevent duplicate projections on the same field.\n          // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n          if (!parsed[field]) {\n            // Determine whether the tuple will store enumerated or ranged values.\n            // Interval selections store ranges for continuous scales, and enumerations otherwise.\n            // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n            var tplType = 'E';\n\n            if (type === 'interval') {\n              var scaleType = model.getScaleComponent(channel).get('type');\n\n              if (hasContinuousDomain(scaleType)) {\n                tplType = 'R';\n              }\n            } else if (fieldDef.bin) {\n              tplType = 'R-RE';\n            }\n\n            var p = {\n              field: field,\n              channel: channel,\n              type: tplType\n            };\n            p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n            proj.items.push(parsed[field] = p);\n            proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n          }\n        } else {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var _iterator4 = _createForOfIteratorHelper(fields !== null && fields !== void 0 ? fields : []),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _field = _step4.value;\n        if (proj.hasField[_field]) continue;\n        var _p = {\n          type: 'E',\n          field: _field\n        };\n        _p.signals = Object.assign({}, signalName(_p, 'data'));\n        proj.items.push(_p);\n        proj.hasField[_field] = _p;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    if (init) {\n      selCmpt.init = init.map(function (v) {\n        // Selections can be initialized either with a full object that maps projections to values\n        // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n        return proj.items.map(function (p) {\n          return isObject(v) ? v[p.channel] !== undefined ? v[p.channel] : v[p.field] : v;\n        });\n      });\n    }\n\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: function signals(model, selCmpt, allSignals) {\n    var name = selCmpt.name + TUPLE_FIELDS;\n    var hasSignal = allSignals.filter(function (s) {\n      return s.name === name;\n    });\n    return hasSignal.length > 0 ? allSignals : allSignals.concat({\n      name: name,\n      value: selCmpt.project.items.map(function (proj) {\n        var signals = proj.signals,\n            hasLegend = proj.hasLegend,\n            rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n\n        rest.field = replacePathInField(rest.field);\n        return rest;\n      })\n    });\n  }\n};\nexport default project;","map":{"version":3,"sources":["../../../../src/compile/selection/project.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isObject } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n    constructor(...items) {\n        this.items = items;\n        this.hasChannel = {};\n        this.hasField = {};\n    }\n}\nconst project = {\n    defined: () => {\n        return true; // This transform handles its own defaults, so always run parse.\n    },\n    parse: (model, selCmpt, selDef) => {\n        var _a;\n        const name = selCmpt.name;\n        const proj = ((_a = selCmpt.project) !== null && _a !== void 0 ? _a : (selCmpt.project = new SelectionProjectionComponent()));\n        const parsed = {};\n        const timeUnits = {};\n        const signals = new Set();\n        const signalName = (p, range) => {\n            const suffix = range === 'visual' ? p.channel : p.field;\n            let sg = varName(`${name}_${suffix}`);\n            for (let counter = 1; signals.has(sg); counter++) {\n                sg = varName(`${name}_${suffix}_${counter}`);\n            }\n            signals.add(sg);\n            return { [range]: sg };\n        };\n        const type = selCmpt.type;\n        const cfg = model.config.selection[type];\n        const init = selDef.value !== undefined\n            ? array(selDef.value)\n            : null;\n        // If no explicit projection (either fields or encodings) is specified, set some defaults.\n        // If an initial value is set, try to infer projections.\n        let { fields, encodings } = (isObject(selDef.select) ? selDef.select : {});\n        if (!fields && !encodings && init) {\n            for (const initVal of init) {\n                // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n                if (!isObject(initVal)) {\n                    continue;\n                }\n                for (const key of keys(initVal)) {\n                    if (isSingleDefUnitChannel(key)) {\n                        (encodings || (encodings = [])).push(key);\n                    }\n                    else {\n                        if (type === 'interval') {\n                            log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                            encodings = cfg.encodings;\n                        }\n                        else {\n                            (fields || (fields = [])).push(key);\n                        }\n                    }\n                }\n            }\n        }\n        // If no initial value is specified, use the default configuration.\n        // We break this out as a separate if block (instead of an else condition)\n        // to account for unprojected point selections that have scalar initial values\n        if (!fields && !encodings) {\n            encodings = cfg.encodings;\n            if ('fields' in cfg) {\n                fields = cfg.fields;\n            }\n        }\n        for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {\n            const fieldDef = model.fieldDef(channel);\n            if (fieldDef) {\n                let field = fieldDef.field;\n                if (fieldDef.aggregate) {\n                    log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n                    continue;\n                }\n                else if (!field) {\n                    log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n                    continue;\n                }\n                if (fieldDef.timeUnit) {\n                    field = model.vgField(channel);\n                    // Construct TimeUnitComponents which will be combined into a\n                    // TimeUnitNode. This node may need to be inserted into the\n                    // dataflow if the selection is used across views that do not\n                    // have these time units defined.\n                    const component = {\n                        timeUnit: fieldDef.timeUnit,\n                        as: field,\n                        field: fieldDef.field\n                    };\n                    timeUnits[hash(component)] = component;\n                }\n                // Prevent duplicate projections on the same field.\n                // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n                if (!parsed[field]) {\n                    // Determine whether the tuple will store enumerated or ranged values.\n                    // Interval selections store ranges for continuous scales, and enumerations otherwise.\n                    // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n                    let tplType = 'E';\n                    if (type === 'interval') {\n                        const scaleType = model.getScaleComponent(channel).get('type');\n                        if (hasContinuousDomain(scaleType)) {\n                            tplType = 'R';\n                        }\n                    }\n                    else if (fieldDef.bin) {\n                        tplType = 'R-RE';\n                    }\n                    const p = { field, channel, type: tplType };\n                    p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n                    proj.items.push((parsed[field] = p));\n                    proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n                }\n            }\n            else {\n                log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            }\n        }\n        for (const field of fields !== null && fields !== void 0 ? fields : []) {\n            if (proj.hasField[field])\n                continue;\n            const p = { type: 'E', field };\n            p.signals = Object.assign({}, signalName(p, 'data'));\n            proj.items.push(p);\n            proj.hasField[field] = p;\n        }\n        if (init) {\n            selCmpt.init = init.map((v) => {\n                // Selections can be initialized either with a full object that maps projections to values\n                // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n                return proj.items.map(p => (isObject(v) ? (v[p.channel] !== undefined ? v[p.channel] : v[p.field]) : v));\n            });\n        }\n        if (!isEmpty(timeUnits)) {\n            proj.timeUnit = new TimeUnitNode(null, timeUnits);\n        }\n    },\n    signals: (model, selCmpt, allSignals) => {\n        const name = selCmpt.name + TUPLE_FIELDS;\n        const hasSignal = allSignals.filter(s => s.name === name);\n        return hasSignal.length > 0\n            ? allSignals\n            : allSignals.concat({\n                name,\n                value: selCmpt.project.items.map(proj => {\n                    const { signals, hasLegend } = proj, rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n                    rest.field = replacePathInField(rest.field);\n                    return rest;\n                })\n            });\n    }\n};\nexport default project;\n//# sourceMappingURL=project.js.map"]},"metadata":{},"sourceType":"module"}