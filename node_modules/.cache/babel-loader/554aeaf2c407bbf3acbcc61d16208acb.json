{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport { isMeshoptSupported, meshoptDecodeGltfBuffer } from '../../meshopt/meshopt-decoder';\nvar DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\nvar EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport var name = EXT_MESHOPT_COMPRESSION;\nexport function preprocess(gltfData) {\n  var scenegraph = new GLTFScenegraph(gltfData);\n\n  if (scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) && !isMeshoptSupported()) {\n    throw new Error(\"gltf: Required extension \".concat(EXT_MESHOPT_COMPRESSION, \" not supported by browser\"));\n  }\n}\nexport function decode(_x, _x2) {\n  return _decode.apply(this, arguments);\n}\n\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltfData, options) {\n    var _options$gltf, scenegraph, promises, _iterator, _step, bufferViewIndex;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            scenegraph = new GLTFScenegraph(gltfData);\n\n            if (options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 3:\n            promises = [];\n            _iterator = _createForOfIteratorHelper(gltfData.json.bufferViews || []);\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                bufferViewIndex = _step.value;\n                promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            _context.next = 8;\n            return Promise.all(promises);\n\n          case 8:\n            scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\n\nfunction decodeMeshoptBufferView(_x3, _x4) {\n  return _decodeMeshoptBufferView.apply(this, arguments);\n}\n\nfunction _decodeMeshoptBufferView() {\n  _decodeMeshoptBufferView = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(scenegraph, bufferView) {\n    var meshoptExtension, buffer, _meshoptExtension$byt, byteOffset, _meshoptExtension$byt2, byteLength, byteStride, count, mode, _meshoptExtension$fil, filter, source, result;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n\n            if (!meshoptExtension) {\n              _context2.next = 9;\n              break;\n            }\n\n            buffer = bufferView.buffer;\n            _meshoptExtension$byt = meshoptExtension.byteOffset, byteOffset = _meshoptExtension$byt === void 0 ? 0 : _meshoptExtension$byt, _meshoptExtension$byt2 = meshoptExtension.byteLength, byteLength = _meshoptExtension$byt2 === void 0 ? 0 : _meshoptExtension$byt2, byteStride = meshoptExtension.byteStride, count = meshoptExtension.count, mode = meshoptExtension.mode, _meshoptExtension$fil = meshoptExtension.filter, filter = _meshoptExtension$fil === void 0 ? 'NONE' : _meshoptExtension$fil;\n            source = new Uint8Array(buffer, byteOffset, byteLength);\n            result = new ArrayBuffer(count * byteStride);\n            _context2.next = 8;\n            return meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n\n          case 8:\n            return _context2.abrupt(\"return\", result);\n\n          case 9:\n            return _context2.abrupt(\"return\", null);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _decodeMeshoptBufferView.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/EXT_meshopt_compression.ts"],"names":["DEFAULT_MESHOPT_OPTIONS","byteOffset","filter","EXT_MESHOPT_COMPRESSION","name","scenegraph","isMeshoptSupported","options","promises","gltfData","decodeMeshoptBufferView","Promise","meshoptExtension","buffer","bufferView","byteLength","source","result","count","meshoptDecodeGltfBuffer"],"mappings":";;;AAGA,OAAA,cAAA,MAAA,wBAAA;AACA,SAAA,kBAAA,EAAA,uBAAA,QAAA,+BAAA;AAIA,IAAMA,uBAAuB,GAAG;AAC9BC,EAAAA,UAAU,EADoB,CAAA;AAE9BC,EAAAA,MAAM,EAAE;AAFsB,CAAhC;AAMA,IAAMC,uBAAuB,GAA7B,yBAAA;AAEA,OAAO,IAAMC,IAAI,GAAV,uBAAA;AAEP,OAAO,SAAA,UAAA,CAAA,QAAA,EAA4C;AACjD,MAAMC,UAAU,GAAG,IAAA,cAAA,CAAnB,QAAmB,CAAnB;;AACA,MACEA,UAAU,CAAVA,qBAAAA,GAAAA,QAAAA,CAAAA,uBAAAA,KACA,CAACC,kBAFH,EAAA,EAGE;AACA,UAAM,IAAA,KAAA,CAAA,4BAAA,MAAA,CAAA,uBAAA,EAAN,2BAAM,CAAA,CAAN;AACD;AACF;AAED,gBAAO,MAAP;AAAA;AAAA;;;qEAAO,iBAAA,QAAA,EAAA,OAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACCD,YAAAA,UADD,GACc,IAAA,cAAA,CAAnB,QAAmB,CADd;;AAAA,gBAGAE,OAAD,KAAA,IAACA,IAAAA,OAAD,KAAA,KAAA,CAACA,IAAD,CAAA,aAAA,GAACA,OAAO,CAAR,IAAA,MAAA,IAACA,IAAD,aAAA,KAAA,KAAA,CAACA,IAAAA,aAAAA,CAAL,gBAHK;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAOCC,YAAAA,QAPD,GAOL,EAPK;AAAA,mDAQyBC,QAAQ,CAARA,IAAAA,CAAAA,WAAAA,IAA9B,EARK;;AAAA;AAQL,kEAA+D;AAA/D,gBAAA,eAA+D;AAC7DD,gBAAAA,QAAQ,CAARA,IAAAA,CAAcE,uBAAuB,CAAA,UAAA,EAArCF,eAAqC,CAArCA;AACD;AAVI;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAaCG,OAAO,CAAPA,GAAAA,CAAN,QAAMA,CAbD;;AAAA;AAgBLN,YAAAA,UAAU,CAAVA,eAAAA,CAAAA,uBAAAA;;AAhBK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAoBP,uB;;;;;sFAAA,kBAAA,UAAA,EAAA,UAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIQO,YAAAA,gBAJR,GAI2BP,UAAU,CAAVA,kBAAAA,CAAAA,UAAAA,EAAzB,uBAAyBA,CAJ3B;;AAAA,iBAQE,gBARF;AAAA;AAAA;AAAA;;AASUQ,YAAAA,MATV,GASmBC,UAAU,CAAzB,MATJ;AAAA,oCAWI,gBAXJ,CAYMb,UAZN,EAYMA,UAZN,sCAWU,CAXV,mDAWI,gBAXJ,CAaMc,UAbN,EAaMA,UAbN,uCAWU,CAXV,2BAWU,UAXV,GAWI,gBAXJ,CAWU,UAXV,EAWU,KAXV,GAWI,gBAXJ,CAWU,KAXV,EAWU,IAXV,GAWI,gBAXJ,CAWU,IAXV,0BAWI,gBAXJ,CAiBMb,MAjBN,EAiBMA,MAjBN,sCAiBe,MAjBf;AAqBUc,YAAAA,MArBV,GAqBmB,IAAA,UAAA,CAAA,MAAA,EAAA,UAAA,EAAf,UAAe,CArBnB;AAsBUC,YAAAA,MAtBV,GAsBmB,IAAA,WAAA,CAAgBC,KAAK,GAApC,UAAe,CAtBnB;AAAA;AAAA,mBAuBUC,uBAAuB,CAAC,IAAA,UAAA,CAAD,MAAC,CAAD,EAAA,KAAA,EAAA,UAAA,EAAA,MAAA,EAAA,IAAA,EAA7B,MAA6B,CAvBjC;;AAAA;AAAA,8CAwBI,MAxBJ;;AAAA;AAAA,8CA2BE,IA3BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/* eslint-disable camelcase */\nimport type {GLTF, GLTFBufferView, GLTF_EXT_meshopt_compression} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {isMeshoptSupported, meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nexport const name = EXT_MESHOPT_COMPRESSION;\n\nexport function preprocess(gltfData: {json: GLTF}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  if (\n    scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) &&\n    !isMeshoptSupported()\n  ) {\n    throw new Error(`gltf: Required extension ${EXT_MESHOPT_COMPRESSION} not supported by browser`);\n  }\n}\n\nexport async function decode(gltfData: {json: GLTF}, options: GLTFLoaderOptions) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(\n  scenegraph: GLTFScenegraph,\n  bufferView: GLTFBufferView\n): Promise<ArrayBuffer | null> {\n  const meshoptExtension = scenegraph.getObjectExtension<GLTF_EXT_meshopt_compression>(\n    bufferView,\n    EXT_MESHOPT_COMPRESSION\n  );\n  if (meshoptExtension) {\n    const buffer = bufferView.buffer;\n\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n\n    // @ts-expect-error TODO - fix buffer handling\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}