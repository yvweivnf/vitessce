{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { readFeature, classifyRings } from '../../helpers/mapbox-util-functions';\nexport default class VectorTileFeature {\n  static get types() {\n    return ['Unknown', 'Point', 'LineString', 'Polygon'];\n  }\n\n  constructor(pbf, end, extent, keys, values) {\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"extent\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"_pbf\", void 0);\n\n    _defineProperty(this, \"_geometry\", void 0);\n\n    _defineProperty(this, \"_keys\", void 0);\n\n    _defineProperty(this, \"_values\", void 0);\n\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    pbf.readFields(readFeature, this, end);\n  }\n\n  loadGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    const lines = [];\n    let line;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          if (line) lines.push(line);\n          line = [];\n        }\n\n        if (line) line.push([x, y]);\n      } else if (cmd === 7) {\n        if (line) {\n          line.push(line[0].slice());\n        }\n      } else {\n        throw new Error(\"unknown command \".concat(cmd));\n      }\n    }\n\n    if (line) lines.push(line);\n    return lines;\n  }\n\n  bbox() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      } else if (cmd !== 7) {\n        throw new Error(\"unknown command \".concat(cmd));\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n\n  _toGeoJSON(transform) {\n    let coords = this.loadGeometry();\n    let type = VectorTileFeature.types[this.type];\n    let i;\n    let j;\n\n    switch (this.type) {\n      case 1:\n        const points = [];\n\n        for (i = 0; i < coords.length; i++) {\n          points[i] = coords[i][0];\n        }\n\n        coords = points;\n        transform(coords, this);\n        break;\n\n      case 2:\n        for (i = 0; i < coords.length; i++) {\n          transform(coords[i], this);\n        }\n\n        break;\n\n      case 3:\n        coords = classifyRings(coords);\n\n        for (i = 0; i < coords.length; i++) {\n          for (j = 0; j < coords[i].length; j++) {\n            transform(coords[i][j], this);\n          }\n        }\n\n        break;\n    }\n\n    if (coords.length === 1) {\n      coords = coords[0];\n    } else {\n      type = \"Multi\".concat(type);\n    }\n\n    const result = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates: coords\n      },\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toGeoJSON(options) {\n    if (typeof options === 'function') {\n      return this._toGeoJSON(options);\n    }\n\n    const {\n      x,\n      y,\n      z\n    } = options;\n    const size = this.extent * Math.pow(2, z);\n    const x0 = this.extent * x;\n    const y0 = this.extent * y;\n\n    function project(line) {\n      for (let j = 0; j < line.length; j++) {\n        const p = line[j];\n        p[0] = (p[0] + x0) * 360 / size - 180;\n        const y2 = 180 - (p[1] + y0) * 360 / size;\n        p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n      }\n    }\n\n    return this._toGeoJSON(project);\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/mapbox-vector-tile/vector-tile-feature.ts"],"names":["types","constructor","pbf","loadGeometry","end","cmd","length","x","y","lines","cmdLen","line","bbox","x1","x2","y1","y2","_toGeoJSON","coords","type","VectorTileFeature","points","i","transform","classifyRings","j","result","geometry","coordinates","properties","toGeoJSON","z","size","Math","x0","y0","p"],"mappings":"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","sourcesContent":["// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\nimport Protobuf from 'pbf';\nimport {MvtMapboxCoordinates, MvtMapboxGeometry} from '../types';\nimport {readFeature, classifyRings} from '../../helpers/mapbox-util-functions';\n\nexport default class VectorTileFeature {\n  properties: {[x: string]: string | number | boolean | null};\n  extent: any;\n  type: number;\n  id: number | null;\n  _pbf: Protobuf;\n  _geometry: number;\n  _keys: string[];\n  _values: (string | number | boolean | null)[];\n  static get types() {\n    return ['Unknown', 'Point', 'LineString', 'Polygon'];\n  }\n\n  constructor(\n    pbf: Protobuf,\n    end: number,\n    extent: any,\n    keys: string[],\n    values: (string | number | boolean | null)[]\n  ) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n\n    pbf.readFields(readFeature, this, end);\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  loadGeometry(): MvtMapboxGeometry {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    const lines: number[][][] = [];\n    let line: number[][] | undefined;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // moveTo\n          if (line) lines.push(line);\n          line = [];\n        }\n        if (line) line.push([x, y]);\n      } else if (cmd === 7) {\n        // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n        if (line) {\n          line.push(line[0].slice()); // closePolygon\n        }\n      } else {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n\n    if (line) lines.push(line);\n\n    return lines;\n  }\n\n  // eslint-disable-next-line max-statements\n  bbox() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      } else if (cmd !== 7) {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n\n  _toGeoJSON(transform) {\n    let coords = this.loadGeometry();\n    let type = VectorTileFeature.types[this.type];\n    let i: number;\n    let j: number;\n\n    // eslint-disable-next-line default-case\n    switch (this.type) {\n      case 1:\n        const points: number[] = [];\n        for (i = 0; i < coords.length; i++) {\n          points[i] = coords[i][0];\n        }\n        coords = points;\n        transform(coords, this);\n        break;\n\n      case 2:\n        for (i = 0; i < coords.length; i++) {\n          transform(coords[i], this);\n        }\n        break;\n\n      case 3:\n        coords = classifyRings(coords);\n        for (i = 0; i < coords.length; i++) {\n          for (j = 0; j < coords[i].length; j++) {\n            transform(coords[i][j], this);\n          }\n        }\n        break;\n    }\n\n    if (coords.length === 1) {\n      coords = coords[0];\n    } else {\n      type = `Multi${type}`;\n    }\n\n    const result: MvtMapboxCoordinates = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates: coords\n      },\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toGeoJSON(\n    options: {x: number; y: number; z: number} | ((data: number[], feature: {extent: any}) => void)\n  ): MvtMapboxCoordinates {\n    if (typeof options === 'function') {\n      return this._toGeoJSON(options);\n    }\n    const {x, y, z} = options;\n    const size = this.extent * Math.pow(2, z);\n    const x0 = this.extent * x;\n    const y0 = this.extent * y;\n\n    function project(line: number[]) {\n      for (let j = 0; j < line.length; j++) {\n        const p = line[j];\n        p[0] = ((p[0] + x0) * 360) / size - 180;\n        const y2 = 180 - ((p[1] + y0) * 360) / size;\n        p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n      }\n    }\n    return this._toGeoJSON(project);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}