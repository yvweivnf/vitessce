{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nimport uuidv4 from 'uuid/v4';\nimport isNil from 'lodash/isNil';\nimport isEqual from 'lodash/isEqual';\nimport range from 'lodash/range';\nimport { featureCollection as turfFeatureCollection, point as turfPoint } from '@turf/helpers';\nimport centroid from '@turf/centroid';\nimport concaveman from 'concaveman';\nimport { HIERARCHICAL_SCHEMAS } from './constants';\nimport { getDefaultColor, PALETTE } from '../utils';\nimport { pathToKey } from './utils';\n/**\n * Alias for the uuidv4 function to make code more readable.\n * @returns {string} UUID.\n */\n\nfunction generateKey() {\n  return uuidv4();\n}\n/**\n * Get the set associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {array} The array representing the set associated with the node.\n */\n\n\nexport function nodeToSet(currNode) {\n  if (!currNode) {\n    return [];\n  }\n\n  if (!currNode.children) {\n    return currNode.set || [];\n  }\n\n  return currNode.children.flatMap(c => nodeToSet(c));\n}\n/**\n * Get the height of a node (the number of levels to reach a leaf).\n * @param {object} currNode A node object.\n * @param {number} level The level that the height will be computed relative to. By default, 0.\n * @returns {number} The height. If the node has a .children property,\n * then the minimum value returned is 1.\n */\n\nexport function nodeToHeight(currNode, level = 0) {\n  if (!currNode.children) {\n    return level;\n  }\n\n  const newLevel = level + 1;\n  const childrenHeights = currNode.children.map(c => nodeToHeight(c, newLevel));\n  return Math.max(...childrenHeights, newLevel);\n}\n/**\n * Get the size associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {number} The length of all the node's children\n */\n\nexport function getNodeLength(currNode) {\n  if (!currNode) {\n    return 0;\n  }\n\n  if (!currNode.children) {\n    var _currNode$set;\n\n    return ((_currNode$set = currNode.set) === null || _currNode$set === void 0 ? void 0 : _currNode$set.length) || 0;\n  }\n\n  return currNode.children.reduce((acc, curr) => acc + getNodeLength(curr), 0);\n}\n/**\n * Find a node with a matching name path, relative to a particular node.\n * @param {object} node A node object.\n * @param {string[]} path The name path for the node of interest.\n * @param {number} currLevelIndex The index of the current hierarchy level.\n * @returns {object|null} A matching node object, or null if none is found.\n */\n\nfunction nodeFindNodeByNamePath(node, path, currLevelIndex) {\n  const currNodeName = path[currLevelIndex];\n\n  if (node.name === currNodeName) {\n    if (currLevelIndex === path.length - 1) {\n      return node;\n    }\n\n    if (node.children) {\n      const foundNodes = node.children.map(child => nodeFindNodeByNamePath(child, path, currLevelIndex + 1)).filter(Boolean);\n\n      if (foundNodes.length === 1) {\n        return foundNodes[0];\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * Find a node with a matching name path, relative to the whole tree.\n * @param {object} currTree A tree object.\n * @param {string[]} targetNamePath The name path for the node of interest.\n * @returns {object|null} A matching node object, or null if none is found.\n */\n\n\nexport function treeFindNodeByNamePath(currTree, targetNamePath) {\n  const foundNodes = currTree.tree.map(levelZeroNode => nodeFindNodeByNamePath(levelZeroNode, targetNamePath, 0)).filter(Boolean);\n\n  if (foundNodes.length === 1) {\n    return foundNodes[0];\n  }\n\n  return null;\n}\n/**\n * Transform a node object using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */\n\nexport function nodeTransform(node, predicate, transform, transformedPaths, currPath) {\n  let newPath;\n\n  if (!currPath) {\n    newPath = [node.name];\n  } else {\n    newPath = [...currPath];\n  }\n\n  if (predicate(node, newPath)) {\n    transformedPaths.push(newPath);\n    return transform(node, newPath);\n  }\n\n  if (node.children) {\n    return { ...node,\n      children: node.children.map(child => nodeTransform(child, predicate, transform, transformedPaths, newPath.concat([child.name])))\n    };\n  }\n\n  return node;\n}\n/**\n * Transform many node objects using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */\n\nexport function nodeTransformAll(node, predicate, transform, transformedPaths, currPath) {\n  let newPath;\n\n  if (!currPath) {\n    newPath = [node.name];\n  } else {\n    newPath = [...currPath];\n  }\n\n  let newNode = node;\n\n  if (predicate(node, newPath)) {\n    transformedPaths.push(newPath);\n    newNode = transform(node, newPath);\n  }\n\n  if (node.children) {\n    return { ...newNode,\n      children: newNode.children.map(child => nodeTransformAll(child, predicate, transform, transformedPaths, newPath.concat([child.name])))\n    };\n  }\n\n  return newNode;\n}\n/**\n * Append a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */\n\nexport function nodeAppendChild(currNode, newChild) {\n  return { ...currNode,\n    children: [...currNode.children, newChild]\n  };\n}\n/**\n * Prepend a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */\n\nexport function nodePrependChild(currNode, newChild) {\n  return { ...currNode,\n    children: [newChild, ...currNode.children]\n  };\n}\n/**\n * Insert a child to a parent node.\n * @param {object} currNode A node object.\n * @param {*} newChild The child node object.\n * @param {*} insertIndex The index at which to insert the child.\n * @returns {object} The updated node.\n */\n\nexport function nodeInsertChild(currNode, newChild, insertIndex) {\n  const newChildren = Array.from(currNode.children);\n  newChildren.splice(insertIndex, 0, newChild);\n  return { ...currNode,\n    children: newChildren\n  };\n}\n/**\n * Get an array representing the union of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the union of the sets of checked nodes.\n */\n\nexport function treeToUnion(currTree, checkedPaths) {\n  const nodes = checkedPaths.map(path => treeFindNodeByNamePath(currTree, path));\n  const nodeSets = nodes.map(node => nodeToSet(node).map(([cellId]) => cellId));\n  return nodeSets.reduce((a, h) => a.concat(h.filter(hEl => !a.includes(hEl))), nodeSets[0] || []);\n}\n/**\n * Get an array representing the intersection of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the intersection of the sets of checked nodes.\n */\n\nexport function treeToIntersection(currTree, checkedPaths) {\n  const nodes = checkedPaths.map(path => treeFindNodeByNamePath(currTree, path));\n  const nodeSets = nodes.map(node => nodeToSet(node).map(([cellId]) => cellId));\n  return nodeSets.reduce((a, h) => h.filter(hEl => a.includes(hEl)), nodeSets[0] || []);\n}\n/**\n * Get an array representing the complement of the union of the sets of checked nodes.\n * @param {object} currTree\n * @returns {array} An array representing the complement of the\n * union of the sets of checked nodes.\n */\n\nexport function treeToComplement(currTree, checkedPaths, items) {\n  const primaryUnion = treeToUnion(currTree, checkedPaths);\n  return items.filter(el => !primaryUnion.includes(el));\n}\n/**\n * Get an flattened array of descendants at a particular relative\n * level of interest.\n * @param {object} node A node object.\n * @param {number} level The relative level of interest.\n * 0 for this node's children, 1 for grandchildren, etc.\n * @param {boolean} stopEarly Should a node be returned early if no children exist?\n * @returns {object[]} An array of descendants at the specified level,\n * where the level is relative to the node.\n */\n\nexport function nodeToLevelDescendantNamePaths(node, level, prevPath, stopEarly = false) {\n  if (!node.children) {\n    if (!stopEarly) {\n      return null;\n    }\n\n    return [[...prevPath, node.name]];\n  }\n\n  if (level === 0) {\n    return [[...prevPath, node.name]];\n  }\n\n  return node.children.flatMap(c => nodeToLevelDescendantNamePaths(c, level - 1, [...prevPath, node.name], stopEarly)).filter(Boolean);\n}\n/**\n * Export the tree by clearing tree state and all node states.\n * @param {object} currTree A tree object.\n * @returns {object} Tree object with tree and node state removed.\n */\n\nexport function treeExport(currTree, datatype) {\n  return {\n    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n    datatype,\n    tree: currTree.tree\n  };\n}\n/**\n * Export the tree by clearing tree state and all node states,\n * and filter so that only the level zero node of interest is included.\n * @param {object} currTree A tree object.\n * @param {string} nodePath The path of the node of interest.\n * @param {string} dataType Datatype (i.e cell sets)\n * @param {Array} cellSetColors Array of objects of cell set colors and paths\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} { treeToExport, nodeName }\n * Tree with one level zero node, and with state removed.\n */\n\nexport function treeExportLevelZeroNode(currTree, nodePath, datatype, cellSetColors, theme) {\n  const node = treeFindNodeByNamePath(currTree, nodePath);\n  const nodeWithColors = nodeTransformAll(node, () => true, (n, nPath) => {\n    var _cellSetColors$find$c, _cellSetColors$find;\n\n    const nodeColor = (_cellSetColors$find$c = cellSetColors === null || cellSetColors === void 0 ? void 0 : (_cellSetColors$find = cellSetColors.find(c => isEqual(c.path, nPath))) === null || _cellSetColors$find === void 0 ? void 0 : _cellSetColors$find.color) !== null && _cellSetColors$find$c !== void 0 ? _cellSetColors$find$c : getDefaultColor(theme);\n    return { ...n,\n      color: nodeColor.slice(0, 3)\n    };\n  }, []);\n  const treeWithOneLevelZeroNode = { ...currTree,\n    tree: [nodeWithColors]\n  };\n  return {\n    treeToExport: treeExport(treeWithOneLevelZeroNode, datatype),\n    nodeName: node.name\n  };\n}\n/**\n * Prepare the set of a node of interest for export.\n * @param {object} currTree A tree object.\n * @param {string} nodeKey The key of the node of interest.\n * @returns {object} { setToExport, nodeName } The set as an array.\n */\n\nexport function treeExportSet(currTree, nodePath) {\n  const node = treeFindNodeByNamePath(currTree, nodePath);\n  return {\n    setToExport: nodeToSet(node),\n    nodeName: node.name\n  };\n}\n/**\n * Get an empty tree, with a default tree state.\n * @param {string} datatype The type of sets that this tree contains.\n * @returns {object} Empty tree.\n */\n\nexport function treeInitialize(datatype) {\n  return {\n    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n    datatype,\n    tree: []\n  };\n}\n/**\n * For convenience, get an object with information required\n * to render a node as a component.\n * @param {object} node A node to be rendered.\n * @returns {object} An object containing properties required\n * by the TreeNode render functions.\n */\n\nexport function nodeToRenderProps(node, path, cellSetColor) {\n  var _cellSetColor$find;\n\n  const level = path.length - 1;\n  return {\n    title: node.name,\n    nodeKey: pathToKey(path),\n    path,\n    size: getNodeLength(node),\n    color: cellSetColor === null || cellSetColor === void 0 ? void 0 : (_cellSetColor$find = cellSetColor.find(d => isEqual(d.path, path))) === null || _cellSetColor$find === void 0 ? void 0 : _cellSetColor$find.color,\n    level,\n    isLeaf: (!node.children || node.children.length === 0) && Boolean(node.set),\n    height: nodeToHeight(node)\n  };\n}\n/**\n * Using a color and a probability, mix the color with an \"uncertainty\" color,\n * for example, gray.\n * Reference: https://github.com/bgrins/TinyColor/blob/80f7225029c428c0de0757f7d98ac15f497bee57/tinycolor.js#L701\n * @param {number[]} originalColor The color assignment for the class.\n * @param {number} p The mixing amount, or level certainty in the originalColor classification,\n * between 0 and 1.\n * @param {number[]} mixingColor The color with which to mix. By default, [128, 128, 128] gray.\n * @returns {number[]} Returns the color after mixing.\n */\n\nfunction colorMixWithUncertainty(originalColor, p, mixingColor = [128, 128, 128]) {\n  return [(originalColor[0] - mixingColor[0]) * p + mixingColor[0], (originalColor[1] - mixingColor[1]) * p + mixingColor[1], (originalColor[2] - mixingColor[2]) * p + mixingColor[2]];\n}\n/**\n * Given a tree with state, get the cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n *  @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} cellSetColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {array} Tuple of [cellIds, cellColors]\n * where cellIds is an array of strings,\n * and cellColors is an object mapping cellIds to color [r,g,b] arrays.\n */\n\n\nexport function treeToCellColorsBySetNames(currTree, selectedNamePaths, cellSetColor, theme) {\n  let cellColorsArray = [];\n  selectedNamePaths.forEach(setNamePath => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n\n    if (node) {\n      var _cellSetColor$find2;\n\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (cellSetColor === null || cellSetColor === void 0 ? void 0 : (_cellSetColor$find2 = cellSetColor.find(d => isEqual(d.path, setNamePath))) === null || _cellSetColor$find2 === void 0 ? void 0 : _cellSetColor$find2.color) || getDefaultColor(theme);\n      cellColorsArray = [...cellColorsArray, ...nodeSet.map(([cellId, prob]) => [cellId, isNil(prob) ? nodeColor : colorMixWithUncertainty(nodeColor, prob)])];\n    }\n  });\n  return new Map(cellColorsArray);\n}\n/**\n * Given a tree with state, get an array of\n * objects with cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme.\n * @returns {object[]} Array of objects with properties\n * `obsId`, `name`, and `color`.\n */\n\nexport function treeToObjectsBySetNames(currTree, selectedNamePaths, setColor, theme) {\n  let cellsArray = [];\n\n  for (let i = 0; i < selectedNamePaths.length; i += 1) {\n    const setNamePath = selectedNamePaths[i];\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n\n    if (node) {\n      var _setColor$find;\n\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (setColor === null || setColor === void 0 ? void 0 : (_setColor$find = setColor.find(d => isEqual(d.path, setNamePath))) === null || _setColor$find === void 0 ? void 0 : _setColor$find.color) || getDefaultColor(theme);\n      cellsArray = cellsArray.concat(nodeSet.map(([cellId]) => ({\n        obsId: cellId,\n        name: node.name,\n        color: nodeColor\n      })));\n    }\n  }\n\n  return cellsArray;\n}\nexport function treeToCellPolygonsBySetNames(currTree, cells, mapping, selectedNamePaths, cellSetColor, theme) {\n  const cellSetPolygons = [];\n  selectedNamePaths.forEach(setNamePath => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n\n    if (node) {\n      var _cellSetColor$find3;\n\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (cellSetColor === null || cellSetColor === void 0 ? void 0 : (_cellSetColor$find3 = cellSetColor.find(d => isEqual(d.path, setNamePath))) === null || _cellSetColor$find3 === void 0 ? void 0 : _cellSetColor$find3.color) || getDefaultColor(theme);\n      const cellPositions = nodeSet.map(([cellId]) => {\n        var _cells$cellId, _cells$cellId2;\n\n        return [(_cells$cellId = cells[cellId]) === null || _cells$cellId === void 0 ? void 0 : _cells$cellId.mappings[mapping][0], -((_cells$cellId2 = cells[cellId]) === null || _cells$cellId2 === void 0 ? void 0 : _cells$cellId2.mappings[mapping][1])];\n      }).filter(cell => cell.every(i => typeof i === 'number'));\n\n      if (cellPositions.length > 2) {\n        const points = turfFeatureCollection(cellPositions.map(turfPoint));\n        const concavity = Infinity;\n        const hullCoords = concaveman(cellPositions, concavity);\n\n        if (hullCoords) {\n          const centroidCoords = centroid(points).geometry.coordinates;\n          cellSetPolygons.push({\n            path: setNamePath,\n            name: setNamePath[setNamePath.length - 1],\n            hull: hullCoords,\n            color: nodeColor,\n            centroid: centroidCoords\n          });\n        }\n      }\n    }\n  });\n  return cellSetPolygons;\n}\n/**\n * Given a tree with state, get the sizes of the\n * sets currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object[]} Array of objects\n * with the properties `name`, `size`, `key`,\n * and `color`.\n */\n\nexport function treeToSetSizesBySetNames(currTree, selectedNamePaths, setColor, theme) {\n  const sizes = [];\n  selectedNamePaths.forEach(setNamePath => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n\n    if (node) {\n      var _setColor$find2;\n\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (setColor === null || setColor === void 0 ? void 0 : (_setColor$find2 = setColor.find(d => isEqual(d.path, setNamePath))) === null || _setColor$find2 === void 0 ? void 0 : _setColor$find2.color) || getDefaultColor(theme);\n      sizes.push({\n        key: generateKey(),\n        name: node.name,\n        size: nodeSet.length,\n        color: nodeColor\n      });\n    }\n  });\n  return sizes;\n}\n/**\n * Find and remove a node from the descendants of the current node.\n * @param {object} node A node to search on.\n * @param {array} prevPath Path of the current node to be searched.\n * @param {array} filterPath The path sought.\n * @returns {object} A new node without a node at filterPath.\n */\n\nexport function filterNode(node, prevPath, filterPath) {\n  if (isEqual([...prevPath, node.name], filterPath)) {\n    return null;\n  }\n\n  if (!node.children) {\n    return node;\n  }\n\n  return { ...node,\n    children: node.children.map(c => filterNode(c, [...prevPath, node.name], filterPath)).filter(Boolean)\n  };\n}\nexport function treeToExpectedCheckedLevel(currTree, checkedPaths) {\n  let result = null;\n\n  if (currTree) {\n    currTree.tree.forEach(lzn => {\n      const levelZeroPath = [lzn.name];\n      const height = nodeToHeight(lzn);\n      range(height).forEach(i => {\n        const levelIndex = i + 1;\n        const levelNodePaths = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);\n\n        if (isEqual(levelNodePaths, checkedPaths)) {\n          result = {\n            levelZeroPath,\n            levelIndex\n          };\n        }\n      });\n    });\n  }\n\n  return result;\n}\nexport function treesConflict(cellSets, testCellSets) {\n  const paths = [];\n  const testPaths = [];\n  let hasConflict = false;\n\n  function getPaths(node, prevPath) {\n    paths.push([...prevPath, node.name]);\n\n    if (node.children) {\n      node.children.forEach(c => getPaths(c, [...prevPath, node.name]));\n    }\n  }\n\n  cellSets.tree.forEach(lzn => getPaths(lzn, []));\n\n  function getTestPaths(node, prevPath) {\n    testPaths.push([...prevPath, node.name]);\n\n    if (node.children) {\n      node.children.forEach(c => getPaths(c, [...prevPath, node.name]));\n    }\n  }\n\n  testCellSets.tree.forEach(lzn => getTestPaths(lzn, []));\n  testPaths.forEach(testPath => {\n    if (paths.find(p => isEqual(p, testPath))) {\n      hasConflict = true;\n    }\n  });\n  return hasConflict;\n}\nexport function initializeCellSetColor(cellSets, cellSetColor) {\n  const nextCellSetColor = [...(cellSetColor || [])];\n  const nodeCountPerTreePerLevel = cellSets.tree.map(tree => Array.from({\n    length: nodeToHeight(tree) + 1 // Need to add one because its an array.\n\n  }).fill(0));\n\n  function processNode(node, prevPath, hierarchyLevel, treeIndex) {\n    const index = nodeCountPerTreePerLevel[treeIndex][hierarchyLevel];\n    const nodePath = [...prevPath, node.name];\n    const nodeColor = nextCellSetColor.find(d => isEqual(d.path, nodePath));\n\n    if (!nodeColor) {\n      // If there is a color for the node specified via the cell set tree,\n      // then use it. Otherwise, use a color from the default color palette.\n      const nodeColorArray = node.color ? node.color : PALETTE[index % PALETTE.length];\n      nextCellSetColor.push({\n        path: nodePath,\n        color: nodeColorArray\n      });\n    }\n\n    nodeCountPerTreePerLevel[treeIndex][hierarchyLevel] += 1;\n\n    if (node.children) {\n      node.children.forEach(c => processNode(c, nodePath, hierarchyLevel + 1, treeIndex));\n    }\n  }\n\n  cellSets.tree.forEach((lzn, treeIndex) => processNode(lzn, [], 0, treeIndex));\n  return nextCellSetColor;\n}\nexport function getCellSetPolygons(params) {\n  const {\n    cells,\n    mapping,\n    cellSets,\n    cellSetSelection,\n    cellSetColor,\n    theme\n  } = params;\n\n  if (cellSetSelection && cellSetSelection.length > 0 && cellSets && cells) {\n    return treeToCellPolygonsBySetNames(cellSets, cells, mapping, cellSetSelection, cellSetColor, theme);\n  }\n\n  return [];\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/cell-set-utils.js"],"names":["uuidv4","isNil","isEqual","range","featureCollection","turfFeatureCollection","point","turfPoint","centroid","concaveman","HIERARCHICAL_SCHEMAS","getDefaultColor","PALETTE","pathToKey","generateKey","nodeToSet","currNode","children","set","flatMap","c","nodeToHeight","level","newLevel","childrenHeights","map","Math","max","getNodeLength","length","reduce","acc","curr","nodeFindNodeByNamePath","node","path","currLevelIndex","currNodeName","name","foundNodes","child","filter","Boolean","treeFindNodeByNamePath","currTree","targetNamePath","tree","levelZeroNode","nodeTransform","predicate","transform","transformedPaths","currPath","newPath","push","concat","nodeTransformAll","newNode","nodeAppendChild","newChild","nodePrependChild","nodeInsertChild","insertIndex","newChildren","Array","from","splice","treeToUnion","checkedPaths","nodes","nodeSets","cellId","a","h","hEl","includes","treeToIntersection","treeToComplement","items","primaryUnion","el","nodeToLevelDescendantNamePaths","prevPath","stopEarly","treeExport","datatype","version","latestVersion","treeExportLevelZeroNode","nodePath","cellSetColors","theme","nodeWithColors","n","nPath","nodeColor","find","color","slice","treeWithOneLevelZeroNode","treeToExport","nodeName","treeExportSet","setToExport","treeInitialize","nodeToRenderProps","cellSetColor","title","nodeKey","size","d","isLeaf","height","colorMixWithUncertainty","originalColor","p","mixingColor","treeToCellColorsBySetNames","selectedNamePaths","cellColorsArray","forEach","setNamePath","nodeSet","prob","Map","treeToObjectsBySetNames","setColor","cellsArray","i","obsId","treeToCellPolygonsBySetNames","cells","mapping","cellSetPolygons","cellPositions","mappings","cell","every","points","concavity","Infinity","hullCoords","centroidCoords","geometry","coordinates","hull","treeToSetSizesBySetNames","sizes","key","filterNode","filterPath","treeToExpectedCheckedLevel","result","lzn","levelZeroPath","levelIndex","levelNodePaths","treesConflict","cellSets","testCellSets","paths","testPaths","hasConflict","getPaths","getTestPaths","testPath","initializeCellSetColor","nextCellSetColor","nodeCountPerTreePerLevel","fill","processNode","hierarchyLevel","treeIndex","index","nodeColorArray","getCellSetPolygons","params","cellSetSelection"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport uuidv4 from 'uuid/v4';\nimport isNil from 'lodash/isNil';\nimport isEqual from 'lodash/isEqual';\nimport range from 'lodash/range';\nimport { featureCollection as turfFeatureCollection, point as turfPoint } from '@turf/helpers';\nimport centroid from '@turf/centroid';\nimport concaveman from 'concaveman';\nimport {\n  HIERARCHICAL_SCHEMAS,\n} from './constants';\nimport { getDefaultColor, PALETTE } from '../utils';\nimport { pathToKey } from './utils';\n\n/**\n * Alias for the uuidv4 function to make code more readable.\n * @returns {string} UUID.\n */\nfunction generateKey() {\n  return uuidv4();\n}\n\n/**\n * Get the set associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {array} The array representing the set associated with the node.\n */\nexport function nodeToSet(currNode) {\n  if (!currNode) {\n    return [];\n  }\n  if (!currNode.children) {\n    return (currNode.set || []);\n  }\n  return currNode.children.flatMap(c => nodeToSet(c));\n}\n\n/**\n * Get the height of a node (the number of levels to reach a leaf).\n * @param {object} currNode A node object.\n * @param {number} level The level that the height will be computed relative to. By default, 0.\n * @returns {number} The height. If the node has a .children property,\n * then the minimum value returned is 1.\n */\nexport function nodeToHeight(currNode, level = 0) {\n  if (!currNode.children) {\n    return level;\n  }\n  const newLevel = level + 1;\n  const childrenHeights = currNode.children.map(c => nodeToHeight(c, newLevel));\n  return Math.max(...childrenHeights, newLevel);\n}\n\n/**\n * Get the size associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {number} The length of all the node's children\n */\nexport function getNodeLength(currNode) {\n  if (!currNode) {\n    return 0;\n  }\n  if (!currNode.children) {\n    return (currNode.set?.length || 0);\n  }\n  return currNode.children.reduce((acc, curr) => acc + getNodeLength(curr), 0);\n}\n\n/**\n * Find a node with a matching name path, relative to a particular node.\n * @param {object} node A node object.\n * @param {string[]} path The name path for the node of interest.\n * @param {number} currLevelIndex The index of the current hierarchy level.\n * @returns {object|null} A matching node object, or null if none is found.\n */\nfunction nodeFindNodeByNamePath(node, path, currLevelIndex) {\n  const currNodeName = path[currLevelIndex];\n  if (node.name === currNodeName) {\n    if (currLevelIndex === path.length - 1) {\n      return node;\n    }\n    if (node.children) {\n      const foundNodes = node.children\n        .map(child => nodeFindNodeByNamePath(child, path, currLevelIndex + 1))\n        .filter(Boolean);\n      if (foundNodes.length === 1) {\n        return foundNodes[0];\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Find a node with a matching name path, relative to the whole tree.\n * @param {object} currTree A tree object.\n * @param {string[]} targetNamePath The name path for the node of interest.\n * @returns {object|null} A matching node object, or null if none is found.\n */\nexport function treeFindNodeByNamePath(currTree, targetNamePath) {\n  const foundNodes = currTree.tree\n    .map(levelZeroNode => nodeFindNodeByNamePath(levelZeroNode, targetNamePath, 0))\n    .filter(Boolean);\n  if (foundNodes.length === 1) {\n    return foundNodes[0];\n  }\n  return null;\n}\n\n/**\n * Transform a node object using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */\nexport function nodeTransform(node, predicate, transform, transformedPaths, currPath) {\n  let newPath;\n  if (!currPath) {\n    newPath = [node.name];\n  } else {\n    newPath = [...currPath];\n  }\n  if (predicate(node, newPath)) {\n    transformedPaths.push(newPath);\n    return transform(node, newPath);\n  }\n  if (node.children) {\n    return {\n      ...node,\n      children: node.children.map(\n        child => nodeTransform(\n          child, predicate, transform, transformedPaths, newPath.concat([child.name]),\n        ),\n      ),\n    };\n  }\n  return node;\n}\n\n/**\n * Transform many node objects using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */\nexport function nodeTransformAll(node, predicate, transform, transformedPaths, currPath) {\n  let newPath;\n  if (!currPath) {\n    newPath = [node.name];\n  } else {\n    newPath = [...currPath];\n  }\n  let newNode = node;\n  if (predicate(node, newPath)) {\n    transformedPaths.push(newPath);\n    newNode = transform(node, newPath);\n  }\n  if (node.children) {\n    return {\n      ...newNode,\n      children: newNode.children.map(\n        child => nodeTransformAll(\n          child, predicate, transform, transformedPaths, newPath.concat([child.name]),\n        ),\n      ),\n    };\n  }\n  return newNode;\n}\n\n/**\n * Append a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */\nexport function nodeAppendChild(currNode, newChild) {\n  return {\n    ...currNode,\n    children: [...currNode.children, newChild],\n  };\n}\n\n/**\n * Prepend a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */\nexport function nodePrependChild(currNode, newChild) {\n  return {\n    ...currNode,\n    children: [newChild, ...currNode.children],\n  };\n}\n\n/**\n * Insert a child to a parent node.\n * @param {object} currNode A node object.\n * @param {*} newChild The child node object.\n * @param {*} insertIndex The index at which to insert the child.\n * @returns {object} The updated node.\n */\nexport function nodeInsertChild(currNode, newChild, insertIndex) {\n  const newChildren = Array.from(currNode.children);\n  newChildren.splice(insertIndex, 0, newChild);\n  return {\n    ...currNode,\n    children: newChildren,\n  };\n}\n\n/**\n * Get an array representing the union of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the union of the sets of checked nodes.\n */\nexport function treeToUnion(currTree, checkedPaths) {\n  const nodes = checkedPaths.map(path => treeFindNodeByNamePath(currTree, path));\n  const nodeSets = nodes.map(node => nodeToSet(node).map(([cellId]) => cellId));\n  return nodeSets\n    .reduce((a, h) => a.concat(h.filter(hEl => !a.includes(hEl))), nodeSets[0] || []);\n}\n\n/**\n * Get an array representing the intersection of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the intersection of the sets of checked nodes.\n */\nexport function treeToIntersection(currTree, checkedPaths) {\n  const nodes = checkedPaths.map(path => treeFindNodeByNamePath(currTree, path));\n  const nodeSets = nodes.map(node => nodeToSet(node).map(([cellId]) => cellId));\n  return nodeSets\n    .reduce((a, h) => h.filter(hEl => a.includes(hEl)), nodeSets[0] || []);\n}\n\n/**\n * Get an array representing the complement of the union of the sets of checked nodes.\n * @param {object} currTree\n * @returns {array} An array representing the complement of the\n * union of the sets of checked nodes.\n */\nexport function treeToComplement(currTree, checkedPaths, items) {\n  const primaryUnion = treeToUnion(currTree, checkedPaths);\n  return items.filter(el => !primaryUnion.includes(el));\n}\n\n/**\n * Get an flattened array of descendants at a particular relative\n * level of interest.\n * @param {object} node A node object.\n * @param {number} level The relative level of interest.\n * 0 for this node's children, 1 for grandchildren, etc.\n * @param {boolean} stopEarly Should a node be returned early if no children exist?\n * @returns {object[]} An array of descendants at the specified level,\n * where the level is relative to the node.\n */\nexport function nodeToLevelDescendantNamePaths(node, level, prevPath, stopEarly = false) {\n  if (!node.children) {\n    if (!stopEarly) {\n      return null;\n    }\n    return [[...prevPath, node.name]];\n  }\n  if (level === 0) {\n    return [[...prevPath, node.name]];\n  }\n  return node.children\n    .flatMap(c => nodeToLevelDescendantNamePaths(c, level - 1, [...prevPath, node.name], stopEarly))\n    .filter(Boolean);\n}\n\n/**\n * Export the tree by clearing tree state and all node states.\n * @param {object} currTree A tree object.\n * @returns {object} Tree object with tree and node state removed.\n */\nexport function treeExport(currTree, datatype) {\n  return {\n    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n    datatype,\n    tree: currTree.tree,\n  };\n}\n\n/**\n * Export the tree by clearing tree state and all node states,\n * and filter so that only the level zero node of interest is included.\n * @param {object} currTree A tree object.\n * @param {string} nodePath The path of the node of interest.\n * @param {string} dataType Datatype (i.e cell sets)\n * @param {Array} cellSetColors Array of objects of cell set colors and paths\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} { treeToExport, nodeName }\n * Tree with one level zero node, and with state removed.\n */\nexport function treeExportLevelZeroNode(currTree, nodePath, datatype, cellSetColors, theme) {\n  const node = treeFindNodeByNamePath(currTree, nodePath);\n  const nodeWithColors = nodeTransformAll(node, () => true, (n, nPath) => {\n    const nodeColor = cellSetColors?.find(c => isEqual(c.path, nPath))?.color\n      ?? getDefaultColor(theme);\n    return {\n      ...n,\n      color: nodeColor.slice(0, 3),\n    };\n  }, []);\n  const treeWithOneLevelZeroNode = {\n    ...currTree,\n    tree: [nodeWithColors],\n  };\n  return {\n    treeToExport: treeExport(treeWithOneLevelZeroNode, datatype),\n    nodeName: node.name,\n  };\n}\n\n/**\n * Prepare the set of a node of interest for export.\n * @param {object} currTree A tree object.\n * @param {string} nodeKey The key of the node of interest.\n * @returns {object} { setToExport, nodeName } The set as an array.\n */\nexport function treeExportSet(currTree, nodePath) {\n  const node = treeFindNodeByNamePath(currTree, nodePath);\n  return { setToExport: nodeToSet(node), nodeName: node.name };\n}\n\n/**\n * Get an empty tree, with a default tree state.\n * @param {string} datatype The type of sets that this tree contains.\n * @returns {object} Empty tree.\n */\nexport function treeInitialize(datatype) {\n  return {\n    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n    datatype,\n    tree: [],\n  };\n}\n\n/**\n * For convenience, get an object with information required\n * to render a node as a component.\n * @param {object} node A node to be rendered.\n * @returns {object} An object containing properties required\n * by the TreeNode render functions.\n */\nexport function nodeToRenderProps(node, path, cellSetColor) {\n  const level = path.length - 1;\n  return {\n    title: node.name,\n    nodeKey: pathToKey(path),\n    path,\n    size: getNodeLength(node),\n    color: cellSetColor?.find(d => isEqual(d.path, path))?.color,\n    level,\n    isLeaf: (!node.children || node.children.length === 0) && Boolean(node.set),\n    height: nodeToHeight(node),\n  };\n}\n\n/**\n * Using a color and a probability, mix the color with an \"uncertainty\" color,\n * for example, gray.\n * Reference: https://github.com/bgrins/TinyColor/blob/80f7225029c428c0de0757f7d98ac15f497bee57/tinycolor.js#L701\n * @param {number[]} originalColor The color assignment for the class.\n * @param {number} p The mixing amount, or level certainty in the originalColor classification,\n * between 0 and 1.\n * @param {number[]} mixingColor The color with which to mix. By default, [128, 128, 128] gray.\n * @returns {number[]} Returns the color after mixing.\n */\nfunction colorMixWithUncertainty(originalColor, p, mixingColor = [128, 128, 128]) {\n  return [\n    ((originalColor[0] - mixingColor[0]) * p) + mixingColor[0],\n    ((originalColor[1] - mixingColor[1]) * p) + mixingColor[1],\n    ((originalColor[2] - mixingColor[2]) * p) + mixingColor[2],\n  ];\n}\n\n/**\n * Given a tree with state, get the cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n *  @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} cellSetColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {array} Tuple of [cellIds, cellColors]\n * where cellIds is an array of strings,\n * and cellColors is an object mapping cellIds to color [r,g,b] arrays.\n */\nexport function treeToCellColorsBySetNames(currTree, selectedNamePaths, cellSetColor, theme) {\n  let cellColorsArray = [];\n  selectedNamePaths.forEach((setNamePath) => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (\n        cellSetColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme)\n      );\n      cellColorsArray = [\n        ...cellColorsArray,\n        ...nodeSet.map(([cellId, prob]) => [\n          cellId,\n          (isNil(prob) ? nodeColor : colorMixWithUncertainty(nodeColor, prob)),\n        ]),\n      ];\n    }\n  });\n  return new Map(cellColorsArray);\n}\n\n/**\n * Given a tree with state, get an array of\n * objects with cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme.\n * @returns {object[]} Array of objects with properties\n * `obsId`, `name`, and `color`.\n */\nexport function treeToObjectsBySetNames(currTree, selectedNamePaths, setColor, theme) {\n  let cellsArray = [];\n  for (let i = 0; i < selectedNamePaths.length; i += 1) {\n    const setNamePath = selectedNamePaths[i];\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (\n        setColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme)\n      );\n      cellsArray = cellsArray.concat(nodeSet.map(([cellId]) => ({\n        obsId: cellId,\n        name: node.name,\n        color: nodeColor,\n      })));\n    }\n  }\n  return cellsArray;\n}\n\nexport function treeToCellPolygonsBySetNames(\n  currTree, cells, mapping, selectedNamePaths, cellSetColor, theme,\n) {\n  const cellSetPolygons = [];\n  selectedNamePaths.forEach((setNamePath) => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (\n        cellSetColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme)\n      );\n      const cellPositions = nodeSet\n        .map(([cellId]) => ([\n          cells[cellId]?.mappings[mapping][0],\n          -cells[cellId]?.mappings[mapping][1],\n        ]))\n        .filter(cell => cell.every(i => typeof i === 'number'));\n\n      if (cellPositions.length > 2) {\n        const points = turfFeatureCollection(\n          cellPositions.map(turfPoint),\n        );\n        const concavity = Infinity;\n        const hullCoords = concaveman(cellPositions, concavity);\n        if (hullCoords) {\n          const centroidCoords = centroid(points).geometry.coordinates;\n          cellSetPolygons.push({\n            path: setNamePath,\n            name: setNamePath[setNamePath.length - 1],\n            hull: hullCoords,\n            color: nodeColor,\n            centroid: centroidCoords,\n          });\n        }\n      }\n    }\n  });\n  return cellSetPolygons;\n}\n\n/**\n * Given a tree with state, get the sizes of the\n * sets currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object[]} Array of objects\n * with the properties `name`, `size`, `key`,\n * and `color`.\n */\nexport function treeToSetSizesBySetNames(currTree, selectedNamePaths, setColor, theme) {\n  const sizes = [];\n  selectedNamePaths.forEach((setNamePath) => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = setColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme);\n      sizes.push({\n        key: generateKey(),\n        name: node.name,\n        size: nodeSet.length,\n        color: nodeColor,\n      });\n    }\n  });\n  return sizes;\n}\n\n/**\n * Find and remove a node from the descendants of the current node.\n * @param {object} node A node to search on.\n * @param {array} prevPath Path of the current node to be searched.\n * @param {array} filterPath The path sought.\n * @returns {object} A new node without a node at filterPath.\n */\nexport function filterNode(node, prevPath, filterPath) {\n  if (isEqual([...prevPath, node.name], filterPath)) {\n    return null;\n  }\n  if (!node.children) {\n    return node;\n  }\n  return {\n    ...node,\n    children: node.children.map(\n      c => filterNode(c, [...prevPath, node.name], filterPath),\n    ).filter(Boolean),\n  };\n}\n\nexport function treeToExpectedCheckedLevel(currTree, checkedPaths) {\n  let result = null;\n  if (currTree) {\n    currTree.tree.forEach((lzn) => {\n      const levelZeroPath = [lzn.name];\n      const height = nodeToHeight(lzn);\n      range(height).forEach((i) => {\n        const levelIndex = i + 1;\n        const levelNodePaths = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);\n        if (isEqual(levelNodePaths, checkedPaths)) {\n          result = { levelZeroPath, levelIndex };\n        }\n      });\n    });\n  }\n  return result;\n}\n\nexport function treesConflict(cellSets, testCellSets) {\n  const paths = [];\n  const testPaths = [];\n  let hasConflict = false;\n\n  function getPaths(node, prevPath) {\n    paths.push([...prevPath, node.name]);\n    if (node.children) {\n      node.children.forEach(c => getPaths(c, [...prevPath, node.name]));\n    }\n  }\n  cellSets.tree.forEach(lzn => getPaths(lzn, []));\n\n  function getTestPaths(node, prevPath) {\n    testPaths.push([...prevPath, node.name]);\n    if (node.children) {\n      node.children.forEach(c => getPaths(c, [...prevPath, node.name]));\n    }\n  }\n  testCellSets.tree.forEach(lzn => getTestPaths(lzn, []));\n\n  testPaths.forEach((testPath) => {\n    if (paths.find(p => isEqual(p, testPath))) {\n      hasConflict = true;\n    }\n  });\n  return hasConflict;\n}\n\nexport function initializeCellSetColor(cellSets, cellSetColor) {\n  const nextCellSetColor = [...(cellSetColor || [])];\n  const nodeCountPerTreePerLevel = cellSets.tree.map(tree => Array\n    .from({\n      length: nodeToHeight(tree) + 1, // Need to add one because its an array.\n    }).fill(0));\n\n  function processNode(node, prevPath, hierarchyLevel, treeIndex) {\n    const index = nodeCountPerTreePerLevel[treeIndex][hierarchyLevel];\n    const nodePath = [...prevPath, node.name];\n\n    const nodeColor = nextCellSetColor.find(d => isEqual(d.path, nodePath));\n    if (!nodeColor) {\n      // If there is a color for the node specified via the cell set tree,\n      // then use it. Otherwise, use a color from the default color palette.\n      const nodeColorArray = (node.color ? node.color : PALETTE[index % PALETTE.length]);\n      nextCellSetColor.push({\n        path: nodePath,\n        color: nodeColorArray,\n      });\n    }\n    nodeCountPerTreePerLevel[treeIndex][hierarchyLevel] += 1;\n    if (node.children) {\n      node.children.forEach(c => processNode(c, nodePath, hierarchyLevel + 1, treeIndex));\n    }\n  }\n\n  cellSets.tree.forEach((lzn, treeIndex) => processNode(lzn, [], 0, treeIndex));\n  return nextCellSetColor;\n}\n\nexport function getCellSetPolygons(params) {\n  const {\n    cells,\n    mapping,\n    cellSets,\n    cellSetSelection,\n    cellSetColor,\n    theme,\n  } = params;\n  if (cellSetSelection && cellSetSelection.length > 0 && cellSets && cells) {\n    return treeToCellPolygonsBySetNames(\n      cellSets, cells, mapping, cellSetSelection, cellSetColor, theme,\n    );\n  }\n  return [];\n}\n"]},"metadata":{},"sourceType":"module"}