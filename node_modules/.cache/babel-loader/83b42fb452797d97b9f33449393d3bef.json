{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData } from './data/parse';\nimport { assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n  return vgField(sort, Object.assign({\n    suffix: `by_${vgField(fieldDef)}`\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}\nexport class FacetModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName, config) {\n    super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n    this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n    this.children = [this.child];\n    this.facet = this.initFacet(spec.facet);\n  }\n\n  initFacet(facet) {\n    // clone to prevent side effect to the original spec\n    if (!isFacetMapping(facet)) {\n      return {\n        facet: this.initFacetFieldDef(facet, 'facet')\n      };\n    }\n\n    const channels = keys(facet);\n    const normalizedFacet = {};\n\n    for (const channel of channels) {\n      if (![ROW, COLUMN].includes(channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        break;\n      }\n\n      const fieldDef = facet[channel];\n\n      if (fieldDef.field === undefined) {\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        break;\n      }\n\n      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n    }\n\n    return normalizedFacet;\n  }\n\n  initFacetFieldDef(fieldDef, channel) {\n    // Cast because we call initFieldDef, which assumes general FieldDef.\n    // However, FacetFieldDef is a bit more constrained than the general FieldDef\n    const facetFieldDef = initFieldDef(fieldDef, channel);\n\n    if (facetFieldDef.header) {\n      facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n    } else if (facetFieldDef.header === null) {\n      facetFieldDef.header = null;\n    }\n\n    return facetFieldDef;\n  }\n\n  channelHasField(channel) {\n    return !!this.facet[channel];\n  }\n\n  fieldDef(channel) {\n    return this.facet[channel];\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n    this.child.parseData();\n  }\n\n  parseLayoutSize() {\n    parseChildrenLayoutSize(this);\n  }\n\n  parseSelections() {\n    // As a facet has a single child, the selection components are the same.\n    // The child maintains its selections to assemble signals, which remain\n    // within its unit.\n    this.child.parseSelections();\n    this.component.selection = this.child.component.selection;\n  }\n\n  parseMarkGroup() {\n    this.child.parseMarkGroup();\n  }\n\n  parseAxesAndHeaders() {\n    this.child.parseAxesAndHeaders();\n    parseFacetHeaders(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return this.child.assembleSelectionTopLevelSignals(signals);\n  }\n\n  assembleSignals() {\n    this.child.assembleSignals();\n    return [];\n  }\n\n  assembleSelectionData(data) {\n    return this.child.assembleSelectionData(data);\n  }\n\n  getHeaderLayoutMixins() {\n    var _a, _b, _c;\n\n    const layoutMixins = {};\n\n    for (const channel of FACET_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const layoutHeaderComponent = this.component.layoutHeaders[channel];\n        const headerComponent = layoutHeaderComponent[headerType];\n        const {\n          facetFieldDef\n        } = layoutHeaderComponent;\n\n        if (facetFieldDef) {\n          const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n\n          if (['right', 'bottom'].includes(titleOrient)) {\n            const headerChannel = getHeaderChannel(channel, titleOrient);\n            (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : layoutMixins.titleAnchor = {};\n            layoutMixins.titleAnchor[headerChannel] = 'end';\n          }\n        }\n\n        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {\n          // set header/footerBand\n          const sizeType = channel === 'row' ? 'height' : 'width';\n          const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n\n          if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n            // If facet child does not have size signal, then apply headerBand\n            (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : layoutMixins[bandType] = {};\n            layoutMixins[bandType][channel] = 0.5;\n          }\n\n          if (layoutHeaderComponent.title) {\n            (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : layoutMixins.offset = {};\n            layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n          }\n        }\n      }\n    }\n\n    return layoutMixins;\n  }\n\n  assembleDefaultLayout() {\n    const {\n      column,\n      row\n    } = this.facet;\n    const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n    let align = 'all'; // Do not align the cells if the scale corresponding to the direction is indepent.\n    // We always align when we facet into both row and column.\n\n    if (!row && this.component.resolve.scale.x === 'independent') {\n      align = 'none';\n    } else if (!column && this.component.resolve.scale.y === 'independent') {\n      align = 'none';\n    }\n\n    return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? {\n      columns\n    } : {}), {\n      bounds: 'full',\n      align\n    });\n  }\n\n  assembleLayoutSignals() {\n    // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n    return this.child.assembleLayoutSignals();\n  }\n\n  columnDistinctSignal() {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // For nested facet, we will add columns to group mark instead\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return undefined;\n    } else {\n      // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n      const facetLayoutDataName = this.getName('column_domain');\n      return {\n        signal: `length(data('${facetLayoutDataName}'))`\n      };\n    }\n  }\n\n  assembleGroupStyle() {\n    return undefined;\n  }\n\n  assembleGroup(signals) {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // Provide number of columns for layout.\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return Object.assign(Object.assign({}, this.channelHasField('column') ? {\n        encode: {\n          update: {\n            // TODO(https://github.com/vega/vega-lite/issues/2759):\n            // Correct the signal for facet of concat of facet_column\n            columns: {\n              field: vgField(this.facet.column, {\n                prefix: 'distinct'\n              })\n            }\n          }\n        }\n      } : {}), super.assembleGroup(signals));\n    }\n\n    return super.assembleGroup(signals);\n  }\n  /**\n   * Aggregate cardinality for calculating size\n   */\n\n\n  getCardinalityAggregateForChild() {\n    const fields = [];\n    const ops = [];\n    const as = [];\n\n    if (this.child instanceof FacetModel) {\n      if (this.child.channelHasField('column')) {\n        const field = vgField(this.child.facet.column);\n        fields.push(field);\n        ops.push('distinct');\n        as.push(`distinct_${field}`);\n      }\n    } else {\n      for (const channel of POSITION_SCALE_CHANNELS) {\n        const childScaleComponent = this.child.component.scales[channel];\n\n        if (childScaleComponent && !childScaleComponent.merged) {\n          const type = childScaleComponent.get('type');\n          const range = childScaleComponent.get('range');\n\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            const domain = assembleDomain(this.child, channel);\n            const field = getFieldFromDomain(domain);\n\n            if (field) {\n              fields.push(field);\n              ops.push('distinct');\n              as.push(`distinct_${field}`);\n            } else {\n              log.warn(log.message.unknownField(channel));\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      fields,\n      ops,\n      as\n    };\n  }\n\n  assembleFacet() {\n    const {\n      name,\n      data\n    } = this.component.data.facetRoot;\n    const {\n      row,\n      column\n    } = this.facet;\n    const {\n      fields,\n      ops,\n      as\n    } = this.getCardinalityAggregateForChild();\n    const groupby = [];\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = this.facet[channel];\n\n      if (fieldDef) {\n        groupby.push(vgField(fieldDef));\n        const {\n          bin,\n          sort\n        } = fieldDef;\n\n        if (isBinning(bin)) {\n          groupby.push(vgField(fieldDef, {\n            binSuffix: 'end'\n          }));\n        }\n\n        if (isSortField(sort)) {\n          const {\n            field,\n            op = DEFAULT_SORT_OP\n          } = sort;\n          const outputName = facetSortFieldName(fieldDef, sort);\n\n          if (row && column) {\n            // For crossed facet, use pre-calculate field as it requires a different groupby\n            // For each calculated field, apply max and assign them to the same name as\n            // all values of the same group should be the same anyway.\n            fields.push(outputName);\n            ops.push('max');\n            as.push(outputName);\n          } else {\n            fields.push(field);\n            ops.push(op);\n            as.push(outputName);\n          }\n        } else if (isArray(sort)) {\n          const outputName = sortArrayIndexField(fieldDef, channel);\n          fields.push(outputName);\n          ops.push('max');\n          as.push(outputName);\n        }\n      }\n    }\n\n    const cross = !!row && !!column;\n    return Object.assign({\n      name,\n      data,\n      groupby\n    }, cross || fields.length > 0 ? {\n      aggregate: Object.assign(Object.assign({}, cross ? {\n        cross\n      } : {}), fields.length ? {\n        fields,\n        ops,\n        as\n      } : {})\n    } : {});\n  }\n\n  facetSortFields(channel) {\n    const {\n      facet\n    } = this;\n    const fieldDef = facet[channel];\n\n    if (fieldDef) {\n      if (isSortField(fieldDef.sort)) {\n        return [facetSortFieldName(fieldDef, fieldDef.sort, {\n          expr: 'datum'\n        })];\n      } else if (isArray(fieldDef.sort)) {\n        return [sortArrayIndexField(fieldDef, channel, {\n          expr: 'datum'\n        })];\n      }\n\n      return [vgField(fieldDef, {\n        expr: 'datum'\n      })];\n    }\n\n    return [];\n  }\n\n  facetSortOrder(channel) {\n    const {\n      facet\n    } = this;\n    const fieldDef = facet[channel];\n\n    if (fieldDef) {\n      const {\n        sort\n      } = fieldDef;\n      const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n      return [order];\n    }\n\n    return [];\n  }\n\n  assembleLabelTitle() {\n    var _a;\n\n    const {\n      facet,\n      config\n    } = this;\n\n    if (facet.facet) {\n      // Facet always uses title to display labels\n      return assembleLabelTitle(facet.facet, 'facet', config);\n    }\n\n    const ORTHOGONAL_ORIENT = {\n      row: ['top', 'bottom'],\n      column: ['left', 'right']\n    };\n\n    for (const channel of HEADER_CHANNELS) {\n      if (facet[channel]) {\n        const labelOrient = getHeaderProperty('labelOrient', (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);\n\n        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n          // Row/Column with orthogonal labelOrient must use title to display labels\n          return assembleLabelTitle(facet[channel], channel, config);\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  assembleMarks() {\n    const {\n      child\n    } = this; // If we facet by two dimensions, we need to add a cross operator to the aggregation\n    // so that we create all groups\n\n    const facetRoot = this.component.data.facetRoot;\n    const data = assembleFacetData(facetRoot);\n    const encodeEntry = child.assembleGroupEncodeEntry(false);\n    const title = this.assembleLabelTitle() || child.assembleTitle();\n    const style = child.assembleGroupStyle();\n    const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      name: this.getName('cell'),\n      type: 'group'\n    }, title ? {\n      title\n    } : {}), style ? {\n      style\n    } : {}), {\n      from: {\n        facet: this.assembleFacet()\n      },\n      // TODO: move this to after data\n      sort: {\n        field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n        order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n      }\n    }), data.length > 0 ? {\n      data: data\n    } : {}), encodeEntry ? {\n      encode: {\n        update: encodeEntry\n      }\n    } : {}), child.assembleGroup(assembleFacetSignals(this, [])));\n    return [markGroup];\n  }\n\n  getMapping() {\n    return this.facet;\n  }\n\n}","map":{"version":3,"sources":["../../../src/compile/facet.ts"],"names":[],"mappings":"AACA,SAAQ,OAAR,QAAsB,WAAtB;AACA,SAAQ,SAAR,QAAwB,QAAxB;AACA,SAAQ,MAAR,EAA+C,cAA/C,EAA+D,uBAA/D,EAAwF,GAAxF,QAAkG,YAAlG;AACA,SAAmC,YAAnC,EAAgE,OAAhE,QAA8E,eAA9E;AAEA,SAAiB,cAAjB,QAAsC,SAAtC;AACA,OAAO,KAAK,GAAZ,MAAqB,QAArB;AACA,SAAQ,iBAAR,QAAgC,UAAhC;AACA,SAAQ,eAAR,EAA4C,WAA5C,QAAyE,SAAzE;AAEA,SAA2D,cAA3D,QAAgF,eAAhF;AACA,SAAQ,IAAR,QAAmB,SAAnB;AACA,SAAQ,aAAR,QAA2D,gBAA3D;AACA,SAAQ,UAAR,QAAyB,cAAzB;AACA,SAAQ,iBAAR,QAAgC,iBAAhC;AACA,SAAQ,mBAAR,QAAkC,kBAAlC;AACA,SAAQ,SAAR,QAAwB,cAAxB;AACA,SAAQ,kBAAR,QAAiC,mBAAjC;AACA,SAAQ,gBAAR,EAA0B,iBAA1B,QAAkD,iBAAlD;AACA,SAAQ,eAAR,EAAyB,YAAzB,QAA4C,oBAA5C;AACA,SAAQ,iBAAR,QAAgC,gBAAhC;AACA,SAAQ,uBAAR,QAAsC,oBAAtC;AACA,SAAe,cAAf,QAAoC,SAApC;AACA,SAAQ,cAAR,EAAwB,kBAAxB,QAAiD,gBAAjD;AACA,SAAQ,oBAAR,QAAmC,sBAAnC;AAEA,OAAM,SAAU,kBAAV,CACJ,QADI,EAEJ,IAFI,EAGJ,GAHI,EAGgB;AAEpB,SAAO,OAAO,CAAC,IAAD,EAAK,MAAA,CAAA,MAAA,CAAA;AAAG,IAAA,MAAM,EAAE,MAAM,OAAO,CAAC,QAAD,CAAU;AAAlC,GAAA,EAA0C,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAA,GAAA,GAAO,EAAjD,CAAL,CAAd;AACD;AAED,OAAM,MAAO,UAAP,SAA0B,cAA1B,CAAwC;AAO5C,EAAA,WAAA,CAAY,IAAZ,EAAuC,MAAvC,EAAsD,eAAtD,EAA+E,MAA/E,EAAwG;AACtG,UAAM,IAAN,EAAY,OAAZ,EAAqB,MAArB,EAA6B,eAA7B,EAA8C,MAA9C,EAAsD,IAAI,CAAC,OAA3D;AAEA,SAAK,KAAL,GAAa,UAAU,CAAC,IAAI,CAAC,IAAN,EAAY,IAAZ,EAAkB,KAAK,OAAL,CAAa,OAAb,CAAlB,EAAyC,SAAzC,EAAoD,MAApD,CAAvB;AACA,SAAK,QAAL,GAAgB,CAAC,KAAK,KAAN,CAAhB;AAEA,SAAK,KAAL,GAAa,KAAK,SAAL,CAAe,IAAI,CAAC,KAApB,CAAb;AACD;;AAEO,EAAA,SAAS,CACf,KADe,EAC0C;AAEzD;AACA,QAAI,CAAC,cAAc,CAAC,KAAD,CAAnB,EAA4B;AAC1B,aAAO;AAAC,QAAA,KAAK,EAAE,KAAK,iBAAL,CAAuB,KAAvB,EAA8B,OAA9B;AAAR,OAAP;AACD;;AAED,UAAM,QAAQ,GAAG,IAAI,CAAC,KAAD,CAArB;AACA,UAAM,eAAe,GAAG,EAAxB;;AACA,SAAK,MAAM,OAAX,IAAsB,QAAtB,EAAgC;AAC9B,UAAI,CAAC,CAAC,GAAD,EAAM,MAAN,EAAc,QAAd,CAAuB,OAAvB,CAAL,EAAsC;AACpC;AACA,QAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,mBAAZ,CAAgC,OAAhC,EAAyC,OAAzC,CAAT;AACA;AACD;;AAED,YAAM,QAAQ,GAAG,KAAK,CAAC,OAAD,CAAtB;;AACA,UAAI,QAAQ,CAAC,KAAT,KAAmB,SAAvB,EAAkC;AAChC,QAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,aAAZ,CAA0B,QAA1B,EAAoC,OAApC,CAAT;AACA;AACD;;AAED,MAAA,eAAe,CAAC,OAAD,CAAf,GAA2B,KAAK,iBAAL,CAAuB,QAAvB,EAAiC,OAAjC,CAA3B;AACD;;AAED,WAAO,eAAP;AACD;;AAEO,EAAA,iBAAiB,CAAC,QAAD,EAA0D,OAA1D,EAA+E;AACtG;AACA;AACA,UAAM,aAAa,GAAG,YAAY,CAAC,QAAD,EAAW,OAAX,CAAlC;;AACA,QAAI,aAAa,CAAC,MAAlB,EAA0B;AACxB,MAAA,aAAa,CAAC,MAAd,GAAuB,cAAc,CAAC,aAAa,CAAC,MAAf,CAArC;AACD,KAFD,MAEO,IAAI,aAAa,CAAC,MAAd,KAAyB,IAA7B,EAAmC;AACxC,MAAA,aAAa,CAAC,MAAd,GAAuB,IAAvB;AACD;;AACD,WAAO,aAAP;AACD;;AAEM,EAAA,eAAe,CAAC,OAAD,EAAyB;AAC7C,WAAO,CAAC,CAAC,KAAK,KAAL,CAAW,OAAX,CAAT;AACD;;AAEM,EAAA,QAAQ,CAAC,OAAD,EAAyB;AACtC,WAAO,KAAK,KAAL,CAAW,OAAX,CAAP;AACD;;AAEM,EAAA,SAAS,GAAA;AACd,SAAK,SAAL,CAAe,IAAf,GAAsB,SAAS,CAAC,IAAD,CAA/B;AACA,SAAK,KAAL,CAAW,SAAX;AACD;;AAEM,EAAA,eAAe,GAAA;AACpB,IAAA,uBAAuB,CAAC,IAAD,CAAvB;AACD;;AAEM,EAAA,eAAe,GAAA;AACpB;AACA;AACA;AACA,SAAK,KAAL,CAAW,eAAX;AACA,SAAK,SAAL,CAAe,SAAf,GAA2B,KAAK,KAAL,CAAW,SAAX,CAAqB,SAAhD;AACD;;AAEM,EAAA,cAAc,GAAA;AACnB,SAAK,KAAL,CAAW,cAAX;AACD;;AAEM,EAAA,mBAAmB,GAAA;AACxB,SAAK,KAAL,CAAW,mBAAX;AAEA,IAAA,iBAAiB,CAAC,IAAD,CAAjB;AACD;;AAEM,EAAA,gCAAgC,CAAC,OAAD,EAAqB;AAC1D,WAAO,KAAK,KAAL,CAAW,gCAAX,CAA4C,OAA5C,CAAP;AACD;;AAEM,EAAA,eAAe,GAAA;AACpB,SAAK,KAAL,CAAW,eAAX;AACA,WAAO,EAAP;AACD;;AAEM,EAAA,qBAAqB,CAAC,IAAD,EAAwB;AAClD,WAAO,KAAK,KAAL,CAAW,qBAAX,CAAiC,IAAjC,CAAP;AACD;;AAEO,EAAA,qBAAqB,GAAA;;;AAC3B,UAAM,YAAY,GAAa,EAA/B;;AAEA,SAAK,MAAM,OAAX,IAAsB,cAAtB,EAAsC;AACpC,WAAK,MAAM,UAAX,IAAyB,YAAzB,EAAuC;AACrC,cAAM,qBAAqB,GAAG,KAAK,SAAL,CAAe,aAAf,CAA6B,OAA7B,CAA9B;AACA,cAAM,eAAe,GAAG,qBAAqB,CAAC,UAAD,CAA7C;AAEA,cAAM;AAAC,UAAA;AAAD,YAAkB,qBAAxB;;AACA,YAAI,aAAJ,EAAmB;AACjB,gBAAM,WAAW,GAAG,iBAAiB,CAAC,aAAD,EAAgB,aAAa,CAAC,MAA9B,EAAsC,KAAK,MAA3C,EAAmD,OAAnD,CAArC;;AAEA,cAAI,CAAC,OAAD,EAAU,QAAV,EAAoB,QAApB,CAA6B,WAA7B,CAAJ,EAA+C;AAC7C,kBAAM,aAAa,GAAG,gBAAgB,CAAC,OAAD,EAAU,WAAV,CAAtC;AACA,aAAA,EAAA,GAAA,YAAY,CAAC,WAAb,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,EAAxB,GAAA,YAAY,CAAC,WAAb,GAA6B,EAA7B;AACA,YAAA,YAAY,CAAC,WAAb,CAAyB,aAAzB,IAA0C,KAA1C;AACD;AACF;;AAED,YAAI,eAAe,KAAA,IAAf,IAAA,eAAe,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAA,eAAe,CAAG,CAAH,CAAnB,EAA0B;AACxB;AACA,gBAAM,QAAQ,GAAG,OAAO,KAAK,KAAZ,GAAoB,QAApB,GAA+B,OAAhD;AACA,gBAAM,QAAQ,GAAG,UAAU,KAAK,QAAf,GAA0B,YAA1B,GAAyC,YAA1D;;AACA,cAAI,OAAO,KAAK,OAAZ,IAAuB,CAAC,KAAK,KAAL,CAAW,SAAX,CAAqB,UAArB,CAAgC,GAAhC,CAAoC,QAApC,CAA5B,EAA2E;AACzE;AACA,aAAA,EAAA,GAAA,YAAY,CAAC,QAAD,CAAZ,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,EAArB,GAAA,YAAY,CAAC,QAAD,CAAZ,GAA2B,EAA3B;AACA,YAAA,YAAY,CAAC,QAAD,CAAZ,CAAuB,OAAvB,IAAkC,GAAlC;AACD;;AAED,cAAI,qBAAqB,CAAC,KAA1B,EAAiC;AAC/B,aAAA,EAAA,GAAA,YAAY,CAAC,MAAb,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAA,YAAY,CAAC,MAAb,GAAwB,EAAxB;AACA,YAAA,YAAY,CAAC,MAAb,CAAoB,OAAO,KAAK,KAAZ,GAAoB,UAApB,GAAiC,aAArD,IAAsE,EAAtE;AACD;AACF;AACF;AACF;;AACD,WAAO,YAAP;AACD;;AAES,EAAA,qBAAqB,GAAA;AAC7B,UAAM;AAAC,MAAA,MAAD;AAAS,MAAA;AAAT,QAAgB,KAAK,KAA3B;AAEA,UAAM,OAAO,GAAG,MAAM,GAAG,KAAK,oBAAL,EAAH,GAAiC,GAAG,GAAG,CAAH,GAAO,SAAjE;AAEA,QAAI,KAAK,GAAgB,KAAzB,CAL6B,CAO7B;AACA;;AACA,QAAI,CAAC,GAAD,IAAQ,KAAK,SAAL,CAAe,OAAf,CAAuB,KAAvB,CAA6B,CAA7B,KAAmC,aAA/C,EAA8D;AAC5D,MAAA,KAAK,GAAG,MAAR;AACD,KAFD,MAEO,IAAI,CAAC,MAAD,IAAW,KAAK,SAAL,CAAe,OAAf,CAAuB,KAAvB,CAA6B,CAA7B,KAAmC,aAAlD,EAAiE;AACtE,MAAA,KAAK,GAAG,MAAR;AACD;;AAED,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,KAAK,qBAAL,EADL,CAAA,EAGM,OAAO,GAAG;AAAC,MAAA;AAAD,KAAH,GAAe,EAH5B,CAAA,EAG+B;AAC7B,MAAA,MAAM,EAAE,MADqB;AAE7B,MAAA;AAF6B,KAH/B,CAAA;AAOD;;AAEM,EAAA,qBAAqB,GAAA;AAC1B;AACA,WAAO,KAAK,KAAL,CAAW,qBAAX,EAAP;AACD;;AAEO,EAAA,oBAAoB,GAAA;AAC1B,QAAI,KAAK,MAAL,IAAe,KAAK,MAAL,YAAuB,UAA1C,EAAsD;AACpD;AACA;AACA;AACA,aAAO,SAAP;AACD,KALD,MAKO;AACL;AACA,YAAM,mBAAmB,GAAG,KAAK,OAAL,CAAa,eAAb,CAA5B;AACA,aAAO;AAAC,QAAA,MAAM,EAAE,gBAAgB,mBAAmB;AAA5C,OAAP;AACD;AACF;;AAEM,EAAA,kBAAkB,GAAA;AACvB,WAAO,SAAP;AACD;;AAEM,EAAA,aAAa,CAAC,OAAD,EAAqB;AACvC,QAAI,KAAK,MAAL,IAAe,KAAK,MAAL,YAAuB,UAA1C,EAAsD;AACpD;AACA;AACA;AACA,aAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACM,KAAK,eAAL,CAAqB,QAArB,IACA;AACE,QAAA,MAAM,EAAE;AACN,UAAA,MAAM,EAAE;AACN;AACA;AACA,YAAA,OAAO,EAAE;AAAC,cAAA,KAAK,EAAE,OAAO,CAAC,KAAK,KAAL,CAAW,MAAZ,EAAoB;AAAC,gBAAA,MAAM,EAAE;AAAT,eAApB;AAAf;AAHH;AADF;AADV,OADA,GAUA,EAXN,CAAA,EAYK,MAAM,aAAN,CAAoB,OAApB,CAZL,CAAA;AAcD;;AACD,WAAO,MAAM,aAAN,CAAoB,OAApB,CAAP;AACD;AAED;;;;;AAGQ,EAAA,+BAA+B,GAAA;AACrC,UAAM,MAAM,GAAa,EAAzB;AACA,UAAM,GAAG,GAAkB,EAA3B;AACA,UAAM,EAAE,GAAa,EAArB;;AAEA,QAAI,KAAK,KAAL,YAAsB,UAA1B,EAAsC;AACpC,UAAI,KAAK,KAAL,CAAW,eAAX,CAA2B,QAA3B,CAAJ,EAA0C;AACxC,cAAM,KAAK,GAAG,OAAO,CAAC,KAAK,KAAL,CAAW,KAAX,CAAiB,MAAlB,CAArB;AACA,QAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACA,QAAA,GAAG,CAAC,IAAJ,CAAS,UAAT;AACA,QAAA,EAAE,CAAC,IAAH,CAAQ,YAAY,KAAK,EAAzB;AACD;AACF,KAPD,MAOO;AACL,WAAK,MAAM,OAAX,IAAsB,uBAAtB,EAA+C;AAC7C,cAAM,mBAAmB,GAAG,KAAK,KAAL,CAAW,SAAX,CAAqB,MAArB,CAA4B,OAA5B,CAA5B;;AACA,YAAI,mBAAmB,IAAI,CAAC,mBAAmB,CAAC,MAAhD,EAAwD;AACtD,gBAAM,IAAI,GAAG,mBAAmB,CAAC,GAApB,CAAwB,MAAxB,CAAb;AACA,gBAAM,KAAK,GAAG,mBAAmB,CAAC,GAApB,CAAwB,OAAxB,CAAd;;AAEA,cAAI,iBAAiB,CAAC,IAAD,CAAjB,IAA2B,aAAa,CAAC,KAAD,CAA5C,EAAqD;AACnD,kBAAM,MAAM,GAAG,cAAc,CAAC,KAAK,KAAN,EAAa,OAAb,CAA7B;AACA,kBAAM,KAAK,GAAG,kBAAkB,CAAC,MAAD,CAAhC;;AACA,gBAAI,KAAJ,EAAW;AACT,cAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACA,cAAA,GAAG,CAAC,IAAJ,CAAS,UAAT;AACA,cAAA,EAAE,CAAC,IAAH,CAAQ,YAAY,KAAK,EAAzB;AACD,aAJD,MAIO;AACL,cAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,YAAZ,CAAyB,OAAzB,CAAT;AACD;AACF;AACF;AACF;AACF;;AACD,WAAO;AAAC,MAAA,MAAD;AAAS,MAAA,GAAT;AAAc,MAAA;AAAd,KAAP;AACD;;AAEO,EAAA,aAAa,GAAA;AACnB,UAAM;AAAC,MAAA,IAAD;AAAO,MAAA;AAAP,QAAe,KAAK,SAAL,CAAe,IAAf,CAAoB,SAAzC;AACA,UAAM;AAAC,MAAA,GAAD;AAAM,MAAA;AAAN,QAAgB,KAAK,KAA3B;AACA,UAAM;AAAC,MAAA,MAAD;AAAS,MAAA,GAAT;AAAc,MAAA;AAAd,QAAoB,KAAK,+BAAL,EAA1B;AACA,UAAM,OAAO,GAAa,EAA1B;;AAEA,SAAK,MAAM,OAAX,IAAsB,cAAtB,EAAsC;AACpC,YAAM,QAAQ,GAAG,KAAK,KAAL,CAAW,OAAX,CAAjB;;AACA,UAAI,QAAJ,EAAc;AACZ,QAAA,OAAO,CAAC,IAAR,CAAa,OAAO,CAAC,QAAD,CAApB;AAEA,cAAM;AAAC,UAAA,GAAD;AAAM,UAAA;AAAN,YAAc,QAApB;;AAEA,YAAI,SAAS,CAAC,GAAD,CAAb,EAAoB;AAClB,UAAA,OAAO,CAAC,IAAR,CAAa,OAAO,CAAC,QAAD,EAAW;AAAC,YAAA,SAAS,EAAE;AAAZ,WAAX,CAApB;AACD;;AAED,YAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AACrB,gBAAM;AAAC,YAAA,KAAD;AAAQ,YAAA,EAAE,GAAG;AAAb,cAAgC,IAAtC;AACA,gBAAM,UAAU,GAAG,kBAAkB,CAAC,QAAD,EAAW,IAAX,CAArC;;AACA,cAAI,GAAG,IAAI,MAAX,EAAmB;AACjB;AACA;AACA;AACA,YAAA,MAAM,CAAC,IAAP,CAAY,UAAZ;AACA,YAAA,GAAG,CAAC,IAAJ,CAAS,KAAT;AACA,YAAA,EAAE,CAAC,IAAH,CAAQ,UAAR;AACD,WAPD,MAOO;AACL,YAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACA,YAAA,GAAG,CAAC,IAAJ,CAAS,EAAT;AACA,YAAA,EAAE,CAAC,IAAH,CAAQ,UAAR;AACD;AACF,SAfD,MAeO,IAAI,OAAO,CAAC,IAAD,CAAX,EAAmB;AACxB,gBAAM,UAAU,GAAG,mBAAmB,CAAC,QAAD,EAAW,OAAX,CAAtC;AACA,UAAA,MAAM,CAAC,IAAP,CAAY,UAAZ;AACA,UAAA,GAAG,CAAC,IAAJ,CAAS,KAAT;AACA,UAAA,EAAE,CAAC,IAAH,CAAQ,UAAR;AACD;AACF;AACF;;AAED,UAAM,KAAK,GAAG,CAAC,CAAC,GAAF,IAAS,CAAC,CAAC,MAAzB;AAEA,WAAA,MAAA,CAAA,MAAA,CAAA;AACE,MAAA,IADF;AAEE,MAAA,IAFF;AAGE,MAAA;AAHF,KAAA,EAIM,KAAK,IAAI,MAAM,CAAC,MAAP,GAAgB,CAAzB,GACA;AACE,MAAA,SAAS,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACH,KAAK,GAAG;AAAC,QAAA;AAAD,OAAH,GAAa,EADf,CAAA,EAEH,MAAM,CAAC,MAAP,GAAgB;AAAC,QAAA,MAAD;AAAS,QAAA,GAAT;AAAc,QAAA;AAAd,OAAhB,GAAoC,EAFjC;AADX,KADA,GAOA,EAXN,CAAA;AAaD;;AAEO,EAAA,eAAe,CAAC,OAAD,EAAsB;AAC3C,UAAM;AAAC,MAAA;AAAD,QAAU,IAAhB;AACA,UAAM,QAAQ,GAAG,KAAK,CAAC,OAAD,CAAtB;;AAEA,QAAI,QAAJ,EAAc;AACZ,UAAI,WAAW,CAAC,QAAQ,CAAC,IAAV,CAAf,EAAgC;AAC9B,eAAO,CAAC,kBAAkB,CAAC,QAAD,EAAW,QAAQ,CAAC,IAApB,EAA0B;AAAC,UAAA,IAAI,EAAE;AAAP,SAA1B,CAAnB,CAAP;AACD,OAFD,MAEO,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAV,CAAX,EAA4B;AACjC,eAAO,CAAC,mBAAmB,CAAC,QAAD,EAAW,OAAX,EAAoB;AAAC,UAAA,IAAI,EAAE;AAAP,SAApB,CAApB,CAAP;AACD;;AACD,aAAO,CAAC,OAAO,CAAC,QAAD,EAAW;AAAC,QAAA,IAAI,EAAE;AAAP,OAAX,CAAR,CAAP;AACD;;AACD,WAAO,EAAP;AACD;;AAEO,EAAA,cAAc,CAAC,OAAD,EAAsB;AAC1C,UAAM;AAAC,MAAA;AAAD,QAAU,IAAhB;AACA,UAAM,QAAQ,GAAG,KAAK,CAAC,OAAD,CAAtB;;AACA,QAAI,QAAJ,EAAc;AACZ,YAAM;AAAC,QAAA;AAAD,UAAS,QAAf;AACA,YAAM,KAAK,GAAG,CAAC,WAAW,CAAC,IAAD,CAAX,GAAoB,IAAI,CAAC,KAAzB,GAAiC,CAAC,OAAO,CAAC,IAAD,CAAR,IAAkB,IAApD,KAA6D,WAA3E;AACA,aAAO,CAAC,KAAD,CAAP;AACD;;AACD,WAAO,EAAP;AACD;;AAEO,EAAA,kBAAkB,GAAA;;;AACxB,UAAM;AAAC,MAAA,KAAD;AAAQ,MAAA;AAAR,QAAkB,IAAxB;;AACA,QAAI,KAAK,CAAC,KAAV,EAAiB;AACf;AACA,aAAO,kBAAkB,CAAC,KAAK,CAAC,KAAP,EAAc,OAAd,EAAuB,MAAvB,CAAzB;AACD;;AAED,UAAM,iBAAiB,GAAG;AACxB,MAAA,GAAG,EAAE,CAAC,KAAD,EAAQ,QAAR,CADmB;AAExB,MAAA,MAAM,EAAE,CAAC,MAAD,EAAS,OAAT;AAFgB,KAA1B;;AAKA,SAAK,MAAM,OAAX,IAAsB,eAAtB,EAAuC;AACrC,UAAI,KAAK,CAAC,OAAD,CAAT,EAAoB;AAClB,cAAM,WAAW,GAAG,iBAAiB,CAAC,aAAD,EAAgB,CAAA,EAAA,GAAA,KAAK,CAAC,OAAD,CAAL,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,MAAhC,EAAwC,MAAxC,EAAgD,OAAhD,CAArC;;AACA,YAAI,iBAAiB,CAAC,OAAD,CAAjB,CAA2B,QAA3B,CAAoC,WAApC,CAAJ,EAAsD;AACpD;AACA,iBAAO,kBAAkB,CAAC,KAAK,CAAC,OAAD,CAAN,EAAiB,OAAjB,EAA0B,MAA1B,CAAzB;AACD;AACF;AACF;;AACD,WAAO,SAAP;AACD;;AAEM,EAAA,aAAa,GAAA;AAClB,UAAM;AAAC,MAAA;AAAD,QAAU,IAAhB,CADkB,CAGlB;AACA;;AACA,UAAM,SAAS,GAAG,KAAK,SAAL,CAAe,IAAf,CAAoB,SAAtC;AACA,UAAM,IAAI,GAAG,iBAAiB,CAAC,SAAD,CAA9B;AAEA,UAAM,WAAW,GAAG,KAAK,CAAC,wBAAN,CAA+B,KAA/B,CAApB;AAEA,UAAM,KAAK,GAAG,KAAK,kBAAL,MAA6B,KAAK,CAAC,aAAN,EAA3C;AACA,UAAM,KAAK,GAAG,KAAK,CAAC,kBAAN,EAAd;AAEA,UAAM,SAAS,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACb,MAAA,IAAI,EAAE,KAAK,OAAL,CAAa,MAAb,CADO;AAEb,MAAA,IAAI,EAAE;AAFO,KAAA,EAGT,KAAK,GAAG;AAAC,MAAA;AAAD,KAAH,GAAa,EAHT,CAAA,EAIT,KAAK,GAAG;AAAC,MAAA;AAAD,KAAH,GAAa,EAJT,CAAA,EAIY;AACzB,MAAA,IAAI,EAAE;AACJ,QAAA,KAAK,EAAE,KAAK,aAAL;AADH,OADmB;AAIzB;AACA,MAAA,IAAI,EAAE;AACJ,QAAA,KAAK,EAAE,cAAc,CAAC,GAAf,CAAmB,CAAC,IAAI,KAAK,eAAL,CAAqB,CAArB,CAAxB,EAAiD,IAAjD,EADH;AAEJ,QAAA,KAAK,EAAE,cAAc,CAAC,GAAf,CAAmB,CAAC,IAAI,KAAK,cAAL,CAAoB,CAApB,CAAxB,EAAgD,IAAhD;AAFH;AALmB,KAJZ,CAAA,EAaT,IAAI,CAAC,MAAL,GAAc,CAAd,GAAkB;AAAC,MAAA,IAAI,EAAE;AAAP,KAAlB,GAAiC,EAbxB,CAAA,EAcT,WAAW,GAAG;AAAC,MAAA,MAAM,EAAE;AAAC,QAAA,MAAM,EAAE;AAAT;AAAT,KAAH,GAAqC,EAdvC,CAAA,EAeV,KAAK,CAAC,aAAN,CAAoB,oBAAoB,CAAC,IAAD,EAAO,EAAP,CAAxC,CAfU,CAAf;AAkBA,WAAO,CAAC,SAAD,CAAP;AACD;;AAES,EAAA,UAAU,GAAA;AAClB,WAAO,KAAK,KAAZ;AACD;;AA5Y2C","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData } from './data/parse';\nimport { assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n    return vgField(sort, Object.assign({ suffix: `by_${vgField(fieldDef)}` }, (opt !== null && opt !== void 0 ? opt : {})));\n}\nexport class FacetModel extends ModelWithField {\n    constructor(spec, parent, parentGivenName, config) {\n        super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n        this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n        this.children = [this.child];\n        this.facet = this.initFacet(spec.facet);\n    }\n    initFacet(facet) {\n        // clone to prevent side effect to the original spec\n        if (!isFacetMapping(facet)) {\n            return { facet: this.initFacetFieldDef(facet, 'facet') };\n        }\n        const channels = keys(facet);\n        const normalizedFacet = {};\n        for (const channel of channels) {\n            if (![ROW, COLUMN].includes(channel)) {\n                // Drop unsupported channel\n                log.warn(log.message.incompatibleChannel(channel, 'facet'));\n                break;\n            }\n            const fieldDef = facet[channel];\n            if (fieldDef.field === undefined) {\n                log.warn(log.message.emptyFieldDef(fieldDef, channel));\n                break;\n            }\n            normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n        }\n        return normalizedFacet;\n    }\n    initFacetFieldDef(fieldDef, channel) {\n        // Cast because we call initFieldDef, which assumes general FieldDef.\n        // However, FacetFieldDef is a bit more constrained than the general FieldDef\n        const facetFieldDef = initFieldDef(fieldDef, channel);\n        if (facetFieldDef.header) {\n            facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n        }\n        else if (facetFieldDef.header === null) {\n            facetFieldDef.header = null;\n        }\n        return facetFieldDef;\n    }\n    channelHasField(channel) {\n        return !!this.facet[channel];\n    }\n    fieldDef(channel) {\n        return this.facet[channel];\n    }\n    parseData() {\n        this.component.data = parseData(this);\n        this.child.parseData();\n    }\n    parseLayoutSize() {\n        parseChildrenLayoutSize(this);\n    }\n    parseSelections() {\n        // As a facet has a single child, the selection components are the same.\n        // The child maintains its selections to assemble signals, which remain\n        // within its unit.\n        this.child.parseSelections();\n        this.component.selection = this.child.component.selection;\n    }\n    parseMarkGroup() {\n        this.child.parseMarkGroup();\n    }\n    parseAxesAndHeaders() {\n        this.child.parseAxesAndHeaders();\n        parseFacetHeaders(this);\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return this.child.assembleSelectionTopLevelSignals(signals);\n    }\n    assembleSignals() {\n        this.child.assembleSignals();\n        return [];\n    }\n    assembleSelectionData(data) {\n        return this.child.assembleSelectionData(data);\n    }\n    getHeaderLayoutMixins() {\n        var _a, _b, _c;\n        const layoutMixins = {};\n        for (const channel of FACET_CHANNELS) {\n            for (const headerType of HEADER_TYPES) {\n                const layoutHeaderComponent = this.component.layoutHeaders[channel];\n                const headerComponent = layoutHeaderComponent[headerType];\n                const { facetFieldDef } = layoutHeaderComponent;\n                if (facetFieldDef) {\n                    const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n                    if (['right', 'bottom'].includes(titleOrient)) {\n                        const headerChannel = getHeaderChannel(channel, titleOrient);\n                        (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : (layoutMixins.titleAnchor = {});\n                        layoutMixins.titleAnchor[headerChannel] = 'end';\n                    }\n                }\n                if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {\n                    // set header/footerBand\n                    const sizeType = channel === 'row' ? 'height' : 'width';\n                    const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n                    if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n                        // If facet child does not have size signal, then apply headerBand\n                        (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : (layoutMixins[bandType] = {});\n                        layoutMixins[bandType][channel] = 0.5;\n                    }\n                    if (layoutHeaderComponent.title) {\n                        (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : (layoutMixins.offset = {});\n                        layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n                    }\n                }\n            }\n        }\n        return layoutMixins;\n    }\n    assembleDefaultLayout() {\n        const { column, row } = this.facet;\n        const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n        let align = 'all';\n        // Do not align the cells if the scale corresponding to the direction is indepent.\n        // We always align when we facet into both row and column.\n        if (!row && this.component.resolve.scale.x === 'independent') {\n            align = 'none';\n        }\n        else if (!column && this.component.resolve.scale.y === 'independent') {\n            align = 'none';\n        }\n        return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), (columns ? { columns } : {})), { bounds: 'full', align });\n    }\n    assembleLayoutSignals() {\n        // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n        return this.child.assembleLayoutSignals();\n    }\n    columnDistinctSignal() {\n        if (this.parent && this.parent instanceof FacetModel) {\n            // For nested facet, we will add columns to group mark instead\n            // See discussion in https://github.com/vega/vega/issues/952\n            // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n            return undefined;\n        }\n        else {\n            // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n            const facetLayoutDataName = this.getName('column_domain');\n            return { signal: `length(data('${facetLayoutDataName}'))` };\n        }\n    }\n    assembleGroupStyle() {\n        return undefined;\n    }\n    assembleGroup(signals) {\n        if (this.parent && this.parent instanceof FacetModel) {\n            // Provide number of columns for layout.\n            // See discussion in https://github.com/vega/vega/issues/952\n            // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n            return Object.assign(Object.assign({}, (this.channelHasField('column')\n                ? {\n                    encode: {\n                        update: {\n                            // TODO(https://github.com/vega/vega-lite/issues/2759):\n                            // Correct the signal for facet of concat of facet_column\n                            columns: { field: vgField(this.facet.column, { prefix: 'distinct' }) }\n                        }\n                    }\n                }\n                : {})), super.assembleGroup(signals));\n        }\n        return super.assembleGroup(signals);\n    }\n    /**\n     * Aggregate cardinality for calculating size\n     */\n    getCardinalityAggregateForChild() {\n        const fields = [];\n        const ops = [];\n        const as = [];\n        if (this.child instanceof FacetModel) {\n            if (this.child.channelHasField('column')) {\n                const field = vgField(this.child.facet.column);\n                fields.push(field);\n                ops.push('distinct');\n                as.push(`distinct_${field}`);\n            }\n        }\n        else {\n            for (const channel of POSITION_SCALE_CHANNELS) {\n                const childScaleComponent = this.child.component.scales[channel];\n                if (childScaleComponent && !childScaleComponent.merged) {\n                    const type = childScaleComponent.get('type');\n                    const range = childScaleComponent.get('range');\n                    if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                        const domain = assembleDomain(this.child, channel);\n                        const field = getFieldFromDomain(domain);\n                        if (field) {\n                            fields.push(field);\n                            ops.push('distinct');\n                            as.push(`distinct_${field}`);\n                        }\n                        else {\n                            log.warn(log.message.unknownField(channel));\n                        }\n                    }\n                }\n            }\n        }\n        return { fields, ops, as };\n    }\n    assembleFacet() {\n        const { name, data } = this.component.data.facetRoot;\n        const { row, column } = this.facet;\n        const { fields, ops, as } = this.getCardinalityAggregateForChild();\n        const groupby = [];\n        for (const channel of FACET_CHANNELS) {\n            const fieldDef = this.facet[channel];\n            if (fieldDef) {\n                groupby.push(vgField(fieldDef));\n                const { bin, sort } = fieldDef;\n                if (isBinning(bin)) {\n                    groupby.push(vgField(fieldDef, { binSuffix: 'end' }));\n                }\n                if (isSortField(sort)) {\n                    const { field, op = DEFAULT_SORT_OP } = sort;\n                    const outputName = facetSortFieldName(fieldDef, sort);\n                    if (row && column) {\n                        // For crossed facet, use pre-calculate field as it requires a different groupby\n                        // For each calculated field, apply max and assign them to the same name as\n                        // all values of the same group should be the same anyway.\n                        fields.push(outputName);\n                        ops.push('max');\n                        as.push(outputName);\n                    }\n                    else {\n                        fields.push(field);\n                        ops.push(op);\n                        as.push(outputName);\n                    }\n                }\n                else if (isArray(sort)) {\n                    const outputName = sortArrayIndexField(fieldDef, channel);\n                    fields.push(outputName);\n                    ops.push('max');\n                    as.push(outputName);\n                }\n            }\n        }\n        const cross = !!row && !!column;\n        return Object.assign({ name,\n            data,\n            groupby }, (cross || fields.length > 0\n            ? {\n                aggregate: Object.assign(Object.assign({}, (cross ? { cross } : {})), (fields.length ? { fields, ops, as } : {}))\n            }\n            : {}));\n    }\n    facetSortFields(channel) {\n        const { facet } = this;\n        const fieldDef = facet[channel];\n        if (fieldDef) {\n            if (isSortField(fieldDef.sort)) {\n                return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: 'datum' })];\n            }\n            else if (isArray(fieldDef.sort)) {\n                return [sortArrayIndexField(fieldDef, channel, { expr: 'datum' })];\n            }\n            return [vgField(fieldDef, { expr: 'datum' })];\n        }\n        return [];\n    }\n    facetSortOrder(channel) {\n        const { facet } = this;\n        const fieldDef = facet[channel];\n        if (fieldDef) {\n            const { sort } = fieldDef;\n            const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n            return [order];\n        }\n        return [];\n    }\n    assembleLabelTitle() {\n        var _a;\n        const { facet, config } = this;\n        if (facet.facet) {\n            // Facet always uses title to display labels\n            return assembleLabelTitle(facet.facet, 'facet', config);\n        }\n        const ORTHOGONAL_ORIENT = {\n            row: ['top', 'bottom'],\n            column: ['left', 'right']\n        };\n        for (const channel of HEADER_CHANNELS) {\n            if (facet[channel]) {\n                const labelOrient = getHeaderProperty('labelOrient', (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);\n                if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n                    // Row/Column with orthogonal labelOrient must use title to display labels\n                    return assembleLabelTitle(facet[channel], channel, config);\n                }\n            }\n        }\n        return undefined;\n    }\n    assembleMarks() {\n        const { child } = this;\n        // If we facet by two dimensions, we need to add a cross operator to the aggregation\n        // so that we create all groups\n        const facetRoot = this.component.data.facetRoot;\n        const data = assembleFacetData(facetRoot);\n        const encodeEntry = child.assembleGroupEncodeEntry(false);\n        const title = this.assembleLabelTitle() || child.assembleTitle();\n        const style = child.assembleGroupStyle();\n        const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: this.getName('cell'), type: 'group' }, (title ? { title } : {})), (style ? { style } : {})), { from: {\n                facet: this.assembleFacet()\n            }, \n            // TODO: move this to after data\n            sort: {\n                field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n                order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n            } }), (data.length > 0 ? { data: data } : {})), (encodeEntry ? { encode: { update: encodeEntry } } : {})), child.assembleGroup(assembleFacetSignals(this, [])));\n        return [markGroup];\n    }\n    getMapping() {\n        return this.facet;\n    }\n}\n//# sourceMappingURL=facet.js.map"]},"metadata":{},"sourceType":"module"}