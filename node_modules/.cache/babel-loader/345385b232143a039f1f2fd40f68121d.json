{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar meta_1 = require(\"@turf/meta\");\n\nvar invariant_1 = require(\"@turf/invariant\");\n\nvar line_overlap_1 = require(\"@turf/line-overlap\");\n\nvar line_intersect_1 = require(\"@turf/line-intersect\");\n\nvar GeojsonEquality = require(\"geojson-equality\");\n/**\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n *\n * @name booleanOverlap\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\n * @returns {boolean} true/false\n * @example\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\n *\n * turf.booleanOverlap(poly1, poly2)\n * //=true\n * turf.booleanOverlap(poly2, poly3)\n * //=false\n */\n\n\nfunction booleanOverlap(feature1, feature2) {\n  // validation\n  if (!feature1) throw new Error('feature1 is required');\n  if (!feature2) throw new Error('feature2 is required');\n  var type1 = invariant_1.getType(feature1);\n  var type2 = invariant_1.getType(feature2);\n  if (type1 !== type2) throw new Error('features must be of the same type');\n  if (type1 === 'Point') throw new Error('Point geometry not supported'); // features must be not equal\n\n  var equality = new GeojsonEquality({\n    precision: 6\n  });\n  if (equality.compare(feature1, feature2)) return false;\n  var overlap = 0;\n\n  switch (type1) {\n    case 'MultiPoint':\n      var coords1 = meta_1.coordAll(feature1);\n      var coords2 = meta_1.coordAll(feature2);\n      coords1.forEach(function (coord1) {\n        coords2.forEach(function (coord2) {\n          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) overlap++;\n        });\n      });\n      break;\n\n    case 'LineString':\n    case 'MultiLineString':\n      meta_1.segmentEach(feature1, function (segment1) {\n        meta_1.segmentEach(feature2, function (segment2) {\n          if (line_overlap_1.default(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n\n    case 'Polygon':\n    case 'MultiPolygon':\n      meta_1.segmentEach(feature1, function (segment1) {\n        meta_1.segmentEach(feature2, function (segment2) {\n          if (line_intersect_1.default(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n  }\n\n  return overlap > 0;\n}\n\nexports.default = booleanOverlap;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/boolean-overlap/index.js"],"names":["Object","defineProperty","exports","value","meta_1","require","invariant_1","line_overlap_1","line_intersect_1","GeojsonEquality","booleanOverlap","feature1","feature2","Error","type1","getType","type2","equality","precision","compare","overlap","coords1","coordAll","coords2","forEach","coord1","coord2","segmentEach","segment1","segment2","default","features","length"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,OAAO,CAAC,YAAD,CAApB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,iBAAD,CAAzB;;AACA,IAAIE,cAAc,GAAGF,OAAO,CAAC,oBAAD,CAA5B;;AACA,IAAIG,gBAAgB,GAAGH,OAAO,CAAC,sBAAD,CAA9B;;AACA,IAAII,eAAe,GAAGJ,OAAO,CAAC,kBAAD,CAA7B;AACA;;;;;;;;;;;;;;;;;;;;;AAmBA,SAASK,cAAT,CAAwBC,QAAxB,EAAkCC,QAAlC,EAA4C;AACxC;AACA,MAAI,CAACD,QAAL,EACI,MAAM,IAAIE,KAAJ,CAAU,sBAAV,CAAN;AACJ,MAAI,CAACD,QAAL,EACI,MAAM,IAAIC,KAAJ,CAAU,sBAAV,CAAN;AACJ,MAAIC,KAAK,GAAGR,WAAW,CAACS,OAAZ,CAAoBJ,QAApB,CAAZ;AACA,MAAIK,KAAK,GAAGV,WAAW,CAACS,OAAZ,CAAoBH,QAApB,CAAZ;AACA,MAAIE,KAAK,KAAKE,KAAd,EACI,MAAM,IAAIH,KAAJ,CAAU,mCAAV,CAAN;AACJ,MAAIC,KAAK,KAAK,OAAd,EACI,MAAM,IAAID,KAAJ,CAAU,8BAAV,CAAN,CAXoC,CAYxC;;AACA,MAAII,QAAQ,GAAG,IAAIR,eAAJ,CAAoB;AAAES,IAAAA,SAAS,EAAE;AAAb,GAApB,CAAf;AACA,MAAID,QAAQ,CAACE,OAAT,CAAiBR,QAAjB,EAA2BC,QAA3B,CAAJ,EACI,OAAO,KAAP;AACJ,MAAIQ,OAAO,GAAG,CAAd;;AACA,UAAQN,KAAR;AACI,SAAK,YAAL;AACI,UAAIO,OAAO,GAAGjB,MAAM,CAACkB,QAAP,CAAgBX,QAAhB,CAAd;AACA,UAAIY,OAAO,GAAGnB,MAAM,CAACkB,QAAP,CAAgBV,QAAhB,CAAd;AACAS,MAAAA,OAAO,CAACG,OAAR,CAAgB,UAAUC,MAAV,EAAkB;AAC9BF,QAAAA,OAAO,CAACC,OAAR,CAAgB,UAAUE,MAAV,EAAkB;AAC9B,cAAID,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAApB,IAA2BD,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAAnD,EACIN,OAAO;AACd,SAHD;AAIH,OALD;AAMA;;AACJ,SAAK,YAAL;AACA,SAAK,iBAAL;AACIhB,MAAAA,MAAM,CAACuB,WAAP,CAAmBhB,QAAnB,EAA6B,UAAUiB,QAAV,EAAoB;AAC7CxB,QAAAA,MAAM,CAACuB,WAAP,CAAmBf,QAAnB,EAA6B,UAAUiB,QAAV,EAAoB;AAC7C,cAAItB,cAAc,CAACuB,OAAf,CAAuBF,QAAvB,EAAiCC,QAAjC,EAA2CE,QAA3C,CAAoDC,MAAxD,EACIZ,OAAO;AACd,SAHD;AAIH,OALD;AAMA;;AACJ,SAAK,SAAL;AACA,SAAK,cAAL;AACIhB,MAAAA,MAAM,CAACuB,WAAP,CAAmBhB,QAAnB,EAA6B,UAAUiB,QAAV,EAAoB;AAC7CxB,QAAAA,MAAM,CAACuB,WAAP,CAAmBf,QAAnB,EAA6B,UAAUiB,QAAV,EAAoB;AAC7C,cAAIrB,gBAAgB,CAACsB,OAAjB,CAAyBF,QAAzB,EAAmCC,QAAnC,EAA6CE,QAA7C,CAAsDC,MAA1D,EACIZ,OAAO;AACd,SAHD;AAIH,OALD;AAMA;AA5BR;;AA8BA,SAAOA,OAAO,GAAG,CAAjB;AACH;;AACDlB,OAAO,CAAC4B,OAAR,GAAkBpB,cAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar line_overlap_1 = require(\"@turf/line-overlap\");\nvar line_intersect_1 = require(\"@turf/line-intersect\");\nvar GeojsonEquality = require(\"geojson-equality\");\n/**\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n *\n * @name booleanOverlap\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\n * @returns {boolean} true/false\n * @example\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\n *\n * turf.booleanOverlap(poly1, poly2)\n * //=true\n * turf.booleanOverlap(poly2, poly3)\n * //=false\n */\nfunction booleanOverlap(feature1, feature2) {\n    // validation\n    if (!feature1)\n        throw new Error('feature1 is required');\n    if (!feature2)\n        throw new Error('feature2 is required');\n    var type1 = invariant_1.getType(feature1);\n    var type2 = invariant_1.getType(feature2);\n    if (type1 !== type2)\n        throw new Error('features must be of the same type');\n    if (type1 === 'Point')\n        throw new Error('Point geometry not supported');\n    // features must be not equal\n    var equality = new GeojsonEquality({ precision: 6 });\n    if (equality.compare(feature1, feature2))\n        return false;\n    var overlap = 0;\n    switch (type1) {\n        case 'MultiPoint':\n            var coords1 = meta_1.coordAll(feature1);\n            var coords2 = meta_1.coordAll(feature2);\n            coords1.forEach(function (coord1) {\n                coords2.forEach(function (coord2) {\n                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1])\n                        overlap++;\n                });\n            });\n            break;\n        case 'LineString':\n        case 'MultiLineString':\n            meta_1.segmentEach(feature1, function (segment1) {\n                meta_1.segmentEach(feature2, function (segment2) {\n                    if (line_overlap_1.default(segment1, segment2).features.length)\n                        overlap++;\n                });\n            });\n            break;\n        case 'Polygon':\n        case 'MultiPolygon':\n            meta_1.segmentEach(feature1, function (segment1) {\n                meta_1.segmentEach(feature2, function (segment2) {\n                    if (line_intersect_1.default(segment1, segment2).features.length)\n                        overlap++;\n                });\n            });\n            break;\n    }\n    return overlap > 0;\n}\nexports.default = booleanOverlap;\n"]},"metadata":{},"sourceType":"script"}