{"ast":null,"code":"function systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\nconst DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n  var _header$shape;\n\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {\n    header,\n    headerEndOffset\n  } = parseHeader(view);\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n\n  if (!ArrayType) {\n    console.warn(\"Decoding of npy dtype not implemented: \".concat(numpyType));\n    return null;\n  }\n\n  const nArrayElements = (_header$shape = header.shape) === null || _header$shape === void 0 ? void 0 : _header$shape.reduce((a, b) => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  if (numpyType[0] === '>' && LITTLE_ENDIAN_OS || numpyType[0] === '<' && !LITTLE_ENDIAN_OS) {\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\nfunction parseHeader(view) {\n  const majorVersion = view.getUint8(6);\n  let offset = 8;\n  let headerLength;\n\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n  const header = JSON.parse(headerText.replace(/'/g, '\"').replace('False', 'false').replace('(', '[').replace(/,*\\),*/g, ']'));\n  return {\n    header,\n    headerEndOffset: offset\n  };\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-npy.ts"],"names":["a","b","LITTLE_ENDIAN_OS","systemIsLittleEndian","DTYPES","u1","i1","u2","i2","u4","i4","f4","f8","Float64Array","view","headerEndOffset","parseHeader","numpyType","header","ArrayType","console","nArrayElements","arrayByteLength","data","arrayBuffer","majorVersion","offset","headerLength","encoding","decoder","headerArray","headerText","JSON"],"mappings":"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","sourcesContent":["type NumpyHeader = {descr: string; shape: number[]};\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES: Record<string, any> = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer: ArrayBuffer, options?: unknown) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn(`Decoding of npy dtype not implemented: ${numpyType}`);\n    return null;\n  }\n\n  const nArrayElements = header.shape?.reduce((a: number, b: number): number => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view: DataView): {header: NumpyHeader; headerEndOffset: number} {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n"]},"metadata":{},"sourceType":"module"}