{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport { parseUniformName, getUniformSetter } from './uniforms';\nimport { VertexShader, FragmentShader } from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport { copyUniform, checkUniformValues } from './uniforms';\nimport { isWebGL2, assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { getPrimitiveDrawMode } from '../webgl-utils/attribute-utils';\nimport { assert } from '../utils/assert';\nimport { uid } from '../utils/utils';\nvar LOG_PROGRAM_PERF_PRIORITY = 4;\nvar GL_SEPARATE_ATTRIBS = 0x8c8d;\nvar V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];\n\nvar Program = /*#__PURE__*/function (_Resource) {\n  _inherits(Program, _Resource);\n\n  var _super = _createSuper(Program);\n\n  function Program(gl) {\n    var _this;\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Program);\n\n    _this = _super.call(this, gl, props);\n\n    _this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n\n    _this._isCached = false;\n\n    _this.initialize(props);\n\n    Object.seal(_assertThisInitialized(_this));\n\n    _this._setId(props.id);\n\n    return _this;\n  }\n\n  _createClass(Program, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var hash = props.hash,\n          vs = props.vs,\n          fs = props.fs,\n          varyings = props.varyings,\n          _props$bufferMode = props.bufferMode,\n          bufferMode = _props$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _props$bufferMode;\n      this.hash = hash || '';\n      this.vs = typeof vs === 'string' ? new VertexShader(this.gl, {\n        id: \"\".concat(props.id, \"-vs\"),\n        source: vs\n      }) : vs;\n      this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, {\n        id: \"\".concat(props.id, \"-fs\"),\n        source: fs\n      }) : fs;\n      assert(this.vs instanceof VertexShader);\n      assert(this.fs instanceof FragmentShader);\n      this.uniforms = {};\n      this._textureUniforms = {};\n\n      if (varyings && varyings.length > 0) {\n        assertWebGL2Context(this.gl);\n        this.varyings = varyings;\n        this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n      }\n\n      this._compileAndLink();\n\n      this._readUniformLocationsFromLinkedProgram();\n\n      this.configuration = new ProgramConfiguration(this);\n      return this.setProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._isCached) {\n        return this;\n      }\n\n      return _get(_getPrototypeOf(Program.prototype), \"delete\", this).call(this, options);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref) {\n      var _this2 = this;\n\n      var logPriority = _ref.logPriority,\n          _ref$drawMode = _ref.drawMode,\n          drawMode = _ref$drawMode === void 0 ? 4 : _ref$drawMode,\n          vertexCount = _ref.vertexCount,\n          _ref$offset = _ref.offset,\n          offset = _ref$offset === void 0 ? 0 : _ref$offset,\n          start = _ref.start,\n          end = _ref.end,\n          _ref$isIndexed = _ref.isIndexed,\n          isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed,\n          _ref$indexType = _ref.indexType,\n          indexType = _ref$indexType === void 0 ? 5123 : _ref$indexType,\n          _ref$instanceCount = _ref.instanceCount,\n          instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount,\n          _ref$isInstanced = _ref.isInstanced,\n          isInstanced = _ref$isInstanced === void 0 ? instanceCount > 0 : _ref$isInstanced,\n          _ref$vertexArray = _ref.vertexArray,\n          vertexArray = _ref$vertexArray === void 0 ? null : _ref$vertexArray,\n          transformFeedback = _ref.transformFeedback,\n          framebuffer = _ref.framebuffer,\n          _ref$parameters = _ref.parameters,\n          parameters = _ref$parameters === void 0 ? {} : _ref$parameters,\n          uniforms = _ref.uniforms,\n          samplers = _ref.samplers;\n\n      if (uniforms || samplers) {\n        log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n        this.setUniforms(uniforms || {});\n      }\n\n      if (log.priority >= logPriority) {\n        var fb = framebuffer ? framebuffer.id : 'default';\n        var message = \"mode=\".concat(getKey(this.gl, drawMode), \" verts=\").concat(vertexCount, \" \") + \"instances=\".concat(instanceCount, \" indexType=\").concat(getKey(this.gl, indexType), \" \") + \"isInstanced=\".concat(isInstanced, \" isIndexed=\").concat(isIndexed, \" \") + \"Framebuffer=\".concat(fb);\n        log.log(logPriority, message)();\n      }\n\n      assert(vertexArray);\n      this.gl.useProgram(this.handle);\n\n      if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {\n        return false;\n      }\n\n      vertexArray.bindForDraw(vertexCount, instanceCount, function () {\n        if (framebuffer !== undefined) {\n          parameters = Object.assign({}, parameters, {\n            framebuffer: framebuffer\n          });\n        }\n\n        if (transformFeedback) {\n          var primitiveMode = getPrimitiveDrawMode(drawMode);\n          transformFeedback.begin(primitiveMode);\n        }\n\n        _this2._bindTextures();\n\n        withParameters(_this2.gl, parameters, function () {\n          if (isIndexed && isInstanced) {\n            _this2.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n          } else if (isIndexed && isWebGL2(_this2.gl) && !isNaN(start) && !isNaN(end)) {\n            _this2.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n          } else if (isIndexed) {\n            _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);\n          } else if (isInstanced) {\n            _this2.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n          } else {\n            _this2.gl.drawArrays(drawMode, offset, vertexCount);\n          }\n        });\n\n        if (transformFeedback) {\n          transformFeedback.end();\n        }\n      });\n      return true;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (log.priority >= 2) {\n        checkUniformValues(uniforms, this.id, this._uniformSetters);\n      }\n\n      this.gl.useProgram(this.handle);\n\n      for (var uniformName in uniforms) {\n        var uniform = uniforms[uniformName];\n        var uniformSetter = this._uniformSetters[uniformName];\n\n        if (uniformSetter) {\n          var value = uniform;\n          var textureUpdate = false;\n\n          if (value instanceof Framebuffer) {\n            value = value.texture;\n          }\n\n          if (value instanceof Texture) {\n            textureUpdate = this.uniforms[uniformName] !== uniform;\n\n            if (textureUpdate) {\n              if (uniformSetter.textureIndex === undefined) {\n                uniformSetter.textureIndex = this._textureIndexCounter++;\n              }\n\n              var texture = value;\n              var textureIndex = uniformSetter.textureIndex;\n              texture.bind(textureIndex);\n              value = textureIndex;\n              this._textureUniforms[uniformName] = texture;\n            } else {\n              value = uniformSetter.textureIndex;\n            }\n          } else if (this._textureUniforms[uniformName]) {\n            delete this._textureUniforms[uniformName];\n          }\n\n          if (uniformSetter(value) || textureUpdate) {\n            copyUniform(this.uniforms, uniformName, uniform);\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_areTexturesRenderable\",\n    value: function _areTexturesRenderable() {\n      var texturesRenderable = true;\n\n      for (var uniformName in this._textureUniforms) {\n        var texture = this._textureUniforms[uniformName];\n        texture.update();\n        texturesRenderable = texturesRenderable && texture.loaded;\n      }\n\n      return texturesRenderable;\n    }\n  }, {\n    key: \"_bindTextures\",\n    value: function _bindTextures() {\n      for (var uniformName in this._textureUniforms) {\n        var textureIndex = this._uniformSetters[uniformName].textureIndex;\n\n        this._textureUniforms[uniformName].bind(textureIndex);\n      }\n    }\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createProgram();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteProgram(this.handle);\n    }\n  }, {\n    key: \"_getOptionsFromHandle\",\n    value: function _getOptionsFromHandle(handle) {\n      var shaderHandles = this.gl.getAttachedShaders(handle);\n      var opts = {};\n\n      var _iterator = _createForOfIteratorHelper(shaderHandles),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var shaderHandle = _step.value;\n          var type = this.gl.getShaderParameter(this.handle, 35663);\n\n          switch (type) {\n            case 35633:\n              opts.vs = new VertexShader({\n                handle: shaderHandle\n              });\n              break;\n\n            case 35632:\n              opts.fs = new FragmentShader({\n                handle: shaderHandle\n              });\n              break;\n\n            default:\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return opts;\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      return this.gl.getProgramParameter(this.handle, pname);\n    }\n  }, {\n    key: \"_setId\",\n    value: function _setId(id) {\n      if (!id) {\n        var programName = this._getName();\n\n        this.id = uid(programName);\n      }\n    }\n  }, {\n    key: \"_getName\",\n    value: function _getName() {\n      var programName = this.vs.getName() || this.fs.getName();\n      programName = programName.replace(/shader/i, '');\n      programName = programName ? \"\".concat(programName, \"-program\") : 'program';\n      return programName;\n    }\n  }, {\n    key: \"_compileAndLink\",\n    value: function _compileAndLink() {\n      var gl = this.gl;\n      gl.attachShader(this.handle, this.vs.handle);\n      gl.attachShader(this.handle, this.fs.handle);\n      log.time(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n      gl.linkProgram(this.handle);\n      log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n\n      if (gl.debug || log.level > 0) {\n        var linked = gl.getProgramParameter(this.handle, 35714);\n\n        if (!linked) {\n          throw new Error(\"Error linking: \".concat(gl.getProgramInfoLog(this.handle)));\n        }\n\n        gl.validateProgram(this.handle);\n        var validated = gl.getProgramParameter(this.handle, 35715);\n\n        if (!validated) {\n          throw new Error(\"Error validating: \".concat(gl.getProgramInfoLog(this.handle)));\n        }\n      }\n    }\n  }, {\n    key: \"_readUniformLocationsFromLinkedProgram\",\n    value: function _readUniformLocationsFromLinkedProgram() {\n      var gl = this.gl;\n      this._uniformSetters = {};\n      this._uniformCount = this._getParameter(35718);\n\n      for (var i = 0; i < this._uniformCount; i++) {\n        var info = this.gl.getActiveUniform(this.handle, i);\n\n        var _parseUniformName = parseUniformName(info.name),\n            name = _parseUniformName.name;\n\n        var location = gl.getUniformLocation(this.handle, name);\n        this._uniformSetters[name] = getUniformSetter(gl, location, info);\n\n        if (info.size > 1) {\n          for (var l = 0; l < info.size; l++) {\n            location = gl.getUniformLocation(this.handle, \"\".concat(name, \"[\").concat(l, \"]\"));\n            this._uniformSetters[\"\".concat(name, \"[\").concat(l, \"]\")] = getUniformSetter(gl, location, info);\n          }\n        }\n      }\n\n      this._textureIndexCounter = 0;\n    }\n  }, {\n    key: \"getActiveUniforms\",\n    value: function getActiveUniforms(uniformIndices, pname) {\n      return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);\n    }\n  }, {\n    key: \"getUniformBlockIndex\",\n    value: function getUniformBlockIndex(blockName) {\n      return this.gl2.getUniformBlockIndex(this.handle, blockName);\n    }\n  }, {\n    key: \"getActiveUniformBlockParameter\",\n    value: function getActiveUniformBlockParameter(blockIndex, pname) {\n      return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n    }\n  }, {\n    key: \"uniformBlockBinding\",\n    value: function uniformBlockBinding(blockIndex, blockBinding) {\n      this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n    }\n  }]);\n\n  return Program;\n}(Resource);\n\nexport { Program as default };","map":{"version":3,"sources":["../../../src/classes/program.js"],"names":["LOG_PROGRAM_PERF_PRIORITY","GL_SEPARATE_ATTRIBS","V6_DEPRECATED_METHODS","constructor","props","Object","bufferMode","hash","id","source","vs","fs","assert","varyings","assertWebGL2Context","options","drawMode","offset","isIndexed","indexType","instanceCount","isInstanced","vertexArray","parameters","samplers","uniforms","log","fb","framebuffer","message","getKey","vertexCount","primitiveMode","getPrimitiveDrawMode","transformFeedback","withParameters","isWebGL2","isNaN","checkUniformValues","uniform","uniformSetter","value","textureUpdate","texture","textureIndex","copyUniform","texturesRenderable","shaderHandles","opts","type","handle","shaderHandle","programName","uid","gl","linked","validated","i","info","name","parseUniformName","location","getUniformSetter","l"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\n\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport {parseUniformName, getUniformSetter} from './uniforms';\nimport {VertexShader, FragmentShader} from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport {copyUniform, checkUniformValues} from './uniforms';\n\nimport {isWebGL2, assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {getPrimitiveDrawMode} from '../webgl-utils/attribute-utils';\nimport {assert} from '../utils/assert';\nimport {uid} from '../utils/utils';\n\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\n\nconst GL_SEPARATE_ATTRIBS = 0x8c8d;\n\nconst V6_DEPRECATED_METHODS = [\n  'setVertexArray',\n  'setAttributes',\n  'setBuffers',\n  'unsetBuffers',\n\n  'use',\n  'getUniformCount',\n  'getUniformInfo',\n  'getUniformLocation',\n  'getUniformValue',\n\n  'getVarying',\n  'getFragDataLocation',\n  'getAttachedShaders',\n  'getAttributeCount',\n  'getAttributeLocation',\n  'getAttributeInfo'\n];\n\nexport default class Program extends Resource {\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n\n    // Experimental flag to avoid deleting Program object while it is cached\n    this._isCached = false;\n\n    this.initialize(props);\n\n    Object.seal(this);\n\n    this._setId(props.id);\n  }\n\n  initialize(props = {}) {\n    const {hash, vs, fs, varyings, bufferMode = GL_SEPARATE_ATTRIBS} = props;\n\n    this.hash = hash || ''; // Used by ProgramManager\n\n    // Create shaders if needed\n    this.vs =\n      typeof vs === 'string' ? new VertexShader(this.gl, {id: `${props.id}-vs`, source: vs}) : vs;\n    this.fs =\n      typeof fs === 'string' ? new FragmentShader(this.gl, {id: `${props.id}-fs`, source: fs}) : fs;\n    assert(this.vs instanceof VertexShader);\n    assert(this.fs instanceof FragmentShader);\n\n    // uniforms\n    this.uniforms = {};\n\n    this._textureUniforms = {};\n\n    // Setup varyings if supplied\n    if (varyings && varyings.length > 0) {\n      assertWebGL2Context(this.gl);\n      this.varyings = varyings;\n      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n\n    this._compileAndLink();\n    this._readUniformLocationsFromLinkedProgram();\n    this.configuration = new ProgramConfiguration(this);\n\n    return this.setProps(props);\n  }\n\n  delete(options = {}) {\n    if (this._isCached) {\n      // This object is cached, do not delete\n      return this;\n    }\n    return super.delete(options);\n  }\n\n  setProps(props) {\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n    return this;\n  }\n\n  // A good thing about the WebGL API is that there are so many ways to draw things ;)\n  // This function unifies those ways into a single call using common parameters with sane defaults\n  draw({\n    logPriority, // Probe log priority, enables Model to do more integrated logging\n\n    drawMode = GL.TRIANGLES,\n    vertexCount,\n    offset = 0,\n    start,\n    end,\n    isIndexed = false,\n    indexType = GL.UNSIGNED_SHORT,\n    instanceCount = 0,\n    isInstanced = instanceCount > 0,\n\n    vertexArray = null,\n    transformFeedback,\n    framebuffer,\n    parameters = {},\n\n    // Deprecated\n    uniforms,\n    samplers\n  }) {\n    if (uniforms || samplers) {\n      // DEPRECATED: v7.0 (deprecated earlier but warning not properly implemented)\n      log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n      this.setUniforms(uniforms || {});\n    }\n\n    if (log.priority >= logPriority) {\n      const fb = framebuffer ? framebuffer.id : 'default';\n      const message =\n        `mode=${getKey(this.gl, drawMode)} verts=${vertexCount} ` +\n        `instances=${instanceCount} indexType=${getKey(this.gl, indexType)} ` +\n        `isInstanced=${isInstanced} isIndexed=${isIndexed} ` +\n        `Framebuffer=${fb}`;\n      log.log(logPriority, message)();\n    }\n\n    // TODO - move vertex array binding and transform feedback binding to withParameters?\n    assert(vertexArray);\n\n    this.gl.useProgram(this.handle);\n\n    if (\n      // Note: async textures set as uniforms might still be loading.\n      // Now that all uniforms have been updated, check if any texture\n      // in the uniforms is not yet initialized, then we don't draw\n      !this._areTexturesRenderable() ||\n      // Avoid WebGL draw call when not rendering any data\n      vertexCount === 0 ||\n      (isInstanced && instanceCount === 0)\n    ) {\n      return false;\n    }\n\n    vertexArray.bindForDraw(vertexCount, instanceCount, () => {\n      if (framebuffer !== undefined) {\n        parameters = Object.assign({}, parameters, {framebuffer});\n      }\n\n      if (transformFeedback) {\n        const primitiveMode = getPrimitiveDrawMode(drawMode);\n        transformFeedback.begin(primitiveMode);\n      }\n\n      this._bindTextures();\n\n      withParameters(this.gl, parameters, () => {\n        // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension\n        if (isIndexed && isInstanced) {\n          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n        } else if (isIndexed) {\n          this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n        } else if (isInstanced) {\n          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n        } else {\n          this.gl.drawArrays(drawMode, offset, vertexCount);\n        }\n      });\n\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n\n    return true;\n  }\n\n  setUniforms(uniforms = {}) {\n    if (log.priority >= 2) {\n      checkUniformValues(uniforms, this.id, this._uniformSetters);\n    }\n\n    this.gl.useProgram(this.handle);\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n\n      if (uniformSetter) {\n        let value = uniform;\n        let textureUpdate = false;\n\n        if (value instanceof Framebuffer) {\n          value = value.texture;\n        }\n        if (value instanceof Texture) {\n          textureUpdate = this.uniforms[uniformName] !== uniform;\n\n          if (textureUpdate) {\n            // eslint-disable-next-line max-depth\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            }\n\n            // Bind texture to index\n            const texture = value;\n            const {textureIndex} = uniformSetter;\n\n            texture.bind(textureIndex);\n            value = textureIndex;\n\n            this._textureUniforms[uniformName] = texture;\n          } else {\n            value = uniformSetter.textureIndex;\n          }\n        } else if (this._textureUniforms[uniformName]) {\n          delete this._textureUniforms[uniformName];\n        }\n\n        // NOTE(Tarek): uniformSetter returns whether\n        //   value had to be updated or not.\n        if (uniformSetter(value) || textureUpdate) {\n          copyUniform(this.uniforms, uniformName, uniform);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  // Checks if all texture-values uniforms are renderable (i.e. loaded)\n  // Update a texture if needed (e.g. from video)\n  // Note: This is currently done before every draw call\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n\n    for (const uniformName in this._textureUniforms) {\n      const texture = this._textureUniforms[uniformName];\n      texture.update();\n      texturesRenderable = texturesRenderable && texture.loaded;\n    }\n\n    return texturesRenderable;\n  }\n\n  // Binds textures\n  // Note: This is currently done before every draw call\n  _bindTextures() {\n    for (const uniformName in this._textureUniforms) {\n      const textureIndex = this._uniformSetters[uniformName].textureIndex;\n      this._textureUniforms[uniformName].bind(textureIndex);\n    }\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n\n  // Extract opts needed to initialize a `Program` from an independently created WebGLProgram handle\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, GL.SHADER_TYPE);\n      switch (type) {\n        case GL.VERTEX_SHADER:\n          // @ts-ignore\n          opts.vs = new VertexShader({handle: shaderHandle});\n          break;\n        case GL.FRAGMENT_SHADER:\n          // @ts-ignore\n          opts.fs = new FragmentShader({handle: shaderHandle});\n          break;\n        default:\n      }\n    }\n    return opts;\n  }\n\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n\n  // If program is not named, name it after shader names\n  // TODO - this.id will already have been initialized\n  _setId(id) {\n    if (!id) {\n      const programName = this._getName();\n      this.id = uid(programName);\n    }\n  }\n\n  // Generate a default name for the program based on names of the shaders\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? `${programName}-program` : 'program';\n    return programName;\n  }\n\n  _compileAndLink() {\n    const {gl} = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n\n    // Avoid checking program linking error in production\n    // @ts-ignore\n    if (gl.debug || log.level > 0) {\n      const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n      if (!linked) {\n        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n\n      gl.validateProgram(this.handle);\n      const validated = gl.getProgramParameter(this.handle, gl.VALIDATE_STATUS);\n      if (!validated) {\n        throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n    }\n  }\n\n  // query uniform locations and build name to setter map.\n  // TODO - This overlaps with ProgramConfiguration?\n  _readUniformLocationsFromLinkedProgram() {\n    const {gl} = this;\n    this._uniformSetters = {};\n    this._uniformCount = this._getParameter(GL.ACTIVE_UNIFORMS);\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.gl.getActiveUniform(this.handle, i);\n      const {name} = parseUniformName(info.name);\n      let location = gl.getUniformLocation(this.handle, name);\n      this._uniformSetters[name] = getUniformSetter(gl, location, info);\n      if (info.size > 1) {\n        for (let l = 0; l < info.size; l++) {\n          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);\n          this._uniformSetters[`${name}[${l}]`] = getUniformSetter(gl, location, info);\n        }\n      }\n    }\n    this._textureIndexCounter = 0;\n  }\n\n  // TO BE REMOVED in v7?\n\n  // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms\n  getActiveUniforms(uniformIndices, pname) {\n    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);\n  }\n\n  // Retrieves the index of a uniform block\n  getUniformBlockIndex(blockName) {\n    return this.gl2.getUniformBlockIndex(this.handle, blockName);\n  }\n\n  // Retrieves information about an active uniform block (`blockIndex`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter\n  getActiveUniformBlockParameter(blockIndex, pname) {\n    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n  }\n\n  // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)\n  uniformBlockBinding(blockIndex, blockBinding) {\n    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}