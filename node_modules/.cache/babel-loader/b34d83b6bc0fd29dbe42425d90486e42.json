{"ast":null,"code":"import { extend, error, isFunction, stringValue, toBoolean, toNumber, toDate, toString, identity, field, isObject, isArray, isIterable, hasOwnProperty } from 'vega-util';\nimport { dsvFormat } from 'd3-dsv';\nimport { feature, mesh } from 'topojson-client';\nimport { timeFormatDefaultLocale } from 'vega-format'; //   https://...    file://...    //...\n\nconst protocol_re = /^(data:|([A-Za-z]+:)?\\/\\/)/; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\n\nconst allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\n\nconst whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n// Special treatment in node.js for the file: protocol\n\nconst fileProtocol = 'file://';\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\n\nfunction loaderFactory(fetch, fs) {\n  return options => ({\n    options: options || {},\n    sanitize: sanitize,\n    load: load,\n    fileAccess: !!fs,\n    file: fileLoader(fs),\n    http: httpLoader(fetch)\n  });\n}\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\n\n\nasync function load(uri, options) {\n  const opt = await this.sanitize(uri, options),\n        url = opt.href;\n  return opt.localFile ? this.file(url) : this.http(url, options);\n}\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\n\n\nasync function sanitize(uri, options) {\n  options = extend({}, this.options, options);\n  const fileAccess = this.fileAccess,\n        result = {\n    href: null\n  };\n  let isFile, loadFile, base;\n  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n\n  if (uri == null || typeof uri !== 'string' || !isAllowed) {\n    error('Sanitize failure, invalid URI: ' + stringValue(uri));\n  }\n\n  const hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL\n\n  if ((base = options.baseURL) && !hasProtocol) {\n    // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    if (!uri.startsWith('/') && !base.endsWith('/')) {\n      uri = '/' + uri;\n    }\n\n    uri = base + uri;\n  } // should we load from file system?\n\n\n  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;\n\n  if (isFile) {\n    // strip file protocol\n    uri = uri.slice(fileProtocol.length);\n  } else if (uri.startsWith('//')) {\n    if (options.defaultProtocol === 'file') {\n      // if is file, strip protocol and set loadFile flag\n      uri = uri.slice(2);\n      loadFile = true;\n    } else {\n      // if relative protocol (starts with '//'), prepend default protocol\n      uri = (options.defaultProtocol || 'http') + ':' + uri;\n    }\n  } // set non-enumerable mode flag to indicate local file load\n\n\n  Object.defineProperty(result, 'localFile', {\n    value: !!loadFile\n  }); // set uri\n\n  result.href = uri; // set default result target, if specified\n\n  if (options.target) {\n    result.target = options.target + '';\n  } // set default result rel, if specified (#1542)\n\n\n  if (options.rel) {\n    result.rel = options.rel + '';\n  } // provide control over cross-origin image handling (#2238)\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\n\n\n  if (options.context === 'image' && options.crossOrigin) {\n    result.crossOrigin = options.crossOrigin + '';\n  } // return\n\n\n  return result;\n}\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\n\n\nfunction fileLoader(fs) {\n  return fs ? filename => new Promise((accept, reject) => {\n    fs.readFile(filename, (error, data) => {\n      if (error) reject(error);else accept(data);\n    });\n  }) : fileReject;\n}\n/**\n * Default file system loader that simply rejects.\n */\n\n\nasync function fileReject() {\n  error('No file system access.');\n}\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\n\n\nfunction httpLoader(fetch) {\n  return fetch ? async function (url, options) {\n    const opt = extend({}, this.options.http, options),\n          type = options && options.response,\n          response = await fetch(url, opt);\n    return !response.ok ? error(response.status + '' + response.statusText) : isFunction(response[type]) ? response[type]() : response.text();\n  } : httpReject;\n}\n/**\n * Default http request handler that simply rejects.\n */\n\n\nasync function httpReject() {\n  error('No HTTP fetch method available.');\n}\n\nconst isValid = _ => _ != null && _ === _;\n\nconst isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;\n\nconst isDate = _ => !Number.isNaN(Date.parse(_));\n\nconst isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);\n\nconst isInteger = _ => isNumber(_) && Number.isInteger(+_);\n\nconst typeParsers = {\n  boolean: toBoolean,\n  integer: toNumber,\n  number: toNumber,\n  date: toDate,\n  string: toString,\n  unknown: identity\n};\nconst typeTests = [isBoolean, isInteger, isNumber, isDate];\nconst typeList = ['boolean', 'integer', 'number', 'date'];\n\nfunction inferType(values, field) {\n  if (!values || !values.length) return 'unknown';\n  const n = values.length,\n        m = typeTests.length,\n        a = typeTests.map((_, i) => i + 1);\n\n  for (let i = 0, t = 0, j, value; i < n; ++i) {\n    value = field ? values[i][field] : values[i];\n\n    for (j = 0; j < m; ++j) {\n      if (a[j] && isValid(value) && !typeTests[j](value)) {\n        a[j] = 0;\n        ++t;\n        if (t === typeTests.length) return 'string';\n      }\n    }\n  }\n\n  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];\n}\n\nfunction inferTypes(data, fields) {\n  return fields.reduce((types, field) => {\n    types[field] = inferType(data, field);\n    return types;\n  }, {});\n}\n\nfunction delimitedFormat(delimiter) {\n  const parse = function (data, format) {\n    const delim = {\n      delimiter: delimiter\n    };\n    return dsv(data, format ? extend(format, delim) : delim);\n  };\n\n  parse.responseType = 'text';\n  return parse;\n}\n\nfunction dsv(data, format) {\n  if (format.header) {\n    data = format.header.map(stringValue).join(format.delimiter) + '\\n' + data;\n  }\n\n  return dsvFormat(format.delimiter).parse(data + '');\n}\n\ndsv.responseType = 'text';\n\nfunction isBuffer(_) {\n  return typeof Buffer === 'function' && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;\n}\n\nfunction json(data, format) {\n  const prop = format && format.property ? field(format.property) : identity;\n  return isObject(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));\n}\n\njson.responseType = 'json';\n\nfunction parseJSON(data, format) {\n  if (!isArray(data) && isIterable(data)) {\n    data = [...data];\n  }\n\n  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;\n}\n\nconst filters = {\n  interior: (a, b) => a !== b,\n  exterior: (a, b) => a === b\n};\n\nfunction topojson(data, format) {\n  let method, object, property, filter;\n  data = json(data, format);\n\n  if (format && format.feature) {\n    method = feature;\n    property = format.feature;\n  } else if (format && format.mesh) {\n    method = mesh;\n    property = format.mesh;\n    filter = filters[format.filter];\n  } else {\n    error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  object = (object = data.objects[property]) ? method(data, object, filter) : error('Invalid TopoJSON object: ' + property);\n  return object && object.features || [object];\n}\n\ntopojson.responseType = 'json';\nconst format = {\n  dsv: dsv,\n  csv: delimitedFormat(','),\n  tsv: delimitedFormat('\\t'),\n  json: json,\n  topojson: topojson\n};\n\nfunction formats(name, reader) {\n  if (arguments.length > 1) {\n    format[name] = reader;\n    return this;\n  } else {\n    return hasOwnProperty(format, name) ? format[name] : null;\n  }\n}\n\nfunction responseType(type) {\n  const f = formats(type);\n  return f && f.responseType || 'text';\n}\n\nfunction read(data, schema, timeParser, utcParser) {\n  schema = schema || {};\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\n\nfunction parse(data, types, timeParser, utcParser) {\n  if (!data.length) return; // early exit for empty data\n\n  const locale = timeFormatDefaultLocale();\n  timeParser = timeParser || locale.timeParse;\n  utcParser = utcParser || locale.utcParse;\n  let fields = data.columns || Object.keys(data[0]),\n      datum,\n      field,\n      i,\n      j,\n      n,\n      m;\n  if (types === 'auto') types = inferTypes(data, fields);\n  fields = Object.keys(types);\n  const parsers = fields.map(field => {\n    const type = types[field];\n    let parts, pattern;\n\n    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\n      parts = type.split(/:(.+)?/, 2); // split on first :\n\n      pattern = parts[1];\n\n      if (pattern[0] === '\\'' && pattern[pattern.length - 1] === '\\'' || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n        pattern = pattern.slice(1, -1);\n      }\n\n      const parse = parts[0] === 'utc' ? utcParser : timeParser;\n      return parse(pattern);\n    }\n\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return typeParsers[type];\n  });\n\n  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {\n    datum = data[i];\n\n    for (j = 0; j < m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}\n\nconst loader = loaderFactory(typeof fetch !== 'undefined' && fetch, // use built-in fetch API\nnull // no file system access\n);\nexport { format, formats, inferType, inferTypes, loader, read, responseType, typeParsers };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-loader/build/vega-loader.browser.module.js"],"names":["extend","error","isFunction","stringValue","toBoolean","toNumber","toDate","toString","identity","field","isObject","isArray","isIterable","hasOwnProperty","dsvFormat","feature","mesh","timeFormatDefaultLocale","protocol_re","allowed_re","whitespace_re","fileProtocol","loaderFactory","fetch","fs","options","sanitize","load","fileAccess","file","fileLoader","http","httpLoader","uri","opt","url","href","localFile","result","isFile","loadFile","base","isAllowed","test","replace","hasProtocol","baseURL","startsWith","endsWith","mode","slice","length","defaultProtocol","Object","defineProperty","value","target","rel","context","crossOrigin","filename","Promise","accept","reject","readFile","data","fileReject","type","response","ok","status","statusText","text","httpReject","isValid","_","isBoolean","isDate","Number","isNaN","Date","parse","isNumber","isInteger","typeParsers","boolean","integer","number","date","string","unknown","typeTests","typeList","inferType","values","n","m","a","map","i","t","j","reduce","u","v","inferTypes","fields","types","delimitedFormat","delimiter","format","delim","dsv","responseType","header","join","isBuffer","Buffer","json","prop","property","parseJSON","JSON","copy","stringify","filters","interior","b","exterior","topojson","method","object","filter","objects","features","csv","tsv","formats","name","reader","arguments","f","read","schema","timeParser","utcParser","columns","locale","timeParse","utcParse","keys","datum","parsers","parts","pattern","split","Error","loader"],"mappings":"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","sourcesContent":["import { extend, error, isFunction, stringValue, toBoolean, toNumber, toDate, toString, identity, field, isObject, isArray, isIterable, hasOwnProperty } from 'vega-util';\nimport { dsvFormat } from 'd3-dsv';\nimport { feature, mesh } from 'topojson-client';\nimport { timeFormatDefaultLocale } from 'vega-format';\n\n//   https://...    file://...    //...\n\nconst protocol_re = /^(data:|([A-Za-z]+:)?\\/\\/)/; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\n\nconst allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\n\nconst whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n// Special treatment in node.js for the file: protocol\n\nconst fileProtocol = 'file://';\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\n\nfunction loaderFactory (fetch, fs) {\n  return options => ({\n    options: options || {},\n    sanitize: sanitize,\n    load: load,\n    fileAccess: !!fs,\n    file: fileLoader(fs),\n    http: httpLoader(fetch)\n  });\n}\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\n\nasync function load(uri, options) {\n  const opt = await this.sanitize(uri, options),\n        url = opt.href;\n  return opt.localFile ? this.file(url) : this.http(url, options);\n}\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\n\n\nasync function sanitize(uri, options) {\n  options = extend({}, this.options, options);\n  const fileAccess = this.fileAccess,\n        result = {\n    href: null\n  };\n  let isFile, loadFile, base;\n  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n\n  if (uri == null || typeof uri !== 'string' || !isAllowed) {\n    error('Sanitize failure, invalid URI: ' + stringValue(uri));\n  }\n\n  const hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL\n\n  if ((base = options.baseURL) && !hasProtocol) {\n    // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    if (!uri.startsWith('/') && !base.endsWith('/')) {\n      uri = '/' + uri;\n    }\n\n    uri = base + uri;\n  } // should we load from file system?\n\n\n  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;\n\n  if (isFile) {\n    // strip file protocol\n    uri = uri.slice(fileProtocol.length);\n  } else if (uri.startsWith('//')) {\n    if (options.defaultProtocol === 'file') {\n      // if is file, strip protocol and set loadFile flag\n      uri = uri.slice(2);\n      loadFile = true;\n    } else {\n      // if relative protocol (starts with '//'), prepend default protocol\n      uri = (options.defaultProtocol || 'http') + ':' + uri;\n    }\n  } // set non-enumerable mode flag to indicate local file load\n\n\n  Object.defineProperty(result, 'localFile', {\n    value: !!loadFile\n  }); // set uri\n\n  result.href = uri; // set default result target, if specified\n\n  if (options.target) {\n    result.target = options.target + '';\n  } // set default result rel, if specified (#1542)\n\n\n  if (options.rel) {\n    result.rel = options.rel + '';\n  } // provide control over cross-origin image handling (#2238)\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\n\n\n  if (options.context === 'image' && options.crossOrigin) {\n    result.crossOrigin = options.crossOrigin + '';\n  } // return\n\n\n  return result;\n}\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\n\n\nfunction fileLoader(fs) {\n  return fs ? filename => new Promise((accept, reject) => {\n    fs.readFile(filename, (error, data) => {\n      if (error) reject(error);else accept(data);\n    });\n  }) : fileReject;\n}\n/**\n * Default file system loader that simply rejects.\n */\n\n\nasync function fileReject() {\n  error('No file system access.');\n}\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\n\n\nfunction httpLoader(fetch) {\n  return fetch ? async function (url, options) {\n    const opt = extend({}, this.options.http, options),\n          type = options && options.response,\n          response = await fetch(url, opt);\n    return !response.ok ? error(response.status + '' + response.statusText) : isFunction(response[type]) ? response[type]() : response.text();\n  } : httpReject;\n}\n/**\n * Default http request handler that simply rejects.\n */\n\n\nasync function httpReject() {\n  error('No HTTP fetch method available.');\n}\n\nconst isValid = _ => _ != null && _ === _;\n\nconst isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;\n\nconst isDate = _ => !Number.isNaN(Date.parse(_));\n\nconst isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);\n\nconst isInteger = _ => isNumber(_) && Number.isInteger(+_);\n\nconst typeParsers = {\n  boolean: toBoolean,\n  integer: toNumber,\n  number: toNumber,\n  date: toDate,\n  string: toString,\n  unknown: identity\n};\nconst typeTests = [isBoolean, isInteger, isNumber, isDate];\nconst typeList = ['boolean', 'integer', 'number', 'date'];\nfunction inferType(values, field) {\n  if (!values || !values.length) return 'unknown';\n  const n = values.length,\n        m = typeTests.length,\n        a = typeTests.map((_, i) => i + 1);\n\n  for (let i = 0, t = 0, j, value; i < n; ++i) {\n    value = field ? values[i][field] : values[i];\n\n    for (j = 0; j < m; ++j) {\n      if (a[j] && isValid(value) && !typeTests[j](value)) {\n        a[j] = 0;\n        ++t;\n        if (t === typeTests.length) return 'string';\n      }\n    }\n  }\n\n  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];\n}\nfunction inferTypes(data, fields) {\n  return fields.reduce((types, field) => {\n    types[field] = inferType(data, field);\n    return types;\n  }, {});\n}\n\nfunction delimitedFormat(delimiter) {\n  const parse = function (data, format) {\n    const delim = {\n      delimiter: delimiter\n    };\n    return dsv(data, format ? extend(format, delim) : delim);\n  };\n\n  parse.responseType = 'text';\n  return parse;\n}\nfunction dsv(data, format) {\n  if (format.header) {\n    data = format.header.map(stringValue).join(format.delimiter) + '\\n' + data;\n  }\n\n  return dsvFormat(format.delimiter).parse(data + '');\n}\ndsv.responseType = 'text';\n\nfunction isBuffer(_) {\n  return typeof Buffer === 'function' && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;\n}\n\nfunction json(data, format) {\n  const prop = format && format.property ? field(format.property) : identity;\n  return isObject(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));\n}\njson.responseType = 'json';\n\nfunction parseJSON(data, format) {\n  if (!isArray(data) && isIterable(data)) {\n    data = [...data];\n  }\n\n  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;\n}\n\nconst filters = {\n  interior: (a, b) => a !== b,\n  exterior: (a, b) => a === b\n};\nfunction topojson(data, format) {\n  let method, object, property, filter;\n  data = json(data, format);\n\n  if (format && format.feature) {\n    method = feature;\n    property = format.feature;\n  } else if (format && format.mesh) {\n    method = mesh;\n    property = format.mesh;\n    filter = filters[format.filter];\n  } else {\n    error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  object = (object = data.objects[property]) ? method(data, object, filter) : error('Invalid TopoJSON object: ' + property);\n  return object && object.features || [object];\n}\ntopojson.responseType = 'json';\n\nconst format = {\n  dsv: dsv,\n  csv: delimitedFormat(','),\n  tsv: delimitedFormat('\\t'),\n  json: json,\n  topojson: topojson\n};\nfunction formats(name, reader) {\n  if (arguments.length > 1) {\n    format[name] = reader;\n    return this;\n  } else {\n    return hasOwnProperty(format, name) ? format[name] : null;\n  }\n}\nfunction responseType(type) {\n  const f = formats(type);\n  return f && f.responseType || 'text';\n}\n\nfunction read (data, schema, timeParser, utcParser) {\n  schema = schema || {};\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\n\nfunction parse(data, types, timeParser, utcParser) {\n  if (!data.length) return; // early exit for empty data\n\n  const locale = timeFormatDefaultLocale();\n  timeParser = timeParser || locale.timeParse;\n  utcParser = utcParser || locale.utcParse;\n  let fields = data.columns || Object.keys(data[0]),\n      datum,\n      field,\n      i,\n      j,\n      n,\n      m;\n  if (types === 'auto') types = inferTypes(data, fields);\n  fields = Object.keys(types);\n  const parsers = fields.map(field => {\n    const type = types[field];\n    let parts, pattern;\n\n    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\n      parts = type.split(/:(.+)?/, 2); // split on first :\n\n      pattern = parts[1];\n\n      if (pattern[0] === '\\'' && pattern[pattern.length - 1] === '\\'' || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n        pattern = pattern.slice(1, -1);\n      }\n\n      const parse = parts[0] === 'utc' ? utcParser : timeParser;\n      return parse(pattern);\n    }\n\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return typeParsers[type];\n  });\n\n  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {\n    datum = data[i];\n\n    for (j = 0; j < m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}\n\nconst loader = loaderFactory(typeof fetch !== 'undefined' && fetch, // use built-in fetch API\nnull // no file system access\n);\n\nexport { format, formats, inferType, inferTypes, loader, read, responseType, typeParsers };\n"]},"metadata":{},"sourceType":"module"}