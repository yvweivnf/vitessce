{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _geoLayers = require(\"@deck.gl/geo-layers\");\n\nvar _editModes = require(\"@nebula.gl/edit-modes\");\n\nvar _h3Js = require(\"h3-js\");\n\nvar _editableGeojsonLayer = _interopRequireDefault(require(\"./editable-geojson-layer\"));\n\nvar _editableLayer = _interopRequireDefault(require(\"./editable-layer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_EDIT_MODE = _editModes.ViewMode;\nvar DEFAULT_H3_RESOLUTION = 9;\nvar EMPTY_FEATURE_COLLECTION = {\n  type: 'FeatureCollection',\n  features: []\n};\n\nvar defaultProps = _objectSpread({\n  mode: DEFAULT_EDIT_MODE\n}, _editableGeojsonLayer[\"default\"].defaultProps, {\n  // h3 layer\n  data: [],\n  selectedIndexes: [],\n  filled: false,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'pixels',\n  getHexagons: function getHexagons(d) {\n    return d.hexIds;\n  },\n  getEditedCluster: function getEditedCluster(updatedHexagons, existingCluster) {\n    if (existingCluster) {\n      return _objectSpread({}, existingCluster, {\n        hexIds: updatedHexagons\n      });\n    }\n\n    return {\n      hexIds: updatedHexagons\n    };\n  },\n  resolution: DEFAULT_H3_RESOLUTION\n});\n\nvar EditableH3ClusterLayer = /*#__PURE__*/function (_EditableLayer) {\n  _inherits(EditableH3ClusterLayer, _EditableLayer);\n\n  var _super = _createSuper(EditableH3ClusterLayer);\n\n  function EditableH3ClusterLayer() {\n    _classCallCheck(this, EditableH3ClusterLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EditableH3ClusterLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      _get(_getPrototypeOf(EditableH3ClusterLayer.prototype), \"initializeState\", this).call(this);\n\n      this.setState({\n        tentativeHexagonIDs: []\n      });\n    } // convert array of (lng, lat) coords to cluster of hexes\n\n  }, {\n    key: \"getDerivedHexagonIDs\",\n    value: function getDerivedHexagonIDs(coords) {\n      return (0, _h3Js.polyfill)(coords, this.props.resolution, true);\n    } // convert pair of (lng, lat) coords into single hex\n\n  }, {\n    key: \"getDerivedHexagonID\",\n    value: function getDerivedHexagonID(coords) {\n      return (0, _h3Js.geoToH3)(coords[1], coords[0], this.props.resolution);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n\n      var layers = [new _editableGeojsonLayer[\"default\"](this.getSubLayerProps({\n        id: 'editable-geojson',\n        mode: this.props.mode,\n        data: EMPTY_FEATURE_COLLECTION,\n        selectedFeatureIndexes: [],\n        onEdit: function onEdit(editAction) {\n          var editType = editAction.editType,\n              editContext = editAction.editContext;\n\n          switch (editType) {\n            case 'updateTentativeFeature':\n              // tentative feature updates, updated on every pointer move\n              if (editContext.feature.geometry.type === 'Polygon') {\n                var coords = editContext.feature.geometry.coordinates;\n\n                var hexIDs = _this.getDerivedHexagonIDs(coords);\n\n                _this.setState({\n                  tentativeHexagonIDs: hexIDs\n                });\n              } else if (editContext.feature.geometry.type === 'Point') {\n                var _coords = editContext.feature.geometry.coordinates;\n\n                var hexID = _this.getDerivedHexagonID(_coords);\n\n                _this.setState({\n                  tentativeHexagonIDs: [hexID]\n                });\n              }\n\n              break;\n\n            case 'addFeature':\n              var updatedData = _toConsumableArray(_this.props.data);\n\n              var modeConfig = _this.props.modeConfig;\n\n              if (!modeConfig || !modeConfig.booleanOperation) {\n                // add new h3 cluster\n                updatedData.push(_this.props.getEditedCluster(_this.state.tentativeHexagonIDs, null));\n              } else if (_this.props.selectedIndexes.length !== 1) {\n                // eslint-disable-next-line no-console,no-undef\n                console.warn('booleanOperation only supported for single cluster selection');\n              } else {\n                // they're affecting a selected cluster\n                var finalHexagonIDs;\n                var committedHexagonIDs = new Set(_this.getSelectedHexIDs());\n                var tentativeHexagonIDs = new Set(_this.state.tentativeHexagonIDs);\n\n                switch (modeConfig.booleanOperation) {\n                  case 'union':\n                  default:\n                    finalHexagonIDs = _toConsumableArray(new Set([].concat(_toConsumableArray(committedHexagonIDs), _toConsumableArray(tentativeHexagonIDs))));\n                    break;\n\n                  case 'intersection':\n                    finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function (hexID) {\n                      return tentativeHexagonIDs.has(hexID);\n                    });\n                    break;\n\n                  case 'difference':\n                    finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function (hexID) {\n                      return !tentativeHexagonIDs.has(hexID);\n                    });\n                    break;\n                }\n\n                var selectedIndex = _this.props.selectedIndexes[0];\n                var existingCluster = _this.props.data[selectedIndex];\n                updatedData[selectedIndex] = _this.props.getEditedCluster(finalHexagonIDs, existingCluster);\n              }\n\n              _this.setState({\n                tentativeHexagonIDs: []\n              });\n\n              _this.props.onEdit({\n                updatedData: updatedData\n              });\n\n              break;\n\n            default:\n              break;\n          }\n        }\n      })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({\n        id: 'hexagons',\n        data: this.props.data,\n        getHexagons: this.props.getHexagons\n      })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({\n        id: 'tentative-hexagons',\n        data: [{\n          hexIds: this.state.tentativeHexagonIDs\n        }],\n        getHexagons: function getHexagons(d) {\n          return d.hexIds;\n        }\n      }))];\n      return layers;\n    } // because data is an array of hexagon data, we take the cumulative of all selected indexes,\n    // using props.getHexagons to support multiple data types\n\n  }, {\n    key: \"getSelectedHexIDs\",\n    value: function getSelectedHexIDs() {\n      var _this2 = this;\n\n      var cumulativeHexIDs = [];\n      this.props.selectedIndexes.forEach(function (index) {\n        var selectedCluster = _this2.props.data[index];\n\n        var hexIDs = _this2.props.getHexagons(selectedCluster);\n\n        cumulativeHexIDs = cumulativeHexIDs.concat(hexIDs);\n      });\n      return cumulativeHexIDs;\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(_ref) {\n      var isDragging = _ref.isDragging;\n      var cursor = this.state.cursor;\n\n      if (!cursor) {\n        // default cursor\n        cursor = isDragging ? 'grabbing' : 'grab';\n      }\n\n      return cursor;\n    }\n  }]);\n\n  return EditableH3ClusterLayer;\n}(_editableLayer[\"default\"]);\n\nexports[\"default\"] = EditableH3ClusterLayer;\n\n_defineProperty(EditableH3ClusterLayer, \"layerName\", 'EditableH3ClusterLayer');\n\n_defineProperty(EditableH3ClusterLayer, \"defaultProps\", defaultProps);","map":{"version":3,"sources":["../../src/layers/editable-h3-cluster-layer.ts"],"names":["DEFAULT_EDIT_MODE","ViewMode","DEFAULT_H3_RESOLUTION","EMPTY_FEATURE_COLLECTION","type","features","defaultProps","mode","EditableGeoJsonLayer","data","selectedIndexes","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","Number","lineWidthUnits","getHexagons","d","getEditedCluster","hexIds","updatedHexagons","resolution","EditableH3ClusterLayer","EditableLayer","tentativeHexagonIDs","coords","layers","id","selectedFeatureIndexes","onEdit","editType","editContext","editAction","hexIDs","hexID","updatedData","modeConfig","console","committedHexagonIDs","finalHexagonIDs","selectedIndex","existingCluster","H3ClusterLayer","cumulativeHexIDs","selectedCluster","isDragging","cursor"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\nimport { H3ClusterLayer } from '@deck.gl/geo-layers';\nimport { ViewMode } from '@nebula.gl/edit-modes';\nimport { polyfill, geoToH3 } from 'h3-js';\nimport EditableGeoJsonLayer from './editable-geojson-layer';\nimport EditableLayer from './editable-layer';\n\nconst DEFAULT_EDIT_MODE = ViewMode;\nconst DEFAULT_H3_RESOLUTION = 9;\nconst EMPTY_FEATURE_COLLECTION = {\n  type: 'FeatureCollection',\n  features: [],\n};\n\nconst defaultProps = {\n  mode: DEFAULT_EDIT_MODE,\n\n  // EditableGeoJsonLayer\n  ...EditableGeoJsonLayer.defaultProps,\n\n  // h3 layer\n  data: [],\n  selectedIndexes: [],\n  filled: false,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'pixels',\n  getHexagons: (d) => d.hexIds,\n  getEditedCluster: (updatedHexagons, existingCluster) => {\n    if (existingCluster) {\n      return {\n        ...existingCluster,\n        hexIds: updatedHexagons,\n      };\n    }\n    return {\n      hexIds: updatedHexagons,\n    };\n  },\n  resolution: DEFAULT_H3_RESOLUTION,\n};\n\nexport default class EditableH3ClusterLayer extends EditableLayer {\n  static layerName = 'EditableH3ClusterLayer';\n  static defaultProps = defaultProps;\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      tentativeHexagonIDs: [],\n    });\n  }\n\n  // convert array of (lng, lat) coords to cluster of hexes\n  getDerivedHexagonIDs(coords) {\n    return polyfill(coords, this.props.resolution, true);\n  }\n\n  // convert pair of (lng, lat) coords into single hex\n  getDerivedHexagonID(coords) {\n    return geoToH3(coords[1], coords[0], this.props.resolution);\n  }\n\n  renderLayers() {\n    const layers: any = [\n      new EditableGeoJsonLayer(\n        this.getSubLayerProps({\n          id: 'editable-geojson',\n\n          mode: this.props.mode,\n          data: EMPTY_FEATURE_COLLECTION,\n          selectedFeatureIndexes: [],\n\n          onEdit: (editAction) => {\n            const { editType, editContext } = editAction;\n\n            switch (editType) {\n              case 'updateTentativeFeature':\n                // tentative feature updates, updated on every pointer move\n                if (editContext.feature.geometry.type === 'Polygon') {\n                  const coords = editContext.feature.geometry.coordinates;\n                  const hexIDs = this.getDerivedHexagonIDs(coords);\n\n                  this.setState({ tentativeHexagonIDs: hexIDs });\n                } else if (editContext.feature.geometry.type === 'Point') {\n                  const coords = editContext.feature.geometry.coordinates;\n                  const hexID = this.getDerivedHexagonID(coords);\n\n                  this.setState({ tentativeHexagonIDs: [hexID] });\n                }\n                break;\n              case 'addFeature':\n                const updatedData = [...this.props.data];\n                const { modeConfig } = this.props;\n\n                if (!modeConfig || !modeConfig.booleanOperation) {\n                  // add new h3 cluster\n                  updatedData.push(\n                    this.props.getEditedCluster(this.state.tentativeHexagonIDs, null)\n                  );\n                } else if (this.props.selectedIndexes.length !== 1) {\n                  // eslint-disable-next-line no-console,no-undef\n                  console.warn('booleanOperation only supported for single cluster selection');\n                } else {\n                  // they're affecting a selected cluster\n                  let finalHexagonIDs;\n                  const committedHexagonIDs = new Set(this.getSelectedHexIDs());\n                  const tentativeHexagonIDs = new Set(this.state.tentativeHexagonIDs);\n\n                  switch (modeConfig.booleanOperation) {\n                    case 'union':\n                    default:\n                      finalHexagonIDs = [\n                        ...new Set([...committedHexagonIDs, ...tentativeHexagonIDs]),\n                      ];\n                      break;\n                    case 'intersection':\n                      finalHexagonIDs = [...committedHexagonIDs].filter((hexID: string) =>\n                        tentativeHexagonIDs.has(hexID)\n                      );\n                      break;\n                    case 'difference':\n                      finalHexagonIDs = [...committedHexagonIDs].filter(\n                        (hexID: string) => !tentativeHexagonIDs.has(hexID)\n                      );\n                      break;\n                  }\n\n                  const selectedIndex = this.props.selectedIndexes[0];\n                  const existingCluster = this.props.data[selectedIndex];\n                  updatedData[selectedIndex] = this.props.getEditedCluster(\n                    finalHexagonIDs,\n                    existingCluster\n                  );\n                }\n\n                this.setState({\n                  tentativeHexagonIDs: [],\n                });\n\n                this.props.onEdit({ updatedData });\n\n                break;\n              default:\n                break;\n            }\n          },\n        })\n      ),\n\n      new H3ClusterLayer(\n        this.getSubLayerProps({\n          id: 'hexagons',\n          data: this.props.data,\n          getHexagons: this.props.getHexagons,\n        })\n      ),\n      new H3ClusterLayer(\n        this.getSubLayerProps({\n          id: 'tentative-hexagons',\n          data: [\n            {\n              hexIds: this.state.tentativeHexagonIDs,\n            },\n          ],\n          getHexagons: (d) => d.hexIds,\n        })\n      ),\n    ];\n    return layers;\n  }\n\n  // because data is an array of hexagon data, we take the cumulative of all selected indexes,\n  // using props.getHexagons to support multiple data types\n  getSelectedHexIDs() {\n    let cumulativeHexIDs = [];\n    this.props.selectedIndexes.forEach((index) => {\n      const selectedCluster = this.props.data[index];\n      const hexIDs = this.props.getHexagons(selectedCluster);\n      cumulativeHexIDs = cumulativeHexIDs.concat(hexIDs);\n    });\n    return cumulativeHexIDs;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    let { cursor } = this.state;\n    if (!cursor) {\n      // default cursor\n      cursor = isDragging ? 'grabbing' : 'grab';\n    }\n    return cursor;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}