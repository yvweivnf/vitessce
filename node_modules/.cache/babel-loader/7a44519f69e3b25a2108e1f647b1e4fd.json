{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  const {\n    tooltip\n  } = oldEncoding,\n        filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n\n  if (!tooltip) {\n    return {\n      filteredEncoding\n    };\n  }\n\n  let customTooltipWithAggregatedField;\n  let customTooltipWithoutAggregatedField;\n\n  if (isArray(tooltip)) {\n    for (const t of tooltip) {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n\n        customTooltipWithAggregatedField.push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n\n        customTooltipWithoutAggregatedField.push(t);\n      }\n    }\n\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n\n  return {\n    customTooltipWithoutAggregatedField,\n    filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n\n  const fiveSummaryTooltip = tooltipSummary.map(({\n    fieldPrefix,\n    titlePrefix\n  }) => {\n    const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n    return {\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: isSignalRef(titlePrefix) ? {\n        signal: `${titlePrefix}\"${escape(mainTitle)}\"`\n      } : titlePrefix + mainTitle\n    };\n  });\n  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n  return {\n    tooltip: [...fiveSummaryTooltip, // need to cast because TextFieldDef supports fewer types of bin\n    ...unique(tooltipFieldDefs, hash)]\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  const {\n    title,\n    field\n  } = continuousAxisChannelDef;\n  return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  const {\n    scale,\n    axis\n  } = continuousAxisChannelDef;\n  return ({\n    partName,\n    mark,\n    positionPrefix,\n    endPositionPrefix = undefined,\n    extraEncoding = {}\n  }) => {\n    const title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark,\n      encoding: Object.assign(Object.assign(Object.assign({\n        [continuousAxis]: Object.assign(Object.assign(Object.assign({\n          field: `${positionPrefix}_${continuousAxisChannelDef.field}`,\n          type: continuousAxisChannelDef.type\n        }, title !== undefined ? {\n          title\n        } : {}), scale !== undefined ? {\n          scale\n        } : {}), axis !== undefined ? {\n          axis\n        } : {})\n      }, isString(endPositionPrefix) ? {\n        [`${continuousAxis}2`]: {\n          field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n        }\n      } : {}), sharedEncoding), extraEncoding)\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  const {\n    clip,\n    color,\n    opacity\n  } = markDef;\n  const mark = markDef.type;\n\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [Object.assign(Object.assign({}, partBaseSpec), {\n      mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? {\n        clip\n      } : {}), color ? {\n        color\n      } : {}), opacity ? {\n        opacity\n      } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n        type: partBaseSpec.mark\n      }), {\n        style: `${mark}-${part}`\n      }), isBoolean(markDef[part]) ? {} : markDef[part])\n    })];\n  }\n\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  const {\n    encoding\n  } = spec;\n  const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n\n  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];\n  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];\n  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {\n    const {\n      aggregate\n    } = continuousAxisChannelDef,\n          continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient(spec, compositeMark) {\n  const {\n    mark,\n    encoding\n  } = spec;\n  const {\n    x,\n    y\n  } = encoding;\n\n  if (isMarkDef(mark) && mark.orient) {\n    return mark.orient;\n  }\n\n  if (isContinuousFieldOrDatumDef(x)) {\n    // x is continuous\n    if (isContinuousFieldOrDatumDef(y)) {\n      // both x and y are continuous\n      const xAggregate = isFieldDef(x) && x.aggregate;\n      const yAggregate = isFieldDef(y) && y.aggregate;\n\n      if (!xAggregate && yAggregate === compositeMark) {\n        return 'vertical';\n      } else if (!yAggregate && xAggregate === compositeMark) {\n        return 'horizontal';\n      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n          // y is temporal but x is not\n          return 'horizontal';\n        } // default orientation for two continuous\n\n\n        return 'vertical';\n      }\n    }\n\n    return 'horizontal';\n  } else if (isContinuousFieldOrDatumDef(y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n  }\n}","map":{"version":3,"sources":["../../../src/compositemark/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n    const { tooltip } = oldEncoding, filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n    if (!tooltip) {\n        return { filteredEncoding };\n    }\n    let customTooltipWithAggregatedField;\n    let customTooltipWithoutAggregatedField;\n    if (isArray(tooltip)) {\n        for (const t of tooltip) {\n            if (t.aggregate) {\n                if (!customTooltipWithAggregatedField) {\n                    customTooltipWithAggregatedField = [];\n                }\n                customTooltipWithAggregatedField.push(t);\n            }\n            else {\n                if (!customTooltipWithoutAggregatedField) {\n                    customTooltipWithoutAggregatedField = [];\n                }\n                customTooltipWithoutAggregatedField.push(t);\n            }\n        }\n        if (customTooltipWithAggregatedField) {\n            filteredEncoding.tooltip = customTooltipWithAggregatedField;\n        }\n    }\n    else {\n        if (tooltip['aggregate']) {\n            filteredEncoding.tooltip = tooltip;\n        }\n        else {\n            customTooltipWithoutAggregatedField = tooltip;\n        }\n    }\n    if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n        customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n    }\n    return { customTooltipWithoutAggregatedField, filteredEncoding };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {\n    if ('tooltip' in encodingWithoutContinuousAxis) {\n        return { tooltip: encodingWithoutContinuousAxis.tooltip };\n    }\n    const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {\n        const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n        return {\n            field: fieldPrefix + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type,\n            title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}\"${escape(mainTitle)}\"` } : titlePrefix + mainTitle\n        };\n    });\n    const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n    return {\n        tooltip: [\n            ...fiveSummaryTooltip,\n            // need to cast because TextFieldDef supports fewer types of bin\n            ...unique(tooltipFieldDefs, hash)\n        ]\n    };\n}\nexport function getTitle(continuousAxisChannelDef) {\n    const { title, field } = continuousAxisChannelDef;\n    return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n    const { scale, axis } = continuousAxisChannelDef;\n    return ({ partName, mark, positionPrefix, endPositionPrefix = undefined, extraEncoding = {} }) => {\n        const title = getTitle(continuousAxisChannelDef);\n        return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n            mark,\n            encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: `${positionPrefix}_${continuousAxisChannelDef.field}`, type: continuousAxisChannelDef.type }, (title !== undefined ? { title } : {})), (scale !== undefined ? { scale } : {})), (axis !== undefined ? { axis } : {})) }, (isString(endPositionPrefix)\n                ? {\n                    [`${continuousAxis}2`]: {\n                        field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n                    }\n                }\n                : {})), sharedEncoding), extraEncoding)\n        });\n    };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n    const { clip, color, opacity } = markDef;\n    const mark = markDef.type;\n    if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n        return [\n            Object.assign(Object.assign({}, partBaseSpec), { mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), (clip ? { clip } : {})), (color ? { color } : {})), (opacity ? { opacity } : {})), (isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark })), { style: `${mark}-${part}` }), (isBoolean(markDef[part]) ? {} : markDef[part])) })\n        ];\n    }\n    return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n    const { encoding } = spec;\n    const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n    const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n    const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];\n    const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];\n    const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];\n    return {\n        continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n        continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n        continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n        continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n        continuousAxis\n    };\n}\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n    if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {\n        const { aggregate } = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n        if (aggregate !== compositeMark) {\n            log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n        }\n        return continuousAxisWithoutAggregate;\n    }\n    else {\n        return continuousAxisChannelDef;\n    }\n}\nexport function compositeMarkOrient(spec, compositeMark) {\n    const { mark, encoding } = spec;\n    const { x, y } = encoding;\n    if (isMarkDef(mark) && mark.orient) {\n        return mark.orient;\n    }\n    if (isContinuousFieldOrDatumDef(x)) {\n        // x is continuous\n        if (isContinuousFieldOrDatumDef(y)) {\n            // both x and y are continuous\n            const xAggregate = isFieldDef(x) && x.aggregate;\n            const yAggregate = isFieldDef(y) && y.aggregate;\n            if (!xAggregate && yAggregate === compositeMark) {\n                return 'vertical';\n            }\n            else if (!yAggregate && xAggregate === compositeMark) {\n                return 'horizontal';\n            }\n            else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n                throw new Error('Both x and y cannot have aggregate');\n            }\n            else {\n                if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n                    // y is temporal but x is not\n                    return 'horizontal';\n                }\n                // default orientation for two continuous\n                return 'vertical';\n            }\n        }\n        return 'horizontal';\n    }\n    else if (isContinuousFieldOrDatumDef(y)) {\n        // y is continuous but x is not\n        return 'vertical';\n    }\n    else {\n        // Neither x nor y is continuous.\n        throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n    }\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}