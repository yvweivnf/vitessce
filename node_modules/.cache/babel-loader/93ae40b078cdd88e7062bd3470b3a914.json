{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nexport var TypedArrayManager = /*#__PURE__*/function () {\n  function TypedArrayManager(props) {\n    _classCallCheck(this, TypedArrayManager);\n\n    this._pool = [];\n    this.props = {\n      overAlloc: 2,\n      poolSize: 100\n    };\n    this.setProps(props);\n  }\n\n  _createClass(TypedArrayManager, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      Object.assign(this.props, props);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(typedArray, count, _ref) {\n      var _ref$size = _ref.size,\n          size = _ref$size === void 0 ? 1 : _ref$size,\n          type = _ref.type,\n          _ref$padding = _ref.padding,\n          padding = _ref$padding === void 0 ? 0 : _ref$padding,\n          _ref$copy = _ref.copy,\n          copy = _ref$copy === void 0 ? false : _ref$copy,\n          _ref$initialize = _ref.initialize,\n          initialize = _ref$initialize === void 0 ? false : _ref$initialize,\n          maxCount = _ref.maxCount;\n      var Type = type || typedArray && typedArray.constructor || Float32Array;\n      var newSize = count * size + padding;\n\n      if (ArrayBuffer.isView(typedArray)) {\n        if (newSize <= typedArray.length) {\n          return typedArray;\n        }\n\n        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n          return new Type(typedArray.buffer, 0, newSize);\n        }\n      }\n\n      var maxSize;\n\n      if (maxCount) {\n        maxSize = maxCount * size + padding;\n      }\n\n      var newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n      if (typedArray && copy) {\n        newArray.set(typedArray);\n      } else if (!initialize) {\n        newArray.fill(0, 0, 4);\n      }\n\n      this._release(typedArray);\n\n      return newArray;\n    }\n  }, {\n    key: \"release\",\n    value: function release(typedArray) {\n      this._release(typedArray);\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(Type, size, initialize, maxSize) {\n      var sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);\n\n      if (sizeToAllocate > maxSize) {\n        sizeToAllocate = maxSize;\n      }\n\n      var pool = this._pool;\n      var byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n\n      if (i >= 0) {\n        var array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n\n        if (initialize) {\n          array.fill(0);\n        }\n\n        return array;\n      }\n\n      return new Type(sizeToAllocate);\n    }\n  }, {\n    key: \"_release\",\n    value: function _release(typedArray) {\n      if (!ArrayBuffer.isView(typedArray)) {\n        return;\n      }\n\n      var pool = this._pool;\n      var buffer = typedArray.buffer;\n      var byteLength = buffer.byteLength;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n\n      if (i < 0) {\n        pool.push(buffer);\n      } else if (i > 0 || pool.length < this.props.poolSize) {\n        pool.splice(i, 0, buffer);\n      }\n\n      if (pool.length > this.props.poolSize) {\n        pool.shift();\n      }\n    }\n  }]);\n\n  return TypedArrayManager;\n}();\nexport default new TypedArrayManager();","map":{"version":3,"sources":["../../../src/utils/typed-array-manager.js"],"names":["constructor","overAlloc","poolSize","Object","size","padding","copy","initialize","maxCount","Type","type","typedArray","newSize","count","ArrayBuffer","maxSize","newArray","sizeToAllocate","Math","pool","byteLength","i","b","array","buffer"],"mappings":"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","sourcesContent":["export class TypedArrayManager {\n  constructor(props) {\n    this._pool = [];\n    this.props = {overAlloc: 2, poolSize: 100};\n    this.setProps(props);\n  }\n\n  setProps(props) {\n    Object.assign(this.props, props);\n  }\n\n  allocate(\n    typedArray,\n    count,\n    {size = 1, type, padding = 0, copy = false, initialize = false, maxCount}\n  ) {\n    const Type = type || (typedArray && typedArray.constructor) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    let maxSize;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size, initialize, maxSize) {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.props.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.props.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"]},"metadata":{},"sourceType":"module"}