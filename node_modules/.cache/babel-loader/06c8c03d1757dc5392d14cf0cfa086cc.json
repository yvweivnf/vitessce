{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { getOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\n\nexport function pointPosition(channel, model, _ref) {\n  var defaultPos = _ref.defaultPos,\n      vgChannel = _ref.vgChannel;\n  var encoding = model.encoding,\n      markDef = model.markDef,\n      config = model.config,\n      stack = model.stack;\n  var channelDef = encoding[channel];\n  var channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  var scaleName = model.scaleName(channel);\n  var scale = model.getScaleComponent(channel);\n  var offset = getOffset(channel, markDef); // Get default position or position from mark def\n\n  var defaultRef = pointPositionDefaultRef({\n    model: model,\n    defaultPos: defaultPos,\n    channel: channel,\n    scaleName: scaleName,\n    scale: scale\n  });\n  var valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: channel2Def,\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: defaultRef\n  });\n  return valueRef ? _defineProperty({}, vgChannel || channel, valueRef) : undefined;\n} // TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\n\nexport function positionRef(params) {\n  var channel = params.channel,\n      channelDef = params.channelDef,\n      scaleName = params.scaleName,\n      stack = params.stack,\n      offset = params.offset,\n      markDef = params.markDef; // This isn't a part of midPoint because we use midPoint for non-position too\n\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      var bandPosition = channelDef.bandPosition;\n\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName: scaleName,\n          fieldOrDatumDef: channelDef,\n          startSuffix: 'start',\n          bandPosition: bandPosition,\n          offset: offset\n        });\n      }\n    } // x or y use stack_end so that stacked line's point mark use stack_end too.\n\n\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset: offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef(_ref3) {\n  var model = _ref3.model,\n      defaultPos = _ref3.defaultPos,\n      channel = _ref3.channel,\n      scaleName = _ref3.scaleName,\n      scale = _ref3.scale;\n  var markDef = model.markDef,\n      config = model.config;\n  return function () {\n    var mainChannel = getMainRangeChannel(channel);\n    var vgChannel = getVgPositionChannel(channel);\n    var definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel: vgChannel\n    });\n\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n\n    switch (defaultPos) {\n      case 'zeroOrMin':\n      case 'zeroOrMax':\n        if (scaleName) {\n          var scaleType = scale.get('type');\n\n          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {// Log scales cannot have zero.\n            // Zero in time scale is arbitrary, and does not affect ratio.\n            // (Time is an interval level of measurement, not ratio).\n            // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          } else {\n            if (scale.domainDefinitelyIncludesZero()) {\n              return {\n                scale: scaleName,\n                value: 0\n              };\n            }\n          }\n        }\n\n        if (defaultPos === 'zeroOrMin') {\n          return mainChannel === 'y' ? {\n            field: {\n              group: 'height'\n            }\n          } : {\n            value: 0\n          };\n        } else {\n          // zeroOrMax\n          switch (mainChannel) {\n            case 'radius':\n              // max of radius is min(width, height) / 2\n              return {\n                signal: \"min(\".concat(model.width.signal, \",\").concat(model.height.signal, \")/2\")\n              };\n\n            case 'theta':\n              return {\n                signal: '2*PI'\n              };\n\n            case 'x':\n              return {\n                field: {\n                  group: 'width'\n                }\n              };\n\n            case 'y':\n              return {\n                value: 0\n              };\n          }\n        }\n\n        break;\n\n      case 'mid':\n        {\n          var sizeRef = model[getSizeChannel(channel)];\n          return Object.assign(Object.assign({}, sizeRef), {\n            mult: 0.5\n          });\n        }\n    } // defaultPos === null\n\n\n    return undefined;\n  };\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-point.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { getOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(channel, model, { defaultPos, vgChannel }) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding[channel];\n    const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const offset = getOffset(channel, markDef);\n    // Get default position or position from mark def\n    const defaultRef = pointPositionDefaultRef({\n        model,\n        defaultPos,\n        channel,\n        scaleName,\n        scale\n    });\n    const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude)\n        ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n            { field: model.getName(channel) }\n        : positionRef({\n            channel,\n            channelDef,\n            channel2Def,\n            markDef,\n            config,\n            scaleName,\n            scale,\n            stack,\n            offset,\n            defaultRef\n        });\n    return valueRef ? { [vgChannel || channel]: valueRef } : undefined;\n}\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(params) {\n    const { channel, channelDef, scaleName, stack, offset, markDef } = params;\n    // This isn't a part of midPoint because we use midPoint for non-position too\n    if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n        if (isFieldDef(channelDef)) {\n            let bandPosition = channelDef.bandPosition;\n            if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n                // theta and radius of text mark should use bandPosition = 0.5 by default\n                // so that labels for arc marks are centered automatically\n                bandPosition = 0.5;\n            }\n            if (bandPosition !== undefined) {\n                return ref.interpolatedSignalRef({\n                    scaleName,\n                    fieldOrDatumDef: channelDef,\n                    startSuffix: 'start',\n                    bandPosition,\n                    offset\n                });\n            }\n        }\n        // x or y use stack_end so that stacked line's point mark use stack_end too.\n        return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: 'end' }, { offset });\n    }\n    return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale }) {\n    const { markDef, config } = model;\n    return () => {\n        const mainChannel = getMainRangeChannel(channel);\n        const vgChannel = getVgPositionChannel(channel);\n        const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });\n        if (definedValueOrConfig !== undefined) {\n            return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n        }\n        switch (defaultPos) {\n            case 'zeroOrMin':\n            case 'zeroOrMax':\n                if (scaleName) {\n                    const scaleType = scale.get('type');\n                    if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n                        // Log scales cannot have zero.\n                        // Zero in time scale is arbitrary, and does not affect ratio.\n                        // (Time is an interval level of measurement, not ratio).\n                        // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n                    }\n                    else {\n                        if (scale.domainDefinitelyIncludesZero()) {\n                            return {\n                                scale: scaleName,\n                                value: 0\n                            };\n                        }\n                    }\n                }\n                if (defaultPos === 'zeroOrMin') {\n                    return mainChannel === 'y' ? { field: { group: 'height' } } : { value: 0 };\n                }\n                else {\n                    // zeroOrMax\n                    switch (mainChannel) {\n                        case 'radius':\n                            // max of radius is min(width, height) / 2\n                            return {\n                                signal: `min(${model.width.signal},${model.height.signal})/2`\n                            };\n                        case 'theta':\n                            return { signal: '2*PI' };\n                        case 'x':\n                            return { field: { group: 'width' } };\n                        case 'y':\n                            return { value: 0 };\n                    }\n                }\n                break;\n            case 'mid': {\n                const sizeRef = model[getSizeChannel(channel)];\n                return Object.assign(Object.assign({}, sizeRef), { mult: 0.5 });\n            }\n        }\n        // defaultPos === null\n        return undefined;\n    };\n}\n//# sourceMappingURL=position-point.js.map"]},"metadata":{},"sourceType":"module"}