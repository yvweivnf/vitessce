{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TranslateMode = void 0;\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _transformTranslate = _interopRequireDefault(require(\"@turf/transform-translate\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar TranslateMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(TranslateMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(TranslateMode);\n\n  function TranslateMode() {\n    var _this;\n\n    _classCallCheck(this, TranslateMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_geometryBeforeTranslate\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isTranslatable\", void 0);\n\n    return _this;\n  }\n\n  _createClass(TranslateMode, [{\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      if (!this._isTranslatable) {\n        // Nothing to do\n        return;\n      }\n\n      if (this._geometryBeforeTranslate) {\n        // Translate the geometry\n        var editAction = this.getTranslateAction(event.pointerDownMapCoords, event.mapCoords, 'translating', props);\n\n        if (editAction) {\n          props.onEdit(editAction);\n        }\n      } // cancel map panning\n\n\n      event.cancelPan();\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      this._isTranslatable = this.isSelectionPicked(event.pointerDownPicks || event.picks, props);\n      this.updateCursor(props);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      if (!this._isTranslatable) {\n        return;\n      }\n\n      this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection(props);\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      if (this._geometryBeforeTranslate) {\n        // Translate the geometry\n        var editAction = this.getTranslateAction(event.pointerDownMapCoords, event.mapCoords, 'translated', props);\n\n        if (editAction) {\n          props.onEdit(editAction);\n        }\n\n        this._geometryBeforeTranslate = null;\n      }\n    }\n  }, {\n    key: \"updateCursor\",\n    value: function updateCursor(props) {\n      if (this._isTranslatable) {\n        props.onUpdateCursor('move');\n      } else {\n        props.onUpdateCursor(null);\n      }\n    }\n  }, {\n    key: \"getTranslateAction\",\n    value: function getTranslateAction(startDragPoint, currentPoint, editType, props) {\n      if (!this._geometryBeforeTranslate) {\n        return null;\n      }\n\n      var p1 = (0, _helpers.point)(startDragPoint);\n      var p2 = (0, _helpers.point)(currentPoint);\n      var distanceMoved = (0, _distance[\"default\"])(p1, p2);\n      var direction = (0, _bearing[\"default\"])(p1, p2);\n      var movedFeatures = (0, _transformTranslate[\"default\"])( // @ts-ignore\n      this._geometryBeforeTranslate, distanceMoved, direction);\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n      var selectedIndexes = props.selectedIndexes;\n\n      for (var i = 0; i < selectedIndexes.length; i++) {\n        var selectedIndex = selectedIndexes[i];\n        var movedFeature = movedFeatures.features[i];\n        updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n      }\n\n      return {\n        updatedData: updatedData.getObject(),\n        editType: editType,\n        editContext: {\n          featureIndexes: selectedIndexes\n        }\n      };\n    }\n  }]);\n\n  return TranslateMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.TranslateMode = TranslateMode;","map":{"version":3,"sources":["../../src/lib/translate-mode.ts"],"names":["TranslateMode","GeoJsonEditMode","event","props","editAction","startDragPoint","currentPoint","editType","p1","p2","distanceMoved","direction","movedFeatures","updatedData","ImmutableFeatureCollection","selectedIndexes","i","selectedIndex","movedFeature","editContext","featureIndexes"],"mappings":"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","sourcesContent":["import turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfTransformTranslate from '@turf/transform-translate';\nimport { point } from '@turf/helpers';\nimport { FeatureCollection, Position } from '../geojson-types';\nimport {\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  ModeProps,\n} from '../types';\nimport { GeoJsonEditMode, GeoJsonEditAction } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class TranslateMode extends GeoJsonEditMode {\n  _geometryBeforeTranslate: FeatureCollection | null | undefined;\n  _isTranslatable: boolean;\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isTranslatable) {\n      // Nothing to do\n      return;\n    }\n\n    if (this._geometryBeforeTranslate) {\n      // Translate the geometry\n      const editAction = this.getTranslateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'translating',\n        props\n      );\n\n      if (editAction) {\n        props.onEdit(editAction);\n      }\n    }\n\n    // cancel map panning\n    event.cancelPan();\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    this._isTranslatable = this.isSelectionPicked(event.pointerDownPicks || event.picks, props);\n\n    this.updateCursor(props);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isTranslatable) {\n      return;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection(props);\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._geometryBeforeTranslate) {\n      // Translate the geometry\n      const editAction = this.getTranslateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'translated',\n        props\n      );\n\n      if (editAction) {\n        props.onEdit(editAction);\n      }\n\n      this._geometryBeforeTranslate = null;\n    }\n  }\n\n  updateCursor(props: ModeProps<FeatureCollection>) {\n    if (this._isTranslatable) {\n      props.onUpdateCursor('move');\n    } else {\n      props.onUpdateCursor(null);\n    }\n  }\n\n  getTranslateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ): GeoJsonEditAction | null | undefined {\n    if (!this._geometryBeforeTranslate) {\n      return null;\n    }\n    const p1 = point(startDragPoint);\n    const p2 = point(currentPoint);\n\n    const distanceMoved = turfDistance(p1, p2);\n    const direction = turfBearing(p1, p2);\n\n    const movedFeatures = turfTransformTranslate(\n      // @ts-ignore\n      this._geometryBeforeTranslate,\n      distanceMoved,\n      direction\n    );\n\n    let updatedData = new ImmutableFeatureCollection(props.data);\n\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = movedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      editContext: {\n        featureIndexes: selectedIndexes,\n      },\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}