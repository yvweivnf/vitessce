{"ast":null,"code":"import { Schema, Field, FixedSizeList } from '../../lib/schema/schema';\nimport { getArrowTypeFromTypedArray } from '../../lib/arrow/arrow-like-type-utils';\nexport function deduceMeshSchema(attributes, metadata) {\n  const fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\nexport function deduceMeshField(attributeName, attribute, optionalMetadata) {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field('value', type)), false, metadata);\n  return field;\n}\n\nfunction deduceMeshFields(attributes) {\n  const fields = [];\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n\n  return fields;\n}\n\nexport function makeMeshAttributeMetadata(attribute) {\n  const result = new Map();\n\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset.toString(10));\n  }\n\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride.toString(10));\n  }\n\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized.toString());\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../../../src/category/mesh/deduce-mesh-schema.ts"],"names":["fields","deduceMeshFields","type","getArrowTypeFromTypedArray","attribute","metadata","optionalMetadata","makeMeshAttributeMetadata","field","attributes","deduceMeshField","result"],"mappings":"AACA,SAAA,MAAA,EAAA,KAAA,EAAA,aAAA,QAAA,yBAAA;AACA,SAAA,0BAAA,QAAA,uCAAA;AAQA,OAAO,SAAA,gBAAA,CAAA,UAAA,EAAA,QAAA,EAGG;AACR,QAAMA,MAAM,GAAGC,gBAAgB,CAA/B,UAA+B,CAA/B;AACA,SAAO,IAAA,MAAA,CAAA,MAAA,EAAP,QAAO,CAAP;AACD;AASD,OAAO,SAAA,eAAA,CAAA,aAAA,EAAA,SAAA,EAAA,gBAAA,EAIE;AACP,QAAMC,IAAI,GAAGC,0BAA0B,CAACC,SAAS,CAAjD,KAAuC,CAAvC;AACA,QAAMC,QAAQ,GAAGC,gBAAgB,GAAA,gBAAA,GAAsBC,yBAAyB,CAAhF,SAAgF,CAAhF;AACA,QAAMC,KAAK,GAAG,IAAA,KAAA,CAAA,aAAA,EAEZ,IAAA,aAAA,CAAkBJ,SAAS,CAA3B,IAAA,EAAkC,IAAA,KAAA,CAAA,OAAA,EAFtB,IAEsB,CAAlC,CAFY,EAAA,KAAA,EAAd,QAAc,CAAd;AAMA,SAAA,KAAA;AACD;;AAOD,SAAA,gBAAA,CAAA,UAAA,EAA+D;AAC7D,QAAMJ,MAAe,GAArB,EAAA;;AACA,OAAK,MAAL,aAAA,IAAA,UAAA,EAAwC;AACtC,UAAMI,SAAwB,GAAGK,UAAU,CAA3C,aAA2C,CAA3C;AACAT,IAAAA,MAAM,CAANA,IAAAA,CAAYU,eAAe,CAAA,aAAA,EAA3BV,SAA2B,CAA3BA;AACD;;AACD,SAAA,MAAA;AACD;;AAOD,OAAO,SAAA,yBAAA,CAAA,SAAA,EAAkF;AACvF,QAAMW,MAAM,GAAG,IAAf,GAAe,EAAf;;AACA,MAAI,gBAAJ,SAAA,EAA+B;AAC7BA,IAAAA,MAAM,CAANA,GAAAA,CAAAA,YAAAA,EAAyBP,SAAS,CAATA,UAAAA,CAAAA,QAAAA,CAAzBO,EAAyBP,CAAzBO;AACD;;AACD,MAAI,gBAAJ,SAAA,EAA+B;AAC7BA,IAAAA,MAAM,CAANA,GAAAA,CAAAA,YAAAA,EAAyBP,SAAS,CAATA,UAAAA,CAAAA,QAAAA,CAAzBO,EAAyBP,CAAzBO;AACD;;AACD,MAAI,gBAAJ,SAAA,EAA+B;AAC7BA,IAAAA,MAAM,CAANA,GAAAA,CAAAA,YAAAA,EAAyBP,SAAS,CAATA,UAAAA,CAAzBO,QAAyBP,EAAzBO;AACD;;AACD,SAAA,MAAA;AACD","sourcesContent":["import {MeshAttribute, MeshAttributes} from './mesh-types';\nimport {Schema, Field, FixedSizeList} from '../../lib/schema/schema';\nimport {getArrowTypeFromTypedArray} from '../../lib/arrow/arrow-like-type-utils';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata?: Map<string, string>\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  attributeName: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Map<string, string>\n): Field {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadata\n  );\n  return field;\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Map<string, string> {\n  const result = new Map();\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset!.toString(10));\n  }\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride!.toString(10));\n  }\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized!.toString());\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}