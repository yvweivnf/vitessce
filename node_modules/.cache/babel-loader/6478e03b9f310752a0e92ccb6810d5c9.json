{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray } from 'vega';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport class SelectionCompatibilityNormalizer extends SpecMapper {\n  map(spec, normParams) {\n    var _a, _b;\n\n    (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : normParams.emptySelections = {};\n    (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : normParams.selectionPredicates = {};\n    spec = normalizeTransforms(spec, normParams);\n    return super.map(spec, normParams);\n  }\n\n  mapLayerOrUnit(spec, normParams) {\n    spec = normalizeTransforms(spec, normParams);\n\n    if (spec.encoding) {\n      const encoding = {};\n\n      for (const [channel, enc] of entries(spec.encoding)) {\n        encoding[channel] = normalizeChannelDef(enc, normParams);\n      }\n\n      spec = Object.assign(Object.assign({}, spec), {\n        encoding\n      });\n    }\n\n    return super.mapLayerOrUnit(spec, normParams);\n  }\n\n  mapUnit(spec, normParams) {\n    const _a = spec,\n          {\n      selection\n    } = _a,\n          rest = __rest(_a, [\"selection\"]);\n\n    if (selection) {\n      return Object.assign(Object.assign({}, rest), {\n        params: entries(selection).map(([name, selDef]) => {\n          var _a;\n\n          const _b = selDef,\n                {\n            init: value,\n            bind,\n            empty\n          } = _b,\n                select = __rest(_b, [\"init\", \"bind\", \"empty\"]);\n\n          if (select.type === 'single') {\n            select.type = 'point';\n            select.toggle = false;\n          } else if (select.type === 'multi') {\n            select.type = 'point';\n          } // Propagate emptiness forwards and backwards\n\n\n          normParams.emptySelections[name] = empty !== 'none';\n\n          for (const pred of vals((_a = normParams.selectionPredicates[name]) !== null && _a !== void 0 ? _a : {})) {\n            pred.empty = empty !== 'none';\n          }\n\n          return {\n            name,\n            value,\n            select,\n            bind\n          };\n        })\n      });\n    }\n\n    return spec;\n  }\n\n}\n\nfunction normalizeTransforms(spec, normParams) {\n  const {\n    transform: tx\n  } = spec,\n        rest = __rest(spec, [\"transform\"]);\n\n  if (tx) {\n    const transform = tx.map(t => {\n      if (isFilter(t)) {\n        return {\n          filter: normalizePredicate(t, normParams)\n        };\n      } else if (isBin(t) && isBinParams(t.bin)) {\n        return Object.assign(Object.assign({}, t), {\n          bin: normalizeBinExtent(t.bin)\n        });\n      } else if (isLookup(t)) {\n        const _a = t.from,\n              {\n          selection: param\n        } = _a,\n              from = __rest(_a, [\"selection\"]);\n\n        return param ? Object.assign(Object.assign({}, t), {\n          from: Object.assign({\n            param\n          }, from)\n        }) : t;\n      }\n\n      return t;\n    });\n    return Object.assign(Object.assign({}, rest), {\n      transform\n    });\n  }\n\n  return spec;\n}\n\nfunction normalizeChannelDef(obj, normParams) {\n  var _a, _b;\n\n  const enc = duplicate(obj);\n\n  if (isFieldDef(enc) && isBinParams(enc.bin)) {\n    enc.bin = normalizeBinExtent(enc.bin);\n  }\n\n  if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {\n    const _c = enc.scale.domain,\n          {\n      selection: param\n    } = _c,\n          domain = __rest(_c, [\"selection\"]);\n\n    enc.scale.domain = Object.assign(Object.assign({}, domain), param ? {\n      param\n    } : {});\n  }\n\n  if (isConditionalDef(enc)) {\n    if (isArray(enc.condition)) {\n      enc.condition = enc.condition.map(c => {\n        const {\n          selection,\n          param,\n          test\n        } = c,\n              cond = __rest(c, [\"selection\", \"param\", \"test\"]);\n\n        return param ? c : Object.assign(Object.assign({}, cond), {\n          test: normalizePredicate(c, normParams)\n        });\n      });\n    } else {\n      const _d = normalizeChannelDef(enc.condition, normParams),\n            {\n        selection,\n        param,\n        test\n      } = _d,\n            cond = __rest(_d, [\"selection\", \"param\", \"test\"]);\n\n      enc.condition = param ? enc.condition : Object.assign(Object.assign({}, cond), {\n        test: normalizePredicate(enc.condition, normParams)\n      });\n    }\n  }\n\n  return enc;\n}\n\nfunction normalizeBinExtent(bin) {\n  const ext = bin.extent;\n\n  if (ext === null || ext === void 0 ? void 0 : ext.selection) {\n    const {\n      selection: param\n    } = ext,\n          rest = __rest(ext, [\"selection\"]);\n\n    return Object.assign(Object.assign({}, bin), {\n      extent: Object.assign(Object.assign({}, rest), {\n        param\n      })\n    });\n  }\n\n  return bin;\n}\n\nfunction normalizePredicate(op, normParams) {\n  // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n  const normalizeSelectionComposition = o => {\n    return normalizeLogicalComposition(o, param => {\n      var _a, _b;\n\n      var _c;\n\n      const empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;\n      const pred = {\n        param,\n        empty\n      };\n      (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : _c[param] = [];\n      normParams.selectionPredicates[param].push(pred);\n      return pred;\n    });\n  };\n\n  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, o => o.selection ? normalizeSelectionComposition(o.selection) : o);\n}","map":{"version":3,"sources":["../../../src/normalize/selectioncompat.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray } from 'vega';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport class SelectionCompatibilityNormalizer extends SpecMapper {\n    map(spec, normParams) {\n        var _a, _b;\n        (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : (normParams.emptySelections = {});\n        (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : (normParams.selectionPredicates = {});\n        spec = normalizeTransforms(spec, normParams);\n        return super.map(spec, normParams);\n    }\n    mapLayerOrUnit(spec, normParams) {\n        spec = normalizeTransforms(spec, normParams);\n        if (spec.encoding) {\n            const encoding = {};\n            for (const [channel, enc] of entries(spec.encoding)) {\n                encoding[channel] = normalizeChannelDef(enc, normParams);\n            }\n            spec = Object.assign(Object.assign({}, spec), { encoding });\n        }\n        return super.mapLayerOrUnit(spec, normParams);\n    }\n    mapUnit(spec, normParams) {\n        const _a = spec, { selection } = _a, rest = __rest(_a, [\"selection\"]);\n        if (selection) {\n            return Object.assign(Object.assign({}, rest), { params: entries(selection).map(([name, selDef]) => {\n                    var _a;\n                    const _b = selDef, { init: value, bind, empty } = _b, select = __rest(_b, [\"init\", \"bind\", \"empty\"]);\n                    if (select.type === 'single') {\n                        select.type = 'point';\n                        select.toggle = false;\n                    }\n                    else if (select.type === 'multi') {\n                        select.type = 'point';\n                    }\n                    // Propagate emptiness forwards and backwards\n                    normParams.emptySelections[name] = empty !== 'none';\n                    for (const pred of vals((_a = normParams.selectionPredicates[name]) !== null && _a !== void 0 ? _a : {})) {\n                        pred.empty = empty !== 'none';\n                    }\n                    return { name, value, select, bind };\n                }) });\n        }\n        return spec;\n    }\n}\nfunction normalizeTransforms(spec, normParams) {\n    const { transform: tx } = spec, rest = __rest(spec, [\"transform\"]);\n    if (tx) {\n        const transform = tx.map((t) => {\n            if (isFilter(t)) {\n                return { filter: normalizePredicate(t, normParams) };\n            }\n            else if (isBin(t) && isBinParams(t.bin)) {\n                return Object.assign(Object.assign({}, t), { bin: normalizeBinExtent(t.bin) });\n            }\n            else if (isLookup(t)) {\n                const _a = t.from, { selection: param } = _a, from = __rest(_a, [\"selection\"]);\n                return param\n                    ? Object.assign(Object.assign({}, t), { from: Object.assign({ param }, from) }) : t;\n            }\n            return t;\n        });\n        return Object.assign(Object.assign({}, rest), { transform });\n    }\n    return spec;\n}\nfunction normalizeChannelDef(obj, normParams) {\n    var _a, _b;\n    const enc = duplicate(obj);\n    if (isFieldDef(enc) && isBinParams(enc.bin)) {\n        enc.bin = normalizeBinExtent(enc.bin);\n    }\n    if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {\n        const _c = enc.scale.domain, { selection: param } = _c, domain = __rest(_c, [\"selection\"]);\n        enc.scale.domain = Object.assign(Object.assign({}, domain), (param ? { param } : {}));\n    }\n    if (isConditionalDef(enc)) {\n        if (isArray(enc.condition)) {\n            enc.condition = enc.condition.map((c) => {\n                const { selection, param, test } = c, cond = __rest(c, [\"selection\", \"param\", \"test\"]);\n                return param ? c : Object.assign(Object.assign({}, cond), { test: normalizePredicate(c, normParams) });\n            });\n        }\n        else {\n            const _d = normalizeChannelDef(enc.condition, normParams), { selection, param, test } = _d, cond = __rest(_d, [\"selection\", \"param\", \"test\"]);\n            enc.condition = param\n                ? enc.condition\n                : Object.assign(Object.assign({}, cond), { test: normalizePredicate(enc.condition, normParams) });\n        }\n    }\n    return enc;\n}\nfunction normalizeBinExtent(bin) {\n    const ext = bin.extent;\n    if (ext === null || ext === void 0 ? void 0 : ext.selection) {\n        const { selection: param } = ext, rest = __rest(ext, [\"selection\"]);\n        return Object.assign(Object.assign({}, bin), { extent: Object.assign(Object.assign({}, rest), { param }) });\n    }\n    return bin;\n}\nfunction normalizePredicate(op, normParams) {\n    // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n    const normalizeSelectionComposition = (o) => {\n        return normalizeLogicalComposition(o, param => {\n            var _a, _b;\n            var _c;\n            const empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;\n            const pred = { param, empty };\n            (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : (_c[param] = []);\n            normParams.selectionPredicates[param].push(pred);\n            return pred;\n        });\n    };\n    return op.selection\n        ? normalizeSelectionComposition(op.selection)\n        : normalizeLogicalComposition(op.test || op.filter, o => o.selection ? normalizeSelectionComposition(o.selection) : o);\n}\n//# sourceMappingURL=selectioncompat.js.map"]},"metadata":{},"sourceType":"module"}