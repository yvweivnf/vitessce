{"ast":null,"code":"import * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\n\nexport class DataFlowNode {\n  constructor(parent, debugName) {\n    this.debugName = debugName;\n    this._children = [];\n    this._parent = null;\n\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n\n\n  clone() {\n    throw new Error('Cannot clone node');\n  }\n\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * Set the parent of the node and also add this node to the parent's children.\n   */\n\n\n  set parent(parent) {\n    this._parent = parent;\n\n    if (parent) {\n      parent.addChild(this);\n    }\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  numChildren() {\n    return this._children.length;\n  }\n\n  addChild(child, loc) {\n    // do not add the same child twice\n    if (this._children.includes(child)) {\n      log.warn(log.message.ADD_SAME_CHILD_TWICE);\n      return;\n    }\n\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n\n  removeChild(oldChild) {\n    const loc = this._children.indexOf(oldChild);\n\n    this._children.splice(loc, 1);\n\n    return loc;\n  }\n  /**\n   * Remove node from the dataflow.\n   */\n\n\n  remove() {\n    let loc = this._parent.removeChild(this);\n\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n\n      this._parent.addChild(child, loc++);\n    }\n  }\n  /**\n   * Insert another node as a parent of this node.\n   */\n\n\n  insertAsParentOf(other) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n\n  swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent; // reconnect the children\n\n    for (const child of this._children) {\n      child.parent = parent;\n    } // remove old links\n\n\n    this._children = []; // equivalent to removing every child link one by one\n\n    parent.removeChild(this);\n    parent.parent.removeChild(parent); // swap two nodes\n\n    this.parent = newParent;\n    parent.parent = this;\n  }\n\n}\nexport class OutputNode extends DataFlowNode {\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(parent, source, type, refCounts) {\n    super(parent, source);\n    this.type = type;\n    this.refCounts = refCounts;\n    this._source = this._name = source;\n\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n\n  clone() {\n    const cloneObj = new this.constructor();\n    cloneObj.debugName = `clone_${this.debugName}`;\n    cloneObj._source = this._source;\n    cloneObj._name = `clone_${this._name}`;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n\n  dependentFields() {\n    return new Set();\n  }\n\n  producedFields() {\n    return new Set();\n  }\n\n  hash() {\n    if (this._hash === undefined) {\n      this._hash = `Output ${uniqueId()}`;\n    }\n\n    return this._hash;\n  }\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n\n\n  getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n\n  isRequired() {\n    return !!this.refCounts[this._name];\n  }\n\n  setSource(source) {\n    this._source = source;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/dataflow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\nexport class DataFlowNode {\n    constructor(parent, debugName) {\n        this.debugName = debugName;\n        this._children = [];\n        this._parent = null;\n        if (parent) {\n            this.parent = parent;\n        }\n    }\n    /**\n     * Clone this node with a deep copy but don't clone links to children or parents.\n     */\n    clone() {\n        throw new Error('Cannot clone node');\n    }\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Set the parent of the node and also add this node to the parent's children.\n     */\n    set parent(parent) {\n        this._parent = parent;\n        if (parent) {\n            parent.addChild(this);\n        }\n    }\n    get children() {\n        return this._children;\n    }\n    numChildren() {\n        return this._children.length;\n    }\n    addChild(child, loc) {\n        // do not add the same child twice\n        if (this._children.includes(child)) {\n            log.warn(log.message.ADD_SAME_CHILD_TWICE);\n            return;\n        }\n        if (loc !== undefined) {\n            this._children.splice(loc, 0, child);\n        }\n        else {\n            this._children.push(child);\n        }\n    }\n    removeChild(oldChild) {\n        const loc = this._children.indexOf(oldChild);\n        this._children.splice(loc, 1);\n        return loc;\n    }\n    /**\n     * Remove node from the dataflow.\n     */\n    remove() {\n        let loc = this._parent.removeChild(this);\n        for (const child of this._children) {\n            // do not use the set method because we want to insert at a particular location\n            child._parent = this._parent;\n            this._parent.addChild(child, loc++);\n        }\n    }\n    /**\n     * Insert another node as a parent of this node.\n     */\n    insertAsParentOf(other) {\n        const parent = other.parent;\n        parent.removeChild(this);\n        this.parent = parent;\n        other.parent = this;\n    }\n    swapWithParent() {\n        const parent = this._parent;\n        const newParent = parent.parent;\n        // reconnect the children\n        for (const child of this._children) {\n            child.parent = parent;\n        }\n        // remove old links\n        this._children = []; // equivalent to removing every child link one by one\n        parent.removeChild(this);\n        parent.parent.removeChild(parent);\n        // swap two nodes\n        this.parent = newParent;\n        parent.parent = this;\n    }\n}\nexport class OutputNode extends DataFlowNode {\n    /**\n     * @param source The name of the source. Will change in assemble.\n     * @param type The type of the output node.\n     * @param refCounts A global ref counter map.\n     */\n    constructor(parent, source, type, refCounts) {\n        super(parent, source);\n        this.type = type;\n        this.refCounts = refCounts;\n        this._source = this._name = source;\n        if (this.refCounts && !(this._name in this.refCounts)) {\n            this.refCounts[this._name] = 0;\n        }\n    }\n    clone() {\n        const cloneObj = new this.constructor();\n        cloneObj.debugName = `clone_${this.debugName}`;\n        cloneObj._source = this._source;\n        cloneObj._name = `clone_${this._name}`;\n        cloneObj.type = this.type;\n        cloneObj.refCounts = this.refCounts;\n        cloneObj.refCounts[cloneObj._name] = 0;\n        return cloneObj;\n    }\n    dependentFields() {\n        return new Set();\n    }\n    producedFields() {\n        return new Set();\n    }\n    hash() {\n        if (this._hash === undefined) {\n            this._hash = `Output ${uniqueId()}`;\n        }\n        return this._hash;\n    }\n    /**\n     * Request the datasource name and increase the ref counter.\n     *\n     * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n     * It is crucial to request the name from an output node to mark it as a required node.\n     * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n     *\n     * In the assemble phase, this will return the correct name.\n     */\n    getSource() {\n        this.refCounts[this._name]++;\n        return this._source;\n    }\n    isRequired() {\n        return !!this.refCounts[this._name];\n    }\n    setSource(source) {\n        this._source = source;\n    }\n}\n//# sourceMappingURL=dataflow.js.map"]},"metadata":{},"sourceType":"module"}