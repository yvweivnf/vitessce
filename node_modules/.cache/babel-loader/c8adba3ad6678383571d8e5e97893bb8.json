{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\src\\\\components\\\\layer-controller\\\\RasterChannelController.js\";\nimport React, { useCallback, useState, useEffect } from 'react';\nimport Grid from '@material-ui/core/Grid';\nimport Slider from '@material-ui/core/Slider';\nimport debounce from 'lodash/debounce';\nimport isEqual from 'lodash/isEqual';\nimport ChannelOptions from './ChannelOptions';\nimport { DOMAINS } from './constants';\nimport { getSourceFromLoader } from '../../utils';\nimport { getMultiSelectionStats } from './utils';\nimport { ChannelSelectionDropdown, ChannelVisibilityCheckbox } from './shared-channel-controls'; // Returns an rgb string for display, and changes the color (arr)\n// to use a grey for light theme + white color or if the colormap is on.\n\nexport const toRgbUIString = (on, arr, theme) => {\n  const color = on || theme === 'light' && arr.every(i => i === 255) ? [220, 220, 220] : arr;\n  return `rgb(${color})`;\n};\n\nfunction abbreviateNumber(value) {\n  // Return an abbreviated representation of value, in 5 characters or less.\n  const maxLength = 5;\n  let maxNaiveDigits = maxLength;\n  /* eslint-disable no-plusplus */\n\n  if (!Number.isInteger(value)) {\n    --maxNaiveDigits;\n  } // Wasted on \".\"\n\n\n  if (value < 1) {\n    --maxNaiveDigits;\n  } // Wasted on \"0.\"\n\n  /* eslint-disable no-plusplus */\n\n\n  const naive = Intl.NumberFormat('en-US', {\n    maximumSignificantDigits: maxNaiveDigits,\n    useGrouping: false\n  }).format(value);\n  if (naive.length <= maxLength) return naive; // \"e+9\" consumes 3 characters, so if we even had two significant digits,\n  // it would take take us to six characters, including the decimal point.\n\n  return value.toExponential(0);\n}\n/**\n * Slider for controlling current colormap.\n * @prop {string} color Current color for this channel.\n * @prop {arry} slider Current value of the slider.\n * @prop {function} handleChange Callback for each slider change.\n * @prop {array} domain Current max/min allowable slider values.\n */\n\n\nfunction ChannelSlider({\n  color,\n  slider = [0, 0],\n  handleChange,\n  domain = [0, 0],\n  dtype,\n  disabled\n}) {\n  const [min, max] = domain;\n  const sliderCopy = slider.slice();\n\n  if (slider[0] < min) {\n    sliderCopy[0] = min;\n  }\n\n  if (slider[1] > max) {\n    sliderCopy[1] = max;\n  }\n\n  const handleChangeDebounced = useCallback(debounce(handleChange, 3, {\n    trailing: true\n  }), [handleChange]);\n  const step = max - min < 500 && dtype === 'Float32' ? (max - min) / 500 : 1;\n  return /*#__PURE__*/React.createElement(Slider, {\n    value: slider,\n    valueLabelFormat: abbreviateNumber,\n    onChange: (e, v) => handleChangeDebounced(v),\n    valueLabelDisplay: \"auto\",\n    getAriaLabel: () => `${color}-${slider}`,\n    min: min,\n    max: max,\n    step: step,\n    orientation: \"horizontal\",\n    style: {\n      color,\n      marginTop: '7px'\n    },\n    disabled: disabled,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 5\n    }\n  });\n}\n/**\n * Controller for the handling the colormapping sliders.\n * @prop {boolean} visibility Whether or not this channel is \"on\"\n * @prop {array} slider Current slider range.\n * @prop {array} color Current color for this channel.\n * @prop {array} domain Current max/min for this channel.\n * @prop {string} dimName Name of the dimensions this slider controls (usually \"channel\").\n * @prop {boolean} colormapOn Whether or not the colormap (viridis, magma etc.) is on.\n * @prop {object} channelOptions All available options for this dimension (i.e channel names).\n * @prop {function} handlePropertyChange Callback for when a property (color, slider etc.) changes.\n * @prop {function} handleChannelRemove When a channel is removed, this is called.\n * @prop {function} handleIQRUpdate When the IQR button is clicked, this is called.\n * @prop {number} selectionIndex The current numeric index of the selection.\n */\n\n\nfunction RasterChannelController({\n  visibility = false,\n  slider,\n  color,\n  channels,\n  channelId,\n  domainType: newDomainType,\n  dimName,\n  theme,\n  loader,\n  colormapOn,\n  channelOptions,\n  handlePropertyChange,\n  handleChannelRemove,\n  handleIQRUpdate,\n  selectionIndex,\n  isLoading,\n  use3d: newUse3d\n}) {\n  const {\n    dtype\n  } = getSourceFromLoader(loader);\n  const [domain, setDomain] = useState(null);\n  const [domainType, setDomainType] = useState(null);\n  const [use3d, setUse3d] = useState(null);\n  const [selection, setSelection] = useState([{ ...channels[channelId].selection\n  }]);\n  const rgbColor = toRgbUIString(colormapOn, color, theme);\n  useEffect(() => {\n    // Use mounted to prevent state updates/re-renders after the component has been unmounted.\n    // All state updates should happen within the mounted check.\n    let mounted = true;\n\n    if (dtype && loader && channels) {\n      const selections = [{ ...channels[channelId].selection\n      }];\n      let domains;\n      const hasDomainChanged = newDomainType !== domainType;\n      const has3dChanged = use3d !== newUse3d;\n      const hasSelectionChanged = !isEqual(selections, selection);\n\n      if (hasDomainChanged || hasSelectionChanged || has3dChanged) {\n        if (newDomainType === 'Full') {\n          domains = [DOMAINS[dtype]];\n          const [newDomain] = domains;\n\n          if (mounted) {\n            setDomain(newDomain);\n            setDomainType(newDomainType);\n\n            if (hasSelectionChanged) {\n              setSelection(selections);\n            }\n\n            if (has3dChanged) {\n              setUse3d(newUse3d);\n            }\n          }\n        } else {\n          getMultiSelectionStats({\n            loader: loader.data,\n            selections,\n            use3d: newUse3d\n          }).then(stats => {\n            // eslint-disable-next-line prefer-destructuring\n            domains = stats.domains;\n            const [newDomain] = domains;\n\n            if (mounted) {\n              setDomain(newDomain);\n              setDomainType(newDomainType);\n\n              if (hasSelectionChanged) {\n                setSelection(selections);\n              }\n\n              if (has3dChanged) {\n                setUse3d(newUse3d);\n              }\n            }\n          });\n        }\n      }\n    }\n\n    return () => {\n      mounted = false;\n    };\n  }, [domainType, channels, channelId, loader, dtype, newDomainType, selection, newUse3d, use3d]);\n  /* A valid selection is defined by an object where the keys are\n   *  the name of a dimension of the data, and the values are the\n   *  index of the image along that particular dimension.\n   *\n   *  Since we currently only support making a selection along one\n   *  addtional dimension (i.e. the dropdown just has channels or mz)\n   *  we have a helper function to create the selection.\n   *\n   *  e.g { channel: 2 } // channel dimension, third channel\n   */\n\n  const createSelection = index => ({\n    [dimName]: index\n  });\n\n  return /*#__PURE__*/React.createElement(Grid, {\n    container: true,\n    direction: \"column\",\n    m: 1,\n    justifyContent: \"center\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(Grid, {\n    container: true,\n    direction: \"row\",\n    justifyContent: \"space-between\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(Grid, {\n    item: true,\n    xs: 10,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(ChannelSelectionDropdown, {\n    handleChange: v => handlePropertyChange('selection', createSelection(v)),\n    selectionIndex: selectionIndex,\n    channelOptions: channelOptions,\n    disabled: isLoading,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 11\n    }\n  })), /*#__PURE__*/React.createElement(Grid, {\n    item: true,\n    xs: 1,\n    style: {\n      marginTop: '4px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 223,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(ChannelOptions, {\n    handlePropertyChange: handlePropertyChange,\n    handleChannelRemove: handleChannelRemove,\n    handleIQRUpdate: handleIQRUpdate,\n    disabled: isLoading,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 11\n    }\n  }))), /*#__PURE__*/React.createElement(Grid, {\n    container: true,\n    direction: \"row\",\n    justifyContent: \"space-between\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 232,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(Grid, {\n    item: true,\n    xs: 2,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(ChannelVisibilityCheckbox, {\n    color: rgbColor,\n    checked: visibility,\n    toggle: () => handlePropertyChange('visible', !visibility),\n    disabled: isLoading,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 234,\n      columnNumber: 11\n    }\n  })), /*#__PURE__*/React.createElement(Grid, {\n    item: true,\n    xs: 9,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 241,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(ChannelSlider, {\n    color: rgbColor,\n    slider: slider,\n    domain: domain || DOMAINS[dtype],\n    dtype: dtype,\n    handleChange: v => handlePropertyChange('slider', v),\n    disabled: isLoading,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 242,\n      columnNumber: 11\n    }\n  }))));\n}\n\nexport default RasterChannelController;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/layer-controller/RasterChannelController.js"],"names":["React","useCallback","useState","useEffect","Grid","Slider","debounce","isEqual","ChannelOptions","DOMAINS","getSourceFromLoader","getMultiSelectionStats","ChannelSelectionDropdown","ChannelVisibilityCheckbox","toRgbUIString","on","arr","theme","color","every","i","abbreviateNumber","value","maxLength","maxNaiveDigits","Number","isInteger","naive","Intl","NumberFormat","maximumSignificantDigits","useGrouping","format","length","toExponential","ChannelSlider","slider","handleChange","domain","dtype","disabled","min","max","sliderCopy","slice","handleChangeDebounced","trailing","step","e","v","marginTop","RasterChannelController","visibility","channels","channelId","domainType","newDomainType","dimName","loader","colormapOn","channelOptions","handlePropertyChange","handleChannelRemove","handleIQRUpdate","selectionIndex","isLoading","use3d","newUse3d","setDomain","setDomainType","setUse3d","selection","setSelection","rgbColor","mounted","selections","domains","hasDomainChanged","has3dChanged","hasSelectionChanged","newDomain","data","then","stats","createSelection","index"],"mappings":"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","sourcesContent":["import React, { useCallback, useState, useEffect } from 'react';\n\nimport Grid from '@material-ui/core/Grid';\nimport Slider from '@material-ui/core/Slider';\nimport debounce from 'lodash/debounce';\nimport isEqual from 'lodash/isEqual';\n\nimport ChannelOptions from './ChannelOptions';\nimport { DOMAINS } from './constants';\nimport { getSourceFromLoader } from '../../utils';\nimport { getMultiSelectionStats } from './utils';\nimport {\n  ChannelSelectionDropdown,\n  ChannelVisibilityCheckbox,\n} from './shared-channel-controls';\n\n// Returns an rgb string for display, and changes the color (arr)\n// to use a grey for light theme + white color or if the colormap is on.\nexport const toRgbUIString = (on, arr, theme) => {\n  const color = on || (theme === 'light' && arr.every(i => i === 255))\n    ? [220, 220, 220]\n    : arr;\n  return `rgb(${color})`;\n};\n\nfunction abbreviateNumber(value) {\n  // Return an abbreviated representation of value, in 5 characters or less.\n\n  const maxLength = 5;\n  let maxNaiveDigits = maxLength;\n\n  /* eslint-disable no-plusplus */\n  if (!Number.isInteger(value)) {\n    --maxNaiveDigits;\n  } // Wasted on \".\"\n  if (value < 1) {\n    --maxNaiveDigits;\n  } // Wasted on \"0.\"\n  /* eslint-disable no-plusplus */\n\n  const naive = Intl.NumberFormat('en-US', {\n    maximumSignificantDigits: maxNaiveDigits,\n    useGrouping: false,\n  }).format(value);\n  if (naive.length <= maxLength) return naive;\n\n  // \"e+9\" consumes 3 characters, so if we even had two significant digits,\n  // it would take take us to six characters, including the decimal point.\n  return value.toExponential(0);\n}\n\n/**\n * Slider for controlling current colormap.\n * @prop {string} color Current color for this channel.\n * @prop {arry} slider Current value of the slider.\n * @prop {function} handleChange Callback for each slider change.\n * @prop {array} domain Current max/min allowable slider values.\n */\nfunction ChannelSlider({\n  color,\n  slider = [0, 0],\n  handleChange,\n  domain = [0, 0],\n  dtype,\n  disabled,\n}) {\n  const [min, max] = domain;\n  const sliderCopy = slider.slice();\n  if (slider[0] < min) {\n    sliderCopy[0] = min;\n  }\n  if (slider[1] > max) {\n    sliderCopy[1] = max;\n  }\n  const handleChangeDebounced = useCallback(\n    debounce(handleChange, 3, { trailing: true }),\n    [handleChange],\n  );\n  const step = max - min < 500 && dtype === 'Float32' ? (max - min) / 500 : 1;\n  return (\n    <Slider\n      value={slider}\n      valueLabelFormat={abbreviateNumber}\n      onChange={(e, v) => handleChangeDebounced(v)}\n      valueLabelDisplay=\"auto\"\n      getAriaLabel={() => `${color}-${slider}`}\n      min={min}\n      max={max}\n      step={step}\n      orientation=\"horizontal\"\n      style={{ color, marginTop: '7px' }}\n      disabled={disabled}\n    />\n  );\n}\n\n/**\n * Controller for the handling the colormapping sliders.\n * @prop {boolean} visibility Whether or not this channel is \"on\"\n * @prop {array} slider Current slider range.\n * @prop {array} color Current color for this channel.\n * @prop {array} domain Current max/min for this channel.\n * @prop {string} dimName Name of the dimensions this slider controls (usually \"channel\").\n * @prop {boolean} colormapOn Whether or not the colormap (viridis, magma etc.) is on.\n * @prop {object} channelOptions All available options for this dimension (i.e channel names).\n * @prop {function} handlePropertyChange Callback for when a property (color, slider etc.) changes.\n * @prop {function} handleChannelRemove When a channel is removed, this is called.\n * @prop {function} handleIQRUpdate When the IQR button is clicked, this is called.\n * @prop {number} selectionIndex The current numeric index of the selection.\n */\nfunction RasterChannelController({\n  visibility = false,\n  slider,\n  color,\n  channels,\n  channelId,\n  domainType: newDomainType,\n  dimName,\n  theme,\n  loader,\n  colormapOn,\n  channelOptions,\n  handlePropertyChange,\n  handleChannelRemove,\n  handleIQRUpdate,\n  selectionIndex,\n  isLoading,\n  use3d: newUse3d,\n}) {\n  const { dtype } = getSourceFromLoader(loader);\n  const [domain, setDomain] = useState(null);\n  const [domainType, setDomainType] = useState(null);\n  const [use3d, setUse3d] = useState(null);\n  const [selection, setSelection] = useState([\n    { ...channels[channelId].selection },\n  ]);\n  const rgbColor = toRgbUIString(colormapOn, color, theme);\n\n  useEffect(() => {\n    // Use mounted to prevent state updates/re-renders after the component has been unmounted.\n    // All state updates should happen within the mounted check.\n    let mounted = true;\n    if (dtype && loader && channels) {\n      const selections = [{ ...channels[channelId].selection }];\n      let domains;\n      const hasDomainChanged = newDomainType !== domainType;\n      const has3dChanged = use3d !== newUse3d;\n      const hasSelectionChanged = !isEqual(selections, selection);\n      if (hasDomainChanged || hasSelectionChanged || has3dChanged) {\n        if (newDomainType === 'Full') {\n          domains = [DOMAINS[dtype]];\n          const [newDomain] = domains;\n          if (mounted) {\n            setDomain(newDomain);\n            setDomainType(newDomainType);\n            if (hasSelectionChanged) {\n              setSelection(selections);\n            }\n            if (has3dChanged) {\n              setUse3d(newUse3d);\n            }\n          }\n        } else {\n          getMultiSelectionStats({\n            loader: loader.data,\n            selections,\n            use3d: newUse3d,\n          }).then((stats) => {\n            // eslint-disable-next-line prefer-destructuring\n            domains = stats.domains;\n            const [newDomain] = domains;\n            if (mounted) {\n              setDomain(newDomain);\n              setDomainType(newDomainType);\n              if (hasSelectionChanged) {\n                setSelection(selections);\n              }\n              if (has3dChanged) {\n                setUse3d(newUse3d);\n              }\n            }\n          });\n        }\n      }\n    }\n    return () => {\n      mounted = false;\n    };\n  }, [\n    domainType,\n    channels,\n    channelId,\n    loader,\n    dtype,\n    newDomainType,\n    selection,\n    newUse3d,\n    use3d,\n  ]);\n  /* A valid selection is defined by an object where the keys are\n   *  the name of a dimension of the data, and the values are the\n   *  index of the image along that particular dimension.\n   *\n   *  Since we currently only support making a selection along one\n   *  addtional dimension (i.e. the dropdown just has channels or mz)\n   *  we have a helper function to create the selection.\n   *\n   *  e.g { channel: 2 } // channel dimension, third channel\n   */\n  const createSelection = index => ({ [dimName]: index });\n  return (\n    <Grid container direction=\"column\" m={1} justifyContent=\"center\">\n      <Grid container direction=\"row\" justifyContent=\"space-between\">\n        <Grid item xs={10}>\n          <ChannelSelectionDropdown\n            handleChange={v => handlePropertyChange('selection', createSelection(v))\n            }\n            selectionIndex={selectionIndex}\n            channelOptions={channelOptions}\n            disabled={isLoading}\n          />\n        </Grid>\n        <Grid item xs={1} style={{ marginTop: '4px' }}>\n          <ChannelOptions\n            handlePropertyChange={handlePropertyChange}\n            handleChannelRemove={handleChannelRemove}\n            handleIQRUpdate={handleIQRUpdate}\n            disabled={isLoading}\n          />\n        </Grid>\n      </Grid>\n      <Grid container direction=\"row\" justifyContent=\"space-between\">\n        <Grid item xs={2}>\n          <ChannelVisibilityCheckbox\n            color={rgbColor}\n            checked={visibility}\n            toggle={() => handlePropertyChange('visible', !visibility)}\n            disabled={isLoading}\n          />\n        </Grid>\n        <Grid item xs={9}>\n          <ChannelSlider\n            color={rgbColor}\n            slider={slider}\n            domain={domain || DOMAINS[dtype]}\n            dtype={dtype}\n            handleChange={v => handlePropertyChange('slider', v)}\n            disabled={isLoading}\n          />\n        </Grid>\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default RasterChannelController;\n"]},"metadata":{},"sourceType":"module"}