{"ast":null,"code":"import Observable from \"./observable\"; // TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\n\nclass MulticastSubject extends Observable {\n  constructor() {\n    super(observer => {\n      this._observers.add(observer);\n\n      return () => this._observers.delete(observer);\n    });\n    this._observers = new Set();\n  }\n\n  next(value) {\n    for (const observer of this._observers) {\n      observer.next(value);\n    }\n  }\n\n  error(error) {\n    for (const observer of this._observers) {\n      observer.error(error);\n    }\n  }\n\n  complete() {\n    for (const observer of this._observers) {\n      observer.complete();\n    }\n  }\n\n}\n\nexport default MulticastSubject;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/observable-fns/dist.esm/subject.js"],"names":["Observable","MulticastSubject","constructor","observer","_observers","add","delete","Set","next","value","error","complete"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,cAAvB,C,CACA;AACA;AACA;;AACA;;;;;;;;;;AASA,MAAMC,gBAAN,SAA+BD,UAA/B,CAA0C;AACtCE,EAAAA,WAAW,GAAG;AACV,UAAMC,QAAQ,IAAI;AACd,WAAKC,UAAL,CAAgBC,GAAhB,CAAoBF,QAApB;;AACA,aAAO,MAAM,KAAKC,UAAL,CAAgBE,MAAhB,CAAuBH,QAAvB,CAAb;AACH,KAHD;AAIA,SAAKC,UAAL,GAAkB,IAAIG,GAAJ,EAAlB;AACH;;AACDC,EAAAA,IAAI,CAACC,KAAD,EAAQ;AACR,SAAK,MAAMN,QAAX,IAAuB,KAAKC,UAA5B,EAAwC;AACpCD,MAAAA,QAAQ,CAACK,IAAT,CAAcC,KAAd;AACH;AACJ;;AACDC,EAAAA,KAAK,CAACA,KAAD,EAAQ;AACT,SAAK,MAAMP,QAAX,IAAuB,KAAKC,UAA5B,EAAwC;AACpCD,MAAAA,QAAQ,CAACO,KAAT,CAAeA,KAAf;AACH;AACJ;;AACDC,EAAAA,QAAQ,GAAG;AACP,SAAK,MAAMR,QAAX,IAAuB,KAAKC,UAA5B,EAAwC;AACpCD,MAAAA,QAAQ,CAACQ,QAAT;AACH;AACJ;;AAtBqC;;AAwB1C,eAAeV,gBAAf","sourcesContent":["import Observable from \"./observable\";\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nclass MulticastSubject extends Observable {\n    constructor() {\n        super(observer => {\n            this._observers.add(observer);\n            return () => this._observers.delete(observer);\n        });\n        this._observers = new Set();\n    }\n    next(value) {\n        for (const observer of this._observers) {\n            observer.next(value);\n        }\n    }\n    error(error) {\n        for (const observer of this._observers) {\n            observer.error(error);\n        }\n    }\n    complete() {\n        for (const observer of this._observers) {\n            observer.complete();\n        }\n    }\n}\nexport default MulticastSubject;\n"]},"metadata":{},"sourceType":"module"}