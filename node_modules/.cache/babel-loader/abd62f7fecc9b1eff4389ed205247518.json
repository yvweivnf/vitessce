{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { assert } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getImageSize } from '@loaders.gl/images';\nimport { generateUrl } from './generate-url';\nimport { deepLoad, shallowLoad } from './deep-load';\nexport function loadImageTexture(_x) {\n  return _loadImageTexture.apply(this, arguments);\n}\n\nfunction _loadImageTexture() {\n  _loadImageTexture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(getUrl) {\n    var options,\n        imageUrls,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _context.next = 3;\n            return getImageUrls(getUrl, options);\n\n          case 3:\n            imageUrls = _context.sent;\n            _context.next = 6;\n            return deepLoad(imageUrls, ImageLoader.parse, options);\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadImageTexture.apply(this, arguments);\n}\n\nexport function getImageUrls(_x2, _x3) {\n  return _getImageUrls.apply(this, arguments);\n}\n\nfunction _getImageUrls() {\n  _getImageUrls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(getUrl, options) {\n    var urlOptions,\n        mipLevels,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            urlOptions = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n            mipLevels = options && options.image && options.image.mipLevels || 0;\n\n            if (!(mipLevels !== 0)) {\n              _context2.next = 8;\n              break;\n            }\n\n            _context2.next = 5;\n            return getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions);\n\n          case 5:\n            _context2.t0 = _context2.sent;\n            _context2.next = 9;\n            break;\n\n          case 8:\n            _context2.t0 = generateUrl(getUrl, options, urlOptions);\n\n          case 9:\n            return _context2.abrupt(\"return\", _context2.t0);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getImageUrls.apply(this, arguments);\n}\n\nfunction getMipmappedImageUrls(_x4, _x5, _x6, _x7) {\n  return _getMipmappedImageUrls.apply(this, arguments);\n}\n\nfunction _getMipmappedImageUrls() {\n  _getMipmappedImageUrls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(getUrl, mipLevels, options, urlOptions) {\n    var urls, url, image, _getImageSize, width, height, mipLevel, _url;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            urls = [];\n\n            if (!(mipLevels === 'auto')) {\n              _context3.next = 9;\n              break;\n            }\n\n            url = generateUrl(getUrl, options, _objectSpread({}, urlOptions, {\n              lod: 0\n            }));\n            _context3.next = 5;\n            return shallowLoad(url, ImageLoader.parse, options);\n\n          case 5:\n            image = _context3.sent;\n            _getImageSize = getImageSize(image), width = _getImageSize.width, height = _getImageSize.height;\n            mipLevels = getMipLevels({\n              width: width,\n              height: height\n            });\n            urls.push(url);\n\n          case 9:\n            assert(mipLevels > 0);\n\n            for (mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n              _url = generateUrl(getUrl, options, _objectSpread({}, urlOptions, {\n                lod: mipLevel\n              }));\n              urls.push(_url);\n            }\n\n            return _context3.abrupt(\"return\", urls);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getMipmappedImageUrls.apply(this, arguments);\n}\n\nexport function getMipLevels(size) {\n  return 1 + Math.floor(Math.log2(Math.max(size.width, size.height)));\n}","map":{"version":3,"sources":["../../../../src/lib/texture-api/load-image.ts"],"names":["options","imageUrls","getImageUrls","deepLoad","ImageLoader","urlOptions","mipLevels","getMipmappedImageUrls","generateUrl","urls","url","lod","image","shallowLoad","height","getImageSize","getMipLevels","width","assert","mipLevel","Math","size"],"mappings":";;;AAAA,SAAA,MAAA,QAAA,0BAAA;AACA,SAAA,WAAA,EAAA,YAAA,QAAA,oBAAA;AAEA,SAAA,WAAA,QAAA,gBAAA;AACA,SAAA,QAAA,EAAA,WAAA,QAAA,aAAA;AAEA,gBAAO,gBAAP;AAAA;AAAA;;;+EAAO,iBAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyDA,YAAAA,OAAzD,2DAAA,EAAA;AAAA;AAAA,mBACmBE,YAAY,CAAA,MAAA,EAApC,OAAoC,CAD/B;;AAAA;AACCD,YAAAA,SADD;AAAA;AAAA,mBAEQE,QAAQ,CAAA,SAAA,EAAYC,WAAW,CAAvB,KAAA,EAArB,OAAqB,CAFhB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAKP,gBAAO,YAAP;AAAA;AAAA;;;2EAAO,kBAAA,MAAA,EAAA,OAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGLC,YAAAA,UAHK,8DAAA,EAAA;AAKCC,YAAAA,SALD,GAKcN,OAAO,IAAIA,OAAO,CAAlBA,KAAAA,IAA4BA,OAAO,CAAPA,KAAAA,CAA7B,SAACA,IAAnB,CALK;;AAAA,kBAMEM,SAAS,KAATA,CANF;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAOKC,qBAAqB,CAAA,MAAA,EAAA,SAAA,EAAA,OAAA,EADxBD,UACwB,CAP1B;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAQDE,WAAW,CAAA,MAAA,EAAA,OAAA,EAFf,UAEe,CARV;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAWP,qB;;;;;oFAAA,kBAAA,MAAA,EAAA,SAAA,EAAA,OAAA,EAAA,UAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAMQC,YAAAA,IANR,GAME,EANF;;AAAA,kBASMH,SAAS,KAAb,MATF;AAAA;AAAA;AAAA;;AAUUI,YAAAA,GAVV,GAUgBF,WAAW,CAAA,MAAA,EAAA,OAAA,oBAAkB,UAAlB;AAAkCG,cAAAA,GAAG,EAAE;AAAvC,eAV3B;AAAA;AAAA,mBAWwBE,WAAW,CAAA,GAAA,EAAMT,WAAW,CAAjB,KAAA,EAA/B,OAA+B,CAXnC;;AAAA;AAWUQ,YAAAA,KAXV;AAAA,4BAa4BG,YAAY,CAApC,KAAoC,CAbxC,EAaU,KAbV,iBAaU,KAbV,EAakBD,MAblB,iBAakBA,MAblB;AAcIR,YAAAA,SAAS,GAAGU,YAAY,CAAC;AAACC,cAAAA,KAAD,EAACA,KAAD;AAAQH,cAAAA,MAAAA,EAAAA;AAAR,aAAD,CAAxBR;AAGAG,YAAAA,IAAI,CAAJA,IAAAA,CAAAA,GAAAA;;AAjBJ;AAqBES,YAAAA,MAAM,CAACZ,SAAS,GAAhBY,CAAM,CAANA;;AAEA,iBAASC,QAAT,GAAoBV,IAAI,CAAxB,MAAA,EAAiCU,QAAQ,GAAzC,SAAA,EAAuD,EAAvD,QAAA,EAAmE;AAC3DT,cAAAA,IAD2D,GACrDF,WAAW,CAAA,MAAA,EAAA,OAAA,oBAAkB,UAAlB;AAAkCG,gBAAAA,GAAG,EAAEQ;AAAvC,iBAD0C;AAEjEV,cAAAA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA;AACD;;AA1BH,8CA4BE,IA5BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAgCA,OAAO,SAAA,YAAA,CAAA,IAAA,EAAqE;AAC1E,SAAO,IAAIW,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,IAAAA,CAAUA,IAAI,CAAJA,GAAAA,CAASC,IAAI,CAAbD,KAAAA,EAAqBC,IAAI,CAAzD,MAAgCD,CAAVA,CAAXA,CAAX;AACD","sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport {ImageLoader, getImageSize} from '@loaders.gl/images';\nimport type {GetUrl, UrlOptions} from './texture-api-types';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImageTexture(getUrl: string | GetUrl, options = {}): Promise<any> {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, ImageLoader.parse, options);\n}\n\nexport async function getImageUrls(\n  getUrl: string | GetUrl,\n  options: any,\n  urlOptions: UrlOptions = {}\n): Promise<any> {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(\n  getUrl: string | GetUrl,\n  mipLevels: number | 'auto',\n  options: any,\n  urlOptions: UrlOptions\n): Promise<string[]> {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, ImageLoader.parse, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels(size: {width: number; height: number}): number {\n  return 1 + Math.floor(Math.log2(Math.max(size.width, size.height)));\n}\n"]},"metadata":{},"sourceType":"module"}