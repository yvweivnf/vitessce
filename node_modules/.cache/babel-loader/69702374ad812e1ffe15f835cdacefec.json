{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash as _hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\n\nfunction rangeFormula(model, fieldDef, channel, config) {\n  var _a, _b;\n\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    var guide = isUnitModel(model) ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};\n    var startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    var endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n    };\n  }\n\n  return {};\n}\n\nfunction binKey(bin, field) {\n  return \"\".concat(binToString(bin), \"_\").concat(field);\n}\n\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(\"\".concat(key, \"_bins\")),\n    extentSignal: model.getName(\"\".concat(key, \"_extent\"))\n  };\n}\n\nexport function getBinSignalName(model, field, bin) {\n  var _a;\n\n  var normalizedBin = (_a = normalizeBin(bin, undefined)) !== null && _a !== void 0 ? _a : {};\n  var key = binKey(normalizedBin, field);\n  return model.getName(\"\".concat(key, \"_bins\"));\n}\n\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t, bin, model) {\n  var as;\n  var span;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, \"\".concat(t.as, \"_end\")] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n\n  var normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n  var key = binKey(normalizedBin, t.field);\n\n  var _getSignalsFromModel = getSignalsFromModel(model, key),\n      signal = _getSignalsFromModel.signal,\n      extentSignal = _getSignalsFromModel.extentSignal;\n\n  if (isParameterExtent(normalizedBin.extent)) {\n    var ext = normalizedBin.extent;\n    span = parseSelectionExtent(model, ext.param, ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  var binComponent = Object.assign(Object.assign(Object.assign({\n    bin: normalizedBin,\n    field: t.field,\n    as: [as]\n  }, signal ? {\n    signal: signal\n  } : {}), extentSignal ? {\n    extentSignal: extentSignal\n  } : {}), span ? {\n    span: span\n  } : {});\n  return {\n    key: key,\n    binComponent: binComponent\n  };\n}\n\nexport var BinNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(BinNode, _DataFlowNode);\n\n  var _super = _createSuper(BinNode);\n\n  function BinNode(parent, bins) {\n    var _this;\n\n    _classCallCheck(this, BinNode);\n\n    _this = _super.call(this, parent);\n    _this.bins = bins;\n    return _this;\n  }\n\n  _createClass(BinNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new BinNode(null, duplicate(this.bins));\n    }\n  }, {\n    key: \"merge\",\n\n    /**\n     * Merge bin nodes. This method either integrates the bin config from the other node\n     * or if this node already has a bin config, renames the corresponding signal in the model.\n     */\n    value: function merge(other, renameSignal) {\n      var _iterator = _createForOfIteratorHelper(keys(other.bins)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n\n          if (key in this.bins) {\n            renameSignal(other.bins[key].signal, this.bins[key].signal); // Ensure that we don't have duplicate names for signal pairs\n\n            this.bins[key].as = unique([].concat(_toConsumableArray(this.bins[key].as), _toConsumableArray(other.bins[key].as)), _hash);\n          } else {\n            this.bins[key] = other.bins[key];\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(other.children),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          other.removeChild(child);\n          child.parent = this;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      other.remove();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(vals(this.bins).map(function (c) {\n        return c.as;\n      }).flat(2));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(vals(this.bins).map(function (c) {\n        return c.field;\n      }));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Bin \".concat(_hash(this.bins));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return vals(this.bins).flatMap(function (bin) {\n        var transform = [];\n\n        var _bin$as = _toArray(bin.as),\n            binAs = _bin$as[0],\n            remainingAs = _bin$as.slice(1);\n\n        var _a = bin.bin,\n            extent = _a.extent,\n            params = __rest(_a, [\"extent\"]);\n\n        var binTrans = Object.assign(Object.assign(Object.assign({\n          type: 'bin',\n          field: replacePathInField(bin.field),\n          as: binAs,\n          signal: bin.signal\n        }, !isParameterExtent(extent) ? {\n          extent: extent\n        } : {\n          extent: null\n        }), bin.span ? {\n          span: {\n            signal: \"span(\".concat(bin.span, \")\")\n          }\n        } : {}), params);\n\n        if (!extent && bin.extentSignal) {\n          transform.push({\n            type: 'extent',\n            field: replacePathInField(bin.field),\n            signal: bin.extentSignal\n          });\n          binTrans.extent = {\n            signal: bin.extentSignal\n          };\n        }\n\n        transform.push(binTrans);\n\n        var _iterator3 = _createForOfIteratorHelper(remainingAs),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var as = _step3.value;\n\n            for (var i = 0; i < 2; i++) {\n              transform.push({\n                type: 'formula',\n                expr: vgField({\n                  field: binAs[i]\n                }, {\n                  expr: 'datum'\n                }),\n                as: as[i]\n              });\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (bin.formula) {\n          transform.push({\n            type: 'formula',\n            expr: bin.formula,\n            as: bin.formulaAs\n          });\n        }\n\n        return transform;\n      });\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var bins = model.reduceFieldDef(function (binComponentIndex, fieldDef, channel) {\n        if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          var _createBinComponent = createBinComponent(fieldDef, fieldDef.bin, model),\n              key = _createBinComponent.key,\n              binComponent = _createBinComponent.binComponent;\n\n          binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n        }\n\n        return binComponentIndex;\n      }, {});\n\n      if (isEmpty(bins)) {\n        return null;\n      }\n\n      return new BinNode(parent, bins);\n    }\n    /**\n     * Creates a bin node from BinTransform.\n     * The optional parameter should provide\n     */\n\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t, model) {\n      var _createBinComponent2 = createBinComponent(t, t.bin, model),\n          key = _createBinComponent2.key,\n          binComponent = _createBinComponent2.binComponent;\n\n      return new BinNode(parent, _defineProperty({}, key, binComponent));\n    }\n  }]);\n\n  return BinNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/bin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\nfunction rangeFormula(model, fieldDef, channel, config) {\n    var _a, _b;\n    if (binRequiresRange(fieldDef, channel)) {\n        // read format from axis or legend, if there is no format then use config.numberFormat\n        const guide = isUnitModel(model)\n            ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {}\n            : {};\n        const startField = vgField(fieldDef, { expr: 'datum' });\n        const endField = vgField(fieldDef, { expr: 'datum', binSuffix: 'end' });\n        return {\n            formulaAs: vgField(fieldDef, { binSuffix: 'range', forAs: true }),\n            formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n        };\n    }\n    return {};\n}\nfunction binKey(bin, field) {\n    return `${binToString(bin)}_${field}`;\n}\nfunction getSignalsFromModel(model, key) {\n    return {\n        signal: model.getName(`${key}_bins`),\n        extentSignal: model.getName(`${key}_extent`)\n    };\n}\nexport function getBinSignalName(model, field, bin) {\n    var _a;\n    const normalizedBin = (_a = normalizeBin(bin, undefined)) !== null && _a !== void 0 ? _a : {};\n    const key = binKey(normalizedBin, field);\n    return model.getName(`${key}_bins`);\n}\nfunction isBinTransform(t) {\n    return 'as' in t;\n}\nfunction createBinComponent(t, bin, model) {\n    let as;\n    let span;\n    if (isBinTransform(t)) {\n        as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n    }\n    else {\n        as = [vgField(t, { forAs: true }), vgField(t, { binSuffix: 'end', forAs: true })];\n    }\n    const normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n    const key = binKey(normalizedBin, t.field);\n    const { signal, extentSignal } = getSignalsFromModel(model, key);\n    if (isParameterExtent(normalizedBin.extent)) {\n        const ext = normalizedBin.extent;\n        span = parseSelectionExtent(model, ext.param, ext);\n        delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n    }\n    const binComponent = Object.assign(Object.assign(Object.assign({ bin: normalizedBin, field: t.field, as: [as] }, (signal ? { signal } : {})), (extentSignal ? { extentSignal } : {})), (span ? { span } : {}));\n    return { key, binComponent };\n}\nexport class BinNode extends DataFlowNode {\n    constructor(parent, bins) {\n        super(parent);\n        this.bins = bins;\n    }\n    clone() {\n        return new BinNode(null, duplicate(this.bins));\n    }\n    static makeFromEncoding(parent, model) {\n        const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n            if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n                const { key, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);\n                binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n            }\n            return binComponentIndex;\n        }, {});\n        if (isEmpty(bins)) {\n            return null;\n        }\n        return new BinNode(parent, bins);\n    }\n    /**\n     * Creates a bin node from BinTransform.\n     * The optional parameter should provide\n     */\n    static makeFromTransform(parent, t, model) {\n        const { key, binComponent } = createBinComponent(t, t.bin, model);\n        return new BinNode(parent, {\n            [key]: binComponent\n        });\n    }\n    /**\n     * Merge bin nodes. This method either integrates the bin config from the other node\n     * or if this node already has a bin config, renames the corresponding signal in the model.\n     */\n    merge(other, renameSignal) {\n        for (const key of keys(other.bins)) {\n            if (key in this.bins) {\n                renameSignal(other.bins[key].signal, this.bins[key].signal);\n                // Ensure that we don't have duplicate names for signal pairs\n                this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n            }\n            else {\n                this.bins[key] = other.bins[key];\n            }\n        }\n        for (const child of other.children) {\n            other.removeChild(child);\n            child.parent = this;\n        }\n        other.remove();\n    }\n    producedFields() {\n        return new Set(vals(this.bins)\n            .map(c => c.as)\n            .flat(2));\n    }\n    dependentFields() {\n        return new Set(vals(this.bins).map(c => c.field));\n    }\n    hash() {\n        return `Bin ${hash(this.bins)}`;\n    }\n    assemble() {\n        return vals(this.bins).flatMap(bin => {\n            const transform = [];\n            const [binAs, ...remainingAs] = bin.as;\n            const _a = bin.bin, { extent } = _a, params = __rest(_a, [\"extent\"]);\n            const binTrans = Object.assign(Object.assign(Object.assign({ type: 'bin', field: replacePathInField(bin.field), as: binAs, signal: bin.signal }, (!isParameterExtent(extent) ? { extent } : { extent: null })), (bin.span ? { span: { signal: `span(${bin.span})` } } : {})), params);\n            if (!extent && bin.extentSignal) {\n                transform.push({\n                    type: 'extent',\n                    field: replacePathInField(bin.field),\n                    signal: bin.extentSignal\n                });\n                binTrans.extent = { signal: bin.extentSignal };\n            }\n            transform.push(binTrans);\n            for (const as of remainingAs) {\n                for (let i = 0; i < 2; i++) {\n                    transform.push({\n                        type: 'formula',\n                        expr: vgField({ field: binAs[i] }, { expr: 'datum' }),\n                        as: as[i]\n                    });\n                }\n            }\n            if (bin.formula) {\n                transform.push({\n                    type: 'formula',\n                    expr: bin.formula,\n                    as: bin.formulaAs\n                });\n            }\n            return transform;\n        });\n    }\n}\n//# sourceMappingURL=bin.js.map"]},"metadata":{},"sourceType":"module"}