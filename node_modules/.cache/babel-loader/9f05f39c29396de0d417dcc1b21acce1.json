{"ast":null,"code":"import { ImageLoader } from '@loaders.gl/images';\nimport { getImageUrls } from './load-image';\nimport { deepLoad } from './deep-load';\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\nconst CUBE_FACES = [{\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_X,\n  direction: 'right',\n  axis: 'x',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X,\n  direction: 'left',\n  axis: 'x',\n  sign: 'negative'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y,\n  direction: 'top',\n  axis: 'y',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  direction: 'bottom',\n  axis: 'y',\n  sign: 'negative'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z,\n  direction: 'front',\n  axis: 'z',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,\n  direction: 'back',\n  axis: 'z',\n  sign: 'negative'\n}];\nexport async function getImageCubeUrls(getUrl, options) {\n  const urls = {};\n  const promises = [];\n  let index = 0;\n\n  for (let i = 0; i < CUBE_FACES.length; ++i) {\n    const face = CUBE_FACES[index];\n    const promise = getImageUrls(getUrl, options, { ...face,\n      index: index++\n    }).then(url => {\n      urls[face.face] = url;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n  return urls;\n}\nexport async function loadImageTextureCube(getUrl, options = {}) {\n  const urls = await getImageCubeUrls(getUrl, options);\n  return await deepLoad(urls, ImageLoader.parse, options);\n}","map":{"version":3,"sources":["../../../../src/lib/texture-api/load-image-cube.ts"],"names":["GL_TEXTURE_CUBE_MAP_POSITIVE_X","GL_TEXTURE_CUBE_MAP_NEGATIVE_X","GL_TEXTURE_CUBE_MAP_POSITIVE_Y","GL_TEXTURE_CUBE_MAP_NEGATIVE_Y","GL_TEXTURE_CUBE_MAP_POSITIVE_Z","GL_TEXTURE_CUBE_MAP_NEGATIVE_Z","CUBE_FACES","face","direction","axis","sign","urls","promises","index","i","promise","url","Promise","options","getImageCubeUrls","deepLoad","ImageLoader"],"mappings":"AACA,SAAA,WAAA,QAAA,oBAAA;AAEA,SAAA,YAAA,QAAA,cAAA;AACA,SAAA,QAAA,QAAA,aAAA;AAGA,MAAMA,8BAA8B,GAApC,MAAA;AACA,MAAMC,8BAA8B,GAApC,MAAA;AACA,MAAMC,8BAA8B,GAApC,MAAA;AACA,MAAMC,8BAA8B,GAApC,MAAA;AACA,MAAMC,8BAA8B,GAApC,MAAA;AACA,MAAMC,8BAA8B,GAApC,MAAA;AAEA,MAAMC,UAAU,GAAG,CACjB;AAACC,EAAAA,IAAI,EAAL,8BAAA;AAAuCC,EAAAA,SAAS,EAAhD,OAAA;AAA2DC,EAAAA,IAAI,EAA/D,GAAA;AAAsEC,EAAAA,IAAI,EAAE;AAA5E,CADiB,EAEjB;AAACH,EAAAA,IAAI,EAAL,8BAAA;AAAuCC,EAAAA,SAAS,EAAhD,MAAA;AAA0DC,EAAAA,IAAI,EAA9D,GAAA;AAAqEC,EAAAA,IAAI,EAAE;AAA3E,CAFiB,EAGjB;AAACH,EAAAA,IAAI,EAAL,8BAAA;AAAuCC,EAAAA,SAAS,EAAhD,KAAA;AAAyDC,EAAAA,IAAI,EAA7D,GAAA;AAAoEC,EAAAA,IAAI,EAAE;AAA1E,CAHiB,EAIjB;AAACH,EAAAA,IAAI,EAAL,8BAAA;AAAuCC,EAAAA,SAAS,EAAhD,QAAA;AAA4DC,EAAAA,IAAI,EAAhE,GAAA;AAAuEC,EAAAA,IAAI,EAAE;AAA7E,CAJiB,EAKjB;AAACH,EAAAA,IAAI,EAAL,8BAAA;AAAuCC,EAAAA,SAAS,EAAhD,OAAA;AAA2DC,EAAAA,IAAI,EAA/D,GAAA;AAAsEC,EAAAA,IAAI,EAAE;AAA5E,CALiB,EAMjB;AAACH,EAAAA,IAAI,EAAL,8BAAA;AAAuCC,EAAAA,SAAS,EAAhD,MAAA;AAA0DC,EAAAA,IAAI,EAA9D,GAAA;AAAqEC,EAAAA,IAAI,EAAE;AAA3E,CANiB,CAAnB;AAoBA,OAAO,eAAA,gBAAA,CAAA,MAAA,EAAA,OAAA,EAAqE;AAE1E,QAAMC,IAAuC,GAA7C,EAAA;AACA,QAAMC,QAAwB,GAA9B,EAAA;AAEA,MAAIC,KAAK,GAAT,CAAA;;AACA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGR,UAAU,CAA9B,MAAA,EAAuC,EAAvC,CAAA,EAA4C;AAC1C,UAAMC,IAAI,GAAGD,UAAU,CAAvB,KAAuB,CAAvB;AACA,UAAMS,OAAO,GAAG,YAAY,CAAA,MAAA,EAAA,OAAA,EAAkB,EAAC,GAAD,IAAA;AAAUF,MAAAA,KAAK,EAAEA,KAAK;AAAtB,KAAlB,CAAZ,CAAA,IAAA,CAA+DG,GAAD,IAAS;AACrFL,MAAAA,IAAI,CAACJ,IAAI,CAATI,IAAI,CAAJA,GAAAA,GAAAA;AADF,KAAgB,CAAhB;AAGAC,IAAAA,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AACD;;AAED,QAAMK,OAAO,CAAPA,GAAAA,CAAN,QAAMA,CAAN;AAEA,SAAA,IAAA;AACD;AAID,OAAO,eAAA,oBAAA,CAAA,MAAA,EAELC,OAAO,GAFF,EAAA,EAGsB;AAC3B,QAAMP,IAAI,GAAG,MAAMQ,gBAAgB,CAAA,MAAA,EAAnC,OAAmC,CAAnC;AACA,SAAQ,MAAMC,QAAQ,CAAA,IAAA,EAAOC,WAAW,CAAlB,KAAA,EAAtB,OAAsB,CAAtB;AACD","sourcesContent":["// loaders.gl, MIT license\nimport {ImageLoader} from '@loaders.gl/images';\nimport type {GetUrl, UrlOptions} from './texture-api-types';\nimport {getImageUrls} from './load-image';\nimport {deepLoad} from './deep-load';\n\n// Returned map will be have keys corresponding to GL cubemap constants\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\n\nconst CUBE_FACES = [\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: 'right', axis: 'x', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: 'left', axis: 'x', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: 'top', axis: 'y', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: 'bottom', axis: 'y', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: 'front', axis: 'z', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: 'back', axis: 'z', sign: 'negative'}\n];\n\nexport type ImageCubeTexture = {\n  GL_TEXTURE_CUBE_MAP_POSITIVE_X: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_X: any;\n  GL_TEXTURE_CUBE_MAP_POSITIVE_Y: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: any;\n  GL_TEXTURE_CUBE_MAP_POSITIVE_Z: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: any;\n};\n\n// Returns an object with six key-value pairs containing the urls (or url mip arrays)\n// for each cube face\nexport async function getImageCubeUrls(getUrl: GetUrl, options: UrlOptions) {\n  // Calculate URLs\n  const urls: Record<number, string | string[]> = {};\n  const promises: Promise<any>[] = [];\n\n  let index = 0;\n  for (let i = 0; i < CUBE_FACES.length; ++i) {\n    const face = CUBE_FACES[index];\n    const promise = getImageUrls(getUrl, options, {...face, index: index++}).then((url) => {\n      urls[face.face] = url;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return urls;\n}\n\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function loadImageTextureCube(\n  getUrl: GetUrl,\n  options = {}\n): Promise<ImageCubeTexture> {\n  const urls = await getImageCubeUrls(getUrl, options);\n  return (await deepLoad(urls, ImageLoader.parse, options)) as ImageCubeTexture;\n}\n"]},"metadata":{},"sourceType":"module"}