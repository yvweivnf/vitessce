{"ast":null,"code":"import { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nexport function assembleProjections(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n  const component = model.component.projection;\n\n  if (!component || component.merged) {\n    return [];\n  }\n\n  const projection = component.combine();\n  const {\n    name\n  } = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [Object.assign(Object.assign({\n      name\n    }, {\n      translate: {\n        signal: '[width / 2, height / 2]'\n      }\n    }), projection)];\n  } else {\n    // generate projection that uses extent fitting\n    const size = {\n      signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n    };\n    const fits = component.data.reduce((sources, data) => {\n      const source = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n\n      return sources;\n    }, []);\n\n    if (fits.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n\n    return [Object.assign({\n      name,\n      size,\n      fit: {\n        signal: fits.length > 1 ? `[${fits.join(', ')}]` : fits[0]\n      }\n    }, projection)];\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/projection/assemble.ts"],"names":[],"mappings":"AACA,SAAQ,QAAR,QAAuB,YAAvB;AACA,SAAQ,WAAR,QAA0B,mBAA1B;AACA,SAAQ,aAAR,EAAuB,YAAvB,QAAiD,UAAjD;AAEA,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAA0C;AAC9C,MAAI,YAAY,CAAC,KAAD,CAAZ,IAAuB,aAAa,CAAC,KAAD,CAAxC,EAAiD;AAC/C,WAAO,sCAAsC,CAAC,KAAD,CAA7C;AACD,GAFD,MAEO;AACL,WAAO,0BAA0B,CAAC,KAAD,CAAjC;AACD;AACF;AAED,OAAM,SAAU,sCAAV,CAAiD,KAAjD,EAA6D;AACjE,SAAO,KAAK,CAAC,QAAN,CAAe,MAAf,CAAsB,CAAC,WAAD,EAAc,KAAd,KAAuB;AAClD,WAAO,WAAW,CAAC,MAAZ,CAAmB,KAAK,CAAC,mBAAN,EAAnB,CAAP;AACD,GAFM,EAEJ,0BAA0B,CAAC,KAAD,CAFtB,CAAP;AAGD;AAED,OAAM,SAAU,0BAAV,CAAqC,KAArC,EAAiD;AACrD,QAAM,SAAS,GAAG,KAAK,CAAC,SAAN,CAAgB,UAAlC;;AACA,MAAI,CAAC,SAAD,IAAc,SAAS,CAAC,MAA5B,EAAoC;AAClC,WAAO,EAAP;AACD;;AAED,QAAM,UAAU,GAAG,SAAS,CAAC,OAAV,EAAnB;AACA,QAAM;AAAC,IAAA;AAAD,MAAS,UAAf,CAPqD,CAO1B;;AAE3B,MAAI,CAAC,SAAS,CAAC,IAAf,EAAqB;AACnB;AACA,WAAO,C;AAEH,MAAA;OAEG;AAAC,MAAA,SAAS,EAAE;AAAC,QAAA,MAAM,EAAE;AAAT;AAAZ,K,GAEA,U,CANA,CAAP;AASD,GAXD,MAWO;AACL;AACA,UAAM,IAAI,GAAc;AACtB,MAAA,MAAM,EAAE,IAAI,SAAS,CAAC,IAAV,CAAe,GAAf,CAAmB,GAAG,IAAI,GAAG,CAAC,MAA9B,EAAsC,IAAtC,CAA2C,IAA3C,CAAgD;AADtC,KAAxB;AAIA,UAAM,IAAI,GAAa,SAAS,CAAC,IAAV,CAAe,MAAf,CAAsB,CAAC,OAAD,EAAU,IAAV,KAAkB;AAC7D,YAAM,MAAM,GAAW,WAAW,CAAC,IAAD,CAAX,GAAoB,IAAI,CAAC,MAAzB,GAAkC,SAAS,KAAK,CAAC,gBAAN,CAAuB,IAAvB,CAA4B,IAA9F;;AACA,UAAI,CAAC,QAAQ,CAAC,OAAD,EAAU,MAAV,CAAb,EAAgC;AAC9B;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,MAAb;AACD;;AACD,aAAO,OAAP;AACD,KAPsB,EAOpB,EAPoB,CAAvB;;AASA,QAAI,IAAI,CAAC,MAAL,IAAe,CAAnB,EAAsB;AACpB,YAAM,IAAI,KAAJ,CAAU,+CAAV,CAAN;AACD;;AAED,WAAO,C;AAEH,MAAA,I;AACA,MAAA,I;AACA,MAAA,GAAG,EAAE;AACH,QAAA,MAAM,EAAE,IAAI,CAAC,MAAL,GAAc,CAAd,GAAkB,IAAI,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,GAArC,GAA2C,IAAI,CAAC,CAAD;AADpD;OAGF,U,CAPA,CAAP;AAUD;AACF","sourceRoot":"","sourcesContent":["import { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nexport function assembleProjections(model) {\n    if (isLayerModel(model) || isConcatModel(model)) {\n        return assembleProjectionsForModelAndChildren(model);\n    }\n    else {\n        return assembleProjectionForModel(model);\n    }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n    return model.children.reduce((projections, child) => {\n        return projections.concat(child.assembleProjections());\n    }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n    const component = model.component.projection;\n    if (!component || component.merged) {\n        return [];\n    }\n    const projection = component.combine();\n    const { name } = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n    if (!component.data) {\n        // generate custom projection, no automatic fitting\n        return [\n            Object.assign(Object.assign({ name }, { translate: { signal: '[width / 2, height / 2]' } }), projection)\n        ];\n    }\n    else {\n        // generate projection that uses extent fitting\n        const size = {\n            signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n        };\n        const fits = component.data.reduce((sources, data) => {\n            const source = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n            if (!contains(sources, source)) {\n                // build a unique list of sources\n                sources.push(source);\n            }\n            return sources;\n        }, []);\n        if (fits.length <= 0) {\n            throw new Error(\"Projection's fit didn't find any data sources\");\n        }\n        return [\n            Object.assign({ name,\n                size, fit: {\n                    signal: fits.length > 1 ? `[${fits.join(', ')}]` : fits[0]\n                } }, projection)\n        ];\n    }\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}