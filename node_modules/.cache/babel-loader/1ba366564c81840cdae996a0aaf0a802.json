{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n  constructor() {\n    super(...arguments);\n    this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer()];\n  }\n\n  map(spec, params) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n\n    return super.map(spec, params);\n  } // This is for normalizing non-facet unit\n\n\n  mapUnit(spec, params) {\n    const {\n      parentEncoding,\n      parentProjection\n    } = params;\n    const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n    const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), encoding ? {\n      encoding\n    } : {});\n\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n    }\n\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n        return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n      }\n    }\n\n    return specWithReplacedEncoding;\n  }\n\n  mapRepeat(spec, params) {\n    if (isLayerRepeatSpec(spec)) {\n      return this.mapLayerRepeat(spec, params);\n    } else {\n      return this.mapNonLayerRepeat(spec, params);\n    }\n  }\n\n  mapLayerRepeat(spec, params) {\n    const {\n      repeat,\n      spec: childSpec\n    } = spec,\n          rest = __rest(spec, [\"repeat\", \"spec\"]);\n\n    const {\n      row,\n      column,\n      layer\n    } = repeat;\n    const {\n      repeater = {},\n      repeaterPrefix = ''\n    } = params;\n\n    if (row || column) {\n      return this.mapRepeat(Object.assign(Object.assign({}, spec), {\n        repeat: Object.assign(Object.assign({}, row ? {\n          row\n        } : {}), column ? {\n          column\n        } : {}),\n        spec: {\n          repeat: {\n            layer\n          },\n          spec: childSpec\n        }\n      }), params);\n    } else {\n      return Object.assign(Object.assign({}, rest), {\n        layer: layer.map(layerValue => {\n          const childRepeater = Object.assign(Object.assign({}, repeater), {\n            layer: layerValue\n          });\n          const childName = `${(childSpec.name || '') + repeaterPrefix}child__layer_${varName(layerValue)}`;\n          const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), {\n            repeater: childRepeater,\n            repeaterPrefix: childName\n          }));\n          child.name = childName;\n          return child;\n        })\n      });\n    }\n  }\n\n  mapNonLayerRepeat(spec, params) {\n    var _a;\n\n    const {\n      repeat,\n      spec: childSpec,\n      data\n    } = spec,\n          remainingProperties = __rest(spec, [\"repeat\", \"spec\", \"data\"]);\n\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n\n    const concat = [];\n    const {\n      repeater = {},\n      repeaterPrefix = ''\n    } = params;\n    const row = !isArray(repeat) && repeat.row || [repeater ? repeater.row : null];\n    const column = !isArray(repeat) && repeat.column || [repeater ? repeater.column : null];\n    const repeatValues = isArray(repeat) && repeat || [repeater ? repeater.repeat : null]; // cross product\n\n    for (const repeatValue of repeatValues) {\n      for (const rowValue of row) {\n        for (const columnValue of column) {\n          const childRepeater = {\n            repeat: repeatValue,\n            row: rowValue,\n            column: columnValue,\n            layer: repeater.layer\n          };\n          const childName = (childSpec.name || '') + repeaterPrefix + 'child__' + (isArray(repeat) ? `${varName(repeatValue)}` : (repeat.row ? `row_${varName(rowValue)}` : '') + (repeat.column ? `column_${varName(columnValue)}` : ''));\n          const child = this.map(childSpec, Object.assign(Object.assign({}, params), {\n            repeater: childRepeater,\n            repeaterPrefix: childName\n          }));\n          child.name = childName; // we move data up\n\n          concat.push(omit(child, ['data']));\n        }\n      }\n    }\n\n    const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n    return Object.assign(Object.assign({\n      data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data,\n      align: 'all'\n    }, remainingProperties), {\n      columns,\n      concat\n    });\n  }\n\n  mapFacet(spec, params) {\n    const {\n      facet\n    } = spec;\n\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n\n    return super.mapFacet(spec, params);\n  }\n\n  mapUnitWithParentEncodingOrProjection(spec, params) {\n    const {\n      encoding,\n      projection\n    } = spec;\n    const {\n      parentEncoding,\n      parentProjection,\n      config\n    } = params;\n    const mergedProjection = mergeProjection({\n      parentProjection,\n      projection\n    });\n    const mergedEncoding = mergeEncoding({\n      parentEncoding,\n      encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n    });\n    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {\n      projection: mergedProjection\n    } : {}), mergedEncoding ? {\n      encoding: mergedEncoding\n    } : {}), {\n      config\n    });\n  }\n\n  mapFacetedUnit(spec, normParams) {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const _a = spec.encoding,\n          {\n      row,\n      column,\n      facet\n    } = _a,\n          encoding = __rest(_a, [\"row\", \"column\", \"facet\"]); // Mark and encoding should be moved into the inner spec\n\n\n    const {\n      mark,\n      width,\n      projection,\n      height,\n      view,\n      params,\n      encoding: _\n    } = spec,\n          outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"view\", \"params\", \"encoding\"]);\n\n    const {\n      facetMapping,\n      layout\n    } = this.getFacetMappingAndLayout({\n      row,\n      column,\n      facet\n    }, normParams);\n    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {\n      // row / column has higher precedence than facet\n      facet: facetMapping,\n      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width ? {\n        width\n      } : {}), height ? {\n        height\n      } : {}), view ? {\n        view\n      } : {}), projection ? {\n        projection\n      } : {}), {\n        mark,\n        encoding: newEncoding\n      }), params ? {\n        params\n      } : {})\n    }), normParams);\n  }\n\n  getFacetMappingAndLayout(facets, params) {\n    var _a;\n\n    const {\n      row,\n      column,\n      facet\n    } = facets;\n\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n\n      const facetMapping = {};\n      const layout = {};\n\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n\n        if (def) {\n          const {\n            align,\n            center,\n            spacing,\n            columns\n          } = def,\n                defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n          facetMapping[channel] = defWithoutLayout;\n\n          for (const prop of ['align', 'center', 'spacing']) {\n            if (def[prop] !== undefined) {\n              (_a = layout[prop]) !== null && _a !== void 0 ? _a : layout[prop] = {};\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n\n      return {\n        facetMapping,\n        layout\n      };\n    } else {\n      const {\n        align,\n        center,\n        spacing,\n        columns\n      } = facet,\n            facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n      return {\n        facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align ? {\n          align\n        } : {}), center ? {\n          center\n        } : {}), spacing ? {\n          spacing\n        } : {}), columns ? {\n          columns\n        } : {})\n      };\n    }\n  }\n\n  mapLayer(spec, _a) {\n    // Special handling for extended layer spec\n    var {\n      parentEncoding,\n      parentProjection\n    } = _a,\n        otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n\n    const {\n      encoding,\n      projection\n    } = spec,\n          rest = __rest(spec, [\"encoding\", \"projection\"]);\n\n    const params = Object.assign(Object.assign({}, otherParams), {\n      parentEncoding: mergeEncoding({\n        parentEncoding,\n        encoding,\n        layer: true\n      }),\n      parentProjection: mergeProjection({\n        parentProjection,\n        projection\n      })\n    });\n    return super.mapLayer(rest, params);\n  }\n\n}\n\nfunction mergeEncoding({\n  parentEncoding,\n  encoding = {},\n  layer\n}) {\n  let merged = {};\n\n  if (parentEncoding) {\n    const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n\n    for (const channel of channels) {\n      const channelDef = encoding[channel];\n      const parentChannelDef = parentEncoding[channel];\n\n      if (isFieldOrDatumDef(channelDef)) {\n        // Field/Datum Def can inherit properties from its parent\n        // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n        const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);\n        merged[channel] = mergedChannelDef;\n      } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        merged[channel] = Object.assign(Object.assign({}, channelDef), {\n          condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition)\n        });\n      } else if (channelDef || channelDef === null) {\n        merged[channel] = channelDef;\n      } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray(parentChannelDef)) {\n        merged[channel] = parentChannelDef;\n      }\n    }\n  } else {\n    merged = encoding;\n  }\n\n  return !merged || isEmpty(merged) ? undefined : merged;\n}\n\nfunction mergeProjection(opt) {\n  const {\n    parentProjection,\n    projection\n  } = opt;\n\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection,\n      projection\n    }));\n  }\n\n  return projection !== null && projection !== void 0 ? projection : parentProjection;\n}","map":{"version":3,"sources":["../../../src/normalize/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n    constructor() {\n        super(...arguments);\n        this.nonFacetUnitNormalizers = [\n            boxPlotNormalizer,\n            errorBarNormalizer,\n            errorBandNormalizer,\n            new PathOverlayNormalizer(),\n            new RuleForRangedLineNormalizer()\n        ];\n    }\n    map(spec, params) {\n        // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n        if (isUnitSpec(spec)) {\n            const hasRow = channelHasField(spec.encoding, ROW);\n            const hasColumn = channelHasField(spec.encoding, COLUMN);\n            const hasFacet = channelHasField(spec.encoding, FACET);\n            if (hasRow || hasColumn || hasFacet) {\n                return this.mapFacetedUnit(spec, params);\n            }\n        }\n        return super.map(spec, params);\n    }\n    // This is for normalizing non-facet unit\n    mapUnit(spec, params) {\n        const { parentEncoding, parentProjection } = params;\n        const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n        const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), (encoding ? { encoding } : {}));\n        if (parentEncoding || parentProjection) {\n            return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n        }\n        const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n        for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n            if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n                return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n            }\n        }\n        return specWithReplacedEncoding;\n    }\n    mapRepeat(spec, params) {\n        if (isLayerRepeatSpec(spec)) {\n            return this.mapLayerRepeat(spec, params);\n        }\n        else {\n            return this.mapNonLayerRepeat(spec, params);\n        }\n    }\n    mapLayerRepeat(spec, params) {\n        const { repeat, spec: childSpec } = spec, rest = __rest(spec, [\"repeat\", \"spec\"]);\n        const { row, column, layer } = repeat;\n        const { repeater = {}, repeaterPrefix = '' } = params;\n        if (row || column) {\n            return this.mapRepeat(Object.assign(Object.assign({}, spec), { repeat: Object.assign(Object.assign({}, (row ? { row } : {})), (column ? { column } : {})), spec: {\n                    repeat: { layer },\n                    spec: childSpec\n                } }), params);\n        }\n        else {\n            return Object.assign(Object.assign({}, rest), { layer: layer.map(layerValue => {\n                    const childRepeater = Object.assign(Object.assign({}, repeater), { layer: layerValue });\n                    const childName = `${(childSpec.name || '') + repeaterPrefix}child__layer_${varName(layerValue)}`;\n                    const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));\n                    child.name = childName;\n                    return child;\n                }) });\n        }\n    }\n    mapNonLayerRepeat(spec, params) {\n        var _a;\n        const { repeat, spec: childSpec, data } = spec, remainingProperties = __rest(spec, [\"repeat\", \"spec\", \"data\"]);\n        if (!isArray(repeat) && spec.columns) {\n            // is repeat with row/column\n            spec = omit(spec, ['columns']);\n            log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n        }\n        const concat = [];\n        const { repeater = {}, repeaterPrefix = '' } = params;\n        const row = (!isArray(repeat) && repeat.row) || [repeater ? repeater.row : null];\n        const column = (!isArray(repeat) && repeat.column) || [repeater ? repeater.column : null];\n        const repeatValues = (isArray(repeat) && repeat) || [repeater ? repeater.repeat : null];\n        // cross product\n        for (const repeatValue of repeatValues) {\n            for (const rowValue of row) {\n                for (const columnValue of column) {\n                    const childRepeater = {\n                        repeat: repeatValue,\n                        row: rowValue,\n                        column: columnValue,\n                        layer: repeater.layer\n                    };\n                    const childName = (childSpec.name || '') +\n                        repeaterPrefix +\n                        'child__' +\n                        (isArray(repeat)\n                            ? `${varName(repeatValue)}`\n                            : (repeat.row ? `row_${varName(rowValue)}` : '') +\n                                (repeat.column ? `column_${varName(columnValue)}` : ''));\n                    const child = this.map(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));\n                    child.name = childName;\n                    // we move data up\n                    concat.push(omit(child, ['data']));\n                }\n            }\n        }\n        const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n        return Object.assign(Object.assign({ data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data, align: 'all' }, remainingProperties), { columns,\n            concat });\n    }\n    mapFacet(spec, params) {\n        const { facet } = spec;\n        if (isFacetMapping(facet) && spec.columns) {\n            // is facet with row/column\n            spec = omit(spec, ['columns']);\n            log.warn(log.message.columnsNotSupportByRowCol('facet'));\n        }\n        return super.mapFacet(spec, params);\n    }\n    mapUnitWithParentEncodingOrProjection(spec, params) {\n        const { encoding, projection } = spec;\n        const { parentEncoding, parentProjection, config } = params;\n        const mergedProjection = mergeProjection({ parentProjection, projection });\n        const mergedEncoding = mergeEncoding({\n            parentEncoding,\n            encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n        });\n        return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), (mergedProjection ? { projection: mergedProjection } : {})), (mergedEncoding ? { encoding: mergedEncoding } : {})), { config });\n    }\n    mapFacetedUnit(spec, normParams) {\n        // New encoding in the inside spec should not contain row / column\n        // as row/column should be moved to facet\n        const _a = spec.encoding, { row, column, facet } = _a, encoding = __rest(_a, [\"row\", \"column\", \"facet\"]);\n        // Mark and encoding should be moved into the inner spec\n        const { mark, width, projection, height, view, params, encoding: _ } = spec, outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"view\", \"params\", \"encoding\"]);\n        const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, normParams);\n        const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n        return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), { \n            // row / column has higher precedence than facet\n            facet: facetMapping, spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (width ? { width } : {})), (height ? { height } : {})), (view ? { view } : {})), (projection ? { projection } : {})), { mark, encoding: newEncoding }), (params ? { params } : {})) }), normParams);\n    }\n    getFacetMappingAndLayout(facets, params) {\n        var _a;\n        const { row, column, facet } = facets;\n        if (row || column) {\n            if (facet) {\n                log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n            }\n            const facetMapping = {};\n            const layout = {};\n            for (const channel of [ROW, COLUMN]) {\n                const def = facets[channel];\n                if (def) {\n                    const { align, center, spacing, columns } = def, defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n                    facetMapping[channel] = defWithoutLayout;\n                    for (const prop of ['align', 'center', 'spacing']) {\n                        if (def[prop] !== undefined) {\n                            (_a = layout[prop]) !== null && _a !== void 0 ? _a : (layout[prop] = {});\n                            layout[prop][channel] = def[prop];\n                        }\n                    }\n                }\n            }\n            return { facetMapping, layout };\n        }\n        else {\n            const { align, center, spacing, columns } = facet, facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n            return {\n                facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n                layout: Object.assign(Object.assign(Object.assign(Object.assign({}, (align ? { align } : {})), (center ? { center } : {})), (spacing ? { spacing } : {})), (columns ? { columns } : {}))\n            };\n        }\n    }\n    mapLayer(spec, _a) {\n        // Special handling for extended layer spec\n        var { parentEncoding, parentProjection } = _a, otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n        const { encoding, projection } = spec, rest = __rest(spec, [\"encoding\", \"projection\"]);\n        const params = Object.assign(Object.assign({}, otherParams), { parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }), parentProjection: mergeProjection({ parentProjection, projection }) });\n        return super.mapLayer(rest, params);\n    }\n}\nfunction mergeEncoding({ parentEncoding, encoding = {}, layer }) {\n    let merged = {};\n    if (parentEncoding) {\n        const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n        for (const channel of channels) {\n            const channelDef = encoding[channel];\n            const parentChannelDef = parentEncoding[channel];\n            if (isFieldOrDatumDef(channelDef)) {\n                // Field/Datum Def can inherit properties from its parent\n                // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n                const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);\n                merged[channel] = mergedChannelDef;\n            }\n            else if (hasConditionalFieldOrDatumDef(channelDef)) {\n                merged[channel] = Object.assign(Object.assign({}, channelDef), { condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition) });\n            }\n            else if (channelDef || channelDef === null) {\n                merged[channel] = channelDef;\n            }\n            else if (layer ||\n                isValueDef(parentChannelDef) ||\n                isSignalRef(parentChannelDef) ||\n                isFieldOrDatumDef(parentChannelDef) ||\n                isArray(parentChannelDef)) {\n                merged[channel] = parentChannelDef;\n            }\n        }\n    }\n    else {\n        merged = encoding;\n    }\n    return !merged || isEmpty(merged) ? undefined : merged;\n}\nfunction mergeProjection(opt) {\n    const { parentProjection, projection } = opt;\n    if (parentProjection && projection) {\n        log.warn(log.message.projectionOverridden({ parentProjection, projection }));\n    }\n    return projection !== null && projection !== void 0 ? projection : parentProjection;\n}\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"module"}