{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Buffer, Transform, Framebuffer, Texture2D, readPixelsToArray } from '@luma.gl/core';\nimport { padBuffer, getAttributeTypeFromSize, getSourceBufferAttribute, getAttributeBufferLength, cycleBuffers } from '../lib/attribute/attribute-transition-utils';\nimport Attribute from '../lib/attribute/attribute';\nimport Transition from './transition';\n\nvar GPUSpringTransition = /*#__PURE__*/function () {\n  function GPUSpringTransition(_ref) {\n    _classCallCheck(this, GPUSpringTransition);\n\n    var gl = _ref.gl,\n        attribute = _ref.attribute,\n        timeline = _ref.timeline;\n    this.gl = gl;\n    this.type = 'spring';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    this.attributeInTransition = new Attribute(gl, _objectSpread({}, attribute.settings, {\n      normalized: false\n    }));\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = 0;\n    this.texture = getTexture(gl);\n    this.framebuffer = getFramebuffer(gl, this.texture);\n    this.transform = getTransform(gl, attribute, this.framebuffer);\n    var bufferOpts = {\n      byteLength: 0,\n      usage: 35050\n    };\n    this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];\n  }\n\n  _createClass(GPUSpringTransition, [{\n    key: \"start\",\n    value: function start(transitionSettings, numInstances) {\n      var gl = this.gl,\n          buffers = this.buffers,\n          attribute = this.attribute;\n      var padBufferOpts = {\n        numInstances: numInstances,\n        attribute: attribute,\n        fromLength: this.currentLength,\n        fromStartIndices: this.currentStartIndices,\n        getData: transitionSettings.enter\n      };\n\n      var _iterator = _createForOfIteratorHelper(buffers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var buffer = _step.value;\n          padBuffer(_objectSpread({\n            buffer: buffer\n          }, padBufferOpts));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.currentStartIndices = attribute.startIndices;\n      this.currentLength = getAttributeBufferLength(attribute, numInstances);\n      this.attributeInTransition.update({\n        buffer: buffers[1],\n        value: attribute.value\n      });\n      this.transition.start(transitionSettings);\n      this.transform.update({\n        elementCount: Math.floor(this.currentLength / attribute.size),\n        sourceBuffers: {\n          aTo: getSourceBufferAttribute(gl, attribute)\n        }\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var buffers = this.buffers,\n          transform = this.transform,\n          framebuffer = this.framebuffer,\n          transition = this.transition;\n      var updated = transition.update();\n\n      if (!updated) {\n        return false;\n      }\n\n      transform.update({\n        sourceBuffers: {\n          aPrev: buffers[0],\n          aCur: buffers[1]\n        },\n        feedbackBuffers: {\n          vNext: buffers[2]\n        }\n      });\n      transform.run({\n        framebuffer: framebuffer,\n        discard: false,\n        clearRenderTarget: true,\n        uniforms: {\n          stiffness: transition.settings.stiffness,\n          damping: transition.settings.damping\n        },\n        parameters: {\n          depthTest: false,\n          blend: true,\n          viewport: [0, 0, 1, 1],\n          blendFunc: [1, 1],\n          blendEquation: [32776, 32776]\n        }\n      });\n      cycleBuffers(buffers);\n      this.attributeInTransition.update({\n        buffer: buffers[1],\n        value: this.attribute.value\n      });\n      var isTransitioning = readPixelsToArray(framebuffer)[0] > 0;\n\n      if (!isTransitioning) {\n        transition.end();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.transition.cancel();\n      this.transform.delete();\n\n      while (this.buffers.length) {\n        this.buffers.pop().delete();\n      }\n\n      this.texture.delete();\n      this.texture = null;\n      this.framebuffer.delete();\n      this.framebuffer = null;\n    }\n  }, {\n    key: \"inProgress\",\n    get: function get() {\n      return this.transition.inProgress;\n    }\n  }]);\n\n  return GPUSpringTransition;\n}();\n\nexport { GPUSpringTransition as default };\n\nfunction getTransform(gl, attribute, framebuffer) {\n  var attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    framebuffer: framebuffer,\n    vs: \"\\n#define SHADER_NAME spring-transition-vertex-shader\\n\\n#define EPSILON 0.00001\\n\\nuniform float stiffness;\\nuniform float damping;\\nattribute ATTRIBUTE_TYPE aPrev;\\nattribute ATTRIBUTE_TYPE aCur;\\nattribute ATTRIBUTE_TYPE aTo;\\nvarying ATTRIBUTE_TYPE vNext;\\nvarying float vIsTransitioningFlag;\\n\\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\\n  ATTRIBUTE_TYPE velocity = cur - prev;\\n  ATTRIBUTE_TYPE delta = dest - cur;\\n  ATTRIBUTE_TYPE spring = delta * stiffness;\\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\\n  return spring + damper + velocity + cur;\\n}\\n\\nvoid main(void) {\\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\\n\\n  vNext = getNextValue(aCur, aPrev, aTo);\\n  gl_Position = vec4(0, 0, 0, 1);\\n  gl_PointSize = 100.0;\\n}\\n\",\n    fs: \"\\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\\n\\nvarying float vIsTransitioningFlag;\\n\\nvoid main(void) {\\n  if (vIsTransitioningFlag == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor = vec4(1.0);\\n}\",\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vNext']\n  });\n}\n\nfunction getTexture(gl) {\n  return new Texture2D(gl, {\n    data: new Uint8Array(4),\n    format: 6408,\n    type: 5121,\n    border: 0,\n    mipmaps: false,\n    dataFormat: 6408,\n    width: 1,\n    height: 1\n  });\n}\n\nfunction getFramebuffer(gl, texture) {\n  return new Framebuffer(gl, {\n    id: 'spring-transition-is-transitioning-framebuffer',\n    width: 1,\n    height: 1,\n    attachments: _defineProperty({}, 36064, texture)\n  });\n}","map":{"version":3,"sources":["../../../src/transitions/gpu-spring-transition.js"],"names":["constructor","timeline","attribute","normalized","getTexture","getFramebuffer","getTransform","bufferOpts","byteLength","usage","padBufferOpts","numInstances","fromLength","fromStartIndices","getData","transitionSettings","enter","padBuffer","buffer","getAttributeBufferLength","buffers","value","elementCount","Math","sourceBuffers","aTo","getSourceBufferAttribute","transition","updated","transform","aPrev","aCur","feedbackBuffers","vNext","framebuffer","discard","clearRenderTarget","uniforms","stiffness","damping","parameters","depthTest","blend","viewport","blendFunc","blendEquation","cycleBuffers","isTransitioning","readPixelsToArray","attributeType","getAttributeTypeFromSize","vs","fs","defines","ATTRIBUTE_TYPE","varyings","data","format","type","border","mipmaps","dataFormat","width","height","id","attachments","texture"],"mappings":"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","sourcesContent":["/* eslint-disable complexity, max-statements, max-params */\nimport GL from '@luma.gl/constants';\nimport {Buffer, Transform, Framebuffer, Texture2D, readPixelsToArray} from '@luma.gl/core';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers\n} from '../lib/attribute/attribute-transition-utils';\nimport Attribute from '../lib/attribute/attribute';\nimport Transition from './transition';\n\nexport default class GPUSpringTransition {\n  constructor({gl, attribute, timeline}) {\n    this.gl = gl;\n    this.type = 'spring';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, {...attribute.settings, normalized: false});\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.texture = getTexture(gl);\n    this.framebuffer = getFramebuffer(gl, this.texture);\n    this.transform = getTransform(gl, attribute, this.framebuffer);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // previous\n      new Buffer(gl, bufferOpts), // current\n      new Buffer(gl, bufferOpts) // next\n    ];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings, numInstances) {\n    const {gl, buffers, attribute} = this;\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value\n    });\n\n    // when an attribute changes values, a new transition is started. These\n    // are properties that we have to store on this.transition but can change\n    // when new transitions are started, so we have to keep them up-to-date.\n    // this.transition.start() takes the latest settings and updates them.\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aTo: getSourceBufferAttribute(gl, attribute)\n      }\n    });\n  }\n\n  update() {\n    const {buffers, transform, framebuffer, transition} = this;\n    const updated = transition.update();\n    if (!updated) {\n      return false;\n    }\n\n    transform.update({\n      sourceBuffers: {\n        aPrev: buffers[0],\n        aCur: buffers[1]\n      },\n      feedbackBuffers: {\n        vNext: buffers[2]\n      }\n    });\n    transform.run({\n      framebuffer,\n      discard: false,\n      clearRenderTarget: true,\n      uniforms: {\n        stiffness: transition.settings.stiffness,\n        damping: transition.settings.damping\n      },\n      parameters: {\n        depthTest: false,\n        blend: true,\n        viewport: [0, 0, 1, 1],\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: [GL.MAX, GL.MAX]\n      }\n    });\n\n    cycleBuffers(buffers);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: this.attribute.value\n    });\n\n    const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;\n\n    if (!isTransitioning) {\n      transition.end();\n    }\n\n    return true;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n    while (this.buffers.length) {\n      this.buffers.pop().delete();\n    }\n    this.texture.delete();\n    this.texture = null;\n    this.framebuffer.delete();\n    this.framebuffer = null;\n  }\n}\n\nfunction getTransform(gl, attribute, framebuffer) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    framebuffer,\n    vs: `\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n`,\n    fs: `\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}`,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vNext']\n  });\n}\n\nfunction getTexture(gl) {\n  return new Texture2D(gl, {\n    data: new Uint8Array(4),\n    format: GL.RGBA,\n    type: GL.UNSIGNED_BYTE,\n    border: 0,\n    mipmaps: false,\n    dataFormat: GL.RGBA,\n    width: 1,\n    height: 1\n  });\n}\n\nfunction getFramebuffer(gl, texture) {\n  return new Framebuffer(gl, {\n    id: 'spring-transition-is-transitioning-framebuffer',\n    width: 1,\n    height: 1,\n    attachments: {\n      [GL.COLOR_ATTACHMENT0]: texture\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}