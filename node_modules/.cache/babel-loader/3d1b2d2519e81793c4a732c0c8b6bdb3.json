{"ast":null,"code":"const defaultGetValue = points => points.length;\n\nimport { clamp, getQuantileDomain, getOrdinalDomain } from './scale-utils';\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n\nconst defaultGetPoints = bin => bin.points;\n\nconst defaultGetIndex = bin => bin.index;\n\nconst ascending = (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n\nconst defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\nexport default class BinSorter {\n  constructor() {\n    let bins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultProps;\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n\n    this._updateMinMaxValues();\n\n    this.binMap = this.getBinMap();\n  }\n\n  getAggregatedBins(bins, props) {\n    const {\n      getValue = defaultGetValue,\n      getPoints = defaultGetPoints,\n      getIndex = defaultGetIndex,\n      filterData\n    } = props;\n    const hasFilter = typeof filterData === 'function';\n    const binCount = bins.length;\n    const aggregatedBins = [];\n    let index = 0;\n\n    for (let binIndex = 0; binIndex < binCount; binIndex++) {\n      const bin = bins[binIndex];\n      const points = getPoints(bin);\n      const i = getIndex(bin);\n      const filteredPoints = hasFilter ? points.filter(filterData) : points;\n      bin.filteredPoints = hasFilter ? filteredPoints : null;\n      const value = filteredPoints.length ? getValue(filteredPoints) : null;\n\n      if (value !== null && value !== undefined) {\n        aggregatedBins[index] = {\n          i: Number.isFinite(i) ? i : binIndex,\n          value,\n          counts: filteredPoints.length\n        };\n        index++;\n      }\n    }\n\n    return aggregatedBins;\n  }\n\n  _percentileToIndex(percentileRange) {\n    const len = this.sortedBins.length;\n\n    if (len < 2) {\n      return [0, 0];\n    }\n\n    const [lower, upper] = percentileRange.map(n => clamp(n, 0, 100));\n    const lowerIdx = Math.ceil(lower / 100 * (len - 1));\n    const upperIdx = Math.floor(upper / 100 * (len - 1));\n    return [lowerIdx, upperIdx];\n  }\n\n  getBinMap() {\n    const binMap = {};\n\n    for (const bin of this.aggregatedBins) {\n      binMap[bin.i] = bin;\n    }\n\n    return binMap;\n  }\n\n  _updateMinMaxValues() {\n    let maxCount = 0;\n    let maxValue = 0;\n    let minValue = MAX_32_BIT_FLOAT;\n    let totalCount = 0;\n\n    for (const x of this.aggregatedBins) {\n      maxCount = maxCount > x.counts ? maxCount : x.counts;\n      maxValue = maxValue > x.value ? maxValue : x.value;\n      minValue = minValue < x.value ? minValue : x.value;\n      totalCount += x.counts;\n    }\n\n    this.maxCount = maxCount;\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n    this.totalCount = totalCount;\n  }\n\n  getValueRange(percentileRange) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n\n    if (!this.sortedBins.length) {\n      return [];\n    }\n\n    let lowerIdx = 0;\n    let upperIdx = this.sortedBins.length - 1;\n\n    if (Array.isArray(percentileRange)) {\n      const idxRange = this._percentileToIndex(percentileRange);\n\n      lowerIdx = idxRange[0];\n      upperIdx = idxRange[1];\n    }\n\n    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n  }\n\n  getValueDomainByScale(scale) {\n    let [lower = 0, upper = 100] = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n\n    if (!this.sortedBins.length) {\n      return [];\n    }\n\n    const indexEdge = this._percentileToIndex([lower, upper]);\n\n    return this._getScaleDomain(scale, indexEdge);\n  }\n\n  _getScaleDomain(scaleType, _ref) {\n    let [lowerIdx, upperIdx] = _ref;\n    const bins = this.sortedBins;\n\n    switch (scaleType) {\n      case 'quantize':\n      case 'linear':\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n\n      case 'quantile':\n        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), d => d.value);\n\n      case 'ordinal':\n        return getOrdinalDomain(bins, d => d.value);\n\n      default:\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/utils/bin-sorter.js"],"names":["defaultGetValue","points","MAX_32_BIT_FLOAT","defaultGetPoints","bin","defaultGetIndex","ascending","a","defaultProps","getValue","getPoints","getIndex","filterData","constructor","bins","props","getAggregatedBins","hasFilter","binCount","aggregatedBins","index","binIndex","i","filteredPoints","value","Number","counts","length","_percentileToIndex","len","percentileRange","n","clamp","lowerIdx","Math","lower","upperIdx","upper","getBinMap","binMap","_updateMinMaxValues","maxCount","maxValue","minValue","totalCount","x","getValueRange","b","Array","idxRange","getValueDomainByScale","indexEdge","_getScaleDomain","getQuantileDomain","d","getOrdinalDomain"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// getValue takes an array of points returns a value to sort the bins on.\n// by default it returns the number of points\n// this is where to pass in a function to color the bins by\n// avg/mean/max of specific value of the point\nconst defaultGetValue = points => points.length;\n\nimport {clamp, getQuantileDomain, getOrdinalDomain} from './scale-utils';\n\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n\n// access array of points in each bin\nconst defaultGetPoints = bin => bin.points;\n// access index of each bin\nconst defaultGetIndex = bin => bin.index;\n\n// d3-scending\nconst ascending = (a, b) => (a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN);\n\nconst defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\n\nexport default class BinSorter {\n  constructor(bins = [], props = defaultProps) {\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n    this._updateMinMaxValues();\n    this.binMap = this.getBinMap();\n  }\n\n  /**\n   * Get an array of object with aggregated values and index of bins\n   * Array object will be sorted by value optionally.\n   * @param {Array} bins\n   * @param {Function} getValue\n   * @return {Array} array of values and index lookup\n   */\n  getAggregatedBins(bins, props) {\n    const {\n      getValue = defaultGetValue,\n      getPoints = defaultGetPoints,\n      getIndex = defaultGetIndex,\n      filterData\n    } = props;\n\n    const hasFilter = typeof filterData === 'function';\n    const binCount = bins.length;\n    const aggregatedBins = [];\n    let index = 0;\n\n    for (let binIndex = 0; binIndex < binCount; binIndex++) {\n      const bin = bins[binIndex];\n      const points = getPoints(bin);\n      const i = getIndex(bin);\n\n      const filteredPoints = hasFilter ? points.filter(filterData) : points;\n\n      bin.filteredPoints = hasFilter ? filteredPoints : null;\n\n      const value = filteredPoints.length ? getValue(filteredPoints) : null;\n\n      if (value !== null && value !== undefined) {\n        // filter bins if value is null or undefined\n        aggregatedBins[index] = {\n          i: Number.isFinite(i) ? i : binIndex,\n          value,\n          counts: filteredPoints.length\n        };\n        index++;\n      }\n    }\n    return aggregatedBins;\n  }\n\n  _percentileToIndex(percentileRange) {\n    const len = this.sortedBins.length;\n    if (len < 2) {\n      return [0, 0];\n    }\n\n    const [lower, upper] = percentileRange.map(n => clamp(n, 0, 100));\n\n    const lowerIdx = Math.ceil((lower / 100) * (len - 1));\n    const upperIdx = Math.floor((upper / 100) * (len - 1));\n\n    return [lowerIdx, upperIdx];\n  }\n\n  /**\n   * Get a mapping from cell/hexagon index to sorted bin\n   * This is used to retrieve bin value for color calculation\n   * @return {Object} bin index to aggregatedBins\n   */\n  getBinMap() {\n    const binMap = {};\n    for (const bin of this.aggregatedBins) {\n      binMap[bin.i] = bin;\n    }\n    return binMap;\n  }\n\n  // Private\n\n  /**\n   * Get ths max count of all bins\n   * @return {Number | Boolean} max count\n   */\n  _updateMinMaxValues() {\n    let maxCount = 0;\n    let maxValue = 0;\n    let minValue = MAX_32_BIT_FLOAT;\n    let totalCount = 0;\n    for (const x of this.aggregatedBins) {\n      maxCount = maxCount > x.counts ? maxCount : x.counts;\n      maxValue = maxValue > x.value ? maxValue : x.value;\n      minValue = minValue < x.value ? minValue : x.value;\n      totalCount += x.counts;\n    }\n    this.maxCount = maxCount;\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n    this.totalCount = totalCount;\n  }\n\n  /**\n   * Get range of values of all bins\n   * @param {Number[]} range\n   * @param {Number} range[0] - lower bound\n   * @param {Number} range[1] - upper bound\n   * @return {Array} array of new value range\n   */\n  getValueRange(percentileRange) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      return [];\n    }\n    let lowerIdx = 0;\n    let upperIdx = this.sortedBins.length - 1;\n\n    if (Array.isArray(percentileRange)) {\n      const idxRange = this._percentileToIndex(percentileRange);\n      lowerIdx = idxRange[0];\n      upperIdx = idxRange[1];\n    }\n\n    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n  }\n\n  getValueDomainByScale(scale, [lower = 0, upper = 100] = []) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      return [];\n    }\n    const indexEdge = this._percentileToIndex([lower, upper]);\n\n    return this._getScaleDomain(scale, indexEdge);\n  }\n\n  _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {\n    const bins = this.sortedBins;\n\n    switch (scaleType) {\n      case 'quantize':\n      case 'linear':\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n\n      case 'quantile':\n        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), d => d.value);\n\n      case 'ordinal':\n        return getOrdinalDomain(bins, d => d.value);\n\n      default:\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}