{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n  var _a, _b, _c, _d;\n\n  var config = model.config,\n      encoding = model.encoding,\n      markDef = model.markDef;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var sizeChannel = getSizeChannel(channel);\n  var channelDef = encoding[channel];\n  var channelDef2 = encoding[channel2];\n  var scale = model.getScaleComponent(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n  var scaleName = model.scaleName(channel);\n  var orient = markDef.orient;\n  var hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  var isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal'); // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !hasDiscreteDomain(scaleType)) {\n    var bandSize = getBandSize({\n      channel: channel,\n      fieldDef: channelDef,\n      markDef: markDef,\n      config: config,\n      scaleType: scaleType\n    });\n    var axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n    var axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel: channel,\n      markDef: markDef,\n      scaleName: scaleName,\n      bandSize: bandSize,\n      axisTranslate: axisTranslate,\n      spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n      reverse: scale.get('reverse'),\n      config: config\n    });\n  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType) || isBarBand) && !channelDef2) {\n    return positionAndSize(channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {\n  if (isRelativeBandSize(bandSize)) {\n    if (scale) {\n      var scaleType = scale.get('type');\n\n      if (scaleType === 'band') {\n        return {\n          scale: scaleName,\n          band: bandSize.band\n        };\n      } else if (bandSize.band !== 1) {\n        log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n        bandSize = undefined;\n      }\n    } else {\n      return {\n        mult: bandSize.band,\n        field: {\n          group: sizeChannel\n        }\n      };\n    }\n  } else if (isSignalRef(bandSize)) {\n    return bandSize;\n  } else if (bandSize) {\n    return {\n      value: bandSize\n    };\n  } // no valid band size\n\n\n  if (scale) {\n    var scaleRange = scale.get('range');\n\n    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n      return {\n        value: scaleRange.step - 2\n      };\n    }\n  }\n\n  var defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n  return {\n    value: defaultStep - 2\n  };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\n\n\nfunction positionAndSize(fieldDef, channel, model) {\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config,\n      stack = model.stack;\n  var orient = markDef.orient;\n  var scaleName = model.scaleName(channel);\n  var scale = model.getScaleComponent(channel);\n  var vgSizeChannel = getSizeChannel(channel);\n  var channel2 = getSecondaryRangeChannel(channel); // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n\n  var useVlSizeChannel = orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x'; // Use size encoding / mark property / config if it exists\n\n  var sizeMixins;\n\n  if (encoding.size || markDef.size) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultRef: signalOrValueRef(markDef.size)\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  } // Otherwise, apply default value\n\n\n  var bandSize = getBandSize({\n    channel: channel,\n    fieldDef: fieldDef,\n    markDef: markDef,\n    config: config,\n    scaleType: scale === null || scale === void 0 ? void 0 : scale.get('type'),\n    useVlSizeChannel: useVlSizeChannel\n  });\n  sizeMixins = sizeMixins || _defineProperty({}, vgSizeChannel, defaultSizeRef(vgSizeChannel, scaleName, scale, config, bandSize));\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n       Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n\n  var defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]) ? 'middle' : 'top';\n  var vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n  var center = vgChannel === 'xc' || vgChannel === 'yc';\n  var offset = getOffset(channel, markDef);\n  var posRef = ref.midPointRefWithPositionInvalidTest({\n    channel: channel,\n    channelDef: fieldDef,\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: pointPositionDefaultRef({\n      model: model,\n      defaultPos: 'mid',\n      channel: channel,\n      scaleName: scaleName,\n      scale: scale\n    }),\n    bandPosition: center ? 0.5 : isSignalRef(bandSize) ? {\n      signal: \"(1-\".concat(bandSize, \")/2\")\n    } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0\n  });\n\n  if (vgSizeChannel) {\n    return Object.assign(_defineProperty({}, vgChannel, posRef), sizeMixins);\n  } else {\n    var _ref2;\n\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    var vgChannel2 = getVgPositionChannel(channel2);\n    var sizeRef = sizeMixins[vgSizeChannel];\n    var sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), {\n      offset: offset\n    }) : sizeRef;\n    return _ref2 = {}, _defineProperty(_ref2, vgChannel, posRef), _defineProperty(_ref2, vgChannel2, isArray(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), {\n      offset: sizeOffset\n    })] : Object.assign(Object.assign({}, posRef), {\n      offset: sizeOffset\n    })), _ref2;\n  }\n}\n\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n\n  var spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n    var reverseExpr = signalOrStringValue(reverse);\n    var offsetExpr = signalOrStringValue(offset);\n    var translateExpr = signalOrStringValue(translate);\n    var t = translateExpr ? \"\".concat(translateExpr, \" + \") : '';\n    var r = reverseExpr ? \"(\".concat(reverseExpr, \" ? -1 : 1) * \") : '';\n    var o = offsetExpr ? \"(\".concat(offsetExpr, \" + \").concat(spacingOffset, \")\") : spacingOffset;\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\n\nexport function rectBinPosition(_ref3) {\n  var fieldDef = _ref3.fieldDef,\n      fieldDef2 = _ref3.fieldDef2,\n      channel = _ref3.channel,\n      bandSize = _ref3.bandSize,\n      scaleName = _ref3.scaleName,\n      markDef = _ref3.markDef,\n      _ref3$spacing = _ref3.spacing,\n      spacing = _ref3$spacing === void 0 ? 0 : _ref3$spacing,\n      axisTranslate = _ref3.axisTranslate,\n      reverse = _ref3.reverse,\n      config = _ref3.config;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var vgChannel = getVgPositionChannel(channel);\n  var vgChannel2 = getVgPositionChannel(channel2);\n  var offset = getOffset(channel, markDef);\n  var bandPosition = isSignalRef(bandSize) ? {\n    signal: \"(1-\".concat(bandSize.signal, \")/2\")\n  } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    var _ref4;\n\n    return _ref4 = {}, _defineProperty(_ref4, vgChannel2, rectBinRef({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      bandPosition: bandPosition,\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n      config: config\n    })), _defineProperty(_ref4, vgChannel, rectBinRef({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      bandPosition: isSignalRef(bandPosition) ? {\n        signal: \"1-\".concat(bandPosition.signal)\n      } : 1 - bandPosition,\n      offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n      config: config\n    })), _ref4;\n  } else if (isBinned(fieldDef.bin)) {\n    var startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n    });\n\n    if (isFieldDef(fieldDef2)) {\n      var _ref5;\n\n      return _ref5 = {}, _defineProperty(_ref5, vgChannel2, startRef), _defineProperty(_ref5, vgChannel, ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      })), _ref5;\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      var _ref6;\n\n      return _ref6 = {}, _defineProperty(_ref6, vgChannel2, startRef), _defineProperty(_ref6, vgChannel, {\n        signal: \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(vgField(fieldDef, {\n          expr: 'datum'\n        }), \" + \").concat(fieldDef.bin.step, \")\"),\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      }), _ref6;\n    }\n  }\n\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function rectBinRef(_ref7) {\n  var channel = _ref7.channel,\n      fieldDef = _ref7.fieldDef,\n      scaleName = _ref7.scaleName,\n      markDef = _ref7.markDef,\n      bandPosition = _ref7.bandPosition,\n      offset = _ref7.offset,\n      config = _ref7.config;\n  var r = ref.interpolatedSignalRef({\n    scaleName: scaleName,\n    fieldOrDatumDef: fieldDef,\n    bandPosition: bandPosition,\n    offset: offset\n  });\n  return ref.wrapPositionInvalidTest({\n    fieldDef: fieldDef,\n    channel: channel,\n    markDef: markDef,\n    ref: r,\n    config: config\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-rect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n    var _a, _b, _c, _d;\n    const { config, encoding, markDef } = model;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const channelDef = encoding[channel];\n    const channelDef2 = encoding[channel2];\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const scaleName = model.scaleName(channel);\n    const orient = markDef.orient;\n    const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, { vgChannel: sizeChannel });\n    const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal');\n    // x, x2, and width -- we must specify two of these in all conditions\n    if (isFieldDef(channelDef) &&\n        (isBinning(channelDef.bin) || isBinned(channelDef.bin) || (channelDef.timeUnit && !channelDef2)) &&\n        !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) &&\n        !hasDiscreteDomain(scaleType)) {\n        const bandSize = getBandSize({ channel, fieldDef: channelDef, markDef, config, scaleType });\n        const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n        const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n        return rectBinPosition({\n            fieldDef: channelDef,\n            fieldDef2: channelDef2,\n            channel,\n            markDef,\n            scaleName,\n            bandSize,\n            axisTranslate,\n            spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n            reverse: scale.get('reverse'),\n            config\n        });\n    }\n    else if (((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType)) || isBarBand) && !channelDef2) {\n        return positionAndSize(channelDef, channel, model);\n    }\n    else {\n        return rangePosition(channel, model, { defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin' });\n    }\n}\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {\n    if (isRelativeBandSize(bandSize)) {\n        if (scale) {\n            const scaleType = scale.get('type');\n            if (scaleType === 'band') {\n                return { scale: scaleName, band: bandSize.band };\n            }\n            else if (bandSize.band !== 1) {\n                log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n                bandSize = undefined;\n            }\n        }\n        else {\n            return {\n                mult: bandSize.band,\n                field: { group: sizeChannel }\n            };\n        }\n    }\n    else if (isSignalRef(bandSize)) {\n        return bandSize;\n    }\n    else if (bandSize) {\n        return { value: bandSize };\n    }\n    // no valid band size\n    if (scale) {\n        const scaleRange = scale.get('range');\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n            return { value: scaleRange.step - 2 };\n        }\n    }\n    const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n    return { value: defaultStep - 2 };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(fieldDef, channel, model) {\n    const { markDef, encoding, config, stack } = model;\n    const orient = markDef.orient;\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const vgSizeChannel = getSizeChannel(channel);\n    const channel2 = getSecondaryRangeChannel(channel);\n    // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n    const useVlSizeChannel = (orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x');\n    // Use size encoding / mark property / config if it exists\n    let sizeMixins;\n    if (encoding.size || markDef.size) {\n        if (useVlSizeChannel) {\n            sizeMixins = nonPosition('size', model, {\n                vgChannel: vgSizeChannel,\n                defaultRef: signalOrValueRef(markDef.size)\n            });\n        }\n        else {\n            log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n        }\n    }\n    // Otherwise, apply default value\n    const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scale === null || scale === void 0 ? void 0 : scale.get('type'), useVlSizeChannel });\n    sizeMixins = sizeMixins || { [vgSizeChannel]: defaultSizeRef(vgSizeChannel, scaleName, scale, config, bandSize) };\n    /*\n      Band scales with size value and all point scales, use xc/yc + band=0.5\n  \n      Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n      In this case, size_band is the band specified in the x/y-encoding.\n      By default band is 1, so `(1 - band) / 2` = 0.\n      If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n     */\n    const defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]) ? 'middle' : 'top';\n    const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n    const center = vgChannel === 'xc' || vgChannel === 'yc';\n    const offset = getOffset(channel, markDef);\n    const posRef = ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: fieldDef,\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: pointPositionDefaultRef({ model, defaultPos: 'mid', channel, scaleName, scale }),\n        bandPosition: center\n            ? 0.5\n            : isSignalRef(bandSize)\n                ? { signal: `(1-${bandSize})/2` }\n                : isRelativeBandSize(bandSize)\n                    ? (1 - bandSize.band) / 2\n                    : 0\n    });\n    if (vgSizeChannel) {\n        return Object.assign({ [vgChannel]: posRef }, sizeMixins);\n    }\n    else {\n        // otherwise, we must simulate size by setting position2 = position + size\n        // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n        const vgChannel2 = getVgPositionChannel(channel2);\n        const sizeRef = sizeMixins[vgSizeChannel];\n        const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), { offset }) : sizeRef;\n        return {\n            [vgChannel]: posRef,\n            // posRef might be an array that wraps position invalid test\n            [vgChannel2]: isArray(posRef)\n                ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })]\n                : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })\n        };\n    }\n}\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n    if (isPolarPositionChannel(channel)) {\n        return 0;\n    }\n    const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n    if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n        const reverseExpr = signalOrStringValue(reverse);\n        const offsetExpr = signalOrStringValue(offset);\n        const translateExpr = signalOrStringValue(translate);\n        const t = translateExpr ? `${translateExpr} + ` : '';\n        const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n        const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n        return {\n            signal: t + r + o\n        };\n    }\n    else {\n        offset = offset || 0;\n        return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n    }\n}\nexport function rectBinPosition({ fieldDef, fieldDef2, channel, bandSize, scaleName, markDef, spacing = 0, axisTranslate, reverse, config }) {\n    const channel2 = getSecondaryRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const offset = getOffset(channel, markDef);\n    const bandPosition = isSignalRef(bandSize)\n        ? { signal: `(1-${bandSize.signal})/2` }\n        : isRelativeBandSize(bandSize)\n            ? (1 - bandSize.band) / 2\n            : 0.5;\n    if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n        return {\n            [vgChannel2]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                bandPosition,\n                offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n                config\n            }),\n            [vgChannel]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                bandPosition: isSignalRef(bandPosition) ? { signal: `1-${bandPosition.signal}` } : 1 - bandPosition,\n                offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n                config\n            })\n        };\n    }\n    else if (isBinned(fieldDef.bin)) {\n        const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset) });\n        if (isFieldDef(fieldDef2)) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset) })\n            };\n        }\n        else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: {\n                    signal: `scale(\"${scaleName}\", ${vgField(fieldDef, { expr: 'datum' })} + ${fieldDef.bin.step})`,\n                    offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n                }\n            };\n        }\n    }\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n}\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef({ channel, fieldDef, scaleName, markDef, bandPosition, offset, config }) {\n    const r = ref.interpolatedSignalRef({\n        scaleName,\n        fieldOrDatumDef: fieldDef,\n        bandPosition,\n        offset\n    });\n    return ref.wrapPositionInvalidTest({\n        fieldDef,\n        channel,\n        markDef,\n        ref: r,\n        config\n    });\n}\n//# sourceMappingURL=position-rect.js.map"]},"metadata":{},"sourceType":"module"}