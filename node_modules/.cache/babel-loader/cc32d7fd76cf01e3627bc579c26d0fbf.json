{"ast":null,"code":"import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource';\nimport { AbortError, AggregateError, wait, zip } from '../utils';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n  /**\n   * @returns {number} the top byte border\n   */\n\n\n  get top() {\n    return this.offset + this.length;\n  }\n\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, {\n    blockSize = 65536,\n    cacheSize = 100\n  } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n    this.blockCache = new LRUCache({\n      max: cacheSize\n    }); // mapping blockId -> Block instance\n\n    this.blockRequests = new Map(); // set of blockIds missing for the current requests\n\n    this.blockIdsToFetch = new Set();\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n\n\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n\n    for (const {\n      offset,\n      length\n    } of slices) {\n      let top = offset + length;\n      const {\n        fileSize\n      } = this;\n\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n\n        allBlockIds.push(blockId);\n      }\n    } // allow additional block requests to accumulate\n\n\n    await wait();\n    this.fetchBlocks(signal); // Gather all of the new requests that this fetch call is contributing to `fetch`.\n\n    const missingRequests = [];\n\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    } // Actually await all pending requests that are needed for this `fetch`.\n\n\n    await Promise.allSettled(blockRequests.values());\n    await Promise.allSettled(missingRequests.values()); // Perform retries if a block was interrupted by a previous signal\n\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds.filter(id => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach(id => this.blockIdsToFetch.add(id)); // start the retry of some blocks if required\n\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n\n        abortedBlockRequests.push(block);\n      }\n\n      await Promise.allSettled(Array.from(abortedBlockRequests.values()));\n    } // throw an  abort error\n\n\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map(id => this.blockCache.get(id));\n    const failedBlocks = blocks.filter(i => !i);\n\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    } // create a final Map, with all required blocks for this request to satisfy\n\n\n    const requiredBlocks = new Map(zip(allBlockIds, blocks)); // TODO: satisfy each slice\n\n    return this.readSliceData(slices, requiredBlocks);\n  }\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n\n\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch); // start requesting slices of data\n\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(blockOffset, data.byteLength, data, blockId);\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.del(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n\n      this.blockIdsToFetch.clear();\n    }\n  }\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n\n\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n    return groups;\n  }\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n\n\n  readSliceData(slices, blocks) {\n    return slices.map(slice => {\n      let top = slice.offset + slice.length;\n\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/geotiff/src/source/blockedsource.js"],"names":["LRUCache","BaseSource","AbortError","AggregateError","wait","zip","Block","constructor","offset","length","data","top","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","max","blockRequests","Map","blockIdsToFetch","Set","abortedBlockIds","fileSize","fetch","slices","signal","missingBlockIds","allBlockIds","Math","min","firstBlockOffset","floor","current","blockId","has","add","push","get","fetchBlocks","missingRequests","Promise","allSettled","values","abortedBlockRequests","filter","id","forEach","aborted","block","Error","Array","from","blocks","map","failedBlocks","i","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","groupIndex","group","set","response","blockOffset","o","t","byteLength","slice","delete","err","name","del","clear","sortedBlockIds","sort","a","b","lastBlockId","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","Uint8Array","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView"],"mappings":"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","sourcesContent":["import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource';\nimport { AbortError, AggregateError, wait, zip } from '../utils';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = []\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests.values());\n    await Promise.allSettled(missingRequests.values());\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter(id => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach(id => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(Array.from(abortedBlockRequests.values()));\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.del(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}