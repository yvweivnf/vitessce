{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\n\nexport function pointOrRangePosition(channel, model, {\n  defaultPos,\n  defaultPos2,\n  range\n}) {\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos,\n      defaultPos2\n    });\n  }\n\n  return pointPosition(channel, model, {\n    defaultPos\n  });\n}\nexport function rangePosition(channel, model, {\n  defaultPos,\n  defaultPos2\n}) {\n  const {\n    markDef,\n    config\n  } = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n  const vgChannel = pos2Mixins[sizeChannel] ? // If there is width/height, we need to position the marks based on the alignment.\n  vgAlignedPositionChannel(channel, markDef, config) : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n  getVgPositionChannel(channel);\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos,\n    vgChannel\n  })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\n\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n  const {\n    encoding,\n    mark,\n    markDef,\n    stack,\n    config\n  } = model;\n  const baseChannel = getMainRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n  const offset = channel in encoding || channel in markDef ? getOffset(channel, model.markDef) : getOffset(baseChannel, model.markDef);\n\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    const vgSizeChannel = getSizeChannel(channel);\n    const size = model.markDef[vgSizeChannel];\n\n    if (size != null) {\n      return {\n        [vgSizeChannel]: {\n          value: size\n        }\n      };\n    } else {\n      return {\n        [vgChannel]: {\n          field: model.getName(channel)\n        }\n      };\n    }\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {\n      [vgChannel]: valueRef\n    };\n  } // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n\n  return position2orSize(channel, markDef) || position2orSize(channel, {\n    [channel]: getMarkStyleConfig(channel, markDef, config.style),\n    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n  }) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || {\n    [vgChannel]: pointPositionDefaultRef({\n      model,\n      defaultPos,\n      channel,\n      scaleName,\n      scale\n    })()\n  };\n}\n\nexport function position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}) {\n  if (isFieldOrDatumDef(channelDef) && stack && // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(channel, markDef) {\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n\n  if (markDef[vgChannel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel])\n    };\n  } else if (markDef[channel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel])\n    };\n  } else if (markDef[sizeChannel]) {\n    const dimensionSize = markDef[sizeChannel];\n\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return {\n        [sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize)\n      };\n    }\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-range.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range }) {\n    if (range) {\n        return rangePosition(channel, model, { defaultPos, defaultPos2 });\n    }\n    return pointPosition(channel, model, { defaultPos });\n}\nexport function rangePosition(channel, model, { defaultPos, defaultPos2 }) {\n    const { markDef, config } = model;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n    const vgChannel = pos2Mixins[sizeChannel]\n        ? // If there is width/height, we need to position the marks based on the alignment.\n            vgAlignedPositionChannel(channel, markDef, config)\n        : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n            getVgPositionChannel(channel);\n    return Object.assign(Object.assign({}, pointPosition(channel, model, { defaultPos, vgChannel })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n    const { encoding, mark, markDef, stack, config } = model;\n    const baseChannel = getMainRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const channelDef = encoding[baseChannel];\n    const scaleName = model.scaleName(baseChannel);\n    const scale = model.getScaleComponent(baseChannel);\n    const offset = channel in encoding || channel in markDef\n        ? getOffset(channel, model.markDef)\n        : getOffset(baseChannel, model.markDef);\n    if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n        const vgSizeChannel = getSizeChannel(channel);\n        const size = model.markDef[vgSizeChannel];\n        if (size != null) {\n            return {\n                [vgSizeChannel]: { value: size }\n            };\n        }\n        else {\n            return {\n                [vgChannel]: { field: model.getName(channel) }\n            };\n        }\n    }\n    const valueRef = position2Ref({\n        channel,\n        channelDef,\n        channel2Def: encoding[channel],\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: undefined\n    });\n    if (valueRef !== undefined) {\n        return { [vgChannel]: valueRef };\n    }\n    // TODO: check width/height encoding here once we add them\n    // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n    // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n    return (position2orSize(channel, markDef) ||\n        position2orSize(channel, {\n            [channel]: getMarkStyleConfig(channel, markDef, config.style),\n            [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n        }) ||\n        position2orSize(channel, config[mark]) ||\n        position2orSize(channel, config.mark) || {\n        [vgChannel]: pointPositionDefaultRef({\n            model,\n            defaultPos,\n            channel,\n            scaleName,\n            scale\n        })()\n    });\n}\nexport function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack, offset, defaultRef }) {\n    if (isFieldOrDatumDef(channelDef) &&\n        stack &&\n        // If fieldChannel is X and channel is X2 (or Y and Y2)\n        channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n        return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: 'start' }, { offset });\n    }\n    return ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: channel2Def,\n        scaleName,\n        scale,\n        stack,\n        markDef,\n        config,\n        offset,\n        defaultRef\n    });\n}\nfunction position2orSize(channel, markDef) {\n    const sizeChannel = getSizeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    if (markDef[vgChannel] !== undefined) {\n        return { [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };\n    }\n    else if (markDef[channel] !== undefined) {\n        return { [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel]) };\n    }\n    else if (markDef[sizeChannel]) {\n        const dimensionSize = markDef[sizeChannel];\n        if (isRelativeBandSize(dimensionSize)) {\n            log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n        }\n        else {\n            return { [sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize) };\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=position-range.js.map"]},"metadata":{},"sourceType":"module"}