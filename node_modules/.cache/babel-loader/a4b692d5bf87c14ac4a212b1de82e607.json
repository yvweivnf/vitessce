{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { ANGLE, CHANNELS, COLOR, DESCRIPTION, DETAIL, FILL, FILLOPACITY, HREF, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, supportMark, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, Y, Y2 } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, hasConditionalFieldDef, initChannelDef, initFieldDef, isConditionalDef, isDatumDef, isFieldDef, isTypedFieldDef, isValueDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { QUANTITATIVE, TEMPORAL } from './type';\nimport { keys, some } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function channelHasField(encoding, channel) {\n  const channelDef = encoding && encoding[channel];\n\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n\n  return false;\n}\nexport function isAggregate(encoding) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n\n    return false;\n  });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n  const groupby = [];\n  const bins = [];\n  const timeUnits = [];\n  const aggregate = [];\n  const encoding = {};\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const {\n        field,\n        aggregate: aggOp,\n        bin,\n        timeUnit\n      } = channelDef,\n            remaining = __rest(channelDef, [\"field\", \"aggregate\", \"bin\", \"timeUnit\"]);\n\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;\n        let newField = vgField(channelDef, {\n          forAs: true\n        });\n        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : {\n          title: title(channelDef, config, {\n            allowDisabling: true\n          })\n        }), remaining), {\n          // Always overwrite field\n          field: newField\n        });\n\n        if (aggOp) {\n          let op;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({\n              op: 'argmax',\n              field: aggOp.argmax\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({\n              op: 'argmin',\n              field: aggOp.argmin\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            const aggregateEntry = {\n              op,\n              as: newField\n            };\n\n            if (field) {\n              aggregateEntry.field = field;\n            }\n\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({\n              bin,\n              field,\n              as: newField\n            }); // Add additional groupbys for range and end of bins\n\n            groupby.push(vgField(channelDef, {\n              binSuffix: 'end'\n            }));\n\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {\n                binSuffix: 'range'\n              }));\n            } // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n\n\n            if (isXorY(channel)) {\n              const secondaryChannel = {\n                field: `${newField}_end`\n              };\n              encoding[`${channel}2`] = secondaryChannel;\n            }\n\n            newFieldDef.bin = 'binned';\n\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = QUANTITATIVE;\n            }\n          } else if (timeUnit) {\n            timeUnits.push({\n              timeUnit,\n              field,\n              as: newField\n            }); // define the format type for later compilation\n\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n\n            if (formatType) {\n              if (channel === TEXT || channel === TOOLTIP) {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = Object.assign({\n                  formatType\n                }, newFieldDef['legend']);\n              } else if (isXorY(channel)) {\n                newFieldDef['axis'] = Object.assign({\n                  formatType\n                }, newFieldDef['axis']);\n              }\n            }\n          }\n        } // now the field should refer to post-transformed field instead\n\n\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def / signal ref / datum def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n  const markSupported = supportMark(channel, mark);\n\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === X2 ? X : Y]; // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function initEncoding(encoding, mark, filled, config) {\n  return keys(encoding).reduce((normalizedEncoding, channel) => {\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    const channelDef = encoding[channel];\n\n    if (channel === 'angle' && mark === 'arc' && !encoding.theta) {\n      log.warn(log.message.REPLACE_ANGLE_WITH_THETA);\n      channel = THETA;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    } // Drop line's size if the field is aggregated.\n\n\n    if (channel === SIZE && mark === 'line') {\n      const fieldDef = getFieldDef(encoding[channel]);\n\n      if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    } // Drop color if either fill or stroke is specified\n\n\n    if (channel === COLOR && (filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {\n        fill: 'fill' in encoding,\n        stroke: 'stroke' in encoding\n      }));\n      return normalizedEncoding;\n    }\n\n    if (channel === DETAIL || channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray(channelDef)) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = array(channelDef).reduce((defs, fieldDef) => {\n          if (!isFieldDef(fieldDef)) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          } else {\n            defs.push(initFieldDef(fieldDef, channel));\n          }\n\n          return defs;\n        }, []);\n      }\n    } else {\n      if (channel === TOOLTIP && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n\n      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);\n    }\n\n    return normalizedEncoding;\n  }, {});\n}\n/**\n * For composite marks, we have to call initChannelDef during init so we can infer types earlier.\n */\n\nexport function normalizeEncoding(encoding, config) {\n  const normalizedEncoding = {};\n\n  for (const channel of keys(encoding)) {\n    const newChannelDef = initChannelDef(encoding[channel], channel, config, {\n      compositeMark: true\n    });\n    normalizedEncoding[channel] = newChannelDef;\n  }\n\n  return normalizedEncoding;\n}\nexport function fieldDefs(encoding) {\n  const arr = [];\n\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      const channelDefArray = array(channelDef);\n\n      for (const def of channelDefArray) {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      }\n    }\n  }\n\n  return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n\n    if (isArray(el)) {\n      for (const channelDef of el) {\n        f.call(thisArg, channelDef, channel);\n      }\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\nexport function reduce(mapping, f, init, thisArg) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n\n    if (isArray(map)) {\n      return map.reduce((r1, channelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\n\nexport function pathGroupingFields(mark, encoding) {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group\n      case X:\n      case Y:\n      case HREF:\n      case DESCRIPTION:\n      case URL:\n      case X2:\n      case Y2:\n      case THETA:\n      case THETA2:\n      case RADIUS:\n      case RADIUS2: // falls through\n\n      case LATITUDE:\n      case LONGITUDE:\n      case LATITUDE2:\n      case LONGITUDE2: // TODO: case 'cursor':\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n\n      case TEXT:\n      case SHAPE:\n      case ANGLE: // falls through\n      // tooltip fields should not be added to group by [falls through]\n\n      case TOOLTIP:\n        return details;\n\n      case ORDER:\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n\n      // but order should group area for stacking (falls through)\n\n      case DETAIL:\n      case KEY:\n        {\n          const channelDef = encoding[channel];\n\n          if (isArray(channelDef) || isFieldDef(channelDef)) {\n            for (const fieldDef of array(channelDef)) {\n              if (!fieldDef.aggregate) {\n                details.push(vgField(fieldDef, {}));\n              }\n            }\n          }\n\n          return details;\n        }\n\n      case SIZE:\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n\n      // For line, size should group lines.\n      // falls through\n\n      case COLOR:\n      case FILL:\n      case STROKE:\n      case OPACITY:\n      case FILLOPACITY:\n      case STROKEOPACITY:\n      case STROKEDASH:\n      case STROKEWIDTH:\n        {\n          // TODO strokeDashOffset:\n          // falls through\n          const fieldDef = getFieldDef(encoding[channel]);\n\n          if (fieldDef && !fieldDef.aggregate) {\n            details.push(vgField(fieldDef, {}));\n          }\n\n          return details;\n        }\n    }\n  }, []);\n}","map":{"version":3,"sources":["../../src/encoding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { ANGLE, CHANNELS, COLOR, DESCRIPTION, DETAIL, FILL, FILLOPACITY, HREF, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, supportMark, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, Y, Y2 } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, hasConditionalFieldDef, initChannelDef, initFieldDef, isConditionalDef, isDatumDef, isFieldDef, isTypedFieldDef, isValueDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { QUANTITATIVE, TEMPORAL } from './type';\nimport { keys, some } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function channelHasField(encoding, channel) {\n    const channelDef = encoding && encoding[channel];\n    if (channelDef) {\n        if (isArray(channelDef)) {\n            return some(channelDef, fieldDef => !!fieldDef.field);\n        }\n        else {\n            return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n        }\n    }\n    return false;\n}\nexport function isAggregate(encoding) {\n    return some(CHANNELS, channel => {\n        if (channelHasField(encoding, channel)) {\n            const channelDef = encoding[channel];\n            if (isArray(channelDef)) {\n                return some(channelDef, fieldDef => !!fieldDef.aggregate);\n            }\n            else {\n                const fieldDef = getFieldDef(channelDef);\n                return fieldDef && !!fieldDef.aggregate;\n            }\n        }\n        return false;\n    });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n    const groupby = [];\n    const bins = [];\n    const timeUnits = [];\n    const aggregate = [];\n    const encoding = {};\n    forEach(oldEncoding, (channelDef, channel) => {\n        // Extract potential embedded transformations along with remaining properties\n        if (isFieldDef(channelDef)) {\n            const { field, aggregate: aggOp, bin, timeUnit } = channelDef, remaining = __rest(channelDef, [\"field\", \"aggregate\", \"bin\", \"timeUnit\"]);\n            if (aggOp || timeUnit || bin) {\n                const guide = getGuide(channelDef);\n                const isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;\n                let newField = vgField(channelDef, { forAs: true });\n                const newFieldDef = Object.assign(Object.assign(Object.assign({}, (isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) })), remaining), { \n                    // Always overwrite field\n                    field: newField });\n                if (aggOp) {\n                    let op;\n                    if (isArgmaxDef(aggOp)) {\n                        op = 'argmax';\n                        newField = vgField({ op: 'argmax', field: aggOp.argmax }, { forAs: true });\n                        newFieldDef.field = `${newField}.${field}`;\n                    }\n                    else if (isArgminDef(aggOp)) {\n                        op = 'argmin';\n                        newField = vgField({ op: 'argmin', field: aggOp.argmin }, { forAs: true });\n                        newFieldDef.field = `${newField}.${field}`;\n                    }\n                    else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n                        op = aggOp;\n                    }\n                    if (op) {\n                        const aggregateEntry = {\n                            op,\n                            as: newField\n                        };\n                        if (field) {\n                            aggregateEntry.field = field;\n                        }\n                        aggregate.push(aggregateEntry);\n                    }\n                }\n                else {\n                    groupby.push(newField);\n                    if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n                        bins.push({ bin, field, as: newField });\n                        // Add additional groupbys for range and end of bins\n                        groupby.push(vgField(channelDef, { binSuffix: 'end' }));\n                        if (binRequiresRange(channelDef, channel)) {\n                            groupby.push(vgField(channelDef, { binSuffix: 'range' }));\n                        }\n                        // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n                        if (isXorY(channel)) {\n                            const secondaryChannel = {\n                                field: `${newField}_end`\n                            };\n                            encoding[`${channel}2`] = secondaryChannel;\n                        }\n                        newFieldDef.bin = 'binned';\n                        if (!isSecondaryRangeChannel(channel)) {\n                            newFieldDef['type'] = QUANTITATIVE;\n                        }\n                    }\n                    else if (timeUnit) {\n                        timeUnits.push({\n                            timeUnit,\n                            field,\n                            as: newField\n                        });\n                        // define the format type for later compilation\n                        const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n                        if (formatType) {\n                            if (channel === TEXT || channel === TOOLTIP) {\n                                newFieldDef['formatType'] = formatType;\n                            }\n                            else if (isNonPositionScaleChannel(channel)) {\n                                newFieldDef['legend'] = Object.assign({ formatType }, newFieldDef['legend']);\n                            }\n                            else if (isXorY(channel)) {\n                                newFieldDef['axis'] = Object.assign({ formatType }, newFieldDef['axis']);\n                            }\n                        }\n                    }\n                }\n                // now the field should refer to post-transformed field instead\n                encoding[channel] = newFieldDef;\n            }\n            else {\n                groupby.push(field);\n                encoding[channel] = oldEncoding[channel];\n            }\n        }\n        else {\n            // For value def / signal ref / datum def, just copy\n            encoding[channel] = oldEncoding[channel];\n        }\n    });\n    return {\n        bins,\n        timeUnits,\n        aggregate,\n        groupby,\n        encoding\n    };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n    const markSupported = supportMark(channel, mark);\n    if (!markSupported) {\n        return false;\n    }\n    else if (markSupported === 'binned') {\n        const primaryFieldDef = encoding[channel === X2 ? X : Y];\n        // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n        // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n        if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexport function initEncoding(encoding, mark, filled, config) {\n    return keys(encoding).reduce((normalizedEncoding, channel) => {\n        if (!isChannel(channel)) {\n            // Drop invalid channel\n            log.warn(log.message.invalidEncodingChannel(channel));\n            return normalizedEncoding;\n        }\n        const channelDef = encoding[channel];\n        if (channel === 'angle' && mark === 'arc' && !encoding.theta) {\n            log.warn(log.message.REPLACE_ANGLE_WITH_THETA);\n            channel = THETA;\n        }\n        if (!markChannelCompatible(encoding, channel, mark)) {\n            // Drop unsupported channel\n            log.warn(log.message.incompatibleChannel(channel, mark));\n            return normalizedEncoding;\n        }\n        // Drop line's size if the field is aggregated.\n        if (channel === SIZE && mark === 'line') {\n            const fieldDef = getFieldDef(encoding[channel]);\n            if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {\n                log.warn(log.message.LINE_WITH_VARYING_SIZE);\n                return normalizedEncoding;\n            }\n        }\n        // Drop color if either fill or stroke is specified\n        if (channel === COLOR && (filled ? 'fill' in encoding : 'stroke' in encoding)) {\n            log.warn(log.message.droppingColor('encoding', { fill: 'fill' in encoding, stroke: 'stroke' in encoding }));\n            return normalizedEncoding;\n        }\n        if (channel === DETAIL ||\n            (channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef)) ||\n            (channel === TOOLTIP && isArray(channelDef))) {\n            if (channelDef) {\n                // Array of fieldDefs for detail channel (or production rule)\n                normalizedEncoding[channel] = array(channelDef).reduce((defs, fieldDef) => {\n                    if (!isFieldDef(fieldDef)) {\n                        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n                    }\n                    else {\n                        defs.push(initFieldDef(fieldDef, channel));\n                    }\n                    return defs;\n                }, []);\n            }\n        }\n        else {\n            if (channel === TOOLTIP && channelDef === null) {\n                // Preserve null so we can use it to disable tooltip\n                normalizedEncoding[channel] = null;\n            }\n            else if (!isFieldDef(channelDef) &&\n                !isDatumDef(channelDef) &&\n                !isValueDef(channelDef) &&\n                !isConditionalDef(channelDef) &&\n                !isSignalRef(channelDef)) {\n                log.warn(log.message.emptyFieldDef(channelDef, channel));\n                return normalizedEncoding;\n            }\n            normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);\n        }\n        return normalizedEncoding;\n    }, {});\n}\n/**\n * For composite marks, we have to call initChannelDef during init so we can infer types earlier.\n */\nexport function normalizeEncoding(encoding, config) {\n    const normalizedEncoding = {};\n    for (const channel of keys(encoding)) {\n        const newChannelDef = initChannelDef(encoding[channel], channel, config, { compositeMark: true });\n        normalizedEncoding[channel] = newChannelDef;\n    }\n    return normalizedEncoding;\n}\nexport function fieldDefs(encoding) {\n    const arr = [];\n    for (const channel of keys(encoding)) {\n        if (channelHasField(encoding, channel)) {\n            const channelDef = encoding[channel];\n            const channelDefArray = array(channelDef);\n            for (const def of channelDefArray) {\n                if (isFieldDef(def)) {\n                    arr.push(def);\n                }\n                else if (hasConditionalFieldDef(def)) {\n                    arr.push(def.condition);\n                }\n            }\n        }\n    }\n    return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n    if (!mapping) {\n        return;\n    }\n    for (const channel of keys(mapping)) {\n        const el = mapping[channel];\n        if (isArray(el)) {\n            for (const channelDef of el) {\n                f.call(thisArg, channelDef, channel);\n            }\n        }\n        else {\n            f.call(thisArg, el, channel);\n        }\n    }\n}\nexport function reduce(mapping, f, init, thisArg) {\n    if (!mapping) {\n        return init;\n    }\n    return keys(mapping).reduce((r, channel) => {\n        const map = mapping[channel];\n        if (isArray(map)) {\n            return map.reduce((r1, channelDef) => {\n                return f.call(thisArg, r1, channelDef, channel);\n            }, r);\n        }\n        else {\n            return f.call(thisArg, r, map, channel);\n        }\n    }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\nexport function pathGroupingFields(mark, encoding) {\n    return keys(encoding).reduce((details, channel) => {\n        switch (channel) {\n            // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group\n            case X:\n            case Y:\n            case HREF:\n            case DESCRIPTION:\n            case URL:\n            case X2:\n            case Y2:\n            case THETA:\n            case THETA2:\n            case RADIUS:\n            case RADIUS2:\n            // falls through\n            case LATITUDE:\n            case LONGITUDE:\n            case LATITUDE2:\n            case LONGITUDE2:\n            // TODO: case 'cursor':\n            // text, shape, shouldn't be a part of line/trail/area [falls through]\n            case TEXT:\n            case SHAPE:\n            case ANGLE:\n            // falls through\n            // tooltip fields should not be added to group by [falls through]\n            case TOOLTIP:\n                return details;\n            case ORDER:\n                // order should not group line / trail\n                if (mark === 'line' || mark === 'trail') {\n                    return details;\n                }\n            // but order should group area for stacking (falls through)\n            case DETAIL:\n            case KEY: {\n                const channelDef = encoding[channel];\n                if (isArray(channelDef) || isFieldDef(channelDef)) {\n                    for (const fieldDef of array(channelDef)) {\n                        if (!fieldDef.aggregate) {\n                            details.push(vgField(fieldDef, {}));\n                        }\n                    }\n                }\n                return details;\n            }\n            case SIZE:\n                if (mark === 'trail') {\n                    // For trail, size should not group trail lines.\n                    return details;\n                }\n            // For line, size should group lines.\n            // falls through\n            case COLOR:\n            case FILL:\n            case STROKE:\n            case OPACITY:\n            case FILLOPACITY:\n            case STROKEOPACITY:\n            case STROKEDASH:\n            case STROKEWIDTH: {\n                // TODO strokeDashOffset:\n                // falls through\n                const fieldDef = getFieldDef(encoding[channel]);\n                if (fieldDef && !fieldDef.aggregate) {\n                    details.push(vgField(fieldDef, {}));\n                }\n                return details;\n            }\n        }\n    }, []);\n}\n//# sourceMappingURL=encoding.js.map"]},"metadata":{},"sourceType":"module"}