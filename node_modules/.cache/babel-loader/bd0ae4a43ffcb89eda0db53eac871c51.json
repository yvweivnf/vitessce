{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n})(this, function () {\n  'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n   * splaytree v3.1.0\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n\n\n  var Node =\n  /** @class */\n  function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n\n    return Node;\n  }();\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n\n\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n\n    while (true) {\n      var cmp = comparator(i, t.key); //if (i < t.key) {\n\n      if (cmp < 0) {\n        if (t.left === null) break; //if (i < t.left.key) {\n\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left;\n          /* rotate right */\n\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n\n        r.left = t;\n        /* link right */\n\n        r = t;\n        t = t.left; //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break; //if (i > t.right.key) {\n\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right;\n          /* rotate left */\n\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n\n        l.right = t;\n        /* link left */\n\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n\n\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n\n    return node;\n  }\n\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n\n    return {\n      left: left,\n      right: right\n    };\n  }\n\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n\n\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n\n  var Tree =\n  /** @class */\n  function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n\n\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n\n\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n\n\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n\n\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n\n        this._size--;\n        return x;\n      }\n\n      return t;\n      /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n\n\n    Tree.prototype.pop = function () {\n      var node = this._root;\n\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }\n\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n\n\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return null;\n    };\n\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n\n      return this._root;\n    };\n\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return false;\n    };\n\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = [];\n      /* Initialize stack s */\n\n      var done = false;\n\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n\n          node = node.right;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n\n\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n\n\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.left) {\n        t = t.left;\n      }\n      return t;\n    };\n\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.right) {\n        t = t.right;\n      }\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n\n\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return null;\n    };\n\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n\n      if (d.right) {\n        successor = d.right;\n\n        while (successor.left) {\n          successor = successor.left;\n        }\n\n        return successor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n\n      return successor;\n    };\n\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n\n      if (d.left !== null) {\n        predecessor = d.left;\n\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }\n\n        return predecessor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n\n      return predecessor;\n    };\n\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n\n\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n\n      if (presort === void 0) {\n        presort = false;\n      }\n\n      var size = keys.length;\n      var comparator = this._comparator; // sort if needed\n\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n\n      return this;\n    };\n\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function printNode(n) {\n          return String(n.key);\n        };\n      }\n\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n\n      var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n\n      this._root = merge(left, right, comparator);\n    };\n\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n\n    return Tree;\n  }();\n\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n\n    p.next = null;\n    return head.next;\n  }\n\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n\n    p.next = null; // that'll work even if the tree was empty\n\n    return head.next;\n  }\n\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n\n    return null;\n  }\n\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n\n      p = p.next;\n    }\n\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n\n    return head.next;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n\n\n  var isInBbox = function isInBbox(bbox, point) {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n\n\n  var getBboxOverlap = function getBboxOverlap(b1, b2) {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n\n\n  var epsilon = Number.EPSILON; // IE Polyfill\n\n  if (epsilon === undefined) epsilon = Math.pow(2, -52);\n  var EPSILON_SQ = epsilon * epsilon;\n  /* FLP comparator */\n\n  var cmp = function cmp(a, b) {\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n      if (-epsilon < b && b < epsilon) {\n        return 0;\n      }\n    } // check if they're flp equal\n\n\n    var ab = a - b;\n\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    } // normal comparison\n\n\n    return a < b ? -1 : 1;\n  };\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n\n  var PtRounder = /*#__PURE__*/function () {\n    function PtRounder() {\n      _classCallCheck(this, PtRounder);\n\n      this.reset();\n    }\n\n    _createClass(PtRounder, [{\n      key: \"reset\",\n      value: function reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n    }, {\n      key: \"round\",\n      value: function round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }]);\n\n    return PtRounder;\n  }();\n\n  var CoordRounder = /*#__PURE__*/function () {\n    function CoordRounder() {\n      _classCallCheck(this, CoordRounder);\n\n      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n      this.round(0);\n    } // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n\n\n    _createClass(CoordRounder, [{\n      key: \"round\",\n      value: function round(coord) {\n        var node = this.tree.add(coord);\n        var prevNode = this.tree.prev(node);\n\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n\n        var nextNode = this.tree.next(node);\n\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n\n        return coord;\n      }\n    }]);\n\n    return CoordRounder;\n  }(); // singleton available by import\n\n\n  var rounder = new PtRounder();\n  /* Cross Product of two vectors with first point at origin */\n\n  var crossProduct = function crossProduct(a, b) {\n    return a.x * b.y - a.y * b.x;\n  };\n  /* Dot Product of two vectors with first point at origin */\n\n\n  var dotProduct = function dotProduct(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n  /* Comparator for two vectors with same starting point */\n\n\n  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n    var v1 = {\n      x: endPt1.x - basePt.x,\n      y: endPt1.y - basePt.y\n    };\n    var v2 = {\n      x: endPt2.x - basePt.x,\n      y: endPt2.y - basePt.y\n    };\n    var kross = crossProduct(v1, v2);\n    return cmp(kross, 0);\n  };\n\n  var length = function length(v) {\n    return Math.sqrt(dotProduct(v, v));\n  };\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n\n  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n\n  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n\n  var horizontalIntersection = function horizontalIntersection(pt, v, y) {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n\n  var verticalIntersection = function verticalIntersection(pt, v, x) {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n\n  var intersection = function intersection(pt1, v1, pt2, v2) {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    var kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    var ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    var d1 = crossProduct(ve, v1) / kross;\n    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n    var x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n    var y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n    var x = (x1 + x2) / 2;\n    var y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  var SweepEvent = /*#__PURE__*/function () {\n    _createClass(SweepEvent, null, [{\n      key: \"compare\",\n      // for ordering sweep events in the sweep event queue\n      value: function compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n        if (a.point !== b.point) a.link(b); // favor right events over left\n\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n\n        return Segment.compare(a.segment, b.segment);\n      } // for ordering points in sweep line order\n\n    }, {\n      key: \"comparePoints\",\n      value: function comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      } // Warning: 'point' input will be modified and re-used (for performance)\n\n    }]);\n\n    function SweepEvent(point, isLeft) {\n      _classCallCheck(this, SweepEvent);\n\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n    }\n\n    _createClass(SweepEvent, [{\n      key: \"link\",\n      value: function link(other) {\n        if (other.point === this.point) {\n          throw new Error('Tried to link already linked events');\n        }\n\n        var otherEvents = other.point.events;\n\n        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          var evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n\n        this.checkForConsuming();\n      }\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n\n    }, {\n      key: \"checkForConsuming\",\n      value: function checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        var numEvents = this.point.events.length;\n\n        for (var i = 0; i < numEvents; i++) {\n          var evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n\n          for (var j = i + 1; j < numEvents; j++) {\n            var evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        var events = [];\n\n        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          var evt = this.point.events[i];\n\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n\n        return events;\n      }\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function getLeftmostComparator(baseEvent) {\n        var _this = this;\n\n        var cache = new Map();\n\n        var fillCache = function fillCache(linkedEvent) {\n          var nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n\n        return function (a, b) {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n\n          var _cache$get = cache.get(a),\n              asine = _cache$get.sine,\n              acosine = _cache$get.cosine;\n\n          var _cache$get2 = cache.get(b),\n              bsine = _cache$get2.sine,\n              bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          } // both below x-axis\n\n\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          } // one above x-axis, one below\n\n\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }]);\n\n    return SweepEvent;\n  }(); // segments and sweep events when all else is identical\n\n\n  var segmentId = 0;\n\n  var Segment = /*#__PURE__*/function () {\n    _createClass(Segment, null, [{\n      key: \"compare\",\n\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      value: function compare(a, b) {\n        var alx = a.leftSE.point.x;\n        var blx = b.leftSE.point.x;\n        var arx = a.rightSE.point.x;\n        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        var aly = a.leftSE.point.y;\n        var bly = b.leftSE.point.y;\n        var ary = a.rightSE.point.y;\n        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n          var aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n          var bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return -1;\n        } // is left endpoint of segment A the right-more?\n\n\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n          var bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n          var aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return 1;\n        } // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n\n\n        if (aly < bly) return -1;\n        if (aly > bly) return 1; // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n\n        if (arx < brx) {\n          var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n          if (_bCmpARight !== 0) return _bCmpARight;\n        } // is the B right endpoint more left-more?\n\n\n        if (arx > brx) {\n          var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n          if (_aCmpBRight < 0) return 1;\n          if (_aCmpBRight > 0) return -1;\n        }\n\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          var ay = ary - aly;\n          var ax = arx - alx;\n          var by = bry - bly;\n          var bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        } // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n\n\n        if (arx > brx) return 1;\n        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n\n        if (ary < bry) return -1;\n        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1; // identical segment, ie a === b\n\n        return 0;\n      }\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n\n    }]);\n\n    function Segment(leftSE, rightSE, rings, windings) {\n      _classCallCheck(this, Segment);\n\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings; // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n\n    _createClass(Segment, [{\n      key: \"replaceRightSE\",\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      value: function replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function bbox() {\n        var y1 = this.leftSE.point.y;\n        var y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n      /* A vector from the left point to the right */\n\n    }, {\n      key: \"vector\",\n      value: function vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n\n    }, {\n      key: \"comparePoint\",\n      value: function comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        var lPt = this.leftSE.point;\n        var rPt = this.rightSE.point;\n        var v = this.vector(); // Exactly vertical segments.\n\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        } // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n\n\n        var yDist = (point.y - lPt.y) / v.y;\n        var xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0; // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n\n        var xDist = (point.x - lPt.x) / v.x;\n        var yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n\n    }, {\n      key: \"getIntersection\",\n      value: function getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        var tBbox = this.bbox();\n        var oBbox = other.bbox();\n        var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        var tlp = this.leftSE.point;\n        var trp = this.rightSE.point;\n        var olp = other.leftSE.point;\n        var orp = other.rightSE.point; // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n\n        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n\n          return null;\n        } // does this left endpoint matches (other doesn't)\n\n\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return tlp;\n        } // does other left endpoint matches (this doesn't)\n\n\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return olp;\n        } // trivial intersection on right endpoints\n\n\n        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n\n        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n\n        if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n        return rounder.round(pt.x, pt.y);\n      }\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n\n    }, {\n      key: \"split\",\n      value: function split(point) {\n        var newEvents = [];\n        var alreadyLinked = point.events !== undefined;\n        var newLeftSE = new SweepEvent(point, true);\n        var newRightSE = new SweepEvent(point, false);\n        var oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        } // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n\n\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n\n        return newEvents;\n      }\n      /* Swap which event is left and right */\n\n    }, {\n      key: \"swapEvents\",\n      value: function swapEvents() {\n        var tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n\n        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n\n    }, {\n      key: \"consume\",\n      value: function consume(other) {\n        var consumer = this;\n        var consumee = other;\n\n        while (consumer.consumedBy) {\n          consumer = consumer.consumedBy;\n        }\n\n        while (consumee.consumedBy) {\n          consumee = consumee.consumedBy;\n        }\n\n        var cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n\n        if (cmp > 0) {\n          var tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        } // make sure a segment doesn't consume it's prev\n\n\n        if (consumer.prev === consumee) {\n          var _tmp = consumer;\n          consumer = consumee;\n          consumee = _tmp;\n        }\n\n        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          var ring = consumee.rings[i];\n          var winding = consumee.windings[i];\n          var index = consumer.rings.indexOf(ring);\n\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n      /* The first segment previous segment chain that is in the result */\n\n    }, {\n      key: \"prevInResult\",\n      value: function prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n    }, {\n      key: \"beforeState\",\n      value: function beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        var beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        var ringsAfter = this._afterState.rings;\n        var windingsAfter = this._afterState.windings;\n        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n          var ring = this.rings[i];\n          var winding = this.windings[i];\n          var index = ringsAfter.indexOf(ring);\n\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        } // calcualte polysAfter\n\n\n        var polysAfter = [];\n        var polysExclude = [];\n\n        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n          if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n          var _ring = ringsAfter[_i];\n          var poly = _ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (_ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n            var _index = polysAfter.indexOf(_ring.poly);\n\n            if (_index !== -1) polysAfter.splice(_index, 1);\n          }\n        } // calculate multiPolysAfter\n\n\n        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n          var mp = polysAfter[_i2].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n\n        return this._afterState;\n      }\n      /* Is this segment part of the final result? */\n\n    }, {\n      key: \"isInResult\",\n      value: function isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        var mpsBefore = this.beforeState().multiPolys;\n        var mpsAfter = this.afterState().multiPolys;\n\n        switch (operation.type) {\n          case 'union':\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              var noBefores = mpsBefore.length === 0;\n              var noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n\n          case 'intersection':\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              var least;\n              var most;\n\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n\n          case 'xor':\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n\n          case 'difference':\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              var isJustSubject = function isJustSubject(mps) {\n                return mps.length === 1 && mps[0].isSubject;\n              };\n\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n        }\n\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function fromRing(pt1, pt2, ring) {\n        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n        var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n        var leftSE = new SweepEvent(leftPt, true);\n        var rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n    }]);\n\n    return Segment;\n  }();\n\n  var RingIn = /*#__PURE__*/function () {\n    function RingIn(geomRing, poly, isExterior) {\n      _classCallCheck(this, RingIn);\n\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n\n      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      var prevPoint = firstPoint;\n\n      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n        }\n\n        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      } // add segment from last to first if last is not the same as first\n\n\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n\n    _createClass(RingIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n          var segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return RingIn;\n  }();\n\n  var PolyIn = /*#__PURE__*/function () {\n    function PolyIn(geomPoly, multiPoly) {\n      _classCallCheck(this, PolyIn);\n\n      if (!Array.isArray(geomPoly)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n\n      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        var ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n\n      this.multiPoly = multiPoly;\n    }\n\n    _createClass(PolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = this.exteriorRing.getSweepEvents();\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return PolyIn;\n  }();\n\n  var MultiPolyIn = /*#__PURE__*/function () {\n    function MultiPolyIn(geom, isSubject) {\n      _classCallCheck(this, MultiPolyIn);\n\n      if (!Array.isArray(geom)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === 'number') geom = [geom];\n      } catch (ex) {// The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n\n      for (var i = 0, iMax = geom.length; i < iMax; i++) {\n        var poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n\n      this.isSubject = isSubject;\n    }\n\n    _createClass(MultiPolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polySweepEvents = this.polys[i].getSweepEvents();\n\n          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return MultiPolyIn;\n  }();\n\n  var RingOut = /*#__PURE__*/function () {\n    _createClass(RingOut, null, [{\n      key: \"factory\",\n\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      value: function factory(allSegments) {\n        var ringsOut = [];\n\n        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n          var segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          var prevEvent = null;\n          var event = segment.leftSE;\n          var nextEvent = segment.rightSE;\n          var events = [event];\n          var startingPoint = event.point;\n          var intersectionLEs = [];\n          /* Walk the chain of linked events to form a closed ring */\n\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n            /* Is the ring complete? */\n\n            if (event.point === startingPoint) break;\n\n            while (true) {\n              var availableLEs = event.getAvailableLinkedEvents();\n              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n               * part of the algorithm malfunctioned... please file a bug report. */\n\n              if (availableLEs.length === 0) {\n                var firstPt = events[0].point;\n                var lastPt = events[events.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n              }\n              /* Only one way to go, so cotinue on the path */\n\n\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n              /* We must have an intersection. Check for a completed loop */\n\n\n              var indexLE = null;\n\n              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n\n\n              if (indexLE !== null) {\n                var intersectionLE = intersectionLEs.splice(indexLE)[0];\n                var ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n\n\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n\n              var comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n\n          ringsOut.push(new RingOut(events));\n        }\n\n        return ringsOut;\n      }\n    }]);\n\n    function RingOut(events) {\n      _classCallCheck(this, RingOut);\n\n      this.events = events;\n\n      for (var i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n\n      this.poly = null;\n    }\n\n    _createClass(RingOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        var prevPt = this.events[0].point;\n        var points = [prevPt];\n\n        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          var _pt = this.events[i].point;\n          var _nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n          points.push(_pt);\n          prevPt = _pt;\n        } // ring was all (within rounding error of angle calc) colinear points\n\n\n        if (points.length === 1) return null; // check if the starting point is necessary\n\n        var pt = points[0];\n        var nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        var step = this.isExteriorRing() ? 1 : -1;\n        var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        var iEnd = this.isExteriorRing() ? points.length : -1;\n        var orderedPoints = [];\n\n        for (var _i = iStart; _i != iEnd; _i += step) {\n          orderedPoints.push([points[_i].x, points[_i].y]);\n        }\n\n        return orderedPoints;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          var enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n\n        return this._enclosingRing;\n      }\n      /* Returns the ring that encloses this one, if any */\n\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        var leftMostEvt = this.events[0];\n\n        for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n          var evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n\n        var prevSeg = leftMostEvt.segment.prevInResult();\n        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n\n          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          } // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n\n\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }]);\n\n    return RingOut;\n  }();\n\n  var PolyOut = /*#__PURE__*/function () {\n    function PolyOut(exteriorRing) {\n      _classCallCheck(this, PolyOut);\n\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n\n    _createClass(PolyOut, [{\n      key: \"addInterior\",\n      value: function addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (geom[0] === null) return null;\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n\n        return geom;\n      }\n    }]);\n\n    return PolyOut;\n  }();\n\n  var MultiPolyOut = /*#__PURE__*/function () {\n    function MultiPolyOut(rings) {\n      _classCallCheck(this, MultiPolyOut);\n\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n\n    _createClass(MultiPolyOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n\n        return geom;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function _composePolys(rings) {\n        var polys = [];\n\n        for (var i = 0, iMax = rings.length; i < iMax; i++) {\n          var ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            var enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n\n        return polys;\n      }\n    }]);\n\n    return MultiPolyOut;\n  }();\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n\n  var SweepLine = /*#__PURE__*/function () {\n    function SweepLine(queue) {\n      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n      _classCallCheck(this, SweepLine);\n\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n\n    _createClass(SweepLine, [{\n      key: \"process\",\n      value: function process(event) {\n        var segment = event.segment;\n        var newEvents = []; // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n\n        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n        if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n        var prevNode = node;\n        var nextNode = node;\n        var prevSeg = undefined;\n        var nextSeg = undefined; // skip consumed segments still in tree\n\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        } // skip consumed segments still in tree\n\n\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          var prevMySplitter = null;\n\n          if (prevSeg) {\n            var prevInter = prevSeg.getIntersection(segment);\n\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          } // Check for intersections against the next segment in the sweep line\n\n\n          var nextMySplitter = null;\n\n          if (nextSeg) {\n            var nextInter = nextSeg.getIntersection(segment);\n\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                  newEvents.push(_newEventsFromSplit[_i]);\n                }\n              }\n            }\n          } // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n\n\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            var mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            } // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n\n            var _newEventsFromSplit2 = segment.split(mySplitter);\n\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit2[_i2]);\n            }\n          }\n\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            var inter = prevSeg.getIntersection(nextSeg);\n\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                  newEvents.push(_newEventsFromSplit3[_i3]);\n                }\n              }\n\n              if (!nextSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                  newEvents.push(_newEventsFromSplit4[_i4]);\n                }\n              }\n            }\n          }\n\n          this.tree.remove(segment);\n        }\n\n        return newEvents;\n      }\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n\n    }, {\n      key: \"_splitSafely\",\n      value: function _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        var rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        var newEvents = seg.split(pt);\n        newEvents.push(rightSE); // splitting can trigger consumption\n\n        if (seg.consumedBy === undefined) this.tree.insert(seg);\n        return newEvents;\n      }\n    }]);\n\n    return SweepLine;\n  }();\n\n  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n\n  var Operation = /*#__PURE__*/function () {\n    function Operation() {\n      _classCallCheck(this, Operation);\n    }\n\n    _createClass(Operation, [{\n      key: \"run\",\n      value: function run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */\n\n        var multipolys = [new MultiPolyIn(geom, true)];\n\n        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n\n        if (operation.type === 'difference') {\n          // in place removal\n          var subject = multipolys[0];\n          var _i = 1;\n\n          while (_i < multipolys.length) {\n            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n          }\n        }\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n\n\n        if (operation.type === 'intersection') {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n            var mpA = multipolys[_i2];\n\n            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n        /* Put segment endpoints in a priority queue */\n\n\n        var queue = new Tree(SweepEvent.compare);\n\n        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n          var sweepEvents = multipolys[_i3].getSweepEvents();\n\n          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n            queue.insert(sweepEvents[_j]);\n\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n            }\n          }\n        }\n        /* Pass the sweep line over those endpoints */\n\n\n        var sweepLine = new SweepLine(queue);\n        var prevQueueSize = queue.size;\n        var node = queue.pop();\n\n        while (node) {\n          var evt = node.key;\n\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            var seg = evt.segment;\n            throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n          }\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n          }\n\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n          }\n\n          var newEvents = sweepLine.process(evt);\n\n          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n            var _evt = newEvents[_i4];\n            if (_evt.consumedBy === undefined) queue.insert(_evt);\n          }\n\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        } // free some memory we don't need anymore\n\n\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */\n\n        var ringsOut = RingOut.factory(sweepLine.segments);\n        var result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }]);\n\n    return Operation;\n  }(); // singleton available by import\n\n\n  var operation = new Operation();\n\n  var union = function union(geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n\n    return operation.run('union', geom, moreGeoms);\n  };\n\n  var intersection$1 = function intersection(geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n\n    return operation.run('intersection', geom, moreGeoms);\n  };\n\n  var xor = function xor(geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n\n    return operation.run('xor', geom, moreGeoms);\n  };\n\n  var difference = function difference(subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n\n    return operation.run('difference', subjectGeom, clippingGeoms);\n  };\n\n  var index = {\n    union: union,\n    intersection: intersection$1,\n    xor: xor,\n    difference: difference\n  };\n  return index;\n});","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/polygon-clipping/dist/polygon-clipping.umd.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","polygonClipping","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Node","data","next","left","right","DEFAULT_COMPARE","a","b","splay","t","comparator","N","l","r","cmp","y","insert","node","split","v","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","add","remove","_remove","x","pop","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","done","push","call","range","low","high","fn","keys","_a","values","min","minNode","max","maxNode","at","index","d","successor","prev","predecessor","clear","toList","load","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","head","isEmpty","get","toString","n","String","join","update","newKey","newData","start","end","middle","Math","floor","p","list","l1","l2","p1","p2","pivot","j","tmp","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","lowerY","upperY","epsilon","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","reset","value","xRounder","CoordRounder","yRounder","round","tree","coord","prevNode","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection","pt1","pt2","ve","d1","d2","x1","x2","y1","y2","SweepEvent","ptCmp","comparePoints","link","isLeft","Segment","segment","aPt","bPt","events","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","asine","acosine","_cache$get2","bsine","bcosine","segmentId","alx","leftSE","blx","arx","rightSE","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","_bCmpARight","_aCmpBRight","ay","ax","by","bx","id","rings","windings","replaceRightSE","newRightSE","vector","isAnEndpoint","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","getIntersection","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","_tmp","ring","winding","indexOf","prevInResult","_prevInResult","beforeState","_beforeState","multiPolys","seg","afterState","_afterState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","_i","_iMax","_ring","poly","isExterior","_index","splice","_i2","_iMax2","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","abs","isJustSubject","mps","isSubject","concat","fromRing","leftPt","rightPt","cmpPts","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","getSweepEvents","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","unshift","reverse","getGeom","prevPt","points","_pt","_nextPt","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","addInterior","ringGeom","MultiPolyOut","_composePolys","polyGeom","SweepLine","queue","arguments","process","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","_newEventsFromSplit","mySplitter","cmpSplitters","_newEventsFromSplit2","inter","_newEventsFromSplit3","_i3","_iMax3","_newEventsFromSplit4","_i4","_iMax4","POLYGON_CLIPPING_MAX_QUEUE_SIZE","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","run","moreGeoms","multipolys","subject","mpA","_j","_jMax","sweepLine","prevQueueSize","_evt","result","union","_len","_key","intersection$1","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n}(this, (function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /**\n   * splaytree v3.1.0\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n  var Node =\n  /** @class */\n  function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n\n    return Node;\n  }();\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n\n\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n\n    while (true) {\n      var cmp = comparator(i, t.key); //if (i < t.key) {\n\n      if (cmp < 0) {\n        if (t.left === null) break; //if (i < t.left.key) {\n\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left;\n          /* rotate right */\n\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n\n        r.left = t;\n        /* link right */\n\n        r = t;\n        t = t.left; //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break; //if (i > t.right.key) {\n\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right;\n          /* rotate left */\n\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n\n        l.right = t;\n        /* link left */\n\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n\n\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n\n    return node;\n  }\n\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n\n    return {\n      left: left,\n      right: right\n    };\n  }\n\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n\n\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n\n  var Tree =\n  /** @class */\n  function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n\n\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n\n\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n\n\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n\n\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n\n        this._size--;\n        return x;\n      }\n\n      return t;\n      /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n\n\n    Tree.prototype.pop = function () {\n      var node = this._root;\n\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }\n\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n\n\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return null;\n    };\n\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n\n      return this._root;\n    };\n\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return false;\n    };\n\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = [];\n      /* Initialize stack s */\n\n      var done = false;\n\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n\n          node = node.right;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n\n\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n\n\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.left) {\n        t = t.left;\n      }\n      return t;\n    };\n\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.right) {\n        t = t.right;\n      }\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n\n\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return null;\n    };\n\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n\n      if (d.right) {\n        successor = d.right;\n\n        while (successor.left) {\n          successor = successor.left;\n        }\n\n        return successor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n\n      return successor;\n    };\n\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n\n      if (d.left !== null) {\n        predecessor = d.left;\n\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }\n\n        return predecessor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n\n      return predecessor;\n    };\n\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n\n\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n\n      if (presort === void 0) {\n        presort = false;\n      }\n\n      var size = keys.length;\n      var comparator = this._comparator; // sort if needed\n\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n\n      return this;\n    };\n\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function printNode(n) {\n          return String(n.key);\n        };\n      }\n\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n\n      var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n\n      this._root = merge(left, right, comparator);\n    };\n\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n\n    return Tree;\n  }();\n\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n\n    p.next = null;\n    return head.next;\n  }\n\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n\n    p.next = null; // that'll work even if the tree was empty\n\n    return head.next;\n  }\n\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n\n    return null;\n  }\n\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n\n      p = p.next;\n    }\n\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n\n    return head.next;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n  var isInBbox = function isInBbox(bbox, point) {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n\n  var getBboxOverlap = function getBboxOverlap(b1, b2) {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n  var epsilon = Number.EPSILON; // IE Polyfill\n\n  if (epsilon === undefined) epsilon = Math.pow(2, -52);\n  var EPSILON_SQ = epsilon * epsilon;\n  /* FLP comparator */\n\n  var cmp = function cmp(a, b) {\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n      if (-epsilon < b && b < epsilon) {\n        return 0;\n      }\n    } // check if they're flp equal\n\n\n    var ab = a - b;\n\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    } // normal comparison\n\n\n    return a < b ? -1 : 1;\n  };\n\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n  var PtRounder = /*#__PURE__*/function () {\n    function PtRounder() {\n      _classCallCheck(this, PtRounder);\n\n      this.reset();\n    }\n\n    _createClass(PtRounder, [{\n      key: \"reset\",\n      value: function reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n    }, {\n      key: \"round\",\n      value: function round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }]);\n\n    return PtRounder;\n  }();\n\n  var CoordRounder = /*#__PURE__*/function () {\n    function CoordRounder() {\n      _classCallCheck(this, CoordRounder);\n\n      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n      this.round(0);\n    } // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n\n\n    _createClass(CoordRounder, [{\n      key: \"round\",\n      value: function round(coord) {\n        var node = this.tree.add(coord);\n        var prevNode = this.tree.prev(node);\n\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n\n        var nextNode = this.tree.next(node);\n\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n\n        return coord;\n      }\n    }]);\n\n    return CoordRounder;\n  }(); // singleton available by import\n\n\n  var rounder = new PtRounder();\n\n  /* Cross Product of two vectors with first point at origin */\n\n  var crossProduct = function crossProduct(a, b) {\n    return a.x * b.y - a.y * b.x;\n  };\n  /* Dot Product of two vectors with first point at origin */\n\n  var dotProduct = function dotProduct(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n  /* Comparator for two vectors with same starting point */\n\n  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n    var v1 = {\n      x: endPt1.x - basePt.x,\n      y: endPt1.y - basePt.y\n    };\n    var v2 = {\n      x: endPt2.x - basePt.x,\n      y: endPt2.y - basePt.y\n    };\n    var kross = crossProduct(v1, v2);\n    return cmp(kross, 0);\n  };\n  var length = function length(v) {\n    return Math.sqrt(dotProduct(v, v));\n  };\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var horizontalIntersection = function horizontalIntersection(pt, v, y) {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var verticalIntersection = function verticalIntersection(pt, v, x) {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var intersection = function intersection(pt1, v1, pt2, v2) {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    var kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    var ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    var d1 = crossProduct(ve, v1) / kross;\n    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n    var x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n    var y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n    var x = (x1 + x2) / 2;\n    var y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  var SweepEvent = /*#__PURE__*/function () {\n    _createClass(SweepEvent, null, [{\n      key: \"compare\",\n      // for ordering sweep events in the sweep event queue\n      value: function compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n        if (a.point !== b.point) a.link(b); // favor right events over left\n\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n\n        return Segment.compare(a.segment, b.segment);\n      } // for ordering points in sweep line order\n\n    }, {\n      key: \"comparePoints\",\n      value: function comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      } // Warning: 'point' input will be modified and re-used (for performance)\n\n    }]);\n\n    function SweepEvent(point, isLeft) {\n      _classCallCheck(this, SweepEvent);\n\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n    }\n\n    _createClass(SweepEvent, [{\n      key: \"link\",\n      value: function link(other) {\n        if (other.point === this.point) {\n          throw new Error('Tried to link already linked events');\n        }\n\n        var otherEvents = other.point.events;\n\n        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          var evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n\n        this.checkForConsuming();\n      }\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n\n    }, {\n      key: \"checkForConsuming\",\n      value: function checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        var numEvents = this.point.events.length;\n\n        for (var i = 0; i < numEvents; i++) {\n          var evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n\n          for (var j = i + 1; j < numEvents; j++) {\n            var evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        var events = [];\n\n        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          var evt = this.point.events[i];\n\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n\n        return events;\n      }\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function getLeftmostComparator(baseEvent) {\n        var _this = this;\n\n        var cache = new Map();\n\n        var fillCache = function fillCache(linkedEvent) {\n          var nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n\n        return function (a, b) {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n\n          var _cache$get = cache.get(a),\n              asine = _cache$get.sine,\n              acosine = _cache$get.cosine;\n\n          var _cache$get2 = cache.get(b),\n              bsine = _cache$get2.sine,\n              bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          } // both below x-axis\n\n\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          } // one above x-axis, one below\n\n\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }]);\n\n    return SweepEvent;\n  }();\n\n  // segments and sweep events when all else is identical\n\n  var segmentId = 0;\n\n  var Segment = /*#__PURE__*/function () {\n    _createClass(Segment, null, [{\n      key: \"compare\",\n\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      value: function compare(a, b) {\n        var alx = a.leftSE.point.x;\n        var blx = b.leftSE.point.x;\n        var arx = a.rightSE.point.x;\n        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        var aly = a.leftSE.point.y;\n        var bly = b.leftSE.point.y;\n        var ary = a.rightSE.point.y;\n        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n          var aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n          var bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return -1;\n        } // is left endpoint of segment A the right-more?\n\n\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n          var bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n          var aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return 1;\n        } // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n\n\n        if (aly < bly) return -1;\n        if (aly > bly) return 1; // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n\n        if (arx < brx) {\n          var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n          if (_bCmpARight !== 0) return _bCmpARight;\n        } // is the B right endpoint more left-more?\n\n\n        if (arx > brx) {\n          var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n          if (_aCmpBRight < 0) return 1;\n          if (_aCmpBRight > 0) return -1;\n        }\n\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          var ay = ary - aly;\n          var ax = arx - alx;\n          var by = bry - bly;\n          var bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        } // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n\n\n        if (arx > brx) return 1;\n        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n\n        if (ary < bry) return -1;\n        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1; // identical segment, ie a === b\n\n        return 0;\n      }\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n\n    }]);\n\n    function Segment(leftSE, rightSE, rings, windings) {\n      _classCallCheck(this, Segment);\n\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings; // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n\n    _createClass(Segment, [{\n      key: \"replaceRightSE\",\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      value: function replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function bbox() {\n        var y1 = this.leftSE.point.y;\n        var y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n      /* A vector from the left point to the right */\n\n    }, {\n      key: \"vector\",\n      value: function vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n\n    }, {\n      key: \"comparePoint\",\n      value: function comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        var lPt = this.leftSE.point;\n        var rPt = this.rightSE.point;\n        var v = this.vector(); // Exactly vertical segments.\n\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        } // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n\n\n        var yDist = (point.y - lPt.y) / v.y;\n        var xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0; // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n\n        var xDist = (point.x - lPt.x) / v.x;\n        var yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n\n    }, {\n      key: \"getIntersection\",\n      value: function getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        var tBbox = this.bbox();\n        var oBbox = other.bbox();\n        var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        var tlp = this.leftSE.point;\n        var trp = this.rightSE.point;\n        var olp = other.leftSE.point;\n        var orp = other.rightSE.point; // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n\n        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n\n          return null;\n        } // does this left endpoint matches (other doesn't)\n\n\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return tlp;\n        } // does other left endpoint matches (this doesn't)\n\n\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return olp;\n        } // trivial intersection on right endpoints\n\n\n        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n\n        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n\n        if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n        return rounder.round(pt.x, pt.y);\n      }\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n\n    }, {\n      key: \"split\",\n      value: function split(point) {\n        var newEvents = [];\n        var alreadyLinked = point.events !== undefined;\n        var newLeftSE = new SweepEvent(point, true);\n        var newRightSE = new SweepEvent(point, false);\n        var oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        } // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n\n\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n\n        return newEvents;\n      }\n      /* Swap which event is left and right */\n\n    }, {\n      key: \"swapEvents\",\n      value: function swapEvents() {\n        var tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n\n        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n\n    }, {\n      key: \"consume\",\n      value: function consume(other) {\n        var consumer = this;\n        var consumee = other;\n\n        while (consumer.consumedBy) {\n          consumer = consumer.consumedBy;\n        }\n\n        while (consumee.consumedBy) {\n          consumee = consumee.consumedBy;\n        }\n\n        var cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n\n        if (cmp > 0) {\n          var tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        } // make sure a segment doesn't consume it's prev\n\n\n        if (consumer.prev === consumee) {\n          var _tmp = consumer;\n          consumer = consumee;\n          consumee = _tmp;\n        }\n\n        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          var ring = consumee.rings[i];\n          var winding = consumee.windings[i];\n          var index = consumer.rings.indexOf(ring);\n\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n      /* The first segment previous segment chain that is in the result */\n\n    }, {\n      key: \"prevInResult\",\n      value: function prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n    }, {\n      key: \"beforeState\",\n      value: function beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        var beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        var ringsAfter = this._afterState.rings;\n        var windingsAfter = this._afterState.windings;\n        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n          var ring = this.rings[i];\n          var winding = this.windings[i];\n          var index = ringsAfter.indexOf(ring);\n\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        } // calcualte polysAfter\n\n\n        var polysAfter = [];\n        var polysExclude = [];\n\n        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n          if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n          var _ring = ringsAfter[_i];\n          var poly = _ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (_ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n            var _index = polysAfter.indexOf(_ring.poly);\n\n            if (_index !== -1) polysAfter.splice(_index, 1);\n          }\n        } // calculate multiPolysAfter\n\n\n        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n          var mp = polysAfter[_i2].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n\n        return this._afterState;\n      }\n      /* Is this segment part of the final result? */\n\n    }, {\n      key: \"isInResult\",\n      value: function isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        var mpsBefore = this.beforeState().multiPolys;\n        var mpsAfter = this.afterState().multiPolys;\n\n        switch (operation.type) {\n          case 'union':\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              var noBefores = mpsBefore.length === 0;\n              var noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n\n          case 'intersection':\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              var least;\n              var most;\n\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n\n          case 'xor':\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n\n          case 'difference':\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              var isJustSubject = function isJustSubject(mps) {\n                return mps.length === 1 && mps[0].isSubject;\n              };\n\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n        }\n\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function fromRing(pt1, pt2, ring) {\n        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n        var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n        var leftSE = new SweepEvent(leftPt, true);\n        var rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n    }]);\n\n    return Segment;\n  }();\n\n  var RingIn = /*#__PURE__*/function () {\n    function RingIn(geomRing, poly, isExterior) {\n      _classCallCheck(this, RingIn);\n\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n\n      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      var prevPoint = firstPoint;\n\n      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n        }\n\n        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      } // add segment from last to first if last is not the same as first\n\n\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n\n    _createClass(RingIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n          var segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return RingIn;\n  }();\n  var PolyIn = /*#__PURE__*/function () {\n    function PolyIn(geomPoly, multiPoly) {\n      _classCallCheck(this, PolyIn);\n\n      if (!Array.isArray(geomPoly)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n\n      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        var ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n\n      this.multiPoly = multiPoly;\n    }\n\n    _createClass(PolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = this.exteriorRing.getSweepEvents();\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return PolyIn;\n  }();\n  var MultiPolyIn = /*#__PURE__*/function () {\n    function MultiPolyIn(geom, isSubject) {\n      _classCallCheck(this, MultiPolyIn);\n\n      if (!Array.isArray(geom)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === 'number') geom = [geom];\n      } catch (ex) {// The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n\n      for (var i = 0, iMax = geom.length; i < iMax; i++) {\n        var poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n\n      this.isSubject = isSubject;\n    }\n\n    _createClass(MultiPolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polySweepEvents = this.polys[i].getSweepEvents();\n\n          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return MultiPolyIn;\n  }();\n\n  var RingOut = /*#__PURE__*/function () {\n    _createClass(RingOut, null, [{\n      key: \"factory\",\n\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      value: function factory(allSegments) {\n        var ringsOut = [];\n\n        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n          var segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          var prevEvent = null;\n          var event = segment.leftSE;\n          var nextEvent = segment.rightSE;\n          var events = [event];\n          var startingPoint = event.point;\n          var intersectionLEs = [];\n          /* Walk the chain of linked events to form a closed ring */\n\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n            /* Is the ring complete? */\n\n            if (event.point === startingPoint) break;\n\n            while (true) {\n              var availableLEs = event.getAvailableLinkedEvents();\n              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n               * part of the algorithm malfunctioned... please file a bug report. */\n\n              if (availableLEs.length === 0) {\n                var firstPt = events[0].point;\n                var lastPt = events[events.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n              }\n              /* Only one way to go, so cotinue on the path */\n\n\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n              /* We must have an intersection. Check for a completed loop */\n\n\n              var indexLE = null;\n\n              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n\n\n              if (indexLE !== null) {\n                var intersectionLE = intersectionLEs.splice(indexLE)[0];\n                var ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n\n\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n\n              var comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n\n          ringsOut.push(new RingOut(events));\n        }\n\n        return ringsOut;\n      }\n    }]);\n\n    function RingOut(events) {\n      _classCallCheck(this, RingOut);\n\n      this.events = events;\n\n      for (var i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n\n      this.poly = null;\n    }\n\n    _createClass(RingOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        var prevPt = this.events[0].point;\n        var points = [prevPt];\n\n        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          var _pt = this.events[i].point;\n          var _nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n          points.push(_pt);\n          prevPt = _pt;\n        } // ring was all (within rounding error of angle calc) colinear points\n\n\n        if (points.length === 1) return null; // check if the starting point is necessary\n\n        var pt = points[0];\n        var nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        var step = this.isExteriorRing() ? 1 : -1;\n        var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        var iEnd = this.isExteriorRing() ? points.length : -1;\n        var orderedPoints = [];\n\n        for (var _i = iStart; _i != iEnd; _i += step) {\n          orderedPoints.push([points[_i].x, points[_i].y]);\n        }\n\n        return orderedPoints;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          var enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n\n        return this._enclosingRing;\n      }\n      /* Returns the ring that encloses this one, if any */\n\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        var leftMostEvt = this.events[0];\n\n        for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n          var evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n\n        var prevSeg = leftMostEvt.segment.prevInResult();\n        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n\n          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          } // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n\n\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }]);\n\n    return RingOut;\n  }();\n  var PolyOut = /*#__PURE__*/function () {\n    function PolyOut(exteriorRing) {\n      _classCallCheck(this, PolyOut);\n\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n\n    _createClass(PolyOut, [{\n      key: \"addInterior\",\n      value: function addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (geom[0] === null) return null;\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n\n        return geom;\n      }\n    }]);\n\n    return PolyOut;\n  }();\n  var MultiPolyOut = /*#__PURE__*/function () {\n    function MultiPolyOut(rings) {\n      _classCallCheck(this, MultiPolyOut);\n\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n\n    _createClass(MultiPolyOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n\n        return geom;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function _composePolys(rings) {\n        var polys = [];\n\n        for (var i = 0, iMax = rings.length; i < iMax; i++) {\n          var ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            var enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n\n        return polys;\n      }\n    }]);\n\n    return MultiPolyOut;\n  }();\n\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n  var SweepLine = /*#__PURE__*/function () {\n    function SweepLine(queue) {\n      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n      _classCallCheck(this, SweepLine);\n\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n\n    _createClass(SweepLine, [{\n      key: \"process\",\n      value: function process(event) {\n        var segment = event.segment;\n        var newEvents = []; // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n\n        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n        if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n        var prevNode = node;\n        var nextNode = node;\n        var prevSeg = undefined;\n        var nextSeg = undefined; // skip consumed segments still in tree\n\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        } // skip consumed segments still in tree\n\n\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          var prevMySplitter = null;\n\n          if (prevSeg) {\n            var prevInter = prevSeg.getIntersection(segment);\n\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          } // Check for intersections against the next segment in the sweep line\n\n\n          var nextMySplitter = null;\n\n          if (nextSeg) {\n            var nextInter = nextSeg.getIntersection(segment);\n\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                  newEvents.push(_newEventsFromSplit[_i]);\n                }\n              }\n            }\n          } // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n\n\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            var mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            } // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n\n            var _newEventsFromSplit2 = segment.split(mySplitter);\n\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit2[_i2]);\n            }\n          }\n\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            var inter = prevSeg.getIntersection(nextSeg);\n\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                  newEvents.push(_newEventsFromSplit3[_i3]);\n                }\n              }\n\n              if (!nextSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                  newEvents.push(_newEventsFromSplit4[_i4]);\n                }\n              }\n            }\n          }\n\n          this.tree.remove(segment);\n        }\n\n        return newEvents;\n      }\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n\n    }, {\n      key: \"_splitSafely\",\n      value: function _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        var rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        var newEvents = seg.split(pt);\n        newEvents.push(rightSE); // splitting can trigger consumption\n\n        if (seg.consumedBy === undefined) this.tree.insert(seg);\n        return newEvents;\n      }\n    }]);\n\n    return SweepLine;\n  }();\n\n  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n  var Operation = /*#__PURE__*/function () {\n    function Operation() {\n      _classCallCheck(this, Operation);\n    }\n\n    _createClass(Operation, [{\n      key: \"run\",\n      value: function run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */\n\n        var multipolys = [new MultiPolyIn(geom, true)];\n\n        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n\n        if (operation.type === 'difference') {\n          // in place removal\n          var subject = multipolys[0];\n          var _i = 1;\n\n          while (_i < multipolys.length) {\n            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n          }\n        }\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n\n\n        if (operation.type === 'intersection') {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n            var mpA = multipolys[_i2];\n\n            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n        /* Put segment endpoints in a priority queue */\n\n\n        var queue = new Tree(SweepEvent.compare);\n\n        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n          var sweepEvents = multipolys[_i3].getSweepEvents();\n\n          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n            queue.insert(sweepEvents[_j]);\n\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n            }\n          }\n        }\n        /* Pass the sweep line over those endpoints */\n\n\n        var sweepLine = new SweepLine(queue);\n        var prevQueueSize = queue.size;\n        var node = queue.pop();\n\n        while (node) {\n          var evt = node.key;\n\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            var seg = evt.segment;\n            throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n          }\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n          }\n\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n          }\n\n          var newEvents = sweepLine.process(evt);\n\n          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n            var _evt = newEvents[_i4];\n            if (_evt.consumedBy === undefined) queue.insert(_evt);\n          }\n\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        } // free some memory we don't need anymore\n\n\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */\n\n        var ringsOut = RingOut.factory(sweepLine.segments);\n        var result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }]);\n\n    return Operation;\n  }(); // singleton available by import\n\n  var operation = new Operation();\n\n  var union = function union(geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n\n    return operation.run('union', geom, moreGeoms);\n  };\n\n  var intersection$1 = function intersection(geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n\n    return operation.run('intersection', geom, moreGeoms);\n  };\n\n  var xor = function xor(geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n\n    return operation.run('xor', geom, moreGeoms);\n  };\n\n  var difference = function difference(subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n\n    return operation.run('difference', subjectGeom, clippingGeoms);\n  };\n\n  var index = {\n    union: union,\n    intersection: intersection$1,\n    xor: xor,\n    difference: difference\n  };\n\n  return index;\n\n})));\n"]},"metadata":{},"sourceType":"script"}