{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\src\\\\components\\\\scatterplot\\\\Scatterplot.js\";\nimport React, { forwardRef } from 'react';\nimport { PolygonLayer, TextLayer, ScatterplotLayer } from '@deck.gl/layers'; // eslint-disable-line import/no-extraneous-dependencies\n\nimport { forceSimulation } from 'd3-force';\nimport { getSelectionLayers } from '../../layers';\nimport { cellLayerDefaultProps, getDefaultColor } from '../utils';\nimport { createCellsQuadTree } from '../shared-spatial-scatterplot/quadtree';\nimport AbstractSpatialOrScatterplot from '../shared-spatial-scatterplot/AbstractSpatialOrScatterplot';\nimport { forceCollideRects } from '../shared-spatial-scatterplot/force-collide-rects';\nimport { ScaledExpressionExtension, SelectionExtension } from '../../layer-extensions';\nconst CELLS_LAYER_ID = 'scatterplot';\nconst LABEL_FONT_FAMILY = \"-apple-system, 'Helvetica Neue', Arial, sans-serif\";\nconst NUM_FORCE_SIMULATION_TICKS = 100;\nconst LABEL_UPDATE_ZOOM_DELTA = 0.25; // Default getter function props.\n\nconst makeDefaultGetCellPosition = mapping => cellEntry => {\n  const {\n    mappings\n  } = cellEntry[1];\n\n  if (!(mapping in mappings)) {\n    const available = Object.keys(mappings).map(s => `\"${s}\"`).join(', ');\n    throw new Error(`Expected to find \"${mapping}\", but available mappings are: ${available}`);\n  }\n\n  const mappedCell = mappings[mapping]; // The negative applied to the y-axis is because\n  // graphics rendering has the y-axis positive going south.\n\n  return [mappedCell[0], -mappedCell[1], 0];\n};\n\nconst makeDefaultGetCellCoords = mapping => cell => cell.mappings[mapping];\n\nconst makeDefaultGetCellColors = (cellColors, theme) => cellEntry => {\n  const [r, g, b, a] = cellColors && cellColors.get(cellEntry[0]) || getDefaultColor(theme);\n  return [r, g, b, 255 * (a || 1)];\n};\n/**\n * React component which renders a scatterplot from cell data.\n * @param {object} props\n * @param {string} props.uuid A unique identifier for this component.\n * @param {string} props.theme The current vitessce theme.\n * @param {object} props.viewState The deck.gl view state.\n * @param {function} props.setViewState Function to call to update the deck.gl view state.\n * @param {object} props.cells\n * @param {string} props.mapping The name of the coordinate mapping field,\n * for each cell, for example \"PCA\" or \"t-SNE\".\n * @param {Map} props.cellColors Mapping of cell IDs to colors.\n * @param {array} props.cellSelection Array of selected cell IDs.\n * @param {array} props.cellFilter Array of filtered cell IDs. By default, null.\n * @param {number} props.cellRadius The value for `radiusScale` to pass\n * to the deck.gl cells ScatterplotLayer.\n * @param {number} props.cellOpacity The value for `opacity` to pass\n * to the deck.gl cells ScatterplotLayer.\n * @param {function} props.getCellCoords Getter function for cell coordinates\n * (used by the selection layer).\n * @param {function} props.getCellPosition Getter function for cell [x, y, z] position.\n * @param {function} props.getCellColor Getter function for cell color as [r, g, b] array.\n * @param {function} props.getExpressionValue Getter function for cell expression value.\n * @param {function} props.getCellIsSelected Getter function for cell layer isSelected.\n * @param {function} props.setCellSelection\n * @param {function} props.setCellHighlight\n * @param {function} props.updateViewInfo\n * @param {function} props.onToolChange Callback for tool changes\n * (lasso/pan/rectangle selection tools).\n * @param {function} props.onCellClick Getter function for cell layer onClick.\n */\n\n\nclass Scatterplot extends AbstractSpatialOrScatterplot {\n  constructor(props) {\n    super(props); // To avoid storing large arrays/objects\n    // in React state, this component\n    // uses instance variables.\n    // All instance variables used in this class:\n\n    this.cellsEntries = [];\n    this.cellsQuadTree = null;\n    this.cellsLayer = null;\n    this.cellSetsForceSimulation = forceCollideRects();\n    this.cellSetsLabelPrevZoom = null;\n    this.cellSetsLayers = []; // Initialize data and layers.\n\n    this.onUpdateCellsData();\n    this.onUpdateCellsLayer();\n    this.onUpdateCellSetsLayers();\n  }\n\n  createCellsLayer() {\n    const {\n      cellsEntries\n    } = this;\n    const {\n      theme,\n      mapping,\n      getCellPosition = makeDefaultGetCellPosition(mapping),\n      cellRadius = 1.0,\n      cellOpacity = 1.0,\n      cellFilter,\n      cellSelection,\n      setCellHighlight,\n      setComponentHover,\n      getCellIsSelected,\n      cellColors,\n      getCellColor = makeDefaultGetCellColors(cellColors, theme),\n      getExpressionValue,\n      onCellClick,\n      geneExpressionColormap,\n      geneExpressionColormapRange = [0.0, 1.0],\n      cellColorEncoding\n    } = this.props;\n    const filteredCellsEntries = cellFilter ? cellsEntries.filter(cellEntry => cellFilter.includes(cellEntry[0])) : cellsEntries;\n    return new ScatterplotLayer({\n      id: CELLS_LAYER_ID,\n      backgroundColor: theme === 'dark' ? [0, 0, 0] : [241, 241, 241],\n      getCellIsSelected,\n      opacity: cellOpacity,\n      radiusScale: cellRadius,\n      radiusMinPixels: 1,\n      radiusMaxPixels: 30,\n      // Our radius pixel setters measure in pixels.\n      radiusUnits: 'pixels',\n      lineWidthUnits: 'pixels',\n      getPosition: getCellPosition,\n      getFillColor: getCellColor,\n      getLineColor: getCellColor,\n      getRadius: 1,\n      getExpressionValue,\n      getLineWidth: 0,\n      extensions: [new ScaledExpressionExtension(), new SelectionExtension({\n        instanced: true\n      })],\n      colorScaleLo: geneExpressionColormapRange[0],\n      colorScaleHi: geneExpressionColormapRange[1],\n      isExpressionMode: cellColorEncoding === 'geneSelection',\n      colormap: geneExpressionColormap,\n      onClick: info => {\n        if (onCellClick) {\n          onCellClick(info);\n        }\n      },\n      updateTriggers: {\n        getExpressionValue,\n        getFillColor: [cellColorEncoding, cellSelection, cellColors],\n        getLineColor: [cellColorEncoding, cellSelection, cellColors],\n        getPosition: [mapping],\n        getCellIsSelected\n      },\n      ...cellLayerDefaultProps(filteredCellsEntries, undefined, setCellHighlight, setComponentHover),\n      stroked: 0\n    });\n  }\n\n  createCellSetsLayers() {\n    const {\n      theme,\n      cellSetPolygons,\n      viewState,\n      cellSetPolygonsVisible,\n      cellSetLabelsVisible,\n      cellSetLabelSize\n    } = this.props;\n    const result = [];\n\n    if (cellSetPolygonsVisible) {\n      result.push(new PolygonLayer({\n        id: 'cell-sets-polygon-layer',\n        data: cellSetPolygons,\n        stroked: true,\n        filled: false,\n        wireframe: true,\n        lineWidthMaxPixels: 1,\n        getPolygon: d => d.hull,\n        getLineColor: d => d.color,\n        getLineWidth: 1\n      }));\n    }\n\n    if (cellSetLabelsVisible) {\n      const {\n        zoom\n      } = viewState;\n      const nodes = cellSetPolygons.map(p => ({\n        x: p.centroid[0],\n        y: p.centroid[1],\n        label: p.name\n      }));\n      const collisionForce = this.cellSetsForceSimulation.size(d => [cellSetLabelSize * 1 / 2 ** zoom * 4 * d.label.length, cellSetLabelSize * 1 / 2 ** zoom * 1.5]);\n      forceSimulation().nodes(nodes).force('collision', collisionForce).tick(NUM_FORCE_SIMULATION_TICKS);\n      result.push(new TextLayer({\n        id: 'cell-sets-text-layer',\n        data: nodes,\n        getPosition: d => [d.x, d.y],\n        getText: d => d.label,\n        getColor: theme === 'dark' ? [255, 255, 255] : [0, 0, 0],\n        getSize: cellSetLabelSize,\n        getAngle: 0,\n        getTextAnchor: 'middle',\n        getAlignmentBaseline: 'center',\n        fontFamily: LABEL_FONT_FAMILY,\n        fontWeight: 'normal'\n      }));\n    }\n\n    return result;\n  }\n\n  createSelectionLayers() {\n    const {\n      viewState,\n      mapping,\n      getCellCoords = makeDefaultGetCellCoords(mapping),\n      setCellSelection\n    } = this.props;\n    const {\n      tool\n    } = this.state;\n    const {\n      cellsQuadTree\n    } = this;\n    const flipYTooltip = true;\n    return getSelectionLayers(tool, viewState.zoom, CELLS_LAYER_ID, getCellCoords, setCellSelection, cellsQuadTree, flipYTooltip);\n  }\n\n  getLayers() {\n    const {\n      cellsLayer,\n      cellSetsLayers\n    } = this;\n    return [cellsLayer, ...cellSetsLayers, ...this.createSelectionLayers()];\n  }\n\n  onUpdateCellsData() {\n    const {\n      cells = {},\n      mapping,\n      getCellCoords = makeDefaultGetCellCoords(mapping)\n    } = this.props;\n    const cellsEntries = Object.entries(cells);\n    this.cellsEntries = cellsEntries;\n    this.cellsQuadTree = createCellsQuadTree(cellsEntries, getCellCoords);\n  }\n\n  onUpdateCellsLayer() {\n    this.cellsLayer = this.createCellsLayer();\n  }\n\n  onUpdateCellSetsLayers(onlyViewStateChange) {\n    // Because the label sizes for the force simulation depend on the zoom level,\n    // we _could_ run the simulation every time the zoom level changes.\n    // However, this has a performance impact in firefox.\n    if (onlyViewStateChange) {\n      const {\n        viewState,\n        cellSetLabelsVisible\n      } = this.props;\n      const {\n        zoom\n      } = viewState;\n      const {\n        cellSetsLabelPrevZoom\n      } = this; // Instead, we can just check if the zoom level has changed\n      // by some relatively large delta, to be more conservative\n      // about re-running the force simulation.\n\n      if (cellSetLabelsVisible && (cellSetsLabelPrevZoom === null || Math.abs(cellSetsLabelPrevZoom - zoom) > LABEL_UPDATE_ZOOM_DELTA)) {\n        this.cellSetsLayers = this.createCellSetsLayers();\n        this.cellSetsLabelPrevZoom = zoom;\n      }\n    } else {\n      // Otherwise, something more substantial than just\n      // the viewState has changed, such as the label array\n      // itself, so we always want to update the layer\n      // in this case.\n      this.cellSetsLayers = this.createCellSetsLayers();\n    }\n  }\n\n  viewInfoDidUpdate() {\n    const {\n      mapping,\n      getCellPosition = makeDefaultGetCellPosition(mapping)\n    } = this.props;\n    super.viewInfoDidUpdate(cell => getCellPosition([null, cell]));\n  }\n  /**\n   * Here, asynchronously check whether props have\n   * updated which require re-computing memoized variables,\n   * followed by a re-render.\n   * This function does not follow React conventions or paradigms,\n   * it is only implemented this way to try to squeeze out\n   * performance.\n   * @param {object} prevProps The previous props to diff against.\n   */\n\n\n  componentDidUpdate(prevProps) {\n    this.viewInfoDidUpdate();\n\n    const shallowDiff = propName => prevProps[propName] !== this.props[propName];\n\n    if (['cells'].some(shallowDiff)) {\n      // Cells data changed.\n      this.onUpdateCellsData();\n      this.forceUpdate();\n    }\n\n    if (['cells', 'mapping', 'cellFilter', 'cellSelection', 'cellColors', 'cellRadius', 'cellOpacity', 'cellRadiusMode', 'geneExpressionColormap', 'geneExpressionColormapRange', 'geneSelection', 'cellColorEncoding'].some(shallowDiff)) {\n      // Cells layer props changed.\n      this.onUpdateCellsLayer();\n      this.forceUpdate();\n    }\n\n    if (['cellSetPolygons', 'cellSetPolygonsVisible', 'cellSetLabelsVisible', 'cellSetLabelSize'].some(shallowDiff)) {\n      // Cell sets layer props changed.\n      this.onUpdateCellSetsLayers(false);\n      this.forceUpdate();\n    }\n\n    if (shallowDiff('viewState')) {\n      // The viewState prop has changed (due to zoom or pan).\n      this.onUpdateCellSetsLayers(true);\n      this.forceUpdate();\n    }\n  } // render() is implemented in the abstract parent class.\n\n\n}\n/**\n * Need this wrapper function here,\n * since we want to pass a forwardRef\n * so that outer components can\n * access the grandchild DeckGL ref,\n * but we are using a class component.\n */\n\n\nconst ScatterplotWrapper = forwardRef((props, deckRef) => /*#__PURE__*/React.createElement(Scatterplot, Object.assign({}, props, {\n  deckRef: deckRef,\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 357,\n    columnNumber: 3\n  }\n})));\nexport default ScatterplotWrapper;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/scatterplot/Scatterplot.js"],"names":["React","forwardRef","PolygonLayer","TextLayer","ScatterplotLayer","forceSimulation","getSelectionLayers","cellLayerDefaultProps","getDefaultColor","createCellsQuadTree","AbstractSpatialOrScatterplot","forceCollideRects","ScaledExpressionExtension","SelectionExtension","CELLS_LAYER_ID","LABEL_FONT_FAMILY","NUM_FORCE_SIMULATION_TICKS","LABEL_UPDATE_ZOOM_DELTA","makeDefaultGetCellPosition","mapping","cellEntry","mappings","available","Object","keys","map","s","join","Error","mappedCell","makeDefaultGetCellCoords","cell","makeDefaultGetCellColors","cellColors","theme","r","g","b","a","get","Scatterplot","constructor","props","cellsEntries","cellsQuadTree","cellsLayer","cellSetsForceSimulation","cellSetsLabelPrevZoom","cellSetsLayers","onUpdateCellsData","onUpdateCellsLayer","onUpdateCellSetsLayers","createCellsLayer","getCellPosition","cellRadius","cellOpacity","cellFilter","cellSelection","setCellHighlight","setComponentHover","getCellIsSelected","getCellColor","getExpressionValue","onCellClick","geneExpressionColormap","geneExpressionColormapRange","cellColorEncoding","filteredCellsEntries","filter","includes","id","backgroundColor","opacity","radiusScale","radiusMinPixels","radiusMaxPixels","radiusUnits","lineWidthUnits","getPosition","getFillColor","getLineColor","getRadius","getLineWidth","extensions","instanced","colorScaleLo","colorScaleHi","isExpressionMode","colormap","onClick","info","updateTriggers","undefined","stroked","createCellSetsLayers","cellSetPolygons","viewState","cellSetPolygonsVisible","cellSetLabelsVisible","cellSetLabelSize","result","push","data","filled","wireframe","lineWidthMaxPixels","getPolygon","d","hull","color","zoom","nodes","p","x","centroid","y","label","name","collisionForce","size","length","force","tick","getText","getColor","getSize","getAngle","getTextAnchor","getAlignmentBaseline","fontFamily","fontWeight","createSelectionLayers","getCellCoords","setCellSelection","tool","state","flipYTooltip","getLayers","cells","entries","onlyViewStateChange","Math","abs","viewInfoDidUpdate","componentDidUpdate","prevProps","shallowDiff","propName","some","forceUpdate","ScatterplotWrapper","deckRef"],"mappings":"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","sourcesContent":["import React, { forwardRef } from 'react';\nimport { PolygonLayer, TextLayer, ScatterplotLayer } from '@deck.gl/layers'; // eslint-disable-line import/no-extraneous-dependencies\nimport { forceSimulation } from 'd3-force';\nimport { getSelectionLayers } from '../../layers';\nimport { cellLayerDefaultProps, getDefaultColor } from '../utils';\nimport {\n  createCellsQuadTree,\n} from '../shared-spatial-scatterplot/quadtree';\nimport AbstractSpatialOrScatterplot from '../shared-spatial-scatterplot/AbstractSpatialOrScatterplot';\nimport { forceCollideRects } from '../shared-spatial-scatterplot/force-collide-rects';\nimport { ScaledExpressionExtension, SelectionExtension } from '../../layer-extensions';\n\nconst CELLS_LAYER_ID = 'scatterplot';\nconst LABEL_FONT_FAMILY = \"-apple-system, 'Helvetica Neue', Arial, sans-serif\";\nconst NUM_FORCE_SIMULATION_TICKS = 100;\nconst LABEL_UPDATE_ZOOM_DELTA = 0.25;\n\n// Default getter function props.\nconst makeDefaultGetCellPosition = mapping => (cellEntry) => {\n  const { mappings } = cellEntry[1];\n  if (!(mapping in mappings)) {\n    const available = Object.keys(mappings).map(s => `\"${s}\"`).join(', ');\n    throw new Error(`Expected to find \"${mapping}\", but available mappings are: ${available}`);\n  }\n  const mappedCell = mappings[mapping];\n  // The negative applied to the y-axis is because\n  // graphics rendering has the y-axis positive going south.\n  return [mappedCell[0], -mappedCell[1], 0];\n};\nconst makeDefaultGetCellCoords = mapping => cell => cell.mappings[mapping];\nconst makeDefaultGetCellColors = (cellColors, theme) => (cellEntry) => {\n  const [r, g, b, a] = (cellColors && cellColors.get(cellEntry[0])) || getDefaultColor(theme);\n  return [r, g, b, 255 * (a || 1)];\n};\n\n/**\n * React component which renders a scatterplot from cell data.\n * @param {object} props\n * @param {string} props.uuid A unique identifier for this component.\n * @param {string} props.theme The current vitessce theme.\n * @param {object} props.viewState The deck.gl view state.\n * @param {function} props.setViewState Function to call to update the deck.gl view state.\n * @param {object} props.cells\n * @param {string} props.mapping The name of the coordinate mapping field,\n * for each cell, for example \"PCA\" or \"t-SNE\".\n * @param {Map} props.cellColors Mapping of cell IDs to colors.\n * @param {array} props.cellSelection Array of selected cell IDs.\n * @param {array} props.cellFilter Array of filtered cell IDs. By default, null.\n * @param {number} props.cellRadius The value for `radiusScale` to pass\n * to the deck.gl cells ScatterplotLayer.\n * @param {number} props.cellOpacity The value for `opacity` to pass\n * to the deck.gl cells ScatterplotLayer.\n * @param {function} props.getCellCoords Getter function for cell coordinates\n * (used by the selection layer).\n * @param {function} props.getCellPosition Getter function for cell [x, y, z] position.\n * @param {function} props.getCellColor Getter function for cell color as [r, g, b] array.\n * @param {function} props.getExpressionValue Getter function for cell expression value.\n * @param {function} props.getCellIsSelected Getter function for cell layer isSelected.\n * @param {function} props.setCellSelection\n * @param {function} props.setCellHighlight\n * @param {function} props.updateViewInfo\n * @param {function} props.onToolChange Callback for tool changes\n * (lasso/pan/rectangle selection tools).\n * @param {function} props.onCellClick Getter function for cell layer onClick.\n */\nclass Scatterplot extends AbstractSpatialOrScatterplot {\n  constructor(props) {\n    super(props);\n\n    // To avoid storing large arrays/objects\n    // in React state, this component\n    // uses instance variables.\n    // All instance variables used in this class:\n    this.cellsEntries = [];\n    this.cellsQuadTree = null;\n    this.cellsLayer = null;\n    this.cellSetsForceSimulation = forceCollideRects();\n    this.cellSetsLabelPrevZoom = null;\n    this.cellSetsLayers = [];\n\n    // Initialize data and layers.\n    this.onUpdateCellsData();\n    this.onUpdateCellsLayer();\n    this.onUpdateCellSetsLayers();\n  }\n\n  createCellsLayer() {\n    const { cellsEntries } = this;\n    const {\n      theme,\n      mapping,\n      getCellPosition = makeDefaultGetCellPosition(mapping),\n      cellRadius = 1.0,\n      cellOpacity = 1.0,\n      cellFilter,\n      cellSelection,\n      setCellHighlight,\n      setComponentHover,\n      getCellIsSelected,\n      cellColors,\n      getCellColor = makeDefaultGetCellColors(cellColors, theme),\n      getExpressionValue,\n      onCellClick,\n      geneExpressionColormap,\n      geneExpressionColormapRange = [0.0, 1.0],\n      cellColorEncoding,\n    } = this.props;\n    const filteredCellsEntries = (cellFilter\n      ? cellsEntries.filter(cellEntry => cellFilter.includes(cellEntry[0]))\n      : cellsEntries);\n    return new ScatterplotLayer({\n      id: CELLS_LAYER_ID,\n      backgroundColor: (theme === 'dark' ? [0, 0, 0] : [241, 241, 241]),\n      getCellIsSelected,\n      opacity: cellOpacity,\n      radiusScale: cellRadius,\n      radiusMinPixels: 1,\n      radiusMaxPixels: 30,\n      // Our radius pixel setters measure in pixels.\n      radiusUnits: 'pixels',\n      lineWidthUnits: 'pixels',\n      getPosition: getCellPosition,\n      getFillColor: getCellColor,\n      getLineColor: getCellColor,\n      getRadius: 1,\n      getExpressionValue,\n      getLineWidth: 0,\n      extensions: [\n        new ScaledExpressionExtension(),\n        new SelectionExtension({ instanced: true }),\n      ],\n      colorScaleLo: geneExpressionColormapRange[0],\n      colorScaleHi: geneExpressionColormapRange[1],\n      isExpressionMode: (cellColorEncoding === 'geneSelection'),\n      colormap: geneExpressionColormap,\n      onClick: (info) => {\n        if (onCellClick) {\n          onCellClick(info);\n        }\n      },\n      updateTriggers: {\n        getExpressionValue,\n        getFillColor: [cellColorEncoding, cellSelection, cellColors],\n        getLineColor: [cellColorEncoding, cellSelection, cellColors],\n        getPosition: [mapping],\n        getCellIsSelected,\n      },\n      ...cellLayerDefaultProps(\n        filteredCellsEntries, undefined, setCellHighlight, setComponentHover,\n      ),\n      stroked: 0,\n    });\n  }\n\n  createCellSetsLayers() {\n    const {\n      theme,\n      cellSetPolygons,\n      viewState,\n      cellSetPolygonsVisible,\n      cellSetLabelsVisible,\n      cellSetLabelSize,\n    } = this.props;\n\n    const result = [];\n\n    if (cellSetPolygonsVisible) {\n      result.push(new PolygonLayer({\n        id: 'cell-sets-polygon-layer',\n        data: cellSetPolygons,\n        stroked: true,\n        filled: false,\n        wireframe: true,\n        lineWidthMaxPixels: 1,\n        getPolygon: d => d.hull,\n        getLineColor: d => d.color,\n        getLineWidth: 1,\n      }));\n    }\n\n    if (cellSetLabelsVisible) {\n      const { zoom } = viewState;\n      const nodes = cellSetPolygons.map(p => ({\n        x: p.centroid[0],\n        y: p.centroid[1],\n        label: p.name,\n      }));\n\n      const collisionForce = this.cellSetsForceSimulation\n        .size(d => ([\n          cellSetLabelSize * 1 / (2 ** zoom) * 4 * d.label.length,\n          cellSetLabelSize * 1 / (2 ** zoom) * 1.5,\n        ]));\n\n      forceSimulation()\n        .nodes(nodes)\n        .force('collision', collisionForce)\n        .tick(NUM_FORCE_SIMULATION_TICKS);\n\n      result.push(new TextLayer({\n        id: 'cell-sets-text-layer',\n        data: nodes,\n        getPosition: d => ([d.x, d.y]),\n        getText: d => d.label,\n        getColor: (theme === 'dark' ? [255, 255, 255] : [0, 0, 0]),\n        getSize: cellSetLabelSize,\n        getAngle: 0,\n        getTextAnchor: 'middle',\n        getAlignmentBaseline: 'center',\n        fontFamily: LABEL_FONT_FAMILY,\n        fontWeight: 'normal',\n      }));\n    }\n\n    return result;\n  }\n\n  createSelectionLayers() {\n    const {\n      viewState,\n      mapping,\n      getCellCoords = makeDefaultGetCellCoords(mapping),\n      setCellSelection,\n    } = this.props;\n    const { tool } = this.state;\n    const { cellsQuadTree } = this;\n    const flipYTooltip = true;\n    return getSelectionLayers(\n      tool,\n      viewState.zoom,\n      CELLS_LAYER_ID,\n      getCellCoords,\n      setCellSelection,\n      cellsQuadTree,\n      flipYTooltip,\n    );\n  }\n\n  getLayers() {\n    const {\n      cellsLayer,\n      cellSetsLayers,\n    } = this;\n    return [\n      cellsLayer,\n      ...cellSetsLayers,\n      ...this.createSelectionLayers(),\n    ];\n  }\n\n  onUpdateCellsData() {\n    const {\n      cells = {},\n      mapping,\n      getCellCoords = makeDefaultGetCellCoords(mapping),\n    } = this.props;\n    const cellsEntries = Object.entries(cells);\n    this.cellsEntries = cellsEntries;\n    this.cellsQuadTree = createCellsQuadTree(cellsEntries, getCellCoords);\n  }\n\n  onUpdateCellsLayer() {\n    this.cellsLayer = this.createCellsLayer();\n  }\n\n  onUpdateCellSetsLayers(onlyViewStateChange) {\n    // Because the label sizes for the force simulation depend on the zoom level,\n    // we _could_ run the simulation every time the zoom level changes.\n    // However, this has a performance impact in firefox.\n    if (onlyViewStateChange) {\n      const { viewState, cellSetLabelsVisible } = this.props;\n      const { zoom } = viewState;\n      const { cellSetsLabelPrevZoom } = this;\n      // Instead, we can just check if the zoom level has changed\n      // by some relatively large delta, to be more conservative\n      // about re-running the force simulation.\n      if (cellSetLabelsVisible\n        && (\n          cellSetsLabelPrevZoom === null\n          || Math.abs(cellSetsLabelPrevZoom - zoom) > LABEL_UPDATE_ZOOM_DELTA\n        )\n      ) {\n        this.cellSetsLayers = this.createCellSetsLayers();\n        this.cellSetsLabelPrevZoom = zoom;\n      }\n    } else {\n      // Otherwise, something more substantial than just\n      // the viewState has changed, such as the label array\n      // itself, so we always want to update the layer\n      // in this case.\n      this.cellSetsLayers = this.createCellSetsLayers();\n    }\n  }\n\n  viewInfoDidUpdate() {\n    const {\n      mapping,\n      getCellPosition = makeDefaultGetCellPosition(mapping),\n    } = this.props;\n    super.viewInfoDidUpdate(cell => getCellPosition([null, cell]));\n  }\n\n  /**\n   * Here, asynchronously check whether props have\n   * updated which require re-computing memoized variables,\n   * followed by a re-render.\n   * This function does not follow React conventions or paradigms,\n   * it is only implemented this way to try to squeeze out\n   * performance.\n   * @param {object} prevProps The previous props to diff against.\n   */\n  componentDidUpdate(prevProps) {\n    this.viewInfoDidUpdate();\n\n    const shallowDiff = propName => (prevProps[propName] !== this.props[propName]);\n    if (['cells'].some(shallowDiff)) {\n      // Cells data changed.\n      this.onUpdateCellsData();\n      this.forceUpdate();\n    }\n\n    if ([\n      'cells', 'mapping', 'cellFilter', 'cellSelection', 'cellColors',\n      'cellRadius', 'cellOpacity', 'cellRadiusMode', 'geneExpressionColormap',\n      'geneExpressionColormapRange', 'geneSelection', 'cellColorEncoding',\n    ].some(shallowDiff)) {\n      // Cells layer props changed.\n      this.onUpdateCellsLayer();\n      this.forceUpdate();\n    }\n    if ([\n      'cellSetPolygons', 'cellSetPolygonsVisible',\n      'cellSetLabelsVisible', 'cellSetLabelSize',\n    ].some(shallowDiff)) {\n      // Cell sets layer props changed.\n      this.onUpdateCellSetsLayers(false);\n      this.forceUpdate();\n    }\n    if (shallowDiff('viewState')) {\n      // The viewState prop has changed (due to zoom or pan).\n      this.onUpdateCellSetsLayers(true);\n      this.forceUpdate();\n    }\n  }\n\n  // render() is implemented in the abstract parent class.\n}\n\n/**\n * Need this wrapper function here,\n * since we want to pass a forwardRef\n * so that outer components can\n * access the grandchild DeckGL ref,\n * but we are using a class component.\n */\nconst ScatterplotWrapper = forwardRef((props, deckRef) => (\n  <Scatterplot\n    {...props}\n    deckRef={deckRef}\n  />\n));\nexport default ScatterplotWrapper;\n"]},"metadata":{},"sourceType":"module"}