{"ast":null,"code":"import { isArray, isString } from 'vega';\nimport { isSelectionParameter } from '../selection';\nimport { isUnitSpec } from '../spec';\nimport { SpecMapper } from '../spec/map';\nexport class TopLevelSelectionsNormalizer extends SpecMapper {\n  map(spec, normParams) {\n    var _a;\n\n    const selections = (_a = normParams.selections) !== null && _a !== void 0 ? _a : [];\n\n    if (spec.params && !isUnitSpec(spec)) {\n      const params = [];\n\n      for (const param of spec.params) {\n        if (isSelectionParameter(param)) {\n          selections.push(param);\n        } else {\n          params.push(param);\n        }\n      }\n\n      spec.params = params;\n    }\n\n    normParams.selections = selections;\n    return super.map(spec, addSpecNameToParams(spec, normParams));\n  }\n\n  mapUnit(spec, normParams) {\n    var _a;\n\n    const selections = normParams.selections;\n    if (!selections || !selections.length) return spec;\n    const path = ((_a = normParams.path) !== null && _a !== void 0 ? _a : []).concat(spec.name);\n    const params = [];\n\n    for (const selection of selections) {\n      // By default, apply selections to all unit views.\n      if (!selection.views || !selection.views.length) {\n        params.push(selection);\n      } else {\n        for (const view of selection.views) {\n          // view is either a specific unit name, or a partial path through the spec tree.\n          if (isString(view) && (view === spec.name || path.indexOf(view) >= 0) || isArray(view) && view.map(v => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) {\n            params.push(selection);\n          }\n        }\n      }\n    }\n\n    if (params.length) spec.params = params;\n    return spec;\n  }\n\n}\n\nfor (const method of ['mapFacet', 'mapRepeat', 'mapHConcat', 'mapVConcat', 'mapLayer']) {\n  const proto = TopLevelSelectionsNormalizer.prototype[method];\n\n  TopLevelSelectionsNormalizer.prototype[method] = function (spec, params) {\n    return proto.call(this, spec, addSpecNameToParams(spec, params));\n  };\n}\n\nfunction addSpecNameToParams(spec, params) {\n  var _a;\n\n  return spec.name ? Object.assign(Object.assign({}, params), {\n    path: ((_a = params.path) !== null && _a !== void 0 ? _a : []).concat(spec.name)\n  }) : params;\n}","map":{"version":3,"sources":["../../../src/normalize/toplevelselection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isString } from 'vega';\nimport { isSelectionParameter } from '../selection';\nimport { isUnitSpec } from '../spec';\nimport { SpecMapper } from '../spec/map';\nexport class TopLevelSelectionsNormalizer extends SpecMapper {\n    map(spec, normParams) {\n        var _a;\n        const selections = (_a = normParams.selections) !== null && _a !== void 0 ? _a : [];\n        if (spec.params && !isUnitSpec(spec)) {\n            const params = [];\n            for (const param of spec.params) {\n                if (isSelectionParameter(param)) {\n                    selections.push(param);\n                }\n                else {\n                    params.push(param);\n                }\n            }\n            spec.params = params;\n        }\n        normParams.selections = selections;\n        return super.map(spec, addSpecNameToParams(spec, normParams));\n    }\n    mapUnit(spec, normParams) {\n        var _a;\n        const selections = normParams.selections;\n        if (!selections || !selections.length)\n            return spec;\n        const path = ((_a = normParams.path) !== null && _a !== void 0 ? _a : []).concat(spec.name);\n        const params = [];\n        for (const selection of selections) {\n            // By default, apply selections to all unit views.\n            if (!selection.views || !selection.views.length) {\n                params.push(selection);\n            }\n            else {\n                for (const view of selection.views) {\n                    // view is either a specific unit name, or a partial path through the spec tree.\n                    if ((isString(view) && (view === spec.name || path.indexOf(view) >= 0)) ||\n                        (isArray(view) &&\n                            view.map(v => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1])))) {\n                        params.push(selection);\n                    }\n                }\n            }\n        }\n        if (params.length)\n            spec.params = params;\n        return spec;\n    }\n}\nfor (const method of ['mapFacet', 'mapRepeat', 'mapHConcat', 'mapVConcat', 'mapLayer']) {\n    const proto = TopLevelSelectionsNormalizer.prototype[method];\n    TopLevelSelectionsNormalizer.prototype[method] = function (spec, params) {\n        return proto.call(this, spec, addSpecNameToParams(spec, params));\n    };\n}\nfunction addSpecNameToParams(spec, params) {\n    var _a;\n    return spec.name\n        ? Object.assign(Object.assign({}, params), { path: ((_a = params.path) !== null && _a !== void 0 ? _a : []).concat(spec.name) }) : params;\n}\n//# sourceMappingURL=toplevelselection.js.map"]},"metadata":{},"sourceType":"module"}