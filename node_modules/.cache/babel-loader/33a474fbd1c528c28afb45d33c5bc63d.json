{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\n\nexport class UnitModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {\n    var _a;\n\n    super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n    this.specifiedScales = {};\n    this.specifiedAxes = {};\n    this.specifiedLegends = {};\n    this.specifiedProjection = {};\n    this.selection = [];\n    this.children = [];\n    const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : {\n      type: spec.mark\n    };\n    const mark = markDef.type; // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n\n    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);\n    this.markDef = initMarkdef(markDef, encoding, config);\n    this.size = initLayoutSize({\n      encoding: encoding,\n      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n        width: spec.width\n      } : {}), spec.height ? {\n        height: spec.height\n      } : {}) : parentGivenSize\n    }); // calculate stack properties\n\n    this.stack = stack(mark, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegends(encoding);\n    this.specifiedProjection = spec.projection; // Selections will be initialized upon parse.\n\n    this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter(p => isSelectionParameter(p));\n  }\n\n  get hasProjection() {\n    const {\n      encoding\n    } = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n\n\n  scaleDomain(channel) {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  axis(channel) {\n    return this.specifiedAxes[channel];\n  }\n\n  legend(channel) {\n    return this.specifiedLegends[channel];\n  }\n\n  initScales(mark, encoding) {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      var _a;\n\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n\n      if (fieldOrDatumDef) {\n        scales[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});\n      }\n\n      return scales;\n    }, {});\n  }\n\n  initScale(scale) {\n    const {\n      domain,\n      range\n    } = scale; // TODO: we could simplify this function if we had a recursive replace function\n\n    const scaleInternal = replaceExprRef(scale);\n\n    if (isArray(domain)) {\n      scaleInternal.domain = domain.map(signalRefOrValue);\n    }\n\n    if (isArray(range)) {\n      scaleInternal.range = range.map(signalRefOrValue);\n    }\n\n    return scaleInternal;\n  }\n\n  initAxes(encoding) {\n    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n      // Position Axis\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n\n      if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {\n        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n        _axis[channel] = axisSpec ? this.initAxis(Object.assign({}, axisSpec)) // convert truthy value to object\n        : axisSpec;\n      }\n\n      return _axis;\n    }, {});\n  }\n\n  initAxis(axis) {\n    const props = keys(axis);\n    const axisInternal = {};\n\n    for (const prop of props) {\n      const val = axis[prop];\n      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);\n    }\n\n    return axisInternal;\n  }\n\n  initLegends(encoding) {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n\n      if (fieldOrDatumDef && supportLegend(channel)) {\n        const legend = fieldOrDatumDef.legend;\n        _legend[channel] = legend ? replaceExprRef(legend) // convert truthy value to object\n        : legend;\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n  }\n\n  parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  assembleSignals() {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  assembleSelectionData(data) {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  assembleLayout() {\n    return null;\n  }\n\n  assembleLayoutSignals() {\n    return assembleLayoutSignals(this);\n  }\n\n  assembleMarks() {\n    var _a;\n\n    let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : []; // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  assembleGroupStyle() {\n    const {\n      style\n    } = this.view || {};\n\n    if (style !== undefined) {\n      return style;\n    }\n\n    if (this.encoding.x || this.encoding.y) {\n      return 'cell';\n    } else {\n      return undefined;\n    }\n  }\n\n  getMapping() {\n    return this.encoding;\n  }\n\n  get mark() {\n    return this.markDef.type;\n  }\n\n  channelHasField(channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  fieldDef(channel) {\n    const channelDef = this.encoding[channel];\n    return getFieldDef(channelDef);\n  }\n\n  typedFieldDef(channel) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (isTypedFieldDef(fieldDef)) {\n      return fieldDef;\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["../../../src/compile/unit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n    constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {\n        var _a;\n        super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n        this.specifiedScales = {};\n        this.specifiedAxes = {};\n        this.specifiedLegends = {};\n        this.specifiedProjection = {};\n        this.selection = [];\n        this.children = [];\n        const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : { type: spec.mark };\n        const mark = markDef.type;\n        // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n        if (markDef.filled === undefined) {\n            markDef.filled = defaultFilled(markDef, config, {\n                graticule: spec.data && isGraticuleGenerator(spec.data)\n            });\n        }\n        const encoding = (this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config));\n        this.markDef = initMarkdef(markDef, encoding, config);\n        this.size = initLayoutSize({\n            encoding: encoding,\n            size: isFrameMixins(spec)\n                ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), (spec.width ? { width: spec.width } : {})), (spec.height ? { height: spec.height } : {})) : parentGivenSize\n        });\n        // calculate stack properties\n        this.stack = stack(mark, encoding);\n        this.specifiedScales = this.initScales(mark, encoding);\n        this.specifiedAxes = this.initAxes(encoding);\n        this.specifiedLegends = this.initLegends(encoding);\n        this.specifiedProjection = spec.projection;\n        // Selections will be initialized upon parse.\n        this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter(p => isSelectionParameter(p));\n    }\n    get hasProjection() {\n        const { encoding } = this;\n        const isGeoShapeMark = this.mark === GEOSHAPE;\n        const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n        return isGeoShapeMark || hasGeoPosition;\n    }\n    /**\n     * Return specified Vega-Lite scale domain for a particular channel\n     * @param channel\n     */\n    scaleDomain(channel) {\n        const scale = this.specifiedScales[channel];\n        return scale ? scale.domain : undefined;\n    }\n    axis(channel) {\n        return this.specifiedAxes[channel];\n    }\n    legend(channel) {\n        return this.specifiedLegends[channel];\n    }\n    initScales(mark, encoding) {\n        return SCALE_CHANNELS.reduce((scales, channel) => {\n            var _a;\n            const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n            if (fieldOrDatumDef) {\n                scales[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});\n            }\n            return scales;\n        }, {});\n    }\n    initScale(scale) {\n        const { domain, range } = scale;\n        // TODO: we could simplify this function if we had a recursive replace function\n        const scaleInternal = replaceExprRef(scale);\n        if (isArray(domain)) {\n            scaleInternal.domain = domain.map(signalRefOrValue);\n        }\n        if (isArray(range)) {\n            scaleInternal.range = range.map(signalRefOrValue);\n        }\n        return scaleInternal;\n    }\n    initAxes(encoding) {\n        return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n            // Position Axis\n            // TODO: handle ConditionFieldDef\n            const channelDef = encoding[channel];\n            if (isFieldOrDatumDef(channelDef) ||\n                (channel === X && isFieldOrDatumDef(encoding.x2)) ||\n                (channel === Y && isFieldOrDatumDef(encoding.y2))) {\n                const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n                _axis[channel] = axisSpec\n                    ? this.initAxis(Object.assign({}, axisSpec)) // convert truthy value to object\n                    : axisSpec;\n            }\n            return _axis;\n        }, {});\n    }\n    initAxis(axis) {\n        const props = keys(axis);\n        const axisInternal = {};\n        for (const prop of props) {\n            const val = axis[prop];\n            axisInternal[prop] = isConditionalAxisValue(val)\n                ? signalOrValueRefWithCondition(val)\n                : signalRefOrValue(val);\n        }\n        return axisInternal;\n    }\n    initLegends(encoding) {\n        return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n            const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n            if (fieldOrDatumDef && supportLegend(channel)) {\n                const legend = fieldOrDatumDef.legend;\n                _legend[channel] = legend\n                    ? replaceExprRef(legend) // convert truthy value to object\n                    : legend;\n            }\n            return _legend;\n        }, {});\n    }\n    parseData() {\n        this.component.data = parseData(this);\n    }\n    parseLayoutSize() {\n        parseUnitLayoutSize(this);\n    }\n    parseSelections() {\n        this.component.selection = parseUnitSelection(this, this.selection);\n    }\n    parseMarkGroup() {\n        this.component.mark = parseMarkGroups(this);\n    }\n    parseAxesAndHeaders() {\n        this.component.axes = parseUnitAxes(this);\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return assembleTopLevelSignals(this, signals);\n    }\n    assembleSignals() {\n        return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n    }\n    assembleSelectionData(data) {\n        return assembleUnitSelectionData(this, data);\n    }\n    assembleLayout() {\n        return null;\n    }\n    assembleLayoutSignals() {\n        return assembleLayoutSignals(this);\n    }\n    assembleMarks() {\n        var _a;\n        let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : [];\n        // If this unit is part of a layer, selections should augment\n        // all in concert rather than each unit individually. This\n        // ensures correct interleaving of clipping and brushed marks.\n        if (!this.parent || !isLayerModel(this.parent)) {\n            marks = assembleUnitSelectionMarks(this, marks);\n        }\n        return marks.map(this.correctDataNames);\n    }\n    assembleGroupStyle() {\n        const { style } = this.view || {};\n        if (style !== undefined) {\n            return style;\n        }\n        if (this.encoding.x || this.encoding.y) {\n            return 'cell';\n        }\n        else {\n            return undefined;\n        }\n    }\n    getMapping() {\n        return this.encoding;\n    }\n    get mark() {\n        return this.markDef.type;\n    }\n    channelHasField(channel) {\n        return vlEncoding.channelHasField(this.encoding, channel);\n    }\n    fieldDef(channel) {\n        const channelDef = this.encoding[channel];\n        return getFieldDef(channelDef);\n    }\n    typedFieldDef(channel) {\n        const fieldDef = this.fieldDef(channel);\n        if (isTypedFieldDef(fieldDef)) {\n            return fieldDef;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=unit.js.map"]},"metadata":{},"sourceType":"module"}