{"ast":null,"code":"/* eslint-disable no-plusplus */\n// Adapted from https://github.com/feross/fromentries/blob/29b52a850bb3a47c390937631c2638edf3443942/index.js\nexport function fromEntries(iterable) {\n  return [...iterable].reduce((obj, {\n    0: key,\n    1: val\n  }) => Object.assign(obj, {\n    [key]: val\n  }), {});\n}\n/**\n * Select between a singular and plural version of a word,\n * based on an item count.\n * @param {string} singular The singular version of the word.\n * @param {string} plural The plural version of the word.\n * @param {number} count The number of items.\n * @returns {string} Singular if count is one, else plural.\n */\n\nexport function pluralize(singular, plural, count) {\n  return count === 1 ? singular : plural;\n}\n/**\n * Capitalize a the first letter of a string.\n * @param {string} word A string to capitalize.\n * @returns {string} The word parameter with the first letter capitalized.\n */\n\nexport function capitalize(word) {\n  return word.charAt(0).toUpperCase() + word.slice(1);\n}\n/**\n * Get the longest string in the array of strings.\n * @param {string[]} strings The array of strings.\n * @returns The longest string.\n */\n\nexport function getLongestString(strings) {\n  return strings.reduce((prevLongest, currentValue) => prevLongest.length > currentValue.length ? prevLongest : currentValue);\n}\n/**\n * Generate a new scope name which does not\n * conflict / overlap with a previous scope name.\n * Really these just need to be unique within the coordination object.\n * So in theory they could be String(Math.random()) or uuidv4() or something.\n * However it may be good to make them more human-readable and memorable\n * since eventually we will want to expose a UI to update the coordination.\n * @param {string[]} prevScopes Previous scope names.\n * @returns {string} The new scope name.\n */\n\nexport function getNextScope(prevScopes) {\n  // Keep an ordered list of valid characters.\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // Store the value of the next character for each position\n  // in the new string.\n  // For example, [0] -> \"A\", [1] -> \"B\", [0, 1] -> \"AB\"\n\n  const nextCharIndices = [0]; // Generate a new scope name,\n  // potentially conflicting with an existing name.\n  // Reference: https://stackoverflow.com/a/12504061\n\n  function next() {\n    const r = [];\n    nextCharIndices.forEach(charIndex => {\n      r.unshift(chars[charIndex]);\n    });\n    let increment = true;\n\n    for (let i = 0; i < nextCharIndices.length; i++) {\n      const val = ++nextCharIndices[i];\n\n      if (val >= chars.length) {\n        nextCharIndices[i] = 0;\n      } else {\n        increment = false;\n        break;\n      }\n    }\n\n    if (increment) {\n      nextCharIndices.push(0);\n    }\n\n    return r.join('');\n  }\n\n  let nextScope;\n\n  do {\n    nextScope = next();\n  } while (prevScopes.includes(nextScope));\n\n  return nextScope;\n}\n/**\n * Get a representative PixelSource from a loader object returned from\n * the Vitessce imaging loaders\n * @param {object} loader { data: (PixelSource[]|PixelSource), metadata, channels } object\n * @param {number=} level Level of the multiscale loader from which to get a PixelSource\n * @returns {object} PixelSource object\n */\n\nexport function getSourceFromLoader(loader, level) {\n  const {\n    data\n  } = loader;\n  const source = Array.isArray(data) ? data[level || data.length - 1] : data;\n  return source;\n}\n/*\n * Helper method to determine whether pixel data is interleaved and rgb or not.\n * @param {object} loader\n */\n\nexport function isRgb(loader) {\n  const source = getSourceFromLoader(loader);\n  const {\n    shape,\n    dtype,\n    labels\n  } = source;\n  const channelSize = shape[labels.indexOf('c')];\n  return channelSize === 3 && dtype === 'Uint8';\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/utils.js"],"names":["fromEntries","iterable","reduce","obj","key","val","Object","assign","pluralize","singular","plural","count","capitalize","word","charAt","toUpperCase","slice","getLongestString","strings","prevLongest","currentValue","length","getNextScope","prevScopes","chars","nextCharIndices","next","r","forEach","charIndex","unshift","increment","i","push","join","nextScope","includes","getSourceFromLoader","loader","level","data","source","Array","isArray","isRgb","shape","dtype","labels","channelSize","indexOf"],"mappings":"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","sourcesContent":["/* eslint-disable no-plusplus */\n\n// Adapted from https://github.com/feross/fromentries/blob/29b52a850bb3a47c390937631c2638edf3443942/index.js\nexport function fromEntries(iterable) {\n  return [...iterable]\n    .reduce((obj, { 0: key, 1: val }) => Object.assign(obj, { [key]: val }), {});\n}\n\n/**\n * Select between a singular and plural version of a word,\n * based on an item count.\n * @param {string} singular The singular version of the word.\n * @param {string} plural The plural version of the word.\n * @param {number} count The number of items.\n * @returns {string} Singular if count is one, else plural.\n */\nexport function pluralize(singular, plural, count) {\n  return (count === 1 ? singular : plural);\n}\n\n/**\n * Capitalize a the first letter of a string.\n * @param {string} word A string to capitalize.\n * @returns {string} The word parameter with the first letter capitalized.\n */\nexport function capitalize(word) {\n  return word.charAt(0).toUpperCase() + word.slice(1);\n}\n\n/**\n * Get the longest string in the array of strings.\n * @param {string[]} strings The array of strings.\n * @returns The longest string.\n */\nexport function getLongestString(strings) {\n  return strings.reduce(\n    (prevLongest, currentValue) => (\n      prevLongest.length > currentValue.length ? prevLongest : currentValue\n    ),\n  );\n}\n\n/**\n * Generate a new scope name which does not\n * conflict / overlap with a previous scope name.\n * Really these just need to be unique within the coordination object.\n * So in theory they could be String(Math.random()) or uuidv4() or something.\n * However it may be good to make them more human-readable and memorable\n * since eventually we will want to expose a UI to update the coordination.\n * @param {string[]} prevScopes Previous scope names.\n * @returns {string} The new scope name.\n */\nexport function getNextScope(prevScopes) {\n  // Keep an ordered list of valid characters.\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  // Store the value of the next character for each position\n  // in the new string.\n  // For example, [0] -> \"A\", [1] -> \"B\", [0, 1] -> \"AB\"\n  const nextCharIndices = [0];\n\n  // Generate a new scope name,\n  // potentially conflicting with an existing name.\n  // Reference: https://stackoverflow.com/a/12504061\n  function next() {\n    const r = [];\n    nextCharIndices.forEach((charIndex) => {\n      r.unshift(chars[charIndex]);\n    });\n    let increment = true;\n    for (let i = 0; i < nextCharIndices.length; i++) {\n      const val = ++nextCharIndices[i];\n      if (val >= chars.length) {\n        nextCharIndices[i] = 0;\n      } else {\n        increment = false;\n        break;\n      }\n    }\n    if (increment) {\n      nextCharIndices.push(0);\n    }\n    return r.join('');\n  }\n\n  let nextScope;\n  do {\n    nextScope = next();\n  } while (prevScopes.includes(nextScope));\n  return nextScope;\n}\n\n/**\n * Get a representative PixelSource from a loader object returned from\n * the Vitessce imaging loaders\n * @param {object} loader { data: (PixelSource[]|PixelSource), metadata, channels } object\n * @param {number=} level Level of the multiscale loader from which to get a PixelSource\n * @returns {object} PixelSource object\n */\nexport function getSourceFromLoader(loader, level) {\n  const { data } = loader;\n  const source = Array.isArray(data) ? data[(level || data.length - 1)] : data;\n  return source;\n}\n\n/*\n * Helper method to determine whether pixel data is interleaved and rgb or not.\n * @param {object} loader\n */\nexport function isRgb(loader) {\n  const source = getSourceFromLoader(loader);\n  const { shape, dtype, labels } = source;\n  const channelSize = shape[labels.indexOf('c')];\n  return (channelSize === 3) && dtype === 'Uint8';\n}\n"]},"metadata":{},"sourceType":"module"}