{"ast":null,"code":"import { loadOmeZarr } from '@hms-dbmi/viv';\nimport { AbstractLoaderError } from './errors';\nimport LoaderResult from './LoaderResult';\nimport { initializeRasterLayersAndChannels } from '../components/spatial/utils';\nimport AbstractTwoStepLoader from './AbstractTwoStepLoader';\n\nfunction hexToRgb(hex) {\n  const result = /^#?([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})$/i.exec(hex);\n  return [parseInt(result[1].toLowerCase(), 16), parseInt(result[2].toLowerCase(), 16), parseInt(result[3].toLowerCase(), 16)];\n}\n\nexport default class OmeZarrLoader extends AbstractTwoStepLoader {\n  async load() {\n    var _rdefs$defaultT, _rdefs$defaultZ;\n\n    const payload = await this.dataSource.getJson('.zattrs').catch(reason => Promise.resolve(reason));\n\n    if (payload instanceof AbstractLoaderError) {\n      return Promise.reject(payload);\n    }\n\n    const loader = await loadOmeZarr(this.url, {\n      fetchOptions: this.requestInit,\n      type: 'multiscales'\n    });\n    const {\n      metadata,\n      data\n    } = loader;\n    const {\n      omero\n    } = metadata;\n\n    if (!omero) {\n      console.error('Path for image not valid');\n      return Promise.reject(payload);\n    }\n\n    const {\n      rdefs,\n      channels\n    } = omero;\n    const t = (_rdefs$defaultT = rdefs.defaultT) !== null && _rdefs$defaultT !== void 0 ? _rdefs$defaultT : 0;\n    const z = (_rdefs$defaultZ = rdefs.defaultZ) !== null && _rdefs$defaultZ !== void 0 ? _rdefs$defaultZ : 0;\n\n    const filterSelection = sel => {\n      // Remove selection keys for which there is no dimension.\n      if (data.length > 0) {\n        const nextSel = {}; // eslint-disable-next-line prefer-destructuring\n\n        const labels = data[0].labels;\n        Object.keys(sel).forEach(key => {\n          if (labels.includes(key)) {\n            nextSel[key] = sel[key];\n          }\n        });\n        return nextSel;\n      }\n\n      return sel;\n    };\n\n    const imagesWithLoaderCreators = [{\n      name: omero.name || 'Image',\n      channels: channels.map((channel, i) => ({\n        selection: filterSelection({\n          z,\n          t,\n          c: i\n        }),\n        slider: [channel.window.start, channel.window.end],\n        color: hexToRgb(channel.color)\n      })),\n      loaderCreator: async () => ({ ...loader,\n        channels: channels.map(c => c.label)\n      })\n    }]; // TODO: use options for initial selection of channels\n    // which omit domain/slider ranges.\n\n    const [autoImageLayers, imageLayerLoaders, imageLayerMeta] = await initializeRasterLayersAndChannels(imagesWithLoaderCreators, undefined);\n    const coordinationValues = {\n      spatialImageLayer: autoImageLayers\n    };\n    return Promise.resolve(new LoaderResult({\n      loaders: imageLayerLoaders,\n      meta: imageLayerMeta\n    }, [], coordinationValues));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/OmeZarrLoader.js"],"names":["loadOmeZarr","AbstractLoaderError","LoaderResult","initializeRasterLayersAndChannels","AbstractTwoStepLoader","hexToRgb","hex","result","exec","parseInt","toLowerCase","OmeZarrLoader","load","payload","dataSource","getJson","catch","reason","Promise","resolve","reject","loader","url","fetchOptions","requestInit","type","metadata","data","omero","console","error","rdefs","channels","t","defaultT","z","defaultZ","filterSelection","sel","length","nextSel","labels","Object","keys","forEach","key","includes","imagesWithLoaderCreators","name","map","channel","i","selection","c","slider","window","start","end","color","loaderCreator","label","autoImageLayers","imageLayerLoaders","imageLayerMeta","undefined","coordinationValues","spatialImageLayer","loaders","meta"],"mappings":"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","sourcesContent":["import { loadOmeZarr } from '@hms-dbmi/viv';\nimport { AbstractLoaderError } from './errors';\nimport LoaderResult from './LoaderResult';\n\nimport { initializeRasterLayersAndChannels } from '../components/spatial/utils';\nimport AbstractTwoStepLoader from './AbstractTwoStepLoader';\n\nfunction hexToRgb(hex) {\n  const result = /^#?([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})$/i.exec(hex);\n  return [\n    parseInt(result[1].toLowerCase(), 16),\n    parseInt(result[2].toLowerCase(), 16),\n    parseInt(result[3].toLowerCase(), 16),\n  ];\n}\n\nexport default class OmeZarrLoader extends AbstractTwoStepLoader {\n  async load() {\n    const payload = await this.dataSource.getJson('.zattrs').catch(reason => Promise.resolve(reason));\n    if (payload instanceof AbstractLoaderError) {\n      return Promise.reject(payload);\n    }\n\n    const loader = await loadOmeZarr(this.url, { fetchOptions: this.requestInit, type: 'multiscales' });\n    const { metadata, data } = loader;\n\n    const { omero } = metadata;\n\n    if (!omero) {\n      console.error('Path for image not valid');\n      return Promise.reject(payload);\n    }\n\n    const { rdefs, channels } = omero;\n\n    const t = rdefs.defaultT ?? 0;\n    const z = rdefs.defaultZ ?? 0;\n\n    const filterSelection = (sel) => {\n      // Remove selection keys for which there is no dimension.\n      if (data.length > 0) {\n        const nextSel = {};\n        // eslint-disable-next-line prefer-destructuring\n        const labels = data[0].labels;\n        Object.keys(sel).forEach((key) => {\n          if (labels.includes(key)) {\n            nextSel[key] = sel[key];\n          }\n        });\n        return nextSel;\n      }\n      return sel;\n    };\n\n    const imagesWithLoaderCreators = [\n      {\n        name: omero.name || 'Image',\n        channels: channels.map((channel, i) => ({\n          selection: filterSelection({ z, t, c: i }),\n          slider: [channel.window.start, channel.window.end],\n          color: hexToRgb(channel.color),\n        })),\n        loaderCreator: async () => ({ ...loader, channels: channels.map(c => c.label) }),\n      },\n    ];\n\n    // TODO: use options for initial selection of channels\n    // which omit domain/slider ranges.\n    const [\n      autoImageLayers, imageLayerLoaders, imageLayerMeta,\n    ] = await initializeRasterLayersAndChannels(\n      imagesWithLoaderCreators, undefined,\n    );\n\n    const coordinationValues = {\n      spatialImageLayer: autoImageLayers,\n    };\n    return Promise.resolve(new LoaderResult(\n      { loaders: imageLayerLoaders, meta: imageLayerMeta },\n      [],\n      coordinationValues,\n    ));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}