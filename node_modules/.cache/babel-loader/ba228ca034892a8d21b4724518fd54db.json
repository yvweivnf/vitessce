{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransformMode = void 0;\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _translateMode = require(\"./translate-mode\");\n\nvar _scaleMode = require(\"./scale-mode\");\n\nvar _rotateMode = require(\"./rotate-mode\");\n\nvar _compositeMode = require(\"./composite-mode\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar TransformMode = /*#__PURE__*/function (_CompositeMode) {\n  _inherits(TransformMode, _CompositeMode);\n\n  var _super = _createSuper(TransformMode);\n\n  function TransformMode() {\n    _classCallCheck(this, TransformMode);\n\n    return _super.call(this, [new _translateMode.TranslateMode(), new _scaleMode.ScaleMode(), new _rotateMode.RotateMode()]);\n  }\n\n  _createClass(TransformMode, [{\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      var updatedCursor = null;\n\n      _get(_getPrototypeOf(TransformMode.prototype), \"handlePointerMove\", this).call(this, event, _objectSpread({}, props, {\n        onUpdateCursor: function onUpdateCursor(cursor) {\n          updatedCursor = cursor || updatedCursor;\n        }\n      }));\n\n      props.onUpdateCursor(updatedCursor);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      var scaleMode = null;\n      var translateMode = null;\n      var filteredModes = []; // If the user selects a scaling edit handle that overlaps with part of the selected feature,\n      // it is possible for both scale and translate actions to be triggered. This logic prevents\n      // this simultaneous action trigger from happening by putting a higher priority on scaling\n      // since the user needs to be more precise to hover over a scaling edit handle.\n\n      this._modes.forEach(function (mode) {\n        if (mode instanceof _translateMode.TranslateMode) {\n          translateMode = mode;\n        } else {\n          if (mode instanceof _scaleMode.ScaleMode) {\n            scaleMode = mode;\n          }\n\n          filteredModes.push(mode);\n        }\n      });\n\n      if (scaleMode instanceof _scaleMode.ScaleMode && !scaleMode.isEditHandleSelected()) {\n        filteredModes.push(translateMode);\n      }\n\n      filteredModes.filter(Boolean).forEach(function (mode) {\n        return mode.handleStartDragging(event, props);\n      });\n    }\n  }, {\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var compositeGuides = _get(_getPrototypeOf(TransformMode.prototype), \"getGuides\", this).call(this, props);\n\n      var rotateMode = (this._modes || []).find(function (mode) {\n        return mode instanceof _rotateMode.RotateMode;\n      });\n\n      if (rotateMode instanceof _rotateMode.RotateMode) {\n        var nonEnvelopeGuides = compositeGuides.features.filter(function (guide) {\n          var _ref = guide.properties || {},\n              editHandleType = _ref.editHandleType,\n              mode = _ref.mode; // Both scale and rotate modes have the same enveloping box as a guide - only need one\n\n\n          var guidesToFilterOut = [mode]; // Do not render scaling edit handles if rotating\n\n          if (rotateMode.getIsRotating()) {\n            guidesToFilterOut.push(editHandleType);\n          }\n\n          return !guidesToFilterOut.includes('scale');\n        }); // @ts-ignore\n\n        compositeGuides = (0, _helpers.featureCollection)(nonEnvelopeGuides);\n      }\n\n      return compositeGuides;\n    }\n  }]);\n\n  return TransformMode;\n}(_compositeMode.CompositeMode);\n\nexports.TransformMode = TransformMode;","map":{"version":3,"sources":["../../src/lib/transform-mode.ts"],"names":["TransformMode","CompositeMode","TranslateMode","ScaleMode","RotateMode","event","props","updatedCursor","onUpdateCursor","cursor","scaleMode","translateMode","filteredModes","mode","compositeGuides","rotateMode","nonEnvelopeGuides","editHandleType","guide","guidesToFilterOut"],"mappings":"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","sourcesContent":["import { featureCollection } from '@turf/helpers';\nimport { PointerMoveEvent, ModeProps, StartDraggingEvent } from '../types';\nimport { FeatureCollection } from '../geojson-types';\nimport { TranslateMode } from './translate-mode';\nimport { ScaleMode } from './scale-mode';\nimport { RotateMode } from './rotate-mode';\n\nimport { CompositeMode } from './composite-mode';\n\nexport class TransformMode extends CompositeMode {\n  constructor() {\n    super([new TranslateMode(), new ScaleMode(), new RotateMode()]);\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    let updatedCursor = null;\n    super.handlePointerMove(event, {\n      ...props,\n      onUpdateCursor: (cursor) => {\n        updatedCursor = cursor || updatedCursor;\n      },\n    });\n    props.onUpdateCursor(updatedCursor);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    let scaleMode = null;\n    let translateMode = null;\n    const filteredModes = [];\n\n    // If the user selects a scaling edit handle that overlaps with part of the selected feature,\n    // it is possible for both scale and translate actions to be triggered. This logic prevents\n    // this simultaneous action trigger from happening by putting a higher priority on scaling\n    // since the user needs to be more precise to hover over a scaling edit handle.\n    this._modes.forEach((mode) => {\n      if (mode instanceof TranslateMode) {\n        translateMode = mode;\n      } else {\n        if (mode instanceof ScaleMode) {\n          scaleMode = mode;\n        }\n        filteredModes.push(mode);\n      }\n    });\n\n    if (scaleMode instanceof ScaleMode && !scaleMode.isEditHandleSelected()) {\n      filteredModes.push(translateMode);\n    }\n\n    filteredModes.filter(Boolean).forEach((mode) => mode.handleStartDragging(event, props));\n  }\n\n  getGuides(props: ModeProps<FeatureCollection>) {\n    let compositeGuides = super.getGuides(props);\n    const rotateMode = (this._modes || []).find((mode) => mode instanceof RotateMode);\n\n    if (rotateMode instanceof RotateMode) {\n      const nonEnvelopeGuides = compositeGuides.features.filter((guide) => {\n        const { editHandleType, mode } = (guide.properties as any) || {};\n        // Both scale and rotate modes have the same enveloping box as a guide - only need one\n        const guidesToFilterOut = [mode];\n        // Do not render scaling edit handles if rotating\n        if (rotateMode.getIsRotating()) {\n          guidesToFilterOut.push(editHandleType);\n        }\n        return !guidesToFilterOut.includes('scale');\n      });\n      // @ts-ignore\n      compositeGuides = featureCollection(nonEnvelopeGuides);\n    }\n    return compositeGuides;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}