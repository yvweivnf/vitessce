{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { isString } from 'vega-util';\nimport { TUPLE } from '.';\nimport { varName } from '../../util';\nimport inputBindings from './inputs';\nimport toggle, { TOGGLE } from './toggle';\nvar clear = {\n  defined: function defined(selCmpt) {\n    return selCmpt.clear !== undefined && selCmpt.clear !== false;\n  },\n  parse: function parse(model, selCmpt) {\n    if (selCmpt.clear) {\n      selCmpt.clear = isString(selCmpt.clear) ? parseSelector(selCmpt.clear, 'view') : selCmpt.clear;\n    }\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    if (inputBindings.defined(selCmpt)) {\n      var _iterator = _createForOfIteratorHelper(selCmpt.project.items),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var proj = _step.value;\n          var idx = signals.findIndex(function (n) {\n            return n.name === varName(\"\".concat(selCmpt.name, \"_\").concat(proj.field));\n          });\n\n          if (idx !== -1) {\n            signals[idx].on.push({\n              events: selCmpt.clear,\n              update: 'null'\n            });\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return signals;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    function addClear(idx, update) {\n      if (idx !== -1 && _signals[idx].on) {\n        _signals[idx].on.push({\n          events: selCmpt.clear,\n          update: update\n        });\n      }\n    } // Be as minimalist as possible when adding clear triggers to minimize dataflow execution.\n\n\n    if (selCmpt.type === 'interval') {\n      var _iterator2 = _createForOfIteratorHelper(selCmpt.project.items),\n          _step2;\n\n      try {\n        var _loop2 = function _loop2() {\n          var proj = _step2.value;\n\n          var vIdx = _signals.findIndex(function (n) {\n            return n.name === proj.signals.visual;\n          });\n\n          addClear(vIdx, '[0, 0]');\n\n          if (vIdx === -1) {\n            var dIdx = _signals.findIndex(function (n) {\n              return n.name === proj.signals.data;\n            });\n\n            addClear(dIdx, 'null');\n          }\n        };\n\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else {\n      var tIdx = _signals.findIndex(function (n) {\n        return n.name === selCmpt.name + TUPLE;\n      });\n\n      addClear(tIdx, 'null');\n\n      if (toggle.defined(selCmpt)) {\n        tIdx = _signals.findIndex(function (n) {\n          return n.name === selCmpt.name + TOGGLE;\n        });\n        addClear(tIdx, 'false');\n      }\n    }\n\n    return _signals;\n  }\n};\nexport default clear;","map":{"version":3,"sources":["../../../../src/compile/selection/clear.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { selector as parseSelector } from 'vega-event-selector';\nimport { isString } from 'vega-util';\nimport { TUPLE } from '.';\nimport { varName } from '../../util';\nimport inputBindings from './inputs';\nimport toggle, { TOGGLE } from './toggle';\nconst clear = {\n    defined: selCmpt => {\n        return selCmpt.clear !== undefined && selCmpt.clear !== false;\n    },\n    parse: (model, selCmpt) => {\n        if (selCmpt.clear) {\n            selCmpt.clear = isString(selCmpt.clear) ? parseSelector(selCmpt.clear, 'view') : selCmpt.clear;\n        }\n    },\n    topLevelSignals: (model, selCmpt, signals) => {\n        if (inputBindings.defined(selCmpt)) {\n            for (const proj of selCmpt.project.items) {\n                const idx = signals.findIndex(n => n.name === varName(`${selCmpt.name}_${proj.field}`));\n                if (idx !== -1) {\n                    signals[idx].on.push({ events: selCmpt.clear, update: 'null' });\n                }\n            }\n        }\n        return signals;\n    },\n    signals: (model, selCmpt, signals) => {\n        function addClear(idx, update) {\n            if (idx !== -1 && signals[idx].on) {\n                signals[idx].on.push({ events: selCmpt.clear, update });\n            }\n        }\n        // Be as minimalist as possible when adding clear triggers to minimize dataflow execution.\n        if (selCmpt.type === 'interval') {\n            for (const proj of selCmpt.project.items) {\n                const vIdx = signals.findIndex(n => n.name === proj.signals.visual);\n                addClear(vIdx, '[0, 0]');\n                if (vIdx === -1) {\n                    const dIdx = signals.findIndex(n => n.name === proj.signals.data);\n                    addClear(dIdx, 'null');\n                }\n            }\n        }\n        else {\n            let tIdx = signals.findIndex(n => n.name === selCmpt.name + TUPLE);\n            addClear(tIdx, 'null');\n            if (toggle.defined(selCmpt)) {\n                tIdx = signals.findIndex(n => n.name === selCmpt.name + TOGGLE);\n                addClear(tIdx, 'false');\n            }\n        }\n        return signals;\n    }\n};\nexport default clear;\n//# sourceMappingURL=clear.js.map"]},"metadata":{},"sourceType":"module"}