{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/* eslint max-len: [\"error\", { \"code\": 120 }] */\nimport { getFloat16 } from '@petamoriken/float16';\nimport { parse } from 'txml/txml';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb';\nimport { getDecoder } from './compression';\nimport { resample, resampleInterleaved } from './resample';\n\nfunction sum(array, start, end) {\n  var s = 0;\n\n  for (var i = start; i < end; ++i) {\n    s += array[i];\n  }\n\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1:\n      // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n\n      break;\n\n    case 2:\n      // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n\n      break;\n\n    case 3:\n      // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n\n        case 64:\n          return new Float64Array(size);\n\n        default:\n          break;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  var view = new DataView(inBuffer);\n  var outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;\n  var samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;\n  var outArray = arrayForType(format, bitsPerSample, outSize); // let pixel = 0;\n\n  var bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) {\n    // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    var pixelBitSkip; // let sampleBitOffset = 0;\n\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample; // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    } // Bits per line rounds up to next byte boundary.\n\n\n    var bitsPerLine = tileWidth * pixelBitSkip;\n\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = bitsPerLine + 7 & ~7;\n    }\n\n    for (var y = 0; y < tileHeight; ++y) {\n      var lineBitOffset = y * bitsPerLine;\n\n      for (var x = 0; x < tileWidth; ++x) {\n        var pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;\n\n        for (var i = 0; i < samplesToTransfer; ++i) {\n          var bitOffset = pixelBitOffset + i * bitsPerSample;\n          var outIndex = (y * tileWidth + x) * samplesToTransfer + i;\n          var byteOffset = Math.floor(bitOffset / 8);\n          var innerBitOffset = bitOffset % 8;\n\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            var raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);\n            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;\n          } else {\n            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;\n          } // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n\n        } // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n\n      }\n    }\n  } else if (format === 3) {// floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n/**\n * GeoTIFF sub-file image.\n */\n\n\nvar GeoTIFFImage = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  function GeoTIFFImage(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    _classCallCheck(this, GeoTIFFImage);\n\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    var planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;\n\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n\n\n  _createClass(GeoTIFFImage, [{\n    key: \"getFileDirectory\",\n    value: function getFileDirectory() {\n      return this.fileDirectory;\n    }\n    /**\n     * Returns the associated parsed geo keys.\n     * @returns {Object} the parsed geo keys\n     */\n\n  }, {\n    key: \"getGeoKeys\",\n    value: function getGeoKeys() {\n      return this.geoKeys;\n    }\n    /**\n     * Returns the width of the image.\n     * @returns {Number} the width of the image\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.fileDirectory.ImageWidth;\n    }\n    /**\n     * Returns the height of the image.\n     * @returns {Number} the height of the image\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.fileDirectory.ImageLength;\n    }\n    /**\n     * Returns the number of samples per pixel.\n     * @returns {Number} the number of samples per pixel\n     */\n\n  }, {\n    key: \"getSamplesPerPixel\",\n    value: function getSamplesPerPixel() {\n      return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;\n    }\n    /**\n     * Returns the width of each tile.\n     * @returns {Number} the width of each tile\n     */\n\n  }, {\n    key: \"getTileWidth\",\n    value: function getTileWidth() {\n      return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n    }\n    /**\n     * Returns the height of each tile.\n     * @returns {Number} the height of each tile\n     */\n\n  }, {\n    key: \"getTileHeight\",\n    value: function getTileHeight() {\n      if (this.isTiled) {\n        return this.fileDirectory.TileLength;\n      }\n\n      if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n        return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n      }\n\n      return this.getHeight();\n    }\n  }, {\n    key: \"getBlockWidth\",\n    value: function getBlockWidth() {\n      return this.getTileWidth();\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight(y) {\n      if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n        return this.getTileHeight();\n      } else {\n        return this.getHeight() - y * this.getTileHeight();\n      }\n    }\n    /**\n     * Calculates the number of bytes for each pixel across all samples. Only full\n     * bytes are supported, an exception is thrown when this is not the case.\n     * @returns {Number} the bytes per pixel\n     */\n\n  }, {\n    key: \"getBytesPerPixel\",\n    value: function getBytesPerPixel() {\n      var bytes = 0;\n\n      for (var i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n        bytes += this.getSampleByteSize(i);\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"getSampleByteSize\",\n    value: function getSampleByteSize(i) {\n      if (i >= this.fileDirectory.BitsPerSample.length) {\n        throw new RangeError(\"Sample index \".concat(i, \" is out of range.\"));\n      }\n\n      return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n    }\n  }, {\n    key: \"getReaderForSample\",\n    value: function getReaderForSample(sampleIndex) {\n      var format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n      var bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n\n      switch (format) {\n        case 1:\n          // unsigned integer data\n          if (bitsPerSample <= 8) {\n            return DataView.prototype.getUint8;\n          } else if (bitsPerSample <= 16) {\n            return DataView.prototype.getUint16;\n          } else if (bitsPerSample <= 32) {\n            return DataView.prototype.getUint32;\n          }\n\n          break;\n\n        case 2:\n          // twos complement signed integer data\n          if (bitsPerSample <= 8) {\n            return DataView.prototype.getInt8;\n          } else if (bitsPerSample <= 16) {\n            return DataView.prototype.getInt16;\n          } else if (bitsPerSample <= 32) {\n            return DataView.prototype.getInt32;\n          }\n\n          break;\n\n        case 3:\n          switch (bitsPerSample) {\n            case 16:\n              return function (offset, littleEndian) {\n                return getFloat16(this, offset, littleEndian);\n              };\n\n            case 32:\n              return DataView.prototype.getFloat32;\n\n            case 64:\n              return DataView.prototype.getFloat64;\n\n            default:\n              break;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      throw Error('Unsupported data format/bitsPerSample');\n    }\n  }, {\n    key: \"getSampleFormat\",\n    value: function getSampleFormat() {\n      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    }\n  }, {\n    key: \"getBitsPerSample\",\n    value: function getBitsPerSample() {\n      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.fileDirectory.BitsPerSample[sampleIndex];\n    }\n  }, {\n    key: \"getArrayForSample\",\n    value: function getArrayForSample(sampleIndex, size) {\n      var format = this.getSampleFormat(sampleIndex);\n      var bitsPerSample = this.getBitsPerSample(sampleIndex);\n      return arrayForType(format, bitsPerSample, size);\n    }\n    /**\n     * Returns the decoded strip or tile.\n     * @param {Number} x the strip or tile x-offset\n     * @param {Number} y the tile y-offset (0 for stripped images)\n     * @param {Number} sample the sample to get for separated samples\n     * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     * @returns {Promise.<ArrayBuffer>}\n     */\n\n  }, {\n    key: \"getTileOrStrip\",\n    value: function () {\n      var _getTileOrStrip = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(x, y, sample, poolOrDecoder, signal) {\n        var _this = this;\n\n        var numTilesPerRow, numTilesPerCol, index, tiles, offset, byteCount, slice, request;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n                numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n                tiles = this.tiles;\n\n                if (this.planarConfiguration === 1) {\n                  index = y * numTilesPerRow + x;\n                } else if (this.planarConfiguration === 2) {\n                  index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n                }\n\n                if (this.isTiled) {\n                  offset = this.fileDirectory.TileOffsets[index];\n                  byteCount = this.fileDirectory.TileByteCounts[index];\n                } else {\n                  offset = this.fileDirectory.StripOffsets[index];\n                  byteCount = this.fileDirectory.StripByteCounts[index];\n                }\n\n                _context2.next = 7;\n                return this.source.fetch([{\n                  offset: offset,\n                  length: byteCount\n                }], signal);\n\n              case 7:\n                slice = _context2.sent[0];\n\n                if (tiles === null || !tiles[index]) {\n                  // resolve each request by potentially applying array normalization\n                  request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var data, sampleFormat, bitsPerSample;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return poolOrDecoder.decode(_this.fileDirectory, slice);\n\n                          case 2:\n                            data = _context.sent;\n                            sampleFormat = _this.getSampleFormat();\n                            bitsPerSample = _this.getBitsPerSample();\n\n                            if (needsNormalization(sampleFormat, bitsPerSample)) {\n                              data = normalizeArray(data, sampleFormat, _this.planarConfiguration, _this.getSamplesPerPixel(), bitsPerSample, _this.getTileWidth(), _this.getBlockHeight(y));\n                            }\n\n                            return _context.abrupt(\"return\", data);\n\n                          case 7:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }))(); // set the cache\n\n                  if (tiles !== null) {\n                    tiles[index] = request;\n                  }\n                } else {\n                  // get from the cache\n                  request = tiles[index];\n                } // cache the tile request\n\n\n                _context2.t0 = x;\n                _context2.t1 = y;\n                _context2.t2 = sample;\n                _context2.next = 14;\n                return request;\n\n              case 14:\n                _context2.t3 = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  x: _context2.t0,\n                  y: _context2.t1,\n                  sample: _context2.t2,\n                  data: _context2.t3\n                });\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getTileOrStrip(_x, _x2, _x3, _x4, _x5) {\n        return _getTileOrStrip.apply(this, arguments);\n      }\n\n      return getTileOrStrip;\n    }()\n    /**\n     * Internal read function.\n     * @private\n     * @param {Array} imageWindow The image window in pixel coordinates\n     * @param {Array} samples The selected samples (0-based indices)\n     * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n     * @param {Boolean} interleave Whether or not to write in an interleaved manner\n     * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n     * @param {number} width the width of window to be read into\n     * @param {number} height the height of window to be read into\n     * @param {number} resampleMethod the resampling method to be used when interpolating\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n     */\n\n  }, {\n    key: \"_readRaster\",\n    value: function () {\n      var _readRaster2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n        var _this2 = this;\n\n        var tileWidth, tileHeight, minXTile, maxXTile, minYTile, maxYTile, windowWidth, bytesPerPixel, srcSampleOffsets, sampleReaders, i, promises, littleEndian, yTile, xTile, _loop, sampleIndex, resampled;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                tileWidth = this.getTileWidth();\n                tileHeight = this.getTileHeight();\n                minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n                maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(this.getWidth() / this.getTileWidth()));\n                minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n                maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(this.getHeight() / this.getTileHeight()));\n                windowWidth = imageWindow[2] - imageWindow[0];\n                bytesPerPixel = this.getBytesPerPixel();\n                srcSampleOffsets = [];\n                sampleReaders = [];\n\n                for (i = 0; i < samples.length; ++i) {\n                  if (this.planarConfiguration === 1) {\n                    srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n                  } else {\n                    srcSampleOffsets.push(0);\n                  }\n\n                  sampleReaders.push(this.getReaderForSample(samples[i]));\n                }\n\n                promises = [];\n                littleEndian = this.littleEndian;\n\n                for (yTile = minYTile; yTile < maxYTile; ++yTile) {\n                  for (xTile = minXTile; xTile < maxXTile; ++xTile) {\n                    _loop = function _loop(sampleIndex) {\n                      var si = sampleIndex;\n                      var sample = samples[sampleIndex];\n\n                      if (_this2.planarConfiguration === 2) {\n                        bytesPerPixel = _this2.getSampleByteSize(sampleIndex);\n                      }\n\n                      var promise = _this2.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then(function (tile) {\n                        var buffer = tile.data;\n                        var dataView = new DataView(buffer);\n\n                        var blockHeight = _this2.getBlockHeight(tile.y);\n\n                        var firstLine = tile.y * tileHeight;\n                        var firstCol = tile.x * tileWidth;\n                        var lastLine = firstLine + blockHeight;\n                        var lastCol = (tile.x + 1) * tileWidth;\n                        var reader = sampleReaders[si];\n                        var ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]));\n                        var xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]));\n\n                        for (var y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n                          for (var x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                            var pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                            var value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);\n                            var windowCoordinate = void 0;\n\n                            if (interleave) {\n                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;\n                              valueArrays[windowCoordinate] = value;\n                            } else {\n                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];\n                              valueArrays[si][windowCoordinate] = value;\n                            }\n                          }\n                        }\n                      });\n\n                      promises.push(promise);\n                    };\n\n                    for (sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n                      _loop(sampleIndex);\n                    }\n                  }\n                }\n\n                _context3.next = 16;\n                return Promise.all(promises);\n\n              case 16:\n                if (!(width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                if (interleave) {\n                  resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);\n                } else {\n                  resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);\n                }\n\n                resampled.width = width;\n                resampled.height = height;\n                return _context3.abrupt(\"return\", resampled);\n\n              case 21:\n                valueArrays.width = width || imageWindow[2] - imageWindow[0];\n                valueArrays.height = height || imageWindow[3] - imageWindow[1];\n                return _context3.abrupt(\"return\", valueArrays);\n\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _readRaster(_x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14) {\n        return _readRaster2.apply(this, arguments);\n      }\n\n      return _readRaster;\n    }()\n    /**\n     * Reads raster data from the image. This function reads all selected samples\n     * into separate arrays of the correct type for that sample or into a single\n     * combined array when `interleave` is set. When provided, only a subset\n     * of the raster is read for each sample.\n     *\n     * @param {Object} [options={}] optional parameters\n     * @param {Array} [options.window=whole image] the subset to read data from.\n     * @param {Array} [options.samples=all samples] the selection of samples to read from.\n     * @param {Boolean} [options.interleave=false] whether the data shall be read\n     *                                             in one single array or separate\n     *                                             arrays.\n     * @param {Number} [options.pool=null] The optional decoder pool to use.\n     * @param {number} [options.width] The desired width of the output. When the width is\n     *                                 not the same as the images, resampling will be\n     *                                 performed.\n     * @param {number} [options.height] The desired height of the output. When the width\n     *                                  is not the same as the images, resampling will\n     *                                  be performed.\n     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n     * @param {number|number[]} [options.fillValue] The value to use for parts of the image\n     *                                              outside of the images extent. When\n     *                                              multiple samples are requested, an\n     *                                              array of fill values can be passed.\n     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n     *                                       to be aborted\n     * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n     */\n\n  }, {\n    key: \"readRasters\",\n    value: function () {\n      var _readRasters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _ref2,\n            wnd,\n            _ref2$samples,\n            samples,\n            interleave,\n            _ref2$pool,\n            pool,\n            width,\n            height,\n            resampleMethod,\n            fillValue,\n            signal,\n            imageWindow,\n            imageWindowWidth,\n            imageWindowHeight,\n            numPixels,\n            samplesPerPixel,\n            i,\n            _i,\n            valueArrays,\n            format,\n            bitsPerSample,\n            _i2,\n            valueArray,\n            poolOrDecoder,\n            result,\n            _args4 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _ref2 = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {}, wnd = _ref2.window, _ref2$samples = _ref2.samples, samples = _ref2$samples === void 0 ? [] : _ref2$samples, interleave = _ref2.interleave, _ref2$pool = _ref2.pool, pool = _ref2$pool === void 0 ? null : _ref2$pool, width = _ref2.width, height = _ref2.height, resampleMethod = _ref2.resampleMethod, fillValue = _ref2.fillValue, signal = _ref2.signal;\n                imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n                if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new Error('Invalid subsets');\n\n              case 4:\n                imageWindowWidth = imageWindow[2] - imageWindow[0];\n                imageWindowHeight = imageWindow[3] - imageWindow[1];\n                numPixels = imageWindowWidth * imageWindowHeight;\n                samplesPerPixel = this.getSamplesPerPixel();\n\n                if (!(!samples || !samples.length)) {\n                  _context4.next = 12;\n                  break;\n                }\n\n                for (i = 0; i < samplesPerPixel; ++i) {\n                  samples.push(i);\n                }\n\n                _context4.next = 19;\n                break;\n\n              case 12:\n                _i = 0;\n\n              case 13:\n                if (!(_i < samples.length)) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                if (!(samples[_i] >= samplesPerPixel)) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.reject(new RangeError(\"Invalid sample index '\".concat(samples[_i], \"'.\"))));\n\n              case 16:\n                ++_i;\n                _context4.next = 13;\n                break;\n\n              case 19:\n                if (interleave) {\n                  format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n                  bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n                  valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n\n                  if (fillValue) {\n                    valueArrays.fill(fillValue);\n                  }\n                } else {\n                  valueArrays = [];\n\n                  for (_i2 = 0; _i2 < samples.length; ++_i2) {\n                    valueArray = this.getArrayForSample(samples[_i2], numPixels);\n\n                    if (Array.isArray(fillValue) && _i2 < fillValue.length) {\n                      valueArray.fill(fillValue[_i2]);\n                    } else if (fillValue && !Array.isArray(fillValue)) {\n                      valueArray.fill(fillValue);\n                    }\n\n                    valueArrays.push(valueArray);\n                  }\n                }\n\n                poolOrDecoder = pool || getDecoder(this.fileDirectory);\n                _context4.next = 23;\n                return this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);\n\n              case 23:\n                result = _context4.sent;\n                return _context4.abrupt(\"return\", result);\n\n              case 25:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function readRasters() {\n        return _readRasters.apply(this, arguments);\n      }\n\n      return readRasters;\n    }()\n    /**\n     * Reads raster data from the image as RGB. The result is always an\n     * interleaved typed array.\n     * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n     * When no other method is applicable, the first sample is used to produce a\n     * greayscale image.\n     * When provided, only a subset of the raster is read for each sample.\n     *\n     * @param {Object} [options] optional parameters\n     * @param {Array} [options.window=whole image] the subset to read data from.\n     * @param {Number} [options.pool=null] The optional decoder pool to use.\n     * @param {number} [options.width] The desired width of the output. When the width is no the\n     *                                 same as the images, resampling will be performed.\n     * @param {number} [options.height] The desired height of the output. When the width is no the\n     *                                  same as the images, resampling will be performed.\n     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n     * @param {bool} [options.enableAlpha=false] Enable reading alpha channel if present.\n     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n     *                                       to be aborted\n     * @returns {Promise.<TypedArray|TypedArray[]>} the RGB array as a Promise\n     */\n\n  }, {\n    key: \"readRGB\",\n    value: function () {\n      var _readRGB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _ref3,\n            window,\n            _ref3$pool,\n            pool,\n            width,\n            height,\n            resampleMethod,\n            _ref3$enableAlpha,\n            enableAlpha,\n            signal,\n            imageWindow,\n            pi,\n            s,\n            i,\n            samples,\n            subOptions,\n            fileDirectory,\n            raster,\n            max,\n            data,\n            _args5 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _ref3 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, window = _ref3.window, _ref3$pool = _ref3.pool, pool = _ref3$pool === void 0 ? null : _ref3$pool, width = _ref3.width, height = _ref3.height, resampleMethod = _ref3.resampleMethod, _ref3$enableAlpha = _ref3.enableAlpha, enableAlpha = _ref3$enableAlpha === void 0 ? false : _ref3$enableAlpha, signal = _ref3.signal;\n                imageWindow = window || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n                if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                throw new Error('Invalid subsets');\n\n              case 4:\n                pi = this.fileDirectory.PhotometricInterpretation;\n\n                if (!(pi === photometricInterpretations.RGB)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                s = [0, 1, 2];\n\n                if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {\n                  s = [];\n\n                  for (i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n                    s.push(i);\n                  }\n                }\n\n                return _context5.abrupt(\"return\", this.readRasters({\n                  window: window,\n                  interleave: true,\n                  samples: s,\n                  pool: pool,\n                  width: width,\n                  height: height,\n                  resampleMethod: resampleMethod,\n                  signal: signal\n                }));\n\n              case 9:\n                _context5.t0 = pi;\n                _context5.next = _context5.t0 === photometricInterpretations.WhiteIsZero ? 12 : _context5.t0 === photometricInterpretations.BlackIsZero ? 12 : _context5.t0 === photometricInterpretations.Palette ? 12 : _context5.t0 === photometricInterpretations.CMYK ? 14 : _context5.t0 === photometricInterpretations.YCbCr ? 16 : _context5.t0 === photometricInterpretations.CIELab ? 16 : 18;\n                break;\n\n              case 12:\n                samples = [0];\n                return _context5.abrupt(\"break\", 19);\n\n              case 14:\n                samples = [0, 1, 2, 3];\n                return _context5.abrupt(\"break\", 19);\n\n              case 16:\n                samples = [0, 1, 2];\n                return _context5.abrupt(\"break\", 19);\n\n              case 18:\n                throw new Error('Invalid or unsupported photometric interpretation.');\n\n              case 19:\n                subOptions = {\n                  window: imageWindow,\n                  interleave: true,\n                  samples: samples,\n                  pool: pool,\n                  width: width,\n                  height: height,\n                  resampleMethod: resampleMethod,\n                  signal: signal\n                };\n                fileDirectory = this.fileDirectory;\n                _context5.next = 23;\n                return this.readRasters(subOptions);\n\n              case 23:\n                raster = _context5.sent;\n                max = Math.pow(2, this.fileDirectory.BitsPerSample[0]);\n                _context5.t1 = pi;\n                _context5.next = _context5.t1 === photometricInterpretations.WhiteIsZero ? 28 : _context5.t1 === photometricInterpretations.BlackIsZero ? 30 : _context5.t1 === photometricInterpretations.Palette ? 32 : _context5.t1 === photometricInterpretations.CMYK ? 34 : _context5.t1 === photometricInterpretations.YCbCr ? 36 : _context5.t1 === photometricInterpretations.CIELab ? 38 : 40;\n                break;\n\n              case 28:\n                data = fromWhiteIsZero(raster, max);\n                return _context5.abrupt(\"break\", 41);\n\n              case 30:\n                data = fromBlackIsZero(raster, max);\n                return _context5.abrupt(\"break\", 41);\n\n              case 32:\n                data = fromPalette(raster, fileDirectory.ColorMap);\n                return _context5.abrupt(\"break\", 41);\n\n              case 34:\n                data = fromCMYK(raster);\n                return _context5.abrupt(\"break\", 41);\n\n              case 36:\n                data = fromYCbCr(raster);\n                return _context5.abrupt(\"break\", 41);\n\n              case 38:\n                data = fromCIELab(raster);\n                return _context5.abrupt(\"break\", 41);\n\n              case 40:\n                throw new Error('Unsupported photometric interpretation.');\n\n              case 41:\n                data.width = raster.width;\n                data.height = raster.height;\n                return _context5.abrupt(\"return\", data);\n\n              case 44:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function readRGB() {\n        return _readRGB.apply(this, arguments);\n      }\n\n      return readRGB;\n    }()\n    /**\n     * Returns an array of tiepoints.\n     * @returns {Object[]}\n     */\n\n  }, {\n    key: \"getTiePoints\",\n    value: function getTiePoints() {\n      if (!this.fileDirectory.ModelTiepoint) {\n        return [];\n      }\n\n      var tiePoints = [];\n\n      for (var i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n        tiePoints.push({\n          i: this.fileDirectory.ModelTiepoint[i],\n          j: this.fileDirectory.ModelTiepoint[i + 1],\n          k: this.fileDirectory.ModelTiepoint[i + 2],\n          x: this.fileDirectory.ModelTiepoint[i + 3],\n          y: this.fileDirectory.ModelTiepoint[i + 4],\n          z: this.fileDirectory.ModelTiepoint[i + 5]\n        });\n      }\n\n      return tiePoints;\n    }\n    /**\n     * Returns the parsed GDAL metadata items.\n     *\n     * If sample is passed to null, dataset-level metadata will be returned.\n     * Otherwise only metadata specific to the provided sample will be returned.\n     *\n     * @param {Number} [sample=null] The sample index.\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"getGDALMetadata\",\n    value: function getGDALMetadata() {\n      var sample = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var metadata = {};\n\n      if (!this.fileDirectory.GDAL_METADATA) {\n        return null;\n      }\n\n      var string = this.fileDirectory.GDAL_METADATA;\n      var xmlDom = parse(string.substring(0, string.length - 1));\n\n      if (!xmlDom[0].tagName) {\n        throw new Error('Failed to parse GDAL metadata XML.');\n      }\n\n      var root = xmlDom[0];\n\n      if (root.tagName !== 'GDALMetadata') {\n        throw new Error('Unexpected GDAL metadata XML tag.');\n      }\n\n      var items = root.children.filter(function (child) {\n        return child.tagName === 'Item';\n      });\n\n      if (sample !== null) {\n        items = items.filter(function (item) {\n          return Number(item.attributes.sample) === sample;\n        });\n      }\n\n      for (var i = 0; i < items.length; ++i) {\n        var item = items[i];\n        metadata[item.attributes.name] = item.children[0];\n      }\n\n      return metadata;\n    }\n    /**\n     * Returns the GDAL nodata value\n     * @returns {Number} or null\n     */\n\n  }, {\n    key: \"getGDALNoData\",\n    value: function getGDALNoData() {\n      if (!this.fileDirectory.GDAL_NODATA) {\n        return null;\n      }\n\n      var string = this.fileDirectory.GDAL_NODATA;\n      return Number(string.substring(0, string.length - 1));\n    }\n    /**\n     * Returns the image origin as a XYZ-vector. When the image has no affine\n     * transformation, then an exception is thrown.\n     * @returns {Array} The origin as a vector\n     */\n\n  }, {\n    key: \"getOrigin\",\n    value: function getOrigin() {\n      var tiePoints = this.fileDirectory.ModelTiepoint;\n      var modelTransformation = this.fileDirectory.ModelTransformation;\n\n      if (tiePoints && tiePoints.length === 6) {\n        return [tiePoints[3], tiePoints[4], tiePoints[5]];\n      }\n\n      if (modelTransformation) {\n        return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];\n      }\n\n      throw new Error('The image does not have an affine transformation.');\n    }\n    /**\n     * Returns the image resolution as a XYZ-vector. When the image has no affine\n     * transformation, then an exception is thrown.\n     * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n     *                                             in cases when the current image does not have the\n     *                                             required tags on its own.\n     * @returns {Array} The resolution as a vector\n     */\n\n  }, {\n    key: \"getResolution\",\n    value: function getResolution() {\n      var referenceImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var modelPixelScale = this.fileDirectory.ModelPixelScale;\n      var modelTransformation = this.fileDirectory.ModelTransformation;\n\n      if (modelPixelScale) {\n        return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n      }\n\n      if (modelTransformation) {\n        return [modelTransformation[0], modelTransformation[5], modelTransformation[10]];\n      }\n\n      if (referenceImage) {\n        var _referenceImage$getRe = referenceImage.getResolution(),\n            _referenceImage$getRe2 = _slicedToArray(_referenceImage$getRe, 3),\n            refResX = _referenceImage$getRe2[0],\n            refResY = _referenceImage$getRe2[1],\n            refResZ = _referenceImage$getRe2[2];\n\n        return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];\n      }\n\n      throw new Error('The image does not have an affine transformation.');\n    }\n    /**\n     * Returns whether or not the pixels of the image depict an area (or point).\n     * @returns {Boolean} Whether the pixels are a point\n     */\n\n  }, {\n    key: \"pixelIsArea\",\n    value: function pixelIsArea() {\n      return this.geoKeys.GTRasterTypeGeoKey === 1;\n    }\n    /**\n     * Returns the image bounding box as an array of 4 values: min-x, min-y,\n     * max-x and max-y. When the image has no affine transformation, then an\n     * exception is thrown.\n     * @returns {Array} The bounding box\n     */\n\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox() {\n      var origin = this.getOrigin();\n      var resolution = this.getResolution();\n      var x1 = origin[0];\n      var y1 = origin[1];\n      var x2 = x1 + resolution[0] * this.getWidth();\n      var y2 = y1 + resolution[1] * this.getHeight();\n      return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n    }\n  }]);\n\n  return GeoTIFFImage;\n}();\n\nexport default GeoTIFFImage;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/geotiff/src/geotiffimage.js"],"names":["getFloat16","parse","photometricInterpretations","ExtraSamplesValues","fromWhiteIsZero","fromBlackIsZero","fromPalette","fromCMYK","fromYCbCr","fromCIELab","getDecoder","resample","resampleInterleaved","sum","array","start","end","s","i","arrayForType","format","bitsPerSample","size","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","Error","needsNormalization","normalizeArray","inBuffer","planarConfiguration","samplesPerPixel","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","y","lineBitOffset","x","pixelBitOffset","bitOffset","outIndex","byteOffset","Math","floor","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","GeoTIFFImage","fileDirectory","geoKeys","dataView","littleEndian","cache","source","tiles","isTiled","StripOffsets","PlanarConfiguration","ImageWidth","ImageLength","SamplesPerPixel","TileWidth","getWidth","TileLength","RowsPerStrip","min","getHeight","getTileWidth","getTileHeight","bytes","BitsPerSample","length","getSampleByteSize","RangeError","ceil","sampleIndex","SampleFormat","prototype","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","TileOffsets","byteCount","TileByteCounts","StripByteCounts","fetch","slice","request","decode","data","sampleFormat","getSamplesPerPixel","getBlockHeight","imageWindow","samples","valueArrays","interleave","width","height","resampleMethod","minXTile","max","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","getBytesPerPixel","srcSampleOffsets","sampleReaders","push","getReaderForSample","promises","yTile","xTile","si","promise","getTileOrStrip","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","value","call","windowCoordinate","Promise","all","resampled","wnd","window","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","fill","valueArray","getArrayForSample","Array","isArray","_readRaster","result","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","readRasters","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","raster","ColorMap","ModelTiepoint","tiePoints","j","k","z","metadata","GDAL_METADATA","string","xmlDom","substring","tagName","root","items","children","filter","child","item","Number","attributes","name","GDAL_NODATA","modelTransformation","ModelTransformation","referenceImage","modelPixelScale","ModelPixelScale","getResolution","refResX","refResY","refResZ","GTRasterTypeGeoKey","origin","getOrigin","resolution","x1","y1","x2","y2"],"mappings":"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","sourcesContent":["/* eslint max-len: [\"error\", { \"code\": 120 }] */\n\nimport { getFloat16 } from '@petamoriken/float16';\nimport { parse } from 'txml/txml';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb';\nimport { getDecoder } from './compression';\nimport { resample, resampleInterleaved } from './resample';\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(this.getWidth() / this.getTileWidth()),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(this.getHeight() / this.getTileHeight()),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]));\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]));\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is\n   *                                 not the same as the images, resampling will be\n   *                                 performed.\n   * @param {number} [options.height] The desired height of the output. When the width\n   *                                  is not the same as the images, resampling will\n   *                                  be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {number|number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When\n   *                                              multiple samples are requested, an\n   *                                              array of fill values can be passed.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {bool} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise.<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, pool = null, width, height, resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave: true,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {Number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n    const xmlDom = parse(string.substring(0, string.length - 1));\n\n    if (!xmlDom[0].tagName) {\n      throw new Error('Failed to parse GDAL metadata XML.');\n    }\n\n    const root = xmlDom[0];\n    if (root.tagName !== 'GDALMetadata') {\n      throw new Error('Unexpected GDAL metadata XML tag.');\n    }\n\n    let items = root.children\n      .filter((child) => child.tagName === 'Item');\n\n    if (sample !== null) {\n      items = items.filter((item) => Number(item.attributes.sample) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[item.attributes.name] = item.children[0];\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {Number} or null\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n"]},"metadata":{},"sourceType":"module"}