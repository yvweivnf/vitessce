{"ast":null,"code":"import { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n  const {\n    markDef,\n    config\n  } = model;\n  const enableAria = getMarkPropOrConfig('aria', markDef, config); // We can ignore other aria properties if ariaHidden is true.\n\n  if (enableAria === false) {\n    // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n    return {};\n  }\n\n  return Object.assign(Object.assign(Object.assign({}, enableAria ? {\n    aria: enableAria\n  } : {}), ariaRoleDescription(model)), description(model));\n}\n\nfunction ariaRoleDescription(model) {\n  const {\n    mark,\n    markDef,\n    config\n  } = model;\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n\n  if (ariaRoleDesc != null) {\n    return {\n      ariaRoleDescription: {\n        value: ariaRoleDesc\n      }\n    };\n  }\n\n  return mark in VG_MARK_INDEX ? {} : {\n    ariaRoleDescription: {\n      value: mark\n    }\n  };\n}\n\nexport function description(model) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.description;\n\n  if (channelDef) {\n    return wrapCondition(model, channelDef, 'description', cDef => textRef(cDef, model.config));\n  } // Use default from mark def or config if defined.\n  // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n\n\n  const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n\n  if (descriptionValue != null) {\n    return {\n      description: signalOrValueRef(descriptionValue)\n    };\n  }\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const data = tooltipData(encoding, stack, config);\n\n  if (isEmpty(data)) {\n    return undefined;\n  }\n\n  return {\n    description: {\n      signal: entries(data).map(([key, value], index) => `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`).join(' + ')\n    }\n  };\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/aria.ts"],"names":[],"mappings":"AAAA,SAAQ,OAAR,EAAiB,OAAjB,QAA+B,eAA/B;AACA,SAAQ,mBAAR,EAA6B,gBAA7B,QAAoD,cAApD;AACA,SAAQ,aAAR,QAA4B,wBAA5B;AAEA,SAAQ,aAAR,QAA4B,eAA5B;AACA,SAAQ,OAAR,QAAsB,QAAtB;AACA,SAAQ,WAAR,QAA0B,WAA1B;AAEA,OAAM,SAAU,IAAV,CAAe,KAAf,EAA+B;AACnC,QAAM;AAAC,IAAA,OAAD;AAAU,IAAA;AAAV,MAAoB,KAA1B;AAEA,QAAM,UAAU,GAAG,mBAAmB,CAAC,MAAD,EAAS,OAAT,EAAkB,MAAlB,CAAtC,CAHmC,CAKnC;;AACA,MAAI,UAAU,KAAK,KAAnB,EAA0B;AACxB;AACA,WAAO,EAAP;AACD;;AAED,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACM,UAAU,GAAG;AAAC,IAAA,IAAI,EAAE;AAAP,GAAH,GAAwB,EADxC,CAAA,EAEK,mBAAmB,CAAC,KAAD,CAFxB,CAAA,EAGK,WAAW,CAAC,KAAD,CAHhB,CAAA;AAKD;;AAED,SAAS,mBAAT,CAA6B,KAA7B,EAA6C;AAC3C,QAAM;AAAC,IAAA,IAAD;AAAO,IAAA,OAAP;AAAgB,IAAA;AAAhB,MAA0B,KAAhC;;AAEA,MAAI,MAAM,CAAC,IAAP,KAAgB,KAApB,EAA2B;AACzB,WAAO,EAAP;AACD;;AAED,QAAM,YAAY,GAAG,mBAAmB,CAAC,qBAAD,EAAwB,OAAxB,EAAiC,MAAjC,CAAxC;;AAEA,MAAI,YAAY,IAAI,IAApB,EAA0B;AACxB,WAAO;AAAC,MAAA,mBAAmB,EAAE;AAAC,QAAA,KAAK,EAAE;AAAR;AAAtB,KAAP;AACD;;AAED,SAAO,IAAI,IAAI,aAAR,GAAwB,EAAxB,GAA6B;AAAC,IAAA,mBAAmB,EAAE;AAAC,MAAA,KAAK,EAAE;AAAR;AAAtB,GAApC;AACD;;AAED,OAAM,SAAU,WAAV,CAAsB,KAAtB,EAAsC;AAC1C,QAAM;AAAC,IAAA,QAAD;AAAW,IAAA,OAAX;AAAoB,IAAA,MAApB;AAA4B,IAAA;AAA5B,MAAqC,KAA3C;AACA,QAAM,UAAU,GAAG,QAAQ,CAAC,WAA5B;;AAEA,MAAI,UAAJ,EAAgB;AACd,WAAO,aAAa,CAAC,KAAD,EAAQ,UAAR,EAAoB,aAApB,EAAmC,IAAI,IAAI,OAAO,CAAC,IAAD,EAAO,KAAK,CAAC,MAAb,CAAlD,CAApB;AACD,GANyC,CAQ1C;AACA;;;AACA,QAAM,gBAAgB,GAAG,mBAAmB,CAAC,aAAD,EAAgB,OAAhB,EAAyB,MAAzB,CAA5C;;AACA,MAAI,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,WAAO;AACL,MAAA,WAAW,EAAE,gBAAgB,CAAC,gBAAD;AADxB,KAAP;AAGD;;AAED,MAAI,MAAM,CAAC,IAAP,KAAgB,KAApB,EAA2B;AACzB,WAAO,EAAP;AACD;;AAED,QAAM,IAAI,GAAG,WAAW,CAAC,QAAD,EAAW,KAAX,EAAkB,MAAlB,CAAxB;;AAEA,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB;AACjB,WAAO,SAAP;AACD;;AAED,SAAO;AACL,IAAA,WAAW,EAAE;AACX,MAAA,MAAM,EAAE,OAAO,CAAC,IAAD,CAAP,CACL,GADK,CACD,CAAC,CAAC,GAAD,EAAM,KAAN,CAAD,EAAe,KAAf,KAAyB,IAAI,KAAK,GAAG,CAAR,GAAY,IAAZ,GAAmB,EAAE,GAAG,GAAG,UAAU,KAAK,GADtE,EAEL,IAFK,CAEA,KAFA;AADG;AADR,GAAP;AAOD","sourceRoot":"","sourcesContent":["import { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n    const { markDef, config } = model;\n    const enableAria = getMarkPropOrConfig('aria', markDef, config);\n    // We can ignore other aria properties if ariaHidden is true.\n    if (enableAria === false) {\n        // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n        return {};\n    }\n    return Object.assign(Object.assign(Object.assign({}, (enableAria ? { aria: enableAria } : {})), ariaRoleDescription(model)), description(model));\n}\nfunction ariaRoleDescription(model) {\n    const { mark, markDef, config } = model;\n    if (config.aria === false) {\n        return {};\n    }\n    const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n    if (ariaRoleDesc != null) {\n        return { ariaRoleDescription: { value: ariaRoleDesc } };\n    }\n    return mark in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark } };\n}\nexport function description(model) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding.description;\n    if (channelDef) {\n        return wrapCondition(model, channelDef, 'description', cDef => textRef(cDef, model.config));\n    }\n    // Use default from mark def or config if defined.\n    // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n    const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n    if (descriptionValue != null) {\n        return {\n            description: signalOrValueRef(descriptionValue)\n        };\n    }\n    if (config.aria === false) {\n        return {};\n    }\n    const data = tooltipData(encoding, stack, config);\n    if (isEmpty(data)) {\n        return undefined;\n    }\n    return {\n        description: {\n            signal: entries(data)\n                .map(([key, value], index) => `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`)\n                .join(' + ')\n        }\n    };\n}\n//# sourceMappingURL=aria.js.map"]},"metadata":{},"sourceType":"module"}