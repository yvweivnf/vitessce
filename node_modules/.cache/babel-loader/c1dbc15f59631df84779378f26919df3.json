{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\n/*\n * This source file contains the code for proxying calls in the master thread to calls in the workers\n * by `.postMessage()`-ing.\n *\n * Keep in mind that this code can make or break the program's performance! Need to optimize more…\n */\nimport DebugLogger from \"debug\";\nimport { multicast, Observable } from \"observable-fns\";\nimport { deserialize, serialize } from \"../common\";\nimport { ObservablePromise } from \"../observable-promise\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nvar debugMessages = DebugLogger(\"threads:master:messages\");\nvar nextJobUID = 1;\n\nvar dedupe = function dedupe(array) {\n  return Array.from(new Set(array));\n};\n\nvar isJobErrorMessage = function isJobErrorMessage(data) {\n  return data && data.type === WorkerMessageType.error;\n};\n\nvar isJobResultMessage = function isJobResultMessage(data) {\n  return data && data.type === WorkerMessageType.result;\n};\n\nvar isJobStartMessage = function isJobStartMessage(data) {\n  return data && data.type === WorkerMessageType.running;\n};\n\nfunction createObservableForJob(worker, jobUID) {\n  return new Observable(function (observer) {\n    var asyncType;\n\n    var messageHandler = function messageHandler(event) {\n      debugMessages(\"Message from worker:\", event.data);\n      if (!event.data || event.data.uid !== jobUID) return;\n\n      if (isJobStartMessage(event.data)) {\n        asyncType = event.data.resultType;\n      } else if (isJobResultMessage(event.data)) {\n        if (asyncType === \"promise\") {\n          if (typeof event.data.payload !== \"undefined\") {\n            observer.next(deserialize(event.data.payload));\n          }\n\n          observer.complete();\n          worker.removeEventListener(\"message\", messageHandler);\n        } else {\n          if (event.data.payload) {\n            observer.next(deserialize(event.data.payload));\n          }\n\n          if (event.data.complete) {\n            observer.complete();\n            worker.removeEventListener(\"message\", messageHandler);\n          }\n        }\n      } else if (isJobErrorMessage(event.data)) {\n        var error = deserialize(event.data.error);\n\n        if (asyncType === \"promise\" || !asyncType) {\n          observer.error(error);\n        } else {\n          observer.error(error);\n        }\n\n        worker.removeEventListener(\"message\", messageHandler);\n      }\n    };\n\n    worker.addEventListener(\"message\", messageHandler);\n    return function () {\n      if (asyncType === \"observable\" || !asyncType) {\n        var cancelMessage = {\n          type: MasterMessageType.cancel,\n          uid: jobUID\n        };\n        worker.postMessage(cancelMessage);\n      }\n\n      worker.removeEventListener(\"message\", messageHandler);\n    };\n  });\n}\n\nfunction prepareArguments(rawArgs) {\n  if (rawArgs.length === 0) {\n    // Exit early if possible\n    return {\n      args: [],\n      transferables: []\n    };\n  }\n\n  var args = [];\n  var transferables = [];\n\n  var _iterator = _createForOfIteratorHelper(rawArgs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var arg = _step.value;\n\n      if (isTransferDescriptor(arg)) {\n        args.push(serialize(arg.send));\n        transferables.push.apply(transferables, _toConsumableArray(arg.transferables));\n      } else {\n        args.push(serialize(arg));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    args: args,\n    transferables: transferables.length === 0 ? transferables : dedupe(transferables)\n  };\n}\n\nexport function createProxyFunction(worker, method) {\n  return function () {\n    var uid = nextJobUID++;\n\n    for (var _len = arguments.length, rawArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      rawArgs[_key] = arguments[_key];\n    }\n\n    var _prepareArguments = prepareArguments(rawArgs),\n        args = _prepareArguments.args,\n        transferables = _prepareArguments.transferables;\n\n    var runMessage = {\n      type: MasterMessageType.run,\n      uid: uid,\n      method: method,\n      args: args\n    };\n    debugMessages(\"Sending command to run function to worker:\", runMessage);\n\n    try {\n      worker.postMessage(runMessage, transferables);\n    } catch (error) {\n      return ObservablePromise.from(Promise.reject(error));\n    }\n\n    return ObservablePromise.from(multicast(createObservableForJob(worker, uid)));\n  };\n}\nexport function createProxyModule(worker, methodNames) {\n  var proxy = {};\n\n  var _iterator2 = _createForOfIteratorHelper(methodNames),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var methodName = _step2.value;\n      proxy[methodName] = createProxyFunction(worker, methodName);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return proxy;\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/master/invocation-proxy.js"],"names":["DebugLogger","multicast","Observable","deserialize","serialize","ObservablePromise","isTransferDescriptor","MasterMessageType","WorkerMessageType","debugMessages","nextJobUID","dedupe","array","Array","from","Set","isJobErrorMessage","data","type","error","isJobResultMessage","result","isJobStartMessage","running","createObservableForJob","worker","jobUID","observer","asyncType","messageHandler","event","uid","resultType","payload","next","complete","removeEventListener","addEventListener","cancelMessage","cancel","postMessage","prepareArguments","rawArgs","length","args","transferables","arg","push","send","createProxyFunction","method","runMessage","run","Promise","reject","createProxyModule","methodNames","proxy","methodName"],"mappings":"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","sourcesContent":["/*\n * This source file contains the code for proxying calls in the master thread to calls in the workers\n * by `.postMessage()`-ing.\n *\n * Keep in mind that this code can make or break the program's performance! Need to optimize more…\n */\nimport DebugLogger from \"debug\";\nimport { multicast, Observable } from \"observable-fns\";\nimport { deserialize, serialize } from \"../common\";\nimport { ObservablePromise } from \"../observable-promise\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nconst debugMessages = DebugLogger(\"threads:master:messages\");\nlet nextJobUID = 1;\nconst dedupe = (array) => Array.from(new Set(array));\nconst isJobErrorMessage = (data) => data && data.type === WorkerMessageType.error;\nconst isJobResultMessage = (data) => data && data.type === WorkerMessageType.result;\nconst isJobStartMessage = (data) => data && data.type === WorkerMessageType.running;\nfunction createObservableForJob(worker, jobUID) {\n    return new Observable(observer => {\n        let asyncType;\n        const messageHandler = ((event) => {\n            debugMessages(\"Message from worker:\", event.data);\n            if (!event.data || event.data.uid !== jobUID)\n                return;\n            if (isJobStartMessage(event.data)) {\n                asyncType = event.data.resultType;\n            }\n            else if (isJobResultMessage(event.data)) {\n                if (asyncType === \"promise\") {\n                    if (typeof event.data.payload !== \"undefined\") {\n                        observer.next(deserialize(event.data.payload));\n                    }\n                    observer.complete();\n                    worker.removeEventListener(\"message\", messageHandler);\n                }\n                else {\n                    if (event.data.payload) {\n                        observer.next(deserialize(event.data.payload));\n                    }\n                    if (event.data.complete) {\n                        observer.complete();\n                        worker.removeEventListener(\"message\", messageHandler);\n                    }\n                }\n            }\n            else if (isJobErrorMessage(event.data)) {\n                const error = deserialize(event.data.error);\n                if (asyncType === \"promise\" || !asyncType) {\n                    observer.error(error);\n                }\n                else {\n                    observer.error(error);\n                }\n                worker.removeEventListener(\"message\", messageHandler);\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        return () => {\n            if (asyncType === \"observable\" || !asyncType) {\n                const cancelMessage = {\n                    type: MasterMessageType.cancel,\n                    uid: jobUID\n                };\n                worker.postMessage(cancelMessage);\n            }\n            worker.removeEventListener(\"message\", messageHandler);\n        };\n    });\n}\nfunction prepareArguments(rawArgs) {\n    if (rawArgs.length === 0) {\n        // Exit early if possible\n        return {\n            args: [],\n            transferables: []\n        };\n    }\n    const args = [];\n    const transferables = [];\n    for (const arg of rawArgs) {\n        if (isTransferDescriptor(arg)) {\n            args.push(serialize(arg.send));\n            transferables.push(...arg.transferables);\n        }\n        else {\n            args.push(serialize(arg));\n        }\n    }\n    return {\n        args,\n        transferables: transferables.length === 0 ? transferables : dedupe(transferables)\n    };\n}\nexport function createProxyFunction(worker, method) {\n    return ((...rawArgs) => {\n        const uid = nextJobUID++;\n        const { args, transferables } = prepareArguments(rawArgs);\n        const runMessage = {\n            type: MasterMessageType.run,\n            uid,\n            method,\n            args\n        };\n        debugMessages(\"Sending command to run function to worker:\", runMessage);\n        try {\n            worker.postMessage(runMessage, transferables);\n        }\n        catch (error) {\n            return ObservablePromise.from(Promise.reject(error));\n        }\n        return ObservablePromise.from(multicast(createObservableForJob(worker, uid)));\n    });\n}\nexport function createProxyModule(worker, methodNames) {\n    const proxy = {};\n    for (const methodName of methodNames) {\n        proxy[methodName] = createProxyFunction(worker, methodName);\n    }\n    return proxy;\n}\n"]},"metadata":{},"sourceType":"module"}