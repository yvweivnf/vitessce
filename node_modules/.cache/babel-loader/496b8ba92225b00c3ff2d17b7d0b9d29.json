{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '@loaders.gl/loader-utils';\nimport { createTypedArrayFromAccessor } from './helpers/tile-3d-accessor-utils';\nimport { initializeHierarchy, traverseHierarchy } from './tile-3d-batch-table-hierarchy';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nvar clone = function clone(x, y) {\n  return x;\n};\n\nvar IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true,\n  extensions: true,\n  extras: true\n};\n\nvar Tile3DBatchTableParser = /*#__PURE__*/function () {\n  function Tile3DBatchTableParser(json, binary, featureCount) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, Tile3DBatchTableParser);\n\n    var _this$json;\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"binary\", void 0);\n\n    _defineProperty(this, \"featureCount\", void 0);\n\n    _defineProperty(this, \"_extensions\", void 0);\n\n    _defineProperty(this, \"_properties\", void 0);\n\n    _defineProperty(this, \"_binaryProperties\", void 0);\n\n    _defineProperty(this, \"_hierarchy\", void 0);\n\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n    this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};\n    this._properties = {};\n\n    for (var propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  _createClass(Tile3DBatchTableParser, [{\n    key: \"getExtension\",\n    value: function getExtension(extensionName) {\n      return this.json && this.json.extensions && this.json.extensions[extensionName];\n    }\n  }, {\n    key: \"memorySizeInBytes\",\n    value: function memorySizeInBytes() {\n      return 0;\n    }\n  }, {\n    key: \"isClass\",\n    value: function isClass(batchId, className) {\n      this._checkBatchId(batchId);\n\n      assert(typeof className === 'string', className);\n\n      if (this._hierarchy) {\n        var result = traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n          var classId = hierarchy.classIds[instanceIndex];\n          var instanceClass = hierarchy.classes[classId];\n          return instanceClass.name === className;\n        });\n        return defined(result);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isExactClass\",\n    value: function isExactClass(batchId, className) {\n      assert(typeof className === 'string', className);\n      return this.getExactClassName(batchId) === className;\n    }\n  }, {\n    key: \"getExactClassName\",\n    value: function getExactClassName(batchId) {\n      this._checkBatchId(batchId);\n\n      if (this._hierarchy) {\n        var classId = this._hierarchy.classIds[batchId];\n        var instanceClass = this._hierarchy.classes[classId];\n        return instanceClass.name;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"hasProperty\",\n    value: function hasProperty(batchId, name) {\n      this._checkBatchId(batchId);\n\n      assert(typeof name === 'string', name);\n      return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n    }\n  }, {\n    key: \"getPropertyNames\",\n    value: function getPropertyNames(batchId, results) {\n      var _results;\n\n      this._checkBatchId(batchId);\n\n      results = defined(results) ? results : [];\n      results.length = 0;\n      var propertyNames = Object.keys(this._properties);\n\n      (_results = results).push.apply(_results, _toConsumableArray(propertyNames));\n\n      if (this._hierarchy) {\n        this._getPropertyNamesInHierarchy(batchId, results);\n      }\n\n      return results;\n    }\n  }, {\n    key: \"getProperty\",\n    value: function getProperty(batchId, name) {\n      this._checkBatchId(batchId);\n\n      assert(typeof name === 'string', name);\n\n      if (this._binaryProperties) {\n        var binaryProperty = this._binaryProperties[name];\n\n        if (defined(binaryProperty)) {\n          return this._getBinaryProperty(binaryProperty, batchId);\n        }\n      }\n\n      var propertyValues = this._properties[name];\n\n      if (defined(propertyValues)) {\n        return clone(propertyValues[batchId], true);\n      }\n\n      if (this._hierarchy) {\n        var hierarchyProperty = this._getHierarchyProperty(batchId, name);\n\n        if (defined(hierarchyProperty)) {\n          return hierarchyProperty;\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(batchId, name, value) {\n      var featureCount = this.featureCount;\n\n      this._checkBatchId(batchId);\n\n      assert(typeof name === 'string', name);\n\n      if (this._binaryProperties) {\n        var binaryProperty = this._binaryProperties[name];\n\n        if (binaryProperty) {\n          this._setBinaryProperty(binaryProperty, batchId, value);\n\n          return;\n        }\n      }\n\n      if (this._hierarchy) {\n        if (this._setHierarchyProperty(this, batchId, name, value)) {\n          return;\n        }\n      }\n\n      var propertyValues = this._properties[name];\n\n      if (!defined(propertyValues)) {\n        this._properties[name] = new Array(featureCount);\n        propertyValues = this._properties[name];\n      }\n\n      propertyValues[batchId] = clone(value, true);\n    }\n  }, {\n    key: \"_checkBatchId\",\n    value: function _checkBatchId(batchId) {\n      var valid = batchId >= 0 && batchId < this.featureCount;\n\n      if (!valid) {\n        throw new Error('batchId not in range [0, featureCount - 1].');\n      }\n    }\n  }, {\n    key: \"_getBinaryProperty\",\n    value: function _getBinaryProperty(binaryProperty, index) {\n      return binaryProperty.unpack(binaryProperty.typedArray, index);\n    }\n  }, {\n    key: \"_setBinaryProperty\",\n    value: function _setBinaryProperty(binaryProperty, index, value) {\n      binaryProperty.pack(value, binaryProperty.typedArray, index);\n    }\n  }, {\n    key: \"_initializeBinaryProperties\",\n    value: function _initializeBinaryProperties() {\n      var binaryProperties = null;\n\n      for (var name in this._properties) {\n        var property = this._properties[name];\n\n        var binaryProperty = this._initializeBinaryProperty(name, property);\n\n        if (binaryProperty) {\n          binaryProperties = binaryProperties || {};\n          binaryProperties[name] = binaryProperty;\n        }\n      }\n\n      return binaryProperties;\n    }\n  }, {\n    key: \"_initializeBinaryProperty\",\n    value: function _initializeBinaryProperty(name, property) {\n      if ('byteOffset' in property) {\n        var tile3DAccessor = property;\n        assert(this.binary, \"Property \".concat(name, \" requires a batch table binary.\"));\n        assert(tile3DAccessor.type, \"Property \".concat(name, \" requires a type.\"));\n        var accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n        return {\n          typedArray: accessor.values,\n          componentCount: accessor.size,\n          unpack: accessor.unpacker,\n          pack: accessor.packer\n        };\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hasPropertyInHierarchy\",\n    value: function _hasPropertyInHierarchy(batchId, name) {\n      if (!this._hierarchy) {\n        return false;\n      }\n\n      var result = traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instances = hierarchy.classes[classId].instances;\n        return defined(instances[name]);\n      });\n      return defined(result);\n    }\n  }, {\n    key: \"_getPropertyNamesInHierarchy\",\n    value: function _getPropertyNamesInHierarchy(batchId, results) {\n      traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instances = hierarchy.classes[classId].instances;\n\n        for (var name in instances) {\n          if (instances.hasOwnProperty(name)) {\n            if (results.indexOf(name) === -1) {\n              results.push(name);\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"_getHierarchyProperty\",\n    value: function _getHierarchyProperty(batchId, name) {\n      var _this = this;\n\n      return traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instanceClass = hierarchy.classes[classId];\n        var indexInClass = hierarchy.classIndexes[instanceIndex];\n        var propertyValues = instanceClass.instances[name];\n\n        if (defined(propertyValues)) {\n          if (defined(propertyValues.typedArray)) {\n            return _this._getBinaryProperty(propertyValues, indexInClass);\n          }\n\n          return clone(propertyValues[indexInClass], true);\n        }\n\n        return null;\n      });\n    }\n  }, {\n    key: \"_setHierarchyProperty\",\n    value: function _setHierarchyProperty(batchTable, batchId, name, value) {\n      var _this2 = this;\n\n      var result = traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instanceClass = hierarchy.classes[classId];\n        var indexInClass = hierarchy.classIndexes[instanceIndex];\n        var propertyValues = instanceClass.instances[name];\n\n        if (defined(propertyValues)) {\n          assert(instanceIndex === batchId, \"Inherited property \\\"\".concat(name, \"\\\" is read-only.\"));\n\n          if (defined(propertyValues.typedArray)) {\n            _this2._setBinaryProperty(propertyValues, indexInClass, value);\n          } else {\n            propertyValues[indexInClass] = clone(value, true);\n          }\n\n          return true;\n        }\n\n        return false;\n      });\n      return defined(result);\n    }\n  }]);\n\n  return Tile3DBatchTableParser;\n}();\n\nexport { Tile3DBatchTableParser as default };","map":{"version":3,"sources":["../../../../src/lib/classes/tile-3d-batch-table.ts"],"names":["x","clone","IGNORED_PROPERTY_FIELDS","HIERARCHY","extensions","extras","constructor","options","assert","featureCount","json","initializeHierarchy","result","traverseHierarchy","classId","hierarchy","instanceClass","defined","results","propertyNames","Object","binaryProperty","propertyValues","hierarchyProperty","valid","batchId","binaryProperties","property","tile3DAccessor","accessor","createTypedArrayFromAccessor","typedArray","componentCount","unpack","pack","packer","instances","indexInClass","instanceIndex"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {assert} from '@loaders.gl/loader-utils';\n\nimport {createTypedArrayFromAccessor} from './helpers/tile-3d-accessor-utils';\nimport {initializeHierarchy, traverseHierarchy} from './tile-3d-batch-table-hierarchy';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst clone = (x, y) => x;\n\n// These top level fields in the batch table json are not properties\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true, // Deprecated HIERARCHY property\n  extensions: true,\n  extras: true\n};\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nexport default class Tile3DBatchTableParser {\n  json;\n  binary;\n  featureCount;\n  _extensions;\n  // Copy all top-level property fields from the json object, ignoring special fields\n  _properties;\n  _binaryProperties;\n  // TODO: hierarchy support is only partially implemented and not tested\n  _hierarchy;\n\n  constructor(json, binary, featureCount, options = {}) {\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n\n    this._extensions = this.json?.extensions || {};\n\n    // Copy all top-level property fields from the json object, ignoring special fields\n    this._properties = {};\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    // TODO: hierarchy support is only partially implemented and not tested\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes(): number {\n    return 0;\n  }\n\n  isClass(batchId, className: string): boolean {\n    this._checkBatchId(batchId);\n    assert(typeof className === 'string', className);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      // PERFORMANCE_IDEA : cache results in the ancestor classes\n      //   to speed up this check if this area becomes a hotspot\n      // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n        return;\n      }\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n    if (!defined(propertyValues)) {\n      // Property does not exist. Create it.\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value, true);\n  }\n\n  // PRIVATE METHODS\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n    if (!valid) {\n      throw new Error('batchId not in range [0, featureCount - 1].');\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties: Record<string, any> | null = null;\n    for (const name in this._properties) {\n      const property = this._properties[name];\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      // This is a binary property\n      const tile3DAccessor = property;\n\n      assert(this.binary, `Property ${name} requires a batch table binary.`);\n      assert(tile3DAccessor.type, `Property ${name} requires a type.`);\n\n      const accessor = createTypedArrayFromAccessor(\n        tile3DAccessor,\n        this.binary.buffer,\n        this.binary.byteOffset | 0,\n        this.featureCount\n      );\n\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n        return clone(propertyValues[indexInClass], true);\n      }\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, `Inherited property \"${name}\" is read-only.`);\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n      return false;\n    });\n    return defined(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}