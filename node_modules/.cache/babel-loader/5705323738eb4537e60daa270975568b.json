{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\n\n\nfunction booleanPointOnLine(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  } // Normalize inputs\n\n\n  var ptCoords = invariant_1.getCoord(pt);\n  var lineCoords = invariant_1.getCoords(line); // Main\n\n  for (var i = 0; i < lineCoords.length - 1; i++) {\n    var ignoreBoundary = false;\n\n    if (options.ignoreEndVertices) {\n      if (i === 0) {\n        ignoreBoundary = \"start\";\n      }\n\n      if (i === lineCoords.length - 2) {\n        ignoreBoundary = \"end\";\n      }\n\n      if (i === 0 && i + 1 === lineCoords.length - 1) {\n        ignoreBoundary = \"both\";\n      }\n    }\n\n    if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {\n      return true;\n    }\n  }\n\n  return false;\n} // See http://stackoverflow.com/a/4833823/1979085\n\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\n\n\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {\n  var x = pt[0];\n  var y = pt[1];\n  var x1 = lineSegmentStart[0];\n  var y1 = lineSegmentStart[1];\n  var x2 = lineSegmentEnd[0];\n  var y2 = lineSegmentEnd[1];\n  var dxc = pt[0] - x1;\n  var dyc = pt[1] - y1;\n  var dxl = x2 - x1;\n  var dyl = y2 - y1;\n  var cross = dxc * dyl - dyc * dxl;\n\n  if (cross !== 0) {\n    return false;\n  }\n\n  if (!excludeBoundary) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n    }\n\n    return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n  } else if (excludeBoundary === \"start\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n    }\n\n    return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n  } else if (excludeBoundary === \"end\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n    }\n\n    return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n  } else if (excludeBoundary === \"both\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n    }\n\n    return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n  }\n\n  return false;\n}\n\nexports.default = booleanPointOnLine;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/boolean-point-on-line/index.js"],"names":["Object","defineProperty","exports","value","invariant_1","require","booleanPointOnLine","pt","line","options","ptCoords","getCoord","lineCoords","getCoords","i","length","ignoreBoundary","ignoreEndVertices","isPointOnLineSegment","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","cross","Math","abs","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = invariant_1.getCoord(pt);\n    var lineCoords = invariant_1.getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexports.default = booleanPointOnLine;\n"]},"metadata":{},"sourceType":"script"}