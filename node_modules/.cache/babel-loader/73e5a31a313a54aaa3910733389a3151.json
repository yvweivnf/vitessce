{"ast":null,"code":"import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport var legendEncodeRules = {\n  symbols: symbols,\n  gradient: gradient,\n  labels: labels,\n  entries: entries\n};\nexport function symbols(symbolsSpec, _ref) {\n  var fieldOrDatumDef = _ref.fieldOrDatumDef,\n      model = _ref.model,\n      channel = _ref.channel,\n      legendCmpt = _ref.legendCmpt,\n      legendType = _ref.legendType;\n\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config,\n      mark = model.mark;\n  var filled = markDef.filled && mark !== 'trail';\n  var out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model, {\n    filled: filled\n  })); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  var symbolOpacity = (_a = legendCmpt.get('symbolOpacity')) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;\n  var symbolFillColor = (_b = legendCmpt.get('symbolFillColor')) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;\n  var symbolStrokeColor = (_c = legendCmpt.get('symbolStrokeColor')) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;\n  var opacity = symbolOpacity === undefined ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : undefined;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (symbolFillColor) {\n          delete out.fill;\n        } else {\n          out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : 'black');\n          out.fillOpacity = signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1);\n        }\n      } else if (isArray(out.fill)) {\n        var fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : filled && markDef.color;\n\n        if (fill) {\n          out.fill = signalOrValueRef(fill);\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field'] || symbolStrokeColor) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        var stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n\n        if (stroke) {\n          out.stroke = {\n            value: stroke\n          };\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    var condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n\n    if (condition) {\n      out.opacity = [Object.assign({\n        test: condition\n      }, signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1)), signalOrValueRef(config.legend.unselectedOpacity)];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n\n  out = Object.assign(Object.assign({}, out), symbolsSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, _ref2) {\n  var model = _ref2.model,\n      legendType = _ref2.legendType,\n      legendCmpt = _ref2.legendCmpt;\n\n  var _a;\n\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n\n  var config = model.config,\n      markDef = model.markDef,\n      encoding = model.encoding;\n  var out = {};\n  var gradientOpacity = (_a = legendCmpt.get('gradientOpacity')) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;\n  var opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n\n  out = Object.assign(Object.assign({}, out), gradientSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, _ref3) {\n  var fieldOrDatumDef = _ref3.fieldOrDatumDef,\n      model = _ref3.model,\n      channel = _ref3.channel,\n      legendCmpt = _ref3.legendCmpt;\n  var legend = model.legend(channel) || {};\n  var config = model.config;\n  var condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  var opacity = condition ? [{\n    test: condition,\n    value: 1\n  }, {\n    value: config.legend.unselectedOpacity\n  }] : undefined;\n  var format = legend.format,\n      formatType = legend.formatType;\n  var text = isCustomFormatType(formatType) ? formatCustomType({\n    fieldOrDatumDef: fieldOrDatumDef,\n    field: 'datum.value',\n    format: format,\n    formatType: formatType,\n    config: config\n  }) : undefined;\n  var labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity ? {\n    opacity: opacity\n  } : {}), text ? {\n    text: text\n  } : {}), specifiedlabelsSpec);\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, _ref4) {\n  var legendCmpt = _ref4.legendCmpt;\n  var selections = legendCmpt.get('selections');\n  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), {\n    fill: {\n      value: 'transparent'\n    }\n  }) : entriesSpec;\n}\n\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, function (v, conditionalDef) {\n    return Math.max(v, conditionalDef.value);\n  });\n}\n\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, function (v, conditionalDef) {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n\n  return undefined;\n}\n\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n  var selections = legendCmpt.get('selections');\n  if (!(selections === null || selections === void 0 ? void 0 : selections.length)) return undefined;\n  var field = stringValue(fieldDef.field);\n  return selections.map(function (name) {\n    var store = stringValue(varName(name) + STORE);\n    return \"(!length(data(\".concat(store, \")) || (\").concat(name, \"[\").concat(field, \"] && indexof(\").concat(name, \"[\").concat(field, \"], datum.value) >= 0))\");\n  }).join(' || ');\n}","map":{"version":3,"sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"AACA,SAAQ,KAAR,EAAe,OAAf,EAAwB,WAAxB,QAA0C,WAA1C;AACA,SAAQ,KAAR,EAAwC,OAAxC,QAAsD,eAAtD;AACA,SAGE,sBAHF,EAIE,UAJF,EAKE,UALF,QASO,kBATP;AAWA,SAAQ,kBAAR,QAAiC,YAAjC;AACA,SAAQ,eAAR,EAAyB,OAAzB,EAAkC,OAAlC,QAAgD,YAAhD;AACA,SAAQ,eAAR,EAAyB,gBAAzB,QAAgD,WAAhD;AACA,SAAQ,gBAAR,EAA0B,kBAA1B,QAAmD,WAAnD;AACA,OAAO,KAAK,MAAZ,MAAwB,gBAAxB;AACA,SAAQ,KAAR,QAAoB,cAApB;AAYA,OAAO,IAAM,iBAAiB,GAE1B;AACF,EAAA,OAAO,EAAP,OADE;AAEF,EAAA,QAAQ,EAAR,QAFE;AAGF,EAAA,MAAM,EAAN,MAHE;AAIF,EAAA,OAAO,EAAP;AAJE,CAFG;AASP,OAAM,SAAU,OAAV,CACJ,WADI,QAEyE;AAAA,MAA5E,eAA4E,QAA5E,eAA4E;AAAA,MAA3D,KAA2D,QAA3D,KAA2D;AAAA,MAApD,OAAoD,QAApD,OAAoD;AAAA,MAA3C,UAA2C,QAA3C,UAA2C;AAAA,MAA/B,UAA+B,QAA/B,UAA+B;;;;AAE7E,MAAI,UAAU,KAAK,QAAnB,EAA6B;AAC3B,WAAO,SAAP;AACD;;AAJ4E,MAMtE,OANsE,GAMnC,KANmC,CAMtE,OANsE;AAAA,MAM7D,QAN6D,GAMnC,KANmC,CAM7D,QAN6D;AAAA,MAMnD,MANmD,GAMnC,KANmC,CAMnD,MANmD;AAAA,MAM3C,IAN2C,GAMnC,KANmC,CAM3C,IAN2C;AAO7E,MAAM,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,IAAI,KAAK,OAA1C;AAEA,MAAI,GAAG,GAAG,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACL,eAAe,CAAC,EAAD,EAAK,KAAL,EAAY,kBAAZ,CADV,CAAA,EAEL,MAAM,CAAC,KAAP,CAAa,KAAb,EAAoB;AAAC,IAAA,MAAM,EAAN;AAAD,GAApB,CAFK,CAAV,CAT6E,CAYrD;;AAExB,MAAM,aAAa,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,eAAf,CAAA,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,EAA/B,GAAmC,MAAM,CAAC,MAAP,CAAc,aAAvE;AACA,MAAM,eAAe,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,iBAAf,CAAA,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAqC,MAAM,CAAC,MAAP,CAAc,eAA3E;AACA,MAAM,iBAAiB,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,mBAAf,CAAA,MAAmC,IAAnC,IAAmC,EAAA,KAAA,KAAA,CAAnC,GAAmC,EAAnC,GAAuC,MAAM,CAAC,MAAP,CAAc,iBAA/E;AAEA,MAAM,OAAO,GAAG,aAAa,KAAK,SAAlB,GAA8B,CAAA,EAAA,GAAA,WAAW,CAAC,QAAQ,CAAC,OAAV,CAAX,MAA6B,IAA7B,IAA6B,EAAA,KAAA,KAAA,CAA7B,GAA6B,EAA7B,GAAiC,OAAO,CAAC,OAAvE,GAAiF,SAAjG;;AAEA,MAAI,GAAG,CAAC,IAAR,EAAc;AACZ;AACA,QAAI,OAAO,KAAK,MAAZ,IAAuB,MAAM,IAAI,OAAO,KAAK,KAAjD,EAAyD;AACvD,aAAO,GAAG,CAAC,IAAX;AACD,KAFD,MAEO;AACL,UAAI,GAAG,CAAC,IAAJ,CAAS,OAAT,CAAJ,EAAuB;AACrB;AACA,YAAI,eAAJ,EAAqB;AACnB,iBAAO,GAAG,CAAC,IAAX;AACD,SAFD,MAEO;AACL,UAAA,GAAG,CAAC,IAAJ,GAAW,gBAAgB,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,MAAP,CAAc,mBAAd,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAqC,OAAtC,CAA3B;AACA,UAAA,GAAG,CAAC,WAAJ,GAAkB,gBAAgB,CAAC,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,CAAZ,CAAlC;AACD;AACF,OARD,MAQO,IAAI,OAAO,CAAC,GAAG,CAAC,IAAL,CAAX,EAAuB;AAC5B,YAAM,IAAI,GACR,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,sBAAsB,CAAC,CAAA,EAAA,GAAA,QAAQ,CAAC,IAAT,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,EAAb,GAAiB,QAAQ,CAAC,KAA3B,CAAtB,MAAuD,IAAvD,IAAuD,EAAA,KAAA,KAAA,CAAvD,GAAuD,EAAvD,GAA2D,OAAO,CAAC,IAAnE,MAAuE,IAAvE,IAAuE,EAAA,KAAA,KAAA,CAAvE,GAAuE,EAAvE,GAA4E,MAAM,IAAI,OAAO,CAAC,KADhG;;AAEA,YAAI,IAAJ,EAAU;AACR,UAAA,GAAG,CAAC,IAAJ,GAAW,gBAAgB,CAAC,IAAD,CAA3B;AACD;AACF;AACF;AACF;;AAED,MAAI,GAAG,CAAC,MAAR,EAAgB;AACd,QAAI,OAAO,KAAK,QAAZ,IAAyB,CAAC,MAAD,IAAW,OAAO,KAAK,KAApD,EAA4D;AAC1D,aAAO,GAAG,CAAC,MAAX;AACD,KAFD,MAEO;AACL,UAAI,GAAG,CAAC,MAAJ,CAAW,OAAX,KAAuB,iBAA3B,EAA8C;AAC5C;AACA,eAAO,GAAG,CAAC,MAAX;AACD,OAHD,MAGO,IAAI,OAAO,CAAC,GAAG,CAAC,MAAL,CAAX,EAAyB;AAC9B,YAAM,MAAM,GAAG,eAAe,CAC5B,sBAAsB,CAAoB,QAAQ,CAAC,MAAT,IAAmB,QAAQ,CAAC,KAAhD,CADM,EAE5B,OAAO,CAAC,MAFoB,EAG5B,MAAM,GAAG,OAAO,CAAC,KAAX,GAAmB,SAHG,CAA9B;;AAKA,YAAI,MAAJ,EAAY;AACV,UAAA,GAAG,CAAC,MAAJ,GAAa;AAAC,YAAA,KAAK,EAAE;AAAR,WAAb;AACD;AACF;AACF;AACF;;AAED,MAAI,OAAO,KAAK,OAAhB,EAAyB;AACvB,QAAM,SAAS,GAAG,UAAU,CAAC,eAAD,CAAV,IAA+B,iBAAiB,CAAC,KAAD,EAAQ,UAAR,EAAoB,eAApB,CAAlE;;AAEA,QAAI,SAAJ,EAAe;AACb,MAAA,GAAG,CAAC,OAAJ,GAAc,C;AACX,QAAA,IAAI,EAAE;SAAc,gBAAgB,CAAC,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,CAAZ,C,CADzB,EAEZ,gBAAgB,CAAC,MAAM,CAAC,MAAP,CAAc,iBAAf,CAFJ,CAAd;AAID,KALD,MAKO,IAAI,OAAJ,EAAa;AAClB,MAAA,GAAG,CAAC,OAAJ,GAAc,gBAAgB,CAAC,OAAD,CAA9B;AACD;AACF;;AAED,EAAA,GAAG,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,GAAP,CAAA,EAAe,WAAf,CAAH;AAEA,SAAO,OAAO,CAAC,GAAD,CAAP,GAAe,SAAf,GAA2B,GAAlC;AACD;AAED,OAAM,SAAU,QAAV,CAAmB,YAAnB,SAAyF;AAAA,MAAlD,KAAkD,SAAlD,KAAkD;AAAA,MAA3C,UAA2C,SAA3C,UAA2C;AAAA,MAA/B,UAA+B,SAA/B,UAA+B;;;;AAC7F,MAAI,UAAU,KAAK,UAAnB,EAA+B;AAC7B,WAAO,SAAP;AACD;;AAH4F,MAKtF,MALsF,GAKzD,KALyD,CAKtF,MALsF;AAAA,MAK9E,OAL8E,GAKzD,KALyD,CAK9E,OAL8E;AAAA,MAKrE,QALqE,GAKzD,KALyD,CAKrE,QALqE;AAO7F,MAAI,GAAG,GAAsB,EAA7B;AAEA,MAAM,eAAe,GAAG,CAAA,EAAA,GAAA,UAAU,CAAC,GAAX,CAAe,iBAAf,CAAA,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAqC,MAAM,CAAC,MAAP,CAAc,eAA3E;AACA,MAAM,OAAO,GAAG,eAAe,KAAK,SAApB,GAAgC,WAAW,CAAC,QAAQ,CAAC,OAAV,CAAX,IAAiC,OAAO,CAAC,OAAzE,GAAmF,SAAnG;;AACA,MAAI,OAAJ,EAAa;AACX;AACA,IAAA,GAAG,CAAC,OAAJ,GAAc,gBAAgB,CAAC,OAAD,CAA9B;AACD;;AAED,EAAA,GAAG,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,GAAP,CAAA,EAAe,YAAf,CAAH;AACA,SAAO,OAAO,CAAC,GAAD,CAAP,GAAe,SAAf,GAA2B,GAAlC;AACD;AAED,OAAM,SAAU,MAAV,CAAiB,mBAAjB,SAA4G;AAAA,MAAhE,eAAgE,SAAhE,eAAgE;AAAA,MAA/C,KAA+C,SAA/C,KAA+C;AAAA,MAAxC,OAAwC,SAAxC,OAAwC;AAAA,MAA/B,UAA+B,SAA/B,UAA+B;AAChH,MAAM,MAAM,GAAG,KAAK,CAAC,MAAN,CAAa,OAAb,KAAyB,EAAxC;AACA,MAAM,MAAM,GAAG,KAAK,CAAC,MAArB;AAEA,MAAM,SAAS,GAAG,UAAU,CAAC,eAAD,CAAV,GAA8B,iBAAiB,CAAC,KAAD,EAAQ,UAAR,EAAoB,eAApB,CAA/C,GAAsF,SAAxG;AACA,MAAM,OAAO,GAAG,SAAS,GAAG,CAAC;AAAC,IAAA,IAAI,EAAE,SAAP;AAAkB,IAAA,KAAK,EAAE;AAAzB,GAAD,EAA8B;AAAC,IAAA,KAAK,EAAE,MAAM,CAAC,MAAP,CAAc;AAAtB,GAA9B,CAAH,GAA6E,SAAtG;AALgH,MAOzG,MAPyG,GAOnF,MAPmF,CAOzG,MAPyG;AAAA,MAOjG,UAPiG,GAOnF,MAPmF,CAOjG,UAPiG;AAShH,MAAM,IAAI,GAAG,kBAAkB,CAAC,UAAD,CAAlB,GACT,gBAAgB,CAAC;AACf,IAAA,eAAe,EAAf,eADe;AAEf,IAAA,KAAK,EAAE,aAFQ;AAGf,IAAA,MAAM,EAAN,MAHe;AAIf,IAAA,UAAU,EAAV,UAJe;AAKf,IAAA,MAAM,EAAN;AALe,GAAD,CADP,GAQT,SARJ;AAUA,MAAM,UAAU,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACV,OAAO,GAAG;AAAC,IAAA,OAAO,EAAP;AAAD,GAAH,GAAe,EADZ,CAAA,EAEV,IAAI,GAAG;AAAC,IAAA,IAAI,EAAJ;AAAD,GAAH,GAAY,EAFN,CAAA,EAGX,mBAHW,CAAhB;AAMA,SAAO,OAAO,CAAC,UAAD,CAAP,GAAsB,SAAtB,GAAkC,UAAzC;AACD;AAED,OAAM,SAAU,OAAV,CAAkB,WAAlB,SAAoE;AAAA,MAA/B,UAA+B,SAA/B,UAA+B;AACxE,MAAM,UAAU,GAAG,UAAU,CAAC,GAAX,CAAe,YAAf,CAAnB;AACA,SAAO,CAAA,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,MAAZ,IAAoB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,WAAL,CAAA,EAAgB;AAAE,IAAA,IAAI,EAAE;AAAC,MAAA,KAAK,EAAE;AAAR;AAAR,GAAhB,CAApB,GAAsE,WAA7E;AACD;;AAED,SAAS,WAAT,CAAqB,UAArB,EAA4D;AAC1D,SAAO,iBAAiB,CAAS,UAAT,EAAqB,UAAC,CAAD,EAAY,cAAZ;AAAA,WAA+B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,cAAc,CAAC,KAA3B,CAA/B;AAAA,GAArB,CAAxB;AACD;;AAED,OAAM,SAAU,sBAAV,CACJ,UADI,EACqD;AAEzD,SAAO,iBAAiB,CAAI,UAAJ,EAAgB,UAAC,CAAD,EAAO,cAAP,EAAmD;AACzF,WAAO,eAAe,CAAI,CAAJ,EAAO,cAAc,CAAC,KAAtB,CAAtB;AACD,GAFuB,CAAxB;AAGD;;AAED,SAAS,iBAAT,CACE,UADF,EAEE,OAFF,EAEkE;AAEhE,MAAI,sBAAsB,CAAC,UAAD,CAA1B,EAAwC;AACtC,WAAO,KAAK,CAAC,UAAU,CAAC,SAAZ,CAAL,CAA4B,MAA5B,CAAmC,OAAnC,EAA4C,UAAU,CAAC,KAAvD,CAAP;AACD,GAFD,MAEO,IAAI,UAAU,CAAC,UAAD,CAAd,EAA4B;AACjC,WAAO,UAAU,CAAC,KAAlB;AACD;;AACD,SAAO,SAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,KAA3B,EAA6C,UAA7C,EAA0E,QAA1E,EAAyG;AACvG,MAAM,UAAU,GAAG,UAAU,CAAC,GAAX,CAAe,YAAf,CAAnB;AACA,MAAI,EAAC,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAA,UAAU,CAAE,MAAb,CAAJ,EAAyB,OAAO,SAAP;AAEzB,MAAM,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,KAAV,CAAzB;AACA,SAAO,UAAU,CACd,GADI,CACA,UAAA,IAAI,EAAG;AACV,QAAM,KAAK,GAAG,WAAW,CAAC,OAAO,CAAC,IAAD,CAAP,GAAgB,KAAjB,CAAzB;AACA,mCAAwB,KAAxB,oBAAuC,IAAvC,cAA+C,KAA/C,0BAAoE,IAApE,cAA4E,KAA5E;AACD,GAJI,EAKJ,IALI,CAKC,MALD,CAAP;AAMD","sourceRoot":"","sourcesContent":["import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport const legendEncodeRules = {\n    symbols,\n    gradient,\n    labels,\n    entries\n};\nexport function symbols(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType }) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    if (legendType !== 'symbol') {\n        return undefined;\n    }\n    const { markDef, encoding, config, mark } = model;\n    const filled = markDef.filled && mark !== 'trail';\n    let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model, { filled })); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n    const symbolOpacity = (_a = legendCmpt.get('symbolOpacity')) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;\n    const symbolFillColor = (_b = legendCmpt.get('symbolFillColor')) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;\n    const symbolStrokeColor = (_c = legendCmpt.get('symbolStrokeColor')) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;\n    const opacity = symbolOpacity === undefined ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : undefined;\n    if (out.fill) {\n        // for fill legend, we don't want any fill in symbol\n        if (channel === 'fill' || (filled && channel === COLOR)) {\n            delete out.fill;\n        }\n        else {\n            if (out.fill['field']) {\n                // For others, set fill to some opaque value (or nothing if a color is already set)\n                if (symbolFillColor) {\n                    delete out.fill;\n                }\n                else {\n                    out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : 'black');\n                    out.fillOpacity = signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1);\n                }\n            }\n            else if (isArray(out.fill)) {\n                const fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : (filled && markDef.color);\n                if (fill) {\n                    out.fill = signalOrValueRef(fill);\n                }\n            }\n        }\n    }\n    if (out.stroke) {\n        if (channel === 'stroke' || (!filled && channel === COLOR)) {\n            delete out.stroke;\n        }\n        else {\n            if (out.stroke['field'] || symbolStrokeColor) {\n                // For others, remove stroke field\n                delete out.stroke;\n            }\n            else if (isArray(out.stroke)) {\n                const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n                if (stroke) {\n                    out.stroke = { value: stroke };\n                }\n            }\n        }\n    }\n    if (channel !== OPACITY) {\n        const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n        if (condition) {\n            out.opacity = [\n                Object.assign({ test: condition }, signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1)),\n                signalOrValueRef(config.legend.unselectedOpacity)\n            ];\n        }\n        else if (opacity) {\n            out.opacity = signalOrValueRef(opacity);\n        }\n    }\n    out = Object.assign(Object.assign({}, out), symbolsSpec);\n    return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, { model, legendType, legendCmpt }) {\n    var _a;\n    if (legendType !== 'gradient') {\n        return undefined;\n    }\n    const { config, markDef, encoding } = model;\n    let out = {};\n    const gradientOpacity = (_a = legendCmpt.get('gradientOpacity')) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;\n    const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n    if (opacity) {\n        // only apply opacity if it is neither zero or undefined\n        out.opacity = signalOrValueRef(opacity);\n    }\n    out = Object.assign(Object.assign({}, out), gradientSpec);\n    return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {\n    const legend = model.legend(channel) || {};\n    const config = model.config;\n    const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n    const opacity = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : undefined;\n    const { format, formatType } = legend;\n    const text = isCustomFormatType(formatType)\n        ? formatCustomType({\n            fieldOrDatumDef,\n            field: 'datum.value',\n            format,\n            formatType,\n            config\n        })\n        : undefined;\n    const labelsSpec = Object.assign(Object.assign(Object.assign({}, (opacity ? { opacity } : {})), (text ? { text } : {})), specifiedlabelsSpec);\n    return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, { legendCmpt }) {\n    const selections = legendCmpt.get('selections');\n    return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), { fill: { value: 'transparent' } }) : entriesSpec;\n}\nfunction getMaxValue(channelDef) {\n    return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\nexport function getFirstConditionValue(channelDef) {\n    return getConditionValue(channelDef, (v, conditionalDef) => {\n        return getFirstDefined(v, conditionalDef.value);\n    });\n}\nfunction getConditionValue(channelDef, reducer) {\n    if (hasConditionalValueDef(channelDef)) {\n        return array(channelDef.condition).reduce(reducer, channelDef.value);\n    }\n    else if (isValueDef(channelDef)) {\n        return channelDef.value;\n    }\n    return undefined;\n}\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n    const selections = legendCmpt.get('selections');\n    if (!(selections === null || selections === void 0 ? void 0 : selections.length))\n        return undefined;\n    const field = stringValue(fieldDef.field);\n    return selections\n        .map(name => {\n        const store = stringValue(varName(name) + STORE);\n        return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n        .join(' || ');\n}\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"module"}