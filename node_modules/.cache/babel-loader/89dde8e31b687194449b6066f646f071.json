{"ast":null,"code":"import { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nexport function getLodStatus(tile, frameState) {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\nexport function getProjectedRadius(tile, frameState) {\n  const originalViewport = frameState.viewport;\n  const ViewportClass = originalViewport.constructor;\n  const {\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom\n  } = originalViewport;\n  const viewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  const toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  const enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  const cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  const cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n  const extraZ = projection * projection / cameraPositionEnu[2];\n  const extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = new Vector3(extraVertexCartesian).subtract(mbsCenterCartesian).normalize();\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = new Vector3(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();\n  return projectedRadius;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["tile","isNaN","screenSize","getProjectedRadius","originalViewport","frameState","ViewportClass","zoom","viewport","pitch","mbsLat","mbsLon","mbsZ","mbsR","mbsCenterCartesian","cameraPositionCartographic","cameraPositionCartesian","Ellipsoid","toEye","enuToCartesianMatrix","cartesianToEnuMatrix","cameraPositionEnu","projection","Math","extraZ","extraVertexEnu","extraVertexCartesian","extraVectorCartesian","radiusVector","sphereMbsBorderVertexCartesian","sphereMbsBorderVertexCartographic","projectedOrigin","projectedMbsBorderVertex","projectedRadius"],"mappings":"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","sourcesContent":["import {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport Tile3D from '../tile-3d';\nimport {FrameState} from './frame-state';\n\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile \n * @param frameState \n * @returns \n */\nexport function getLodStatus(tile: Tile3D, frameState: FrameState): 'DIG' | 'OUT' | 'DRAW' {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile: Tile3D, frameState: FrameState): number {\n  const originalViewport = frameState.viewport;\n  const ViewportClass = originalViewport.constructor;\n  const {longitude, latitude, height, width, bearing, zoom} = originalViewport;\n  // @ts-ignore\n  const viewport = new ViewportClass({longitude, latitude, height, width, bearing, zoom, pitch: 0});\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  const toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  const enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  const cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  const cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(\n    cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]\n  );\n  const extraZ = (projection * projection) / cameraPositionEnu[2];\n  const extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = new Vector3(extraVertexCartesian)\n    .subtract(mbsCenterCartesian)\n    .normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(\n    sphereMbsBorderVertexCartesian\n  );\n  // ---------------------------\n\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = new Vector3(projectedOrigin)\n    .subtract(projectedMbsBorderVertex)\n    .magnitude();\n  return projectedRadius;\n}\n"]},"metadata":{},"sourceType":"module"}