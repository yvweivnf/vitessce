{"ast":null,"code":"/*\n * This source file contains the code for proxying calls in the master thread to calls in the workers\n * by `.postMessage()`-ing.\n *\n * Keep in mind that this code can make or break the program's performance! Need to optimize more…\n */\nimport DebugLogger from \"debug\";\nimport { multicast, Observable } from \"observable-fns\";\nimport { deserialize, serialize } from \"../common\";\nimport { ObservablePromise } from \"../observable-promise\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nconst debugMessages = DebugLogger(\"threads:master:messages\");\nlet nextJobUID = 1;\n\nconst dedupe = array => Array.from(new Set(array));\n\nconst isJobErrorMessage = data => data && data.type === WorkerMessageType.error;\n\nconst isJobResultMessage = data => data && data.type === WorkerMessageType.result;\n\nconst isJobStartMessage = data => data && data.type === WorkerMessageType.running;\n\nfunction createObservableForJob(worker, jobUID) {\n  return new Observable(observer => {\n    let asyncType;\n\n    const messageHandler = event => {\n      debugMessages(\"Message from worker:\", event.data);\n      if (!event.data || event.data.uid !== jobUID) return;\n\n      if (isJobStartMessage(event.data)) {\n        asyncType = event.data.resultType;\n      } else if (isJobResultMessage(event.data)) {\n        if (asyncType === \"promise\") {\n          if (typeof event.data.payload !== \"undefined\") {\n            observer.next(deserialize(event.data.payload));\n          }\n\n          observer.complete();\n          worker.removeEventListener(\"message\", messageHandler);\n        } else {\n          if (event.data.payload) {\n            observer.next(deserialize(event.data.payload));\n          }\n\n          if (event.data.complete) {\n            observer.complete();\n            worker.removeEventListener(\"message\", messageHandler);\n          }\n        }\n      } else if (isJobErrorMessage(event.data)) {\n        const error = deserialize(event.data.error);\n\n        if (asyncType === \"promise\" || !asyncType) {\n          observer.error(error);\n        } else {\n          observer.error(error);\n        }\n\n        worker.removeEventListener(\"message\", messageHandler);\n      }\n    };\n\n    worker.addEventListener(\"message\", messageHandler);\n    return () => {\n      if (asyncType === \"observable\" || !asyncType) {\n        const cancelMessage = {\n          type: MasterMessageType.cancel,\n          uid: jobUID\n        };\n        worker.postMessage(cancelMessage);\n      }\n\n      worker.removeEventListener(\"message\", messageHandler);\n    };\n  });\n}\n\nfunction prepareArguments(rawArgs) {\n  if (rawArgs.length === 0) {\n    // Exit early if possible\n    return {\n      args: [],\n      transferables: []\n    };\n  }\n\n  const args = [];\n  const transferables = [];\n\n  for (const arg of rawArgs) {\n    if (isTransferDescriptor(arg)) {\n      args.push(serialize(arg.send));\n      transferables.push(...arg.transferables);\n    } else {\n      args.push(serialize(arg));\n    }\n  }\n\n  return {\n    args,\n    transferables: transferables.length === 0 ? transferables : dedupe(transferables)\n  };\n}\n\nexport function createProxyFunction(worker, method) {\n  return (...rawArgs) => {\n    const uid = nextJobUID++;\n    const {\n      args,\n      transferables\n    } = prepareArguments(rawArgs);\n    const runMessage = {\n      type: MasterMessageType.run,\n      uid,\n      method,\n      args\n    };\n    debugMessages(\"Sending command to run function to worker:\", runMessage);\n\n    try {\n      worker.postMessage(runMessage, transferables);\n    } catch (error) {\n      return ObservablePromise.from(Promise.reject(error));\n    }\n\n    return ObservablePromise.from(multicast(createObservableForJob(worker, uid)));\n  };\n}\nexport function createProxyModule(worker, methodNames) {\n  const proxy = {};\n\n  for (const methodName of methodNames) {\n    proxy[methodName] = createProxyFunction(worker, methodName);\n  }\n\n  return proxy;\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/threads/dist-esm/master/invocation-proxy.js"],"names":["DebugLogger","multicast","Observable","deserialize","serialize","ObservablePromise","isTransferDescriptor","MasterMessageType","WorkerMessageType","debugMessages","nextJobUID","dedupe","array","Array","from","Set","isJobErrorMessage","data","type","error","isJobResultMessage","result","isJobStartMessage","running","createObservableForJob","worker","jobUID","observer","asyncType","messageHandler","event","uid","resultType","payload","next","complete","removeEventListener","addEventListener","cancelMessage","cancel","postMessage","prepareArguments","rawArgs","length","args","transferables","arg","push","send","createProxyFunction","method","runMessage","run","Promise","reject","createProxyModule","methodNames","proxy","methodName"],"mappings":"AAAA;;;;;;AAMA,OAAOA,WAAP,MAAwB,OAAxB;AACA,SAASC,SAAT,EAAoBC,UAApB,QAAsC,gBAAtC;AACA,SAASC,WAAT,EAAsBC,SAAtB,QAAuC,WAAvC;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA,SAASC,oBAAT,QAAqC,iBAArC;AACA,SAASC,iBAAT,EAA4BC,iBAA5B,QAAqD,mBAArD;AACA,MAAMC,aAAa,GAAGT,WAAW,CAAC,yBAAD,CAAjC;AACA,IAAIU,UAAU,GAAG,CAAjB;;AACA,MAAMC,MAAM,GAAIC,KAAD,IAAWC,KAAK,CAACC,IAAN,CAAW,IAAIC,GAAJ,CAAQH,KAAR,CAAX,CAA1B;;AACA,MAAMI,iBAAiB,GAAIC,IAAD,IAAUA,IAAI,IAAIA,IAAI,CAACC,IAAL,KAAcV,iBAAiB,CAACW,KAA5E;;AACA,MAAMC,kBAAkB,GAAIH,IAAD,IAAUA,IAAI,IAAIA,IAAI,CAACC,IAAL,KAAcV,iBAAiB,CAACa,MAA7E;;AACA,MAAMC,iBAAiB,GAAIL,IAAD,IAAUA,IAAI,IAAIA,IAAI,CAACC,IAAL,KAAcV,iBAAiB,CAACe,OAA5E;;AACA,SAASC,sBAAT,CAAgCC,MAAhC,EAAwCC,MAAxC,EAAgD;AAC5C,SAAO,IAAIxB,UAAJ,CAAeyB,QAAQ,IAAI;AAC9B,QAAIC,SAAJ;;AACA,UAAMC,cAAc,GAAKC,KAAD,IAAW;AAC/BrB,MAAAA,aAAa,CAAC,sBAAD,EAAyBqB,KAAK,CAACb,IAA/B,CAAb;AACA,UAAI,CAACa,KAAK,CAACb,IAAP,IAAea,KAAK,CAACb,IAAN,CAAWc,GAAX,KAAmBL,MAAtC,EACI;;AACJ,UAAIJ,iBAAiB,CAACQ,KAAK,CAACb,IAAP,CAArB,EAAmC;AAC/BW,QAAAA,SAAS,GAAGE,KAAK,CAACb,IAAN,CAAWe,UAAvB;AACH,OAFD,MAGK,IAAIZ,kBAAkB,CAACU,KAAK,CAACb,IAAP,CAAtB,EAAoC;AACrC,YAAIW,SAAS,KAAK,SAAlB,EAA6B;AACzB,cAAI,OAAOE,KAAK,CAACb,IAAN,CAAWgB,OAAlB,KAA8B,WAAlC,EAA+C;AAC3CN,YAAAA,QAAQ,CAACO,IAAT,CAAc/B,WAAW,CAAC2B,KAAK,CAACb,IAAN,CAAWgB,OAAZ,CAAzB;AACH;;AACDN,UAAAA,QAAQ,CAACQ,QAAT;AACAV,UAAAA,MAAM,CAACW,mBAAP,CAA2B,SAA3B,EAAsCP,cAAtC;AACH,SAND,MAOK;AACD,cAAIC,KAAK,CAACb,IAAN,CAAWgB,OAAf,EAAwB;AACpBN,YAAAA,QAAQ,CAACO,IAAT,CAAc/B,WAAW,CAAC2B,KAAK,CAACb,IAAN,CAAWgB,OAAZ,CAAzB;AACH;;AACD,cAAIH,KAAK,CAACb,IAAN,CAAWkB,QAAf,EAAyB;AACrBR,YAAAA,QAAQ,CAACQ,QAAT;AACAV,YAAAA,MAAM,CAACW,mBAAP,CAA2B,SAA3B,EAAsCP,cAAtC;AACH;AACJ;AACJ,OAjBI,MAkBA,IAAIb,iBAAiB,CAACc,KAAK,CAACb,IAAP,CAArB,EAAmC;AACpC,cAAME,KAAK,GAAGhB,WAAW,CAAC2B,KAAK,CAACb,IAAN,CAAWE,KAAZ,CAAzB;;AACA,YAAIS,SAAS,KAAK,SAAd,IAA2B,CAACA,SAAhC,EAA2C;AACvCD,UAAAA,QAAQ,CAACR,KAAT,CAAeA,KAAf;AACH,SAFD,MAGK;AACDQ,UAAAA,QAAQ,CAACR,KAAT,CAAeA,KAAf;AACH;;AACDM,QAAAA,MAAM,CAACW,mBAAP,CAA2B,SAA3B,EAAsCP,cAAtC;AACH;AACJ,KAnCD;;AAoCAJ,IAAAA,MAAM,CAACY,gBAAP,CAAwB,SAAxB,EAAmCR,cAAnC;AACA,WAAO,MAAM;AACT,UAAID,SAAS,KAAK,YAAd,IAA8B,CAACA,SAAnC,EAA8C;AAC1C,cAAMU,aAAa,GAAG;AAClBpB,UAAAA,IAAI,EAAEX,iBAAiB,CAACgC,MADN;AAElBR,UAAAA,GAAG,EAAEL;AAFa,SAAtB;AAIAD,QAAAA,MAAM,CAACe,WAAP,CAAmBF,aAAnB;AACH;;AACDb,MAAAA,MAAM,CAACW,mBAAP,CAA2B,SAA3B,EAAsCP,cAAtC;AACH,KATD;AAUH,GAjDM,CAAP;AAkDH;;AACD,SAASY,gBAAT,CAA0BC,OAA1B,EAAmC;AAC/B,MAAIA,OAAO,CAACC,MAAR,KAAmB,CAAvB,EAA0B;AACtB;AACA,WAAO;AACHC,MAAAA,IAAI,EAAE,EADH;AAEHC,MAAAA,aAAa,EAAE;AAFZ,KAAP;AAIH;;AACD,QAAMD,IAAI,GAAG,EAAb;AACA,QAAMC,aAAa,GAAG,EAAtB;;AACA,OAAK,MAAMC,GAAX,IAAkBJ,OAAlB,EAA2B;AACvB,QAAIpC,oBAAoB,CAACwC,GAAD,CAAxB,EAA+B;AAC3BF,MAAAA,IAAI,CAACG,IAAL,CAAU3C,SAAS,CAAC0C,GAAG,CAACE,IAAL,CAAnB;AACAH,MAAAA,aAAa,CAACE,IAAd,CAAmB,GAAGD,GAAG,CAACD,aAA1B;AACH,KAHD,MAIK;AACDD,MAAAA,IAAI,CAACG,IAAL,CAAU3C,SAAS,CAAC0C,GAAD,CAAnB;AACH;AACJ;;AACD,SAAO;AACHF,IAAAA,IADG;AAEHC,IAAAA,aAAa,EAAEA,aAAa,CAACF,MAAd,KAAyB,CAAzB,GAA6BE,aAA7B,GAA6ClC,MAAM,CAACkC,aAAD;AAF/D,GAAP;AAIH;;AACD,OAAO,SAASI,mBAAT,CAA6BxB,MAA7B,EAAqCyB,MAArC,EAA6C;AAChD,SAAQ,CAAC,GAAGR,OAAJ,KAAgB;AACpB,UAAMX,GAAG,GAAGrB,UAAU,EAAtB;AACA,UAAM;AAAEkC,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAA0BJ,gBAAgB,CAACC,OAAD,CAAhD;AACA,UAAMS,UAAU,GAAG;AACfjC,MAAAA,IAAI,EAAEX,iBAAiB,CAAC6C,GADT;AAEfrB,MAAAA,GAFe;AAGfmB,MAAAA,MAHe;AAIfN,MAAAA;AAJe,KAAnB;AAMAnC,IAAAA,aAAa,CAAC,4CAAD,EAA+C0C,UAA/C,CAAb;;AACA,QAAI;AACA1B,MAAAA,MAAM,CAACe,WAAP,CAAmBW,UAAnB,EAA+BN,aAA/B;AACH,KAFD,CAGA,OAAO1B,KAAP,EAAc;AACV,aAAOd,iBAAiB,CAACS,IAAlB,CAAuBuC,OAAO,CAACC,MAAR,CAAenC,KAAf,CAAvB,CAAP;AACH;;AACD,WAAOd,iBAAiB,CAACS,IAAlB,CAAuBb,SAAS,CAACuB,sBAAsB,CAACC,MAAD,EAASM,GAAT,CAAvB,CAAhC,CAAP;AACH,GAjBD;AAkBH;AACD,OAAO,SAASwB,iBAAT,CAA2B9B,MAA3B,EAAmC+B,WAAnC,EAAgD;AACnD,QAAMC,KAAK,GAAG,EAAd;;AACA,OAAK,MAAMC,UAAX,IAAyBF,WAAzB,EAAsC;AAClCC,IAAAA,KAAK,CAACC,UAAD,CAAL,GAAoBT,mBAAmB,CAACxB,MAAD,EAASiC,UAAT,CAAvC;AACH;;AACD,SAAOD,KAAP;AACH","sourcesContent":["/*\n * This source file contains the code for proxying calls in the master thread to calls in the workers\n * by `.postMessage()`-ing.\n *\n * Keep in mind that this code can make or break the program's performance! Need to optimize more…\n */\nimport DebugLogger from \"debug\";\nimport { multicast, Observable } from \"observable-fns\";\nimport { deserialize, serialize } from \"../common\";\nimport { ObservablePromise } from \"../observable-promise\";\nimport { isTransferDescriptor } from \"../transferable\";\nimport { MasterMessageType, WorkerMessageType } from \"../types/messages\";\nconst debugMessages = DebugLogger(\"threads:master:messages\");\nlet nextJobUID = 1;\nconst dedupe = (array) => Array.from(new Set(array));\nconst isJobErrorMessage = (data) => data && data.type === WorkerMessageType.error;\nconst isJobResultMessage = (data) => data && data.type === WorkerMessageType.result;\nconst isJobStartMessage = (data) => data && data.type === WorkerMessageType.running;\nfunction createObservableForJob(worker, jobUID) {\n    return new Observable(observer => {\n        let asyncType;\n        const messageHandler = ((event) => {\n            debugMessages(\"Message from worker:\", event.data);\n            if (!event.data || event.data.uid !== jobUID)\n                return;\n            if (isJobStartMessage(event.data)) {\n                asyncType = event.data.resultType;\n            }\n            else if (isJobResultMessage(event.data)) {\n                if (asyncType === \"promise\") {\n                    if (typeof event.data.payload !== \"undefined\") {\n                        observer.next(deserialize(event.data.payload));\n                    }\n                    observer.complete();\n                    worker.removeEventListener(\"message\", messageHandler);\n                }\n                else {\n                    if (event.data.payload) {\n                        observer.next(deserialize(event.data.payload));\n                    }\n                    if (event.data.complete) {\n                        observer.complete();\n                        worker.removeEventListener(\"message\", messageHandler);\n                    }\n                }\n            }\n            else if (isJobErrorMessage(event.data)) {\n                const error = deserialize(event.data.error);\n                if (asyncType === \"promise\" || !asyncType) {\n                    observer.error(error);\n                }\n                else {\n                    observer.error(error);\n                }\n                worker.removeEventListener(\"message\", messageHandler);\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        return () => {\n            if (asyncType === \"observable\" || !asyncType) {\n                const cancelMessage = {\n                    type: MasterMessageType.cancel,\n                    uid: jobUID\n                };\n                worker.postMessage(cancelMessage);\n            }\n            worker.removeEventListener(\"message\", messageHandler);\n        };\n    });\n}\nfunction prepareArguments(rawArgs) {\n    if (rawArgs.length === 0) {\n        // Exit early if possible\n        return {\n            args: [],\n            transferables: []\n        };\n    }\n    const args = [];\n    const transferables = [];\n    for (const arg of rawArgs) {\n        if (isTransferDescriptor(arg)) {\n            args.push(serialize(arg.send));\n            transferables.push(...arg.transferables);\n        }\n        else {\n            args.push(serialize(arg));\n        }\n    }\n    return {\n        args,\n        transferables: transferables.length === 0 ? transferables : dedupe(transferables)\n    };\n}\nexport function createProxyFunction(worker, method) {\n    return ((...rawArgs) => {\n        const uid = nextJobUID++;\n        const { args, transferables } = prepareArguments(rawArgs);\n        const runMessage = {\n            type: MasterMessageType.run,\n            uid,\n            method,\n            args\n        };\n        debugMessages(\"Sending command to run function to worker:\", runMessage);\n        try {\n            worker.postMessage(runMessage, transferables);\n        }\n        catch (error) {\n            return ObservablePromise.from(Promise.reject(error));\n        }\n        return ObservablePromise.from(multicast(createObservableForJob(worker, uid)));\n    });\n}\nexport function createProxyModule(worker, methodNames) {\n    const proxy = {};\n    for (const methodName of methodNames) {\n        proxy[methodName] = createProxyFunction(worker, methodName);\n    }\n    return proxy;\n}\n"]},"metadata":{},"sourceType":"module"}