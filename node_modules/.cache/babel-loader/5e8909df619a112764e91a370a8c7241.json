{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nvar KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport var name = KHR_MATERIALS_UNLIT;\nexport function decode(_x) {\n  return _decode.apply(this, arguments);\n}\n\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltfData) {\n    var gltfScenegraph, json, _iterator2, _step2, material, extension;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            gltfScenegraph = new GLTFScenegraph(gltfData);\n            json = gltfScenegraph.json;\n            gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n            _iterator2 = _createForOfIteratorHelper(json.materials || []);\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                material = _step2.value;\n                extension = material.extensions && material.extensions.KHR_materials_unlit;\n\n                if (extension) {\n                  material.unlit = true;\n                }\n\n                gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\n\nexport function encode(gltfData) {\n  var gltfScenegraph = new GLTFScenegraph(gltfData);\n  var json = gltfScenegraph.json;\n\n  if (gltfScenegraph.materials) {\n    var _iterator = _createForOfIteratorHelper(json.materials || []),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var material = _step.value;\n\n        if (material.unlit) {\n          delete material.unlit;\n          gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n          gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../src/lib/extensions/deprecated/KHR_materials_unlit.ts"],"names":["KHR_MATERIALS_UNLIT","name","gltfScenegraph","json","extension","material"],"mappings":";;;AAKA,OAAA,cAAA,MAAA,2BAAA;AAEA,IAAMA,mBAAmB,GAAzB,qBAAA;AAEA,OAAO,IAAMC,IAAI,GAAV,mBAAA;AAEP,gBAAO,MAAP;AAAA;AAAA;;;qEAAO,iBAAA,QAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACCC,YAAAA,cADD,GACkB,IAAA,cAAA,CAAvB,QAAuB,CADlB;AAEEC,YAAAA,IAFF,GAEL,cAFK,CAEEA,IAFF;AAKLD,YAAAA,cAAc,CAAdA,eAAAA,CAAAA,mBAAAA;AALK,oDASkBC,IAAI,CAAJA,SAAAA,IAAvB,EATK;;AAAA;AASL,qEAA6C;AAA7C,gBAAA,QAA6C;AACrCC,gBAAAA,SADqC,GACzBC,QAAQ,CAARA,UAAAA,IAAuBA,QAAQ,CAARA,UAAAA,CAAzC,mBAD2C;;AAE3C,oBAAA,SAAA,EAAe;AAEbA,kBAAAA,QAAQ,CAARA,KAAAA,GAAAA,IAAAA;AACD;;AACDH,gBAAAA,cAAc,CAAdA,qBAAAA,CAAAA,QAAAA,EAAAA,mBAAAA;AACD;AAhBI;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAmBP,OAAO,SAAA,MAAA,CAAA,QAAA,EAA0B;AAC/B,MAAMA,cAAc,GAAG,IAAA,cAAA,CAAvB,QAAuB,CAAvB;AAD+B,MAExBC,IAFwB,GAE/B,cAF+B,CAExBA,IAFwB;;AAO/B,MAAID,cAAc,CAAlB,SAAA,EAA8B;AAAA,+CACLC,IAAI,CAAJA,SAAAA,IAAvB,EAD4B;AAAA;;AAAA;AAC5B,0DAA6C;AAAA,YAA7C,QAA6C;;AAE3C,YAAIE,QAAQ,CAAZ,KAAA,EAAoB;AAElB,iBAAOA,QAAQ,CAAf,KAAA;AACAH,UAAAA,cAAc,CAAdA,kBAAAA,CAAAA,QAAAA,EAAAA,mBAAAA,EAAAA,EAAAA;AACAA,UAAAA,cAAc,CAAdA,YAAAA,CAAAA,mBAAAA;AACD;AACF;AAT2B;AAAA;AAAA;AAAA;AAAA;AAU7B;AACF","sourcesContent":["// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\n\nexport const name = KHR_MATERIALS_UNLIT;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}