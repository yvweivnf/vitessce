{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash as _hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport var FilterInvalidNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(FilterInvalidNode, _DataFlowNode);\n\n  var _super = _createSuper(FilterInvalidNode);\n\n  function FilterInvalidNode(parent, filter) {\n    var _this;\n\n    _classCallCheck(this, FilterInvalidNode);\n\n    _this = _super.call(this, parent);\n    _this.filter = filter;\n    return _this;\n  }\n\n  _createClass(FilterInvalidNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new FilterInvalidNode(null, Object.assign({}, this.filter));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(keys(this.filter));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(); // filter does not produce any new fields\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"FilterInvalid \".concat(_hash(this.filter));\n    }\n    /**\n     * Create the VgTransforms for each of the filtered fields.\n     */\n\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _this2 = this;\n\n      var filters = keys(this.filter).reduce(function (vegaFilters, field) {\n        var fieldDef = _this2.filter[field];\n        var ref = fieldRef(fieldDef, {\n          expr: 'datum'\n        });\n\n        if (fieldDef !== null) {\n          if (fieldDef.type === 'temporal') {\n            vegaFilters.push(\"(isDate(\".concat(ref, \") || (isValid(\").concat(ref, \") && isFinite(+\").concat(ref, \")))\"));\n          } else if (fieldDef.type === 'quantitative') {\n            vegaFilters.push(\"isValid(\".concat(ref, \")\"));\n            vegaFilters.push(\"isFinite(+\".concat(ref, \")\"));\n          } else {// should never get here\n          }\n        }\n\n        return vegaFilters;\n      }, []);\n      return filters.length > 0 ? {\n        type: 'filter',\n        expr: filters.join(' && ')\n      } : null;\n    }\n  }], [{\n    key: \"make\",\n    value: function make(parent, model) {\n      var config = model.config,\n          mark = model.mark,\n          markDef = model.markDef;\n      var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n      if (invalid !== 'filter') {\n        return null;\n      }\n\n      var filter = model.reduceFieldDef(function (aggregator, fieldDef, channel) {\n        var scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n\n        if (scaleComponent) {\n          var scaleType = scaleComponent.get('type'); // While discrete domain scales can handle invalid values, continuous scales can't.\n          // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n          // (For path marks, we will use \"defined\" property and skip these values instead.)\n\n          if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n            aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n          }\n        }\n\n        return aggregator;\n      }, {});\n\n      if (!keys(filter).length) {\n        return null;\n      }\n\n      return new FilterInvalidNode(parent, filter);\n    }\n  }]);\n\n  return FilterInvalidNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/filterinvalid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport class FilterInvalidNode extends DataFlowNode {\n    constructor(parent, filter) {\n        super(parent);\n        this.filter = filter;\n    }\n    clone() {\n        return new FilterInvalidNode(null, Object.assign({}, this.filter));\n    }\n    static make(parent, model) {\n        const { config, mark, markDef } = model;\n        const invalid = getMarkPropOrConfig('invalid', markDef, config);\n        if (invalid !== 'filter') {\n            return null;\n        }\n        const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n            const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n            if (scaleComponent) {\n                const scaleType = scaleComponent.get('type');\n                // While discrete domain scales can handle invalid values, continuous scales can't.\n                // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n                // (For path marks, we will use \"defined\" property and skip these values instead.)\n                if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n                    aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n                }\n            }\n            return aggregator;\n        }, {});\n        if (!keys(filter).length) {\n            return null;\n        }\n        return new FilterInvalidNode(parent, filter);\n    }\n    dependentFields() {\n        return new Set(keys(this.filter));\n    }\n    producedFields() {\n        return new Set(); // filter does not produce any new fields\n    }\n    hash() {\n        return `FilterInvalid ${hash(this.filter)}`;\n    }\n    /**\n     * Create the VgTransforms for each of the filtered fields.\n     */\n    assemble() {\n        const filters = keys(this.filter).reduce((vegaFilters, field) => {\n            const fieldDef = this.filter[field];\n            const ref = fieldRef(fieldDef, { expr: 'datum' });\n            if (fieldDef !== null) {\n                if (fieldDef.type === 'temporal') {\n                    vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`);\n                }\n                else if (fieldDef.type === 'quantitative') {\n                    vegaFilters.push(`isValid(${ref})`);\n                    vegaFilters.push(`isFinite(+${ref})`);\n                }\n                else {\n                    // should never get here\n                }\n            }\n            return vegaFilters;\n        }, []);\n        return filters.length > 0\n            ? {\n                type: 'filter',\n                expr: filters.join(' && ')\n            }\n            : null;\n    }\n}\n//# sourceMappingURL=filterinvalid.js.map"]},"metadata":{},"sourceType":"module"}