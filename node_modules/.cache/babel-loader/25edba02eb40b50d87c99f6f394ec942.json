{"ast":null,"code":"import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { entries, keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\n\nexport function binToString(bin) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n\n  return 'bin' + keys(bin).map(function (p) {\n    return isParameterExtent(bin[p]) ? varName(\"_\".concat(p, \"_\").concat(entries(bin[p]))) : varName(\"_\".concat(p, \"_\").concat(bin[p]));\n  }).join('');\n}\n/**\n * Vega-Lite should bin the data.\n */\n\nexport function isBinning(bin) {\n  return bin === true || isBinParams(bin) && !bin.binned;\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\n\nexport function isBinned(bin) {\n  return bin === 'binned' || isBinParams(bin) && bin.binned === true;\n}\nexport function isBinParams(bin) {\n  return isObject(bin);\n}\nexport function isParameterExtent(extent) {\n  return extent === null || extent === void 0 ? void 0 : extent['param'];\n}\nexport function autoMaxBins(channel) {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n\n    case SHAPE:\n      return 6;\n    // Vega's \"shape\" has 6 distinct values\n\n    case STROKEDASH:\n      return 4;\n    // We only provide 5 different stroke dash values (but 4 is more effective)\n\n    default:\n      return 10;\n  }\n}","map":{"version":3,"sources":["../../src/bin.ts"],"names":[],"mappings":"AAAA,SAAQ,SAAR,EAAmB,QAAnB,QAAkC,WAAlC;AACA,SACE,KADF,EAEE,MAFF,EAIE,IAJF,EAKE,WALF,EAME,OANF,EAOE,GAPF,EAQE,KARF,EASE,IATF,EAUE,MAVF,EAWE,UAXF,EAYE,aAZF,EAaE,WAbF,QAcO,WAdP;AAeA,SAAQ,YAAR,QAA2B,cAA3B;AAEA,SAAQ,OAAR,EAAiB,IAAjB,EAAuB,OAAvB,QAAqC,QAArC;AA0EA;;;;AAGA,OAAM,SAAU,WAAV,CAAsB,GAAtB,EAA2C;AAC/C,MAAI,SAAS,CAAC,GAAD,CAAb,EAAoB;AAClB,IAAA,GAAG,GAAG,YAAY,CAAC,GAAD,EAAM,SAAN,CAAlB;AACD;;AACD,SACE,QACA,IAAI,CAAC,GAAD,CAAJ,CACG,GADH,CACO,UAAA,CAAC;AAAA,WAAK,iBAAiB,CAAC,GAAG,CAAC,CAAD,CAAJ,CAAjB,GAA4B,OAAO,YAAK,CAAL,cAAU,OAAO,CAAC,GAAG,CAAC,CAAD,CAAJ,CAAjB,EAAnC,GAAkE,OAAO,YAAK,CAAL,cAAU,GAAG,CAAC,CAAD,CAAb,EAA9E;AAAA,GADR,EAEG,IAFH,CAEQ,EAFR,CAFF;AAMD;AAED;;;;AAGA,OAAM,SAAU,SAAV,CAAoB,GAApB,EAAuD;AAC3D,SAAO,GAAG,KAAK,IAAR,IAAiB,WAAW,CAAC,GAAD,CAAX,IAAoB,CAAC,GAAG,CAAC,MAAjD;AACD;AAED;;;;AAGA,OAAM,SAAU,QAAV,CAAmB,GAAnB,EAAsD;AAC1D,SAAO,GAAG,KAAK,QAAR,IAAqB,WAAW,CAAC,GAAD,CAAX,IAAoB,GAAG,CAAC,MAAJ,KAAe,IAA/D;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,GAAtB,EAAyD;AAC7D,SAAO,QAAQ,CAAC,GAAD,CAAf;AACD;AAED,OAAM,SAAU,iBAAV,CAA4B,MAA5B,EAA6C;AACjD,SAAO,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAG,OAAH,CAAb;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,OAAtB,EAA+C;AACnD,UAAQ,OAAR;AACE,SAAK,GAAL;AACA,SAAK,MAAL;AACA,SAAK,IAAL;AACA,SAAK,KAAL;AACA,SAAK,IAAL;AACA,SAAK,MAAL;AACA,SAAK,WAAL;AACA,SAAK,OAAL;AACA,SAAK,WAAL;AACA,SAAK,aAAL,CAVF,CAWE;AACA;;AACA,SAAK,KAAL;AACE,aAAO,CAAP;AAAU;;AACZ,SAAK,UAAL;AACE,aAAO,CAAP;AAAU;;AACZ;AACE,aAAO,EAAP;AAlBJ;AAoBD","sourceRoot":"","sourcesContent":["import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { entries, keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\nexport function binToString(bin) {\n    if (isBoolean(bin)) {\n        bin = normalizeBin(bin, undefined);\n    }\n    return ('bin' +\n        keys(bin)\n            .map(p => (isParameterExtent(bin[p]) ? varName(`_${p}_${entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)))\n            .join(''));\n}\n/**\n * Vega-Lite should bin the data.\n */\nexport function isBinning(bin) {\n    return bin === true || (isBinParams(bin) && !bin.binned);\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\nexport function isBinned(bin) {\n    return bin === 'binned' || (isBinParams(bin) && bin.binned === true);\n}\nexport function isBinParams(bin) {\n    return isObject(bin);\n}\nexport function isParameterExtent(extent) {\n    return extent === null || extent === void 0 ? void 0 : extent['param'];\n}\nexport function autoMaxBins(channel) {\n    switch (channel) {\n        case ROW:\n        case COLUMN:\n        case SIZE:\n        case COLOR:\n        case FILL:\n        case STROKE:\n        case STROKEWIDTH:\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        // Facets and Size shouldn't have too many bins\n        // We choose 6 like shape to simplify the rule [falls through]\n        case SHAPE:\n            return 6; // Vega's \"shape\" has 6 distinct values\n        case STROKEDASH:\n            return 4; // We only provide 5 different stroke dash values (but 4 is more effective)\n        default:\n            return 10;\n    }\n}\n//# sourceMappingURL=bin.js.map"]},"metadata":{},"sourceType":"module"}