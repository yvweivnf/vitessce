{"ast":null,"code":"import { useMemo } from 'react';\nimport { getValueTransformFunction } from '../gating/utils';\nimport { mergeCellSets } from '../utils';\nimport { treeToObjectsBySetNames, treeToSetSizesBySetNames } from './cell-set-utils';\n/**\n * Get expression data for the cells\n * in the selected cell sets.\n * @param {object} expressionMatrix\n * @param {string[]} expressionMatrix.rows Cell IDs.\n * @param {string[]} expressionMatrix.cols Gene names.\n * @param {Uint8Array} expressionMatrix.matrix The\n * flattened expression matrix as a typed array.\n * @param {object} cellSets The cell sets from the dataset.\n * @param {object} additionalCellSets The user-defined cell sets\n * from the coordination space.\n * @param {array} geneSelection Array of selected genes.\n * @param {array} cellSetSelection Array of selected cell set paths.\n * @param {object[]} cellSetColor Array of objects with properties\n * @param {string|null} featureValueTransform The name of the\n * feature value transform function.\n * @param {number} featureValueTransformCoefficient A coefficient\n * to be used in the transform function.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * `path` and `color`.\n */\n\nexport function useExpressionByCellSet(expressionData, expressionDataAttrs, cellSets, additionalCellSets, geneSelection, cellSetSelection, cellSetColor, featureValueTransform, featureValueTransformCoefficient, theme) {\n  const mergedCellSets = useMemo(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]); // From the expression matrix and the list of selected genes / cell sets,\n  // generate the array of data points for the plot.\n\n  const [expressionArr, expressionMax] = useMemo(() => {\n    if (mergedCellSets && cellSetSelection && geneSelection && geneSelection.length >= 1 && expressionData) {\n      const cellObjects = treeToObjectsBySetNames(mergedCellSets, cellSetSelection, cellSetColor, theme);\n      const firstGeneSelected = geneSelection[0]; // Create new cellColors map based on the selected gene.\n\n      let exprMax = -Infinity;\n      const cellIndices = {};\n\n      for (let i = 0; i < expressionDataAttrs.rows.length; i += 1) {\n        cellIndices[expressionDataAttrs.rows[i]] = i;\n      }\n\n      const exprValues = cellObjects.map(cell => {\n        const cellIndex = cellIndices[cell.obsId];\n        const value = expressionData[0][cellIndex];\n        const normValue = value * 100 / 255;\n        const transformFunction = getValueTransformFunction(featureValueTransform, featureValueTransformCoefficient);\n        const transformedValue = transformFunction(normValue);\n        exprMax = Math.max(transformedValue, exprMax);\n        return {\n          value: transformedValue,\n          gene: firstGeneSelected,\n          set: cell.name\n        };\n      });\n      return [exprValues, exprMax];\n    }\n\n    return [null, null];\n  }, [expressionData, expressionDataAttrs, geneSelection, theme, mergedCellSets, cellSetSelection, cellSetColor, featureValueTransform, featureValueTransformCoefficient]); // From the cell sets hierarchy and the list of selected cell sets,\n  // generate the array of set sizes data points for the bar plot.\n\n  const setArr = useMemo(() => mergedCellSets && cellSetSelection && cellSetColor ? treeToSetSizesBySetNames(mergedCellSets, cellSetSelection, cellSetColor, theme) : [], [mergedCellSets, cellSetSelection, cellSetColor, theme]);\n  return [expressionArr, setArr, expressionMax];\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/hooks.js"],"names":["useMemo","getValueTransformFunction","mergeCellSets","treeToObjectsBySetNames","treeToSetSizesBySetNames","useExpressionByCellSet","expressionData","expressionDataAttrs","cellSets","additionalCellSets","geneSelection","cellSetSelection","cellSetColor","featureValueTransform","featureValueTransformCoefficient","theme","mergedCellSets","expressionArr","expressionMax","length","cellObjects","firstGeneSelected","exprMax","Infinity","cellIndices","i","rows","exprValues","map","cell","cellIndex","obsId","value","normValue","transformFunction","transformedValue","Math","max","gene","set","name","setArr"],"mappings":"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","sourcesContent":["import { useMemo } from 'react';\nimport { getValueTransformFunction } from '../gating/utils';\nimport { mergeCellSets } from '../utils';\nimport { treeToObjectsBySetNames, treeToSetSizesBySetNames } from './cell-set-utils';\n\n/**\n * Get expression data for the cells\n * in the selected cell sets.\n * @param {object} expressionMatrix\n * @param {string[]} expressionMatrix.rows Cell IDs.\n * @param {string[]} expressionMatrix.cols Gene names.\n * @param {Uint8Array} expressionMatrix.matrix The\n * flattened expression matrix as a typed array.\n * @param {object} cellSets The cell sets from the dataset.\n * @param {object} additionalCellSets The user-defined cell sets\n * from the coordination space.\n * @param {array} geneSelection Array of selected genes.\n * @param {array} cellSetSelection Array of selected cell set paths.\n * @param {object[]} cellSetColor Array of objects with properties\n * @param {string|null} featureValueTransform The name of the\n * feature value transform function.\n * @param {number} featureValueTransformCoefficient A coefficient\n * to be used in the transform function.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * `path` and `color`.\n */\nexport function useExpressionByCellSet(\n  expressionData, expressionDataAttrs, cellSets, additionalCellSets,\n  geneSelection, cellSetSelection, cellSetColor,\n  featureValueTransform, featureValueTransformCoefficient,\n  theme,\n) {\n  const mergedCellSets = useMemo(\n    () => mergeCellSets(cellSets, additionalCellSets),\n    [cellSets, additionalCellSets],\n  );\n\n  // From the expression matrix and the list of selected genes / cell sets,\n  // generate the array of data points for the plot.\n  const [expressionArr, expressionMax] = useMemo(() => {\n    if (mergedCellSets && cellSetSelection\n        && geneSelection && geneSelection.length >= 1\n        && expressionData\n    ) {\n      const cellObjects = treeToObjectsBySetNames(\n        mergedCellSets, cellSetSelection, cellSetColor, theme,\n      );\n\n      const firstGeneSelected = geneSelection[0];\n      // Create new cellColors map based on the selected gene.\n      let exprMax = -Infinity;\n      const cellIndices = {};\n      for (let i = 0; i < expressionDataAttrs.rows.length; i += 1) {\n        cellIndices[expressionDataAttrs.rows[i]] = i;\n      }\n      const exprValues = cellObjects.map((cell) => {\n        const cellIndex = cellIndices[cell.obsId];\n        const value = expressionData[0][cellIndex];\n        const normValue = value * 100 / 255;\n        const transformFunction = getValueTransformFunction(\n          featureValueTransform, featureValueTransformCoefficient,\n        );\n        const transformedValue = transformFunction(normValue);\n        exprMax = Math.max(transformedValue, exprMax);\n        return { value: transformedValue, gene: firstGeneSelected, set: cell.name };\n      });\n      return [exprValues, exprMax];\n    }\n    return [null, null];\n  }, [expressionData, expressionDataAttrs, geneSelection, theme,\n    mergedCellSets, cellSetSelection, cellSetColor,\n    featureValueTransform, featureValueTransformCoefficient,\n  ]);\n\n  // From the cell sets hierarchy and the list of selected cell sets,\n  // generate the array of set sizes data points for the bar plot.\n  const setArr = useMemo(() => (mergedCellSets && cellSetSelection && cellSetColor\n    ? treeToSetSizesBySetNames(mergedCellSets, cellSetSelection, cellSetColor, theme)\n    : []\n  ), [mergedCellSets, cellSetSelection, cellSetColor, theme]);\n\n  return [expressionArr, setArr, expressionMax];\n}\n"]},"metadata":{},"sourceType":"module"}