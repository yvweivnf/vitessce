{"ast":null,"code":"// ==ClosureCompiler==\n// @output_file_name default.js\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// ==/ClosureCompiler==\n// module.exports = {\n//     parse: parse,\n//     simplify: simplify,\n//     simplifyLostLess: simplifyLostLess,\n//     filter: filter,\n//     stringify: stringify,\n//     toContentString: toContentString,\n//     getElementById: getElementById,\n//     getElementsByClassName: getElementsByClassName,\n//     transformStream: transformStream,\n// };\n\n/**\n * @author: Tobias Nickel\n * @created: 06.04.2015\n * I needed a small xmlparser chat can be used in a worker.\n */\n\n/**\n * @typedef tNode \n * @property {string} tagName \n * @property {object} attributes\n * @property {(tNode|string)[]} children \n **/\n\n/**\n * @typedef TParseOptions\n * @property {number} [pos]\n * @property {string[]} [noChildNodes]\n * @property {boolean} [setPos]\n * @property {boolean} [keepComments] \n * @property {boolean} [keepWhitespace]\n * @property {boolean} [simplify]\n * @property {(a: tNode, b: tNode) => boolean} [filter]\n */\n\n/**\n * parseXML / html into a DOM Object. with no validation and some failur tolerance\n * @param {string} S your XML to parse\n * @param {TParseOptions} [options]  all other options:\n * @return {(tNode | string)[]}\n */\nfunction parse(S, options) {\n  \"txml\";\n\n  options = options || {};\n  var pos = options.pos || 0;\n  var keepComments = !!options.keepComments;\n  var keepWhitespace = !!options.keepWhitespace;\n  var openBracket = \"<\";\n  var openBracketCC = \"<\".charCodeAt(0);\n  var closeBracket = \">\";\n  var closeBracketCC = \">\".charCodeAt(0);\n  var minusCC = \"-\".charCodeAt(0);\n  var slashCC = \"/\".charCodeAt(0);\n  var exclamationCC = '!'.charCodeAt(0);\n  var singleQuoteCC = \"'\".charCodeAt(0);\n  var doubleQuoteCC = '\"'.charCodeAt(0);\n  var openCornerBracketCC = '['.charCodeAt(0);\n  var closeCornerBracketCC = ']'.charCodeAt(0);\n  /**\n   * parsing a list of entries\n   */\n\n  function parseChildren(tagName) {\n    var children = [];\n\n    while (S[pos]) {\n      if (S.charCodeAt(pos) == openBracketCC) {\n        if (S.charCodeAt(pos + 1) === slashCC) {\n          var closeStart = pos + 2;\n          pos = S.indexOf(closeBracket, pos);\n          var closeTag = S.substring(closeStart, pos);\n\n          if (closeTag.indexOf(tagName) == -1) {\n            var parsedText = S.substring(0, pos).split('\\n');\n            throw new Error('Unexpected close tag\\nLine: ' + (parsedText.length - 1) + '\\nColumn: ' + (parsedText[parsedText.length - 1].length + 1) + '\\nChar: ' + S[pos]);\n          }\n\n          if (pos + 1) pos += 1;\n          return children;\n        } else if (S.charCodeAt(pos + 1) === exclamationCC) {\n          if (S.charCodeAt(pos + 2) == minusCC) {\n            //comment support\n            const startCommentPos = pos;\n\n            while (pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1)) {\n              pos = S.indexOf(closeBracket, pos + 1);\n            }\n\n            if (pos === -1) {\n              pos = S.length;\n            }\n\n            if (keepComments) {\n              children.push(S.substring(startCommentPos, pos + 1));\n            }\n          } else if (S.charCodeAt(pos + 2) === openCornerBracketCC && S.charCodeAt(pos + 8) === openCornerBracketCC && S.substr(pos + 3, 5).toLowerCase() === 'cdata') {\n            // cdata\n            var cdataEndIndex = S.indexOf(']]>', pos);\n\n            if (cdataEndIndex == -1) {\n              children.push(S.substr(pos + 9));\n              pos = S.length;\n            } else {\n              children.push(S.substring(pos + 9, cdataEndIndex));\n              pos = cdataEndIndex + 3;\n            }\n\n            continue;\n          } else {\n            // doctypesupport\n            const startDoctype = pos + 1;\n            pos += 2;\n            var encapsuled = false;\n\n            while ((S.charCodeAt(pos) !== closeBracketCC || encapsuled === true) && S[pos]) {\n              if (S.charCodeAt(pos) === openCornerBracketCC) {\n                encapsuled = true;\n              } else if (encapsuled === true && S.charCodeAt(pos) === closeCornerBracketCC) {\n                encapsuled = false;\n              }\n\n              pos++;\n            }\n\n            children.push(S.substring(startDoctype, pos));\n          }\n\n          pos++;\n          continue;\n        }\n\n        var node = parseNode();\n        children.push(node);\n\n        if (node.tagName[0] === '?') {\n          children.push(...node.children);\n          node.children = [];\n        }\n      } else {\n        var text = parseText();\n\n        if (keepWhitespace) {\n          if (text.length > 0) {\n            children.push(text);\n          }\n        } else {\n          var trimmed = text.trim();\n\n          if (trimmed.length > 0) {\n            children.push(trimmed);\n          }\n        }\n\n        pos++;\n      }\n    }\n\n    return children;\n  }\n  /**\n   *    returns the text outside of texts until the first '<'\n   */\n\n\n  function parseText() {\n    var start = pos;\n    pos = S.indexOf(openBracket, pos) - 1;\n    if (pos === -2) pos = S.length;\n    return S.slice(start, pos + 1);\n  }\n  /**\n   *    returns text until the first nonAlphabetic letter\n   */\n\n\n  var nameSpacer = '\\r\\n\\t>/= ';\n\n  function parseName() {\n    var start = pos;\n\n    while (nameSpacer.indexOf(S[pos]) === -1 && S[pos]) {\n      pos++;\n    }\n\n    return S.slice(start, pos);\n  }\n  /**\n   *    is parsing a node, including tagName, Attributes and its children,\n   * to parse children it uses the parseChildren again, that makes the parsing recursive\n   */\n\n\n  var NoChildNodes = options.noChildNodes || ['img', 'br', 'input', 'meta', 'link', 'hr'];\n\n  function parseNode() {\n    pos++;\n    const tagName = parseName();\n    const attributes = {};\n    let children = []; // parsing attributes\n\n    while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n      var c = S.charCodeAt(pos);\n\n      if (c > 64 && c < 91 || c > 96 && c < 123) {\n        //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){\n        var name = parseName(); // search beginning of the string\n\n        var code = S.charCodeAt(pos);\n\n        while (code && code !== singleQuoteCC && code !== doubleQuoteCC && !(code > 64 && code < 91 || code > 96 && code < 123) && code !== closeBracketCC) {\n          pos++;\n          code = S.charCodeAt(pos);\n        }\n\n        if (code === singleQuoteCC || code === doubleQuoteCC) {\n          var value = parseString();\n\n          if (pos === -1) {\n            return {\n              tagName,\n              attributes,\n              children\n            };\n          }\n        } else {\n          value = null;\n          pos--;\n        }\n\n        attributes[name] = value;\n      }\n\n      pos++;\n    } // optional parsing of children\n\n\n    if (S.charCodeAt(pos - 1) !== slashCC) {\n      if (tagName == \"script\") {\n        var start = pos + 1;\n        pos = S.indexOf('</script>', pos);\n        children = [S.slice(start, pos)];\n        pos += 9;\n      } else if (tagName == \"style\") {\n        var start = pos + 1;\n        pos = S.indexOf('</style>', pos);\n        children = [S.slice(start, pos)];\n        pos += 8;\n      } else if (NoChildNodes.indexOf(tagName) === -1) {\n        pos++;\n        children = parseChildren(tagName);\n      } else {\n        pos++;\n      }\n    } else {\n      pos++;\n    }\n\n    return {\n      tagName,\n      attributes,\n      children\n    };\n  }\n  /**\n   *    is parsing a string, that starts with a char and with the same usually  ' or \"\n   */\n\n\n  function parseString() {\n    var startChar = S[pos];\n    var startpos = pos + 1;\n    pos = S.indexOf(startChar, startpos);\n    return S.slice(startpos, pos);\n  }\n  /**\n   *\n   */\n\n\n  function findElements() {\n    var r = new RegExp('\\\\s' + options.attrName + '\\\\s*=[\\'\"]' + options.attrValue + '[\\'\"]').exec(S);\n\n    if (r) {\n      return r.index;\n    } else {\n      return -1;\n    }\n  }\n\n  var out = null;\n\n  if (options.attrValue !== undefined) {\n    options.attrName = options.attrName || 'id';\n    var out = [];\n\n    while ((pos = findElements()) !== -1) {\n      pos = S.lastIndexOf('<', pos);\n\n      if (pos !== -1) {\n        out.push(parseNode());\n      }\n\n      S = S.substr(pos);\n      pos = 0;\n    }\n  } else if (options.parseNode) {\n    out = parseNode();\n  } else {\n    out = parseChildren('');\n  }\n\n  if (options.filter) {\n    out = filter(out, options.filter);\n  }\n\n  if (options.simplify) {\n    return simplify(Array.isArray(out) ? out : [out]);\n  }\n\n  if (options.setPos) {\n    out.pos = pos;\n  }\n\n  return out;\n}\n/**\n * transform the DomObject to an object that is like the object of PHP`s simple_xmp_load_*() methods.\n * this format helps you to write that is more likely to keep your program working, even if there a small changes in the XML schema.\n * be aware, that it is not possible to reproduce the original xml from a simplified version, because the order of elements is not saved.\n * therefore your program will be more flexible and easier to read.\n *\n * @param {tNode[]} children the childrenList\n */\n\n\nfunction simplify(children) {\n  var out = {};\n\n  if (!children.length) {\n    return '';\n  }\n\n  if (children.length === 1 && typeof children[0] == 'string') {\n    return children[0];\n  } // map each object\n\n\n  children.forEach(function (child) {\n    if (typeof child !== 'object') {\n      return;\n    }\n\n    if (!out[child.tagName]) out[child.tagName] = [];\n    var kids = simplify(child.children);\n    out[child.tagName].push(kids);\n\n    if (Object.keys(child.attributes).length && typeof kids !== 'string') {\n      kids._attributes = child.attributes;\n    }\n  });\n\n  for (var i in out) {\n    if (out[i].length == 1) {\n      out[i] = out[i][0];\n    }\n  }\n\n  return out;\n}\n/**\n * similar to simplify, but lost less\n *\n * @param {tNode[]} children the childrenList\n */\n\n\nfunction simplifyLostLess(children, parentAttributes = {}) {\n  var out = {};\n\n  if (!children.length) {\n    return out;\n  }\n\n  if (children.length === 1 && typeof children[0] == 'string') {\n    return Object.keys(parentAttributes).length ? {\n      _attributes: parentAttributes,\n      value: children[0]\n    } : children[0];\n  } // map each object\n\n\n  children.forEach(function (child) {\n    if (typeof child !== 'object') {\n      return;\n    }\n\n    if (!out[child.tagName]) out[child.tagName] = [];\n    var kids = simplifyLostLess(child.children || [], child.attributes);\n    out[child.tagName].push(kids);\n\n    if (Object.keys(child.attributes).length) {\n      kids._attributes = child.attributes;\n    }\n  });\n  return out;\n}\n/**\n * behaves the same way as Array.filter, if the filter method return true, the element is in the resultList\n * @params children{Array} the children of a node\n * @param f{function} the filter method\n */\n\n\nfunction filter(children, f, dept = 0, path = '') {\n  var out = [];\n  children.forEach(function (child, i) {\n    if (typeof child === 'object' && f(child, i, dept, path)) out.push(child);\n\n    if (child.children) {\n      var kids = filter(child.children, f, dept + 1, (path ? path + '.' : '') + i + '.' + child.tagName);\n      out = out.concat(kids);\n    }\n  });\n  return out;\n}\n/**\n * stringify a previously parsed string object.\n * this is useful,\n *  1. to remove whitespace\n * 2. to recreate xml data, with some changed data.\n * @param {tNode} O the object to Stringify\n */\n\n\nfunction stringify(O) {\n  var out = '';\n\n  function writeChildren(O) {\n    if (O) {\n      for (var i = 0; i < O.length; i++) {\n        if (typeof O[i] == 'string') {\n          out += O[i].trim();\n        } else {\n          writeNode(O[i]);\n        }\n      }\n    }\n  }\n\n  function writeNode(N) {\n    out += \"<\" + N.tagName;\n\n    for (var i in N.attributes) {\n      if (N.attributes[i] === null) {\n        out += ' ' + i;\n      } else if (N.attributes[i].indexOf('\"') === -1) {\n        out += ' ' + i + '=\"' + N.attributes[i].trim() + '\"';\n      } else {\n        out += ' ' + i + \"='\" + N.attributes[i].trim() + \"'\";\n      }\n    }\n\n    if (N.tagName[0] === '?') {\n      out += '?>';\n      return;\n    }\n\n    out += '>';\n    writeChildren(N.children);\n    out += '</' + N.tagName + '>';\n  }\n\n  writeChildren(O);\n  return out;\n}\n/**\n * use this method to read the text content, of some node.\n * It is great if you have mixed content like:\n * this text has some <b>big</b> text and a <a href=''>link</a>\n * @return {string}\n */\n\n\nfunction toContentString(tDom) {\n  if (Array.isArray(tDom)) {\n    var out = '';\n    tDom.forEach(function (e) {\n      out += ' ' + toContentString(e);\n      out = out.trim();\n    });\n    return out;\n  } else if (typeof tDom === 'object') {\n    return toContentString(tDom.children);\n  } else {\n    return ' ' + tDom;\n  }\n}\n\nfunction getElementById(S, id, simplified) {\n  var out = parse(S, {\n    attrValue: id\n  });\n  return simplified ? tXml.simplify(out) : out[0];\n}\n\nfunction getElementsByClassName(S, classname, simplified) {\n  const out = parse(S, {\n    attrName: 'class',\n    attrValue: '[a-zA-Z0-9- ]*' + classname + '[a-zA-Z0-9- ]*'\n  });\n  return simplified ? tXml.simplify(out) : out;\n}\n\nexport { filter, getElementById, getElementsByClassName, parse, simplify, simplifyLostLess, stringify, toContentString };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/txml/dist/txml.mjs"],"names":["parse","S","options","pos","keepComments","keepWhitespace","openBracket","openBracketCC","charCodeAt","closeBracket","closeBracketCC","minusCC","slashCC","exclamationCC","singleQuoteCC","doubleQuoteCC","openCornerBracketCC","closeCornerBracketCC","parseChildren","tagName","children","closeStart","indexOf","closeTag","substring","parsedText","split","Error","length","startCommentPos","push","substr","toLowerCase","cdataEndIndex","startDoctype","encapsuled","node","parseNode","text","parseText","trimmed","trim","start","slice","nameSpacer","parseName","NoChildNodes","noChildNodes","attributes","c","name","code","value","parseString","startChar","startpos","findElements","r","RegExp","attrName","attrValue","exec","index","out","undefined","lastIndexOf","filter","simplify","Array","isArray","setPos","forEach","child","kids","Object","keys","_attributes","i","simplifyLostLess","parentAttributes","f","dept","path","concat","stringify","O","writeChildren","writeNode","N","toContentString","tDom","e","getElementById","id","simplified","tXml","getElementsByClassName","classname"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;AAMA;;;;;;;AAOA;;;;;;;;;;;AAWA;;;;;;AAMA,SAASA,KAAT,CAAeC,CAAf,EAAkBC,OAAlB,EAA2B;AACvB;;AACAA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,MAAIC,GAAG,GAAGD,OAAO,CAACC,GAAR,IAAe,CAAzB;AACA,MAAIC,YAAY,GAAG,CAAC,CAACF,OAAO,CAACE,YAA7B;AACA,MAAIC,cAAc,GAAG,CAAC,CAACH,OAAO,CAACG,cAA/B;AAEA,MAAIC,WAAW,GAAG,GAAlB;AACA,MAAIC,aAAa,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAApB;AACA,MAAIC,YAAY,GAAG,GAAnB;AACA,MAAIC,cAAc,GAAG,IAAIF,UAAJ,CAAe,CAAf,CAArB;AACA,MAAIG,OAAO,GAAG,IAAIH,UAAJ,CAAe,CAAf,CAAd;AACA,MAAII,OAAO,GAAG,IAAIJ,UAAJ,CAAe,CAAf,CAAd;AACA,MAAIK,aAAa,GAAG,IAAIL,UAAJ,CAAe,CAAf,CAApB;AACA,MAAIM,aAAa,GAAG,IAAIN,UAAJ,CAAe,CAAf,CAApB;AACA,MAAIO,aAAa,GAAG,IAAIP,UAAJ,CAAe,CAAf,CAApB;AACA,MAAIQ,mBAAmB,GAAG,IAAIR,UAAJ,CAAe,CAAf,CAA1B;AACA,MAAIS,oBAAoB,GAAG,IAAIT,UAAJ,CAAe,CAAf,CAA3B;AAGA;;;;AAGA,WAASU,aAAT,CAAuBC,OAAvB,EAAgC;AAC5B,QAAIC,QAAQ,GAAG,EAAf;;AACA,WAAOnB,CAAC,CAACE,GAAD,CAAR,EAAe;AACX,UAAIF,CAAC,CAACO,UAAF,CAAaL,GAAb,KAAqBI,aAAzB,EAAwC;AACpC,YAAIN,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,MAA0BS,OAA9B,EAAuC;AACnC,cAAIS,UAAU,GAAGlB,GAAG,GAAG,CAAvB;AACAA,UAAAA,GAAG,GAAGF,CAAC,CAACqB,OAAF,CAAUb,YAAV,EAAwBN,GAAxB,CAAN;AAEA,cAAIoB,QAAQ,GAAGtB,CAAC,CAACuB,SAAF,CAAYH,UAAZ,EAAwBlB,GAAxB,CAAf;;AACA,cAAIoB,QAAQ,CAACD,OAAT,CAAiBH,OAAjB,KAA6B,CAAC,CAAlC,EAAqC;AACjC,gBAAIM,UAAU,GAAGxB,CAAC,CAACuB,SAAF,CAAY,CAAZ,EAAerB,GAAf,EAAoBuB,KAApB,CAA0B,IAA1B,CAAjB;AACA,kBAAM,IAAIC,KAAJ,CACF,kCAAkCF,UAAU,CAACG,MAAX,GAAoB,CAAtD,IACA,YADA,IACgBH,UAAU,CAACA,UAAU,CAACG,MAAX,GAAoB,CAArB,CAAV,CAAkCA,MAAlC,GAA2C,CAD3D,IAEA,UAFA,GAEa3B,CAAC,CAACE,GAAD,CAHZ,CAAN;AAKH;;AAED,cAAIA,GAAG,GAAG,CAAV,EAAaA,GAAG,IAAI,CAAP;AAEb,iBAAOiB,QAAP;AACH,SAjBD,MAiBO,IAAInB,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,MAA0BU,aAA9B,EAA6C;AAChD,cAAIZ,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,KAAyBQ,OAA7B,EAAsC;AAClC;AACA,kBAAMkB,eAAe,GAAG1B,GAAxB;;AACA,mBAAOA,GAAG,KAAK,CAAC,CAAT,IAAc,EAAEF,CAAC,CAACO,UAAF,CAAaL,GAAb,MAAsBO,cAAtB,IAAwCT,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,KAAyBQ,OAAjE,IAA4EV,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,KAAyBQ,OAArG,IAAgHR,GAAG,IAAI,CAAC,CAA1H,CAArB,EAAmJ;AAC/IA,cAAAA,GAAG,GAAGF,CAAC,CAACqB,OAAF,CAAUb,YAAV,EAAwBN,GAAG,GAAG,CAA9B,CAAN;AACH;;AACD,gBAAIA,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZA,cAAAA,GAAG,GAAGF,CAAC,CAAC2B,MAAR;AACH;;AACD,gBAAIxB,YAAJ,EAAkB;AACdgB,cAAAA,QAAQ,CAACU,IAAT,CAAc7B,CAAC,CAACuB,SAAF,CAAYK,eAAZ,EAA6B1B,GAAG,GAAG,CAAnC,CAAd;AACH;AACJ,WAZD,MAYO,IACHF,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,MAA0Ba,mBAA1B,IACAf,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,MAA0Ba,mBAD1B,IAEAf,CAAC,CAAC8B,MAAF,CAAS5B,GAAG,GAAG,CAAf,EAAkB,CAAlB,EAAqB6B,WAArB,OAAuC,OAHpC,EAIL;AACE;AACA,gBAAIC,aAAa,GAAGhC,CAAC,CAACqB,OAAF,CAAU,KAAV,EAAiBnB,GAAjB,CAApB;;AACA,gBAAI8B,aAAa,IAAI,CAAC,CAAtB,EAAyB;AACrBb,cAAAA,QAAQ,CAACU,IAAT,CAAc7B,CAAC,CAAC8B,MAAF,CAAS5B,GAAG,GAAG,CAAf,CAAd;AACAA,cAAAA,GAAG,GAAGF,CAAC,CAAC2B,MAAR;AACH,aAHD,MAGO;AACHR,cAAAA,QAAQ,CAACU,IAAT,CAAc7B,CAAC,CAACuB,SAAF,CAAYrB,GAAG,GAAG,CAAlB,EAAqB8B,aAArB,CAAd;AACA9B,cAAAA,GAAG,GAAG8B,aAAa,GAAG,CAAtB;AACH;;AACD;AACH,WAfM,MAeA;AACH;AACA,kBAAMC,YAAY,GAAG/B,GAAG,GAAG,CAA3B;AACAA,YAAAA,GAAG,IAAI,CAAP;AACA,gBAAIgC,UAAU,GAAG,KAAjB;;AACA,mBAAO,CAAClC,CAAC,CAACO,UAAF,CAAaL,GAAb,MAAsBO,cAAtB,IAAwCyB,UAAU,KAAK,IAAxD,KAAiElC,CAAC,CAACE,GAAD,CAAzE,EAAgF;AAC5E,kBAAIF,CAAC,CAACO,UAAF,CAAaL,GAAb,MAAsBa,mBAA1B,EAA+C;AAC3CmB,gBAAAA,UAAU,GAAG,IAAb;AACH,eAFD,MAEO,IAAIA,UAAU,KAAK,IAAf,IAAuBlC,CAAC,CAACO,UAAF,CAAaL,GAAb,MAAsBc,oBAAjD,EAAuE;AAC1EkB,gBAAAA,UAAU,GAAG,KAAb;AACH;;AACDhC,cAAAA,GAAG;AACN;;AACDiB,YAAAA,QAAQ,CAACU,IAAT,CAAc7B,CAAC,CAACuB,SAAF,CAAYU,YAAZ,EAA0B/B,GAA1B,CAAd;AACH;;AACDA,UAAAA,GAAG;AACH;AACH;;AACD,YAAIiC,IAAI,GAAGC,SAAS,EAApB;AACAjB,QAAAA,QAAQ,CAACU,IAAT,CAAcM,IAAd;;AACA,YAAIA,IAAI,CAACjB,OAAL,CAAa,CAAb,MAAoB,GAAxB,EAA6B;AACzBC,UAAAA,QAAQ,CAACU,IAAT,CAAc,GAAGM,IAAI,CAAChB,QAAtB;AACAgB,UAAAA,IAAI,CAAChB,QAAL,GAAgB,EAAhB;AACH;AACJ,OAtED,MAsEO;AACH,YAAIkB,IAAI,GAAGC,SAAS,EAApB;;AACA,YAAIlC,cAAJ,EAAoB;AAChB,cAAIiC,IAAI,CAACV,MAAL,GAAc,CAAlB,EAAqB;AACjBR,YAAAA,QAAQ,CAACU,IAAT,CAAcQ,IAAd;AACH;AACJ,SAJD,MAIO;AACH,cAAIE,OAAO,GAAGF,IAAI,CAACG,IAAL,EAAd;;AACA,cAAID,OAAO,CAACZ,MAAR,GAAiB,CAArB,EAAwB;AACpBR,YAAAA,QAAQ,CAACU,IAAT,CAAcU,OAAd;AACH;AACJ;;AACDrC,QAAAA,GAAG;AACN;AACJ;;AACD,WAAOiB,QAAP;AACH;AAED;;;;;AAGA,WAASmB,SAAT,GAAqB;AACjB,QAAIG,KAAK,GAAGvC,GAAZ;AACAA,IAAAA,GAAG,GAAGF,CAAC,CAACqB,OAAF,CAAUhB,WAAV,EAAuBH,GAAvB,IAA8B,CAApC;AACA,QAAIA,GAAG,KAAK,CAAC,CAAb,EACIA,GAAG,GAAGF,CAAC,CAAC2B,MAAR;AACJ,WAAO3B,CAAC,CAAC0C,KAAF,CAAQD,KAAR,EAAevC,GAAG,GAAG,CAArB,CAAP;AACH;AACD;;;;;AAGA,MAAIyC,UAAU,GAAG,YAAjB;;AAEA,WAASC,SAAT,GAAqB;AACjB,QAAIH,KAAK,GAAGvC,GAAZ;;AACA,WAAOyC,UAAU,CAACtB,OAAX,CAAmBrB,CAAC,CAACE,GAAD,CAApB,MAA+B,CAAC,CAAhC,IAAqCF,CAAC,CAACE,GAAD,CAA7C,EAAoD;AAChDA,MAAAA,GAAG;AACN;;AACD,WAAOF,CAAC,CAAC0C,KAAF,CAAQD,KAAR,EAAevC,GAAf,CAAP;AACH;AACD;;;;;;AAIA,MAAI2C,YAAY,GAAG5C,OAAO,CAAC6C,YAAR,IAAwB,CAAC,KAAD,EAAQ,IAAR,EAAc,OAAd,EAAuB,MAAvB,EAA+B,MAA/B,EAAuC,IAAvC,CAA3C;;AAEA,WAASV,SAAT,GAAqB;AACjBlC,IAAAA,GAAG;AACH,UAAMgB,OAAO,GAAG0B,SAAS,EAAzB;AACA,UAAMG,UAAU,GAAG,EAAnB;AACA,QAAI5B,QAAQ,GAAG,EAAf,CAJiB,CAMjB;;AACA,WAAOnB,CAAC,CAACO,UAAF,CAAaL,GAAb,MAAsBO,cAAtB,IAAwCT,CAAC,CAACE,GAAD,CAAhD,EAAuD;AACnD,UAAI8C,CAAC,GAAGhD,CAAC,CAACO,UAAF,CAAaL,GAAb,CAAR;;AACA,UAAK8C,CAAC,GAAG,EAAJ,IAAUA,CAAC,GAAG,EAAf,IAAuBA,CAAC,GAAG,EAAJ,IAAUA,CAAC,GAAG,GAAzC,EAA+C;AAC3C;AACA,YAAIC,IAAI,GAAGL,SAAS,EAApB,CAF2C,CAG3C;;AACA,YAAIM,IAAI,GAAGlD,CAAC,CAACO,UAAF,CAAaL,GAAb,CAAX;;AACA,eAAOgD,IAAI,IAAIA,IAAI,KAAKrC,aAAjB,IAAkCqC,IAAI,KAAKpC,aAA3C,IAA4D,EAAGoC,IAAI,GAAG,EAAP,IAAaA,IAAI,GAAG,EAArB,IAA6BA,IAAI,GAAG,EAAP,IAAaA,IAAI,GAAG,GAAnD,CAA5D,IAAwHA,IAAI,KAAKzC,cAAxI,EAAwJ;AACpJP,UAAAA,GAAG;AACHgD,UAAAA,IAAI,GAAGlD,CAAC,CAACO,UAAF,CAAaL,GAAb,CAAP;AACH;;AACD,YAAIgD,IAAI,KAAKrC,aAAT,IAA0BqC,IAAI,KAAKpC,aAAvC,EAAsD;AAClD,cAAIqC,KAAK,GAAGC,WAAW,EAAvB;;AACA,cAAIlD,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZ,mBAAO;AACHgB,cAAAA,OADG;AAEH6B,cAAAA,UAFG;AAGH5B,cAAAA;AAHG,aAAP;AAKH;AACJ,SATD,MASO;AACHgC,UAAAA,KAAK,GAAG,IAAR;AACAjD,UAAAA,GAAG;AACN;;AACD6C,QAAAA,UAAU,CAACE,IAAD,CAAV,GAAmBE,KAAnB;AACH;;AACDjD,MAAAA,GAAG;AACN,KAlCgB,CAmCjB;;;AACA,QAAIF,CAAC,CAACO,UAAF,CAAaL,GAAG,GAAG,CAAnB,MAA0BS,OAA9B,EAAuC;AACnC,UAAIO,OAAO,IAAI,QAAf,EAAyB;AACrB,YAAIuB,KAAK,GAAGvC,GAAG,GAAG,CAAlB;AACAA,QAAAA,GAAG,GAAGF,CAAC,CAACqB,OAAF,CAAU,WAAV,EAAuBnB,GAAvB,CAAN;AACAiB,QAAAA,QAAQ,GAAG,CAACnB,CAAC,CAAC0C,KAAF,CAAQD,KAAR,EAAevC,GAAf,CAAD,CAAX;AACAA,QAAAA,GAAG,IAAI,CAAP;AACH,OALD,MAKO,IAAIgB,OAAO,IAAI,OAAf,EAAwB;AAC3B,YAAIuB,KAAK,GAAGvC,GAAG,GAAG,CAAlB;AACAA,QAAAA,GAAG,GAAGF,CAAC,CAACqB,OAAF,CAAU,UAAV,EAAsBnB,GAAtB,CAAN;AACAiB,QAAAA,QAAQ,GAAG,CAACnB,CAAC,CAAC0C,KAAF,CAAQD,KAAR,EAAevC,GAAf,CAAD,CAAX;AACAA,QAAAA,GAAG,IAAI,CAAP;AACH,OALM,MAKA,IAAI2C,YAAY,CAACxB,OAAb,CAAqBH,OAArB,MAAkC,CAAC,CAAvC,EAA0C;AAC7ChB,QAAAA,GAAG;AACHiB,QAAAA,QAAQ,GAAGF,aAAa,CAACC,OAAD,CAAxB;AACH,OAHM,MAGA;AACHhB,QAAAA,GAAG;AACN;AACJ,KAjBD,MAiBO;AACHA,MAAAA,GAAG;AACN;;AACD,WAAO;AACHgB,MAAAA,OADG;AAEH6B,MAAAA,UAFG;AAGH5B,MAAAA;AAHG,KAAP;AAKH;AAED;;;;;AAIA,WAASiC,WAAT,GAAuB;AACnB,QAAIC,SAAS,GAAGrD,CAAC,CAACE,GAAD,CAAjB;AACA,QAAIoD,QAAQ,GAAGpD,GAAG,GAAG,CAArB;AACAA,IAAAA,GAAG,GAAGF,CAAC,CAACqB,OAAF,CAAUgC,SAAV,EAAqBC,QAArB,CAAN;AACA,WAAOtD,CAAC,CAAC0C,KAAF,CAAQY,QAAR,EAAkBpD,GAAlB,CAAP;AACH;AAED;;;;;AAGA,WAASqD,YAAT,GAAwB;AACpB,QAAIC,CAAC,GAAG,IAAIC,MAAJ,CAAW,QAAQxD,OAAO,CAACyD,QAAhB,GAA2B,YAA3B,GAA0CzD,OAAO,CAAC0D,SAAlD,GAA8D,OAAzE,EAAkFC,IAAlF,CAAuF5D,CAAvF,CAAR;;AACA,QAAIwD,CAAJ,EAAO;AACH,aAAOA,CAAC,CAACK,KAAT;AACH,KAFD,MAEO;AACH,aAAO,CAAC,CAAR;AACH;AACJ;;AAED,MAAIC,GAAG,GAAG,IAAV;;AACA,MAAI7D,OAAO,CAAC0D,SAAR,KAAsBI,SAA1B,EAAqC;AACjC9D,IAAAA,OAAO,CAACyD,QAAR,GAAmBzD,OAAO,CAACyD,QAAR,IAAoB,IAAvC;AACA,QAAII,GAAG,GAAG,EAAV;;AAEA,WAAO,CAAC5D,GAAG,GAAGqD,YAAY,EAAnB,MAA2B,CAAC,CAAnC,EAAsC;AAClCrD,MAAAA,GAAG,GAAGF,CAAC,CAACgE,WAAF,CAAc,GAAd,EAAmB9D,GAAnB,CAAN;;AACA,UAAIA,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZ4D,QAAAA,GAAG,CAACjC,IAAJ,CAASO,SAAS,EAAlB;AACH;;AACDpC,MAAAA,CAAC,GAAGA,CAAC,CAAC8B,MAAF,CAAS5B,GAAT,CAAJ;AACAA,MAAAA,GAAG,GAAG,CAAN;AACH;AACJ,GAZD,MAYO,IAAID,OAAO,CAACmC,SAAZ,EAAuB;AAC1B0B,IAAAA,GAAG,GAAG1B,SAAS,EAAf;AACH,GAFM,MAEA;AACH0B,IAAAA,GAAG,GAAG7C,aAAa,CAAC,EAAD,CAAnB;AACH;;AAED,MAAIhB,OAAO,CAACgE,MAAZ,EAAoB;AAChBH,IAAAA,GAAG,GAAGG,MAAM,CAACH,GAAD,EAAM7D,OAAO,CAACgE,MAAd,CAAZ;AACH;;AAED,MAAIhE,OAAO,CAACiE,QAAZ,EAAsB;AAClB,WAAOA,QAAQ,CAACC,KAAK,CAACC,OAAN,CAAcN,GAAd,IAAqBA,GAArB,GAA2B,CAACA,GAAD,CAA5B,CAAf;AACH;;AAED,MAAI7D,OAAO,CAACoE,MAAZ,EAAoB;AAChBP,IAAAA,GAAG,CAAC5D,GAAJ,GAAUA,GAAV;AACH;;AAED,SAAO4D,GAAP;AACH;AAED;;;;;;;;;;AAQA,SAASI,QAAT,CAAkB/C,QAAlB,EAA4B;AACxB,MAAI2C,GAAG,GAAG,EAAV;;AACA,MAAI,CAAC3C,QAAQ,CAACQ,MAAd,EAAsB;AAClB,WAAO,EAAP;AACH;;AAED,MAAIR,QAAQ,CAACQ,MAAT,KAAoB,CAApB,IAAyB,OAAOR,QAAQ,CAAC,CAAD,CAAf,IAAsB,QAAnD,EAA6D;AACzD,WAAOA,QAAQ,CAAC,CAAD,CAAf;AACH,GARuB,CASxB;;;AACAA,EAAAA,QAAQ,CAACmD,OAAT,CAAiB,UAASC,KAAT,EAAgB;AAC7B,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B;AACH;;AACD,QAAI,CAACT,GAAG,CAACS,KAAK,CAACrD,OAAP,CAAR,EACI4C,GAAG,CAACS,KAAK,CAACrD,OAAP,CAAH,GAAqB,EAArB;AACJ,QAAIsD,IAAI,GAAGN,QAAQ,CAACK,KAAK,CAACpD,QAAP,CAAnB;AACA2C,IAAAA,GAAG,CAACS,KAAK,CAACrD,OAAP,CAAH,CAAmBW,IAAnB,CAAwB2C,IAAxB;;AACA,QAAIC,MAAM,CAACC,IAAP,CAAYH,KAAK,CAACxB,UAAlB,EAA8BpB,MAA9B,IAAwC,OAAO6C,IAAP,KAAgB,QAA5D,EAAsE;AAClEA,MAAAA,IAAI,CAACG,WAAL,GAAmBJ,KAAK,CAACxB,UAAzB;AACH;AACJ,GAXD;;AAaA,OAAK,IAAI6B,CAAT,IAAcd,GAAd,EAAmB;AACf,QAAIA,GAAG,CAACc,CAAD,CAAH,CAAOjD,MAAP,IAAiB,CAArB,EAAwB;AACpBmC,MAAAA,GAAG,CAACc,CAAD,CAAH,GAASd,GAAG,CAACc,CAAD,CAAH,CAAO,CAAP,CAAT;AACH;AACJ;;AAED,SAAOd,GAAP;AACH;AAED;;;;;;;AAKA,SAASe,gBAAT,CAA0B1D,QAA1B,EAAoC2D,gBAAgB,GAAG,EAAvD,EAA2D;AACvD,MAAIhB,GAAG,GAAG,EAAV;;AACA,MAAI,CAAC3C,QAAQ,CAACQ,MAAd,EAAsB;AAClB,WAAOmC,GAAP;AACH;;AAED,MAAI3C,QAAQ,CAACQ,MAAT,KAAoB,CAApB,IAAyB,OAAOR,QAAQ,CAAC,CAAD,CAAf,IAAsB,QAAnD,EAA6D;AACzD,WAAOsD,MAAM,CAACC,IAAP,CAAYI,gBAAZ,EAA8BnD,MAA9B,GAAuC;AAC1CgD,MAAAA,WAAW,EAAEG,gBAD6B;AAE1C3B,MAAAA,KAAK,EAAEhC,QAAQ,CAAC,CAAD;AAF2B,KAAvC,GAGHA,QAAQ,CAAC,CAAD,CAHZ;AAIH,GAXsD,CAYvD;;;AACAA,EAAAA,QAAQ,CAACmD,OAAT,CAAiB,UAASC,KAAT,EAAgB;AAC7B,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B;AACH;;AACD,QAAI,CAACT,GAAG,CAACS,KAAK,CAACrD,OAAP,CAAR,EACI4C,GAAG,CAACS,KAAK,CAACrD,OAAP,CAAH,GAAqB,EAArB;AACJ,QAAIsD,IAAI,GAAGK,gBAAgB,CAACN,KAAK,CAACpD,QAAN,IAAkB,EAAnB,EAAuBoD,KAAK,CAACxB,UAA7B,CAA3B;AACAe,IAAAA,GAAG,CAACS,KAAK,CAACrD,OAAP,CAAH,CAAmBW,IAAnB,CAAwB2C,IAAxB;;AACA,QAAIC,MAAM,CAACC,IAAP,CAAYH,KAAK,CAACxB,UAAlB,EAA8BpB,MAAlC,EAA0C;AACtC6C,MAAAA,IAAI,CAACG,WAAL,GAAmBJ,KAAK,CAACxB,UAAzB;AACH;AACJ,GAXD;AAaA,SAAOe,GAAP;AACH;AACD;;;;;;;AAKA,SAASG,MAAT,CAAgB9C,QAAhB,EAA0B4D,CAA1B,EAA6BC,IAAI,GAAG,CAApC,EAAuCC,IAAI,GAAG,EAA9C,EAAkD;AAC9C,MAAInB,GAAG,GAAG,EAAV;AACA3C,EAAAA,QAAQ,CAACmD,OAAT,CAAiB,UAASC,KAAT,EAAgBK,CAAhB,EAAmB;AAChC,QAAI,OAAOL,KAAP,KAAkB,QAAlB,IAA8BQ,CAAC,CAACR,KAAD,EAAQK,CAAR,EAAWI,IAAX,EAAiBC,IAAjB,CAAnC,EAA2DnB,GAAG,CAACjC,IAAJ,CAAS0C,KAAT;;AAC3D,QAAIA,KAAK,CAACpD,QAAV,EAAoB;AAChB,UAAIqD,IAAI,GAAGP,MAAM,CAACM,KAAK,CAACpD,QAAP,EAAiB4D,CAAjB,EAAoBC,IAAI,GAAG,CAA3B,EAA8B,CAACC,IAAI,GAAGA,IAAI,GAAG,GAAV,GAAgB,EAArB,IAA2BL,CAA3B,GAA+B,GAA/B,GAAqCL,KAAK,CAACrD,OAAzE,CAAjB;AACA4C,MAAAA,GAAG,GAAGA,GAAG,CAACoB,MAAJ,CAAWV,IAAX,CAAN;AACH;AACJ,GAND;AAOA,SAAOV,GAAP;AACH;AACD;;;;;;;;;AAOA,SAASqB,SAAT,CAAmBC,CAAnB,EAAsB;AAClB,MAAItB,GAAG,GAAG,EAAV;;AAEA,WAASuB,aAAT,CAAuBD,CAAvB,EAA0B;AACtB,QAAIA,CAAJ,EAAO;AACH,WAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,CAAC,CAACzD,MAAtB,EAA8BiD,CAAC,EAA/B,EAAmC;AAC/B,YAAI,OAAOQ,CAAC,CAACR,CAAD,CAAR,IAAe,QAAnB,EAA6B;AACzBd,UAAAA,GAAG,IAAIsB,CAAC,CAACR,CAAD,CAAD,CAAKpC,IAAL,EAAP;AACH,SAFD,MAEO;AACH8C,UAAAA,SAAS,CAACF,CAAC,CAACR,CAAD,CAAF,CAAT;AACH;AACJ;AACJ;AACJ;;AAED,WAASU,SAAT,CAAmBC,CAAnB,EAAsB;AAClBzB,IAAAA,GAAG,IAAI,MAAMyB,CAAC,CAACrE,OAAf;;AACA,SAAK,IAAI0D,CAAT,IAAcW,CAAC,CAACxC,UAAhB,EAA4B;AACxB,UAAIwC,CAAC,CAACxC,UAAF,CAAa6B,CAAb,MAAoB,IAAxB,EAA8B;AAC1Bd,QAAAA,GAAG,IAAI,MAAMc,CAAb;AACH,OAFD,MAEO,IAAIW,CAAC,CAACxC,UAAF,CAAa6B,CAAb,EAAgBvD,OAAhB,CAAwB,GAAxB,MAAiC,CAAC,CAAtC,EAAyC;AAC5CyC,QAAAA,GAAG,IAAI,MAAMc,CAAN,GAAU,IAAV,GAAiBW,CAAC,CAACxC,UAAF,CAAa6B,CAAb,EAAgBpC,IAAhB,EAAjB,GAA0C,GAAjD;AACH,OAFM,MAEA;AACHsB,QAAAA,GAAG,IAAI,MAAMc,CAAN,GAAU,IAAV,GAAiBW,CAAC,CAACxC,UAAF,CAAa6B,CAAb,EAAgBpC,IAAhB,EAAjB,GAA0C,GAAjD;AACH;AACJ;;AACD,QAAI+C,CAAC,CAACrE,OAAF,CAAU,CAAV,MAAiB,GAArB,EAA0B;AACtB4C,MAAAA,GAAG,IAAI,IAAP;AACA;AACH;;AACDA,IAAAA,GAAG,IAAI,GAAP;AACAuB,IAAAA,aAAa,CAACE,CAAC,CAACpE,QAAH,CAAb;AACA2C,IAAAA,GAAG,IAAI,OAAOyB,CAAC,CAACrE,OAAT,GAAmB,GAA1B;AACH;;AACDmE,EAAAA,aAAa,CAACD,CAAD,CAAb;AAEA,SAAOtB,GAAP;AACH;AAED;;;;;;;;AAMA,SAAS0B,eAAT,CAAyBC,IAAzB,EAA+B;AAC3B,MAAItB,KAAK,CAACC,OAAN,CAAcqB,IAAd,CAAJ,EAAyB;AACrB,QAAI3B,GAAG,GAAG,EAAV;AACA2B,IAAAA,IAAI,CAACnB,OAAL,CAAa,UAASoB,CAAT,EAAY;AACrB5B,MAAAA,GAAG,IAAI,MAAM0B,eAAe,CAACE,CAAD,CAA5B;AACA5B,MAAAA,GAAG,GAAGA,GAAG,CAACtB,IAAJ,EAAN;AACH,KAHD;AAIA,WAAOsB,GAAP;AACH,GAPD,MAOO,IAAI,OAAO2B,IAAP,KAAgB,QAApB,EAA8B;AACjC,WAAOD,eAAe,CAACC,IAAI,CAACtE,QAAN,CAAtB;AACH,GAFM,MAEA;AACH,WAAO,MAAMsE,IAAb;AACH;AACJ;;AACD,SAASE,cAAT,CAAwB3F,CAAxB,EAA2B4F,EAA3B,EAA+BC,UAA/B,EAA2C;AACvC,MAAI/B,GAAG,GAAG/D,KAAK,CAACC,CAAD,EAAI;AACf2D,IAAAA,SAAS,EAAEiC;AADI,GAAJ,CAAf;AAGA,SAAOC,UAAU,GAAGC,IAAI,CAAC5B,QAAL,CAAcJ,GAAd,CAAH,GAAwBA,GAAG,CAAC,CAAD,CAA5C;AACH;;AACD,SAASiC,sBAAT,CAAgC/F,CAAhC,EAAmCgG,SAAnC,EAA8CH,UAA9C,EAA0D;AACtD,QAAM/B,GAAG,GAAG/D,KAAK,CAACC,CAAD,EAAI;AACjB0D,IAAAA,QAAQ,EAAE,OADO;AAEjBC,IAAAA,SAAS,EAAE,mBAAmBqC,SAAnB,GAA+B;AAFzB,GAAJ,CAAjB;AAIA,SAAOH,UAAU,GAAGC,IAAI,CAAC5B,QAAL,CAAcJ,GAAd,CAAH,GAAwBA,GAAzC;AACH;;AAED,SAASG,MAAT,EAAiB0B,cAAjB,EAAiCI,sBAAjC,EAAyDhG,KAAzD,EAAgEmE,QAAhE,EAA0EW,gBAA1E,EAA4FM,SAA5F,EAAuGK,eAAvG","sourcesContent":["// ==ClosureCompiler==\n// @output_file_name default.js\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// ==/ClosureCompiler==\n// module.exports = {\n//     parse: parse,\n//     simplify: simplify,\n//     simplifyLostLess: simplifyLostLess,\n//     filter: filter,\n//     stringify: stringify,\n//     toContentString: toContentString,\n//     getElementById: getElementById,\n//     getElementsByClassName: getElementsByClassName,\n//     transformStream: transformStream,\n// };\n\n/**\n * @author: Tobias Nickel\n * @created: 06.04.2015\n * I needed a small xmlparser chat can be used in a worker.\n */\n\n/**\n * @typedef tNode \n * @property {string} tagName \n * @property {object} attributes\n * @property {(tNode|string)[]} children \n **/\n\n/**\n * @typedef TParseOptions\n * @property {number} [pos]\n * @property {string[]} [noChildNodes]\n * @property {boolean} [setPos]\n * @property {boolean} [keepComments] \n * @property {boolean} [keepWhitespace]\n * @property {boolean} [simplify]\n * @property {(a: tNode, b: tNode) => boolean} [filter]\n */\n\n/**\n * parseXML / html into a DOM Object. with no validation and some failur tolerance\n * @param {string} S your XML to parse\n * @param {TParseOptions} [options]  all other options:\n * @return {(tNode | string)[]}\n */\nfunction parse(S, options) {\n    \"txml\";\n    options = options || {};\n\n    var pos = options.pos || 0;\n    var keepComments = !!options.keepComments;\n    var keepWhitespace = !!options.keepWhitespace;\n\n    var openBracket = \"<\";\n    var openBracketCC = \"<\".charCodeAt(0);\n    var closeBracket = \">\";\n    var closeBracketCC = \">\".charCodeAt(0);\n    var minusCC = \"-\".charCodeAt(0);\n    var slashCC = \"/\".charCodeAt(0);\n    var exclamationCC = '!'.charCodeAt(0);\n    var singleQuoteCC = \"'\".charCodeAt(0);\n    var doubleQuoteCC = '\"'.charCodeAt(0);\n    var openCornerBracketCC = '['.charCodeAt(0);\n    var closeCornerBracketCC = ']'.charCodeAt(0);\n\n\n    /**\n     * parsing a list of entries\n     */\n    function parseChildren(tagName) {\n        var children = [];\n        while (S[pos]) {\n            if (S.charCodeAt(pos) == openBracketCC) {\n                if (S.charCodeAt(pos + 1) === slashCC) {\n                    var closeStart = pos + 2;\n                    pos = S.indexOf(closeBracket, pos);\n\n                    var closeTag = S.substring(closeStart, pos);\n                    if (closeTag.indexOf(tagName) == -1) {\n                        var parsedText = S.substring(0, pos).split('\\n');\n                        throw new Error(\n                            'Unexpected close tag\\nLine: ' + (parsedText.length - 1) +\n                            '\\nColumn: ' + (parsedText[parsedText.length - 1].length + 1) +\n                            '\\nChar: ' + S[pos]\n                        );\n                    }\n\n                    if (pos + 1) pos += 1;\n\n                    return children;\n                } else if (S.charCodeAt(pos + 1) === exclamationCC) {\n                    if (S.charCodeAt(pos + 2) == minusCC) {\n                        //comment support\n                        const startCommentPos = pos;\n                        while (pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1)) {\n                            pos = S.indexOf(closeBracket, pos + 1);\n                        }\n                        if (pos === -1) {\n                            pos = S.length;\n                        }\n                        if (keepComments) {\n                            children.push(S.substring(startCommentPos, pos + 1));\n                        }\n                    } else if (\n                        S.charCodeAt(pos + 2) === openCornerBracketCC &&\n                        S.charCodeAt(pos + 8) === openCornerBracketCC &&\n                        S.substr(pos + 3, 5).toLowerCase() === 'cdata'\n                    ) {\n                        // cdata\n                        var cdataEndIndex = S.indexOf(']]>', pos);\n                        if (cdataEndIndex == -1) {\n                            children.push(S.substr(pos + 9));\n                            pos = S.length;\n                        } else {\n                            children.push(S.substring(pos + 9, cdataEndIndex));\n                            pos = cdataEndIndex + 3;\n                        }\n                        continue;\n                    } else {\n                        // doctypesupport\n                        const startDoctype = pos + 1;\n                        pos += 2;\n                        var encapsuled = false;\n                        while ((S.charCodeAt(pos) !== closeBracketCC || encapsuled === true) && S[pos]) {\n                            if (S.charCodeAt(pos) === openCornerBracketCC) {\n                                encapsuled = true;\n                            } else if (encapsuled === true && S.charCodeAt(pos) === closeCornerBracketCC) {\n                                encapsuled = false;\n                            }\n                            pos++;\n                        }\n                        children.push(S.substring(startDoctype, pos));\n                    }\n                    pos++;\n                    continue;\n                }\n                var node = parseNode();\n                children.push(node);\n                if (node.tagName[0] === '?') {\n                    children.push(...node.children);\n                    node.children = [];\n                }\n            } else {\n                var text = parseText();\n                if (keepWhitespace) {\n                    if (text.length > 0) {\n                        children.push(text);\n                    }\n                } else {\n                    var trimmed = text.trim();\n                    if (trimmed.length > 0) {\n                        children.push(trimmed);\n                    }\n                }\n                pos++;\n            }\n        }\n        return children;\n    }\n\n    /**\n     *    returns the text outside of texts until the first '<'\n     */\n    function parseText() {\n        var start = pos;\n        pos = S.indexOf(openBracket, pos) - 1;\n        if (pos === -2)\n            pos = S.length;\n        return S.slice(start, pos + 1);\n    }\n    /**\n     *    returns text until the first nonAlphabetic letter\n     */\n    var nameSpacer = '\\r\\n\\t>/= ';\n\n    function parseName() {\n        var start = pos;\n        while (nameSpacer.indexOf(S[pos]) === -1 && S[pos]) {\n            pos++;\n        }\n        return S.slice(start, pos);\n    }\n    /**\n     *    is parsing a node, including tagName, Attributes and its children,\n     * to parse children it uses the parseChildren again, that makes the parsing recursive\n     */\n    var NoChildNodes = options.noChildNodes || ['img', 'br', 'input', 'meta', 'link', 'hr'];\n\n    function parseNode() {\n        pos++;\n        const tagName = parseName();\n        const attributes = {};\n        let children = [];\n\n        // parsing attributes\n        while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n            var c = S.charCodeAt(pos);\n            if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n                //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){\n                var name = parseName();\n                // search beginning of the string\n                var code = S.charCodeAt(pos);\n                while (code && code !== singleQuoteCC && code !== doubleQuoteCC && !((code > 64 && code < 91) || (code > 96 && code < 123)) && code !== closeBracketCC) {\n                    pos++;\n                    code = S.charCodeAt(pos);\n                }\n                if (code === singleQuoteCC || code === doubleQuoteCC) {\n                    var value = parseString();\n                    if (pos === -1) {\n                        return {\n                            tagName,\n                            attributes,\n                            children,\n                        };\n                    }\n                } else {\n                    value = null;\n                    pos--;\n                }\n                attributes[name] = value;\n            }\n            pos++;\n        }\n        // optional parsing of children\n        if (S.charCodeAt(pos - 1) !== slashCC) {\n            if (tagName == \"script\") {\n                var start = pos + 1;\n                pos = S.indexOf('</script>', pos);\n                children = [S.slice(start, pos)];\n                pos += 9;\n            } else if (tagName == \"style\") {\n                var start = pos + 1;\n                pos = S.indexOf('</style>', pos);\n                children = [S.slice(start, pos)];\n                pos += 8;\n            } else if (NoChildNodes.indexOf(tagName) === -1) {\n                pos++;\n                children = parseChildren(tagName);\n            } else {\n                pos++;\n            }\n        } else {\n            pos++;\n        }\n        return {\n            tagName,\n            attributes,\n            children,\n        };\n    }\n\n    /**\n     *    is parsing a string, that starts with a char and with the same usually  ' or \"\n     */\n\n    function parseString() {\n        var startChar = S[pos];\n        var startpos = pos + 1;\n        pos = S.indexOf(startChar, startpos);\n        return S.slice(startpos, pos);\n    }\n\n    /**\n     *\n     */\n    function findElements() {\n        var r = new RegExp('\\\\s' + options.attrName + '\\\\s*=[\\'\"]' + options.attrValue + '[\\'\"]').exec(S);\n        if (r) {\n            return r.index;\n        } else {\n            return -1;\n        }\n    }\n\n    var out = null;\n    if (options.attrValue !== undefined) {\n        options.attrName = options.attrName || 'id';\n        var out = [];\n\n        while ((pos = findElements()) !== -1) {\n            pos = S.lastIndexOf('<', pos);\n            if (pos !== -1) {\n                out.push(parseNode());\n            }\n            S = S.substr(pos);\n            pos = 0;\n        }\n    } else if (options.parseNode) {\n        out = parseNode();\n    } else {\n        out = parseChildren('');\n    }\n\n    if (options.filter) {\n        out = filter(out, options.filter);\n    }\n\n    if (options.simplify) {\n        return simplify(Array.isArray(out) ? out : [out]);\n    }\n\n    if (options.setPos) {\n        out.pos = pos;\n    }\n\n    return out;\n}\n\n/**\n * transform the DomObject to an object that is like the object of PHP`s simple_xmp_load_*() methods.\n * this format helps you to write that is more likely to keep your program working, even if there a small changes in the XML schema.\n * be aware, that it is not possible to reproduce the original xml from a simplified version, because the order of elements is not saved.\n * therefore your program will be more flexible and easier to read.\n *\n * @param {tNode[]} children the childrenList\n */\nfunction simplify(children) {\n    var out = {};\n    if (!children.length) {\n        return '';\n    }\n\n    if (children.length === 1 && typeof children[0] == 'string') {\n        return children[0];\n    }\n    // map each object\n    children.forEach(function(child) {\n        if (typeof child !== 'object') {\n            return;\n        }\n        if (!out[child.tagName])\n            out[child.tagName] = [];\n        var kids = simplify(child.children);\n        out[child.tagName].push(kids);\n        if (Object.keys(child.attributes).length && typeof kids !== 'string') {\n            kids._attributes = child.attributes;\n        }\n    });\n\n    for (var i in out) {\n        if (out[i].length == 1) {\n            out[i] = out[i][0];\n        }\n    }\n\n    return out;\n}\n\n/**\n * similar to simplify, but lost less\n *\n * @param {tNode[]} children the childrenList\n */\nfunction simplifyLostLess(children, parentAttributes = {}) {\n    var out = {};\n    if (!children.length) {\n        return out;\n    }\n\n    if (children.length === 1 && typeof children[0] == 'string') {\n        return Object.keys(parentAttributes).length ? {\n            _attributes: parentAttributes,\n            value: children[0]\n        } : children[0];\n    }\n    // map each object\n    children.forEach(function(child) {\n        if (typeof child !== 'object') {\n            return;\n        }\n        if (!out[child.tagName])\n            out[child.tagName] = [];\n        var kids = simplifyLostLess(child.children || [], child.attributes);\n        out[child.tagName].push(kids);\n        if (Object.keys(child.attributes).length) {\n            kids._attributes = child.attributes;\n        }\n    });\n\n    return out;\n}\n/**\n * behaves the same way as Array.filter, if the filter method return true, the element is in the resultList\n * @params children{Array} the children of a node\n * @param f{function} the filter method\n */\nfunction filter(children, f, dept = 0, path = '') {\n    var out = [];\n    children.forEach(function(child, i) {\n        if (typeof(child) === 'object' && f(child, i, dept, path)) out.push(child);\n        if (child.children) {\n            var kids = filter(child.children, f, dept + 1, (path ? path + '.' : '') + i + '.' + child.tagName);\n            out = out.concat(kids);\n        }\n    });\n    return out;\n}\n/**\n * stringify a previously parsed string object.\n * this is useful,\n *  1. to remove whitespace\n * 2. to recreate xml data, with some changed data.\n * @param {tNode} O the object to Stringify\n */\nfunction stringify(O) {\n    var out = '';\n\n    function writeChildren(O) {\n        if (O) {\n            for (var i = 0; i < O.length; i++) {\n                if (typeof O[i] == 'string') {\n                    out += O[i].trim();\n                } else {\n                    writeNode(O[i]);\n                }\n            }\n        }\n    }\n\n    function writeNode(N) {\n        out += \"<\" + N.tagName;\n        for (var i in N.attributes) {\n            if (N.attributes[i] === null) {\n                out += ' ' + i;\n            } else if (N.attributes[i].indexOf('\"') === -1) {\n                out += ' ' + i + '=\"' + N.attributes[i].trim() + '\"';\n            } else {\n                out += ' ' + i + \"='\" + N.attributes[i].trim() + \"'\";\n            }\n        }\n        if (N.tagName[0] === '?') {\n            out += '?>';\n            return;\n        }\n        out += '>';\n        writeChildren(N.children);\n        out += '</' + N.tagName + '>';\n    }\n    writeChildren(O);\n\n    return out;\n}\n\n/**\n * use this method to read the text content, of some node.\n * It is great if you have mixed content like:\n * this text has some <b>big</b> text and a <a href=''>link</a>\n * @return {string}\n */\nfunction toContentString(tDom) {\n    if (Array.isArray(tDom)) {\n        var out = '';\n        tDom.forEach(function(e) {\n            out += ' ' + toContentString(e);\n            out = out.trim();\n        });\n        return out;\n    } else if (typeof tDom === 'object') {\n        return toContentString(tDom.children)\n    } else {\n        return ' ' + tDom;\n    }\n}\nfunction getElementById(S, id, simplified) {\n    var out = parse(S, {\n        attrValue: id\n    });\n    return simplified ? tXml.simplify(out) : out[0];\n}\nfunction getElementsByClassName(S, classname, simplified) {\n    const out = parse(S, {\n        attrName: 'class',\n        attrValue: '[a-zA-Z0-9- ]*' + classname + '[a-zA-Z0-9- ]*'\n    });\n    return simplified ? tXml.simplify(out) : out;\n}\n\nexport { filter, getElementById, getElementsByClassName, parse, simplify, simplifyLostLess, stringify, toContentString };\n"]},"metadata":{},"sourceType":"module"}