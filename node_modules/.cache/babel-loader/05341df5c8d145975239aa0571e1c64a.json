{"ast":null,"code":"import _objectSpread from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";import _toConsumableArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import React,{useEffect,useState,useMemo}from'react';import isEqual from'lodash/isEqual';import packageJson from'../../../package.json';import{useCoordination,useLoaders,useSetWarning}from'../../app/state/hooks';import{COMPONENT_COORDINATION_TYPES}from'../../app/state/coordination';import SetsManager from'./SetsManager';import TitleInfo from'../TitleInfo';import{treeExportLevelZeroNode,treeExportSet,treeToExpectedCheckedLevel,nodeToLevelDescendantNamePaths,treeToIntersection,treeToUnion,treeToComplement,treeFindNodeByNamePath,treesConflict,nodeTransform,nodeAppendChild,nodePrependChild,nodeInsertChild,filterNode,treeInitialize,initializeCellSetColor}from'./cell-set-utils';import{isEqualOrPrefix,tryRenamePath,PATH_SEP}from'./utils';import{downloadForUser,handleExportJSON,handleExportTabular,tryUpgradeTreeToLatestSchema}from'./io';import{FILE_EXTENSION_JSON,FILE_EXTENSION_TABULAR,SETS_DATATYPE_CELL}from'./constants';import{useUrls,useReady}from'../hooks';import{setCellSelection,mergeCellSets,getNextNumberedNodeName}from'../utils';import{useCellsData,useCellSetsData}from'../data-hooks';var CELL_SETS_DATA_TYPES=['cells','cell-sets'];/**\n * A subscriber wrapper around the SetsManager component\n * for the 'cell' datatype.\n * @param {object} props\n * @param {string} props.theme The current theme name.\n * @param {object} props.coordinationScopes The mapping from coordination types to coordination\n * scopes.\n * @param {function} props.removeGridComponent The callback function to pass to TitleInfo,\n * to call when the component has been removed from the grid.\n * @param {string} props.title The component title.\n */export default function CellSetsManagerSubscriber(props){var coordinationScopes=props.coordinationScopes,removeGridComponent=props.removeGridComponent,theme=props.theme,_props$title=props.title,title=_props$title===void 0?'Cell Sets':_props$title;var loaders=useLoaders();var setWarning=useSetWarning();// Get \"props\" from the coordination space.\nvar _useCoordination=useCoordination(COMPONENT_COORDINATION_TYPES.cellSets,coordinationScopes),_useCoordination2=_slicedToArray(_useCoordination,2),_useCoordination2$=_useCoordination2[0],dataset=_useCoordination2$.dataset,cellSetSelection=_useCoordination2$.obsSetSelection,cellSetColor=_useCoordination2$.obsSetColor,additionalCellSets=_useCoordination2$.additionalObsSets,cellColorEncoding=_useCoordination2$.obsColorEncoding,_useCoordination2$2=_useCoordination2[1],setCellSetSelection=_useCoordination2$2.setObsSetSelection,setCellColorEncoding=_useCoordination2$2.setObsColorEncoding,setCellSetColor=_useCoordination2$2.setObsSetColor,setAdditionalCellSets=_useCoordination2$2.setAdditionalObsSets;var _useUrls=useUrls(),_useUrls2=_slicedToArray(_useUrls,3),urls=_useUrls2[0],addUrl=_useUrls2[1],resetUrls=_useUrls2[2];var _useReady=useReady(CELL_SETS_DATA_TYPES),_useReady2=_slicedToArray(_useReady,4),isReady=_useReady2[0],setItemIsReady=_useReady2[1],setItemIsNotReady=_useReady2[2],// eslint-disable-line no-unused-vars\nresetReadyItems=_useReady2[3];var _useState=useState([]),_useState2=_slicedToArray(_useState,2),cellSetExpansion=_useState2[0],setCellSetExpansion=_useState2[1];// Reset file URLs and loader progress when the dataset has changed.\nuseEffect(function(){resetUrls();resetReadyItems();setCellSetExpansion([]);// eslint-disable-next-line react-hooks/exhaustive-deps\n},[loaders,dataset]);// Get data from loaders using the data hooks.\nvar _useCellsData=useCellsData(loaders,dataset,setItemIsReady,addUrl,true),_useCellsData2=_slicedToArray(_useCellsData,1),cells=_useCellsData2[0];var _useCellSetsData=useCellSetsData(loaders,dataset,setItemIsReady,addUrl,false,{setObsSetSelection:setCellSetSelection,setObsSetColor:setCellSetColor},{obsSetSelection:cellSetSelection,obsSetColor:cellSetColor}),_useCellSetsData2=_slicedToArray(_useCellSetsData,1),cellSets=_useCellSetsData2[0];// Validate and upgrade the additionalCellSets.\nuseEffect(function(){if(additionalCellSets){var upgradedCellSets;try{upgradedCellSets=tryUpgradeTreeToLatestSchema(additionalCellSets,SETS_DATATYPE_CELL);}catch(e){setWarning(e.message);return;}setAdditionalCellSets(upgradedCellSets);}},[additionalCellSets,setAdditionalCellSets,setWarning]);// Get an array of all cell IDs to use for set complement operations.\nvar allCellIds=useMemo(function(){return cells?Object.keys(cells):[];},[cells]);// A helper function for updating the encoding for cell colors,\n// which may have previously been set to 'geneSelection'.\nfunction setCellSetColorEncoding(){setCellColorEncoding('cellSetSelection');}// Merged cell sets are only to be used for convenience when reading\n// (if writing: update either `cellSets` _or_ `additionalCellSets`).\nvar mergedCellSets=useMemo(function(){return mergeCellSets(cellSets,additionalCellSets);},[cellSets,additionalCellSets]);// Infer the state of the \"checked level\" radio button based on the selected cell sets.\nvar checkedLevel=useMemo(function(){if(cellSetSelection&&cellSetSelection.length>0&&mergedCellSets&&mergedCellSets.tree.length>0){return treeToExpectedCheckedLevel(mergedCellSets,cellSetSelection);}return null;},[cellSetSelection,mergedCellSets]);// Callback functions\n// The user wants to select all nodes at a particular hierarchy level.\nfunction onCheckLevel(levelZeroName,levelIndex){var lzn=mergedCellSets.tree.find(function(n){return n.name===levelZeroName;});if(lzn){var newCellSetSelection=nodeToLevelDescendantNamePaths(lzn,levelIndex,[],true);setCellSetSelection(newCellSetSelection);setCellSetColorEncoding();}}// The user wants to check or uncheck a cell set node.\nfunction onCheckNode(targetKey,checked){var targetPath=Array.isArray(targetKey)?targetKey:targetKey.split(PATH_SEP);if(!targetKey){return;}if(checked){setCellSetSelection([].concat(_toConsumableArray(cellSetSelection),[targetPath]));}else{setCellSetSelection(cellSetSelection.filter(function(d){return!isEqual(d,targetPath);}));}setCellSetColorEncoding();}// The user wants to expand or collapse a node in the tree.\nfunction onExpandNode(expandedKeys,targetKey,expanded){if(expanded){setCellSetExpansion(function(prev){return[].concat(_toConsumableArray(prev),[targetKey.split(PATH_SEP)]);});}else{setCellSetExpansion(function(prev){return prev.filter(function(d){return!isEqual(d,targetKey.split(PATH_SEP));});});}}// The user dragged a tree node and dropped it somewhere else in the tree\n// to re-arrange or re-order the nodes.\n// We need to verify that their drop target is valid, and if so, complete\n// the tree re-arrangement.\nfunction onDropNode(dropKey,dragKey,dropPosition,dropToGap){var dropPath=dropKey.split(PATH_SEP);var dropNode=treeFindNodeByNamePath(additionalCellSets,dropPath);if(!dropNode.children&&!dropToGap){// Do not allow a node with a set (i.e. leaf) to become a child of another node with a set,\n// as this will result in an internal node having a set, which we do not allow.\nreturn;}var dropNodeLevel=dropPath.length-1;var dropNodeIsLevelZero=dropNodeLevel===0;// Get drag node.\nvar dragPath=dragKey.split(PATH_SEP);var dragNode=treeFindNodeByNamePath(additionalCellSets,dragPath);if(dropNodeIsLevelZero&&dropToGap&&!dragNode.children){// Do not allow a leaf node to become a level zero node.\nreturn;}var dropParentNode;var dropParentPath;var dropNodeCurrIndex;if(!dropNodeIsLevelZero){dropParentPath=dropPath.slice(0,-1);dropParentNode=treeFindNodeByNamePath(additionalCellSets,dropParentPath);dropNodeCurrIndex=dropParentNode.children.findIndex(function(c){return c.name===dropNode.name;});}else{dropNodeCurrIndex=additionalCellSets.tree.findIndex(function(lzn){return lzn.name===dropNode.name;});}// Further, only allow dragging if the dragged node will have a unique\n// name among its new siblings.\nvar hasSiblingNameConflict;var dragNodeName=dragNode.name;if(!dropNodeIsLevelZero&&dropToGap){hasSiblingNameConflict=dropParentNode.children.find(function(c){return c!==dragNode&&c.name===dragNodeName;});}else if(!dropToGap){hasSiblingNameConflict=dropNode.children.find(function(c){return c!==dragNode&&c.name===dragNodeName;});}else{hasSiblingNameConflict=additionalCellSets.tree.find(function(lzn){return lzn!==dragNode&&lzn.name===dragNodeName;});}if(hasSiblingNameConflict){return;}// Remove the dragged object from its current position.\n// Recursively check whether each node path\n// matches the path of the node to delete.\n// If so, return null, and then always use\n// .filter(Boolean) to eliminate any null array elements.\nvar nextAdditionalCellSets=_objectSpread({},additionalCellSets,{tree:additionalCellSets.tree.map(function(lzn){return filterNode(lzn,[],dragPath);}).filter(Boolean)});// Update index values after temporarily removing the dragged node.\n// Names are unique as children of their parents.\nif(!dropNodeIsLevelZero){dropNodeCurrIndex=dropParentNode.children.findIndex(function(c){return c.name===dropNode.name;});}else{dropNodeCurrIndex=nextAdditionalCellSets.tree.findIndex(function(lzn){return lzn.name===dropNode.name;});}var newDragPath=[];if(!dropToGap||!dropNodeIsLevelZero){var addChildFunction;var checkPathFunction;var newPath=[];if(!dropToGap){// Append the dragNode to dropNode's children if dropping _onto_ the dropNode.\n// Set dragNode as the last child of dropNode.\naddChildFunction=function addChildFunction(n){return nodeAppendChild(n,dragNode);};checkPathFunction=function checkPathFunction(path){return isEqual(path,dropPath);};}else if(!dropNodeIsLevelZero){// Prepend or insert the dragNode if dropping _between_ (above or below dropNode).\n// The dropNode is at a level greater than zero,\n// so it has a parent.\ncheckPathFunction=function checkPathFunction(path){return isEqual(path,dropParentPath);};if(dropPosition===-1){// Set dragNode as first child of dropParentNode.\naddChildFunction=function addChildFunction(n){return nodePrependChild(n,dragNode);};}else{// Set dragNode before or after dropNode.\nvar insertIndex=dropNodeCurrIndex+(dropPosition>dropNodeCurrIndex?1:0);addChildFunction=function addChildFunction(n){return nodeInsertChild(n,dragNode,insertIndex);};}}nextAdditionalCellSets.tree=nextAdditionalCellSets.tree.map(function(node){return nodeTransform(node,function(n,path){return checkPathFunction(path);},function(n){var newNode=addChildFunction(n);return newNode;},newPath);});// Done\nsetAdditionalCellSets(nextAdditionalCellSets);newDragPath=[].concat(_toConsumableArray(newPath[0]),[dragNode.name]);setCellSetSelection([newDragPath]);}else if(dropPosition===-1){// We need to drop the dragNode to level zero,\n// and level zero nodes do not have parents.\n// Set dragNode as first level zero node of the tree.\nnextAdditionalCellSets.tree.unshift(dragNode);setAdditionalCellSets(nextAdditionalCellSets);newDragPath=[dragNode.name];setCellSetSelection([newDragPath]);}else{// Set dragNode before or after dropNode in level zero.\nvar _insertIndex=dropNodeCurrIndex+(dropPosition>dropNodeCurrIndex?1:0);var newLevelZero=Array.from(nextAdditionalCellSets.tree);newLevelZero.splice(_insertIndex,0,dragNode);nextAdditionalCellSets.tree=newLevelZero;setAdditionalCellSets(nextAdditionalCellSets);newDragPath=[dragNode.name];setCellSetSelection([newDragPath]);}var oldColors=cellSetColor.filter(function(i){return isEqualOrPrefix(dragPath,i.path);});var newColors=oldColors.map(function(i){return _objectSpread({},i,{path:!isEqual(i.path,dragPath)?newDragPath.concat(i.path.slice(dragPath.length)):newDragPath});});var newCellSetColor=cellSetColor.filter(function(i){return!isEqualOrPrefix(dragPath,i.path);});newCellSetColor.push.apply(newCellSetColor,_toConsumableArray(newColors));setCellSetColor(newCellSetColor);}// The user wants to change the color of a cell set node.\nfunction onNodeSetColor(targetPath,color){// Replace the color if an array element for this path already exists.\nvar prevNodeColor=cellSetColor===null||cellSetColor===void 0?void 0:cellSetColor.find(function(d){return isEqual(d.path,targetPath);});if(!prevNodeColor){setCellSetColor([].concat(_toConsumableArray(cellSetColor||[]),[{path:targetPath,color:color}]));}else{setCellSetColor([].concat(_toConsumableArray(cellSetColor.filter(function(d){return!isEqual(d.path,targetPath);})),[{path:targetPath,color:color}]));}}// The user wants to change the name of a cell set node.\nfunction onNodeSetName(targetPath,name){var nextNamePath=_toConsumableArray(targetPath);nextNamePath.pop();nextNamePath.push(name);// Recursively check whether each node path\n// matches the path or a prefix of the path of the node to rename.\n// If so, rename the node using the new path.\nfunction renameNode(node,prevPath){if(isEqual([].concat(_toConsumableArray(prevPath),[node.name]),targetPath)){return _objectSpread({},node,{name:name});}if(!node.children){return node;}return _objectSpread({},node,{children:node.children.map(function(c){return renameNode(c,[].concat(_toConsumableArray(prevPath),[node.name]));})});}var nextAdditionalCellSets=_objectSpread({},additionalCellSets,{tree:additionalCellSets.tree.map(function(lzn){return renameNode(lzn,[]);})});// Change all paths that have this node as a prefix (i.e. descendants).\nvar nextCellSetColor=cellSetColor.map(function(d){return{path:tryRenamePath(targetPath,d.path,nextNamePath),color:d.color};});var nextCellSetSelection=cellSetSelection.map(function(d){return tryRenamePath(targetPath,d,nextNamePath);});var nextCellSetExpansion=cellSetExpansion.map(function(d){return tryRenamePath(targetPath,d,nextNamePath);});// Need to update the node path everywhere it may be present.\nsetAdditionalCellSets(nextAdditionalCellSets);setCellSetColor(nextCellSetColor);setCellSetSelection(nextCellSetSelection);setCellSetExpansion(nextCellSetExpansion);}// Each time the user types while renaming a cell set node,\n// we need to check whether the potential new name conflicts\n// with any existing cell set node names.\n// If there are conflicts, we want to disable the \"Save\" button.\nfunction onNodeCheckNewName(targetPath,name){var nextNamePath=_toConsumableArray(targetPath);nextNamePath.pop();nextNamePath.push(name);var hasConflicts=!isEqual(targetPath,nextNamePath)&&treeFindNodeByNamePath(additionalCellSets,nextNamePath);return hasConflicts;}// The user wants to delete a cell set node, and has confirmed their choice.\nfunction onNodeRemove(targetPath){// Recursively check whether each node path\n// matches the path of the node to delete.\n// If so, return null, and then always use\n// .filter(Boolean) to eliminate any null array elements.\nvar nextAdditionalCellSets=_objectSpread({},additionalCellSets,{tree:additionalCellSets.tree.map(function(lzn){return filterNode(lzn,[],targetPath);}).filter(Boolean)});// Delete state for all paths that have this node\n// path as a prefix (i.e. delete all descendents).\nvar nextCellSetColor=cellSetColor.filter(function(d){return!isEqualOrPrefix(targetPath,d.path);});var nextCellSetSelection=cellSetSelection.filter(function(d){return!isEqualOrPrefix(targetPath,d);});var nextCellSetExpansion=cellSetExpansion.filter(function(d){return!isEqualOrPrefix(targetPath,d);});setAdditionalCellSets(nextAdditionalCellSets);setCellSetColor(nextCellSetColor);setCellSetSelection(nextCellSetSelection);setCellSetExpansion(nextCellSetExpansion);}// The user wants to view (i.e. select) a particular node,\n// or its expanded descendents.\nfunction onNodeView(targetPath){// If parent node is clicked, and if it is expanded,\n// then select the expanded descendent nodes.\nvar setsToView=[];// Recursively determine which descendent nodes are currently expanded.\nfunction viewNode(node,nodePath){if(cellSetExpansion.find(function(expandedPath){return isEqual(nodePath,expandedPath);})){if(node.children){node.children.forEach(function(c){viewNode(c,[].concat(_toConsumableArray(nodePath),[c.name]));});}else{setsToView.push(nodePath);}}else{setsToView.push(nodePath);}}var targetNode=treeFindNodeByNamePath(mergedCellSets,targetPath);viewNode(targetNode,targetPath);setCellSetSelection(setsToView);setCellSetColorEncoding();}// The user wants to create a new level zero node.\nfunction onCreateLevelZeroNode(){var nextName=getNextNumberedNodeName(additionalCellSets===null||additionalCellSets===void 0?void 0:additionalCellSets.tree,'My hierarchy ');setAdditionalCellSets(_objectSpread({},additionalCellSets||treeInitialize(SETS_DATATYPE_CELL),{tree:[].concat(_toConsumableArray(additionalCellSets?additionalCellSets.tree:[]),[{name:nextName,children:[]}])}));}// The user wants to create a new node corresponding to\n// the union of the selected sets.\nfunction onUnion(){var newSet=treeToUnion(mergedCellSets,cellSetSelection);setCellSelection(newSet,additionalCellSets,cellSetColor,setCellSetSelection,setAdditionalCellSets,setCellSetColor,setCellColorEncoding,'Union ');}// The user wants to create a new node corresponding to\n// the intersection of the selected sets.\nfunction onIntersection(){var newSet=treeToIntersection(mergedCellSets,cellSetSelection);setCellSelection(newSet,additionalCellSets,cellSetColor,setCellSetSelection,setAdditionalCellSets,setCellSetColor,setCellColorEncoding,'Intersection ');}// The user wants to create a new node corresponding to\n// the complement of the selected sets.\nfunction onComplement(){var newSet=treeToComplement(mergedCellSets,cellSetSelection,allCellIds);setCellSelection(newSet,additionalCellSets,cellSetColor,setCellSetSelection,setAdditionalCellSets,setCellSetColor,setCellColorEncoding,'Complement ');}// The user wants to import a cell set hierarchy,\n// probably from a CSV or JSON file.\nfunction onImportTree(treeToImport){// Check for any naming conflicts with the current sets\n// (both user-defined and dataset-defined) before importing.\nvar hasConflict=treesConflict(mergedCellSets,treeToImport);if(!hasConflict){setAdditionalCellSets(_objectSpread({},additionalCellSets||treeInitialize(SETS_DATATYPE_CELL),{tree:[].concat(_toConsumableArray(additionalCellSets?additionalCellSets.tree:[]),_toConsumableArray(treeToImport.tree))}));// Automatically initialize set colors for the imported sets.\nvar importAutoSetColors=initializeCellSetColor(treeToImport,cellSetColor);setCellSetColor([].concat(_toConsumableArray(cellSetColor),_toConsumableArray(importAutoSetColors)));}}// The user wants to download a particular hierarchy to a JSON file.\nfunction onExportLevelZeroNodeJSON(nodePath){var _treeExportLevelZeroN=treeExportLevelZeroNode(mergedCellSets,nodePath,SETS_DATATYPE_CELL,cellSetColor,theme),treeToExport=_treeExportLevelZeroN.treeToExport,nodeName=_treeExportLevelZeroN.nodeName;downloadForUser(handleExportJSON(treeToExport),\"\".concat(nodeName,\"_\").concat(packageJson.name,\"-\").concat(SETS_DATATYPE_CELL,\"-hierarchy.\").concat(FILE_EXTENSION_JSON));}// The user wants to download a particular hierarchy to a CSV file.\nfunction onExportLevelZeroNodeTabular(nodePath){var _treeExportLevelZeroN2=treeExportLevelZeroNode(mergedCellSets,nodePath,SETS_DATATYPE_CELL,cellSetColor,theme),treeToExport=_treeExportLevelZeroN2.treeToExport,nodeName=_treeExportLevelZeroN2.nodeName;downloadForUser(handleExportTabular(treeToExport),\"\".concat(nodeName,\"_\").concat(packageJson.name,\"-\").concat(SETS_DATATYPE_CELL,\"-hierarchy.\").concat(FILE_EXTENSION_TABULAR));}// The user wants to download a particular set to a JSON file.\nfunction onExportSetJSON(nodePath){var _treeExportSet=treeExportSet(mergedCellSets,nodePath),setToExport=_treeExportSet.setToExport,nodeName=_treeExportSet.nodeName;downloadForUser(handleExportJSON(setToExport),\"\".concat(nodeName,\"_\").concat(packageJson.name,\"-\").concat(SETS_DATATYPE_CELL,\"-set.\").concat(FILE_EXTENSION_JSON),FILE_EXTENSION_JSON);}return/*#__PURE__*/React.createElement(TitleInfo,{title:title,isScroll:true,removeGridComponent:removeGridComponent,urls:urls,theme:theme,isReady:isReady},/*#__PURE__*/React.createElement(SetsManager,{setColor:cellSetColor,sets:cellSets,additionalSets:additionalCellSets,levelSelection:checkedLevel,setSelection:cellSetSelection,setExpansion:cellSetExpansion,hasColorEncoding:cellColorEncoding==='cellSetSelection',draggable:true,datatype:SETS_DATATYPE_CELL,onError:setWarning,onCheckNode:onCheckNode,onExpandNode:onExpandNode,onDropNode:onDropNode,onCheckLevel:onCheckLevel,onNodeSetColor:onNodeSetColor,onNodeSetName:onNodeSetName,onNodeCheckNewName:onNodeCheckNewName,onNodeRemove:onNodeRemove,onNodeView:onNodeView,onImportTree:onImportTree,onCreateLevelZeroNode:onCreateLevelZeroNode,onExportLevelZeroNodeJSON:onExportLevelZeroNodeJSON,onExportLevelZeroNodeTabular:onExportLevelZeroNodeTabular,onExportSetJSON:onExportSetJSON,onUnion:onUnion,onIntersection:onIntersection,onComplement:onComplement,hasCheckedSetsToUnion:(cellSetSelection===null||cellSetSelection===void 0?void 0:cellSetSelection.length)>1,hasCheckedSetsToIntersect:(cellSetSelection===null||cellSetSelection===void 0?void 0:cellSetSelection.length)>1,hasCheckedSetsToComplement:(cellSetSelection===null||cellSetSelection===void 0?void 0:cellSetSelection.length)>0,theme:theme}));}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/CellSetsManagerSubscriber.js"],"names":["React","useEffect","useState","useMemo","isEqual","packageJson","useCoordination","useLoaders","useSetWarning","COMPONENT_COORDINATION_TYPES","SetsManager","TitleInfo","treeExportLevelZeroNode","treeExportSet","treeToExpectedCheckedLevel","nodeToLevelDescendantNamePaths","treeToIntersection","treeToUnion","treeToComplement","treeFindNodeByNamePath","treesConflict","nodeTransform","nodeAppendChild","nodePrependChild","nodeInsertChild","filterNode","treeInitialize","initializeCellSetColor","isEqualOrPrefix","tryRenamePath","PATH_SEP","downloadForUser","handleExportJSON","handleExportTabular","tryUpgradeTreeToLatestSchema","FILE_EXTENSION_JSON","FILE_EXTENSION_TABULAR","SETS_DATATYPE_CELL","useUrls","useReady","setCellSelection","mergeCellSets","getNextNumberedNodeName","useCellsData","useCellSetsData","CELL_SETS_DATA_TYPES","CellSetsManagerSubscriber","props","coordinationScopes","removeGridComponent","theme","title","loaders","setWarning","cellSets","dataset","cellSetSelection","obsSetSelection","cellSetColor","obsSetColor","additionalCellSets","additionalObsSets","cellColorEncoding","obsColorEncoding","setCellSetSelection","setObsSetSelection","setCellColorEncoding","setObsColorEncoding","setCellSetColor","setObsSetColor","setAdditionalCellSets","setAdditionalObsSets","urls","addUrl","resetUrls","isReady","setItemIsReady","setItemIsNotReady","resetReadyItems","cellSetExpansion","setCellSetExpansion","cells","upgradedCellSets","e","message","allCellIds","Object","keys","setCellSetColorEncoding","mergedCellSets","checkedLevel","length","tree","onCheckLevel","levelZeroName","levelIndex","lzn","find","n","name","newCellSetSelection","onCheckNode","targetKey","checked","targetPath","Array","isArray","split","filter","d","onExpandNode","expandedKeys","expanded","prev","onDropNode","dropKey","dragKey","dropPosition","dropToGap","dropPath","dropNode","children","dropNodeLevel","dropNodeIsLevelZero","dragPath","dragNode","dropParentNode","dropParentPath","dropNodeCurrIndex","slice","findIndex","c","hasSiblingNameConflict","dragNodeName","nextAdditionalCellSets","map","Boolean","newDragPath","addChildFunction","checkPathFunction","newPath","path","insertIndex","node","newNode","unshift","newLevelZero","from","splice","oldColors","i","newColors","concat","newCellSetColor","push","onNodeSetColor","color","prevNodeColor","onNodeSetName","nextNamePath","pop","renameNode","prevPath","nextCellSetColor","nextCellSetSelection","nextCellSetExpansion","onNodeCheckNewName","hasConflicts","onNodeRemove","onNodeView","setsToView","viewNode","nodePath","expandedPath","forEach","targetNode","onCreateLevelZeroNode","nextName","onUnion","newSet","onIntersection","onComplement","onImportTree","treeToImport","hasConflict","importAutoSetColors","onExportLevelZeroNodeJSON","treeToExport","nodeName","onExportLevelZeroNodeTabular","onExportSetJSON","setToExport"],"mappings":"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","sourcesContent":["import React, {\n  useEffect,\n  useState,\n  useMemo,\n} from 'react';\nimport isEqual from 'lodash/isEqual';\nimport packageJson from '../../../package.json';\nimport {\n  useCoordination,\n  useLoaders,\n  useSetWarning,\n} from '../../app/state/hooks';\nimport { COMPONENT_COORDINATION_TYPES } from '../../app/state/coordination';\nimport SetsManager from './SetsManager';\nimport TitleInfo from '../TitleInfo';\nimport {\n  treeExportLevelZeroNode,\n  treeExportSet,\n  treeToExpectedCheckedLevel,\n  nodeToLevelDescendantNamePaths,\n  treeToIntersection,\n  treeToUnion,\n  treeToComplement,\n  treeFindNodeByNamePath,\n  treesConflict,\n  nodeTransform,\n  nodeAppendChild,\n  nodePrependChild,\n  nodeInsertChild,\n  filterNode,\n  treeInitialize,\n  initializeCellSetColor,\n} from './cell-set-utils';\nimport {\n  isEqualOrPrefix,\n  tryRenamePath,\n  PATH_SEP,\n} from './utils';\nimport {\n  downloadForUser,\n  handleExportJSON,\n  handleExportTabular,\n  tryUpgradeTreeToLatestSchema,\n} from './io';\nimport {\n  FILE_EXTENSION_JSON,\n  FILE_EXTENSION_TABULAR,\n  SETS_DATATYPE_CELL,\n} from './constants';\nimport { useUrls, useReady } from '../hooks';\nimport {\n  setCellSelection,\n  mergeCellSets,\n  getNextNumberedNodeName,\n} from '../utils';\nimport { useCellsData, useCellSetsData } from '../data-hooks';\n\nconst CELL_SETS_DATA_TYPES = ['cells', 'cell-sets'];\n\n/**\n * A subscriber wrapper around the SetsManager component\n * for the 'cell' datatype.\n * @param {object} props\n * @param {string} props.theme The current theme name.\n * @param {object} props.coordinationScopes The mapping from coordination types to coordination\n * scopes.\n * @param {function} props.removeGridComponent The callback function to pass to TitleInfo,\n * to call when the component has been removed from the grid.\n * @param {string} props.title The component title.\n */\nexport default function CellSetsManagerSubscriber(props) {\n  const {\n    coordinationScopes,\n    removeGridComponent,\n    theme,\n    title = 'Cell Sets',\n  } = props;\n\n  const loaders = useLoaders();\n  const setWarning = useSetWarning();\n\n  // Get \"props\" from the coordination space.\n  const [{\n    dataset,\n    obsSetSelection: cellSetSelection,\n    obsSetColor: cellSetColor,\n    additionalObsSets: additionalCellSets,\n    obsColorEncoding: cellColorEncoding,\n  }, {\n    setObsSetSelection: setCellSetSelection,\n    setObsColorEncoding: setCellColorEncoding,\n    setObsSetColor: setCellSetColor,\n    setAdditionalObsSets: setAdditionalCellSets,\n  }] = useCoordination(COMPONENT_COORDINATION_TYPES.cellSets, coordinationScopes);\n\n  const [urls, addUrl, resetUrls] = useUrls();\n  const [\n    isReady,\n    setItemIsReady,\n    setItemIsNotReady, // eslint-disable-line no-unused-vars\n    resetReadyItems,\n  ] = useReady(\n    CELL_SETS_DATA_TYPES,\n  );\n\n  const [cellSetExpansion, setCellSetExpansion] = useState([]);\n\n  // Reset file URLs and loader progress when the dataset has changed.\n  useEffect(() => {\n    resetUrls();\n    resetReadyItems();\n    setCellSetExpansion([]);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [loaders, dataset]);\n\n  // Get data from loaders using the data hooks.\n  const [cells] = useCellsData(loaders, dataset, setItemIsReady, addUrl, true);\n  const [cellSets] = useCellSetsData(\n    loaders, dataset, setItemIsReady, addUrl, false,\n    { setObsSetSelection: setCellSetSelection, setObsSetColor: setCellSetColor },\n    { obsSetSelection: cellSetSelection, obsSetColor: cellSetColor },\n  );\n\n  // Validate and upgrade the additionalCellSets.\n  useEffect(() => {\n    if (additionalCellSets) {\n      let upgradedCellSets;\n      try {\n        upgradedCellSets = tryUpgradeTreeToLatestSchema(additionalCellSets, SETS_DATATYPE_CELL);\n      } catch (e) {\n        setWarning(e.message);\n        return;\n      }\n      setAdditionalCellSets(upgradedCellSets);\n    }\n  }, [additionalCellSets, setAdditionalCellSets, setWarning]);\n\n  // Get an array of all cell IDs to use for set complement operations.\n  const allCellIds = useMemo(() => (cells ? Object.keys(cells) : []), [cells]);\n\n  // A helper function for updating the encoding for cell colors,\n  // which may have previously been set to 'geneSelection'.\n  function setCellSetColorEncoding() {\n    setCellColorEncoding('cellSetSelection');\n  }\n\n  // Merged cell sets are only to be used for convenience when reading\n  // (if writing: update either `cellSets` _or_ `additionalCellSets`).\n  const mergedCellSets = useMemo(\n    () => mergeCellSets(cellSets, additionalCellSets),\n    [cellSets, additionalCellSets],\n  );\n\n  // Infer the state of the \"checked level\" radio button based on the selected cell sets.\n  const checkedLevel = useMemo(() => {\n    if (cellSetSelection && cellSetSelection.length > 0\n    && mergedCellSets && mergedCellSets.tree.length > 0) {\n      return treeToExpectedCheckedLevel(mergedCellSets, cellSetSelection);\n    }\n    return null;\n  }, [cellSetSelection, mergedCellSets]);\n\n  // Callback functions\n\n  // The user wants to select all nodes at a particular hierarchy level.\n  function onCheckLevel(levelZeroName, levelIndex) {\n    const lzn = mergedCellSets.tree.find(n => n.name === levelZeroName);\n    if (lzn) {\n      const newCellSetSelection = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);\n      setCellSetSelection(newCellSetSelection);\n      setCellSetColorEncoding();\n    }\n  }\n\n  // The user wants to check or uncheck a cell set node.\n  function onCheckNode(targetKey, checked) {\n    const targetPath = (Array.isArray(targetKey) ? targetKey : targetKey.split(PATH_SEP));\n    if (!targetKey) {\n      return;\n    }\n    if (checked) {\n      setCellSetSelection([...cellSetSelection, targetPath]);\n    } else {\n      setCellSetSelection(cellSetSelection.filter(d => !isEqual(d, targetPath)));\n    }\n    setCellSetColorEncoding();\n  }\n\n  // The user wants to expand or collapse a node in the tree.\n  function onExpandNode(expandedKeys, targetKey, expanded) {\n    if (expanded) {\n      setCellSetExpansion(prev => ([...prev, targetKey.split(PATH_SEP)]));\n    } else {\n      setCellSetExpansion(prev => prev.filter(d => !isEqual(d, targetKey.split(PATH_SEP))));\n    }\n  }\n\n  // The user dragged a tree node and dropped it somewhere else in the tree\n  // to re-arrange or re-order the nodes.\n  // We need to verify that their drop target is valid, and if so, complete\n  // the tree re-arrangement.\n  function onDropNode(dropKey, dragKey, dropPosition, dropToGap) {\n    const dropPath = dropKey.split(PATH_SEP);\n    const dropNode = treeFindNodeByNamePath(additionalCellSets, dropPath);\n    if (!dropNode.children && !dropToGap) {\n      // Do not allow a node with a set (i.e. leaf) to become a child of another node with a set,\n      // as this will result in an internal node having a set, which we do not allow.\n      return;\n    }\n    const dropNodeLevel = dropPath.length - 1;\n    const dropNodeIsLevelZero = dropNodeLevel === 0;\n\n    // Get drag node.\n    const dragPath = dragKey.split(PATH_SEP);\n    const dragNode = treeFindNodeByNamePath(additionalCellSets, dragPath);\n\n    if (dropNodeIsLevelZero && dropToGap && !dragNode.children) {\n      // Do not allow a leaf node to become a level zero node.\n      return;\n    }\n\n    let dropParentNode;\n    let dropParentPath;\n    let dropNodeCurrIndex;\n    if (!dropNodeIsLevelZero) {\n      dropParentPath = dropPath.slice(0, -1);\n      dropParentNode = treeFindNodeByNamePath(additionalCellSets, dropParentPath);\n      dropNodeCurrIndex = dropParentNode.children.findIndex(c => c.name === dropNode.name);\n    } else {\n      dropNodeCurrIndex = additionalCellSets.tree.findIndex(\n        lzn => lzn.name === dropNode.name,\n      );\n    }\n    // Further, only allow dragging if the dragged node will have a unique\n    // name among its new siblings.\n    let hasSiblingNameConflict;\n    const dragNodeName = dragNode.name;\n    if (!dropNodeIsLevelZero && dropToGap) {\n      hasSiblingNameConflict = dropParentNode.children\n        .find(c => c !== dragNode && c.name === dragNodeName);\n    } else if (!dropToGap) {\n      hasSiblingNameConflict = dropNode.children\n        .find(c => c !== dragNode && c.name === dragNodeName);\n    } else {\n      hasSiblingNameConflict = additionalCellSets.tree\n        .find(lzn => lzn !== dragNode && lzn.name === dragNodeName);\n    }\n\n    if (hasSiblingNameConflict) {\n      return;\n    }\n\n    // Remove the dragged object from its current position.\n    // Recursively check whether each node path\n    // matches the path of the node to delete.\n    // If so, return null, and then always use\n    // .filter(Boolean) to eliminate any null array elements.\n    const nextAdditionalCellSets = {\n      ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => filterNode(lzn, [], dragPath)).filter(Boolean),\n    };\n\n    // Update index values after temporarily removing the dragged node.\n    // Names are unique as children of their parents.\n    if (!dropNodeIsLevelZero) {\n      dropNodeCurrIndex = dropParentNode.children.findIndex(c => c.name === dropNode.name);\n    } else {\n      dropNodeCurrIndex = nextAdditionalCellSets.tree.findIndex(\n        lzn => lzn.name === dropNode.name,\n      );\n    }\n    let newDragPath = [];\n    if (!dropToGap || !dropNodeIsLevelZero) {\n      let addChildFunction;\n      let checkPathFunction;\n      const newPath = [];\n      if (!dropToGap) {\n        // Append the dragNode to dropNode's children if dropping _onto_ the dropNode.\n        // Set dragNode as the last child of dropNode.\n        addChildFunction = n => nodeAppendChild(n, dragNode);\n        checkPathFunction = path => isEqual(path, dropPath);\n      } else if (!dropNodeIsLevelZero) {\n        // Prepend or insert the dragNode if dropping _between_ (above or below dropNode).\n        // The dropNode is at a level greater than zero,\n        // so it has a parent.\n        checkPathFunction = path => isEqual(path, dropParentPath);\n        if (dropPosition === -1) {\n          // Set dragNode as first child of dropParentNode.\n          addChildFunction = n => nodePrependChild(n, dragNode);\n        } else {\n          // Set dragNode before or after dropNode.\n          const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);\n          addChildFunction = n => nodeInsertChild(n, dragNode, insertIndex);\n        }\n      }\n      nextAdditionalCellSets.tree = nextAdditionalCellSets.tree.map(\n        node => nodeTransform(\n          node,\n          (n, path) => checkPathFunction(path),\n          (n) => {\n            const newNode = addChildFunction(n);\n            return newNode;\n          },\n          newPath,\n        ),\n      );\n      // Done\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [...newPath[0], dragNode.name];\n      setCellSetSelection([newDragPath]);\n    } else if (dropPosition === -1) {\n      // We need to drop the dragNode to level zero,\n      // and level zero nodes do not have parents.\n      // Set dragNode as first level zero node of the tree.\n      nextAdditionalCellSets.tree.unshift(dragNode);\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [dragNode.name];\n      setCellSetSelection([newDragPath]);\n    } else {\n      // Set dragNode before or after dropNode in level zero.\n      const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);\n      const newLevelZero = Array.from(nextAdditionalCellSets.tree);\n      newLevelZero.splice(insertIndex, 0, dragNode);\n      nextAdditionalCellSets.tree = newLevelZero;\n      setAdditionalCellSets(nextAdditionalCellSets);\n      newDragPath = [dragNode.name];\n      setCellSetSelection([newDragPath]);\n    }\n    const oldColors = cellSetColor.filter(\n      i => isEqualOrPrefix(dragPath, i.path),\n    );\n    const newColors = oldColors.map(\n      i => (\n        {\n          ...i,\n          path: !isEqual(i.path, dragPath)\n            ? newDragPath.concat(i.path.slice(dragPath.length))\n            : newDragPath,\n        }\n      ),\n    );\n    const newCellSetColor = cellSetColor.filter(\n      i => !isEqualOrPrefix(dragPath, i.path),\n    );\n    newCellSetColor.push(...newColors);\n    setCellSetColor(newCellSetColor);\n  }\n\n  // The user wants to change the color of a cell set node.\n  function onNodeSetColor(targetPath, color) {\n    // Replace the color if an array element for this path already exists.\n    const prevNodeColor = cellSetColor?.find(d => isEqual(d.path, targetPath));\n    if (!prevNodeColor) {\n      setCellSetColor([\n        ...(cellSetColor || []),\n        {\n          path: targetPath,\n          color,\n        },\n      ]);\n    } else {\n      setCellSetColor([\n        ...cellSetColor.filter(d => !isEqual(d.path, targetPath)),\n        {\n          path: targetPath,\n          color,\n        },\n      ]);\n    }\n  }\n\n  // The user wants to change the name of a cell set node.\n  function onNodeSetName(targetPath, name) {\n    const nextNamePath = [...targetPath];\n    nextNamePath.pop();\n    nextNamePath.push(name);\n\n    // Recursively check whether each node path\n    // matches the path or a prefix of the path of the node to rename.\n    // If so, rename the node using the new path.\n    function renameNode(node, prevPath) {\n      if (isEqual([...prevPath, node.name], targetPath)) {\n        return {\n          ...node,\n          name,\n        };\n      }\n      if (!node.children) {\n        return node;\n      }\n      return {\n        ...node,\n        children: node.children.map(c => renameNode(c, [...prevPath, node.name])),\n      };\n    }\n    const nextAdditionalCellSets = {\n      ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => renameNode(lzn, [])),\n    };\n    // Change all paths that have this node as a prefix (i.e. descendants).\n    const nextCellSetColor = cellSetColor.map(d => ({\n      path: tryRenamePath(targetPath, d.path, nextNamePath),\n      color: d.color,\n    }));\n    const nextCellSetSelection = cellSetSelection.map(d => (\n      tryRenamePath(targetPath, d, nextNamePath)\n    ));\n    const nextCellSetExpansion = cellSetExpansion.map(d => (\n      tryRenamePath(targetPath, d, nextNamePath)\n    ));\n    // Need to update the node path everywhere it may be present.\n    setAdditionalCellSets(nextAdditionalCellSets);\n    setCellSetColor(nextCellSetColor);\n    setCellSetSelection(nextCellSetSelection);\n    setCellSetExpansion(nextCellSetExpansion);\n  }\n\n  // Each time the user types while renaming a cell set node,\n  // we need to check whether the potential new name conflicts\n  // with any existing cell set node names.\n  // If there are conflicts, we want to disable the \"Save\" button.\n  function onNodeCheckNewName(targetPath, name) {\n    const nextNamePath = [...targetPath];\n    nextNamePath.pop();\n    nextNamePath.push(name);\n    const hasConflicts = (\n      !isEqual(targetPath, nextNamePath)\n      && treeFindNodeByNamePath(additionalCellSets, nextNamePath)\n    );\n    return hasConflicts;\n  }\n\n  // The user wants to delete a cell set node, and has confirmed their choice.\n  function onNodeRemove(targetPath) {\n    // Recursively check whether each node path\n    // matches the path of the node to delete.\n    // If so, return null, and then always use\n    // .filter(Boolean) to eliminate any null array elements.\n    const nextAdditionalCellSets = {\n      ...additionalCellSets,\n      tree: additionalCellSets.tree.map(lzn => filterNode(lzn, [], targetPath)).filter(Boolean),\n    };\n    // Delete state for all paths that have this node\n    // path as a prefix (i.e. delete all descendents).\n    const nextCellSetColor = cellSetColor.filter(d => !isEqualOrPrefix(targetPath, d.path));\n    const nextCellSetSelection = cellSetSelection.filter(d => !isEqualOrPrefix(targetPath, d));\n    const nextCellSetExpansion = cellSetExpansion.filter(d => !isEqualOrPrefix(targetPath, d));\n    setAdditionalCellSets(nextAdditionalCellSets);\n    setCellSetColor(nextCellSetColor);\n    setCellSetSelection(nextCellSetSelection);\n    setCellSetExpansion(nextCellSetExpansion);\n  }\n\n  // The user wants to view (i.e. select) a particular node,\n  // or its expanded descendents.\n  function onNodeView(targetPath) {\n    // If parent node is clicked, and if it is expanded,\n    // then select the expanded descendent nodes.\n    const setsToView = [];\n    // Recursively determine which descendent nodes are currently expanded.\n    function viewNode(node, nodePath) {\n      if (cellSetExpansion.find(expandedPath => isEqual(nodePath, expandedPath))) {\n        if (node.children) {\n          node.children.forEach((c) => {\n            viewNode(c, [...nodePath, c.name]);\n          });\n        } else {\n          setsToView.push(nodePath);\n        }\n      } else {\n        setsToView.push(nodePath);\n      }\n    }\n    const targetNode = treeFindNodeByNamePath(mergedCellSets, targetPath);\n    viewNode(targetNode, targetPath);\n    setCellSetSelection(setsToView);\n    setCellSetColorEncoding();\n  }\n\n  // The user wants to create a new level zero node.\n  function onCreateLevelZeroNode() {\n    const nextName = getNextNumberedNodeName(additionalCellSets?.tree, 'My hierarchy ');\n    setAdditionalCellSets({\n      ...(additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)),\n      tree: [\n        ...(additionalCellSets ? additionalCellSets.tree : []),\n        {\n          name: nextName,\n          children: [],\n        },\n      ],\n    });\n  }\n\n  // The user wants to create a new node corresponding to\n  // the union of the selected sets.\n  function onUnion() {\n    const newSet = treeToUnion(mergedCellSets, cellSetSelection);\n    setCellSelection(\n      newSet, additionalCellSets, cellSetColor,\n      setCellSetSelection, setAdditionalCellSets, setCellSetColor,\n      setCellColorEncoding,\n      'Union ',\n    );\n  }\n\n  // The user wants to create a new node corresponding to\n  // the intersection of the selected sets.\n  function onIntersection() {\n    const newSet = treeToIntersection(mergedCellSets, cellSetSelection);\n    setCellSelection(\n      newSet, additionalCellSets, cellSetColor,\n      setCellSetSelection, setAdditionalCellSets, setCellSetColor,\n      setCellColorEncoding,\n      'Intersection ',\n    );\n  }\n\n  // The user wants to create a new node corresponding to\n  // the complement of the selected sets.\n  function onComplement() {\n    const newSet = treeToComplement(mergedCellSets, cellSetSelection, allCellIds);\n    setCellSelection(\n      newSet, additionalCellSets, cellSetColor,\n      setCellSetSelection, setAdditionalCellSets, setCellSetColor,\n      setCellColorEncoding,\n      'Complement ',\n    );\n  }\n\n  // The user wants to import a cell set hierarchy,\n  // probably from a CSV or JSON file.\n  function onImportTree(treeToImport) {\n    // Check for any naming conflicts with the current sets\n    // (both user-defined and dataset-defined) before importing.\n    const hasConflict = treesConflict(mergedCellSets, treeToImport);\n    if (!hasConflict) {\n      setAdditionalCellSets({\n        ...(additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)),\n        tree: [\n          ...(additionalCellSets ? additionalCellSets.tree : []),\n          ...treeToImport.tree,\n        ],\n      });\n      // Automatically initialize set colors for the imported sets.\n      const importAutoSetColors = initializeCellSetColor(treeToImport, cellSetColor);\n      setCellSetColor([\n        ...cellSetColor,\n        ...importAutoSetColors,\n      ]);\n    }\n  }\n\n  // The user wants to download a particular hierarchy to a JSON file.\n  function onExportLevelZeroNodeJSON(nodePath) {\n    const {\n      treeToExport, nodeName,\n    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);\n    downloadForUser(\n      handleExportJSON(treeToExport),\n      `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_JSON}`,\n    );\n  }\n\n  // The user wants to download a particular hierarchy to a CSV file.\n  function onExportLevelZeroNodeTabular(nodePath) {\n    const {\n      treeToExport, nodeName,\n    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);\n    downloadForUser(\n      handleExportTabular(treeToExport),\n      `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_TABULAR}`,\n    );\n  }\n\n  // The user wants to download a particular set to a JSON file.\n  function onExportSetJSON(nodePath) {\n    const { setToExport, nodeName } = treeExportSet(mergedCellSets, nodePath);\n    downloadForUser(\n      handleExportJSON(setToExport),\n      `${nodeName}_${packageJson.name}-${SETS_DATATYPE_CELL}-set.${FILE_EXTENSION_JSON}`,\n      FILE_EXTENSION_JSON,\n    );\n  }\n  return (\n    <TitleInfo\n      title={title}\n      isScroll\n      removeGridComponent={removeGridComponent}\n      urls={urls}\n      theme={theme}\n      isReady={isReady}\n    >\n      <SetsManager\n        setColor={cellSetColor}\n        sets={cellSets}\n        additionalSets={additionalCellSets}\n        levelSelection={checkedLevel}\n        setSelection={cellSetSelection}\n        setExpansion={cellSetExpansion}\n        hasColorEncoding={cellColorEncoding === 'cellSetSelection'}\n        draggable\n        datatype={SETS_DATATYPE_CELL}\n        onError={setWarning}\n        onCheckNode={onCheckNode}\n        onExpandNode={onExpandNode}\n        onDropNode={onDropNode}\n        onCheckLevel={onCheckLevel}\n        onNodeSetColor={onNodeSetColor}\n        onNodeSetName={onNodeSetName}\n        onNodeCheckNewName={onNodeCheckNewName}\n        onNodeRemove={onNodeRemove}\n        onNodeView={onNodeView}\n        onImportTree={onImportTree}\n        onCreateLevelZeroNode={onCreateLevelZeroNode}\n        onExportLevelZeroNodeJSON={onExportLevelZeroNodeJSON}\n        onExportLevelZeroNodeTabular={onExportLevelZeroNodeTabular}\n        onExportSetJSON={onExportSetJSON}\n        onUnion={onUnion}\n        onIntersection={onIntersection}\n        onComplement={onComplement}\n        hasCheckedSetsToUnion={cellSetSelection?.length > 1}\n        hasCheckedSetsToIntersect={cellSetSelection?.length > 1}\n        hasCheckedSetsToComplement={cellSetSelection?.length > 0}\n        theme={theme}\n      />\n    </TitleInfo>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}