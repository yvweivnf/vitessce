{"ast":null,"code":"/**\n * Utility for generating row / column headers\n */\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport { HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP } from '../../header';\nimport { isSortField } from '../../sort';\nimport { isFacetMapping } from '../../spec/facet';\nimport { contains, isEmpty, normalizeAngle, replaceAll } from '../../util';\nimport { defaultLabelAlign, defaultLabelBaseline } from '../axis/properties';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { formatSignalRef } from '../format';\nimport { isFacetModel } from '../model';\nimport { getHeaderChannel, getHeaderProperties, getHeaderProperty } from './common';\nimport { HEADER_TYPES } from './component'; // TODO: rename to assembleHeaderTitleGroup\n\nexport function assembleTitleGroup(model, channel) {\n  const title = model.component.layoutHeaders[channel].title;\n  const config = model.config ? model.config : undefined;\n  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : undefined;\n  const {\n    titleAnchor,\n    titleAngle: ta,\n    titleOrient\n  } = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel);\n  const headerChannel = getHeaderChannel(channel, titleOrient);\n  const titleAngle = normalizeAngle(ta);\n  return {\n    name: `${channel}-title`,\n    type: 'group',\n    role: `${headerChannel}-title`,\n    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      text: title\n    }, channel === 'row' ? {\n      orient: 'left'\n    } : {}), {\n      style: 'guide-title'\n    }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))\n  };\n}\nexport function defaultHeaderGuideAlign(headerChannel, angle, anchor = 'middle') {\n  switch (anchor) {\n    case 'start':\n      return {\n        align: 'left'\n      };\n\n    case 'end':\n      return {\n        align: 'right'\n      };\n  }\n\n  const align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n  return align ? {\n    align\n  } : {};\n}\nexport function defaultHeaderGuideBaseline(angle, channel) {\n  const baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n  return baseline ? {\n    baseline\n  } : {};\n}\nexport function assembleHeaderGroups(model, channel) {\n  const layoutHeader = model.component.layoutHeaders[channel];\n  const groups = [];\n\n  for (const headerType of HEADER_TYPES) {\n    if (layoutHeader[headerType]) {\n      for (const headerComponent of layoutHeader[headerType]) {\n        const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n\n        if (group != null) {\n          groups.push(group);\n        }\n      }\n    }\n  }\n\n  return groups;\n}\n\nfunction getSort(facetFieldDef, channel) {\n  var _a;\n\n  const {\n    sort\n  } = facetFieldDef;\n\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {\n        expr: 'datum'\n      }),\n      order: (_a = sort.order) !== null && _a !== void 0 ? _a : 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {\n        expr: 'datum'\n      }),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {\n        expr: 'datum'\n      }),\n      order: sort !== null && sort !== void 0 ? sort : 'ascending'\n    };\n  }\n}\n\nexport function assembleLabelTitle(facetFieldDef, channel, config) {\n  const {\n    format,\n    formatType,\n    labelAngle,\n    labelAnchor,\n    labelOrient,\n    labelExpr\n  } = getHeaderProperties(['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'], facetFieldDef.header, config, channel);\n  const titleTextExpr = formatSignalRef({\n    fieldOrDatumDef: facetFieldDef,\n    format,\n    formatType,\n    expr: 'parent',\n    config\n  }).signal;\n  const headerChannel = getHeaderChannel(channel, labelOrient);\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    text: {\n      signal: labelExpr ? replaceAll(replaceAll(labelExpr, 'datum.label', titleTextExpr), 'datum.value', vgField(facetFieldDef, {\n        expr: 'parent'\n      })) : titleTextExpr\n    }\n  }, channel === 'row' ? {\n    orient: 'left'\n  } : {}), {\n    style: 'guide-label',\n    frame: 'group'\n  }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));\n}\nexport function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {\n  if (headerComponent) {\n    let title = null;\n    const {\n      facetFieldDef\n    } = layoutHeader;\n    const config = model.config ? model.config : undefined;\n\n    if (facetFieldDef && headerComponent.labels) {\n      const {\n        labelOrient\n      } = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel); // Include label title in the header if orient aligns with the channel\n\n      if (channel === 'row' && !contains(['top', 'bottom'], labelOrient) || channel === 'column' && !contains(['left', 'right'], labelOrient)) {\n        title = assembleLabelTitle(facetFieldDef, channel, config);\n      }\n    }\n\n    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n    const axes = headerComponent.axes;\n    const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;\n\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`\n      }, layoutHeader.facetFieldDef ? {\n        from: {\n          data: model.getName(`${channel}_domain`)\n        },\n        sort: getSort(facetFieldDef, channel)\n      } : {}), hasAxes && isFacetWithoutRowCol ? {\n        from: {\n          data: model.getName(`facet_domain_${channel}`)\n        }\n      } : {}), title ? {\n        title\n      } : {}), headerComponent.sizeSignal ? {\n        encode: {\n          update: {\n            [sizeChannel]: headerComponent.sizeSignal\n          }\n        }\n      } : {}), hasAxes ? {\n        axes\n      } : {});\n    }\n  }\n\n  return null;\n}\nconst LAYOUT_TITLE_BAND = {\n  column: {\n    start: 0,\n    end: 1\n  },\n  row: {\n    start: 1,\n    end: 0\n  }\n};\nexport function getLayoutTitleBand(titleAnchor, headerChannel) {\n  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];\n}\nexport function assembleLayoutTitleBand(headerComponentIndex, config) {\n  const titleBand = {};\n\n  for (const channel of FACET_CHANNELS) {\n    const headerComponent = headerComponentIndex[channel];\n\n    if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {\n      const {\n        titleAnchor,\n        titleOrient\n      } = getHeaderProperties(['titleAnchor', 'titleOrient'], headerComponent.facetFieldDef.header, config, channel);\n      const headerChannel = getHeaderChannel(channel, titleOrient);\n      const band = getLayoutTitleBand(titleAnchor, headerChannel);\n\n      if (band !== undefined) {\n        titleBand[headerChannel] = band;\n      }\n    }\n  }\n\n  return isEmpty(titleBand) ? undefined : titleBand;\n}\nexport function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {\n  const props = {};\n\n  for (const prop of properties) {\n    if (!propertiesMap[prop]) {\n      continue;\n    }\n\n    const value = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);\n\n    if (value !== undefined) {\n      props[propertiesMap[prop]] = value;\n    }\n  }\n\n  return props;\n}","map":{"version":3,"sources":["../../../../src/compile/header/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Utility for generating row / column headers\n */\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport { HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP } from '../../header';\nimport { isSortField } from '../../sort';\nimport { isFacetMapping } from '../../spec/facet';\nimport { contains, isEmpty, normalizeAngle, replaceAll } from '../../util';\nimport { defaultLabelAlign, defaultLabelBaseline } from '../axis/properties';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { formatSignalRef } from '../format';\nimport { isFacetModel } from '../model';\nimport { getHeaderChannel, getHeaderProperties, getHeaderProperty } from './common';\nimport { HEADER_TYPES } from './component';\n// TODO: rename to assembleHeaderTitleGroup\nexport function assembleTitleGroup(model, channel) {\n    const title = model.component.layoutHeaders[channel].title;\n    const config = model.config ? model.config : undefined;\n    const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef\n        ? model.component.layoutHeaders[channel].facetFieldDef\n        : undefined;\n    const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel);\n    const headerChannel = getHeaderChannel(channel, titleOrient);\n    const titleAngle = normalizeAngle(ta);\n    return {\n        name: `${channel}-title`,\n        type: 'group',\n        role: `${headerChannel}-title`,\n        title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: title }, (channel === 'row' ? { orient: 'left' } : {})), { style: 'guide-title' }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))\n    };\n}\nexport function defaultHeaderGuideAlign(headerChannel, angle, anchor = 'middle') {\n    switch (anchor) {\n        case 'start':\n            return { align: 'left' };\n        case 'end':\n            return { align: 'right' };\n    }\n    const align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n    return align ? { align } : {};\n}\nexport function defaultHeaderGuideBaseline(angle, channel) {\n    const baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n    return baseline ? { baseline } : {};\n}\nexport function assembleHeaderGroups(model, channel) {\n    const layoutHeader = model.component.layoutHeaders[channel];\n    const groups = [];\n    for (const headerType of HEADER_TYPES) {\n        if (layoutHeader[headerType]) {\n            for (const headerComponent of layoutHeader[headerType]) {\n                const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n                if (group != null) {\n                    groups.push(group);\n                }\n            }\n        }\n    }\n    return groups;\n}\nfunction getSort(facetFieldDef, channel) {\n    var _a;\n    const { sort } = facetFieldDef;\n    if (isSortField(sort)) {\n        return {\n            field: vgField(sort, { expr: 'datum' }),\n            order: (_a = sort.order) !== null && _a !== void 0 ? _a : 'ascending'\n        };\n    }\n    else if (isArray(sort)) {\n        return {\n            field: sortArrayIndexField(facetFieldDef, channel, { expr: 'datum' }),\n            order: 'ascending'\n        };\n    }\n    else {\n        return {\n            field: vgField(facetFieldDef, { expr: 'datum' }),\n            order: sort !== null && sort !== void 0 ? sort : 'ascending'\n        };\n    }\n}\nexport function assembleLabelTitle(facetFieldDef, channel, config) {\n    const { format, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'], facetFieldDef.header, config, channel);\n    const titleTextExpr = formatSignalRef({\n        fieldOrDatumDef: facetFieldDef,\n        format,\n        formatType,\n        expr: 'parent',\n        config\n    }).signal;\n    const headerChannel = getHeaderChannel(channel, labelOrient);\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: {\n            signal: labelExpr\n                ? replaceAll(replaceAll(labelExpr, 'datum.label', titleTextExpr), 'datum.value', vgField(facetFieldDef, { expr: 'parent' }))\n                : titleTextExpr\n        } }, (channel === 'row' ? { orient: 'left' } : {})), { style: 'guide-label', frame: 'group' }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));\n}\nexport function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {\n    if (headerComponent) {\n        let title = null;\n        const { facetFieldDef } = layoutHeader;\n        const config = model.config ? model.config : undefined;\n        if (facetFieldDef && headerComponent.labels) {\n            const { labelOrient } = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel);\n            // Include label title in the header if orient aligns with the channel\n            if ((channel === 'row' && !contains(['top', 'bottom'], labelOrient)) ||\n                (channel === 'column' && !contains(['left', 'right'], labelOrient))) {\n                title = assembleLabelTitle(facetFieldDef, channel, config);\n            }\n        }\n        const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n        const axes = headerComponent.axes;\n        const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;\n        if (title || hasAxes) {\n            const sizeChannel = channel === 'row' ? 'height' : 'width';\n            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName(`${channel}_${headerType}`), type: 'group', role: `${channel}-${headerType}` }, (layoutHeader.facetFieldDef\n                ? {\n                    from: { data: model.getName(`${channel}_domain`) },\n                    sort: getSort(facetFieldDef, channel)\n                }\n                : {})), (hasAxes && isFacetWithoutRowCol\n                ? {\n                    from: { data: model.getName(`facet_domain_${channel}`) }\n                }\n                : {})), (title ? { title } : {})), (headerComponent.sizeSignal\n                ? {\n                    encode: {\n                        update: {\n                            [sizeChannel]: headerComponent.sizeSignal\n                        }\n                    }\n                }\n                : {})), (hasAxes ? { axes } : {}));\n        }\n    }\n    return null;\n}\nconst LAYOUT_TITLE_BAND = {\n    column: {\n        start: 0,\n        end: 1\n    },\n    row: {\n        start: 1,\n        end: 0\n    }\n};\nexport function getLayoutTitleBand(titleAnchor, headerChannel) {\n    return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];\n}\nexport function assembleLayoutTitleBand(headerComponentIndex, config) {\n    const titleBand = {};\n    for (const channel of FACET_CHANNELS) {\n        const headerComponent = headerComponentIndex[channel];\n        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {\n            const { titleAnchor, titleOrient } = getHeaderProperties(['titleAnchor', 'titleOrient'], headerComponent.facetFieldDef.header, config, channel);\n            const headerChannel = getHeaderChannel(channel, titleOrient);\n            const band = getLayoutTitleBand(titleAnchor, headerChannel);\n            if (band !== undefined) {\n                titleBand[headerChannel] = band;\n            }\n        }\n    }\n    return isEmpty(titleBand) ? undefined : titleBand;\n}\nexport function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {\n    const props = {};\n    for (const prop of properties) {\n        if (!propertiesMap[prop]) {\n            continue;\n        }\n        const value = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);\n        if (value !== undefined) {\n            props[propertiesMap[prop]] = value;\n        }\n    }\n    return props;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}