{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var encoding = model.encoding,\n      markDef = model.markDef,\n      config = model.config,\n      stack = model.stack;\n  var channelDef = encoding.tooltip;\n\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, stack, config, opt)\n    };\n  } else {\n    var datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    return wrapCondition(model, channelDef, 'tooltip', function (cDef) {\n      // use valueRef based on channelDef first\n      var tooltipRefFromChannelDef = textRef(cDef, config, datum);\n\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      var markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {\n            signal: datum\n          };\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\nexport function tooltipData(encoding, stack, config) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      reactiveGeom = _ref.reactiveGeom;\n\n  var toSkip = {};\n  var expr = reactiveGeom ? 'datum.datum' : 'datum';\n  var tuples = [];\n\n  function add(fDef, channel) {\n    var mainChannel = getMainRangeChannel(channel);\n    var fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n\n    });\n    var title = fieldDef.title || defaultTitle(fieldDef, config);\n    var key = array(title).join(', ');\n    var value;\n\n    if (isXorY(channel)) {\n      var channel2 = channel === 'x' ? 'x2' : 'y2';\n      var fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        var startField = vgField(fieldDef, {\n          expr: expr\n        });\n        var endField = vgField(fieldDef2, {\n          expr: expr\n        });\n\n        var _getFormatMixins = getFormatMixins(fieldDef),\n            format = _getFormatMixins.format,\n            formatType = _getFormatMixins.formatType;\n\n        value = binFormatExpression(startField, endField, format, formatType, config);\n        toSkip[channel2] = true;\n      } else if (stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n        var _getFormatMixins2 = getFormatMixins(fieldDef),\n            _format = _getFormatMixins2.format,\n            _formatType = _getFormatMixins2.formatType;\n\n        value = formatSignalRef({\n          fieldOrDatumDef: fieldDef,\n          format: _format,\n          formatType: _formatType,\n          expr: expr,\n          config: config,\n          normalizeStack: true\n        }).signal;\n      }\n    }\n\n    value !== null && value !== void 0 ? value : value = textRef(fieldDef, config, expr).signal;\n    tuples.push({\n      channel: channel,\n      key: key,\n      value: value\n    });\n  }\n\n  forEach(encoding, function (channelDef, channel) {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  var out = {};\n\n  for (var _i = 0, _tuples = tuples; _i < _tuples.length; _i++) {\n    var _tuples$_i = _tuples[_i],\n        channel = _tuples$_i.channel,\n        key = _tuples$_i.key,\n        value = _tuples$_i.value;\n\n    if (!toSkip[channel] && !out[key]) {\n      out[key] = value;\n    }\n  }\n\n  return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config) {\n  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      reactiveGeom = _ref2.reactiveGeom;\n\n  var data = tooltipData(encoding, stack, config, {\n    reactiveGeom: reactiveGeom\n  });\n  var keyValues = entries(data).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        key = _ref4[0],\n        value = _ref4[1];\n\n    return \"\\\"\".concat(key, \"\\\": \").concat(value);\n  });\n  return keyValues.length > 0 ? {\n    signal: \"{\".concat(keyValues.join(', '), \"}\")\n  } : undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/tooltip.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model, opt = {}) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding.tooltip;\n    if (isArray(channelDef)) {\n        return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack, config, opt) };\n    }\n    else {\n        const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n        return wrapCondition(model, channelDef, 'tooltip', cDef => {\n            // use valueRef based on channelDef first\n            const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n            if (tooltipRefFromChannelDef) {\n                return tooltipRefFromChannelDef;\n            }\n            if (cDef === null) {\n                // Allow using encoding.tooltip = null to disable tooltip\n                return undefined;\n            }\n            let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n            if (markTooltip === true) {\n                markTooltip = { content: 'encoding' };\n            }\n            if (isString(markTooltip)) {\n                return { value: markTooltip };\n            }\n            else if (isObject(markTooltip)) {\n                // `tooltip` is `{fields: 'encodings' | 'fields'}`\n                if (isSignalRef(markTooltip)) {\n                    return markTooltip;\n                }\n                else if (markTooltip.content === 'encoding') {\n                    return tooltipRefForEncoding(encoding, stack, config, opt);\n                }\n                else {\n                    return { signal: datum };\n                }\n            }\n            return undefined;\n        });\n    }\n}\nexport function tooltipData(encoding, stack, config, { reactiveGeom } = {}) {\n    const toSkip = {};\n    const expr = reactiveGeom ? 'datum.datum' : 'datum';\n    const tuples = [];\n    function add(fDef, channel) {\n        const mainChannel = getMainRangeChannel(channel);\n        const fieldDef = isTypedFieldDef(fDef)\n            ? fDef\n            : Object.assign(Object.assign({}, fDef), { type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n             });\n        const title = fieldDef.title || defaultTitle(fieldDef, config);\n        const key = array(title).join(', ');\n        let value;\n        if (isXorY(channel)) {\n            const channel2 = channel === 'x' ? 'x2' : 'y2';\n            const fieldDef2 = getFieldDef(encoding[channel2]);\n            if (isBinned(fieldDef.bin) && fieldDef2) {\n                const startField = vgField(fieldDef, { expr });\n                const endField = vgField(fieldDef2, { expr });\n                const { format, formatType } = getFormatMixins(fieldDef);\n                value = binFormatExpression(startField, endField, format, formatType, config);\n                toSkip[channel2] = true;\n            }\n            else if (stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n                const { format, formatType } = getFormatMixins(fieldDef);\n                value = formatSignalRef({\n                    fieldOrDatumDef: fieldDef,\n                    format,\n                    formatType,\n                    expr,\n                    config,\n                    normalizeStack: true\n                }).signal;\n            }\n        }\n        value !== null && value !== void 0 ? value : (value = textRef(fieldDef, config, expr).signal);\n        tuples.push({ channel, key, value });\n    }\n    forEach(encoding, (channelDef, channel) => {\n        if (isFieldDef(channelDef)) {\n            add(channelDef, channel);\n        }\n        else if (hasConditionalFieldDef(channelDef)) {\n            add(channelDef.condition, channel);\n        }\n    });\n    const out = {};\n    for (const { channel, key, value } of tuples) {\n        if (!toSkip[channel] && !out[key]) {\n            out[key] = value;\n        }\n    }\n    return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config, { reactiveGeom } = {}) {\n    const data = tooltipData(encoding, stack, config, { reactiveGeom });\n    const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n    return keyValues.length > 0 ? { signal: `{${keyValues.join(', ')}}` } : undefined;\n}\n//# sourceMappingURL=tooltip.js.map"]},"metadata":{},"sourceType":"module"}