{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { getSizeChannel, isColorChannel, isScaleChannel, rangeType } from '../../channel';\nimport { isFieldDef, isPositionFieldOrDatumDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isRelativeBandSize } from '../../mark';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { POLAR_POSITION_SCALE_CHANNEL_INDEX, POSITION_SCALE_CHANNEL_INDEX } from './../../channel';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\n\nexport function scaleType(specifiedScale, channel, fieldDef, mark) {\n  var defaultScaleType = defaultType(channel, fieldDef, mark);\n  var type = specifiedScale.type;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    } // Check if explicitly specified scale type is supported by the data type\n\n\n    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\n\nfunction defaultType(channel, fieldDef, mark) {\n  var _a;\n\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      {\n        if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n          if (channel === 'shape' && fieldDef.type === 'ordinal') {\n            log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n          }\n\n          return 'ordinal';\n        }\n\n        if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n          if (util.contains(['rect', 'bar', 'image', 'rule'], mark.type)) {\n            // The rect/bar mark should fit into a band.\n            // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n            return 'band';\n          }\n        } else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n          return 'band';\n        }\n\n        var dimensionSize = mark[getSizeChannel(channel)];\n\n        if (isRelativeBandSize(dimensionSize)) {\n          return 'band';\n        }\n\n        if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {\n          return 'band';\n        } // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n\n\n        return 'point';\n      }\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal')); // TODO: consider using quantize (equivalent to binning) once we have it\n\n        return 'ordinal';\n      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n        return 'utc';\n      }\n\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative')); // TODO: consider using quantize (equivalent to binning) once we have it\n\n        return 'ordinal';\n      }\n\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach this */\n\n\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}","map":{"version":3,"sources":["../../../../src/compile/scale/type.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isBinning } from '../../bin';\nimport { getSizeChannel, isColorChannel, isScaleChannel, rangeType } from '../../channel';\nimport { isFieldDef, isPositionFieldOrDatumDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isRelativeBandSize } from '../../mark';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { POLAR_POSITION_SCALE_CHANNEL_INDEX, POSITION_SCALE_CHANNEL_INDEX } from './../../channel';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(specifiedScale, channel, fieldDef, mark) {\n    const defaultScaleType = defaultType(channel, fieldDef, mark);\n    const { type } = specifiedScale;\n    if (!isScaleChannel(channel)) {\n        // There is no scale for these channels\n        return null;\n    }\n    if (type !== undefined) {\n        // Check if explicitly specified scale type is supported by the channel\n        if (!channelSupportScaleType(channel, type)) {\n            log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n            return defaultScaleType;\n        }\n        // Check if explicitly specified scale type is supported by the data type\n        if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n            log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n            return defaultScaleType;\n        }\n        return type;\n    }\n    return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(channel, fieldDef, mark) {\n    var _a;\n    switch (fieldDef.type) {\n        case 'nominal':\n        case 'ordinal': {\n            if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n                if (channel === 'shape' && fieldDef.type === 'ordinal') {\n                    log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n                }\n                return 'ordinal';\n            }\n            if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n                if (util.contains(['rect', 'bar', 'image', 'rule'], mark.type)) {\n                    // The rect/bar mark should fit into a band.\n                    // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n                    return 'band';\n                }\n            }\n            else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n                return 'band';\n            }\n            const dimensionSize = mark[getSizeChannel(channel)];\n            if (isRelativeBandSize(dimensionSize)) {\n                return 'band';\n            }\n            if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {\n                return 'band';\n            }\n            // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n            return 'point';\n        }\n        case 'temporal':\n            if (isColorChannel(channel)) {\n                return 'time';\n            }\n            else if (rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n                return 'utc';\n            }\n            return 'time';\n        case 'quantitative':\n            if (isColorChannel(channel)) {\n                if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n                    return 'bin-ordinal';\n                }\n                return 'linear';\n            }\n            else if (rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            return 'linear';\n        case 'geojson':\n            return undefined;\n    }\n    /* istanbul ignore next: should never reach this */\n    throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n//# sourceMappingURL=type.js.map"]},"metadata":{},"sourceType":"module"}