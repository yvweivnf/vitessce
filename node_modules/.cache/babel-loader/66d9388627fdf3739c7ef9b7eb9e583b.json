{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Vector3, Matrix3, Quaternion } from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport { INTERSECTION } from '../../constants';\nvar scratchVector3 = new Vector3();\nvar scratchOffset = new Vector3();\nvar scratchVectorU = new Vector3();\nvar scratchVectorV = new Vector3();\nvar scratchVectorW = new Vector3();\nvar scratchCorner = new Vector3();\nvar scratchToCenter = new Vector3();\nvar MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nvar OrientedBoundingBox = /*#__PURE__*/function () {\n  function OrientedBoundingBox() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    _classCallCheck(this, OrientedBoundingBox);\n\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  _createClass(OrientedBoundingBox, [{\n    key: \"fromCenterHalfSizeQuaternion\",\n    value: function fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n      var quaternionObject = new Quaternion(quaternion);\n      var directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n      this.center = new Vector3().from(center);\n      this.halfAxes = directionsMatrix;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new OrientedBoundingBox(this.center, this.halfAxes);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n    }\n  }, {\n    key: \"getBoundingSphere\",\n    value: function getBoundingSphere() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BoundingSphere();\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var cornerVector = scratchVector3.copy(u).add(v).add(w);\n      result.center.copy(this.center);\n      result.radius = cornerVector.magnitude();\n      return result;\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var center = this.center;\n      var normal = plane.normal;\n      var halfAxes = this.halfAxes;\n      var normalX = normal.x;\n      var normalY = normal.y;\n      var normalZ = normal.z;\n      var radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n      var distanceToPlane = normal.dot(center) + plane.distance;\n\n      if (distanceToPlane <= -radEffective) {\n        return INTERSECTION.OUTSIDE;\n      } else if (distanceToPlane >= radEffective) {\n        return INTERSECTION.INSIDE;\n      }\n\n      return INTERSECTION.INTERSECTING;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var offset = scratchOffset.from(point).subtract(this.center);\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var uHalf = u.magnitude();\n      var vHalf = v.magnitude();\n      var wHalf = w.magnitude();\n      u.normalize();\n      v.normalize();\n      w.normalize();\n      var distanceSquared = 0.0;\n      var d;\n      d = Math.abs(offset.dot(u)) - uHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.dot(v)) - vHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.dot(w)) - wHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      return distanceSquared;\n    }\n  }, {\n    key: \"computePlaneDistances\",\n    value: function computePlaneDistances(position, direction) {\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-0, -0];\n      var minDist = Number.POSITIVE_INFINITY;\n      var maxDist = Number.NEGATIVE_INFINITY;\n      var center = this.center;\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var corner = scratchCorner.copy(u).add(v).add(w).add(center);\n      var toCenter = scratchToCenter.copy(corner).subtract(position);\n      var mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      result[0] = minDist;\n      result[1] = maxDist;\n      return result;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(transformation) {\n      this.center.transformAsPoint(transformation);\n      var xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n      xAxis.transformAsPoint(transformation);\n      var yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n      yAxis.transformAsPoint(transformation);\n      var zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n      zAxis.transformAsPoint(transformation);\n      this.halfAxes = new Matrix3([].concat(_toConsumableArray(xAxis), _toConsumableArray(yAxis), _toConsumableArray(zAxis)));\n      return this;\n    }\n  }, {\n    key: \"getTransform\",\n    value: function getTransform() {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"halfSize\",\n    get: function get() {\n      var xAxis = this.halfAxes.getColumn(0);\n      var yAxis = this.halfAxes.getColumn(1);\n      var zAxis = this.halfAxes.getColumn(2);\n      return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n    }\n  }, {\n    key: \"quaternion\",\n    get: function get() {\n      var xAxis = this.halfAxes.getColumn(0);\n      var yAxis = this.halfAxes.getColumn(1);\n      var zAxis = this.halfAxes.getColumn(2);\n      var normXAxis = new Vector3(xAxis).normalize();\n      var normYAxis = new Vector3(yAxis).normalize();\n      var normZAxis = new Vector3(zAxis).normalize();\n      return new Quaternion().fromMatrix3(new Matrix3([].concat(_toConsumableArray(normXAxis), _toConsumableArray(normYAxis), _toConsumableArray(normZAxis))));\n    }\n  }]);\n\n  return OrientedBoundingBox;\n}();\n\nexport { OrientedBoundingBox as default };","map":{"version":3,"sources":["../../../../src/lib/bounding-volumes/oriented-bounding-box.js"],"names":["scratchVector3","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchCorner","scratchToCenter","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","constructor","center","halfAxes","xAxis","yAxis","zAxis","normXAxis","normYAxis","normZAxis","quaternionObject","directionsMatrix","halfSize","Boolean","right","result","u","v","w","cornerVector","normal","plane","normalX","normalY","normalZ","radEffective","Math","distanceToPlane","INTERSECTION","offset","uHalf","vHalf","wHalf","distanceSquared","d","minDist","Number","maxDist","corner","toCenter","mag","direction"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Quaternion} from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nexport default class OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}