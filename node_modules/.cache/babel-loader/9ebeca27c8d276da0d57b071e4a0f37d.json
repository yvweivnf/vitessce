{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImmutableFeatureCollection = void 0;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ImmutableFeatureCollection = /*#__PURE__*/function () {\n  function ImmutableFeatureCollection(featureCollection) {\n    _classCallCheck(this, ImmutableFeatureCollection);\n\n    _defineProperty(this, \"featureCollection\", void 0);\n\n    this.featureCollection = featureCollection;\n  }\n\n  _createClass(ImmutableFeatureCollection, [{\n    key: \"getObject\",\n    value: function getObject() {\n      return this.featureCollection;\n    }\n    /**\n     * Replaces the position deeply nested withing the given feature's geometry.\n     * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the position to replace\n     * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"replacePosition\",\n    value: function replacePosition(featureIndex, positionIndexes, updatedPosition) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyReplacePosition(geometry.coordinates, positionIndexes, updatedPosition, isPolygonal)\n      });\n\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n    /**\n     * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the postion to remove\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"removePosition\",\n    value: function removePosition(featureIndex, positionIndexes) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n\n      if (geometry.type === 'Point') {\n        throw Error(\"Can't remove a position from a Point or there'd be nothing left\");\n      }\n\n      if (geometry.type === 'MultiPoint' && // only 1 point left\n      geometry.coordinates.length < 2) {\n        throw Error(\"Can't remove the last point of a MultiPoint or there'd be nothing left\");\n      }\n\n      if (geometry.type === 'LineString' && // only 2 positions\n      geometry.coordinates.length < 3) {\n        throw Error(\"Can't remove position. LineString must have at least two positions\");\n      }\n\n      if (geometry.type === 'Polygon' && // outer ring is a triangle\n      geometry.coordinates[0].length < 5 && Array.isArray(positionIndexes) && // trying to remove from outer ring\n      positionIndexes[0] === 0) {\n        throw Error(\"Can't remove position. Polygon's outer ring must have at least four positions\");\n      }\n\n      if (geometry.type === 'MultiLineString' && // only 1 LineString left\n      geometry.coordinates.length === 1 && // only 2 positions\n      geometry.coordinates[0].length < 3) {\n        throw Error(\"Can't remove position. MultiLineString must have at least two positions\");\n      }\n\n      if (geometry.type === 'MultiPolygon' && // only 1 polygon left\n      geometry.coordinates.length === 1 && // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 && Array.isArray(positionIndexes) && // trying to remove from first polygon\n      positionIndexes[0] === 0 && // trying to remove from outer ring\n      positionIndexes[1] === 0) {\n        throw Error(\"Can't remove position. MultiPolygon's outer ring must have at least four positions\");\n      }\n\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)\n      }); // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n\n\n      pruneGeometryIfNecessary(updatedGeometry);\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n    /**\n     * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the position that will proceed the new position\n     * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"addPosition\",\n    value: function addPosition(featureIndex, positionIndexes, positionToAdd) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n\n      if (geometry.type === 'Point') {\n        throw new Error('Unable to add a position to a Point feature');\n      }\n\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyAddPosition(geometry.coordinates, positionIndexes, positionToAdd, isPolygonal)\n      });\n\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n  }, {\n    key: \"replaceGeometry\",\n    value: function replaceGeometry(featureIndex, geometry) {\n      var updatedFeature = _objectSpread({}, this.featureCollection.features[featureIndex], {\n        geometry: geometry\n      });\n\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: [].concat(_toConsumableArray(this.featureCollection.features.slice(0, featureIndex)), [updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }, {\n    key: \"addFeature\",\n    value: function addFeature(feature) {\n      return this.addFeatures([feature]);\n    }\n  }, {\n    key: \"addFeatures\",\n    value: function addFeatures(features) {\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: [].concat(_toConsumableArray(this.featureCollection.features), _toConsumableArray(features))\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }, {\n    key: \"deleteFeature\",\n    value: function deleteFeature(featureIndex) {\n      return this.deleteFeatures([featureIndex]);\n    }\n  }, {\n    key: \"deleteFeatures\",\n    value: function deleteFeatures(featureIndexes) {\n      var features = _toConsumableArray(this.featureCollection.features);\n\n      featureIndexes.sort();\n\n      for (var i = featureIndexes.length - 1; i >= 0; i--) {\n        var featureIndex = featureIndexes[i];\n\n        if (featureIndex >= 0 && featureIndex < features.length) {\n          features.splice(featureIndex, 1);\n        }\n      }\n\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: features\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }]);\n\n  return ImmutableFeatureCollection;\n}();\n\nexports.ImmutableFeatureCollection = ImmutableFeatureCollection;\n\nfunction getUpdatedPosition(updatedPosition, previousPosition) {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    var elevation = previousPosition[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(coordinates, positionIndexes, updatedPosition, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]])], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n\n    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n\n    return updated;\n  } // recursively update inner array\n\n\n  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyReplacePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), updatedPosition, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction immutablyRemovePosition(coordinates, positionIndexes, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n\n    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n\n    return updated;\n  } // recursively update inner array\n\n\n  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyRemovePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction immutablyAddPosition(coordinates, positionIndexes, positionToAdd, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [positionToAdd], _toConsumableArray(coordinates.slice(positionIndexes[0])));\n    return updated;\n  } // recursively update inner array\n\n\n  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyAddPosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), positionToAdd, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction pruneGeometryIfNecessary(geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry) {\n  var polygon = geometry.coordinates; // If any hole is no longer a polygon, remove the hole entirely\n\n  for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry) {\n  for (var lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    var lineString = geometry.coordinates[lineStringIndex];\n\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1); // Keep the index the same\n\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry) {\n  for (var polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    var polygon = geometry.coordinates[polygonIndex];\n    var outerRing = polygon[0]; // If the outer ring is no longer a polygon, remove the whole polygon\n\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1); // It was removed, so keep the index the same\n\n      polygonIndex--;\n    }\n\n    for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon, holeIndex) {\n  var hole = polygon[holeIndex];\n\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../src/lib/immutable-feature-collection.ts"],"names":["ImmutableFeatureCollection","featureIndex","positionIndexes","updatedPosition","geometry","isPolygonal","updatedGeometry","coordinates","immutablyReplacePosition","Error","Array","immutablyRemovePosition","pruneGeometryIfNecessary","positionToAdd","immutablyAddPosition","updatedFeature","updatedFeatureCollection","features","feature","featureIndexes","i","previousPosition","elevation","getUpdatedPosition","updated","prunePolygonIfNecessary","pruneMultiLineStringIfNecessary","pruneMultiPolygonIfNecessary","polygon","holeIndex","removeHoleIfNecessary","lineStringIndex","lineString","polygonIndex","outerRing","hole"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAWaA,0B;AAGX,WAAA,0BAAA,CAAA,iBAAA,EAAkD;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,0BAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,mBAAA,EAAA,KAAA,CAAA,CAAA;;AAChD,SAAA,iBAAA,GAAA,iBAAA;AACD;;;;gCAEW;AACV,aAAO,KAAP,iBAAA;AACD;AAED;;;;;;;;;;;;;oCAWEC,Y,EACAC,e,EACAC,e,EAC4B;AAC5B,UAAMC,QAAQ,GAAG,KAAA,iBAAA,CAAA,QAAA,CAAA,YAAA,EAAjB,QAAA;AAEA,UAAMC,WAAW,GAAGD,QAAQ,CAARA,IAAAA,KAAAA,SAAAA,IAA+BA,QAAQ,CAARA,IAAAA,KAAnD,cAAA;;AACA,UAAME,eAAoB,GAAA,aAAA,CAAA,EAAA,EAAA,QAAA,EAAA;AAExBC,QAAAA,WAAW,EAAEC,wBAAwB,CACnCJ,QAAQ,CAD2B,WAAA,EAAA,eAAA,EAAA,eAAA,EAAA,WAAA;AAFb,OAAA,CAA1B;;AAUA,aAAO,KAAA,eAAA,CAAA,YAAA,EAAP,eAAO,CAAP;AACD;AAED;;;;;;;;;;;;mCAUEH,Y,EACAC,e,EAC4B;AAC5B,UAAME,QAAQ,GAAG,KAAA,iBAAA,CAAA,QAAA,CAAA,YAAA,EAAjB,QAAA;;AAEA,UAAIA,QAAQ,CAARA,IAAAA,KAAJ,OAAA,EAA+B;AAC7B,cAAMK,KAAK,CAAX,iEAAW,CAAX;AACD;;AACD,UACEL,QAAQ,CAARA,IAAAA,KAAAA,YAAAA,IAAkC;AAClCA,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,GAFF,CAAA,EAGE;AACA,cAAMK,KAAK,CAAX,wEAAW,CAAX;AACD;;AACD,UACEL,QAAQ,CAARA,IAAAA,KAAAA,YAAAA,IAAkC;AAClCA,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,GAFF,CAAA,EAGE;AACA,cAAMK,KAAK,CAAX,oEAAW,CAAX;AACD;;AACD,UACEL,QAAQ,CAARA,IAAAA,KAAAA,SAAAA,IAA+B;AAC/BA,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,CAAAA,EAAAA,MAAAA,GADAA,CAAAA,IAEAM,KAAK,CAALA,OAAAA,CAFAN,eAEAM,CAFAN,IAEkC;AAClCF,MAAAA,eAAe,CAAfA,CAAe,CAAfA,KAJF,CAAA,EAKE;AACA,cAAMO,KAAK,CAAX,+EAAW,CAAX;AACD;;AACD,UACEL,QAAQ,CAARA,IAAAA,KAAAA,iBAAAA,IAAuC;AACvCA,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,KADAA,CAAAA,IACqC;AACrCA,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,CAAAA,EAAAA,MAAAA,GAHF,CAAA,EAIE;AACA,cAAMK,KAAK,CAAX,yEAAW,CAAX;AACD;;AACD,UACEL,QAAQ,CAARA,IAAAA,KAAAA,cAAAA,IAAoC;AACpCA,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,KADAA,CAAAA,IACqC;AACrCA,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,MAAAA,GAFAA,CAAAA,IAGAM,KAAK,CAALA,OAAAA,CAHAN,eAGAM,CAHAN,IAGkC;AAClCF,MAAAA,eAAe,CAAfA,CAAe,CAAfA,KAJAE,CAAAA,IAI4B;AAC5BF,MAAAA,eAAe,CAAfA,CAAe,CAAfA,KANF,CAAA,EAOE;AACA,cAAMO,KAAK,CAAX,oFAAW,CAAX;AAGD;;AAED,UAAMJ,WAAW,GAAGD,QAAQ,CAARA,IAAAA,KAAAA,SAAAA,IAA+BA,QAAQ,CAARA,IAAAA,KAAnD,cAAA;;AACA,UAAME,eAAoB,GAAA,aAAA,CAAA,EAAA,EAAA,QAAA,EAAA;AAExBC,QAAAA,WAAW,EAAEI,uBAAuB,CAACP,QAAQ,CAAT,WAAA,EAAA,eAAA,EAAA,WAAA;AAFZ,OAAA,CAA1B,CA/C4B,CAoD5B;;;AACAQ,MAAAA,wBAAwB,CAAxBA,eAAwB,CAAxBA;AAEA,aAAO,KAAA,eAAA,CAAA,YAAA,EAAP,eAAO,CAAP;AACD;AAED;;;;;;;;;;;;;gCAWEX,Y,EACAC,e,EACAW,a,EAC4B;AAC5B,UAAMT,QAAQ,GAAG,KAAA,iBAAA,CAAA,QAAA,CAAA,YAAA,EAAjB,QAAA;;AAEA,UAAIA,QAAQ,CAARA,IAAAA,KAAJ,OAAA,EAA+B;AAC7B,cAAM,IAAA,KAAA,CAAN,6CAAM,CAAN;AACD;;AAED,UAAMC,WAAW,GAAGD,QAAQ,CAARA,IAAAA,KAAAA,SAAAA,IAA+BA,QAAQ,CAARA,IAAAA,KAAnD,cAAA;;AACA,UAAME,eAAoB,GAAA,aAAA,CAAA,EAAA,EAAA,QAAA,EAAA;AAExBC,QAAAA,WAAW,EAAEO,oBAAoB,CAC/BV,QAAQ,CADuB,WAAA,EAAA,eAAA,EAAA,aAAA,EAAA,WAAA;AAFT,OAAA,CAA1B;;AAUA,aAAO,KAAA,eAAA,CAAA,YAAA,EAAP,eAAO,CAAP;AACD;;;oCAEeH,Y,EAAsBG,Q,EAAgD;AACpF,UAAMW,cAAmB,GAAA,aAAA,CAAA,EAAA,EACpB,KAAA,iBAAA,CAAA,QAAA,CADoB,YACpB,CADoB,EAAA;AAEvBX,QAAAA,QAAQ,EAARA;AAFuB,OAAA,CAAzB;;AAKA,UAAMY,wBAAwB,GAAA,aAAA,CAAA,EAAA,EACzB,KADyB,iBAAA,EAAA;AAE5BC,QAAAA,QAAQ,EAAA,GAAA,MAAA,CAAA,kBAAA,CACH,KAAA,iBAAA,CAAA,QAAA,CAAA,KAAA,CAAA,CAAA,EADG,YACH,CADG,CAAA,EAAA,CAAA,cAAA,CAAA,EAAA,kBAAA,CAGH,KAAA,iBAAA,CAAA,QAAA,CAAA,KAAA,CAAsChB,YAAY,GAH/C,CAGH,CAHG,CAAA;AAFoB,OAAA,CAA9B;;AASA,aAAO,IAAA,0BAAA,CAAP,wBAAO,CAAP;AACD;;;+BAEUiB,O,EAA8C;AACvD,aAAO,KAAA,WAAA,CAAiB,CAAxB,OAAwB,CAAjB,CAAP;AACD;;;gCAEWD,Q,EAAiD;AAC3D,UAAMD,wBAAwB,GAAA,aAAA,CAAA,EAAA,EACzB,KADyB,iBAAA,EAAA;AAE5BC,QAAAA,QAAQ,EAAA,GAAA,MAAA,CAAA,kBAAA,CAAM,KAAA,iBAAA,CAAN,QAAA,CAAA,EAAA,kBAAA,CAAA,QAAA,CAAA;AAFoB,OAAA,CAA9B;;AAKA,aAAO,IAAA,0BAAA,CAAP,wBAAO,CAAP;AACD;;;kCAEahB,Y,EAAsB;AAClC,aAAO,KAAA,cAAA,CAAoB,CAA3B,YAA2B,CAApB,CAAP;AACD;;;mCAEckB,c,EAA0B;AACvC,UAAMF,QAAQ,GAAA,kBAAA,CAAO,KAAA,iBAAA,CAArB,QAAc,CAAd;;AACAE,MAAAA,cAAc,CAAdA,IAAAA;;AACA,WAAK,IAAIC,CAAC,GAAGD,cAAc,CAAdA,MAAAA,GAAb,CAAA,EAAwCC,CAAC,IAAzC,CAAA,EAAgDA,CAAhD,EAAA,EAAqD;AACnD,YAAMnB,YAAY,GAAGkB,cAAc,CAAnC,CAAmC,CAAnC;;AACA,YAAIlB,YAAY,IAAZA,CAAAA,IAAqBA,YAAY,GAAGgB,QAAQ,CAAhD,MAAA,EAAyD;AACvDA,UAAAA,QAAQ,CAARA,MAAAA,CAAAA,YAAAA,EAAAA,CAAAA;AACD;AACF;;AAED,UAAMD,wBAAwB,GAAA,aAAA,CAAA,EAAA,EACzB,KADyB,iBAAA,EAAA;AAE5BC,QAAAA,QAAQ,EAARA;AAF4B,OAAA,CAA9B;;AAKA,aAAO,IAAA,0BAAA,CAAP,wBAAO,CAAP;AACD;;;;;;;;AAGH,SAAA,kBAAA,CAAA,eAAA,EAAA,gBAAA,EAA6F;AAC3F;AACA;AACA,MAAId,eAAe,CAAfA,MAAAA,KAAAA,CAAAA,IAAgCkB,gBAAgB,CAAhBA,MAAAA,KAApC,CAAA,EAAmE;AACjE,QAAMC,SAAS,GAAID,gBAAD,CAAlB,CAAkB,CAAlB;AACA,WAAO,CAAClB,eAAe,CAAhB,CAAgB,CAAhB,EAAqBA,eAAe,CAApC,CAAoC,CAApC,EAAP,SAAO,CAAP;AACD;;AAED,SAAA,eAAA;AACD;;AAED,SAAA,wBAAA,CAAA,WAAA,EAAA,eAAA,EAAA,eAAA,EAAA,WAAA,EAKO;AACL,MAAI,CAAJ,eAAA,EAAsB;AACpB,WAAA,WAAA;AACD;;AACD,MAAID,eAAe,CAAfA,MAAAA,KAAJ,CAAA,EAAkC;AAChC,WAAOqB,kBAAkB,CAAA,eAAA,EAAzB,WAAyB,CAAzB;AACD;;AACD,MAAIrB,eAAe,CAAfA,MAAAA,KAAJ,CAAA,EAAkC;AAChC,QAAMsB,OAAO,GAAA,GAAA,MAAA,CAAA,kBAAA,CACRjB,WAAW,CAAXA,KAAAA,CAAAA,CAAAA,EAAqBL,eAAe,CAD5B,CAC4B,CAApCK,CADQ,CAAA,EAAA,CAEXgB,kBAAkB,CAAA,eAAA,EAAkBhB,WAAW,CAACL,eAAe,CAFpD,CAEoD,CAAhB,CAA7B,CAFP,CAAA,EAAA,kBAAA,CAGRK,WAAW,CAAXA,KAAAA,CAAkBL,eAAe,CAAfA,CAAe,CAAfA,GAHvB,CAGKK,CAHQ,CAAA,CAAb;;AAMA,QACEF,WAAW,KACVH,eAAe,CAAfA,CAAe,CAAfA,KAAAA,CAAAA,IAA4BA,eAAe,CAAfA,CAAe,CAAfA,KAAuBK,WAAW,CAAXA,MAAAA,GAFtD,CACa,CADb,EAGE;AACA;AACA;AACAiB,MAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAaD,kBAAkB,CAAA,eAAA,EAAkBhB,WAAW,CAA5DiB,CAA4D,CAA7B,CAA/BA;AACAA,MAAAA,OAAO,CAACjB,WAAW,CAAXA,MAAAA,GAARiB,CAAO,CAAPA,GAAkCD,kBAAkB,CAAA,eAAA,EAAkBhB,WAAW,CAAjFiB,CAAiF,CAA7B,CAApDA;AACD;;AACD,WAAA,OAAA;AAvBG,GAAA,CA0BL;;;AACA,SAAA,GAAA,MAAA,CAAA,kBAAA,CACKjB,WAAW,CAAXA,KAAAA,CAAAA,CAAAA,EAAqBL,eAAe,CADzC,CACyC,CAApCK,CADL,CAAA,EAAA,CAEEC,wBAAwB,CACtBD,WAAW,CAACL,eAAe,CADL,CACK,CAAhB,CADW,EAEtBA,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EAAyBA,eAAe,CAFlB,MAEtBA,CAFsB,EAAA,eAAA,EAF1B,WAE0B,CAF1B,CAAA,EAAA,kBAAA,CAQKK,WAAW,CAAXA,KAAAA,CAAkBL,eAAe,CAAfA,CAAe,CAAfA,GARvB,CAQKK,CARL,CAAA,CAAA;AAUD;;AAED,SAAA,uBAAA,CAAA,WAAA,EAAA,eAAA,EAAA,WAAA,EAIO;AACL,MAAI,CAAJ,eAAA,EAAsB;AACpB,WAAA,WAAA;AACD;;AACD,MAAIL,eAAe,CAAfA,MAAAA,KAAJ,CAAA,EAAkC;AAChC,UAAMO,KAAK,CAAX,kDAAW,CAAX;AACD;;AACD,MAAIP,eAAe,CAAfA,MAAAA,KAAJ,CAAA,EAAkC;AAChC,QAAMsB,OAAO,GAAA,GAAA,MAAA,CAAA,kBAAA,CACRjB,WAAW,CAAXA,KAAAA,CAAAA,CAAAA,EAAqBL,eAAe,CAD5B,CAC4B,CAApCK,CADQ,CAAA,EAAA,kBAAA,CAERA,WAAW,CAAXA,KAAAA,CAAkBL,eAAe,CAAfA,CAAe,CAAfA,GAFvB,CAEKK,CAFQ,CAAA,CAAb;;AAKA,QACEF,WAAW,KACVH,eAAe,CAAfA,CAAe,CAAfA,KAAAA,CAAAA,IAA4BA,eAAe,CAAfA,CAAe,CAAfA,KAAuBK,WAAW,CAAXA,MAAAA,GAFtD,CACa,CADb,EAGE;AACA;AACA;AACA,UAAIL,eAAe,CAAfA,CAAe,CAAfA,KAAJ,CAAA,EAA8B;AAC5B;AACAsB,QAAAA,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAARA,CAAO,CAAPA,GAA8BA,OAAO,CAArCA,CAAqC,CAArCA;AAFF,OAAA,MAGO,IAAItB,eAAe,CAAfA,CAAe,CAAfA,KAAuBK,WAAW,CAAXA,MAAAA,GAA3B,CAAA,EAAmD;AACxD;AACAiB,QAAAA,OAAO,CAAPA,CAAO,CAAPA,GAAaA,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAArBA,CAAoB,CAApBA;AACD;AACF;;AACD,WAAA,OAAA;AA3BG,GAAA,CA8BL;;;AACA,SAAA,GAAA,MAAA,CAAA,kBAAA,CACKjB,WAAW,CAAXA,KAAAA,CAAAA,CAAAA,EAAqBL,eAAe,CADzC,CACyC,CAApCK,CADL,CAAA,EAAA,CAEEI,uBAAuB,CACrBJ,WAAW,CAACL,eAAe,CADN,CACM,CAAhB,CADU,EAErBA,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EAAyBA,eAAe,CAFnB,MAErBA,CAFqB,EAFzB,WAEyB,CAFzB,CAAA,EAAA,kBAAA,CAOKK,WAAW,CAAXA,KAAAA,CAAkBL,eAAe,CAAfA,CAAe,CAAfA,GAPvB,CAOKK,CAPL,CAAA,CAAA;AASD;;AAED,SAAA,oBAAA,CAAA,WAAA,EAAA,eAAA,EAAA,aAAA,EAAA,WAAA,EAKO;AACL,MAAI,CAAJ,eAAA,EAAsB;AACpB,WAAA,WAAA;AACD;;AACD,MAAIL,eAAe,CAAfA,MAAAA,KAAJ,CAAA,EAAkC;AAChC,UAAMO,KAAK,CAAX,kDAAW,CAAX;AACD;;AACD,MAAIP,eAAe,CAAfA,MAAAA,KAAJ,CAAA,EAAkC;AAChC,QAAMsB,OAAO,GAAA,GAAA,MAAA,CAAA,kBAAA,CACRjB,WAAW,CAAXA,KAAAA,CAAAA,CAAAA,EAAqBL,eAAe,CAD5B,CAC4B,CAApCK,CADQ,CAAA,EAAA,CAAA,aAAA,CAAA,EAAA,kBAAA,CAGRA,WAAW,CAAXA,KAAAA,CAAkBL,eAAe,CAHtC,CAGsC,CAAjCK,CAHQ,CAAA,CAAb;AAKA,WAAA,OAAA;AAbG,GAAA,CAgBL;;;AACA,SAAA,GAAA,MAAA,CAAA,kBAAA,CACKA,WAAW,CAAXA,KAAAA,CAAAA,CAAAA,EAAqBL,eAAe,CADzC,CACyC,CAApCK,CADL,CAAA,EAAA,CAEEO,oBAAoB,CAClBP,WAAW,CAACL,eAAe,CADT,CACS,CAAhB,CADO,EAElBA,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EAAyBA,eAAe,CAFtB,MAElBA,CAFkB,EAAA,aAAA,EAFtB,WAEsB,CAFtB,CAAA,EAAA,kBAAA,CAQKK,WAAW,CAAXA,KAAAA,CAAkBL,eAAe,CAAfA,CAAe,CAAfA,GARvB,CAQKK,CARL,CAAA,CAAA;AAUD;;AAED,SAAA,wBAAA,CAAA,QAAA,EAAsD;AACpD,UAAQH,QAAQ,CAAhB,IAAA;AACE,SAAA,SAAA;AACEqB,MAAAA,uBAAuB,CAAvBA,QAAuB,CAAvBA;AACA;;AACF,SAAA,iBAAA;AACEC,MAAAA,+BAA+B,CAA/BA,QAA+B,CAA/BA;AACA;;AACF,SAAA,cAAA;AACEC,MAAAA,4BAA4B,CAA5BA,QAA4B,CAA5BA;AACA;;AACF;AACE;AACA;AAZJ;AAcD;;AAED,SAAA,uBAAA,CAAA,QAAA,EAAoD;AAClD,MAAMC,OAAO,GAAGxB,QAAQ,CAD0B,WAClD,CADkD,CAGlD;;AACA,OAAK,IAAIyB,SAAS,GAAlB,CAAA,EAAwBA,SAAS,GAAGD,OAAO,CAA3C,MAAA,EAAoDC,SAApD,EAAA,EAAiE;AAC/D,QAAIC,qBAAqB,CAAA,OAAA,EAAzB,SAAyB,CAAzB,EAA+C;AAC7C;AACAD,MAAAA,SAAS;AACV;AACF;AACF;;AAED,SAAA,+BAAA,CAAA,QAAA,EAAoE;AAClE,OAAK,IAAIE,eAAe,GAAxB,CAAA,EAA8BA,eAAe,GAAG3B,QAAQ,CAARA,WAAAA,CAAhD,MAAA,EAA6E2B,eAA7E,EAAA,EAAgG;AAC9F,QAAMC,UAAU,GAAG5B,QAAQ,CAARA,WAAAA,CAAnB,eAAmBA,CAAnB;;AACA,QAAI4B,UAAU,CAAVA,MAAAA,KAAJ,CAAA,EAA6B;AAC3B;AACA5B,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,CAAAA,eAAAA,EAF2B,CAE3BA,EAF2B,CAG3B;;AACA2B,MAAAA,eAAe;AAChB;AACF;AACF;;AAED,SAAA,4BAAA,CAAA,QAAA,EAA8D;AAC5D,OAAK,IAAIE,YAAY,GAArB,CAAA,EAA2BA,YAAY,GAAG7B,QAAQ,CAARA,WAAAA,CAA1C,MAAA,EAAuE6B,YAAvE,EAAA,EAAuF;AACrF,QAAML,OAAO,GAAGxB,QAAQ,CAARA,WAAAA,CAAhB,YAAgBA,CAAhB;AACA,QAAM8B,SAAS,GAAGN,OAAO,CAF4D,CAE5D,CAAzB,CAFqF,CAIrF;;AACA,QAAIM,SAAS,CAATA,MAAAA,IAAJ,CAAA,EAA2B;AACzB9B,MAAAA,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,CAAAA,YAAAA,EADyB,CACzBA,EADyB,CAEzB;;AACA6B,MAAAA,YAAY;AACb;;AAED,SAAK,IAAIJ,SAAS,GAAlB,CAAA,EAAwBA,SAAS,GAAGD,OAAO,CAA3C,MAAA,EAAoDC,SAApD,EAAA,EAAiE;AAC/D,UAAIC,qBAAqB,CAAA,OAAA,EAAzB,SAAyB,CAAzB,EAA+C;AAC7C;AACAD,QAAAA,SAAS;AACV;AACF;AACF;AACF;;AAED,SAAA,qBAAA,CAAA,OAAA,EAAA,SAAA,EAA+E;AAC7E,MAAMM,IAAI,GAAGP,OAAO,CAApB,SAAoB,CAApB;;AACA,MAAIO,IAAI,CAAJA,MAAAA,IAAJ,CAAA,EAAsB;AACpBP,IAAAA,OAAO,CAAPA,MAAAA,CAAAA,SAAAA,EAAAA,CAAAA;AACA,WAAA,IAAA;AACD;;AACD,SAAA,KAAA;AACD","sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  Polygon,\n  MultiLineString,\n  MultiPolygon,\n  Position,\n  PolygonCoordinates,\n} from '../geojson-types';\n\nexport class ImmutableFeatureCollection {\n  featureCollection: FeatureCollection;\n\n  constructor(featureCollection: FeatureCollection) {\n    this.featureCollection = featureCollection;\n  }\n\n  getObject() {\n    return this.featureCollection;\n  }\n\n  /**\n   * Replaces the position deeply nested withing the given feature's geometry.\n   * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position to replace\n   * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n   */\n  replacePosition(\n    featureIndex: number,\n    positionIndexes: number[] | null | undefined,\n    updatedPosition: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyReplacePosition(\n        geometry.coordinates,\n        positionIndexes,\n        updatedPosition,\n        isPolygonal\n      ),\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion to remove\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  removePosition(\n    featureIndex: number,\n    positionIndexes: number[] | null | undefined\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw Error(`Can't remove a position from a Point or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'MultiPoint' && // only 1 point left\n      geometry.coordinates.length < 2\n    ) {\n      throw Error(`Can't remove the last point of a MultiPoint or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'LineString' && // only 2 positions\n      geometry.coordinates.length < 3\n    ) {\n      throw Error(`Can't remove position. LineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'Polygon' && // outer ring is a triangle\n      geometry.coordinates[0].length < 5 &&\n      Array.isArray(positionIndexes) && // trying to remove from outer ring\n      positionIndexes[0] === 0\n    ) {\n      throw Error(`Can't remove position. Polygon's outer ring must have at least four positions`);\n    }\n    if (\n      geometry.type === 'MultiLineString' && // only 1 LineString left\n      geometry.coordinates.length === 1 && // only 2 positions\n      geometry.coordinates[0].length < 3\n    ) {\n      throw Error(`Can't remove position. MultiLineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'MultiPolygon' && // only 1 polygon left\n      geometry.coordinates.length === 1 && // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 &&\n      Array.isArray(positionIndexes) && // trying to remove from first polygon\n      positionIndexes[0] === 0 && // trying to remove from outer ring\n      positionIndexes[1] === 0\n    ) {\n      throw Error(\n        `Can't remove position. MultiPolygon's outer ring must have at least four positions`\n      );\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal),\n    };\n\n    // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n    pruneGeometryIfNecessary(updatedGeometry);\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position that will proceed the new position\n   * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  addPosition(\n    featureIndex: number,\n    positionIndexes: number[] | null | undefined,\n    positionToAdd: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw new Error('Unable to add a position to a Point feature');\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyAddPosition(\n        geometry.coordinates,\n        positionIndexes,\n        positionToAdd,\n        isPolygonal\n      ),\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  replaceGeometry(featureIndex: number, geometry: Geometry): ImmutableFeatureCollection {\n    const updatedFeature: any = {\n      ...this.featureCollection.features[featureIndex],\n      geometry,\n    };\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [\n        ...this.featureCollection.features.slice(0, featureIndex),\n        updatedFeature,\n        ...this.featureCollection.features.slice(featureIndex + 1),\n      ],\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  addFeature(feature: Feature): ImmutableFeatureCollection {\n    return this.addFeatures([feature]);\n  }\n\n  addFeatures(features: Feature[]): ImmutableFeatureCollection {\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [...this.featureCollection.features, ...features],\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  deleteFeature(featureIndex: number) {\n    return this.deleteFeatures([featureIndex]);\n  }\n\n  deleteFeatures(featureIndexes: number[]) {\n    const features = [...this.featureCollection.features];\n    featureIndexes.sort();\n    for (let i = featureIndexes.length - 1; i >= 0; i--) {\n      const featureIndex = featureIndexes[i];\n      if (featureIndex >= 0 && featureIndex < features.length) {\n        features.splice(featureIndex, 1);\n      }\n    }\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features,\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n}\n\nfunction getUpdatedPosition(updatedPosition: Position, previousPosition: Position): Position {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    const elevation = (previousPosition as any)[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(\n  coordinates: any,\n  positionIndexes: number[] | null | undefined,\n  updatedPosition: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]]),\n      ...coordinates.slice(positionIndexes[0] + 1),\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyReplacePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      updatedPosition,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1),\n  ];\n}\n\nfunction immutablyRemovePosition(\n  coordinates: any,\n  positionIndexes: number[] | null | undefined,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      ...coordinates.slice(positionIndexes[0] + 1),\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyRemovePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1),\n  ];\n}\n\nfunction immutablyAddPosition(\n  coordinates: any,\n  positionIndexes: number[] | null | undefined,\n  positionToAdd: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      positionToAdd,\n      ...coordinates.slice(positionIndexes[0]),\n    ];\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyAddPosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      positionToAdd,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1),\n  ];\n}\n\nfunction pruneGeometryIfNecessary(geometry: Geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry: Polygon) {\n  const polygon = geometry.coordinates;\n\n  // If any hole is no longer a polygon, remove the hole entirely\n  for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry: MultiLineString) {\n  for (let lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    const lineString = geometry.coordinates[lineStringIndex];\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1);\n      // Keep the index the same\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry: MultiPolygon) {\n  for (let polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    const polygon = geometry.coordinates[polygonIndex];\n    const outerRing = polygon[0];\n\n    // If the outer ring is no longer a polygon, remove the whole polygon\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1);\n      // It was removed, so keep the index the same\n      polygonIndex--;\n    }\n\n    for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon: PolygonCoordinates, holeIndex: number) {\n  const hole = polygon[holeIndex];\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}