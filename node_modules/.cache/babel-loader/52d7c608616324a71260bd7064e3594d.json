{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIntermediatePosition = getIntermediatePosition;\nexports.GeoJsonEditMode = void 0;\n\nvar _union = _interopRequireDefault(require(\"@turf/union\"));\n\nvar _difference = _interopRequireDefault(require(\"@turf/difference\"));\n\nvar _intersect = _interopRequireDefault(require(\"@turf/intersect\"));\n\nvar _rewind = _interopRequireDefault(require(\"@turf/rewind\"));\n\nvar _utils = require(\"../utils\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_GUIDES = {\n  type: 'FeatureCollection',\n  features: []\n};\nvar DEFAULT_TOOLTIPS = []; // Main interface for `EditMode`s that edit GeoJSON\n\nvar GeoJsonEditMode = /*#__PURE__*/function () {\n  function GeoJsonEditMode() {\n    _classCallCheck(this, GeoJsonEditMode);\n\n    _defineProperty(this, \"_clickSequence\", []);\n  }\n\n  _createClass(GeoJsonEditMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      return DEFAULT_GUIDES;\n    }\n  }, {\n    key: \"getTooltips\",\n    value: function getTooltips(props) {\n      return DEFAULT_TOOLTIPS;\n    }\n  }, {\n    key: \"getSelectedFeature\",\n    value: function getSelectedFeature(props) {\n      if (props.selectedIndexes.length === 1) {\n        return props.data.features[props.selectedIndexes[0]];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSelectedGeometry\",\n    value: function getSelectedGeometry(props) {\n      var feature = this.getSelectedFeature(props);\n\n      if (feature) {\n        return feature.geometry;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSelectedFeaturesAsFeatureCollection\",\n    value: function getSelectedFeaturesAsFeatureCollection(props) {\n      var features = props.data.features;\n      var selectedFeatures = props.selectedIndexes.map(function (selectedIndex) {\n        return features[selectedIndex];\n      });\n      return {\n        type: 'FeatureCollection',\n        features: selectedFeatures\n      };\n    }\n  }, {\n    key: \"getClickSequence\",\n    value: function getClickSequence() {\n      return this._clickSequence;\n    }\n  }, {\n    key: \"addClickSequence\",\n    value: function addClickSequence(_ref) {\n      var mapCoords = _ref.mapCoords;\n\n      this._clickSequence.push(mapCoords);\n    }\n  }, {\n    key: \"resetClickSequence\",\n    value: function resetClickSequence() {\n      this._clickSequence = [];\n    }\n  }, {\n    key: \"getTentativeGuide\",\n    value: function getTentativeGuide(props) {\n      var guides = this.getGuides(props); // @ts-ignore\n\n      return guides.features.find(function (f) {\n        return f.properties && f.properties.guideType === 'tentative';\n      });\n    }\n  }, {\n    key: \"isSelectionPicked\",\n    value: function isSelectionPicked(picks, props) {\n      if (!picks.length) return false;\n      var pickedFeatures = (0, _utils.getNonGuidePicks)(picks).map(function (_ref2) {\n        var index = _ref2.index;\n        return index;\n      });\n      var pickedHandles = (0, _utils.getPickedEditHandles)(picks).map(function (_ref3) {\n        var properties = _ref3.properties;\n        return properties.featureIndex;\n      });\n      var pickedIndexes = new Set([].concat(_toConsumableArray(pickedFeatures), _toConsumableArray(pickedHandles)));\n      return props.selectedIndexes.some(function (index) {\n        return pickedIndexes.has(index);\n      });\n    }\n  }, {\n    key: \"rewindPolygon\",\n    value: function rewindPolygon(feature) {\n      var geometry = feature.geometry;\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      if (isPolygonal) {\n        // @ts-ignore\n        return (0, _rewind[\"default\"])(feature);\n      }\n\n      return feature;\n    }\n  }, {\n    key: \"getAddFeatureAction\",\n    value: function getAddFeatureAction(featureOrGeometry, features) {\n      // Unsure why flow can't deal with Geometry type, but there I fixed it\n      var featureOrGeometryAsAny = featureOrGeometry;\n      var feature = featureOrGeometryAsAny.type === 'Feature' ? featureOrGeometryAsAny : {\n        type: 'Feature',\n        properties: {},\n        geometry: featureOrGeometryAsAny\n      };\n      var rewindFeature = this.rewindPolygon(feature);\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features).addFeature(rewindFeature).getObject();\n      return {\n        updatedData: updatedData,\n        editType: 'addFeature',\n        editContext: {\n          featureIndexes: [updatedData.features.length - 1]\n        }\n      };\n    }\n  }, {\n    key: \"getAddManyFeaturesAction\",\n    value: function getAddManyFeaturesAction(_ref4, features) {\n      var featuresToAdd = _ref4.features;\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features);\n      var initialIndex = updatedData.getObject().features.length;\n      var updatedIndexes = [];\n\n      var _iterator = _createForOfIteratorHelper(featuresToAdd),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var feature = _step.value;\n          var properties = feature.properties,\n              geometry = feature.geometry;\n          var geometryAsAny = geometry;\n          updatedData = updatedData.addFeature({\n            type: 'Feature',\n            properties: properties,\n            geometry: geometryAsAny\n          });\n          updatedIndexes.push(initialIndex + updatedIndexes.length);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        updatedData: updatedData.getObject(),\n        editType: 'addFeature',\n        editContext: {\n          featureIndexes: updatedIndexes\n        }\n      };\n    }\n  }, {\n    key: \"getAddFeatureOrBooleanPolygonAction\",\n    value: function getAddFeatureOrBooleanPolygonAction(featureOrGeometry, props) {\n      var featureOrGeometryAsAny = featureOrGeometry;\n      var selectedFeature = this.getSelectedFeature(props);\n      var modeConfig = props.modeConfig;\n\n      if (modeConfig && modeConfig.booleanOperation) {\n        if (!selectedFeature || selectedFeature.geometry.type !== 'Polygon' && selectedFeature.geometry.type !== 'MultiPolygon') {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn('booleanOperation only supported for single Polygon or MultiPolygon selection');\n          return null;\n        }\n\n        var feature = featureOrGeometryAsAny.type === 'Feature' ? featureOrGeometryAsAny : {\n          type: 'Feature',\n          geometry: featureOrGeometryAsAny\n        };\n        var updatedGeometry;\n\n        if (modeConfig.booleanOperation === 'union') {\n          updatedGeometry = (0, _union[\"default\"])(selectedFeature, feature);\n        } else if (modeConfig.booleanOperation === 'difference') {\n          // @ts-ignore\n          updatedGeometry = (0, _difference[\"default\"])(selectedFeature, feature);\n        } else if (modeConfig.booleanOperation === 'intersection') {\n          // @ts-ignore\n          updatedGeometry = (0, _intersect[\"default\"])(selectedFeature, feature);\n        } else {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn(\"Invalid booleanOperation \".concat(modeConfig.booleanOperation));\n          return null;\n        }\n\n        if (!updatedGeometry) {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn('Canceling edit. Boolean operation erased entire polygon.');\n          return null;\n        }\n\n        var featureIndex = props.selectedIndexes[0];\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, updatedGeometry.geometry).getObject();\n        var editAction = {\n          updatedData: updatedData,\n          editType: 'unionGeometry',\n          editContext: {\n            featureIndexes: [featureIndex]\n          }\n        };\n        return editAction;\n      }\n\n      return this.getAddFeatureAction(featureOrGeometry, props.data);\n    }\n  }, {\n    key: \"createTentativeFeature\",\n    value: function createTentativeFeature(props) {\n      return null;\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event, props) {}\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      var tentativeFeature = this.createTentativeFeature(props);\n\n      if (tentativeFeature) {\n        props.onEdit({\n          updatedData: props.data,\n          editType: 'updateTentativeFeature',\n          editContext: {\n            feature: tentativeFeature\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {}\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {}\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {}\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event, props) {\n      if (event.key === 'Escape') {\n        this.resetClickSequence();\n        props.onEdit({\n          // Because the new drawing feature is dropped, so the data will keep as the same.\n          updatedData: props.data,\n          editType: 'cancelFeature',\n          editContext: {}\n        });\n      }\n    }\n  }]);\n\n  return GeoJsonEditMode;\n}();\n\nexports.GeoJsonEditMode = GeoJsonEditMode;\n\nfunction getIntermediatePosition(position1, position2) {\n  var intermediatePosition = [(position1[0] + position2[0]) / 2.0, (position1[1] + position2[1]) / 2.0]; // @ts-ignore\n\n  return intermediatePosition;\n}","map":{"version":3,"sources":["../../src/lib/geojson-edit-mode.ts"],"names":["DEFAULT_GUIDES","type","features","DEFAULT_TOOLTIPS","GeoJsonEditMode","props","feature","selectedFeatures","mapCoords","guides","f","picks","pickedFeatures","index","pickedHandles","properties","pickedIndexes","geometry","isPolygonal","featureOrGeometry","featureOrGeometryAsAny","rewindFeature","updatedData","ImmutableFeatureCollection","editType","editContext","featureIndexes","featuresToAdd","initialIndex","updatedIndexes","geometryAsAny","selectedFeature","modeConfig","console","updatedGeometry","featureIndex","editAction","event","tentativeFeature","intermediatePosition","position1","position2"],"mappings":"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","sourcesContent":["import turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\nimport rewind from '@turf/rewind';\n\nimport {\n  EditAction,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  Pick,\n  Tooltip,\n  ModeProps,\n  GuideFeatureCollection,\n  TentativeFeature,\n} from '../types';\nimport { FeatureCollection, Feature, Polygon, Geometry, Position } from '../geojson-types';\nimport { getPickedEditHandles, getNonGuidePicks } from '../utils';\nimport { EditMode } from './edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport type GeoJsonEditAction = EditAction<FeatureCollection>;\n\nconst DEFAULT_GUIDES: GuideFeatureCollection = {\n  type: 'FeatureCollection',\n  features: [],\n};\nconst DEFAULT_TOOLTIPS: Tooltip[] = [];\n\n// Main interface for `EditMode`s that edit GeoJSON\nexport type GeoJsonEditModeType = EditMode<FeatureCollection, FeatureCollection>;\n\nexport interface GeoJsonEditModeConstructor {\n  new (): GeoJsonEditModeType;\n}\n\nexport class GeoJsonEditMode implements EditMode<FeatureCollection, GuideFeatureCollection> {\n  _clickSequence: Position[] = [];\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    return DEFAULT_GUIDES;\n  }\n\n  getTooltips(props: ModeProps<FeatureCollection>): Tooltip[] {\n    return DEFAULT_TOOLTIPS;\n  }\n\n  getSelectedFeature(props: ModeProps<FeatureCollection>): Feature | null | undefined {\n    if (props.selectedIndexes.length === 1) {\n      return props.data.features[props.selectedIndexes[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(props: ModeProps<FeatureCollection>): Geometry | null | undefined {\n    const feature = this.getSelectedFeature(props);\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(props: ModeProps<FeatureCollection>): FeatureCollection {\n    const { features } = props.data;\n    const selectedFeatures = props.selectedIndexes.map((selectedIndex) => features[selectedIndex]);\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures,\n    };\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  addClickSequence({ mapCoords }: ClickEvent): void {\n    this._clickSequence.push(mapCoords);\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeGuide(props: ModeProps<FeatureCollection>): TentativeFeature | null | undefined {\n    const guides = this.getGuides(props);\n\n    // @ts-ignore\n    return guides.features.find((f) => f.properties && f.properties.guideType === 'tentative');\n  }\n\n  isSelectionPicked(picks: Pick[], props: ModeProps<FeatureCollection>): boolean {\n    if (!picks.length) return false;\n    const pickedFeatures = getNonGuidePicks(picks).map(({ index }) => index);\n    const pickedHandles = getPickedEditHandles(picks).map(\n      ({ properties }) => properties.featureIndex\n    );\n    const pickedIndexes = new Set([...pickedFeatures, ...pickedHandles]);\n    return props.selectedIndexes.some((index) => pickedIndexes.has(index));\n  }\n\n  rewindPolygon(feature: Feature): Feature {\n    const { geometry } = feature;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    if (isPolygonal) {\n      // @ts-ignore\n      return rewind(feature);\n    }\n\n    return feature;\n  }\n\n  getAddFeatureAction(\n    featureOrGeometry: Geometry | Feature,\n    features: FeatureCollection\n  ): GeoJsonEditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const featureOrGeometryAsAny: any = featureOrGeometry;\n\n    const feature: any =\n      featureOrGeometryAsAny.type === 'Feature'\n        ? featureOrGeometryAsAny\n        : {\n            type: 'Feature',\n            properties: {},\n            geometry: featureOrGeometryAsAny,\n          };\n\n    const rewindFeature = this.rewindPolygon(feature);\n    const updatedData = new ImmutableFeatureCollection(features)\n      .addFeature(rewindFeature)\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: [updatedData.features.length - 1],\n      },\n    };\n  }\n\n  getAddManyFeaturesAction(\n    { features: featuresToAdd }: FeatureCollection,\n    features: FeatureCollection\n  ): GeoJsonEditAction {\n    let updatedData = new ImmutableFeatureCollection(features);\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of featuresToAdd) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny,\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: updatedIndexes,\n      },\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(\n    featureOrGeometry: Polygon | Feature,\n    props: ModeProps<FeatureCollection>\n  ): GeoJsonEditAction | null | undefined {\n    const featureOrGeometryAsAny: any = featureOrGeometry;\n\n    const selectedFeature = this.getSelectedFeature(props);\n    const { modeConfig } = props;\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature =\n        featureOrGeometryAsAny.type === 'Feature'\n          ? featureOrGeometryAsAny\n          : {\n              type: 'Feature',\n              geometry: featureOrGeometryAsAny,\n            };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        // @ts-ignore\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        // @ts-ignore\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = props.selectedIndexes[0];\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: GeoJsonEditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        editContext: {\n          featureIndexes: [featureIndex],\n        },\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(featureOrGeometry, props.data);\n  }\n\n  createTentativeFeature(props: ModeProps<FeatureCollection>): TentativeFeature {\n    return null;\n  }\n\n  handleClick(event: ClickEvent, props: ModeProps<FeatureCollection>): void {}\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    const tentativeFeature = this.createTentativeFeature(props);\n    if (tentativeFeature) {\n      props.onEdit({\n        updatedData: props.data,\n        editType: 'updateTentativeFeature',\n        editContext: {\n          feature: tentativeFeature,\n        },\n      });\n    }\n  }\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>): void {}\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>): void {}\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {}\n\n  handleKeyUp(event: KeyboardEvent, props: ModeProps<FeatureCollection>): void {\n    if (event.key === 'Escape') {\n      this.resetClickSequence();\n      props.onEdit({\n        // Because the new drawing feature is dropped, so the data will keep as the same.\n        updatedData: props.data,\n        editType: 'cancelFeature',\n        editContext: {},\n      });\n    }\n  }\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0,\n  ];\n  // @ts-ignore\n  return intermediatePosition;\n}\n"]},"metadata":{},"sourceType":"script"}