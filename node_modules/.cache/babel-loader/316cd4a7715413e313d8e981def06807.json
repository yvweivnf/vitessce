{"ast":null,"code":"import { isFunction, isString } from 'vega-util';\nimport { isCountingAggregateOp } from '../../../aggregate';\nimport { isBinned, isBinning } from '../../../bin';\nimport { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { binRequiresRange, getBandPosition, isDatumDef, isFieldDef, isFieldOrDatumDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport { dateTimeToExpr, isDateTime } from '../../../datetime';\nimport { isExprRef } from '../../../expr';\nimport * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous } from '../../../scale';\nimport { TEMPORAL } from '../../../type';\nimport { contains, stringify } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nexport function midPointRefWithPositionInvalidTest(params) {\n  var channel = params.channel,\n      channelDef = params.channelDef,\n      markDef = params.markDef,\n      scale = params.scale,\n      config = params.config;\n  var ref = midPoint(params); // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n\n  if ( // Only this for field def without counting aggregate (as count wouldn't be null)\n  isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale without zero (otherwise, null / invalid will be interpreted as zero, which doesn't cause layout problem)\n  scale && isContinuousToContinuous(scale.get('type')) && scale.get('zero') === false) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel: channel,\n      markDef: markDef,\n      ref: ref,\n      config: config\n    });\n  }\n\n  return ref;\n}\nexport function wrapPositionInvalidTest(_ref) {\n  var fieldDef = _ref.fieldDef,\n      channel = _ref.channel,\n      markDef = _ref.markDef,\n      ref = _ref.ref,\n      config = _ref.config;\n\n  if (isPathMark(markDef.type)) {\n    // path mark already use defined to skip points, no need to do it here.\n    return ref;\n  }\n\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === null) {\n    // if there is no invalid filter, don't do the invalid test\n    return ref;\n  }\n\n  return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n}\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n  var test = fieldInvalidPredicate(fieldDef, true);\n  var mainChannel = getMainRangeChannel(channel); // we can cast here as the output can't be other things.\n\n  var zeroValueRef = mainChannel === 'y' ? {\n    field: {\n      group: 'height'\n    }\n  } : // x / angle / radius can all use 0\n  {\n    value: 0\n  };\n  return Object.assign({\n    test: test\n  }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field) {\n  var invalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {\n    expr: 'datum'\n  }), !invalid);\n}\nexport function datumDefToExpr(datumDef) {\n  var datum = datumDef.datum;\n\n  if (isDateTime(datum)) {\n    return dateTimeToExpr(datum);\n  }\n\n  return \"\".concat(stringify(datum));\n}\nexport function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {\n  var ref = {};\n\n  if (scaleName) {\n    ref.scale = scaleName;\n  }\n\n  if (isDatumDef(fieldDef)) {\n    var datum = fieldDef.datum;\n\n    if (isDateTime(datum)) {\n      ref.signal = dateTimeToExpr(datum);\n    } else if (isSignalRef(datum)) {\n      ref.signal = datum.signal;\n    } else if (isExprRef(datum)) {\n      ref.signal = datum.expr;\n    } else {\n      ref.value = datum;\n    }\n  } else {\n    ref.field = vgField(fieldDef, opt);\n  }\n\n  if (encode) {\n    var offset = encode.offset,\n        band = encode.band;\n\n    if (offset) {\n      ref.offset = offset;\n    }\n\n    if (band) {\n      ref.band = band;\n    }\n  }\n\n  return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\n\nexport function interpolatedSignalRef(_ref2) {\n  var scaleName = _ref2.scaleName,\n      fieldOrDatumDef = _ref2.fieldOrDatumDef,\n      fieldOrDatumDef2 = _ref2.fieldOrDatumDef2,\n      offset = _ref2.offset,\n      startSuffix = _ref2.startSuffix,\n      _ref2$bandPosition = _ref2.bandPosition,\n      bandPosition = _ref2$bandPosition === void 0 ? 0.5 : _ref2$bandPosition;\n  var expr = 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n  var start = vgField(fieldOrDatumDef, {\n    expr: expr,\n    suffix: startSuffix\n  });\n  var end = fieldOrDatumDef2 !== undefined ? vgField(fieldOrDatumDef2, {\n    expr: expr\n  }) : vgField(fieldOrDatumDef, {\n    suffix: 'end',\n    expr: expr\n  });\n  var ref = {};\n\n  if (bandPosition === 0 || bandPosition === 1) {\n    ref.scale = scaleName;\n    var val = bandPosition === 0 ? start : end;\n    ref.field = val;\n  } else {\n    var datum = isSignalRef(bandPosition) ? \"\".concat(bandPosition.signal, \" * \").concat(start, \" + (1-\").concat(bandPosition.signal, \") * \").concat(end) : \"\".concat(bandPosition, \" * \").concat(start, \" + \").concat(1 - bandPosition, \" * \").concat(end);\n    ref.signal = \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(datum, \")\");\n  }\n\n  if (offset) {\n    ref.offset = offset;\n  }\n\n  return ref;\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\n\nexport function midPoint(_ref3) {\n  var channel = _ref3.channel,\n      channelDef = _ref3.channelDef,\n      channel2Def = _ref3.channel2Def,\n      markDef = _ref3.markDef,\n      config = _ref3.config,\n      scaleName = _ref3.scaleName,\n      scale = _ref3.scale,\n      stack = _ref3.stack,\n      offset = _ref3.offset,\n      defaultRef = _ref3.defaultRef,\n      bandPosition = _ref3.bandPosition;\n\n  var _a; // TODO: datum support\n\n\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldOrDatumDef(channelDef)) {\n      if (isTypedFieldDef(channelDef)) {\n        bandPosition !== null && bandPosition !== void 0 ? bandPosition : bandPosition = getBandPosition({\n          fieldDef: channelDef,\n          fieldDef2: channel2Def,\n          markDef: markDef,\n          config: config\n        });\n        var bin = channelDef.bin,\n            timeUnit = channelDef.timeUnit,\n            type = channelDef.type;\n\n        if (isBinning(bin) || bandPosition && timeUnit && type === TEMPORAL) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (stack === null || stack === void 0 ? void 0 : stack.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, {\n              binSuffix: 'mid'\n            }, {\n              offset: offset\n            });\n          }\n\n          if (bandPosition) {\n            // if band = 0, no need to call interpolation\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return interpolatedSignalRef({\n              scaleName: scaleName,\n              fieldOrDatumDef: channelDef,\n              bandPosition: bandPosition,\n              offset: offset\n            });\n          }\n\n          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset: offset\n          });\n        } else if (isBinned(bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName: scaleName,\n              fieldOrDatumDef: channelDef,\n              fieldOrDatumDef2: channel2Def,\n              bandPosition: bandPosition,\n              offset: offset\n            });\n          } else {\n            var channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      var scaleType = scale === null || scale === void 0 ? void 0 : scale.get('type');\n      return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType) ? {\n        binSuffix: 'range'\n      } : {}, // no need for bin suffix if there is no scale\n      {\n        offset: offset,\n        // For band, to get mid point, need to offset by half of the band\n        band: scaleType === 'band' ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : undefined\n      });\n    } else if (isValueDef(channelDef)) {\n      var value = channelDef.value;\n      var offsetMixins = offset ? {\n        offset: offset\n      } : {};\n      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value)), offsetMixins);\n    } // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n\n  }\n\n  if (isFunction(defaultRef)) {\n    defaultRef = defaultRef();\n  }\n\n  if (defaultRef) {\n    // for non-position, ref could be undefined.\n    return Object.assign(Object.assign({}, defaultRef), offset ? {\n      offset: offset\n    } : {});\n  }\n\n  return defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\n\nexport function widthHeightValueOrSignalRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n\n  return signalOrValueRef(value);\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/valueref.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isFunction, isString } from 'vega-util';\nimport { isCountingAggregateOp } from '../../../aggregate';\nimport { isBinned, isBinning } from '../../../bin';\nimport { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { binRequiresRange, getBandPosition, isDatumDef, isFieldDef, isFieldOrDatumDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport { dateTimeToExpr, isDateTime } from '../../../datetime';\nimport { isExprRef } from '../../../expr';\nimport * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous } from '../../../scale';\nimport { TEMPORAL } from '../../../type';\nimport { contains, stringify } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nexport function midPointRefWithPositionInvalidTest(params) {\n    const { channel, channelDef, markDef, scale, config } = params;\n    const ref = midPoint(params);\n    // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n    if (\n    // Only this for field def without counting aggregate (as count wouldn't be null)\n    isFieldDef(channelDef) &&\n        !isCountingAggregateOp(channelDef.aggregate) &&\n        // and only for continuous scale without zero (otherwise, null / invalid will be interpreted as zero, which doesn't cause layout problem)\n        scale &&\n        isContinuousToContinuous(scale.get('type')) &&\n        scale.get('zero') === false) {\n        return wrapPositionInvalidTest({\n            fieldDef: channelDef,\n            channel,\n            markDef,\n            ref,\n            config\n        });\n    }\n    return ref;\n}\nexport function wrapPositionInvalidTest({ fieldDef, channel, markDef, ref, config }) {\n    if (isPathMark(markDef.type)) {\n        // path mark already use defined to skip points, no need to do it here.\n        return ref;\n    }\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid === null) {\n        // if there is no invalid filter, don't do the invalid test\n        return ref;\n    }\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n}\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n    const test = fieldInvalidPredicate(fieldDef, true);\n    const mainChannel = getMainRangeChannel(channel); // we can cast here as the output can't be other things.\n    const zeroValueRef = mainChannel === 'y'\n        ? { field: { group: 'height' } }\n        : // x / angle / radius can all use 0\n            { value: 0 };\n    return Object.assign({ test }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field, invalid = true) {\n    return fieldValidPredicate(isString(field) ? field : vgField(field, { expr: 'datum' }), !invalid);\n}\nexport function datumDefToExpr(datumDef) {\n    const { datum } = datumDef;\n    if (isDateTime(datum)) {\n        return dateTimeToExpr(datum);\n    }\n    return `${stringify(datum)}`;\n}\nexport function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {\n    const ref = {};\n    if (scaleName) {\n        ref.scale = scaleName;\n    }\n    if (isDatumDef(fieldDef)) {\n        const { datum } = fieldDef;\n        if (isDateTime(datum)) {\n            ref.signal = dateTimeToExpr(datum);\n        }\n        else if (isSignalRef(datum)) {\n            ref.signal = datum.signal;\n        }\n        else if (isExprRef(datum)) {\n            ref.signal = datum.expr;\n        }\n        else {\n            ref.value = datum;\n        }\n    }\n    else {\n        ref.field = vgField(fieldDef, opt);\n    }\n    if (encode) {\n        const { offset, band } = encode;\n        if (offset) {\n            ref.offset = offset;\n        }\n        if (band) {\n            ref.band = band;\n        }\n    }\n    return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nexport function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset, startSuffix, bandPosition = 0.5 }) {\n    const expr = 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n    const start = vgField(fieldOrDatumDef, { expr, suffix: startSuffix });\n    const end = fieldOrDatumDef2 !== undefined\n        ? vgField(fieldOrDatumDef2, { expr })\n        : vgField(fieldOrDatumDef, { suffix: 'end', expr });\n    const ref = {};\n    if (bandPosition === 0 || bandPosition === 1) {\n        ref.scale = scaleName;\n        const val = bandPosition === 0 ? start : end;\n        ref.field = val;\n    }\n    else {\n        const datum = isSignalRef(bandPosition)\n            ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}`\n            : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;\n        ref.signal = `scale(\"${scaleName}\", ${datum})`;\n    }\n    if (offset) {\n        ref.offset = offset;\n    }\n    return ref;\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack, offset, defaultRef, bandPosition }) {\n    var _a;\n    // TODO: datum support\n    if (channelDef) {\n        /* istanbul ignore else */\n        if (isFieldOrDatumDef(channelDef)) {\n            if (isTypedFieldDef(channelDef)) {\n                bandPosition !== null && bandPosition !== void 0 ? bandPosition : (bandPosition = getBandPosition({\n                    fieldDef: channelDef,\n                    fieldDef2: channel2Def,\n                    markDef,\n                    config\n                }));\n                const { bin, timeUnit, type } = channelDef;\n                if (isBinning(bin) || (bandPosition && timeUnit && type === TEMPORAL)) {\n                    // Use middle only for x an y to place marks in the center between start and end of the bin range.\n                    // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n                    if (stack === null || stack === void 0 ? void 0 : stack.impute) {\n                        // For stack, we computed bin_mid so we can impute.\n                        return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: 'mid' }, { offset });\n                    }\n                    if (bandPosition) {\n                        // if band = 0, no need to call interpolation\n                        // For non-stack, we can just calculate bin mid on the fly using signal.\n                        return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, bandPosition, offset });\n                    }\n                    return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: 'range' } : {}, {\n                        offset\n                    });\n                }\n                else if (isBinned(bin)) {\n                    if (isFieldDef(channel2Def)) {\n                        return interpolatedSignalRef({\n                            scaleName,\n                            fieldOrDatumDef: channelDef,\n                            fieldOrDatumDef2: channel2Def,\n                            bandPosition,\n                            offset\n                        });\n                    }\n                    else {\n                        const channel2 = channel === X ? X2 : Y2;\n                        log.warn(log.message.channelRequiredForBinned(channel2));\n                    }\n                }\n            }\n            const scaleType = scale === null || scale === void 0 ? void 0 : scale.get('type');\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType) ? { binSuffix: 'range' } : {}, // no need for bin suffix if there is no scale\n            {\n                offset,\n                // For band, to get mid point, need to offset by half of the band\n                band: scaleType === 'band' ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : undefined\n            });\n        }\n        else if (isValueDef(channelDef)) {\n            const value = channelDef.value;\n            const offsetMixins = offset ? { offset } : {};\n            return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value)), offsetMixins);\n        }\n        // If channelDef is neither field def or value def, it's a condition-only def.\n        // In such case, we will use default ref.\n    }\n    if (isFunction(defaultRef)) {\n        defaultRef = defaultRef();\n    }\n    if (defaultRef) {\n        // for non-position, ref could be undefined.\n        return Object.assign(Object.assign({}, defaultRef), (offset ? { offset } : {}));\n    }\n    return defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function widthHeightValueOrSignalRef(channel, value) {\n    if (contains(['x', 'x2'], channel) && value === 'width') {\n        return { field: { group: 'width' } };\n    }\n    else if (contains(['y', 'y2'], channel) && value === 'height') {\n        return { field: { group: 'height' } };\n    }\n    return signalOrValueRef(value);\n}\n//# sourceMappingURL=valueref.js.map"]},"metadata":{},"sourceType":"module"}