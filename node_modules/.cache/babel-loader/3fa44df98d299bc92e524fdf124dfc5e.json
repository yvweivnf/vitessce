{"ast":null,"code":"import { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\n\nfunction unquote(pattern) {\n  if (pattern[0] === \"'\" && pattern[pattern.length - 1] === \"'\" || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n    return pattern.slice(1, -1);\n  }\n\n  return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\n\n\nfunction parseExpression(field, parse) {\n  const f = accessPathWithDatum(field);\n\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    const specifier = unquote(parse.slice(5, parse.length));\n    return `timeParse(${f},'${specifier}')`;\n  } else if (parse.startsWith('utc:')) {\n    const specifier = unquote(parse.slice(4, parse.length));\n    return `utcParse(${f},'${specifier}')`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport function getImplicitFromFilterTransform(transform) {\n  const implicit = {};\n  forEachLeaf(transform.filter, filter => {\n    var _a;\n\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      let val = null; // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter['in'])[0];\n      } // else -- for filter expression, we can't infer anything\n\n\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromEncoding(model) {\n  const implicit = {};\n\n  function add(fieldDef) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (fieldDef.type === 'quantitative' && isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        const mainChannel = getMainRangeChannel(channel);\n        const mainFieldDef = model.fieldDef(mainChannel);\n        add(Object.assign(Object.assign({}, fieldDef), {\n          type: mainFieldDef.type\n        }));\n      }\n    });\n  } // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n\n\n  if (isUnitModel(model)) {\n    const {\n      mark,\n      markDef,\n      encoding\n    } = model;\n\n    if (isPathMark(mark) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n    !model.encoding.order) {\n      const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      const dimensionChannelDef = encoding[dimensionChannel];\n\n      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === 'quantitative' && !(dimensionChannelDef.field in implicit)) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromSelection(model) {\n  const implicit = {};\n\n  if (isUnitModel(model) && model.component.selection) {\n    for (const name of keys(model.component.selection)) {\n      const selCmpt = model.component.selection[name];\n\n      for (const proj of selCmpt.project.items) {\n        if (!proj.channel && accessPathDepth(proj.field) > 1) {\n          implicit[proj.field] = 'flatten';\n        }\n      }\n    }\n  }\n\n  return implicit;\n}\nexport class ParseNode extends DataFlowNode {\n  constructor(parent, parse) {\n    super(parent);\n    this._parse = parse;\n  }\n\n  clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  hash() {\n    return `Parse ${hash(this._parse)}`;\n  }\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n\n\n  static makeExplicit(parent, model, ancestorParse) {\n    var _a; // Custom parse\n\n\n    let explicit = {};\n    const data = model.data;\n\n    if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n\n\n  static makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit); // add the format parse from this model so that children don't parse the same field again\n\n    ancestorParse.copyAll(parse); // copy only non-null parses\n\n    const p = {};\n\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  get parse() {\n    return this._parse;\n  }\n\n  merge(other) {\n    this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n    other.remove();\n  }\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n\n\n  assembleFormatParse() {\n    const formatParse = {};\n\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n\n    return formatParse;\n  } // format parse depends and produces all fields in its parse\n\n\n  producedFields() {\n    return new Set(keys(this._parse));\n  }\n\n  dependentFields() {\n    return new Set(keys(this._parse));\n  }\n\n  assembleTransforms(onlyNested = false) {\n    return keys(this._parse).filter(field => onlyNested ? accessPathDepth(field) > 1 : true).map(field => {\n      const expr = parseExpression(field, this._parse[field]);\n\n      if (!expr) {\n        return null;\n      }\n\n      const formula = {\n        type: 'formula',\n        expr,\n        as: removePathFromField(field) // Vega output is always flattened\n\n      };\n      return formula;\n    }).filter(t => t !== null);\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/formatparse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern) {\n    if ((pattern[0] === \"'\" && pattern[pattern.length - 1] === \"'\") ||\n        (pattern[0] === '\"' && pattern[pattern.length - 1] === '\"')) {\n        return pattern.slice(1, -1);\n    }\n    return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field, parse) {\n    const f = accessPathWithDatum(field);\n    if (parse === 'number') {\n        return `toNumber(${f})`;\n    }\n    else if (parse === 'boolean') {\n        return `toBoolean(${f})`;\n    }\n    else if (parse === 'string') {\n        return `toString(${f})`;\n    }\n    else if (parse === 'date') {\n        return `toDate(${f})`;\n    }\n    else if (parse === 'flatten') {\n        return f;\n    }\n    else if (parse.startsWith('date:')) {\n        const specifier = unquote(parse.slice(5, parse.length));\n        return `timeParse(${f},'${specifier}')`;\n    }\n    else if (parse.startsWith('utc:')) {\n        const specifier = unquote(parse.slice(4, parse.length));\n        return `utcParse(${f},'${specifier}')`;\n    }\n    else {\n        log.warn(log.message.unrecognizedParse(parse));\n        return null;\n    }\n}\nexport function getImplicitFromFilterTransform(transform) {\n    const implicit = {};\n    forEachLeaf(transform.filter, filter => {\n        var _a;\n        if (isFieldPredicate(filter)) {\n            // Automatically add a parse node for filters with filter objects\n            let val = null;\n            // For EqualFilter, just use the equal property.\n            // For RangeFilter and OneOfFilter, all array members should have\n            // the same type, so we only use the first one.\n            if (isFieldEqualPredicate(filter)) {\n                val = signalRefOrValue(filter.equal);\n            }\n            else if (isFieldLTEPredicate(filter)) {\n                val = signalRefOrValue(filter.lte);\n            }\n            else if (isFieldLTPredicate(filter)) {\n                val = signalRefOrValue(filter.lt);\n            }\n            else if (isFieldGTPredicate(filter)) {\n                val = signalRefOrValue(filter.gt);\n            }\n            else if (isFieldGTEPredicate(filter)) {\n                val = signalRefOrValue(filter.gte);\n            }\n            else if (isFieldRangePredicate(filter)) {\n                val = filter.range[0];\n            }\n            else if (isFieldOneOfPredicate(filter)) {\n                val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter['in'])[0];\n            } // else -- for filter expression, we can't infer anything\n            if (val) {\n                if (isDateTime(val)) {\n                    implicit[filter.field] = 'date';\n                }\n                else if (isNumber(val)) {\n                    implicit[filter.field] = 'number';\n                }\n                else if (isString(val)) {\n                    implicit[filter.field] = 'string';\n                }\n            }\n            if (filter.timeUnit) {\n                implicit[filter.field] = 'date';\n            }\n        }\n    });\n    return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model) {\n    const implicit = {};\n    function add(fieldDef) {\n        if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n            implicit[fieldDef.field] = 'date';\n        }\n        else if (fieldDef.type === 'quantitative' &&\n            isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n        ) {\n            implicit[fieldDef.field] = 'number';\n        }\n        else if (accessPathDepth(fieldDef.field) > 1) {\n            // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n            // (Parsing numbers / dates already flattens numeric and temporal fields.)\n            if (!(fieldDef.field in implicit)) {\n                implicit[fieldDef.field] = 'flatten';\n            }\n        }\n        else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n            // Flatten fields that we sort by but that are not otherwise flattened.\n            if (!(fieldDef.sort.field in implicit)) {\n                implicit[fieldDef.sort.field] = 'flatten';\n            }\n        }\n    }\n    if (isUnitModel(model) || isFacetModel(model)) {\n        // Parse encoded fields\n        model.forEachFieldDef((fieldDef, channel) => {\n            if (isTypedFieldDef(fieldDef)) {\n                add(fieldDef);\n            }\n            else {\n                const mainChannel = getMainRangeChannel(channel);\n                const mainFieldDef = model.fieldDef(mainChannel);\n                add(Object.assign(Object.assign({}, fieldDef), { type: mainFieldDef.type }));\n            }\n        });\n    }\n    // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n    if (isUnitModel(model)) {\n        const { mark, markDef, encoding } = model;\n        if (isPathMark(mark) &&\n            // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n            !model.encoding.order) {\n            const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n            const dimensionChannelDef = encoding[dimensionChannel];\n            if (isFieldDef(dimensionChannelDef) &&\n                dimensionChannelDef.type === 'quantitative' &&\n                !(dimensionChannelDef.field in implicit)) {\n                implicit[dimensionChannelDef.field] = 'number';\n            }\n        }\n    }\n    return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model) {\n    const implicit = {};\n    if (isUnitModel(model) && model.component.selection) {\n        for (const name of keys(model.component.selection)) {\n            const selCmpt = model.component.selection[name];\n            for (const proj of selCmpt.project.items) {\n                if (!proj.channel && accessPathDepth(proj.field) > 1) {\n                    implicit[proj.field] = 'flatten';\n                }\n            }\n        }\n    }\n    return implicit;\n}\nexport class ParseNode extends DataFlowNode {\n    constructor(parent, parse) {\n        super(parent);\n        this._parse = parse;\n    }\n    clone() {\n        return new ParseNode(null, duplicate(this._parse));\n    }\n    hash() {\n        return `Parse ${hash(this._parse)}`;\n    }\n    /**\n     * Creates a parse node from a data.format.parse and updates ancestorParse.\n     */\n    static makeExplicit(parent, model, ancestorParse) {\n        var _a;\n        // Custom parse\n        let explicit = {};\n        const data = model.data;\n        if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {\n            explicit = data.format.parse;\n        }\n        return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n    }\n    /**\n     * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n     */\n    static makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n        // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n        for (const field of keys(implicit)) {\n            const parsedAs = ancestorParse.getWithExplicit(field);\n            if (parsedAs.value !== undefined) {\n                // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n                if (parsedAs.explicit ||\n                    parsedAs.value === implicit[field] ||\n                    parsedAs.value === 'derived' ||\n                    implicit[field] === 'flatten') {\n                    delete implicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n                }\n            }\n        }\n        for (const field of keys(explicit)) {\n            const parsedAs = ancestorParse.get(field);\n            if (parsedAs !== undefined) {\n                // Don't parse a field again if it has been parsed with the same type already.\n                if (parsedAs === explicit[field]) {\n                    delete explicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n                }\n            }\n        }\n        const parse = new Split(explicit, implicit);\n        // add the format parse from this model so that children don't parse the same field again\n        ancestorParse.copyAll(parse);\n        // copy only non-null parses\n        const p = {};\n        for (const key of keys(parse.combine())) {\n            const val = parse.get(key);\n            if (val !== null) {\n                p[key] = val;\n            }\n        }\n        if (keys(p).length === 0 || ancestorParse.parseNothing) {\n            return null;\n        }\n        return new ParseNode(parent, p);\n    }\n    get parse() {\n        return this._parse;\n    }\n    merge(other) {\n        this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n        other.remove();\n    }\n    /**\n     * Assemble an object for Vega's format.parse property.\n     */\n    assembleFormatParse() {\n        const formatParse = {};\n        for (const field of keys(this._parse)) {\n            const p = this._parse[field];\n            if (accessPathDepth(field) === 1) {\n                formatParse[field] = p;\n            }\n        }\n        return formatParse;\n    }\n    // format parse depends and produces all fields in its parse\n    producedFields() {\n        return new Set(keys(this._parse));\n    }\n    dependentFields() {\n        return new Set(keys(this._parse));\n    }\n    assembleTransforms(onlyNested = false) {\n        return keys(this._parse)\n            .filter(field => (onlyNested ? accessPathDepth(field) > 1 : true))\n            .map(field => {\n            const expr = parseExpression(field, this._parse[field]);\n            if (!expr) {\n                return null;\n            }\n            const formula = {\n                type: 'formula',\n                expr,\n                as: removePathFromField(field) // Vega output is always flattened\n            };\n            return formula;\n        })\n            .filter(t => t !== null);\n    }\n}\n//# sourceMappingURL=formatparse.js.map"]},"metadata":{},"sourceType":"module"}