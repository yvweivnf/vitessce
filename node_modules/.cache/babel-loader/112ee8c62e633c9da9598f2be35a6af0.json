{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isObject } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n  constructor(...items) {\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n  }\n\n}\nconst project = {\n  defined: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: (model, selCmpt, selDef) => {\n    var _a;\n\n    const name = selCmpt.name;\n    const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();\n    const parsed = {};\n    const timeUnits = {};\n    const signals = new Set();\n\n    const signalName = (p, range) => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n\n      signals.add(sg);\n      return {\n        [range]: sg\n      };\n    };\n\n    const type = selCmpt.type;\n    const cfg = model.config.selection[type];\n    const init = selDef.value !== undefined ? array(selDef.value) : null; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n\n    let {\n      fields,\n      encodings\n    } = isObject(selDef.select) ? selDef.select : {};\n\n    if (!fields && !encodings && init) {\n      for (const initVal of init) {\n        // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n        if (!isObject(initVal)) {\n          continue;\n        }\n\n        for (const key of keys(initVal)) {\n          if (isSingleDefUnitChannel(key)) {\n            (encodings || (encodings = [])).push(key);\n          } else {\n            if (type === 'interval') {\n              log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n              encodings = cfg.encodings;\n            } else {\n              (fields || (fields = [])).push(key);\n            }\n          }\n        }\n      }\n    } // If no initial value is specified, use the default configuration.\n    // We break this out as a separate if block (instead of an else condition)\n    // to account for unprojected point selections that have scalar initial values\n\n\n    if (!fields && !encodings) {\n      encodings = cfg.encodings;\n\n      if ('fields' in cfg) {\n        fields = cfg.fields;\n      }\n    }\n\n    for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {\n      const fieldDef = model.fieldDef(channel);\n\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n\n          const component = {\n            timeUnit: fieldDef.timeUnit,\n            as: field,\n            field: fieldDef.field\n          };\n          timeUnits[hash(component)] = component;\n        } // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let tplType = 'E';\n\n          if (type === 'interval') {\n            const scaleType = model.getScaleComponent(channel).get('type');\n\n            if (hasContinuousDomain(scaleType)) {\n              tplType = 'R';\n            }\n          } else if (fieldDef.bin) {\n            tplType = 'R-RE';\n          }\n\n          const p = {\n            field,\n            channel,\n            type: tplType\n          };\n          p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n          proj.items.push(parsed[field] = p);\n          proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    for (const field of fields !== null && fields !== void 0 ? fields : []) {\n      if (proj.hasField[field]) continue;\n      const p = {\n        type: 'E',\n        field\n      };\n      p.signals = Object.assign({}, signalName(p, 'data'));\n      proj.items.push(p);\n      proj.hasField[field] = p;\n    }\n\n    if (init) {\n      selCmpt.init = init.map(v => {\n        // Selections can be initialized either with a full object that maps projections to values\n        // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n        return proj.items.map(p => isObject(v) ? v[p.channel] !== undefined ? v[p.channel] : v[p.field] : v);\n      });\n    }\n\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0 ? allSignals : allSignals.concat({\n      name,\n      value: selCmpt.project.items.map(proj => {\n        const {\n          signals,\n          hasLegend\n        } = proj,\n              rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n\n        rest.field = replacePathInField(rest.field);\n        return rest;\n      })\n    });\n  }\n};\nexport default project;","map":{"version":3,"sources":["../../../../src/compile/selection/project.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isObject } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n    constructor(...items) {\n        this.items = items;\n        this.hasChannel = {};\n        this.hasField = {};\n    }\n}\nconst project = {\n    defined: () => {\n        return true; // This transform handles its own defaults, so always run parse.\n    },\n    parse: (model, selCmpt, selDef) => {\n        var _a;\n        const name = selCmpt.name;\n        const proj = ((_a = selCmpt.project) !== null && _a !== void 0 ? _a : (selCmpt.project = new SelectionProjectionComponent()));\n        const parsed = {};\n        const timeUnits = {};\n        const signals = new Set();\n        const signalName = (p, range) => {\n            const suffix = range === 'visual' ? p.channel : p.field;\n            let sg = varName(`${name}_${suffix}`);\n            for (let counter = 1; signals.has(sg); counter++) {\n                sg = varName(`${name}_${suffix}_${counter}`);\n            }\n            signals.add(sg);\n            return { [range]: sg };\n        };\n        const type = selCmpt.type;\n        const cfg = model.config.selection[type];\n        const init = selDef.value !== undefined\n            ? array(selDef.value)\n            : null;\n        // If no explicit projection (either fields or encodings) is specified, set some defaults.\n        // If an initial value is set, try to infer projections.\n        let { fields, encodings } = (isObject(selDef.select) ? selDef.select : {});\n        if (!fields && !encodings && init) {\n            for (const initVal of init) {\n                // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n                if (!isObject(initVal)) {\n                    continue;\n                }\n                for (const key of keys(initVal)) {\n                    if (isSingleDefUnitChannel(key)) {\n                        (encodings || (encodings = [])).push(key);\n                    }\n                    else {\n                        if (type === 'interval') {\n                            log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                            encodings = cfg.encodings;\n                        }\n                        else {\n                            (fields || (fields = [])).push(key);\n                        }\n                    }\n                }\n            }\n        }\n        // If no initial value is specified, use the default configuration.\n        // We break this out as a separate if block (instead of an else condition)\n        // to account for unprojected point selections that have scalar initial values\n        if (!fields && !encodings) {\n            encodings = cfg.encodings;\n            if ('fields' in cfg) {\n                fields = cfg.fields;\n            }\n        }\n        for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {\n            const fieldDef = model.fieldDef(channel);\n            if (fieldDef) {\n                let field = fieldDef.field;\n                if (fieldDef.aggregate) {\n                    log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n                    continue;\n                }\n                else if (!field) {\n                    log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n                    continue;\n                }\n                if (fieldDef.timeUnit) {\n                    field = model.vgField(channel);\n                    // Construct TimeUnitComponents which will be combined into a\n                    // TimeUnitNode. This node may need to be inserted into the\n                    // dataflow if the selection is used across views that do not\n                    // have these time units defined.\n                    const component = {\n                        timeUnit: fieldDef.timeUnit,\n                        as: field,\n                        field: fieldDef.field\n                    };\n                    timeUnits[hash(component)] = component;\n                }\n                // Prevent duplicate projections on the same field.\n                // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n                if (!parsed[field]) {\n                    // Determine whether the tuple will store enumerated or ranged values.\n                    // Interval selections store ranges for continuous scales, and enumerations otherwise.\n                    // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n                    let tplType = 'E';\n                    if (type === 'interval') {\n                        const scaleType = model.getScaleComponent(channel).get('type');\n                        if (hasContinuousDomain(scaleType)) {\n                            tplType = 'R';\n                        }\n                    }\n                    else if (fieldDef.bin) {\n                        tplType = 'R-RE';\n                    }\n                    const p = { field, channel, type: tplType };\n                    p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n                    proj.items.push((parsed[field] = p));\n                    proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n                }\n            }\n            else {\n                log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            }\n        }\n        for (const field of fields !== null && fields !== void 0 ? fields : []) {\n            if (proj.hasField[field])\n                continue;\n            const p = { type: 'E', field };\n            p.signals = Object.assign({}, signalName(p, 'data'));\n            proj.items.push(p);\n            proj.hasField[field] = p;\n        }\n        if (init) {\n            selCmpt.init = init.map((v) => {\n                // Selections can be initialized either with a full object that maps projections to values\n                // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n                return proj.items.map(p => (isObject(v) ? (v[p.channel] !== undefined ? v[p.channel] : v[p.field]) : v));\n            });\n        }\n        if (!isEmpty(timeUnits)) {\n            proj.timeUnit = new TimeUnitNode(null, timeUnits);\n        }\n    },\n    signals: (model, selCmpt, allSignals) => {\n        const name = selCmpt.name + TUPLE_FIELDS;\n        const hasSignal = allSignals.filter(s => s.name === name);\n        return hasSignal.length > 0\n            ? allSignals\n            : allSignals.concat({\n                name,\n                value: selCmpt.project.items.map(proj => {\n                    const { signals, hasLegend } = proj, rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n                    rest.field = replacePathInField(rest.field);\n                    return rest;\n                })\n            });\n    }\n};\nexport default project;\n//# sourceMappingURL=project.js.map"]},"metadata":{},"sourceType":"module"}