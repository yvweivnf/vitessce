{"ast":null,"code":"import { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  extruded: false,\n  material: true\n};\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    const isSupported = GPUGridAggregator.isSupported(gl);\n\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n\n    super.initializeState({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false,\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      color: {\n        size: 3,\n        accessor: 'getColorWeight'\n      },\n      elevation: {\n        size: 3,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      return;\n    }\n\n    super.updateState(opts);\n    const {\n      aggregationDirty\n    } = this.state;\n\n    if (aggregationDirty) {\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n    const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n    return \"\".concat(latIdx, \"-\").concat(lonIdx);\n  }\n\n  getPositionForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo(_ref) {\n    let {\n      info,\n      mode\n    } = _ref;\n    const {\n      index\n    } = info;\n    let object = null;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator\n      } = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n\n      if (mode !== 'hover') {\n        const {\n          props\n        } = this;\n        let {\n          gridHash\n        } = this.state;\n\n        if (!gridHash) {\n          const {\n            gridOffset,\n            translation,\n            boundingBox\n          } = this.state;\n          const {\n            viewport\n          } = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({\n            gridHash\n          });\n        }\n\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const {\n      weights,\n      numRow,\n      numCol,\n      gridOrigin,\n      gridOffset\n    } = this.state;\n    const {\n      color,\n      elevation\n    } = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n    return new SubLayerClass({\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n      colorRange,\n      elevationRange,\n      colorDomain,\n      elevationDomain,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationScale,\n      extruded\n    }, this.getSubLayerProps({\n      id: 'gpu-grid-cell'\n    }), {\n      data: {\n        attributes: {\n          colors: color.aggregationBuffer,\n          elevations: elevation.aggregationBuffer\n        }\n      },\n      colorMaxMinBuffer: color.maxMinBuffer,\n      elevationMaxMinBuffer: elevation.maxMinBuffer,\n      numInstances: numCol * numRow\n    });\n  }\n\n  finalizeState() {\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {\n        aggregationBuffer,\n        maxMinBuffer\n      } = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    });\n    super.finalizeState();\n  }\n\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n    let {\n      boundingBox\n    } = this.state;\n\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {\n      dimension: dimensions.data,\n      compareAll: true\n    });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  _updateAccessors(opts) {\n    const {\n      colorAggregation,\n      elevationAggregation\n    } = opts.props;\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n\n}\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/gpu-grid-layer/gpu-grid-layer.js"],"names":["defaultProps","colorDomain","colorRange","getColorWeight","type","value","colorAggregation","elevationDomain","elevationRange","getElevationWeight","elevationAggregation","elevationScale","min","cellSize","max","coverage","getPosition","x","position","extruded","material","DIMENSIONS","data","props","POSITION_ATTRIBUTE_NAME","initializeState","gl","isSupported","GPUGridAggregator","log","dimensions","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","byteLength","accessor","size","divisor","elevation","positionAttributeName","attributeManager","fp64","updateState","aggregationDirty","gridHash","getHashKeyForIndex","gridOffset","gridSize","gridOrigin","boundingBox","yIndex","Math","index","xIndex","latIdx","lonIdx","getPositionForIndex","yPos","xPos","getPickingInfo","mode","object","gpuGridAggregator","colorInfo","pixelIndex","elevationInfo","colorValue","elevationValue","count","totalCount","viewport","attributes","cpuAggregation","pointToDensityGridDataCPU","key","cpuAggregationData","Object","info","Boolean","renderLayers","colorRangeToFlatArray","SubLayerClass","id","colors","elevations","aggregationBuffer","colorMaxMinBuffer","elevationMaxMinBuffer","numInstances","numCol","numRow","finalizeState","weight","updateAggregationState","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","attributesChanged","getBoundingBox","getGridParams","translation","aggregationDataDirty","dimension","compareAll","_updateAccessors","opts","AGGREGATION_OPERATION","GPUGridLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {log} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION} from '../utils/aggregation-operation-utils';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport {pointToDensityGridDataCPU} from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\n\nconst defaultProps = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n  // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false, // aggregation in world space\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      color: {size: 3, accessor: 'getColorWeight'},\n      elevation: {size: 3, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      // Skip update, layer not supported\n      return;\n    }\n    super.updateState(opts);\n    const {aggregationDirty} = this.state;\n    if (aggregationDirty) {\n      // reset cached CPU Aggregation results (used for picking)\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index) {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n    const latIdx = Math.floor(\n      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]\n    );\n    const lonIdx = Math.floor(\n      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]\n    );\n    return `${latIdx}-${lonIdx}`;\n  }\n\n  getPositionForIndex(index) {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    let object = null;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        // perform CPU aggregation for full list of points for each cell\n        const {props} = this;\n        let {gridHash} = this.state;\n        if (!gridHash) {\n          const {gridOffset, translation, boundingBox} = this.state;\n          const {viewport} = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({gridHash});\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n\n    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;\n    const {color, elevation} = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n\n    return new SubLayerClass(\n      {\n        gridSize: [numCol, numRow],\n        gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange,\n        elevationRange,\n        colorDomain,\n        elevationDomain,\n\n        cellSize: cellSizeMeters,\n        coverage,\n        material,\n        elevationScale,\n        extruded\n      },\n      this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }),\n      {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      }\n    );\n  }\n\n  finalizeState() {\n    const {color, elevation} = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {aggregationBuffer, maxMinBuffer} = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer?.delete();\n    });\n    super.finalizeState();\n  }\n\n  // Aggregation Overrides\n\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {dimensions} = this.state;\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    // any attribute changed\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      attributesChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {colorAggregation, elevationAggregation} = opts.props;\n    const {color, elevation} = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}