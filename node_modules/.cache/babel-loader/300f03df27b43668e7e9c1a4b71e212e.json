{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash as _hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\n\nfunction unquote(pattern) {\n  if (pattern[0] === \"'\" && pattern[pattern.length - 1] === \"'\" || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n    return pattern.slice(1, -1);\n  }\n\n  return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\n\n\nfunction parseExpression(field, parse) {\n  var f = accessPathWithDatum(field);\n\n  if (parse === 'number') {\n    return \"toNumber(\".concat(f, \")\");\n  } else if (parse === 'boolean') {\n    return \"toBoolean(\".concat(f, \")\");\n  } else if (parse === 'string') {\n    return \"toString(\".concat(f, \")\");\n  } else if (parse === 'date') {\n    return \"toDate(\".concat(f, \")\");\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    var specifier = unquote(parse.slice(5, parse.length));\n    return \"timeParse(\".concat(f, \",'\").concat(specifier, \"')\");\n  } else if (parse.startsWith('utc:')) {\n    var _specifier = unquote(parse.slice(4, parse.length));\n\n    return \"utcParse(\".concat(f, \",'\").concat(_specifier, \"')\");\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport function getImplicitFromFilterTransform(transform) {\n  var implicit = {};\n  forEachLeaf(transform.filter, function (filter) {\n    var _a;\n\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      var val = null; // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter['in'])[0];\n      } // else -- for filter expression, we can't infer anything\n\n\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromEncoding(model) {\n  var implicit = {};\n\n  function add(fieldDef) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (fieldDef.type === 'quantitative' && isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef(function (fieldDef, channel) {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        var mainChannel = getMainRangeChannel(channel);\n        var mainFieldDef = model.fieldDef(mainChannel);\n        add(Object.assign(Object.assign({}, fieldDef), {\n          type: mainFieldDef.type\n        }));\n      }\n    });\n  } // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n\n\n  if (isUnitModel(model)) {\n    var mark = model.mark,\n        markDef = model.markDef,\n        encoding = model.encoding;\n\n    if (isPathMark(mark) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n    !model.encoding.order) {\n      var dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      var dimensionChannelDef = encoding[dimensionChannel];\n\n      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === 'quantitative' && !(dimensionChannelDef.field in implicit)) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromSelection(model) {\n  var implicit = {};\n\n  if (isUnitModel(model) && model.component.selection) {\n    var _iterator = _createForOfIteratorHelper(keys(model.component.selection)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var name = _step.value;\n        var selCmpt = model.component.selection[name];\n\n        var _iterator2 = _createForOfIteratorHelper(selCmpt.project.items),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var proj = _step2.value;\n\n            if (!proj.channel && accessPathDepth(proj.field) > 1) {\n              implicit[proj.field] = 'flatten';\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return implicit;\n}\nexport var ParseNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(ParseNode, _DataFlowNode);\n\n  var _super = _createSuper(ParseNode);\n\n  function ParseNode(parent, parse) {\n    var _this;\n\n    _classCallCheck(this, ParseNode);\n\n    _this = _super.call(this, parent);\n    _this._parse = parse;\n    return _this;\n  }\n\n  _createClass(ParseNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ParseNode(null, duplicate(this._parse));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Parse \".concat(_hash(this._parse));\n    }\n    /**\n     * Creates a parse node from a data.format.parse and updates ancestorParse.\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n      other.remove();\n    }\n    /**\n     * Assemble an object for Vega's format.parse property.\n     */\n\n  }, {\n    key: \"assembleFormatParse\",\n    value: function assembleFormatParse() {\n      var formatParse = {};\n\n      var _iterator3 = _createForOfIteratorHelper(keys(this._parse)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var field = _step3.value;\n          var p = this._parse[field];\n\n          if (accessPathDepth(field) === 1) {\n            formatParse[field] = p;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return formatParse;\n    } // format parse depends and produces all fields in its parse\n\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(keys(this._parse));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(keys(this._parse));\n    }\n  }, {\n    key: \"assembleTransforms\",\n    value: function assembleTransforms() {\n      var _this2 = this;\n\n      var onlyNested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return keys(this._parse).filter(function (field) {\n        return onlyNested ? accessPathDepth(field) > 1 : true;\n      }).map(function (field) {\n        var expr = parseExpression(field, _this2._parse[field]);\n\n        if (!expr) {\n          return null;\n        }\n\n        var formula = {\n          type: 'formula',\n          expr: expr,\n          as: removePathFromField(field) // Vega output is always flattened\n\n        };\n        return formula;\n      }).filter(function (t) {\n        return t !== null;\n      });\n    }\n  }, {\n    key: \"parse\",\n    get: function get() {\n      return this._parse;\n    }\n  }], [{\n    key: \"makeExplicit\",\n    value: function makeExplicit(parent, model, ancestorParse) {\n      var _a; // Custom parse\n\n\n      var explicit = {};\n      var data = model.data;\n\n      if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {\n        explicit = data.format.parse;\n      }\n\n      return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n    }\n    /**\n     * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n     */\n\n  }, {\n    key: \"makeWithAncestors\",\n    value: function makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n      // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n      var _iterator4 = _createForOfIteratorHelper(keys(implicit)),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var field = _step4.value;\n          var parsedAs = ancestorParse.getWithExplicit(field);\n\n          if (parsedAs.value !== undefined) {\n            // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n            if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n              delete implicit[field];\n            } else {\n              log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(keys(explicit)),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _field = _step5.value;\n\n          var _parsedAs = ancestorParse.get(_field);\n\n          if (_parsedAs !== undefined) {\n            // Don't parse a field again if it has been parsed with the same type already.\n            if (_parsedAs === explicit[_field]) {\n              delete explicit[_field];\n            } else {\n              log.warn(log.message.differentParse(_field, explicit[_field], _parsedAs));\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var parse = new Split(explicit, implicit); // add the format parse from this model so that children don't parse the same field again\n\n      ancestorParse.copyAll(parse); // copy only non-null parses\n\n      var p = {};\n\n      var _iterator6 = _createForOfIteratorHelper(keys(parse.combine())),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var key = _step6.value;\n          var val = parse.get(key);\n\n          if (val !== null) {\n            p[key] = val;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (keys(p).length === 0 || ancestorParse.parseNothing) {\n        return null;\n      }\n\n      return new ParseNode(parent, p);\n    }\n  }]);\n\n  return ParseNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/formatparse.ts"],"names":[],"mappings":";;;;;AACA,SAAQ,QAAR,EAAkB,QAAlB,QAAiC,WAAjC;AAEA,SAAQ,UAAR,QAAyB,iBAAzB;AACA,SAAQ,mBAAR,QAAoD,eAApD;AACA,SACE,UADF,EAEE,8BAFF,EAGE,eAHF,EAIE,eAJF,QAMO,kBANP;AAOA,SAAQ,WAAR,QAAiC,YAAjC;AACA,SAAkB,UAAlB,QAAmC,gBAAnC;AACA,OAAO,KAAK,GAAZ,MAAqB,WAArB;AACA,SAAQ,WAAR,QAA0B,eAA1B;AACA,SAAQ,UAAR,QAAyB,YAAzB;AACA,SACE,qBADF,EAEE,mBAFF,EAGE,kBAHF,EAIE,mBAJF,EAKE,kBALF,EAME,qBANF,EAOE,gBAPF,EAQE,qBARF,QASO,iBATP;AAUA,SAAQ,WAAR,QAA0B,YAA1B;AAEA,SAAQ,eAAR,EAAyB,mBAAzB,EAAoD,SAApD,EAA+D,IAAI,IAAJ,KAA/D,EAAqE,IAArE,EAA2E,mBAA3E,QAAqG,YAArG;AACA,SAAQ,gBAAR,QAA+B,WAA/B;AACA,SAAQ,YAAR,EAAsB,WAAtB,QAA+C,UAA/C;AACA,SAAQ,KAAR,QAAoB,UAApB;AACA,SAAQ,YAAR,QAA2B,YAA3B;AAEA;;;;AAGA,SAAS,OAAT,CAAiB,OAAjB,EAAgC;AAC9B,MACG,OAAO,CAAC,CAAD,CAAP,KAAe,GAAf,IAAsB,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAP,KAAgC,GAAvD,IACC,OAAO,CAAC,CAAD,CAAP,KAAe,GAAf,IAAsB,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAP,KAAgC,GAFzD,EAGE;AACA,WAAO,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAP;AACD;;AACD,SAAO,OAAP;AACD;AAED;;;;;;AAIA,SAAS,eAAT,CAAyB,KAAzB,EAAwC,KAAxC,EAAqD;AACnD,MAAM,CAAC,GAAG,mBAAmB,CAAC,KAAD,CAA7B;;AACA,MAAI,KAAK,KAAK,QAAd,EAAwB;AACtB,8BAAmB,CAAnB;AACD,GAFD,MAEO,IAAI,KAAK,KAAK,SAAd,EAAyB;AAC9B,+BAAoB,CAApB;AACD,GAFM,MAEA,IAAI,KAAK,KAAK,QAAd,EAAwB;AAC7B,8BAAmB,CAAnB;AACD,GAFM,MAEA,IAAI,KAAK,KAAK,MAAd,EAAsB;AAC3B,4BAAiB,CAAjB;AACD,GAFM,MAEA,IAAI,KAAK,KAAK,SAAd,EAAyB;AAC9B,WAAO,CAAP;AACD,GAFM,MAEA,IAAI,KAAK,CAAC,UAAN,CAAiB,OAAjB,CAAJ,EAA+B;AACpC,QAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,KAAK,CAAC,MAArB,CAAD,CAAzB;AACA,+BAAoB,CAApB,eAA0B,SAA1B;AACD,GAHM,MAGA,IAAI,KAAK,CAAC,UAAN,CAAiB,MAAjB,CAAJ,EAA8B;AACnC,QAAM,UAAS,GAAG,OAAO,CAAC,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,KAAK,CAAC,MAArB,CAAD,CAAzB;;AACA,8BAAmB,CAAnB,eAAyB,UAAzB;AACD,GAHM,MAGA;AACL,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,iBAAZ,CAA8B,KAA9B,CAAT;AACA,WAAO,IAAP;AACD;AACF;;AAED,OAAM,SAAU,8BAAV,CAAyC,SAAzC,EAAmE;AACvE,MAAM,QAAQ,GAAiB,EAA/B;AACA,EAAA,WAAW,CAAC,SAAS,CAAC,MAAX,EAAmB,UAAA,MAAM,EAAG;;;AACrC,QAAI,gBAAgB,CAAC,MAAD,CAApB,EAA8B;AAC5B;AACA,UAAI,GAAG,GAAqD,IAA5D,CAF4B,CAI5B;AACA;AACA;;AACA,UAAI,qBAAqB,CAAC,MAAD,CAAzB,EAAmC;AACjC,QAAA,GAAG,GAAG,gBAAgB,CAAC,MAAM,CAAC,KAAR,CAAtB;AACD,OAFD,MAEO,IAAI,mBAAmB,CAAC,MAAD,CAAvB,EAAiC;AACtC,QAAA,GAAG,GAAG,gBAAgB,CAAC,MAAM,CAAC,GAAR,CAAtB;AACD,OAFM,MAEA,IAAI,kBAAkB,CAAC,MAAD,CAAtB,EAAgC;AACrC,QAAA,GAAG,GAAG,gBAAgB,CAAC,MAAM,CAAC,EAAR,CAAtB;AACD,OAFM,MAEA,IAAI,kBAAkB,CAAC,MAAD,CAAtB,EAAgC;AACrC,QAAA,GAAG,GAAG,gBAAgB,CAAC,MAAM,CAAC,EAAR,CAAtB;AACD,OAFM,MAEA,IAAI,mBAAmB,CAAC,MAAD,CAAvB,EAAiC;AACtC,QAAA,GAAG,GAAG,gBAAgB,CAAC,MAAM,CAAC,GAAR,CAAtB;AACD,OAFM,MAEA,IAAI,qBAAqB,CAAC,MAAD,CAAzB,EAAmC;AACxC,QAAA,GAAG,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAN;AACD,OAFM,MAEA,IAAI,qBAAqB,CAAC,MAAD,CAAzB,EAAmC;AACxC,QAAA,GAAG,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,KAAP,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,EAAZ,GAAgB,MAAM,CAAC,IAAD,CAAvB,EAA+B,CAA/B,CAAN;AACD,OArB2B,CAqB1B;;;AAEF,UAAI,GAAJ,EAAS;AACP,YAAI,UAAU,CAAC,GAAD,CAAd,EAAqB;AACnB,UAAA,QAAQ,CAAC,MAAM,CAAC,KAAR,CAAR,GAAyB,MAAzB;AACD,SAFD,MAEO,IAAI,QAAQ,CAAC,GAAD,CAAZ,EAAmB;AACxB,UAAA,QAAQ,CAAC,MAAM,CAAC,KAAR,CAAR,GAAyB,QAAzB;AACD,SAFM,MAEA,IAAI,QAAQ,CAAC,GAAD,CAAZ,EAAmB;AACxB,UAAA,QAAQ,CAAC,MAAM,CAAC,KAAR,CAAR,GAAyB,QAAzB;AACD;AACF;;AAED,UAAI,MAAM,CAAC,QAAX,EAAqB;AACnB,QAAA,QAAQ,CAAC,MAAM,CAAC,KAAR,CAAR,GAAyB,MAAzB;AACD;AACF;AACF,GAtCU,CAAX;AAwCA,SAAO,QAAP;AACD;AAED;;;;AAGA,OAAM,SAAU,uBAAV,CAAkC,KAAlC,EAA8C;AAClD,MAAM,QAAQ,GAAiB,EAA/B;;AAEA,WAAS,GAAT,CAAa,QAAb,EAA4C;AAC1C,QAAI,8BAA8B,CAAC,QAAD,CAAlC,EAA8C;AAC5C,MAAA,QAAQ,CAAC,QAAQ,CAAC,KAAV,CAAR,GAA2B,MAA3B;AACD,KAFD,MAEO,IACL,QAAQ,CAAC,IAAT,KAAkB,cAAlB,IACA,UAAU,CAAC,QAAQ,CAAC,SAAV,CAFL,CAE0B;AAF1B,MAGL;AACA,MAAA,QAAQ,CAAC,QAAQ,CAAC,KAAV,CAAR,GAA2B,QAA3B;AACD,KALM,MAKA,IAAI,eAAe,CAAC,QAAQ,CAAC,KAAV,CAAf,GAAkC,CAAtC,EAAyC;AAC9C;AACA;AACA,UAAI,EAAE,QAAQ,CAAC,KAAT,IAAkB,QAApB,CAAJ,EAAmC;AACjC,QAAA,QAAQ,CAAC,QAAQ,CAAC,KAAV,CAAR,GAA2B,SAA3B;AACD;AACF,KANM,MAMA,IAAI,eAAe,CAAC,QAAD,CAAf,IAA6B,WAAW,CAAC,QAAQ,CAAC,IAAV,CAAxC,IAA2D,eAAe,CAAC,QAAQ,CAAC,IAAT,CAAc,KAAf,CAAf,GAAuC,CAAtG,EAAyG;AAC9G;AACA,UAAI,EAAE,QAAQ,CAAC,IAAT,CAAc,KAAd,IAAuB,QAAzB,CAAJ,EAAwC;AACtC,QAAA,QAAQ,CAAC,QAAQ,CAAC,IAAT,CAAc,KAAf,CAAR,GAAgC,SAAhC;AACD;AACF;AACF;;AAED,MAAI,WAAW,CAAC,KAAD,CAAX,IAAsB,YAAY,CAAC,KAAD,CAAtC,EAA+C;AAC7C;AACA,IAAA,KAAK,CAAC,eAAN,CAAsB,UAAC,QAAD,EAAW,OAAX,EAAsB;AAC1C,UAAI,eAAe,CAAC,QAAD,CAAnB,EAA+B;AAC7B,QAAA,GAAG,CAAC,QAAD,CAAH;AACD,OAFD,MAEO;AACL,YAAM,WAAW,GAAG,mBAAmB,CAAC,OAAD,CAAvC;AACA,YAAM,YAAY,GAAG,KAAK,CAAC,QAAN,CAAe,WAAf,CAArB;AACA,QAAA,GAAG,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACE,QADF,CAAA,EACU;AACX,UAAA,IAAI,EAAE,YAAY,CAAC;AADR,SADV,CAAA,CAAH;AAID;AACF,KAXD;AAYD,GAvCiD,CAyClD;;;AACA,MAAI,WAAW,CAAC,KAAD,CAAf,EAAwB;AAAA,QACf,IADe,GACY,KADZ,CACf,IADe;AAAA,QACT,OADS,GACY,KADZ,CACT,OADS;AAAA,QACA,QADA,GACY,KADZ,CACA,QADA;;AAEtB,QACE,UAAU,CAAC,IAAD,CAAV,IACA;AACA,KAAC,KAAK,CAAC,QAAN,CAAe,KAHlB,EAIE;AACA,UAAM,gBAAgB,GAAG,OAAO,CAAC,MAAR,KAAmB,YAAnB,GAAkC,GAAlC,GAAwC,GAAjE;AACA,UAAM,mBAAmB,GAAG,QAAQ,CAAC,gBAAD,CAApC;;AACA,UACE,UAAU,CAAC,mBAAD,CAAV,IACA,mBAAmB,CAAC,IAApB,KAA6B,cAD7B,IAEA,EAAE,mBAAmB,CAAC,KAApB,IAA6B,QAA/B,CAHF,EAIE;AACA,QAAA,QAAQ,CAAC,mBAAmB,CAAC,KAArB,CAAR,GAAsC,QAAtC;AACD;AACF;AACF;;AAED,SAAO,QAAP;AACD;AAED;;;;AAGA,OAAM,SAAU,wBAAV,CAAmC,KAAnC,EAA+C;AACnD,MAAM,QAAQ,GAAiB,EAA/B;;AAEA,MAAI,WAAW,CAAC,KAAD,CAAX,IAAsB,KAAK,CAAC,SAAN,CAAgB,SAA1C,EAAqD;AAAA,+CAChC,IAAI,CAAC,KAAK,CAAC,SAAN,CAAgB,SAAjB,CAD4B;AAAA;;AAAA;AACnD,0DAAoD;AAAA,YAAzC,IAAyC;AAClD,YAAM,OAAO,GAAG,KAAK,CAAC,SAAN,CAAgB,SAAhB,CAA0B,IAA1B,CAAhB;;AADkD,oDAE/B,OAAO,CAAC,OAAR,CAAgB,KAFe;AAAA;;AAAA;AAElD,iEAA0C;AAAA,gBAA/B,IAA+B;;AACxC,gBAAI,CAAC,IAAI,CAAC,OAAN,IAAiB,eAAe,CAAC,IAAI,CAAC,KAAN,CAAf,GAA8B,CAAnD,EAAsD;AACpD,cAAA,QAAQ,CAAC,IAAI,CAAC,KAAN,CAAR,GAAuB,SAAvB;AACD;AACF;AANiD;AAAA;AAAA;AAAA;AAAA;AAOnD;AARkD;AAAA;AAAA;AAAA;AAAA;AASpD;;AAED,SAAO,QAAP;AACD;AAED,WAAa,SAAb;AAAA;;AAAA;;AAOE,qBAAY,MAAZ,EAAkC,KAAlC,EAA8C;AAAA;;AAAA;;AAC5C,8BAAM,MAAN;AAEA,UAAK,MAAL,GAAc,KAAd;AAH4C;AAI7C;;AAXH;AAAA;AAAA,4BAGc;AACV,aAAO,IAAI,SAAJ,CAAc,IAAd,EAAoB,SAAS,CAAC,KAAK,MAAN,CAA7B,CAAP;AACD;AALH;AAAA;AAAA,2BAaa;AACT,6BAAgB,KAAI,CAAC,KAAK,MAAN,CAApB;AACD;AAED;;;;AAjBF;AAAA;AAAA,0BA+Fe,KA/Ff,EA+F+B;AAC3B,WAAK,MAAL,GAAW,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,KAAK,MAAZ,CAAA,EAAuB,KAAK,CAAC,KAA7B,CAAX;AACA,MAAA,KAAK,CAAC,MAAN;AACD;AAED;;;;AApGF;AAAA;AAAA,0CAuG4B;AACxB,UAAM,WAAW,GAAiB,EAAlC;;AADwB,kDAEJ,IAAI,CAAC,KAAK,MAAN,CAFA;AAAA;;AAAA;AAExB,+DAAuC;AAAA,cAA5B,KAA4B;AACrC,cAAM,CAAC,GAAG,KAAK,MAAL,CAAY,KAAZ,CAAV;;AACA,cAAI,eAAe,CAAC,KAAD,CAAf,KAA2B,CAA/B,EAAkC;AAChC,YAAA,WAAW,CAAC,KAAD,CAAX,GAAqB,CAArB;AACD;AACF;AAPuB;AAAA;AAAA;AAAA;AAAA;;AAQxB,aAAO,WAAP;AACD,KAhHH,CAkHE;;AAlHF;AAAA;AAAA,qCAmHuB;AACnB,aAAO,IAAI,GAAJ,CAAQ,IAAI,CAAC,KAAK,MAAN,CAAZ,CAAP;AACD;AArHH;AAAA;AAAA,sCAuHwB;AACpB,aAAO,IAAI,GAAJ,CAAQ,IAAI,CAAC,KAAK,MAAN,CAAZ,CAAP;AACD;AAzHH;AAAA;AAAA,yCA2H8C;AAAA;;AAAA,UAAlB,UAAkB,uEAAL,KAAK;AAC1C,aAAO,IAAI,CAAC,KAAK,MAAN,CAAJ,CACJ,MADI,CACG,UAAA,KAAK;AAAA,eAAK,UAAU,GAAG,eAAe,CAAC,KAAD,CAAf,GAAyB,CAA5B,GAAgC,IAA/C;AAAA,OADR,EAEJ,GAFI,CAEA,UAAA,KAAK,EAAG;AACX,YAAM,IAAI,GAAG,eAAe,CAAC,KAAD,EAAQ,MAAI,CAAC,MAAL,CAAY,KAAZ,CAAR,CAA5B;;AACA,YAAI,CAAC,IAAL,EAAW;AACT,iBAAO,IAAP;AACD;;AAED,YAAM,OAAO,GAAuB;AAClC,UAAA,IAAI,EAAE,SAD4B;AAElC,UAAA,IAAI,EAAJ,IAFkC;AAGlC,UAAA,EAAE,EAAE,mBAAmB,CAAC,KAAD,CAHW,CAGH;;AAHG,SAApC;AAKA,eAAO,OAAP;AACD,OAdI,EAeJ,MAfI,CAeG,UAAA,CAAC;AAAA,eAAI,CAAC,KAAK,IAAV;AAAA,OAfJ,CAAP;AAgBD;AA5IH;AAAA;AAAA,wBA2FkB;AACd,aAAO,KAAK,MAAZ;AACD;AA7FH;AAAA;AAAA,iCAoB6B,MApB7B,EAoBmD,KApBnD,EAoBiE,aApBjE,EAoB6F;aAAA,CACzF;;;AACA,UAAI,QAAQ,GAAG,EAAf;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,IAAnB;;AACA,UAAI,CAAC,WAAW,CAAC,IAAD,CAAZ,KAAsB,CAAA,EAAA,GAAA,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,MAAN,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAY,EAAA,CAAE,KAApC,CAAJ,EAA+C;AAC7C,QAAA,QAAQ,GAAG,IAAI,CAAC,MAAL,CAAY,KAAvB;AACD;;AAED,aAAO,KAAK,iBAAL,CAAuB,MAAvB,EAA+B,QAA/B,EAAyC,EAAzC,EAA6C,aAA7C,CAAP;AACD;AAED;;;;AA/BF;AAAA;AAAA,sCAmCI,MAnCJ,EAoCI,QApCJ,EAqCI,QArCJ,EAsCI,aAtCJ,EAsCgC;AAE5B;AAF4B,kDAGR,IAAI,CAAC,QAAD,CAHI;AAAA;;AAAA;AAG5B,+DAAoC;AAAA,cAAzB,KAAyB;AAClC,cAAM,QAAQ,GAAG,aAAa,CAAC,eAAd,CAA8B,KAA9B,CAAjB;;AACA,cAAI,QAAQ,CAAC,KAAT,KAAmB,SAAvB,EAAkC;AAChC;AACA,gBACE,QAAQ,CAAC,QAAT,IACA,QAAQ,CAAC,KAAT,KAAmB,QAAQ,CAAC,KAAD,CAD3B,IAEA,QAAQ,CAAC,KAAT,KAAmB,SAFnB,IAGA,QAAQ,CAAC,KAAD,CAAR,KAAoB,SAJtB,EAKE;AACA,qBAAO,QAAQ,CAAC,KAAD,CAAf;AACD,aAPD,MAOO;AACL,cAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,cAAZ,CAA2B,KAA3B,EAAkC,QAAQ,CAAC,KAAD,CAA1C,EAAmD,QAAQ,CAAC,KAA5D,CAAT;AACD;AACF;AACF;AAlB2B;AAAA;AAAA;AAAA;AAAA;;AAAA,kDAoBR,IAAI,CAAC,QAAD,CApBI;AAAA;;AAAA;AAoB5B,+DAAoC;AAAA,cAAzB,MAAyB;;AAClC,cAAM,SAAQ,GAAG,aAAa,CAAC,GAAd,CAAkB,MAAlB,CAAjB;;AACA,cAAI,SAAQ,KAAK,SAAjB,EAA4B;AAC1B;AACA,gBAAI,SAAQ,KAAK,QAAQ,CAAC,MAAD,CAAzB,EAAkC;AAChC,qBAAO,QAAQ,CAAC,MAAD,CAAf;AACD,aAFD,MAEO;AACL,cAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,cAAZ,CAA2B,MAA3B,EAAkC,QAAQ,CAAC,MAAD,CAA1C,EAAmD,SAAnD,CAAT;AACD;AACF;AACF;AA9B2B;AAAA;AAAA;AAAA;AAAA;;AAgC5B,UAAM,KAAK,GAAG,IAAI,KAAJ,CAAU,QAAV,EAAoB,QAApB,CAAd,CAhC4B,CAkC5B;;AACA,MAAA,aAAa,CAAC,OAAd,CAAsB,KAAtB,EAnC4B,CAqC5B;;AACA,UAAM,CAAC,GAAiB,EAAxB;;AAtC4B,kDAuCV,IAAI,CAAC,KAAK,CAAC,OAAN,EAAD,CAvCM;AAAA;;AAAA;AAuC5B,+DAAyC;AAAA,cAA9B,GAA8B;AACvC,cAAM,GAAG,GAAG,KAAK,CAAC,GAAN,CAAU,GAAV,CAAZ;;AACA,cAAI,GAAG,KAAK,IAAZ,EAAkB;AAChB,YAAA,CAAC,CAAC,GAAD,CAAD,GAAS,GAAT;AACD;AACF;AA5C2B;AAAA;AAAA;AAAA;AAAA;;AA8C5B,UAAI,IAAI,CAAC,CAAD,CAAJ,CAAQ,MAAR,KAAmB,CAAnB,IAAwB,aAAa,CAAC,YAA1C,EAAwD;AACtD,eAAO,IAAP;AACD;;AAED,aAAO,IAAI,SAAJ,CAAc,MAAd,EAAsB,CAAtB,CAAP;AACD;AAzFH;;AAAA;AAAA,EAA+B,YAA/B","sourceRoot":"","sourcesContent":["import { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern) {\n    if ((pattern[0] === \"'\" && pattern[pattern.length - 1] === \"'\") ||\n        (pattern[0] === '\"' && pattern[pattern.length - 1] === '\"')) {\n        return pattern.slice(1, -1);\n    }\n    return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field, parse) {\n    const f = accessPathWithDatum(field);\n    if (parse === 'number') {\n        return `toNumber(${f})`;\n    }\n    else if (parse === 'boolean') {\n        return `toBoolean(${f})`;\n    }\n    else if (parse === 'string') {\n        return `toString(${f})`;\n    }\n    else if (parse === 'date') {\n        return `toDate(${f})`;\n    }\n    else if (parse === 'flatten') {\n        return f;\n    }\n    else if (parse.startsWith('date:')) {\n        const specifier = unquote(parse.slice(5, parse.length));\n        return `timeParse(${f},'${specifier}')`;\n    }\n    else if (parse.startsWith('utc:')) {\n        const specifier = unquote(parse.slice(4, parse.length));\n        return `utcParse(${f},'${specifier}')`;\n    }\n    else {\n        log.warn(log.message.unrecognizedParse(parse));\n        return null;\n    }\n}\nexport function getImplicitFromFilterTransform(transform) {\n    const implicit = {};\n    forEachLeaf(transform.filter, filter => {\n        var _a;\n        if (isFieldPredicate(filter)) {\n            // Automatically add a parse node for filters with filter objects\n            let val = null;\n            // For EqualFilter, just use the equal property.\n            // For RangeFilter and OneOfFilter, all array members should have\n            // the same type, so we only use the first one.\n            if (isFieldEqualPredicate(filter)) {\n                val = signalRefOrValue(filter.equal);\n            }\n            else if (isFieldLTEPredicate(filter)) {\n                val = signalRefOrValue(filter.lte);\n            }\n            else if (isFieldLTPredicate(filter)) {\n                val = signalRefOrValue(filter.lt);\n            }\n            else if (isFieldGTPredicate(filter)) {\n                val = signalRefOrValue(filter.gt);\n            }\n            else if (isFieldGTEPredicate(filter)) {\n                val = signalRefOrValue(filter.gte);\n            }\n            else if (isFieldRangePredicate(filter)) {\n                val = filter.range[0];\n            }\n            else if (isFieldOneOfPredicate(filter)) {\n                val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter['in'])[0];\n            } // else -- for filter expression, we can't infer anything\n            if (val) {\n                if (isDateTime(val)) {\n                    implicit[filter.field] = 'date';\n                }\n                else if (isNumber(val)) {\n                    implicit[filter.field] = 'number';\n                }\n                else if (isString(val)) {\n                    implicit[filter.field] = 'string';\n                }\n            }\n            if (filter.timeUnit) {\n                implicit[filter.field] = 'date';\n            }\n        }\n    });\n    return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model) {\n    const implicit = {};\n    function add(fieldDef) {\n        if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n            implicit[fieldDef.field] = 'date';\n        }\n        else if (fieldDef.type === 'quantitative' &&\n            isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n        ) {\n            implicit[fieldDef.field] = 'number';\n        }\n        else if (accessPathDepth(fieldDef.field) > 1) {\n            // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n            // (Parsing numbers / dates already flattens numeric and temporal fields.)\n            if (!(fieldDef.field in implicit)) {\n                implicit[fieldDef.field] = 'flatten';\n            }\n        }\n        else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n            // Flatten fields that we sort by but that are not otherwise flattened.\n            if (!(fieldDef.sort.field in implicit)) {\n                implicit[fieldDef.sort.field] = 'flatten';\n            }\n        }\n    }\n    if (isUnitModel(model) || isFacetModel(model)) {\n        // Parse encoded fields\n        model.forEachFieldDef((fieldDef, channel) => {\n            if (isTypedFieldDef(fieldDef)) {\n                add(fieldDef);\n            }\n            else {\n                const mainChannel = getMainRangeChannel(channel);\n                const mainFieldDef = model.fieldDef(mainChannel);\n                add(Object.assign(Object.assign({}, fieldDef), { type: mainFieldDef.type }));\n            }\n        });\n    }\n    // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n    if (isUnitModel(model)) {\n        const { mark, markDef, encoding } = model;\n        if (isPathMark(mark) &&\n            // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n            !model.encoding.order) {\n            const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n            const dimensionChannelDef = encoding[dimensionChannel];\n            if (isFieldDef(dimensionChannelDef) &&\n                dimensionChannelDef.type === 'quantitative' &&\n                !(dimensionChannelDef.field in implicit)) {\n                implicit[dimensionChannelDef.field] = 'number';\n            }\n        }\n    }\n    return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model) {\n    const implicit = {};\n    if (isUnitModel(model) && model.component.selection) {\n        for (const name of keys(model.component.selection)) {\n            const selCmpt = model.component.selection[name];\n            for (const proj of selCmpt.project.items) {\n                if (!proj.channel && accessPathDepth(proj.field) > 1) {\n                    implicit[proj.field] = 'flatten';\n                }\n            }\n        }\n    }\n    return implicit;\n}\nexport class ParseNode extends DataFlowNode {\n    constructor(parent, parse) {\n        super(parent);\n        this._parse = parse;\n    }\n    clone() {\n        return new ParseNode(null, duplicate(this._parse));\n    }\n    hash() {\n        return `Parse ${hash(this._parse)}`;\n    }\n    /**\n     * Creates a parse node from a data.format.parse and updates ancestorParse.\n     */\n    static makeExplicit(parent, model, ancestorParse) {\n        var _a;\n        // Custom parse\n        let explicit = {};\n        const data = model.data;\n        if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {\n            explicit = data.format.parse;\n        }\n        return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n    }\n    /**\n     * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n     */\n    static makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n        // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n        for (const field of keys(implicit)) {\n            const parsedAs = ancestorParse.getWithExplicit(field);\n            if (parsedAs.value !== undefined) {\n                // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n                if (parsedAs.explicit ||\n                    parsedAs.value === implicit[field] ||\n                    parsedAs.value === 'derived' ||\n                    implicit[field] === 'flatten') {\n                    delete implicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n                }\n            }\n        }\n        for (const field of keys(explicit)) {\n            const parsedAs = ancestorParse.get(field);\n            if (parsedAs !== undefined) {\n                // Don't parse a field again if it has been parsed with the same type already.\n                if (parsedAs === explicit[field]) {\n                    delete explicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n                }\n            }\n        }\n        const parse = new Split(explicit, implicit);\n        // add the format parse from this model so that children don't parse the same field again\n        ancestorParse.copyAll(parse);\n        // copy only non-null parses\n        const p = {};\n        for (const key of keys(parse.combine())) {\n            const val = parse.get(key);\n            if (val !== null) {\n                p[key] = val;\n            }\n        }\n        if (keys(p).length === 0 || ancestorParse.parseNothing) {\n            return null;\n        }\n        return new ParseNode(parent, p);\n    }\n    get parse() {\n        return this._parse;\n    }\n    merge(other) {\n        this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n        other.remove();\n    }\n    /**\n     * Assemble an object for Vega's format.parse property.\n     */\n    assembleFormatParse() {\n        const formatParse = {};\n        for (const field of keys(this._parse)) {\n            const p = this._parse[field];\n            if (accessPathDepth(field) === 1) {\n                formatParse[field] = p;\n            }\n        }\n        return formatParse;\n    }\n    // format parse depends and produces all fields in its parse\n    producedFields() {\n        return new Set(keys(this._parse));\n    }\n    dependentFields() {\n        return new Set(keys(this._parse));\n    }\n    assembleTransforms(onlyNested = false) {\n        return keys(this._parse)\n            .filter(field => (onlyNested ? accessPathDepth(field) > 1 : true))\n            .map(field => {\n            const expr = parseExpression(field, this._parse[field]);\n            if (!expr) {\n                return null;\n            }\n            const formula = {\n                type: 'formula',\n                expr,\n                as: removePathFromField(field) // Vega output is always flattened\n            };\n            return formula;\n        })\n            .filter(t => t !== null);\n    }\n}\n//# sourceMappingURL=formatparse.js.map"]},"metadata":{},"sourceType":"module"}