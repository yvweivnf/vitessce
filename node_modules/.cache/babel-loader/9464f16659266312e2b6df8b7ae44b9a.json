{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScaleMode = void 0;\n\nvar _bbox = _interopRequireDefault(require(\"@turf/bbox\"));\n\nvar _centroid = _interopRequireDefault(require(\"@turf/centroid\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _bboxPolygon = _interopRequireDefault(require(\"@turf/bbox-polygon\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _polygonToLine = _interopRequireDefault(require(\"@turf/polygon-to-line\"));\n\nvar _meta = require(\"@turf/meta\");\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _transformScale = _interopRequireDefault(require(\"@turf/transform-scale\"));\n\nvar _invariant = require(\"@turf/invariant\");\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ScaleMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(ScaleMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(ScaleMode);\n\n  function ScaleMode() {\n    var _this;\n\n    _classCallCheck(this, ScaleMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_geometryBeingScaled\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_selectedEditHandle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_cornerGuidePoints\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_cursor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isScaling\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isSinglePointGeometrySelected\", function (geometry) {\n      var _ref = geometry || {},\n          features = _ref.features;\n\n      if (Array.isArray(features) && features.length === 1) {\n        // @ts-ignore\n        var _getGeom = (0, _invariant.getGeom)(features[0]),\n            type = _getGeom.type;\n\n        return type === 'Point';\n      }\n\n      return false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_getOppositeScaleHandle\", function (selectedHandle) {\n      var selectedHandleIndex = selectedHandle && selectedHandle.properties && Array.isArray(selectedHandle.properties.positionIndexes) && selectedHandle.properties.positionIndexes[0];\n\n      if (typeof selectedHandleIndex !== 'number') {\n        return null;\n      }\n\n      var guidePointCount = _this._cornerGuidePoints.length;\n      var oppositeIndex = (selectedHandleIndex + guidePointCount / 2) % guidePointCount;\n      return _this._cornerGuidePoints.find(function (p) {\n        if (!Array.isArray(p.properties.positionIndexes)) {\n          return false;\n        }\n\n        return p.properties.positionIndexes[0] === oppositeIndex;\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_getUpdatedData\", function (props, editedData) {\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n      var selectedIndexes = props.selectedIndexes;\n\n      for (var i = 0; i < selectedIndexes.length; i++) {\n        var selectedIndex = selectedIndexes[i];\n        var movedFeature = editedData.features[i];\n        updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n      }\n\n      return updatedData.getObject();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isEditHandleSelected\", function () {\n      return Boolean(_this._selectedEditHandle);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getScaleAction\", function (startDragPoint, currentPoint, editType, props) {\n      if (!_this._selectedEditHandle) {\n        return null;\n      }\n\n      var oppositeHandle = _this._getOppositeScaleHandle(_this._selectedEditHandle);\n\n      var origin = (0, _invariant.getCoord)(oppositeHandle); // @ts-ignore\n\n      var scaleFactor = getScaleFactor(origin, startDragPoint, currentPoint); // @ts-ignore\n\n      var scaledFeatures = (0, _transformScale[\"default\"])( // @ts-ignore\n      _this._geometryBeingScaled, scaleFactor, {\n        origin: origin\n      });\n      return {\n        updatedData: _this._getUpdatedData(props, scaledFeatures),\n        editType: editType,\n        editContext: {\n          featureIndexes: props.selectedIndexes\n        }\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateCursor\", function (props) {\n      if (_this._selectedEditHandle) {\n        if (_this._cursor) {\n          props.onUpdateCursor(_this._cursor);\n        }\n\n        var cursorGeometry = _this.getSelectedFeaturesAsFeatureCollection(props); // Get resize cursor direction from the hovered scale editHandle (e.g. nesw or nwse)\n\n\n        var centroid = (0, _centroid[\"default\"])(cursorGeometry);\n        var bearing = (0, _bearing[\"default\"])(centroid, _this._selectedEditHandle);\n        var positiveBearing = bearing < 0 ? bearing + 180 : bearing;\n\n        if (positiveBearing >= 0 && positiveBearing <= 90 || positiveBearing >= 180 && positiveBearing <= 270) {\n          _this._cursor = 'nesw-resize';\n          props.onUpdateCursor('nesw-resize');\n        } else {\n          _this._cursor = 'nwse-resize';\n          props.onUpdateCursor('nwse-resize');\n        }\n      } else {\n        props.onUpdateCursor(null);\n        _this._cursor = null;\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(ScaleMode, [{\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      if (!this._isScaling) {\n        var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);\n        this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === 'scale' ? selectedEditHandle : null;\n\n        if (selectedEditHandle) {\n          this.updateCursor(props);\n        }\n      }\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      if (this._selectedEditHandle) {\n        this._isScaling = true;\n        this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection(props);\n      }\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      if (!this._isScaling) {\n        return;\n      }\n\n      props.onUpdateCursor(this._cursor);\n      var scaleAction = this.getScaleAction(event.pointerDownMapCoords, event.mapCoords, 'scaling', props);\n\n      if (scaleAction) {\n        props.onEdit(scaleAction);\n      }\n\n      event.cancelPan();\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      if (this._isScaling) {\n        // Scale the geometry\n        var scaleAction = this.getScaleAction(event.pointerDownMapCoords, event.mapCoords, 'scaled', props);\n\n        if (scaleAction) {\n          props.onEdit(scaleAction);\n        }\n\n        props.onUpdateCursor(null);\n        this._geometryBeingScaled = null;\n        this._selectedEditHandle = null;\n        this._cursor = null;\n        this._isScaling = false;\n      }\n    }\n  }, {\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      this._cornerGuidePoints = [];\n      var selectedGeometry = this.getSelectedFeaturesAsFeatureCollection(props); // Add buffer to the enveloping box if a single Point feature is selected\n\n      if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n        return {\n          type: 'FeatureCollection',\n          features: []\n        };\n      }\n\n      var boundingBox = (0, _bboxPolygon[\"default\"])((0, _bbox[\"default\"])(selectedGeometry));\n      boundingBox.properties.mode = 'scale';\n      var cornerGuidePoints = [];\n      (0, _meta.coordEach)(boundingBox, function (coord, coordIndex) {\n        if (coordIndex < 4) {\n          // Get corner midpoint guides from the enveloping box\n          var cornerPoint = (0, _helpers.point)(coord, {\n            guideType: 'editHandle',\n            editHandleType: 'scale',\n            positionIndexes: [coordIndex]\n          });\n          cornerGuidePoints.push(cornerPoint);\n        }\n      });\n      this._cornerGuidePoints = cornerGuidePoints; // @ts-ignore\n\n      return (0, _helpers.featureCollection)([(0, _polygonToLine[\"default\"])(boundingBox)].concat(_toConsumableArray(this._cornerGuidePoints)));\n    }\n  }]);\n\n  return ScaleMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.ScaleMode = ScaleMode;\n\nfunction getScaleFactor(centroid, startDragPoint, currentPoint) {\n  var startDistance = (0, _distance[\"default\"])(centroid, startDragPoint);\n  var endDistance = (0, _distance[\"default\"])(centroid, currentPoint);\n  return endDistance / startDistance;\n}","map":{"version":3,"sources":["../../src/lib/scale-mode.ts"],"names":["ScaleMode","GeoJsonEditMode","features","geometry","Array","type","selectedHandleIndex","selectedHandle","guidePointCount","oppositeIndex","p","updatedData","ImmutableFeatureCollection","props","selectedIndexes","i","selectedIndex","movedFeature","editedData","Boolean","oppositeHandle","origin","scaleFactor","getScaleFactor","scaledFeatures","editType","editContext","featureIndexes","cursorGeometry","centroid","bearing","positiveBearing","event","selectedEditHandle","scaleAction","selectedGeometry","boundingBox","cornerGuidePoints","coordIndex","cornerPoint","guideType","editHandleType","positionIndexes","startDistance","endDistance"],"mappings":"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","sourcesContent":["/* eslint-disable prettier/prettier */\nimport bbox from '@turf/bbox';\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport { point, featureCollection } from '@turf/helpers';\nimport polygonToLine from '@turf/polygon-to-line';\nimport { coordEach } from '@turf/meta';\nimport turfDistance from '@turf/distance';\nimport turfTransformScale from '@turf/transform-scale';\nimport { getCoord, getGeom } from '@turf/invariant';\nimport { FeatureCollection, Position } from '../geojson-types';\nimport {\n  ModeProps,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  EditHandleFeature,\n  GuideFeatureCollection,\n} from '../types';\nimport { getPickedEditHandle } from '../utils';\nimport { GeoJsonEditMode } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ScaleMode extends GeoJsonEditMode {\n  _geometryBeingScaled: FeatureCollection | null | undefined;\n  _selectedEditHandle: EditHandleFeature | null | undefined;\n  _cornerGuidePoints: Array<EditHandleFeature>;\n  _cursor: string | null | undefined;\n  _isScaling = false;\n\n  _isSinglePointGeometrySelected = (geometry: FeatureCollection | null | undefined): boolean => {\n    const { features } = geometry || {};\n    if (Array.isArray(features) && features.length === 1) {\n      // @ts-ignore\n      const { type } = getGeom(features[0]);\n      return type === 'Point';\n    }\n    return false;\n  };\n\n  _getOppositeScaleHandle = (selectedHandle: EditHandleFeature) => {\n    const selectedHandleIndex =\n      selectedHandle &&\n      selectedHandle.properties &&\n      Array.isArray(selectedHandle.properties.positionIndexes) &&\n      selectedHandle.properties.positionIndexes[0];\n\n    if (typeof selectedHandleIndex !== 'number') {\n      return null;\n    }\n    const guidePointCount = this._cornerGuidePoints.length;\n    const oppositeIndex = (selectedHandleIndex + guidePointCount / 2) % guidePointCount;\n    return this._cornerGuidePoints.find((p) => {\n      if (!Array.isArray(p.properties.positionIndexes)) {\n        return false;\n      }\n      return p.properties.positionIndexes[0] === oppositeIndex;\n    });\n  };\n\n  _getUpdatedData = (props: ModeProps<FeatureCollection>, editedData: FeatureCollection) => {\n    let updatedData = new ImmutableFeatureCollection(props.data);\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = editedData.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n    return updatedData.getObject();\n  };\n\n  isEditHandleSelected = (): boolean => Boolean(this._selectedEditHandle);\n\n  getScaleAction = (\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ) => {\n    if (!this._selectedEditHandle) {\n      return null;\n    }\n\n    const oppositeHandle = this._getOppositeScaleHandle(this._selectedEditHandle);\n    const origin = getCoord(oppositeHandle);\n    // @ts-ignore\n    const scaleFactor = getScaleFactor(origin, startDragPoint, currentPoint);\n    // @ts-ignore\n    const scaledFeatures: FeatureCollection = turfTransformScale(\n      // @ts-ignore\n      this._geometryBeingScaled,\n      scaleFactor,\n      { origin }\n    );\n\n    return {\n      updatedData: this._getUpdatedData(props, scaledFeatures),\n      editType,\n      editContext: {\n        featureIndexes: props.selectedIndexes,\n      },\n    };\n  };\n\n  updateCursor = (props: ModeProps<FeatureCollection>) => {\n    if (this._selectedEditHandle) {\n      if (this._cursor) {\n        props.onUpdateCursor(this._cursor);\n      }\n      const cursorGeometry = this.getSelectedFeaturesAsFeatureCollection(props);\n\n      // Get resize cursor direction from the hovered scale editHandle (e.g. nesw or nwse)\n      const centroid = turfCentroid(cursorGeometry);\n      const bearing = turfBearing(centroid, this._selectedEditHandle);\n      const positiveBearing = bearing < 0 ? bearing + 180 : bearing;\n      if (\n        (positiveBearing >= 0 && positiveBearing <= 90) ||\n        (positiveBearing >= 180 && positiveBearing <= 270)\n      ) {\n        this._cursor = 'nesw-resize';\n        props.onUpdateCursor('nesw-resize');\n      } else {\n        this._cursor = 'nwse-resize';\n        props.onUpdateCursor('nwse-resize');\n      }\n    } else {\n      props.onUpdateCursor(null);\n      this._cursor = null;\n    }\n  };\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isScaling) {\n      const selectedEditHandle = getPickedEditHandle(event.picks);\n      this._selectedEditHandle =\n        selectedEditHandle && selectedEditHandle.properties.editHandleType === 'scale'\n          ? selectedEditHandle\n          : null;\n\n      if (selectedEditHandle) {\n        this.updateCursor(props);\n      }\n    }\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      this._isScaling = true;\n      this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection(props);\n    }\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isScaling) {\n      return;\n    }\n\n    props.onUpdateCursor(this._cursor);\n\n    const scaleAction = this.getScaleAction(\n      event.pointerDownMapCoords,\n      event.mapCoords,\n      'scaling',\n      props\n    );\n    if (scaleAction) {\n      props.onEdit(scaleAction);\n    }\n\n    event.cancelPan();\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._isScaling) {\n      // Scale the geometry\n      const scaleAction = this.getScaleAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'scaled',\n        props\n      );\n      if (scaleAction) {\n        props.onEdit(scaleAction);\n      }\n\n      props.onUpdateCursor(null);\n\n      this._geometryBeingScaled = null;\n      this._selectedEditHandle = null;\n      this._cursor = null;\n      this._isScaling = false;\n    }\n  }\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    this._cornerGuidePoints = [];\n    const selectedGeometry = this.getSelectedFeaturesAsFeatureCollection(props);\n\n    // Add buffer to the enveloping box if a single Point feature is selected\n    if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n      return { type: 'FeatureCollection', features: [] };\n    }\n\n    const boundingBox = bboxPolygon(bbox(selectedGeometry));\n    boundingBox.properties.mode = 'scale';\n    const cornerGuidePoints = [];\n\n    coordEach(boundingBox, (coord, coordIndex) => {\n      if (coordIndex < 4) {\n        // Get corner midpoint guides from the enveloping box\n        const cornerPoint = point(coord, {\n          guideType: 'editHandle',\n          editHandleType: 'scale',\n          positionIndexes: [coordIndex],\n        });\n        cornerGuidePoints.push(cornerPoint);\n      }\n    });\n\n    this._cornerGuidePoints = cornerGuidePoints;\n    // @ts-ignore\n    return featureCollection([polygonToLine(boundingBox), ...this._cornerGuidePoints]);\n  }\n}\n\nfunction getScaleFactor(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const startDistance = turfDistance(centroid, startDragPoint);\n  const endDistance = turfDistance(centroid, currentPoint);\n  return endDistance / startDistance;\n}\n"]},"metadata":{},"sourceType":"script"}