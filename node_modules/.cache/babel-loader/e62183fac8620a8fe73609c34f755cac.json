{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { vgField } from '../../channeldef';\nimport { getTimeUnitParts, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash as _hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var TimeUnitNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(TimeUnitNode, _DataFlowNode);\n\n  var _super = _createSuper(TimeUnitNode);\n\n  function TimeUnitNode(parent, formula) {\n    var _this;\n\n    _classCallCheck(this, TimeUnitNode);\n\n    _this = _super.call(this, parent);\n    _this.formula = formula;\n    return _this;\n  }\n\n  _createClass(TimeUnitNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new TimeUnitNode(null, duplicate(this.formula));\n    }\n  }, {\n    key: \"merge\",\n\n    /**\n     * Merge together TimeUnitNodes assigning the children of `other` to `this`\n     * and removing `other`.\n     */\n    value: function merge(other) {\n      this.formula = Object.assign({}, this.formula); // if the same hash happen twice, merge\n\n      for (var key in other.formula) {\n        if (!this.formula[key]) {\n          // copy if it's not a duplicate\n          this.formula[key] = other.formula[key];\n        }\n      }\n\n      var _iterator = _createForOfIteratorHelper(other.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          other.removeChild(child);\n          child.parent = this;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      other.remove();\n    }\n    /**\n     * Remove time units coming from the other node.\n     */\n\n  }, {\n    key: \"removeFormulas\",\n    value: function removeFormulas(fields) {\n      var newFormula = {};\n\n      var _iterator2 = _createForOfIteratorHelper(entries(this.formula)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              key = _step2$value[0],\n              timeUnit = _step2$value[1];\n\n          if (!fields.has(timeUnit.as)) {\n            newFormula[key] = timeUnit;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.formula = newFormula;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(vals(this.formula).map(function (f) {\n        return f.as;\n      }));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(vals(this.formula).map(function (f) {\n        return f.field;\n      }));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"TimeUnit \".concat(_hash(this.formula));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var transforms = [];\n\n      var _iterator3 = _createForOfIteratorHelper(vals(this.formula)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var f = _step3.value;\n          var field = f.field,\n              as = f.as,\n              timeUnit = f.timeUnit;\n\n          var _a = normalizeTimeUnit(timeUnit),\n              unit = _a.unit,\n              utc = _a.utc,\n              params = __rest(_a, [\"unit\", \"utc\"]);\n\n          transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({\n            field: replacePathInField(field),\n            type: 'timeunit'\n          }, unit ? {\n            units: getTimeUnitParts(unit)\n          } : {}), utc ? {\n            timezone: 'utc'\n          } : {}), params), {\n            as: [as, \"\".concat(as, \"_end\")]\n          }));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return transforms;\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var formula = model.reduceFieldDef(function (timeUnitComponent, fieldDef) {\n        var field = fieldDef.field,\n            timeUnit = fieldDef.timeUnit;\n\n        if (timeUnit) {\n          var as = vgField(fieldDef, {\n            forAs: true\n          });\n          timeUnitComponent[_hash({\n            as: as,\n            field: field,\n            timeUnit: timeUnit\n          })] = {\n            as: as,\n            field: field,\n            timeUnit: timeUnit\n          };\n        }\n\n        return timeUnitComponent;\n      }, {});\n\n      if (isEmpty(formula)) {\n        return null;\n      }\n\n      return new TimeUnitNode(parent, formula);\n    }\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t) {\n      var _a = Object.assign({}, t),\n          timeUnit = _a.timeUnit,\n          other = __rest(_a, [\"timeUnit\"]);\n\n      var normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n      var component = Object.assign(Object.assign({}, other), {\n        timeUnit: normalizedTimeUnit\n      });\n      return new TimeUnitNode(parent, _defineProperty({}, _hash(component), component));\n    }\n  }]);\n\n  return TimeUnitNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/timeunit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { vgField } from '../../channeldef';\nimport { getTimeUnitParts, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class TimeUnitNode extends DataFlowNode {\n    constructor(parent, formula) {\n        super(parent);\n        this.formula = formula;\n    }\n    clone() {\n        return new TimeUnitNode(null, duplicate(this.formula));\n    }\n    static makeFromEncoding(parent, model) {\n        const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {\n            const { field, timeUnit } = fieldDef;\n            if (timeUnit) {\n                const as = vgField(fieldDef, { forAs: true });\n                timeUnitComponent[hash({\n                    as,\n                    field,\n                    timeUnit\n                })] = {\n                    as,\n                    field,\n                    timeUnit\n                };\n            }\n            return timeUnitComponent;\n        }, {});\n        if (isEmpty(formula)) {\n            return null;\n        }\n        return new TimeUnitNode(parent, formula);\n    }\n    static makeFromTransform(parent, t) {\n        const _a = Object.assign({}, t), { timeUnit } = _a, other = __rest(_a, [\"timeUnit\"]);\n        const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n        const component = Object.assign(Object.assign({}, other), { timeUnit: normalizedTimeUnit });\n        return new TimeUnitNode(parent, {\n            [hash(component)]: component\n        });\n    }\n    /**\n     * Merge together TimeUnitNodes assigning the children of `other` to `this`\n     * and removing `other`.\n     */\n    merge(other) {\n        this.formula = Object.assign({}, this.formula);\n        // if the same hash happen twice, merge\n        for (const key in other.formula) {\n            if (!this.formula[key]) {\n                // copy if it's not a duplicate\n                this.formula[key] = other.formula[key];\n            }\n        }\n        for (const child of other.children) {\n            other.removeChild(child);\n            child.parent = this;\n        }\n        other.remove();\n    }\n    /**\n     * Remove time units coming from the other node.\n     */\n    removeFormulas(fields) {\n        const newFormula = {};\n        for (const [key, timeUnit] of entries(this.formula)) {\n            if (!fields.has(timeUnit.as)) {\n                newFormula[key] = timeUnit;\n            }\n        }\n        this.formula = newFormula;\n    }\n    producedFields() {\n        return new Set(vals(this.formula).map(f => f.as));\n    }\n    dependentFields() {\n        return new Set(vals(this.formula).map(f => f.field));\n    }\n    hash() {\n        return `TimeUnit ${hash(this.formula)}`;\n    }\n    assemble() {\n        const transforms = [];\n        for (const f of vals(this.formula)) {\n            const { field, as, timeUnit } = f;\n            const _a = normalizeTimeUnit(timeUnit), { unit, utc } = _a, params = __rest(_a, [\"unit\", \"utc\"]);\n            transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({ field: replacePathInField(field), type: 'timeunit' }, (unit ? { units: getTimeUnitParts(unit) } : {})), (utc ? { timezone: 'utc' } : {})), params), { as: [as, `${as}_end`] }));\n        }\n        return transforms;\n    }\n}\n//# sourceMappingURL=timeunit.js.map"]},"metadata":{},"sourceType":"module"}