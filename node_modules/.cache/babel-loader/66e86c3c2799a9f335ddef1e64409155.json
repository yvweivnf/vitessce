{"ast":null,"code":"import { Tile3DSubtreeLoader } from '../../../tile-3d-subtree-loader';\nimport { load } from '@loaders.gl/core';\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\nexport async function parseImplicitTiles(subtree, options, parentData = {\n  mortonIndex: 0,\n  x: 0,\n  y: 0,\n  z: 0\n}, childIndex = 0, level = 0, globalData = {\n  level: 0,\n  mortonIndex: 0,\n  x: 0,\n  y: 0,\n  z: 0\n}) {\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n  const tile = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: ''\n  };\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n  const childX = childIndex & 0b01;\n  const childY = childIndex >> 1 & 0b01;\n  const childZ = childIndex >> 2 & 0b01;\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = \"\".concat(basePath, \"/\").concat(subtreesUriTemplate);\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n    subtree = childSubtree;\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {\n    mortonIndex: childTileMortonIndex,\n    x: childTileX,\n    y: childTileY,\n    z: childTileZ\n  };\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles(subtree, options, pData, index, childTileLevel, globalData);\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const childCoordinates = {\n        childTileX,\n        childTileY,\n        childTileZ\n      };\n      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData, index) {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\nfunction formatTileData(tile, level, childCoordinates, options) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(\"\".concat(basePath, \"/\"), '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  const boundingVolume = calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates);\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {\n      uri\n    },\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    boundingVolume\n  };\n}\n\nfunction calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {\n  if (rootBoundingVolume.region) {\n    const {\n      childTileX,\n      childTileY,\n      childTileZ\n    } = childCoordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n    const sizeX = (east - west) / boundingVolumesCount;\n    const sizeY = (north - south) / boundingVolumesCount;\n    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n    const [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * childTileZ, minimumHeight + sizeZ * (childTileZ + 1)];\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\n\nfunction concatBits(first, second) {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\nexport function replaceContentUrlTemplate(templateUrl, level, x, y, z) {\n  const mapUrl = generateMapUrl({\n    level,\n    x,\n    y,\n    z\n  });\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, matched => mapUrl[matched]);\n}\n\nfunction generateMapUrl(items) {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[\"{\".concat(key, \"}\")] = items[key];\n  }\n\n  return mapUrl;\n}\n\nfunction getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;\n  return bitValue === 1;\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/parse-3d-implicit-tiles.ts"],"names":["QUADTREE_DEVISION_COUNT","OCTREE_DEVISION_COUNT","SUBDIVISION_COUNT_MAP","QUADTREE","OCTREE","parentData","mortonIndex","x","y","z","childIndex","level","globalData","basePath","tile","children","lodMetricValue","contentUrl","childrenPerTile","childX","childY","childZ","levelOffset","childTileMortonIndex","concatBits","tileAvailabilityIndex","childTileX","childTileY","childTileZ","isChildSubtreeAvailable","getAvailabilityResult","subtree","lev","subtreePath","childSubtreeUrl","replaceContentUrlTemplate","childSubtree","load","isTileAvailable","isContentAvailable","childTileLevel","pData","index","currentTile","parseImplicitTiles","globalLevel","childCoordinates","formattedTile","formatTileData","Boolean","availabilityData","getBooleanValueFromBitstream","rootBoundingVolume","uri","rootLodMetricValue","boundingVolume","calculateBoundingVolumeForChildTile","content","id","refine","getRefine","type","getTileType","boundingVolumesCount","sizeX","east","sizeY","north","sizeZ","maximumHeight","west","south","minimumHeight","region","console","parseInt","first","second","mapUrl","generateMapUrl","templateUrl","matched","items","byteIndex","Math","availabilityIndex","bitIndex","bitValue","availabilityBuffer"],"mappings":"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","sourcesContent":["import type {Availability, BoundingVolume, Subtree} from '../../../types';\nimport {Tile3DSubtreeLoader} from '../../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\n\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\n\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\n\n/**\n * Recursively parse implicit tiles tree\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * TODO Check out do we able to use Tile3D class as return type here.\n * @param subtree\n * @param lodMetricValue\n * @param options\n * @param parentData\n * @param childIndex\n * @param level\n * @param globalData\n */\n// eslint-disable-next-line max-params\n// eslint-disable-next-line max-statements\nexport async function parseImplicitTiles(\n  subtree: Subtree,\n  options: any,\n  parentData: {mortonIndex: number; x: number; y: number; z: number} = {\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  childIndex: number = 0,\n  level: number = 0,\n  globalData: {level: number; mortonIndex: number; x: number; y: number; z: number} = {\n    level: 0,\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  }\n) {\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n\n  const tile = {children: [], lodMetricValue: 0, contentUrl: ''};\n\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n\n  const childX = childIndex & 0b01;\n  const childY = (childIndex >> 1) & 0b01;\n  const childZ = (childIndex >> 2) & 0b01;\n\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n\n  // Local tile coordinates\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n\n  // TODO Remove after real implicit tileset will be tested.\n  // Degug data\n  // tile.level = level + globalData.level;\n  // tile.x = concatBits(globalData.x, childTileX);\n  // tile.y = concatBits(globalData.y, childTileY);\n  // tile.z = concatBits(globalData.z, childTileZ);\n  // tile.mortonIndex = childTileMortonIndex;\n  // End of debug data\n\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(\n      subtree.childSubtreeAvailability,\n      childTileMortonIndex\n    );\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = `${basePath}/${subtreesUriTemplate}`;\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n\n    subtree = childSubtree;\n\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(\n    subtree.contentAvailability,\n    tileAvailabilityIndex\n  );\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ};\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles(\n      subtree,\n      options,\n      pData,\n      index,\n      childTileLevel,\n      globalData\n    );\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const childCoordinates = {childTileX, childTileY, childTileZ};\n      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n      // @ts-ignore\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData: Availability, index: number): boolean {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\n/**\n * Do formatting of implicit tile data.\n * TODO Check out do we able to use Tile3D class as type here.\n * @param tile\n * @param lodMetricValue\n * @param options\n * @returns\n */\nfunction formatTileData(\n  tile,\n  level: number,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number},\n  options: any\n) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  const boundingVolume = calculateBoundingVolumeForChildTile(\n    level,\n    rootBoundingVolume,\n    childCoordinates\n  );\n\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {uri},\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    boundingVolume\n    // Temp debug values. Remove when real implicit tileset will be tested.\n    // x: tile.x,\n    // y: tile.y,\n    // z: tile.z,\n    // level: tile.level\n  };\n}\n\n/**\n * Calculate child bounding volume.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subdivision-rules\n * @param level\n * @param rootBoundingVolume\n * @param childCoordinates\n */\nfunction calculateBoundingVolumeForChildTile(\n  level: number,\n  rootBoundingVolume: BoundingVolume,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number}\n): BoundingVolume | null {\n  if (rootBoundingVolume.region) {\n    const {childTileX, childTileY, childTileZ} = childCoordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n\n    const sizeX = (east - west) / boundingVolumesCount;\n    const sizeY = (north - south) / boundingVolumesCount;\n    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n\n    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n    const [childMinimumHeight, childMaximumHeight] = [\n      minimumHeight + sizeZ * childTileZ,\n      minimumHeight + sizeZ * (childTileZ + 1)\n    ];\n\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n\n  // eslint-disable-next-line no-console\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\n\n/**\n * Do binary concatenation\n * @param first\n * @param second\n */\nfunction concatBits(first: number, second: number): number {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\n/**\n * Replace implicit tile content url with real coordinates.\n * @param templateUrl\n * @param level\n * @param x\n * @param y\n * @param z\n */\nexport function replaceContentUrlTemplate(\n  templateUrl: string,\n  level: number,\n  x: number,\n  y: number,\n  z: number\n): string {\n  const mapUrl = generateMapUrl({level, x, y, z});\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);\n}\n\n/**\n * Get Map object for content url generation\n * @param items\n */\nfunction generateMapUrl(items: {[key: string]: number}): {[key: string]: string} {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[`{${key}}`] = items[key];\n  }\n  return mapUrl;\n}\n\n/**\n * Get boolean value from bistream by index\n * A boolean value is encoded as a single bit, either 0 (false) or 1 (true).\n * Multiple boolean values are packed tightly in the same buffer.\n * These buffers of tightly-packed bits are sometimes referred to as bitstreams.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/implicit-revisions/specification/Metadata#booleans\n * @param availabilitiIndex\n */\nfunction getBooleanValueFromBitstream(\n  availabilityIndex: number,\n  availabilityBuffer: Uint8Array\n): boolean {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = (availabilityBuffer[byteIndex] >> bitIndex) & 1;\n\n  return bitValue === 1;\n}\n"]},"metadata":{},"sourceType":"module"}