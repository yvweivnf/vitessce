{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nexport function isLogicalOr(op) {\n  return !!op.or;\n}\nexport function isLogicalAnd(op) {\n  return !!op.and;\n}\nexport function isLogicalNot(op) {\n  return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    var _iterator = _createForOfIteratorHelper(op.and),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var subop = _step.value;\n        forEachLeaf(subop, fn);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (isLogicalOr(op)) {\n    var _iterator2 = _createForOfIteratorHelper(op.or),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _subop = _step2.value;\n        forEachLeaf(_subop, fn);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } else {\n    fn(op);\n  }\n}\nexport function normalizeLogicalComposition(op, normalizer) {\n  if (isLogicalNot(op)) {\n    return {\n      not: normalizeLogicalComposition(op.not, normalizer)\n    };\n  } else if (isLogicalAnd(op)) {\n    return {\n      and: op.and.map(function (o) {\n        return normalizeLogicalComposition(o, normalizer);\n      })\n    };\n  } else if (isLogicalOr(op)) {\n    return {\n      or: op.or.map(function (o) {\n        return normalizeLogicalComposition(o, normalizer);\n      })\n    };\n  } else {\n    return normalizer(op);\n  }\n}","map":{"version":3,"sources":["../../src/logical.ts"],"names":[],"mappings":";AAcA,OAAM,SAAU,WAAV,CAAsB,EAAtB,EAAiD;AACrD,SAAO,CAAC,CAAC,EAAE,CAAC,EAAZ;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAAkD;AACtD,SAAO,CAAC,CAAC,EAAE,CAAC,GAAZ;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAAkD;AACtD,SAAO,CAAC,CAAC,EAAE,CAAC,GAAZ;AACD;AAED,OAAM,SAAU,WAAV,CAAyB,EAAzB,EAAoD,EAApD,EAAuE;AAC3E,MAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AACpB,IAAA,WAAW,CAAC,EAAE,CAAC,GAAJ,EAAS,EAAT,CAAX;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AAAA,+CACP,EAAE,CAAC,GADI;AAAA;;AAAA;AAC3B,0DAA4B;AAAA,YAAjB,KAAiB;AAC1B,QAAA,WAAW,CAAC,KAAD,EAAQ,EAAR,CAAX;AACD;AAH0B;AAAA;AAAA;AAAA;AAAA;AAI5B,GAJM,MAIA,IAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AAAA,gDACN,EAAE,CAAC,EADG;AAAA;;AAAA;AAC1B,6DAA2B;AAAA,YAAhB,MAAgB;AACzB,QAAA,WAAW,CAAC,MAAD,EAAQ,EAAR,CAAX;AACD;AAHyB;AAAA;AAAA;AAAA;AAAA;AAI3B,GAJM,MAIA;AACL,IAAA,EAAE,CAAC,EAAD,CAAF;AACD;AACF;AAED,OAAM,SAAU,2BAAV,CACJ,EADI,EAEJ,UAFI,EAEmB;AAEvB,MAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AACpB,WAAO;AAAC,MAAA,GAAG,EAAE,2BAA2B,CAAC,EAAE,CAAC,GAAJ,EAAS,UAAT;AAAjC,KAAP;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AAC3B,WAAO;AAAC,MAAA,GAAG,EAAE,EAAE,CAAC,GAAH,CAAO,GAAP,CAAW,UAAA,CAAC;AAAA,eAAI,2BAA2B,CAAC,CAAD,EAAI,UAAJ,CAA/B;AAAA,OAAZ;AAAN,KAAP;AACD,GAFM,MAEA,IAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AAC1B,WAAO;AAAC,MAAA,EAAE,EAAE,EAAE,CAAC,EAAH,CAAM,GAAN,CAAU,UAAA,CAAC;AAAA,eAAI,2BAA2B,CAAC,CAAD,EAAI,UAAJ,CAA/B;AAAA,OAAX;AAAL,KAAP;AACD,GAFM,MAEA;AACL,WAAO,UAAU,CAAC,EAAD,CAAjB;AACD;AACF","sourceRoot":"","sourcesContent":["export function isLogicalOr(op) {\n    return !!op.or;\n}\nexport function isLogicalAnd(op) {\n    return !!op.and;\n}\nexport function isLogicalNot(op) {\n    return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n    if (isLogicalNot(op)) {\n        forEachLeaf(op.not, fn);\n    }\n    else if (isLogicalAnd(op)) {\n        for (const subop of op.and) {\n            forEachLeaf(subop, fn);\n        }\n    }\n    else if (isLogicalOr(op)) {\n        for (const subop of op.or) {\n            forEachLeaf(subop, fn);\n        }\n    }\n    else {\n        fn(op);\n    }\n}\nexport function normalizeLogicalComposition(op, normalizer) {\n    if (isLogicalNot(op)) {\n        return { not: normalizeLogicalComposition(op.not, normalizer) };\n    }\n    else if (isLogicalAnd(op)) {\n        return { and: op.and.map(o => normalizeLogicalComposition(o, normalizer)) };\n    }\n    else if (isLogicalOr(op)) {\n        return { or: op.or.map(o => normalizeLogicalComposition(o, normalizer)) };\n    }\n    else {\n        return normalizer(op);\n    }\n}\n//# sourceMappingURL=logical.js.map"]},"metadata":{},"sourceType":"module"}