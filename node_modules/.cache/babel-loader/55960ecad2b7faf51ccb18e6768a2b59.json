{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n  if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n    // we always use header for orient signal since we can't dynamically make header becomes footer\n    return 'header';\n  }\n\n  return 'footer';\n}\nexport function parseFacetHeaders(model) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model, channel) {\n  var _a;\n\n  const {\n    facet,\n    config,\n    child,\n    component\n  } = model;\n\n  if (model.channelHasField(channel)) {\n    const fieldDef = facet[channel];\n    const titleConfig = getHeaderProperty('title', null, config, channel);\n    let title = fieldDefTitle(fieldDef, config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title; // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n\n      title += ` / ${child.component.layoutHeaders[channel].title}`;\n      child.component.layoutHeaders[channel].title = null;\n    }\n\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n    const labels = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n    component.layoutHeaders[channel] = {\n      title: fieldDef.header !== null ? title : null,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\n\nfunction makeHeaderComponent(model, channel, labels) {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model, channel) {\n  var _a;\n\n  const {\n    child\n  } = model;\n\n  if (child.component.axes[channel]) {\n    const {\n      layoutHeaders,\n      resolve\n    } = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n      const layoutHeader = layoutHeaders[headerChannel];\n\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)]; // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {\n          header: true\n        });\n\n        if (mainAxis) {\n          // LayoutHeader no longer keep track of property precedence, thus let's combine.\n          layoutHeader[headerType][0].axes.push(mainAxis);\n        }\n\n        axisComponent.mainExtracted = true;\n      }\n    } else {// Otherwise do nothing for independent axes\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/header/parse.ts"],"names":[],"mappings":"AACA,SAAQ,OAAR,QAAsB,WAAtB;AACA,SAAsB,cAAtB,QAA2C,eAA3C;AACA,SAAQ,KAAK,IAAI,aAAjB,QAAqC,kBAArC;AACA,SAAQ,QAAR,EAAkB,eAAlB,QAAwC,YAAxC;AACA,SAAQ,WAAR,QAA0B,mBAA1B;AACA,SAAQ,YAAR,QAA2B,kBAA3B;AAEA,SAAQ,iBAAR,QAAgC,YAAhC;AACA,SAAQ,iBAAR,QAAgC,UAAhC;AAGA,OAAM,SAAU,aAAV,CAAwB,MAAxB,EAAsD;AAC1D,MAAI,MAAM,KAAK,KAAX,IAAoB,MAAM,KAAK,MAA/B,IAAyC,WAAW,CAAC,MAAD,CAAxD,EAAkE;AAChE;AACA,WAAO,QAAP;AACD;;AACD,SAAO,QAAP;AACD;AAED,OAAM,SAAU,iBAAV,CAA4B,KAA5B,EAA6C;AACjD,OAAK,MAAM,OAAX,IAAsB,cAAtB,EAAsC;AACpC,IAAA,gBAAgB,CAAC,KAAD,EAAQ,OAAR,CAAhB;AACD;;AAED,EAAA,cAAc,CAAC,KAAD,EAAQ,GAAR,CAAd;AACA,EAAA,cAAc,CAAC,KAAD,EAAQ,GAAR,CAAd;AACD;;AAED,SAAS,gBAAT,CAA0B,KAA1B,EAA6C,OAA7C,EAAkE;;;AAChE,QAAM;AAAC,IAAA,KAAD;AAAQ,IAAA,MAAR;AAAgB,IAAA,KAAhB;AAAuB,IAAA;AAAvB,MAAoC,KAA1C;;AACA,MAAI,KAAK,CAAC,eAAN,CAAsB,OAAtB,CAAJ,EAAoC;AAClC,UAAM,QAAQ,GAAG,KAAK,CAAC,OAAD,CAAtB;AACA,UAAM,WAAW,GAAG,iBAAiB,CAAC,OAAD,EAAU,IAAV,EAAgB,MAAhB,EAAwB,OAAxB,CAArC;AACA,QAAI,KAAK,GAAG,aAAa,CAAC,QAAD,EAAW,MAAX,EAAmB;AAC1C,MAAA,cAAc,EAAE,IAD0B;AAE1C,MAAA,cAAc,EAAE,WAAW,KAAK,SAAhB,IAA6B,CAAC,CAAC;AAFL,KAAnB,CAAzB;;AAKA,QAAI,KAAK,CAAC,SAAN,CAAgB,aAAhB,CAA8B,OAA9B,EAAuC,KAA3C,EAAkD;AAChD;AACA,MAAA,KAAK,GAAG,OAAO,CAAC,KAAD,CAAP,GAAiB,KAAK,CAAC,IAAN,CAAW,IAAX,CAAjB,GAAoC,KAA5C,CAFgD,CAIhD;;AACA,MAAA,KAAK,IAAI,MAAM,KAAK,CAAC,SAAN,CAAgB,aAAhB,CAA8B,OAA9B,EAAuC,KAAK,EAA3D;AACA,MAAA,KAAK,CAAC,SAAN,CAAgB,aAAhB,CAA8B,OAA9B,EAAuC,KAAvC,GAA+C,IAA/C;AACD;;AAED,UAAM,WAAW,GAAG,iBAAiB,CAAC,aAAD,EAAgB,QAAQ,CAAC,MAAzB,EAAiC,MAAjC,EAAyC,OAAzC,CAArC;AAEA,UAAM,MAAM,GACV,QAAQ,CAAC,MAAT,KAAoB,IAApB,GAA2B,eAAe,CAAC,CAAA,EAAA,GAAA,QAAQ,CAAC,MAAT,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,MAAlB,EAA0B,MAAM,CAAC,MAAP,CAAc,MAAxC,EAAgD,IAAhD,CAA1C,GAAkG,KADpG;AAEA,UAAM,UAAU,GAAG,QAAQ,CAAC,CAAC,QAAD,EAAW,OAAX,CAAD,EAAsB,WAAtB,CAAR,GAA6C,QAA7C,GAAwD,QAA3E;AAEA,IAAA,SAAS,CAAC,aAAV,CAAwB,OAAxB,IAAmC;AACjC,MAAA,KAAK,EAAE,QAAQ,CAAC,MAAT,KAAoB,IAApB,GAA2B,KAA3B,GAAmC,IADT;AAEjC,MAAA,aAAa,EAAE,QAFkB;AAGjC,OAAC,UAAD,GAAc,OAAO,KAAK,OAAZ,GAAsB,EAAtB,GAA2B,CAAC,mBAAmB,CAAC,KAAD,EAAQ,OAAR,EAAiB,MAAjB,CAApB;AAHR,KAAnC;AAKD;AACF;;AAED,SAAS,mBAAT,CAA6B,KAA7B,EAAgD,OAAhD,EAAwE,MAAxE,EAAuF;AACrF,QAAM,QAAQ,GAAG,OAAO,KAAK,KAAZ,GAAoB,QAApB,GAA+B,OAAhD;AAEA,SAAO;AACL,IAAA,MADK;AAEL,IAAA,UAAU,EAAE,KAAK,CAAC,KAAN,CAAY,SAAZ,CAAsB,UAAtB,CAAiC,GAAjC,CAAqC,QAArC,IAAiD,KAAK,CAAC,KAAN,CAAY,gBAAZ,CAA6B,QAA7B,CAAjD,GAA0F,SAFjG;AAGL,IAAA,IAAI,EAAE;AAHD,GAAP;AAKD;;AAED,SAAS,cAAT,CAAwB,KAAxB,EAA2C,OAA3C,EAA6D;;;AAC3D,QAAM;AAAC,IAAA;AAAD,MAAU,KAAhB;;AACA,MAAI,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,OAArB,CAAJ,EAAmC;AACjC,UAAM;AAAC,MAAA,aAAD;AAAgB,MAAA;AAAhB,QAA2B,KAAK,CAAC,SAAvC;AACA,IAAA,OAAO,CAAC,IAAR,CAAa,OAAb,IAAwB,iBAAiB,CAAC,OAAD,EAAU,OAAV,CAAzC;;AAEA,QAAI,OAAO,CAAC,IAAR,CAAa,OAAb,MAA0B,QAA9B,EAAwC;AACtC;AACA,YAAM,aAAa,GAAG,OAAO,KAAK,GAAZ,GAAkB,QAAlB,GAA6B,KAAnD;AAEA,YAAM,YAAY,GAAG,aAAa,CAAC,aAAD,CAAlC;;AACA,WAAK,MAAM,aAAX,IAA4B,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,OAArB,CAA5B,EAA2D;AACzD,cAAM,UAAU,GAAG,aAAa,CAAC,aAAa,CAAC,GAAd,CAAkB,QAAlB,CAAD,CAAhC;AACA,SAAA,EAAA,GAAA,YAAY,CAAC,UAAD,CAAZ,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,EAAvB,GAAA,YAAY,CAAC,UAAD,CAAZ,GAA6B,CAAC,mBAAmB,CAAC,KAAD,EAAQ,aAAR,EAAuB,KAAvB,CAApB,CAA7B,CAFyD,CAIzD;;AACA,cAAM,QAAQ,GAAG,YAAY,CAAC,aAAD,EAAgB,MAAhB,EAAwB,KAAK,CAAC,MAA9B,EAAsC;AAAC,UAAA,MAAM,EAAE;AAAT,SAAtC,CAA7B;;AACA,YAAI,QAAJ,EAAc;AACZ;AACA,UAAA,YAAY,CAAC,UAAD,CAAZ,CAAyB,CAAzB,EAA4B,IAA5B,CAAiC,IAAjC,CAAsC,QAAtC;AACD;;AACD,QAAA,aAAa,CAAC,aAAd,GAA8B,IAA9B;AACD;AACF,KAjBD,MAiBO,CACL;AACD;AACF;AACF","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n    if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n        // we always use header for orient signal since we can't dynamically make header becomes footer\n        return 'header';\n    }\n    return 'footer';\n}\nexport function parseFacetHeaders(model) {\n    for (const channel of FACET_CHANNELS) {\n        parseFacetHeader(model, channel);\n    }\n    mergeChildAxis(model, 'x');\n    mergeChildAxis(model, 'y');\n}\nfunction parseFacetHeader(model, channel) {\n    var _a;\n    const { facet, config, child, component } = model;\n    if (model.channelHasField(channel)) {\n        const fieldDef = facet[channel];\n        const titleConfig = getHeaderProperty('title', null, config, channel);\n        let title = fieldDefTitle(fieldDef, config, {\n            allowDisabling: true,\n            includeDefault: titleConfig === undefined || !!titleConfig\n        });\n        if (child.component.layoutHeaders[channel].title) {\n            // TODO: better handle multiline titles\n            title = isArray(title) ? title.join(', ') : title;\n            // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n            title += ` / ${child.component.layoutHeaders[channel].title}`;\n            child.component.layoutHeaders[channel].title = null;\n        }\n        const labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n        const labels = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;\n        const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n        component.layoutHeaders[channel] = {\n            title: fieldDef.header !== null ? title : null,\n            facetFieldDef: fieldDef,\n            [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n        };\n    }\n}\nfunction makeHeaderComponent(model, channel, labels) {\n    const sizeType = channel === 'row' ? 'height' : 'width';\n    return {\n        labels,\n        sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n        axes: []\n    };\n}\nfunction mergeChildAxis(model, channel) {\n    var _a;\n    const { child } = model;\n    if (child.component.axes[channel]) {\n        const { layoutHeaders, resolve } = model.component;\n        resolve.axis[channel] = parseGuideResolve(resolve, channel);\n        if (resolve.axis[channel] === 'shared') {\n            // For shared axis, move the axes to facet's header or footer\n            const headerChannel = channel === 'x' ? 'column' : 'row';\n            const layoutHeader = layoutHeaders[headerChannel];\n            for (const axisComponent of child.component.axes[channel]) {\n                const headerType = getHeaderType(axisComponent.get('orient'));\n                (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : (layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)]);\n                // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n                const mainAxis = assembleAxis(axisComponent, 'main', model.config, { header: true });\n                if (mainAxis) {\n                    // LayoutHeader no longer keep track of property precedence, thus let's combine.\n                    layoutHeader[headerType][0].axes.push(mainAxis);\n                }\n                axisComponent.mainExtracted = true;\n            }\n        }\n        else {\n            // Otherwise do nothing for independent axes\n        }\n    }\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}