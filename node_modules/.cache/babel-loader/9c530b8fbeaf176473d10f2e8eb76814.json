{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\n\nfunction dropLineAndPoint(markDef) {\n  var _point = markDef.point,\n      _line = markDef.line,\n      mark = __rest(markDef, [\"point\", \"line\"]);\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config) {\n  for (var _i = 0, _arr = ['line', 'area', 'rule', 'trail']; _i < _arr.length; _i++) {\n    var mark = _arr[_i];\n\n    if (config[mark]) {\n      config = Object.assign(Object.assign({}, config), _defineProperty({}, mark, omit(config[mark], ['point', 'line'])));\n    }\n  }\n\n  return config;\n}\n\nfunction getPointOverlay(markDef) {\n  var markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var encoding = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(markDef) {\n  var markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nexport var PathOverlayNormalizer = /*#__PURE__*/function () {\n  function PathOverlayNormalizer() {\n    _classCallCheck(this, PathOverlayNormalizer);\n\n    this.name = 'path-overlay';\n  }\n\n  _createClass(PathOverlayNormalizer, [{\n    key: \"hasMatchingType\",\n    value: function hasMatchingType(spec, config) {\n      if (isUnitSpec(spec)) {\n        var mark = spec.mark,\n            encoding = spec.encoding;\n        var markDef = isMarkDef(mark) ? mark : {\n          type: mark\n        };\n\n        switch (markDef.type) {\n          case 'line':\n          case 'rule':\n          case 'trail':\n            return !!getPointOverlay(markDef, config[markDef.type], encoding);\n\n          case 'area':\n            return (// false / null are also included as we want to remove the properties\n              !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n            );\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"run\",\n    value: function run(spec, normParams, normalize) {\n      var config = normParams.config;\n\n      var params = spec.params,\n          projection = spec.projection,\n          mark = spec.mark,\n          e = spec.encoding,\n          outerSpec = __rest(spec, [\"params\", \"projection\", \"mark\", \"encoding\"]); // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n\n\n      var encoding = normalizeEncoding(e, config);\n      var markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n      var pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n      var lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n      var layer = [Object.assign(Object.assign({}, params ? {\n        params: params\n      } : {}), {\n        mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined ? {\n          opacity: 0.7\n        } : {}), markDef)),\n        // drop shape from encoding as this might be used to trigger point overlay\n        encoding: omit(encoding, ['shape'])\n      })]; // FIXME: determine rules for applying selections.\n      // Need to copy stack config to overlayed layer\n\n      var stackProps = stack(markDef, encoding);\n      var overlayEncoding = encoding;\n\n      if (stackProps) {\n        var stackFieldChannel = stackProps.fieldChannel,\n            offset = stackProps.offset;\n        overlayEncoding = Object.assign(Object.assign({}, encoding), _defineProperty({}, stackFieldChannel, Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset ? {\n          stack: offset\n        } : {})));\n      }\n\n      if (lineOverlay) {\n        layer.push(Object.assign(Object.assign({}, projection ? {\n          projection: projection\n        } : {}), {\n          mark: Object.assign(Object.assign({\n            type: 'line'\n          }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay),\n          encoding: overlayEncoding\n        }));\n      }\n\n      if (pointOverlay) {\n        layer.push(Object.assign(Object.assign({}, projection ? {\n          projection: projection\n        } : {}), {\n          mark: Object.assign(Object.assign({\n            type: 'point',\n            opacity: 1,\n            filled: true\n          }, pick(markDef, ['clip', 'tooltip'])), pointOverlay),\n          encoding: overlayEncoding\n        }));\n      }\n\n      return normalize(Object.assign(Object.assign({}, outerSpec), {\n        layer: layer\n      }), Object.assign(Object.assign({}, normParams), {\n        config: dropLineAndPointFromConfig(config)\n      }));\n    }\n  }]);\n\n  return PathOverlayNormalizer;\n}();","map":{"version":3,"sources":["../../../src/normalize/pathoverlay.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\nfunction dropLineAndPoint(markDef) {\n    const { point: _point, line: _line } = markDef, mark = __rest(markDef, [\"point\", \"line\"]);\n    return keys(mark).length > 1 ? mark : mark.type;\n}\nfunction dropLineAndPointFromConfig(config) {\n    for (const mark of ['line', 'area', 'rule', 'trail']) {\n        if (config[mark]) {\n            config = Object.assign(Object.assign({}, config), { \n                // TODO: remove as any\n                [mark]: omit(config[mark], ['point', 'line']) });\n        }\n    }\n    return config;\n}\nfunction getPointOverlay(markDef, markConfig = {}, encoding) {\n    if (markDef.point === 'transparent') {\n        return { opacity: 0 };\n    }\n    else if (markDef.point) {\n        // truthy : true or object\n        return isObject(markDef.point) ? markDef.point : {};\n    }\n    else if (markDef.point !== undefined) {\n        // false or null\n        return null;\n    }\n    else {\n        // undefined (not disabled)\n        if (markConfig.point || encoding.shape) {\n            // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n            return isObject(markConfig.point) ? markConfig.point : {};\n        }\n        // markDef.point is defined as falsy\n        return undefined;\n    }\n}\nfunction getLineOverlay(markDef, markConfig = {}) {\n    if (markDef.line) {\n        // true or object\n        return markDef.line === true ? {} : markDef.line;\n    }\n    else if (markDef.line !== undefined) {\n        // false or null\n        return null;\n    }\n    else {\n        // undefined (not disabled)\n        if (markConfig.line) {\n            // enable line overlay if config[mark].line is truthy\n            return markConfig.line === true ? {} : markConfig.line;\n        }\n        // markDef.point is defined as falsy\n        return undefined;\n    }\n}\nexport class PathOverlayNormalizer {\n    constructor() {\n        this.name = 'path-overlay';\n    }\n    hasMatchingType(spec, config) {\n        if (isUnitSpec(spec)) {\n            const { mark, encoding } = spec;\n            const markDef = isMarkDef(mark) ? mark : { type: mark };\n            switch (markDef.type) {\n                case 'line':\n                case 'rule':\n                case 'trail':\n                    return !!getPointOverlay(markDef, config[markDef.type], encoding);\n                case 'area':\n                    return (\n                    // false / null are also included as we want to remove the properties\n                    !!getPointOverlay(markDef, config[markDef.type], encoding) ||\n                        !!getLineOverlay(markDef, config[markDef.type]));\n            }\n        }\n        return false;\n    }\n    run(spec, normParams, normalize) {\n        const { config } = normParams;\n        const { params, projection, mark, encoding: e } = spec, outerSpec = __rest(spec, [\"params\", \"projection\", \"mark\", \"encoding\"]);\n        // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n        const encoding = normalizeEncoding(e, config);\n        const markDef = isMarkDef(mark) ? mark : { type: mark };\n        const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n        const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n        const layer = [\n            Object.assign(Object.assign({}, (params ? { params } : {})), { mark: dropLineAndPoint(Object.assign(Object.assign({}, (markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined\n                    ? { opacity: 0.7 }\n                    : {})), markDef)), \n                // drop shape from encoding as this might be used to trigger point overlay\n                encoding: omit(encoding, ['shape']) })\n        ];\n        // FIXME: determine rules for applying selections.\n        // Need to copy stack config to overlayed layer\n        const stackProps = stack(markDef, encoding);\n        let overlayEncoding = encoding;\n        if (stackProps) {\n            const { fieldChannel: stackFieldChannel, offset } = stackProps;\n            overlayEncoding = Object.assign(Object.assign({}, encoding), { [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), (offset ? { stack: offset } : {})) });\n        }\n        if (lineOverlay) {\n            layer.push(Object.assign(Object.assign({}, (projection ? { projection } : {})), { mark: Object.assign(Object.assign({ type: 'line' }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay), encoding: overlayEncoding }));\n        }\n        if (pointOverlay) {\n            layer.push(Object.assign(Object.assign({}, (projection ? { projection } : {})), { mark: Object.assign(Object.assign({ type: 'point', opacity: 1, filled: true }, pick(markDef, ['clip', 'tooltip'])), pointOverlay), encoding: overlayEncoding }));\n        }\n        return normalize(Object.assign(Object.assign({}, outerSpec), { layer }), Object.assign(Object.assign({}, normParams), { config: dropLineAndPointFromConfig(config) }));\n    }\n}\n//# sourceMappingURL=pathoverlay.js.map"]},"metadata":{},"sourceType":"module"}