{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData as _parseData } from './data/parse';\nimport { assembleLayoutSignals as _assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\n\nexport var UnitModel = /*#__PURE__*/function (_ModelWithField) {\n  _inherits(UnitModel, _ModelWithField);\n\n  var _super = _createSuper(UnitModel);\n\n  function UnitModel(spec, parent, parentGivenName) {\n    var _this;\n\n    var parentGivenSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var config = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, UnitModel);\n\n    var _a;\n\n    _this = _super.call(this, spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n    _this.specifiedScales = {};\n    _this.specifiedAxes = {};\n    _this.specifiedLegends = {};\n    _this.specifiedProjection = {};\n    _this.selection = [];\n    _this.children = [];\n    var markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : {\n      type: spec.mark\n    };\n    var mark = markDef.type; // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n\n    var encoding = _this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);\n    _this.markDef = initMarkdef(markDef, encoding, config);\n    _this.size = initLayoutSize({\n      encoding: encoding,\n      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n        width: spec.width\n      } : {}), spec.height ? {\n        height: spec.height\n      } : {}) : parentGivenSize\n    }); // calculate stack properties\n\n    _this.stack = stack(mark, encoding);\n    _this.specifiedScales = _this.initScales(mark, encoding);\n    _this.specifiedAxes = _this.initAxes(encoding);\n    _this.specifiedLegends = _this.initLegends(encoding);\n    _this.specifiedProjection = spec.projection; // Selections will be initialized upon parse.\n\n    _this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter(function (p) {\n      return isSelectionParameter(p);\n    });\n    return _this;\n  }\n\n  _createClass(UnitModel, [{\n    key: \"scaleDomain\",\n\n    /**\n     * Return specified Vega-Lite scale domain for a particular channel\n     * @param channel\n     */\n    value: function scaleDomain(channel) {\n      var scale = this.specifiedScales[channel];\n      return scale ? scale.domain : undefined;\n    }\n  }, {\n    key: \"axis\",\n    value: function axis(channel) {\n      return this.specifiedAxes[channel];\n    }\n  }, {\n    key: \"legend\",\n    value: function legend(channel) {\n      return this.specifiedLegends[channel];\n    }\n  }, {\n    key: \"initScales\",\n    value: function initScales(mark, encoding) {\n      var _this2 = this;\n\n      return SCALE_CHANNELS.reduce(function (scales, channel) {\n        var _a;\n\n        var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n\n        if (fieldOrDatumDef) {\n          scales[channel] = _this2.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});\n        }\n\n        return scales;\n      }, {});\n    }\n  }, {\n    key: \"initScale\",\n    value: function initScale(scale) {\n      var domain = scale.domain,\n          range = scale.range; // TODO: we could simplify this function if we had a recursive replace function\n\n      var scaleInternal = replaceExprRef(scale);\n\n      if (isArray(domain)) {\n        scaleInternal.domain = domain.map(signalRefOrValue);\n      }\n\n      if (isArray(range)) {\n        scaleInternal.range = range.map(signalRefOrValue);\n      }\n\n      return scaleInternal;\n    }\n  }, {\n    key: \"initAxes\",\n    value: function initAxes(encoding) {\n      var _this3 = this;\n\n      return POSITION_SCALE_CHANNELS.reduce(function (_axis, channel) {\n        // Position Axis\n        // TODO: handle ConditionFieldDef\n        var channelDef = encoding[channel];\n\n        if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {\n          var axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n          _axis[channel] = axisSpec ? _this3.initAxis(Object.assign({}, axisSpec)) // convert truthy value to object\n          : axisSpec;\n        }\n\n        return _axis;\n      }, {});\n    }\n  }, {\n    key: \"initAxis\",\n    value: function initAxis(axis) {\n      var props = keys(axis);\n      var axisInternal = {};\n\n      var _iterator = _createForOfIteratorHelper(props),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n          var val = axis[prop];\n          axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return axisInternal;\n    }\n  }, {\n    key: \"initLegends\",\n    value: function initLegends(encoding) {\n      return NONPOSITION_SCALE_CHANNELS.reduce(function (_legend, channel) {\n        var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n\n        if (fieldOrDatumDef && supportLegend(channel)) {\n          var legend = fieldOrDatumDef.legend;\n          _legend[channel] = legend ? replaceExprRef(legend) // convert truthy value to object\n          : legend;\n        }\n\n        return _legend;\n      }, {});\n    }\n  }, {\n    key: \"parseData\",\n    value: function parseData() {\n      this.component.data = _parseData(this);\n    }\n  }, {\n    key: \"parseLayoutSize\",\n    value: function parseLayoutSize() {\n      parseUnitLayoutSize(this);\n    }\n  }, {\n    key: \"parseSelections\",\n    value: function parseSelections() {\n      this.component.selection = parseUnitSelection(this, this.selection);\n    }\n  }, {\n    key: \"parseMarkGroup\",\n    value: function parseMarkGroup() {\n      this.component.mark = parseMarkGroups(this);\n    }\n  }, {\n    key: \"parseAxesAndHeaders\",\n    value: function parseAxesAndHeaders() {\n      this.component.axes = parseUnitAxes(this);\n    }\n  }, {\n    key: \"assembleSelectionTopLevelSignals\",\n    value: function assembleSelectionTopLevelSignals(signals) {\n      return assembleTopLevelSignals(this, signals);\n    }\n  }, {\n    key: \"assembleSignals\",\n    value: function assembleSignals() {\n      return [].concat(_toConsumableArray(assembleAxisSignals(this)), _toConsumableArray(assembleUnitSelectionSignals(this, [])));\n    }\n  }, {\n    key: \"assembleSelectionData\",\n    value: function assembleSelectionData(data) {\n      return assembleUnitSelectionData(this, data);\n    }\n  }, {\n    key: \"assembleLayout\",\n    value: function assembleLayout() {\n      return null;\n    }\n  }, {\n    key: \"assembleLayoutSignals\",\n    value: function assembleLayoutSignals() {\n      return _assembleLayoutSignals(this);\n    }\n  }, {\n    key: \"assembleMarks\",\n    value: function assembleMarks() {\n      var _a;\n\n      var marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : []; // If this unit is part of a layer, selections should augment\n      // all in concert rather than each unit individually. This\n      // ensures correct interleaving of clipping and brushed marks.\n\n      if (!this.parent || !isLayerModel(this.parent)) {\n        marks = assembleUnitSelectionMarks(this, marks);\n      }\n\n      return marks.map(this.correctDataNames);\n    }\n  }, {\n    key: \"assembleGroupStyle\",\n    value: function assembleGroupStyle() {\n      var _ref = this.view || {},\n          style = _ref.style;\n\n      if (style !== undefined) {\n        return style;\n      }\n\n      if (this.encoding.x || this.encoding.y) {\n        return 'cell';\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"getMapping\",\n    value: function getMapping() {\n      return this.encoding;\n    }\n  }, {\n    key: \"channelHasField\",\n    value: function channelHasField(channel) {\n      return vlEncoding.channelHasField(this.encoding, channel);\n    }\n  }, {\n    key: \"fieldDef\",\n    value: function fieldDef(channel) {\n      var channelDef = this.encoding[channel];\n      return getFieldDef(channelDef);\n    }\n  }, {\n    key: \"typedFieldDef\",\n    value: function typedFieldDef(channel) {\n      var fieldDef = this.fieldDef(channel);\n\n      if (isTypedFieldDef(fieldDef)) {\n        return fieldDef;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasProjection\",\n    get: function get() {\n      var encoding = this.encoding;\n      var isGeoShapeMark = this.mark === GEOSHAPE;\n      var hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(function (channel) {\n        return isFieldOrDatumDef(encoding[channel]);\n      });\n      return isGeoShapeMark || hasGeoPosition;\n    }\n  }, {\n    key: \"mark\",\n    get: function get() {\n      return this.markDef.type;\n    }\n  }]);\n\n  return UnitModel;\n}(ModelWithField);","map":{"version":3,"sources":["../../../src/compile/unit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n    constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {\n        var _a;\n        super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n        this.specifiedScales = {};\n        this.specifiedAxes = {};\n        this.specifiedLegends = {};\n        this.specifiedProjection = {};\n        this.selection = [];\n        this.children = [];\n        const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : { type: spec.mark };\n        const mark = markDef.type;\n        // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n        if (markDef.filled === undefined) {\n            markDef.filled = defaultFilled(markDef, config, {\n                graticule: spec.data && isGraticuleGenerator(spec.data)\n            });\n        }\n        const encoding = (this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config));\n        this.markDef = initMarkdef(markDef, encoding, config);\n        this.size = initLayoutSize({\n            encoding: encoding,\n            size: isFrameMixins(spec)\n                ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), (spec.width ? { width: spec.width } : {})), (spec.height ? { height: spec.height } : {})) : parentGivenSize\n        });\n        // calculate stack properties\n        this.stack = stack(mark, encoding);\n        this.specifiedScales = this.initScales(mark, encoding);\n        this.specifiedAxes = this.initAxes(encoding);\n        this.specifiedLegends = this.initLegends(encoding);\n        this.specifiedProjection = spec.projection;\n        // Selections will be initialized upon parse.\n        this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter(p => isSelectionParameter(p));\n    }\n    get hasProjection() {\n        const { encoding } = this;\n        const isGeoShapeMark = this.mark === GEOSHAPE;\n        const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n        return isGeoShapeMark || hasGeoPosition;\n    }\n    /**\n     * Return specified Vega-Lite scale domain for a particular channel\n     * @param channel\n     */\n    scaleDomain(channel) {\n        const scale = this.specifiedScales[channel];\n        return scale ? scale.domain : undefined;\n    }\n    axis(channel) {\n        return this.specifiedAxes[channel];\n    }\n    legend(channel) {\n        return this.specifiedLegends[channel];\n    }\n    initScales(mark, encoding) {\n        return SCALE_CHANNELS.reduce((scales, channel) => {\n            var _a;\n            const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n            if (fieldOrDatumDef) {\n                scales[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});\n            }\n            return scales;\n        }, {});\n    }\n    initScale(scale) {\n        const { domain, range } = scale;\n        // TODO: we could simplify this function if we had a recursive replace function\n        const scaleInternal = replaceExprRef(scale);\n        if (isArray(domain)) {\n            scaleInternal.domain = domain.map(signalRefOrValue);\n        }\n        if (isArray(range)) {\n            scaleInternal.range = range.map(signalRefOrValue);\n        }\n        return scaleInternal;\n    }\n    initAxes(encoding) {\n        return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n            // Position Axis\n            // TODO: handle ConditionFieldDef\n            const channelDef = encoding[channel];\n            if (isFieldOrDatumDef(channelDef) ||\n                (channel === X && isFieldOrDatumDef(encoding.x2)) ||\n                (channel === Y && isFieldOrDatumDef(encoding.y2))) {\n                const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n                _axis[channel] = axisSpec\n                    ? this.initAxis(Object.assign({}, axisSpec)) // convert truthy value to object\n                    : axisSpec;\n            }\n            return _axis;\n        }, {});\n    }\n    initAxis(axis) {\n        const props = keys(axis);\n        const axisInternal = {};\n        for (const prop of props) {\n            const val = axis[prop];\n            axisInternal[prop] = isConditionalAxisValue(val)\n                ? signalOrValueRefWithCondition(val)\n                : signalRefOrValue(val);\n        }\n        return axisInternal;\n    }\n    initLegends(encoding) {\n        return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n            const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n            if (fieldOrDatumDef && supportLegend(channel)) {\n                const legend = fieldOrDatumDef.legend;\n                _legend[channel] = legend\n                    ? replaceExprRef(legend) // convert truthy value to object\n                    : legend;\n            }\n            return _legend;\n        }, {});\n    }\n    parseData() {\n        this.component.data = parseData(this);\n    }\n    parseLayoutSize() {\n        parseUnitLayoutSize(this);\n    }\n    parseSelections() {\n        this.component.selection = parseUnitSelection(this, this.selection);\n    }\n    parseMarkGroup() {\n        this.component.mark = parseMarkGroups(this);\n    }\n    parseAxesAndHeaders() {\n        this.component.axes = parseUnitAxes(this);\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return assembleTopLevelSignals(this, signals);\n    }\n    assembleSignals() {\n        return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n    }\n    assembleSelectionData(data) {\n        return assembleUnitSelectionData(this, data);\n    }\n    assembleLayout() {\n        return null;\n    }\n    assembleLayoutSignals() {\n        return assembleLayoutSignals(this);\n    }\n    assembleMarks() {\n        var _a;\n        let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : [];\n        // If this unit is part of a layer, selections should augment\n        // all in concert rather than each unit individually. This\n        // ensures correct interleaving of clipping and brushed marks.\n        if (!this.parent || !isLayerModel(this.parent)) {\n            marks = assembleUnitSelectionMarks(this, marks);\n        }\n        return marks.map(this.correctDataNames);\n    }\n    assembleGroupStyle() {\n        const { style } = this.view || {};\n        if (style !== undefined) {\n            return style;\n        }\n        if (this.encoding.x || this.encoding.y) {\n            return 'cell';\n        }\n        else {\n            return undefined;\n        }\n    }\n    getMapping() {\n        return this.encoding;\n    }\n    get mark() {\n        return this.markDef.type;\n    }\n    channelHasField(channel) {\n        return vlEncoding.channelHasField(this.encoding, channel);\n    }\n    fieldDef(channel) {\n        const channelDef = this.encoding[channel];\n        return getFieldDef(channelDef);\n    }\n    typedFieldDef(channel) {\n        const fieldDef = this.fieldDef(channel);\n        if (isTypedFieldDef(fieldDef)) {\n            return fieldDef;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=unit.js.map"]},"metadata":{},"sourceType":"module"}