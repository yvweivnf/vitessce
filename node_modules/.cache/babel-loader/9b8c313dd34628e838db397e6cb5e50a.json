{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toDeckColor = toDeckColor;\nexports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;\nexports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;\nexports.distance2d = distance2d;\nexports.mix = mix;\nexports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;\nexports.nearestPointOnLine = nearestPointOnLine;\nexports.getPickedEditHandle = getPickedEditHandle;\nexports.getPickedSnapSourceEditHandle = getPickedSnapSourceEditHandle;\nexports.getNonGuidePicks = getNonGuidePicks;\nexports.getPickedExistingEditHandle = getPickedExistingEditHandle;\nexports.getPickedIntermediateEditHandle = getPickedIntermediateEditHandle;\nexports.getPickedEditHandles = getPickedEditHandles;\nexports.getEditHandlesForGeometry = getEditHandlesForGeometry;\n\nvar _destination = _interopRequireDefault(require(\"@turf/destination\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _pointToLineDistance = _interopRequireDefault(require(\"@turf/point-to-line-distance\"));\n\nvar _meta = require(\"@turf/meta\");\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _invariant = require(\"@turf/invariant\");\n\nvar _viewportMercatorProject = _interopRequireDefault(require(\"viewport-mercator-project\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction toDeckColor(color) {\n  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];\n\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n} //\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\n\n\nfunction recursivelyTraverseNestedArrays(array, prefix, fn) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n\n  return false;\n}\n\nfunction generatePointsParallelToLinePoints(p1, p2, mapCoords) {\n  var lineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  var pt = (0, _helpers.point)(mapCoords);\n  var ddistance = (0, _pointToLineDistance[\"default\"])(pt, lineString);\n  var lineBearing = (0, _bearing[\"default\"])(p1, p2); // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n\n  var isPointToLeftOfLine = (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string\n\n  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n\n  var p3 = (0, _destination[\"default\"])(p2, ddistance, orthogonalBearing);\n  var p4 = (0, _destination[\"default\"])(p1, ddistance, orthogonalBearing);\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nfunction distance2d(x1, y1, x2, y2) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction mix(a, b, ratio) {\n  return b * ratio + a * (1 - ratio);\n}\n\nfunction nearestPointOnProjectedLine(line, inPoint, viewport) {\n  var wmViewport = new _viewportMercatorProject[\"default\"](viewport); // Project the line to viewport, then find the nearest point\n\n  var coordinates = line.geometry.coordinates;\n  var projectedCoords = coordinates.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        x = _ref2[0],\n        y = _ref2[1],\n        _ref2$ = _ref2[2],\n        z = _ref2$ === void 0 ? 0 : _ref2$;\n\n    return wmViewport.project([x, y, z]);\n  }); // @ts-ignore\n\n  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),\n      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),\n      x = _wmViewport$project2[0],\n      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n\n  var minDistance = Infinity;\n  var minPointInfo = {};\n  projectedCoords.forEach(function (_ref3, index) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        x2 = _ref4[0],\n        y2 = _ref4[1];\n\n    if (index === 0) {\n      return;\n    }\n\n    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),\n        x1 = _projectedCoords[0],\n        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n\n\n    var A = y1 - y2;\n    var B = x2 - x1;\n    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n\n    var div = A * A + B * B;\n    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index: index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div\n      };\n    }\n  }); // @ts-ignore\n\n  var _minPointInfo = minPointInfo,\n      index = _minPointInfo.index,\n      x0 = _minPointInfo.x0,\n      y0 = _minPointInfo.y0;\n\n  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),\n      x1 = _projectedCoords2[0],\n      y1 = _projectedCoords2[1],\n      _projectedCoords2$ = _projectedCoords2[2],\n      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;\n\n  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),\n      x2 = _projectedCoords$inde[0],\n      y2 = _projectedCoords$inde[1],\n      _projectedCoords$inde2 = _projectedCoords$inde[2],\n      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z\n\n\n  var lineLength = distance2d(x1, y1, x2, y2);\n  var startToPointLength = distance2d(x1, y1, x0, y0);\n  var ratio = startToPointLength / lineLength;\n  var z0 = mix(z1, z2, ratio);\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0])\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1\n    }\n  };\n}\n\nfunction nearestPointOnLine(lines, inPoint, viewport) {\n  var _lines$geometry, _lines$geometry2;\n\n  var mercator;\n\n  if (viewport) {\n    mercator = new _viewportMercatorProject[\"default\"](viewport);\n  }\n\n  var closestPoint = (0, _helpers.point)([Infinity, Infinity], {\n    dist: Infinity\n  });\n\n  if (!((_lines$geometry = lines.geometry) === null || _lines$geometry === void 0 ? void 0 : _lines$geometry.coordinates.length) || ((_lines$geometry2 = lines.geometry) === null || _lines$geometry2 === void 0 ? void 0 : _lines$geometry2.coordinates.length) < 2) {\n    return closestPoint;\n  } // @ts-ignore\n\n\n  (0, _meta.flattenEach)(lines, function (line) {\n    var coords = (0, _invariant.getCoords)(line); // @ts-ignore\n\n    var pointCoords = (0, _invariant.getCoords)(inPoint);\n    var minDist;\n    var to;\n    var from;\n    var x;\n    var y;\n    var segmentIdx;\n    var dist;\n\n    if (coords.length > 1 && pointCoords.length) {\n      var lineCoordinates;\n      var pointCoordinate; // If viewport is given, then translate these coordinates to pixels to increase precision\n\n      if (mercator) {\n        lineCoordinates = coords.map(function (lineCoordinate) {\n          return mercator.project(lineCoordinate);\n        });\n        pointCoordinate = mercator.project(pointCoords);\n      } else {\n        lineCoordinates = coords;\n        pointCoordinate = pointCoords;\n      }\n\n      for (var n = 1; n < lineCoordinates.length; n++) {\n        if (lineCoordinates[n][0] !== lineCoordinates[n - 1][0]) {\n          var slope = (lineCoordinates[n][1] - lineCoordinates[n - 1][1]) / (lineCoordinates[n][0] - lineCoordinates[n - 1][0]);\n          var inverseSlope = lineCoordinates[n][1] - slope * lineCoordinates[n][0];\n          dist = Math.abs(slope * pointCoordinate[0] + inverseSlope - pointCoordinate[1]) / Math.sqrt(slope * slope + 1);\n        } else dist = Math.abs(pointCoordinate[0] - lineCoordinates[n][0]); // length^2 of line segment\n\n\n        var rl2 = Math.pow(lineCoordinates[n][1] - lineCoordinates[n - 1][1], 2) + Math.pow(lineCoordinates[n][0] - lineCoordinates[n - 1][0], 2); // distance^2 of pt to end line segment\n\n        var ln2 = Math.pow(lineCoordinates[n][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n][0] - pointCoordinate[0], 2); // distance^2 of pt to begin line segment\n\n        var lnm12 = Math.pow(lineCoordinates[n - 1][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n - 1][0] - pointCoordinate[0], 2); // minimum distance^2 of pt to infinite line\n\n        var dist2 = Math.pow(dist, 2); // calculated length^2 of line segment\n\n        var calcrl2 = ln2 - dist2 + lnm12 - dist2; // redefine minimum distance to line segment (not infinite line) if necessary\n\n        if (calcrl2 > rl2) {\n          dist = Math.sqrt(Math.min(ln2, lnm12));\n        }\n\n        if (minDist === null || minDist === undefined || minDist > dist) {\n          // eslint-disable-next-line max-depth\n          if (calcrl2 > rl2) {\n            // eslint-disable-next-line max-depth\n            if (lnm12 < ln2) {\n              to = 0; // nearer to previous point\n\n              from = 1;\n            } else {\n              from = 0; // nearer to current point\n\n              to = 1;\n            }\n          } else {\n            // perpendicular from point intersects line segment\n            to = Math.sqrt(lnm12 - dist2) / Math.sqrt(rl2);\n            from = Math.sqrt(ln2 - dist2) / Math.sqrt(rl2);\n          }\n\n          minDist = dist;\n          segmentIdx = n;\n        }\n      }\n\n      var dx = lineCoordinates[segmentIdx - 1][0] - lineCoordinates[segmentIdx][0];\n      var dy = lineCoordinates[segmentIdx - 1][1] - lineCoordinates[segmentIdx][1];\n      x = lineCoordinates[segmentIdx - 1][0] - dx * to;\n      y = lineCoordinates[segmentIdx - 1][1] - dy * to;\n    } // index needs to be -1 because we have to account for the shift from initial backscan\n\n\n    var snapPoint = {\n      x: x,\n      y: y,\n      idx: segmentIdx - 1,\n      to: to,\n      from: from\n    };\n\n    if (mercator) {\n      var pixelToLatLong = mercator.unproject([snapPoint.x, snapPoint.y]);\n      snapPoint = {\n        x: pixelToLatLong[0],\n        y: pixelToLatLong[1],\n        idx: segmentIdx - 1,\n        to: to,\n        from: from\n      };\n    }\n\n    closestPoint = (0, _helpers.point)([snapPoint.x, snapPoint.y], {\n      dist: Math.abs(snapPoint.from - snapPoint.to),\n      index: snapPoint.idx\n    });\n  });\n  return closestPoint;\n}\n\nfunction getPickedEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.length ? handles[0] : null;\n}\n\nfunction getPickedSnapSourceEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (handle) {\n    return handle.properties.editHandleType === 'snap-source';\n  });\n}\n\nfunction getNonGuidePicks(picks) {\n  return picks && picks.filter(function (pick) {\n    return !pick.isGuide;\n  });\n}\n\nfunction getPickedExistingEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (_ref5) {\n    var properties = _ref5.properties;\n    return properties.featureIndex >= 0 && properties.editHandleType === 'existing';\n  });\n}\n\nfunction getPickedIntermediateEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (_ref6) {\n    var properties = _ref6.properties;\n    return properties.featureIndex >= 0 && properties.editHandleType === 'intermediate';\n  });\n}\n\nfunction getPickedEditHandles(picks) {\n  var handles = picks && picks.filter(function (pick) {\n    return pick.isGuide && pick.object.properties.guideType === 'editHandle';\n  }).map(function (pick) {\n    return pick.object;\n  }) || [];\n  return handles;\n}\n\nfunction getEditHandlesForGeometry(geometry, featureIndex) {\n  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';\n  var handles = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [{\n        type: 'Feature',\n        properties: {\n          guideType: 'editHandle',\n          editHandleType: editHandleType,\n          positionIndexes: [],\n          featureIndex: featureIndex\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: geometry.coordinates\n        }\n      }];\n      break;\n\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));\n      break;\n\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (var a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));\n\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (var _a = 0; _a < geometry.coordinates.length; _a++) {\n        for (var b = 0; b < geometry.coordinates[_a].length; b++) {\n          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons\n\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n\n    default:\n      // @ts-ignore\n      throw Error(\"Unhandled geometry type: \".concat(geometry.type));\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {\n  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';\n  var editHandles = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var position = coordinates[i];\n    editHandles.push({\n      type: 'Feature',\n      properties: {\n        guideType: 'editHandle',\n        positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [i]),\n        featureIndex: featureIndex,\n        editHandleType: editHandleType\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: position\n      }\n    });\n  }\n\n  return editHandles;\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":["defaultColor","Array","color","array","i","recursivelyTraverseNestedArrays","fn","lineString","type","coordinates","pt","ddistance","lineBearing","isPointToLeftOfLine","mapCoords","p1","p2","orthogonalBearing","p3","p4","dx","x1","dy","y1","Math","b","a","wmViewport","WebMercatorViewport","line","projectedCoords","x","y","z","inPoint","minDistance","minPointInfo","x2","y2","index","A","B","C","div","distance","x0","y0","z1","z2","lineLength","distance2d","startToPointLength","ratio","z0","mix","geometry","properties","dist","mercator","closestPoint","Infinity","lines","coords","pointCoords","lineCoordinates","pointCoordinate","n","slope","inverseSlope","rl2","ln2","lnm12","dist2","calcrl2","minDist","to","from","segmentIdx","snapPoint","idx","pixelToLatLong","handles","getPickedEditHandles","handle","picks","pick","editHandleType","guideType","positionIndexes","featureIndex","getEditHandlesForCoordinates","Error","editHandles","position"],"mappings":"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","sourcesContent":["import destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { flattenEach } from '@turf/meta';\nimport { point, MultiLineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport WebMercatorViewport from 'viewport-mercator-project';\nimport { Viewport, Pick, EditHandleFeature, EditHandleType } from './types';\nimport {\n  Geometry,\n  Position,\n  Point,\n  LineString,\n  FeatureOf,\n  FeatureWithProps,\n} from './geojson-types';\n\nexport type NearestPointType = FeatureWithProps<Point, { dist: number; index: number }>;\n\nexport function toDeckColor(\n  color?: [number, number, number, number] | number,\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  mapCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2],\n  };\n  const pt = point(mapCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates] as Position[];\n}\n\nexport function distance2d(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function mix(a: number, b: number, ratio: number): number {\n  return b * ratio + a * (1 - ratio);\n}\n\nexport function nearestPointOnProjectedLine(\n  line: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport: Viewport\n): NearestPointType {\n  const wmViewport = new WebMercatorViewport(viewport);\n  // Project the line to viewport, then find the nearest point\n  const coordinates: Array<Array<number>> = line.geometry.coordinates as any;\n  const projectedCoords = coordinates.map(([x, y, z = 0]) => wmViewport.project([x, y, z]));\n  // @ts-ignore\n  const [x, y] = wmViewport.project(inPoint.geometry.coordinates);\n  // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n  let minDistance = Infinity;\n  let minPointInfo = {};\n\n  projectedCoords.forEach(([x2, y2], index) => {\n    if (index === 0) {\n      return;\n    }\n\n    const [x1, y1] = projectedCoords[index - 1];\n\n    // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n    const A = y1 - y2;\n    const B = x2 - x1;\n    const C = x1 * y2 - x2 * y1;\n\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    const div = A * A + B * B;\n    const distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);\n\n    // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div,\n      };\n    }\n  });\n  // @ts-ignore\n  const { index, x0, y0 } = minPointInfo;\n  const [x1, y1, z1 = 0] = projectedCoords[index - 1];\n  const [x2, y2, z2 = 0] = projectedCoords[index];\n\n  // calculate what ratio of the line we are on to find the proper z\n  const lineLength = distance2d(x1, y1, x2, y2);\n  const startToPointLength = distance2d(x1, y1, x0, y0);\n  const ratio = startToPointLength / lineLength;\n  const z0 = mix(z1, z2, ratio);\n\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0]),\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1,\n    },\n  };\n}\n\nexport function nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport?: Viewport\n): NearestPointType {\n  let mercator;\n\n  if (viewport) {\n    mercator = new WebMercatorViewport(viewport);\n  }\n  let closestPoint: any = point([Infinity, Infinity], {\n    dist: Infinity,\n  });\n\n  if (!lines.geometry?.coordinates.length || lines.geometry?.coordinates.length < 2) {\n    return closestPoint;\n  }\n\n  // @ts-ignore\n  flattenEach(lines, (line: any) => {\n    const coords: any = getCoords(line);\n    // @ts-ignore\n    const pointCoords: any = getCoords(inPoint);\n\n    let minDist;\n    let to;\n    let from;\n    let x;\n    let y;\n    let segmentIdx;\n    let dist;\n\n    if (coords.length > 1 && pointCoords.length) {\n      let lineCoordinates;\n      let pointCoordinate;\n\n      // If viewport is given, then translate these coordinates to pixels to increase precision\n      if (mercator) {\n        lineCoordinates = coords.map((lineCoordinate) => mercator.project(lineCoordinate));\n        pointCoordinate = mercator.project(pointCoords);\n      } else {\n        lineCoordinates = coords;\n        pointCoordinate = pointCoords;\n      }\n\n      for (let n = 1; n < lineCoordinates.length; n++) {\n        if (lineCoordinates[n][0] !== lineCoordinates[n - 1][0]) {\n          const slope =\n            (lineCoordinates[n][1] - lineCoordinates[n - 1][1]) /\n            (lineCoordinates[n][0] - lineCoordinates[n - 1][0]);\n          const inverseSlope = lineCoordinates[n][1] - slope * lineCoordinates[n][0];\n\n          dist =\n            Math.abs(slope * pointCoordinate[0] + inverseSlope - pointCoordinate[1]) /\n            Math.sqrt(slope * slope + 1);\n        } else dist = Math.abs(pointCoordinate[0] - lineCoordinates[n][0]);\n\n        // length^2 of line segment\n        const rl2 =\n          Math.pow(lineCoordinates[n][1] - lineCoordinates[n - 1][1], 2) +\n          Math.pow(lineCoordinates[n][0] - lineCoordinates[n - 1][0], 2);\n\n        // distance^2 of pt to end line segment\n        const ln2 =\n          Math.pow(lineCoordinates[n][1] - pointCoordinate[1], 2) +\n          Math.pow(lineCoordinates[n][0] - pointCoordinate[0], 2);\n\n        // distance^2 of pt to begin line segment\n        const lnm12 =\n          Math.pow(lineCoordinates[n - 1][1] - pointCoordinate[1], 2) +\n          Math.pow(lineCoordinates[n - 1][0] - pointCoordinate[0], 2);\n\n        // minimum distance^2 of pt to infinite line\n        const dist2 = Math.pow(dist, 2);\n\n        // calculated length^2 of line segment\n        const calcrl2 = ln2 - dist2 + lnm12 - dist2;\n\n        // redefine minimum distance to line segment (not infinite line) if necessary\n        if (calcrl2 > rl2) {\n          dist = Math.sqrt(Math.min(ln2, lnm12));\n        }\n\n        if (minDist === null || minDist === undefined || minDist > dist) {\n          // eslint-disable-next-line max-depth\n          if (calcrl2 > rl2) {\n            // eslint-disable-next-line max-depth\n            if (lnm12 < ln2) {\n              to = 0; // nearer to previous point\n              from = 1;\n            } else {\n              from = 0; // nearer to current point\n              to = 1;\n            }\n          } else {\n            // perpendicular from point intersects line segment\n            to = Math.sqrt(lnm12 - dist2) / Math.sqrt(rl2);\n            from = Math.sqrt(ln2 - dist2) / Math.sqrt(rl2);\n          }\n          minDist = dist;\n          segmentIdx = n;\n        }\n      }\n\n      const dx = lineCoordinates[segmentIdx - 1][0] - lineCoordinates[segmentIdx][0];\n      const dy = lineCoordinates[segmentIdx - 1][1] - lineCoordinates[segmentIdx][1];\n\n      x = lineCoordinates[segmentIdx - 1][0] - dx * to;\n      y = lineCoordinates[segmentIdx - 1][1] - dy * to;\n    }\n\n    // index needs to be -1 because we have to account for the shift from initial backscan\n    let snapPoint = { x, y, idx: segmentIdx - 1, to, from };\n\n    if (mercator) {\n      const pixelToLatLong = mercator.unproject([snapPoint.x, snapPoint.y]);\n      snapPoint = {\n        x: pixelToLatLong[0],\n        y: pixelToLatLong[1],\n        idx: segmentIdx - 1,\n        to,\n        from,\n      };\n    }\n\n    closestPoint = point([snapPoint.x, snapPoint.y], {\n      dist: Math.abs(snapPoint.from - snapPoint.to),\n      index: snapPoint.idx,\n    });\n  });\n\n  return closestPoint;\n}\n\nexport function getPickedEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.length ? handles[0] : null;\n}\n\nexport function getPickedSnapSourceEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.find((handle) => handle.properties.editHandleType === 'snap-source');\n}\n\nexport function getNonGuidePicks(picks: Pick[]): Pick[] {\n  return picks && picks.filter((pick) => !pick.isGuide);\n}\n\nexport function getPickedExistingEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.find(\n    ({ properties }) => properties.featureIndex >= 0 && properties.editHandleType === 'existing'\n  );\n}\n\nexport function getPickedIntermediateEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.find(\n    ({ properties }) => properties.featureIndex >= 0 && properties.editHandleType === 'intermediate'\n  );\n}\n\nexport function getPickedEditHandles(picks: Pick[] | null | undefined): EditHandleFeature[] {\n  const handles =\n    (picks &&\n      picks\n        .filter((pick) => pick.isGuide && pick.object.properties.guideType === 'editHandle')\n        .map((pick) => pick.object)) ||\n    [];\n\n  return handles;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandleFeature[] {\n  let handles: EditHandleFeature[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          type: 'Feature',\n          properties: {\n            guideType: 'editHandle',\n            editHandleType,\n            positionIndexes: [],\n            featureIndex,\n          },\n          geometry: {\n            type: 'Point',\n            coordinates: geometry.coordinates,\n          },\n        },\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n    default:\n      // @ts-ignore\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandleFeature[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      type: 'Feature',\n      properties: {\n        guideType: 'editHandle',\n        positionIndexes: [...positionIndexPrefix, i],\n        featureIndex,\n        editHandleType,\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: position,\n      },\n    });\n  }\n  return editHandles;\n}\n"]},"metadata":{},"sourceType":"script"}