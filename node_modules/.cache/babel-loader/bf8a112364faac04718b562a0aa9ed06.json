{"ast":null,"code":"import clamp from 'lodash/clamp';\nimport range from 'lodash/range';\nimport { AXIS_LABEL_TEXT_SIZE, AXIS_FONT_FAMILY, AXIS_PADDING, AXIS_MIN_SIZE, AXIS_MAX_SIZE } from '../../layers/heatmap-constants';\nexport function getGeneByCellTile(view, {\n  tileSize,\n  tileI,\n  tileJ,\n  numCells,\n  numGenes,\n  cellOrdering,\n  expressionRowLookUp\n}) {\n  const tileData = new Uint8Array(tileSize * tileSize);\n  let offset;\n  let value;\n  let cellI;\n  let geneI;\n  let sortedCellI;\n  const tileSizeRange = range(tileSize);\n  tileSizeRange.forEach(j => {\n    // Need to iterate over cells in the outer loop.\n    cellI = tileJ * tileSize + j;\n\n    if (cellI < numCells) {\n      sortedCellI = expressionRowLookUp.get(cellOrdering[cellI]);\n\n      if (sortedCellI >= -1) {\n        tileSizeRange.forEach(i => {\n          geneI = tileI * tileSize + i;\n          value = view[sortedCellI * numGenes + geneI];\n          offset = (tileSize - i - 1) * tileSize + j;\n          tileData[offset] = value;\n        });\n      }\n    }\n  });\n  return tileData;\n}\nexport function getCellByGeneTile(view, {\n  tileSize,\n  tileI,\n  tileJ,\n  numCells,\n  numGenes,\n  cellOrdering,\n  expressionRowLookUp\n}) {\n  const tileData = new Uint8Array(tileSize * tileSize);\n  let offset;\n  let value;\n  let cellI;\n  let geneI;\n  let sortedCellI;\n  const tileSizeRange = range(tileSize);\n  tileSizeRange.forEach(i => {\n    // Need to iterate over cells in the outer loop.\n    cellI = tileI * tileSize + i;\n\n    if (cellI < numCells) {\n      sortedCellI = expressionRowLookUp.get(cellOrdering[cellI]);\n\n      if (sortedCellI >= -1) {\n        tileSizeRange.forEach(j => {\n          geneI = tileJ * tileSize + j;\n\n          if (geneI < numGenes) {\n            value = view[sortedCellI * numGenes + geneI];\n          } else {\n            value = 0;\n          }\n\n          offset = (tileSize - i - 1) * tileSize + j;\n          tileData[offset] = value;\n        });\n      }\n    }\n  });\n  return tileData;\n}\n/**\n * Called before a layer is drawn to determine whether it should be rendered.\n * Reference: https://deck.gl/docs/api-reference/core/deck#layerfilter\n * @param {object} params A viewport, layer pair.\n * @param {object} params.layer The layer to check.\n * @param {object} params.viewport The viewport to check.\n * @returns {boolean} Should this layer be rendered in this viewport?\n */\n\nexport function layerFilter({\n  layer,\n  viewport\n}) {\n  if (viewport.id === 'axisLeft') {\n    return layer.id.startsWith('axisLeft');\n  }\n\n  if (viewport.id === 'axisTop') {\n    return layer.id.startsWith('axisTop');\n  }\n\n  if (viewport.id === 'cellColorLabel') {\n    return layer.id.startsWith('cellColorLabel');\n  }\n\n  if (viewport.id === 'heatmap') {\n    return layer.id.startsWith('heatmap');\n  }\n\n  if (viewport.id.startsWith('colorsLeft')) {\n    const matches = viewport.id.match(/-(\\d)/);\n    if (matches) return layer.id.startsWith(`colorsLeftLayer-${matches[1]}`);\n  }\n\n  if (viewport.id.startsWith('colorsTop')) {\n    const matches = viewport.id.match(/-(\\d)/);\n    if (matches) return layer.id.startsWith(`colorsTopLayer-${matches[1]}`);\n  }\n\n  return false;\n}\n/**\n * Uses canvas.measureText to compute and return the width of the given text\n * of given font in pixels.\n *\n * @param {String} text The text to be rendered.\n * @param {String} font The css font descriptor that text is to be rendered\n * with (e.g. \"bold 14px verdana\").\n *\n * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n */\n\nfunction getTextWidth(text, font) {\n  // re-use canvas object for better performance\n  const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n}\n/**\n * Get the size of the left and top heatmap axes,\n * taking into account the maximum label string lengths.\n * @param {boolean} transpose Is the heatmap transposed?\n * @param {String} longestGeneLabel longest gene label\n * @param {String} longestCellLabel longest cell label\n * @param {boolean} hideObservationLabels are cell labels hidden?\n * @param {boolean} hideVariableLabels are gene labels hidden?\n * Increases vertical space for heatmap\n * @returns {number[]} [axisOffsetLeft, axisOffsetTop]\n */\n\n\nexport function getAxisSizes(transpose, longestGeneLabel, longestCellLabel, hideObservationLabels, hideVariableLabels) {\n  const font = `${AXIS_LABEL_TEXT_SIZE}pt ${AXIS_FONT_FAMILY}`;\n  const geneLabelMaxWidth = hideVariableLabels ? 0 : getTextWidth(longestGeneLabel, font) + AXIS_PADDING;\n  const cellLabelMaxWidth = hideObservationLabels ? 0 : getTextWidth(longestCellLabel, font) + AXIS_PADDING;\n  const axisOffsetLeft = clamp(transpose ? geneLabelMaxWidth : cellLabelMaxWidth, AXIS_MIN_SIZE, AXIS_MAX_SIZE);\n  const axisOffsetTop = clamp(transpose ? cellLabelMaxWidth : geneLabelMaxWidth, AXIS_MIN_SIZE, AXIS_MAX_SIZE);\n  return [axisOffsetLeft, axisOffsetTop];\n}\n/**\n * Convert a mouse coordinate (x, y) to a heatmap coordinate (col index, row index).\n * @param {number} mouseX The mouse X of interest.\n * @param {number} mouseY The mouse Y of interest.\n * @param {object} param2 An object containing current sizes and scale factors.\n * @returns {number[]} [colI, rowI]\n */\n\nexport function mouseToHeatmapPosition(mouseX, mouseY, {\n  offsetLeft,\n  offsetTop,\n  targetX,\n  targetY,\n  scaleFactor,\n  matrixWidth,\n  matrixHeight,\n  numRows,\n  numCols\n}) {\n  // TODO: use linear algebra\n  const viewMouseX = mouseX - offsetLeft;\n  const viewMouseY = mouseY - offsetTop;\n\n  if (viewMouseX < 0 || viewMouseY < 0) {\n    // The mouse is outside the heatmap.\n    return [null, null];\n  } // Determine the rowI and colI values based on the current viewState.\n\n\n  const bboxTargetX = targetX * scaleFactor + matrixWidth * scaleFactor / 2;\n  const bboxTargetY = targetY * scaleFactor + matrixHeight * scaleFactor / 2;\n  const bboxLeft = bboxTargetX - matrixWidth / 2;\n  const bboxTop = bboxTargetY - matrixHeight / 2;\n  const zoomedOffsetLeft = bboxLeft / (matrixWidth * scaleFactor);\n  const zoomedOffsetTop = bboxTop / (matrixHeight * scaleFactor);\n  const zoomedViewMouseX = viewMouseX / (matrixWidth * scaleFactor);\n  const zoomedViewMouseY = viewMouseY / (matrixHeight * scaleFactor);\n  const zoomedMouseX = zoomedOffsetLeft + zoomedViewMouseX;\n  const zoomedMouseY = zoomedOffsetTop + zoomedViewMouseY;\n  const rowI = Math.floor(zoomedMouseY * numRows);\n  const colI = Math.floor(zoomedMouseX * numCols);\n  return [colI, rowI];\n}\n/**\n * Convert a heatmap coordinate (col index, row index) to a mouse coordinate (x, y).\n * @param {number} colI The column index of interest.\n * @param {number} rowI The row index of interest.\n * @param {object} param2 An object containing current sizes and scale factors.\n * @returns {number[]} [x, y]\n */\n\nexport function heatmapToMousePosition(colI, rowI, {\n  offsetLeft,\n  offsetTop,\n  targetX,\n  targetY,\n  scaleFactor,\n  matrixWidth,\n  matrixHeight,\n  numRows,\n  numCols\n}) {\n  // TODO: use linear algebra\n  let zoomedMouseY = null;\n  let zoomedMouseX = null;\n\n  if (rowI !== null) {\n    const minY = -matrixHeight * scaleFactor / 2;\n    const maxY = matrixHeight * scaleFactor / 2;\n    const totalHeight = maxY - minY;\n    const minInViewY = targetY * scaleFactor - matrixHeight / 2;\n    const maxInViewY = targetY * scaleFactor + matrixHeight / 2;\n    const inViewHeight = maxInViewY - minInViewY;\n    const normalizedRowY = (rowI + 0.5) / numRows;\n    const globalRowY = minY + normalizedRowY * totalHeight;\n\n    if (minInViewY <= globalRowY && globalRowY <= maxInViewY) {\n      zoomedMouseY = offsetTop + (globalRowY - minInViewY) / inViewHeight * matrixHeight;\n    }\n  }\n\n  if (colI !== null) {\n    const minX = -matrixWidth * scaleFactor / 2;\n    const maxX = matrixWidth * scaleFactor / 2;\n    const totalWidth = maxX - minX;\n    const minInViewX = targetX * scaleFactor - matrixWidth / 2;\n    const maxInViewX = targetX * scaleFactor + matrixWidth / 2;\n    const inViewWidth = maxInViewX - minInViewX;\n    const normalizedRowX = (colI + 0.5) / numCols;\n    const globalRowX = minX + normalizedRowX * totalWidth;\n\n    if (minInViewX <= globalRowX && globalRowX <= maxInViewX) {\n      zoomedMouseX = offsetLeft + (globalRowX - minInViewX) / inViewWidth * matrixWidth;\n    }\n  }\n\n  return [zoomedMouseX, zoomedMouseY];\n}\n/**\n * Convert a mouse coordinate (x, y) to a heatmap color bar coordinate (cell index, track index).\n * @param {number} mouseX The mouse X of interest.\n * @param {number} mouseY The mouse Y of interest.\n * @param {object} param2 An object containing current sizes and scale factors.\n * @returns {number[]} [cellI, trackI]\n */\n\nexport function mouseToCellColorPosition(mouseX, mouseY, {\n  axisOffsetTop,\n  axisOffsetLeft,\n  offsetTop,\n  offsetLeft,\n  colorBarSize,\n  numCellColorTracks,\n  transpose,\n  targetX,\n  targetY,\n  scaleFactor,\n  matrixWidth,\n  matrixHeight,\n  numRows,\n  numCols\n}) {\n  const cellPosition = transpose ? mouseX - offsetLeft : mouseY - offsetTop;\n  const trackPosition = transpose ? mouseY - axisOffsetTop : mouseX - axisOffsetLeft;\n  const tracksWidth = numCellColorTracks * colorBarSize; // outside of cell color tracks\n\n  if (cellPosition < 0 || trackPosition < 0 || trackPosition >= tracksWidth) {\n    return [null, null];\n  } // Determine the trackI and cellI values based on the current viewState.\n\n\n  const trackI = Math.floor(trackPosition / colorBarSize);\n  let cellI;\n\n  if (transpose) {\n    const viewMouseX = mouseX - offsetLeft;\n    const bboxTargetX = targetX * scaleFactor + matrixWidth * scaleFactor / 2;\n    const bboxLeft = bboxTargetX - matrixWidth / 2;\n    const zoomedOffsetLeft = bboxLeft / (matrixWidth * scaleFactor);\n    const zoomedViewMouseX = viewMouseX / (matrixWidth * scaleFactor);\n    const zoomedMouseX = zoomedOffsetLeft + zoomedViewMouseX;\n    cellI = Math.floor(zoomedMouseX * numCols);\n    return [cellI, trackI];\n  } // Not transposed\n\n\n  const viewMouseY = mouseY - axisOffsetTop;\n  const bboxTargetY = targetY * scaleFactor + matrixHeight * scaleFactor / 2;\n  const bboxTop = bboxTargetY - matrixHeight / 2;\n  const zoomedOffsetTop = bboxTop / (matrixHeight * scaleFactor);\n  const zoomedViewMouseY = viewMouseY / (matrixHeight * scaleFactor);\n  const zoomedMouseY = zoomedOffsetTop + zoomedViewMouseY;\n  cellI = Math.floor(zoomedMouseY * numRows);\n  return [cellI, trackI];\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/heatmap/utils.js"],"names":["clamp","range","AXIS_LABEL_TEXT_SIZE","AXIS_FONT_FAMILY","AXIS_PADDING","AXIS_MIN_SIZE","AXIS_MAX_SIZE","getGeneByCellTile","view","tileSize","tileI","tileJ","numCells","numGenes","cellOrdering","expressionRowLookUp","tileData","Uint8Array","offset","value","cellI","geneI","sortedCellI","tileSizeRange","forEach","j","get","i","getCellByGeneTile","layerFilter","layer","viewport","id","startsWith","matches","match","getTextWidth","text","font","canvas","document","createElement","context","getContext","metrics","measureText","width","getAxisSizes","transpose","longestGeneLabel","longestCellLabel","hideObservationLabels","hideVariableLabels","geneLabelMaxWidth","cellLabelMaxWidth","axisOffsetLeft","axisOffsetTop","mouseToHeatmapPosition","mouseX","mouseY","offsetLeft","offsetTop","targetX","targetY","scaleFactor","matrixWidth","matrixHeight","numRows","numCols","viewMouseX","viewMouseY","bboxTargetX","bboxTargetY","bboxLeft","bboxTop","zoomedOffsetLeft","zoomedOffsetTop","zoomedViewMouseX","zoomedViewMouseY","zoomedMouseX","zoomedMouseY","rowI","Math","floor","colI","heatmapToMousePosition","minY","maxY","totalHeight","minInViewY","maxInViewY","inViewHeight","normalizedRowY","globalRowY","minX","maxX","totalWidth","minInViewX","maxInViewX","inViewWidth","normalizedRowX","globalRowX","mouseToCellColorPosition","colorBarSize","numCellColorTracks","cellPosition","trackPosition","tracksWidth","trackI"],"mappings":"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","sourcesContent":["import clamp from 'lodash/clamp';\nimport range from 'lodash/range';\n\nimport {\n  AXIS_LABEL_TEXT_SIZE,\n  AXIS_FONT_FAMILY,\n  AXIS_PADDING,\n  AXIS_MIN_SIZE,\n  AXIS_MAX_SIZE,\n} from '../../layers/heatmap-constants';\n\nexport function getGeneByCellTile(view, {\n  tileSize, tileI, tileJ, numCells, numGenes, cellOrdering, expressionRowLookUp,\n}) {\n  const tileData = new Uint8Array(tileSize * tileSize);\n  let offset;\n  let value;\n  let cellI;\n  let geneI;\n  let sortedCellI;\n\n  const tileSizeRange = range(tileSize);\n\n  tileSizeRange.forEach((j) => {\n    // Need to iterate over cells in the outer loop.\n    cellI = (tileJ * tileSize) + j;\n    if (cellI < numCells) {\n      sortedCellI = expressionRowLookUp.get(cellOrdering[cellI]);\n      if (sortedCellI >= -1) {\n        tileSizeRange.forEach((i) => {\n          geneI = (tileI * tileSize) + i;\n          value = view[sortedCellI * numGenes + geneI];\n          offset = ((tileSize - i - 1) * tileSize + j);\n          tileData[offset] = value;\n        });\n      }\n    }\n  });\n  return tileData;\n}\n\nexport function getCellByGeneTile(view, {\n  tileSize, tileI, tileJ, numCells, numGenes, cellOrdering, expressionRowLookUp,\n}) {\n  const tileData = new Uint8Array(tileSize * tileSize);\n  let offset;\n  let value;\n  let cellI;\n  let geneI;\n  let sortedCellI;\n\n  const tileSizeRange = range(tileSize);\n\n  tileSizeRange.forEach((i) => {\n    // Need to iterate over cells in the outer loop.\n    cellI = (tileI * tileSize) + i;\n    if (cellI < numCells) {\n      sortedCellI = expressionRowLookUp.get(cellOrdering[cellI]);\n      if (sortedCellI >= -1) {\n        tileSizeRange.forEach((j) => {\n          geneI = (tileJ * tileSize) + j;\n          if (geneI < numGenes) {\n            value = view[sortedCellI * numGenes + geneI];\n          } else {\n            value = 0;\n          }\n          offset = ((tileSize - i - 1) * tileSize + j);\n          tileData[offset] = value;\n        });\n      }\n    }\n  });\n\n  return tileData;\n}\n\n/**\n * Called before a layer is drawn to determine whether it should be rendered.\n * Reference: https://deck.gl/docs/api-reference/core/deck#layerfilter\n * @param {object} params A viewport, layer pair.\n * @param {object} params.layer The layer to check.\n * @param {object} params.viewport The viewport to check.\n * @returns {boolean} Should this layer be rendered in this viewport?\n */\nexport function layerFilter({ layer, viewport }) {\n  if (viewport.id === 'axisLeft') {\n    return layer.id.startsWith('axisLeft');\n  }\n\n  if (viewport.id === 'axisTop') {\n    return layer.id.startsWith('axisTop');\n  }\n\n  if (viewport.id === 'cellColorLabel') {\n    return layer.id.startsWith('cellColorLabel');\n  }\n\n  if (viewport.id === 'heatmap') {\n    return layer.id.startsWith('heatmap');\n  }\n\n  if (viewport.id.startsWith('colorsLeft')) {\n    const matches = viewport.id.match(/-(\\d)/);\n    if (matches) return layer.id.startsWith(`colorsLeftLayer-${matches[1]}`);\n  }\n\n  if (viewport.id.startsWith('colorsTop')) {\n    const matches = viewport.id.match(/-(\\d)/);\n    if (matches) return layer.id.startsWith(`colorsTopLayer-${matches[1]}`);\n  }\n\n  return false;\n}\n\n/**\n * Uses canvas.measureText to compute and return the width of the given text\n * of given font in pixels.\n *\n * @param {String} text The text to be rendered.\n * @param {String} font The css font descriptor that text is to be rendered\n * with (e.g. \"bold 14px verdana\").\n *\n * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n */\nfunction getTextWidth(text, font) {\n  // re-use canvas object for better performance\n  const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n}\n\n/**\n * Get the size of the left and top heatmap axes,\n * taking into account the maximum label string lengths.\n * @param {boolean} transpose Is the heatmap transposed?\n * @param {String} longestGeneLabel longest gene label\n * @param {String} longestCellLabel longest cell label\n * @param {boolean} hideObservationLabels are cell labels hidden?\n * @param {boolean} hideVariableLabels are gene labels hidden?\n * Increases vertical space for heatmap\n * @returns {number[]} [axisOffsetLeft, axisOffsetTop]\n */\nexport function getAxisSizes(\n  transpose, longestGeneLabel, longestCellLabel,\n  hideObservationLabels, hideVariableLabels,\n) {\n  const font = `${AXIS_LABEL_TEXT_SIZE}pt ${AXIS_FONT_FAMILY}`;\n  const geneLabelMaxWidth = hideVariableLabels\n    ? 0 : getTextWidth(longestGeneLabel, font) + AXIS_PADDING;\n  const cellLabelMaxWidth = hideObservationLabels\n    ? 0 : getTextWidth(longestCellLabel, font) + AXIS_PADDING;\n\n  const axisOffsetLeft = clamp(\n    (transpose ? geneLabelMaxWidth : cellLabelMaxWidth),\n    AXIS_MIN_SIZE,\n    AXIS_MAX_SIZE,\n  );\n  const axisOffsetTop = clamp(\n    (transpose ? cellLabelMaxWidth : geneLabelMaxWidth),\n    AXIS_MIN_SIZE,\n    AXIS_MAX_SIZE,\n  );\n  return [axisOffsetLeft, axisOffsetTop];\n}\n\n/**\n * Convert a mouse coordinate (x, y) to a heatmap coordinate (col index, row index).\n * @param {number} mouseX The mouse X of interest.\n * @param {number} mouseY The mouse Y of interest.\n * @param {object} param2 An object containing current sizes and scale factors.\n * @returns {number[]} [colI, rowI]\n */\nexport function mouseToHeatmapPosition(mouseX, mouseY, {\n  offsetLeft, offsetTop, targetX, targetY, scaleFactor, matrixWidth, matrixHeight, numRows, numCols,\n}) {\n  // TODO: use linear algebra\n  const viewMouseX = mouseX - offsetLeft;\n  const viewMouseY = mouseY - offsetTop;\n\n  if (viewMouseX < 0 || viewMouseY < 0) {\n    // The mouse is outside the heatmap.\n    return [null, null];\n  }\n\n  // Determine the rowI and colI values based on the current viewState.\n  const bboxTargetX = targetX * scaleFactor + matrixWidth * scaleFactor / 2;\n  const bboxTargetY = targetY * scaleFactor + matrixHeight * scaleFactor / 2;\n\n  const bboxLeft = bboxTargetX - matrixWidth / 2;\n  const bboxTop = bboxTargetY - matrixHeight / 2;\n\n  const zoomedOffsetLeft = bboxLeft / (matrixWidth * scaleFactor);\n  const zoomedOffsetTop = bboxTop / (matrixHeight * scaleFactor);\n\n  const zoomedViewMouseX = viewMouseX / (matrixWidth * scaleFactor);\n  const zoomedViewMouseY = viewMouseY / (matrixHeight * scaleFactor);\n\n  const zoomedMouseX = zoomedOffsetLeft + zoomedViewMouseX;\n  const zoomedMouseY = zoomedOffsetTop + zoomedViewMouseY;\n\n  const rowI = Math.floor(zoomedMouseY * numRows);\n  const colI = Math.floor(zoomedMouseX * numCols);\n  return [colI, rowI];\n}\n\n/**\n * Convert a heatmap coordinate (col index, row index) to a mouse coordinate (x, y).\n * @param {number} colI The column index of interest.\n * @param {number} rowI The row index of interest.\n * @param {object} param2 An object containing current sizes and scale factors.\n * @returns {number[]} [x, y]\n */\nexport function heatmapToMousePosition(colI, rowI, {\n  offsetLeft, offsetTop, targetX, targetY, scaleFactor, matrixWidth, matrixHeight, numRows, numCols,\n}) {\n  // TODO: use linear algebra\n  let zoomedMouseY = null;\n  let zoomedMouseX = null;\n\n  if (rowI !== null) {\n    const minY = -matrixHeight * scaleFactor / 2;\n    const maxY = matrixHeight * scaleFactor / 2;\n    const totalHeight = maxY - minY;\n\n    const minInViewY = (targetY * scaleFactor) - (matrixHeight / 2);\n    const maxInViewY = (targetY * scaleFactor) + (matrixHeight / 2);\n    const inViewHeight = maxInViewY - minInViewY;\n\n    const normalizedRowY = (rowI + 0.5) / numRows;\n    const globalRowY = minY + (normalizedRowY * totalHeight);\n\n    if (minInViewY <= globalRowY && globalRowY <= maxInViewY) {\n      zoomedMouseY = offsetTop + ((globalRowY - minInViewY) / inViewHeight) * matrixHeight;\n    }\n  }\n  if (colI !== null) {\n    const minX = -matrixWidth * scaleFactor / 2;\n    const maxX = matrixWidth * scaleFactor / 2;\n    const totalWidth = maxX - minX;\n\n    const minInViewX = (targetX * scaleFactor) - (matrixWidth / 2);\n    const maxInViewX = (targetX * scaleFactor) + (matrixWidth / 2);\n    const inViewWidth = maxInViewX - minInViewX;\n\n    const normalizedRowX = (colI + 0.5) / numCols;\n    const globalRowX = minX + (normalizedRowX * totalWidth);\n\n    if (minInViewX <= globalRowX && globalRowX <= maxInViewX) {\n      zoomedMouseX = offsetLeft + ((globalRowX - minInViewX) / inViewWidth) * matrixWidth;\n    }\n  }\n  return [zoomedMouseX, zoomedMouseY];\n}\n\n/**\n * Convert a mouse coordinate (x, y) to a heatmap color bar coordinate (cell index, track index).\n * @param {number} mouseX The mouse X of interest.\n * @param {number} mouseY The mouse Y of interest.\n * @param {object} param2 An object containing current sizes and scale factors.\n * @returns {number[]} [cellI, trackI]\n */\nexport function mouseToCellColorPosition(mouseX, mouseY, {\n  axisOffsetTop,\n  axisOffsetLeft,\n  offsetTop,\n  offsetLeft,\n  colorBarSize,\n  numCellColorTracks,\n  transpose,\n  targetX,\n  targetY,\n  scaleFactor,\n  matrixWidth,\n  matrixHeight,\n  numRows,\n  numCols,\n}) {\n  const cellPosition = transpose ? mouseX - offsetLeft : mouseY - offsetTop;\n  const trackPosition = transpose ? mouseY - axisOffsetTop : mouseX - axisOffsetLeft;\n\n  const tracksWidth = numCellColorTracks * colorBarSize;\n\n  // outside of cell color tracks\n  if (cellPosition < 0 || trackPosition < 0 || trackPosition >= tracksWidth) {\n    return [null, null];\n  }\n\n  // Determine the trackI and cellI values based on the current viewState.\n  const trackI = Math.floor(trackPosition / colorBarSize);\n\n  let cellI;\n  if (transpose) {\n    const viewMouseX = mouseX - offsetLeft;\n    const bboxTargetX = targetX * scaleFactor + matrixWidth * scaleFactor / 2;\n    const bboxLeft = bboxTargetX - matrixWidth / 2;\n    const zoomedOffsetLeft = bboxLeft / (matrixWidth * scaleFactor);\n    const zoomedViewMouseX = viewMouseX / (matrixWidth * scaleFactor);\n    const zoomedMouseX = zoomedOffsetLeft + zoomedViewMouseX;\n    cellI = Math.floor(zoomedMouseX * numCols);\n    return [cellI, trackI];\n  }\n  // Not transposed\n  const viewMouseY = mouseY - axisOffsetTop;\n  const bboxTargetY = targetY * scaleFactor + matrixHeight * scaleFactor / 2;\n  const bboxTop = bboxTargetY - matrixHeight / 2;\n  const zoomedOffsetTop = bboxTop / (matrixHeight * scaleFactor);\n  const zoomedViewMouseY = viewMouseY / (matrixHeight * scaleFactor);\n  const zoomedMouseY = zoomedOffsetTop + zoomedViewMouseY;\n  cellI = Math.floor(zoomedMouseY * numRows);\n\n  return [cellI, trackI];\n}\n"]},"metadata":{},"sourceType":"module"}