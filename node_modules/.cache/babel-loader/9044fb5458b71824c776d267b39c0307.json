{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar geojson_rbush_1 = require(\"geojson-rbush\");\n\nvar line_segment_1 = require(\"@turf/line-segment\");\n\nvar nearest_point_on_line_1 = require(\"@turf/nearest-point-on-line\");\n\nvar boolean_point_on_line_1 = require(\"@turf/boolean-point-on-line\");\n\nvar invariant_1 = require(\"@turf/invariant\");\n\nvar meta_1 = require(\"@turf/meta\");\n\nvar helpers_1 = require(\"@turf/helpers\");\n\nvar equal = require(\"deep-equal\");\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @name lineOverlap\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\n\n\nfunction lineOverlap(line1, line2, options) {\n  if (options === void 0) {\n    options = {};\n  } // Optional parameters\n\n\n  options = options || {};\n  if (!helpers_1.isObject(options)) throw new Error('options is invalid');\n  var tolerance = options.tolerance || 0; // Containers\n\n  var features = []; // Create Spatial Index\n\n  var tree = geojson_rbush_1.default(); // To-Do -- HACK way to support typescript\n\n  var line = line_segment_1.default(line1);\n  tree.load(line);\n  var overlapSegment; // Line Intersection\n  // Iterate over line segments\n\n  meta_1.segmentEach(line2, function (segment) {\n    var doesOverlaps = false; // Iterate over each segments which falls within the same bounds\n\n    meta_1.featureEach(tree.search(segment), function (match) {\n      if (doesOverlaps === false) {\n        var coordsSegment = invariant_1.getCoords(segment).sort();\n        var coordsMatch = invariant_1.getCoords(match).sort(); // Segment overlaps feature\n\n        if (equal(coordsSegment, coordsMatch)) {\n          doesOverlaps = true; // Overlaps already exists - only append last coordinate of segment\n\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);else overlapSegment = segment; // Match segments which don't share nodes (Issue #901)\n        } else if (tolerance === 0 ? boolean_point_on_line_1.default(coordsSegment[0], match) && boolean_point_on_line_1.default(coordsSegment[1], match) : nearest_point_on_line_1.default(match, coordsSegment[0]).properties.dist <= tolerance && nearest_point_on_line_1.default(match, coordsSegment[1]).properties.dist <= tolerance) {\n          doesOverlaps = true;\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);else overlapSegment = segment;\n        } else if (tolerance === 0 ? boolean_point_on_line_1.default(coordsMatch[0], segment) && boolean_point_on_line_1.default(coordsMatch[1], segment) : nearest_point_on_line_1.default(segment, coordsMatch[0]).properties.dist <= tolerance && nearest_point_on_line_1.default(segment, coordsMatch[1]).properties.dist <= tolerance) {\n          // Do not define (doesOverlap = true) since more matches can occur within the same segment\n          // doesOverlaps = true;\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, match);else overlapSegment = match;\n        }\n      }\n    }); // Segment doesn't overlap - add overlaps to results & reset\n\n    if (doesOverlaps === false && overlapSegment) {\n      features.push(overlapSegment);\n      overlapSegment = undefined;\n    }\n  }); // Add last segment if exists\n\n  if (overlapSegment) features.push(overlapSegment);\n  return helpers_1.featureCollection(features);\n}\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\n\n\nfunction concatSegment(line, segment) {\n  var coords = invariant_1.getCoords(segment);\n  var lineCoords = invariant_1.getCoords(line);\n  var start = lineCoords[0];\n  var end = lineCoords[lineCoords.length - 1];\n  var geom = line.geometry.coordinates;\n  if (equal(coords[0], start)) geom.unshift(coords[1]);else if (equal(coords[0], end)) geom.push(coords[1]);else if (equal(coords[1], start)) geom.unshift(coords[0]);else if (equal(coords[1], end)) geom.push(coords[0]);\n  return line;\n}\n\nexports.default = lineOverlap;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/line-overlap/index.js"],"names":["Object","defineProperty","exports","value","geojson_rbush_1","require","line_segment_1","nearest_point_on_line_1","boolean_point_on_line_1","invariant_1","meta_1","helpers_1","equal","lineOverlap","line1","line2","options","isObject","Error","tolerance","features","tree","default","line","load","overlapSegment","segmentEach","segment","doesOverlaps","featureEach","search","match","coordsSegment","getCoords","sort","coordsMatch","concatSegment","properties","dist","push","undefined","featureCollection","coords","lineCoords","start","end","length","geom","geometry","coordinates","unshift"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar geojson_rbush_1 = require(\"geojson-rbush\");\nvar line_segment_1 = require(\"@turf/line-segment\");\nvar nearest_point_on_line_1 = require(\"@turf/nearest-point-on-line\");\nvar boolean_point_on_line_1 = require(\"@turf/boolean-point-on-line\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\nvar helpers_1 = require(\"@turf/helpers\");\nvar equal = require(\"deep-equal\");\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @name lineOverlap\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\nfunction lineOverlap(line1, line2, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    options = options || {};\n    if (!helpers_1.isObject(options))\n        throw new Error('options is invalid');\n    var tolerance = options.tolerance || 0;\n    // Containers\n    var features = [];\n    // Create Spatial Index\n    var tree = geojson_rbush_1.default();\n    // To-Do -- HACK way to support typescript\n    var line = line_segment_1.default(line1);\n    tree.load(line);\n    var overlapSegment;\n    // Line Intersection\n    // Iterate over line segments\n    meta_1.segmentEach(line2, function (segment) {\n        var doesOverlaps = false;\n        // Iterate over each segments which falls within the same bounds\n        meta_1.featureEach(tree.search(segment), function (match) {\n            if (doesOverlaps === false) {\n                var coordsSegment = invariant_1.getCoords(segment).sort();\n                var coordsMatch = invariant_1.getCoords(match).sort();\n                // Segment overlaps feature\n                if (equal(coordsSegment, coordsMatch)) {\n                    doesOverlaps = true;\n                    // Overlaps already exists - only append last coordinate of segment\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                    // Match segments which don't share nodes (Issue #901)\n                }\n                else if ((tolerance === 0) ?\n                    boolean_point_on_line_1.default(coordsSegment[0], match) && boolean_point_on_line_1.default(coordsSegment[1], match) :\n                    nearest_point_on_line_1.default(match, coordsSegment[0]).properties.dist <= tolerance &&\n                        nearest_point_on_line_1.default(match, coordsSegment[1]).properties.dist <= tolerance) {\n                    doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                }\n                else if ((tolerance === 0) ?\n                    boolean_point_on_line_1.default(coordsMatch[0], segment) && boolean_point_on_line_1.default(coordsMatch[1], segment) :\n                    nearest_point_on_line_1.default(segment, coordsMatch[0]).properties.dist <= tolerance &&\n                        nearest_point_on_line_1.default(segment, coordsMatch[1]).properties.dist <= tolerance) {\n                    // Do not define (doesOverlap = true) since more matches can occur within the same segment\n                    // doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, match);\n                    else\n                        overlapSegment = match;\n                }\n            }\n        });\n        // Segment doesn't overlap - add overlaps to results & reset\n        if (doesOverlaps === false && overlapSegment) {\n            features.push(overlapSegment);\n            overlapSegment = undefined;\n        }\n    });\n    // Add last segment if exists\n    if (overlapSegment)\n        features.push(overlapSegment);\n    return helpers_1.featureCollection(features);\n}\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\nfunction concatSegment(line, segment) {\n    var coords = invariant_1.getCoords(segment);\n    var lineCoords = invariant_1.getCoords(line);\n    var start = lineCoords[0];\n    var end = lineCoords[lineCoords.length - 1];\n    var geom = line.geometry.coordinates;\n    if (equal(coords[0], start))\n        geom.unshift(coords[1]);\n    else if (equal(coords[0], end))\n        geom.push(coords[1]);\n    else if (equal(coords[1], start))\n        geom.unshift(coords[0]);\n    else if (equal(coords[1], end))\n        geom.push(coords[0]);\n    return line;\n}\nexports.default = lineOverlap;\n"]},"metadata":{},"sourceType":"script"}