{"ast":null,"code":"import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n  }\n\n  clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n\n  dependentFields() {\n    var _a;\n\n    return new Set([this.transform.impute, this.transform.key, ...((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : [])]);\n  }\n\n  producedFields() {\n    return new Set([this.transform.impute]);\n  }\n\n  processSequence(keyvals) {\n    const {\n      start = 0,\n      stop,\n      step\n    } = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n    return {\n      signal: `sequence(${result})`\n    };\n  }\n\n  static makeFromTransform(parent, imputeTransform) {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  static makeFromEncoding(parent, model) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {\n        method,\n        value,\n        frame,\n        keyvals\n      } = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n      return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        impute: imputedChannel.field,\n        key: keyChannel.field\n      }, method ? {\n        method\n      } : {}), value !== undefined ? {\n        value\n      } : {}), frame ? {\n        frame\n      } : {}), keyvals !== undefined ? {\n        keyvals\n      } : {}), groupbyFields.length ? {\n        groupby: groupbyFields\n      } : {}));\n    }\n\n    return null;\n  }\n\n  hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n\n  assemble() {\n    const {\n      impute,\n      key,\n      keyvals,\n      method,\n      groupby,\n      value,\n      frame = [null, null]\n    } = this.transform;\n    const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({\n      type: 'impute',\n      field: impute,\n      key\n    }, keyvals ? {\n      keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n    } : {}), {\n      method: 'value'\n    }), groupby ? {\n      groupby\n    } : {}), {\n      value: !method || method === 'value' ? value : null\n    });\n\n    if (method && method !== 'value') {\n      const deriveNewField = Object.assign({\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false\n      }, groupby ? {\n        groupby\n      } : {});\n      const replaceOriginal = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      return [imputeTransform, deriveNewField, replaceOriginal];\n    } else {\n      return [imputeTransform];\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/impute.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n    constructor(parent, transform) {\n        super(parent);\n        this.transform = transform;\n    }\n    clone() {\n        return new ImputeNode(null, duplicate(this.transform));\n    }\n    dependentFields() {\n        var _a;\n        return new Set([this.transform.impute, this.transform.key, ...((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : [])]);\n    }\n    producedFields() {\n        return new Set([this.transform.impute]);\n    }\n    processSequence(keyvals) {\n        const { start = 0, stop, step } = keyvals;\n        const result = [start, stop, ...(step ? [step] : [])].join(',');\n        return { signal: `sequence(${result})` };\n    }\n    static makeFromTransform(parent, imputeTransform) {\n        return new ImputeNode(parent, imputeTransform);\n    }\n    static makeFromEncoding(parent, model) {\n        const encoding = model.encoding;\n        const xDef = encoding.x;\n        const yDef = encoding.y;\n        if (isFieldDef(xDef) && isFieldDef(yDef)) {\n            const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n            if (imputedChannel === undefined) {\n                return undefined;\n            }\n            const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n            const { method, value, frame, keyvals } = imputedChannel.impute;\n            const groupbyFields = pathGroupingFields(model.mark, encoding);\n            return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ impute: imputedChannel.field, key: keyChannel.field }, (method ? { method } : {})), (value !== undefined ? { value } : {})), (frame ? { frame } : {})), (keyvals !== undefined ? { keyvals } : {})), (groupbyFields.length ? { groupby: groupbyFields } : {})));\n        }\n        return null;\n    }\n    hash() {\n        return `Impute ${hash(this.transform)}`;\n    }\n    assemble() {\n        const { impute, key, keyvals, method, groupby, value, frame = [null, null] } = this.transform;\n        const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({ type: 'impute', field: impute, key }, (keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {})), { method: 'value' }), (groupby ? { groupby } : {})), { value: !method || method === 'value' ? value : null });\n        if (method && method !== 'value') {\n            const deriveNewField = Object.assign({ type: 'window', as: [`imputed_${impute}_value`], ops: [method], fields: [impute], frame, ignorePeers: false }, (groupby ? { groupby } : {}));\n            const replaceOriginal = {\n                type: 'formula',\n                expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n                as: impute\n            };\n            return [imputeTransform, deriveNewField, replaceOriginal];\n        }\n        else {\n            return [imputeTransform];\n        }\n    }\n}\n//# sourceMappingURL=impute.js.map"]},"metadata":{},"sourceType":"module"}