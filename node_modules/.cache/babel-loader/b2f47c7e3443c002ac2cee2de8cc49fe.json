{"ast":null,"code":"import { HTTPStore, openArray, slice } from 'zarr';\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction multivecChunksToTileDenseArray(chunks, tileShape, isRow) {\n  // Allocate a Float32Array for the tile (with length tile_size).\n  var fullTileLength = isRow ? tileShape[1] : tileShape[0] * tileShape[1];\n  var fullTileArray = new Float32Array(fullTileLength); // Fill in the data for each sample and chunk.\n\n  var offset = 0;\n\n  if (isRow) {\n    // Single row, no need to iterate over samples.\n    var _iterator = _createForOfIteratorHelper(chunks),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var chunk = _step.value;\n        var chunkData = chunk.data;\n        fullTileArray.set(chunkData, offset);\n        offset += chunkData.length;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    // Multi-row, need to iterate over samples.\n    var numSamples = tileShape[0];\n\n    for (var sampleI = 0; sampleI < numSamples; sampleI++) {\n      var _iterator2 = _createForOfIteratorHelper(chunks),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _chunk = _step2.value;\n          var _chunkData = _chunk.data[sampleI];\n          fullTileArray.set(_chunkData, offset);\n          offset += _chunkData.length;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }\n\n  return fullTileArray;\n}\n\nvar ZarrMultivecDataFetcher = function ZarrMultivecDataFetcher(HGC) {\n  if (!(this instanceof ZarrMultivecDataFetcher ? this.constructor : void 0)) {\n    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without \"new\"');\n  }\n\n  var slugid = HGC.libraries.slugid;\n  var _HGC$utils = HGC.utils,\n      absToChr = _HGC$utils.absToChr,\n      parseChromsizesRows = _HGC$utils.parseChromsizesRows,\n      genomicRangeToChromosomeChunks = _HGC$utils.genomicRangeToChromosomeChunks,\n      DenseDataExtrema1D = _HGC$utils.DenseDataExtrema1D,\n      minNonZero = _HGC$utils.minNonZero,\n      maxNonZero = _HGC$utils.maxNonZero;\n\n  var ZarrMultivecDataFetcherClass = /*#__PURE__*/function () {\n    function ZarrMultivecDataFetcherClass(dataConfig) {\n      _classCallCheck(this, ZarrMultivecDataFetcherClass);\n\n      this.dataConfig = dataConfig;\n      this.trackUid = slugid.nice();\n\n      if (dataConfig.url) {\n        // console.assert(dataConfig.url.endsWith('.zarr'));\n        // S3 bucket must have a CORS policy to allow reading from any origin.\n        this.store = new HTTPStore(dataConfig.url, {\n          supportedMethods: ['GET']\n        });\n      }\n\n      if (dataConfig.row !== undefined) {\n        this.row = dataConfig.row;\n      }\n    }\n\n    _createClass(ZarrMultivecDataFetcherClass, [{\n      key: \"tilesetInfo\",\n      value: function tilesetInfo(callback) {\n        var _this = this;\n\n        this.tilesetInfoLoading = true; // Use the tileset_info stored as JSON in file.zarr/.zattrs\n\n        return this.store.getItem('.zattrs').then(function (bytes) {\n          var decoder = new TextDecoder('utf-8');\n          var json = JSON.parse(decoder.decode(bytes));\n          return json;\n        }).then(function (attrs) {\n          _this.tilesetInfoLoading = false;\n          var chromSizes = attrs.multiscales.map(function (d) {\n            return [d.name, d.metadata.chromsize];\n          });\n          var finalChrom = attrs.multiscales[attrs.multiscales.length - 1];\n          var maxPos = finalChrom.metadata.chromoffset + finalChrom.metadata.chromsize;\n          var tileSize = attrs.shape[1];\n\n          var retVal = _objectSpread(_objectSpread({}, attrs), {}, {\n            shape: [attrs.shape[1], attrs.shape[0]],\n            chromSizes: chromSizes,\n            tile_size: tileSize,\n            max_width: maxPos,\n            min_pos: [0],\n            max_pos: [maxPos],\n            max_zoom: Math.ceil(Math.log(maxPos / tileSize) / Math.log(2))\n          });\n\n          if (callback) {\n            callback(retVal);\n          }\n\n          return retVal;\n        })[\"catch\"](function (err) {\n          _this.tilesetInfoLoading = false;\n\n          if (callback) {\n            callback({\n              error: \"Error parsing zarr multivec: \".concat(err)\n            });\n          }\n        });\n      }\n    }, {\n      key: \"fetchTilesDebounced\",\n      value: function fetchTilesDebounced(receivedTiles, tileIds) {\n        var tiles = {};\n        var validTileIds = [];\n        var tilePromises = [];\n\n        var _iterator3 = _createForOfIteratorHelper(tileIds),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var tileId = _step3.value;\n            var parts = tileId.split('.');\n            var z = parseInt(parts[0], 10);\n            var x = parseInt(parts[1], 10);\n\n            if (Number.isNaN(x) || Number.isNaN(z)) {\n              console.warn('Invalid tile zoom or position:', z, x);\n              continue;\n            }\n\n            validTileIds.push(tileId);\n            tilePromises.push(this.tile(z, x, tileId));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        Promise.all(tilePromises).then(function (values) {\n          for (var i = 0; i < values.length; i++) {\n            var validTileId = validTileIds[i];\n            tiles[validTileId] = values[i];\n            tiles[validTileId].tilePositionId = validTileId;\n          }\n\n          receivedTiles(tiles);\n        });\n        return tiles;\n      }\n    }, {\n      key: \"tile\",\n      value: function tile(z, x, tileId) {\n        var _this2 = this;\n\n        var store = this.store;\n        return this.tilesetInfo().then(function (tsInfo) {\n          // const multiscales = tsInfo.multiscales;\n          // Adapted from clodius.tiles.multivec.get_single_tile\n          // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L66\n          // z is the index of the resolution that should be selected.\n          // Resolution is size of each bin (except for the last bin in each chromosome).\n          var resolution = +tsInfo.resolutions[z];\n          var tileSize = +tsInfo.tile_size;\n          var binSize = resolution; // Where in the data does the tile start and end?\n\n          var tileStart = x * tileSize * resolution;\n          var tileEnd = tileStart + tileSize * resolution; // chromSizes is an array of \"tuples\" [ [\"chr1\", 1000], ... ]\n\n          var chromSizes = tsInfo.chromSizes; // Adapted from clodius.tiles.multivec.get_tile\n          // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L110\n\n          var chromInfo = parseChromsizesRows(chromSizes);\n\n          var _absToChr = absToChr(tileStart, chromInfo),\n              _absToChr2 = _slicedToArray(_absToChr, 2),\n              chrStart = _absToChr2[0],\n              chrStartPos = _absToChr2[1];\n\n          var _absToChr3 = absToChr(tileEnd, chromInfo),\n              _absToChr4 = _slicedToArray(_absToChr3, 2),\n              chrEnd = _absToChr4[0],\n              chrEndPos = _absToChr4[1];\n\n          var genomicStart = {\n            chr: chrStart,\n            pos: chrStartPos\n          };\n          var genomicEnd = {\n            chr: chrEnd,\n            pos: chrEndPos\n          }; // Using the [genomicStart, genomicEnd] range, get an array of \"chromosome chunks\",\n          // where each chunk range starts and ends with the same chromosome.\n          // Start a new chromosome chunk at each chromosome boundary.\n\n          var chrChunks = genomicRangeToChromosomeChunks(chromSizes, genomicStart, genomicEnd, binSize, tileSize); // Get the zarr data for each chromosome chunk,\n          // since data for each chromosome is stored in a separate zarr array.\n\n          return Promise.all(chrChunks.map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 3),\n                chrName = _ref2[0],\n                zStart = _ref2[1],\n                zEnd = _ref2[2];\n\n            return openArray({\n              store: store,\n              path: \"/chromosomes/\".concat(chrName, \"/\").concat(resolution, \"/\"),\n              mode: 'r'\n            }).then(function (arr) {\n              return _this2.row !== undefined ? arr.getRaw([_this2.row, slice(zStart, zEnd)]) : arr.get([null, slice(zStart, zEnd)]);\n            });\n          })).then(function (chunks) {\n            var dense = multivecChunksToTileDenseArray(chunks, [tsInfo.shape[1], tsInfo.shape[0]], _this2.row !== undefined);\n            return Promise.resolve({\n              dense: dense,\n              denseDataExtrema: new DenseDataExtrema1D(dense),\n              dtype: 'float32',\n              min_value: Math.min.apply(null, dense),\n              max_value: Math.max.apply(null, dense),\n              minNonZero: minNonZero(dense),\n              maxNonZero: maxNonZero(dense),\n              server: null,\n              size: 1,\n              shape: tsInfo.shape,\n              tileId: tileId,\n              tilePos: [x],\n              tilePositionId: tileId,\n              tilesetUid: null,\n              zoomLevel: z\n            });\n          });\n        });\n      }\n    }]);\n\n    return ZarrMultivecDataFetcherClass;\n  }(); // end class\n\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return _construct(ZarrMultivecDataFetcherClass, args);\n}; // end function wrapper\n\n\nZarrMultivecDataFetcher.config = {\n  type: 'zarr-multivec'\n};\nexport { ZarrMultivecDataFetcher };","map":{"version":3,"sources":["../src/ZarrMultivecDataFetcher.js"],"names":["fullTileLength","isRow","tileShape","fullTileArray","offset","chunk","chunkData","numSamples","sampleI","ZarrMultivecDataFetcher","args","slugid","HGC","absToChr","parseChromsizesRows","genomicRangeToChromosomeChunks","DenseDataExtrema1D","minNonZero","maxNonZero","ZarrMultivecDataFetcherClass","dataConfig","supportedMethods","decoder","json","JSON","chromSizes","d","finalChrom","attrs","maxPos","tileSize","retVal","shape","tile_size","max_width","min_pos","max_pos","max_zoom","Math","callback","error","tiles","validTileIds","tilePromises","tileId","parts","z","parseInt","x","Number","console","Promise","i","values","validTileId","receivedTiles","store","resolution","tsInfo","binSize","tileStart","tileEnd","chromInfo","chrStart","chrStartPos","chrEnd","chrEndPos","genomicStart","chr","pos","genomicEnd","chrChunks","chrName","zStart","zEnd","path","mode","arr","slice","dense","multivecChunksToTileDenseArray","denseDataExtrema","dtype","min_value","max_value","server","size","tilePos","tilePositionId","tilesetUid","zoomLevel","type"],"mappings":"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","sourcesContent":["import { HTTPStore, openArray, slice } from 'zarr';\n\nfunction multivecChunksToTileDenseArray(chunks, tileShape, isRow) {\n  // Allocate a Float32Array for the tile (with length tile_size).\n  const fullTileLength = (isRow ? tileShape[1] : tileShape[0] * tileShape[1]);\n  const fullTileArray = new Float32Array(fullTileLength);\n\n  // Fill in the data for each sample and chunk.\n  let offset = 0;\n  if(isRow) {\n    // Single row, no need to iterate over samples.\n    for (const chunk of chunks) {\n      const chunkData = chunk.data;\n      fullTileArray.set(chunkData, offset);\n      offset += chunkData.length;\n    }\n  } else {\n    // Multi-row, need to iterate over samples.\n    const numSamples = tileShape[0];\n    for (let sampleI = 0; sampleI < numSamples; sampleI++) {\n      for (const chunk of chunks) {\n        const chunkData = chunk.data[sampleI];\n        fullTileArray.set(chunkData, offset);\n        offset += chunkData.length;\n      }\n    }\n  }\n  \n  return fullTileArray;\n}\n\nconst ZarrMultivecDataFetcher = function ZarrMultivecDataFetcher(HGC, ...args) {\n\n  if (!new.target) {\n        throw new Error(\n          'Uncaught TypeError: Class constructor cannot be invoked without \"new\"',\n        );\n    }\n\n    const { slugid } = HGC.libraries;\n    const {\n      absToChr,\n      parseChromsizesRows,\n      genomicRangeToChromosomeChunks,\n      DenseDataExtrema1D,\n      minNonZero,\n      maxNonZero,\n    } = HGC.utils;\n\n    class ZarrMultivecDataFetcherClass {\n        constructor(dataConfig) {\n            this.dataConfig = dataConfig;\n            this.trackUid = slugid.nice();\n        \n            if (dataConfig.url) {\n              // console.assert(dataConfig.url.endsWith('.zarr'));\n              // S3 bucket must have a CORS policy to allow reading from any origin.\n              this.store = new HTTPStore(dataConfig.url, { supportedMethods: ['GET'] });\n            }\n\n            if(dataConfig.row !== undefined) {\n              this.row = dataConfig.row;\n            }\n        }\n\n        tilesetInfo(callback) {\n            this.tilesetInfoLoading = true;\n        \n            // Use the tileset_info stored as JSON in file.zarr/.zattrs\n            return this.store\n              .getItem('.zattrs')\n              .then(bytes => {\n                const decoder = new TextDecoder('utf-8');\n                const json = JSON.parse(decoder.decode(bytes));\n                return json;\n              })\n              .then(attrs => {\n                this.tilesetInfoLoading = false;\n\n                const chromSizes = attrs.multiscales.map(d => ([d.name, d.metadata.chromsize]));\n                \n                const finalChrom = attrs.multiscales[attrs.multiscales.length - 1];\n                const maxPos = finalChrom.metadata.chromoffset + finalChrom.metadata.chromsize;\n                const tileSize = attrs.shape[1];\n                const retVal = {\n                  ...attrs,\n                  shape: [attrs.shape[1], attrs.shape[0]],\n                  chromSizes,\n                  tile_size: tileSize,\n                  max_width: maxPos,\n                  min_pos: [0],\n                  max_pos: [maxPos],\n                  max_zoom: Math.ceil(Math.log(maxPos / tileSize) / Math.log(2)),\n                };\n        \n                if (callback) {\n                  callback(retVal);\n                }\n        \n                return retVal;\n              })\n              .catch(err => {\n                this.tilesetInfoLoading = false;\n        \n                if (callback) {\n                  callback({\n                    error: `Error parsing zarr multivec: ${err}`,\n                  });\n                }\n              });\n          }\n        \n          fetchTilesDebounced(receivedTiles, tileIds) {\n            const tiles = {};\n        \n            const validTileIds = [];\n            const tilePromises = [];\n        \n            for (const tileId of tileIds) {\n              const parts = tileId.split('.');\n              const z = parseInt(parts[0], 10);\n              const x = parseInt(parts[1], 10);\n        \n              if (Number.isNaN(x) || Number.isNaN(z)) {\n                console.warn('Invalid tile zoom or position:', z, x);\n                continue;\n              }\n        \n              validTileIds.push(tileId);\n              tilePromises.push(this.tile(z, x, tileId));\n            }\n        \n            Promise.all(tilePromises).then(values => {\n              for (let i = 0; i < values.length; i++) {\n                const validTileId = validTileIds[i];\n                tiles[validTileId] = values[i];\n                tiles[validTileId].tilePositionId = validTileId;\n              }\n              receivedTiles(tiles);\n            });\n            return tiles;\n          }\n        \n          tile(z, x, tileId) {\n            const { store } = this;\n            return this.tilesetInfo().then(tsInfo => {\n              // const multiscales = tsInfo.multiscales;\n        \n              // Adapted from clodius.tiles.multivec.get_single_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L66\n        \n              // z is the index of the resolution that should be selected.\n              // Resolution is size of each bin (except for the last bin in each chromosome).\n              const resolution = +tsInfo.resolutions[z];\n              const tileSize = +tsInfo.tile_size;\n              const binSize = resolution;\n        \n              // Where in the data does the tile start and end?\n              const tileStart = x * tileSize * resolution;\n              const tileEnd = tileStart + tileSize * resolution;\n        \n              // chromSizes is an array of \"tuples\" [ [\"chr1\", 1000], ... ]\n              const chromSizes = tsInfo.chromSizes;\n        \n              // Adapted from clodius.tiles.multivec.get_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L110\n\n              const chromInfo = parseChromsizesRows(chromSizes);\n              const [chrStart, chrStartPos] = absToChr(tileStart, chromInfo);\n              const [chrEnd, chrEndPos] = absToChr(tileEnd, chromInfo);\n              const genomicStart = { chr: chrStart, pos: chrStartPos };\n              const genomicEnd = { chr: chrEnd, pos: chrEndPos };\n        \n              // Using the [genomicStart, genomicEnd] range, get an array of \"chromosome chunks\",\n              // where each chunk range starts and ends with the same chromosome.\n              // Start a new chromosome chunk at each chromosome boundary.\n              const chrChunks = genomicRangeToChromosomeChunks(\n                chromSizes,\n                genomicStart,\n                genomicEnd,\n                binSize,\n                tileSize,\n              );\n        \n              // Get the zarr data for each chromosome chunk,\n              // since data for each chromosome is stored in a separate zarr array.\n              return Promise.all(\n                chrChunks.map(([chrName, zStart, zEnd]) => {\n                  return openArray({\n                    store,\n                    path: `/chromosomes/${chrName}/${resolution}/`,\n                    mode: 'r',\n                  }).then(arr => (this.row !== undefined\n                    ? arr.getRaw([this.row, slice(zStart, zEnd)])\n                    : arr.get([null, slice(zStart, zEnd)])\n                  ));\n                }),\n              ).then(chunks => {\n                const dense = multivecChunksToTileDenseArray(chunks, [tsInfo.shape[1], tsInfo.shape[0]], this.row !== undefined);\n                return Promise.resolve({\n                  dense,\n                  denseDataExtrema: new DenseDataExtrema1D(dense),\n                  dtype: 'float32',\n                  min_value: Math.min.apply(null, dense),\n                  max_value: Math.max.apply(null, dense),\n                  minNonZero: minNonZero(dense),\n                  maxNonZero: maxNonZero(dense),\n                  server: null,\n                  size: 1,\n                  shape: tsInfo.shape,\n                  tileId,\n                  tilePos: [x],\n                  tilePositionId: tileId,\n                  tilesetUid: null,\n                  zoomLevel: z,\n                });\n              });\n            });\n        }\n    } // end class\n    return new ZarrMultivecDataFetcherClass(...args);\n} // end function wrapper\n\n\nZarrMultivecDataFetcher.config = {\n    type: 'zarr-multivec',\n};\n\nexport default ZarrMultivecDataFetcher;\n"]},"metadata":{},"sourceType":"module"}