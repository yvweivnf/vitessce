{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { assert, log } from '@luma.gl/webgl';\nimport { Matrix4, Quaternion } from '@math.gl/core';\nexport var ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    var ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    var components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    var length = components * accessor.count;\n    var _accessor$bufferView$ = accessor.bufferView.data,\n        buffer = _accessor$bufferView$.buffer,\n        byteOffset = _accessor$bufferView$.byteOffset;\n    var array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      var slicedArray = [];\n\n      for (var i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\nvar helperMatrix = new Matrix4();\n\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    var rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nvar quaternion = new Quaternion();\n\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    quaternion.slerp({\n      start: start,\n      target: stop,\n      ratio: ratio\n    });\n\n    for (var i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    for (var _i = 0; _i < start.length; _i++) {\n      target[path][_i] = ratio * stop[_i] + (1 - ratio) * start[_i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, _ref) {\n  var p0 = _ref.p0,\n      outTangent0 = _ref.outTangent0,\n      inTangent1 = _ref.inTangent1,\n      p1 = _ref.p1,\n      tDiff = _ref.tDiff,\n      t = _ref.ratio;\n\n  for (var i = 0; i < target[path].length; i++) {\n    var m0 = outTangent0[i] * tDiff;\n    var m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (var i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, _ref2, target, path) {\n  var input = _ref2.input,\n      interpolation = _ref2.interpolation,\n      output = _ref2.output;\n  var maxTime = input[input.length - 1];\n  var animationTime = time % maxTime;\n  var nextIndex = input.findIndex(function (t) {\n    return t >= animationTime;\n  });\n  var previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(\"Bad animation path \".concat(path))();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  var previousTime = input[previousIndex];\n  var nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        var ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        var _ratio = (animationTime - previousTime) / (nextTime - previousTime);\n\n        var tDiff = nextTime - previousTime;\n        var p0 = output[3 * previousIndex + 1];\n        var outTangent0 = output[3 * previousIndex + 2];\n        var inTangent1 = output[3 * nextIndex + 0];\n        var p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0: p0,\n          outTangent0: outTangent0,\n          inTangent1: inTangent1,\n          p1: p1,\n          tDiff: tDiff,\n          ratio: _ratio\n        });\n      }\n\n      break;\n\n    default:\n      log.warn(\"Interpolation \".concat(interpolation, \" not supported\"))();\n      break;\n  }\n}\n\nvar GLTFAnimation = /*#__PURE__*/function () {\n  function GLTFAnimation(props) {\n    _classCallCheck(this, GLTFAnimation);\n\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n    Object.assign(this, props);\n  }\n\n  _createClass(GLTFAnimation, [{\n    key: \"animate\",\n    value: function animate(timeMs) {\n      if (!this.playing) {\n        return;\n      }\n\n      var absTime = timeMs / 1000;\n      var time = (absTime - this.startTime) * this.speed;\n      this.channels.forEach(function (_ref3) {\n        var sampler = _ref3.sampler,\n            target = _ref3.target,\n            path = _ref3.path;\n        interpolate(time, sampler, target, path);\n        applyTranslationRotationScale(target, target._node);\n      });\n    }\n  }]);\n\n  return GLTFAnimation;\n}();\n\nvar GLTFAnimator = /*#__PURE__*/function () {\n  function GLTFAnimator(gltf) {\n    _classCallCheck(this, GLTFAnimator);\n\n    this.animations = gltf.animations.map(function (animation, index) {\n      var name = animation.name || \"Animation-\".concat(index);\n      var samplers = animation.samplers.map(function (_ref4) {\n        var input = _ref4.input,\n            _ref4$interpolation = _ref4.interpolation,\n            interpolation = _ref4$interpolation === void 0 ? 'LINEAR' : _ref4$interpolation,\n            output = _ref4.output;\n        return {\n          input: accessorToJsArray(gltf.accessors[input]),\n          interpolation: interpolation,\n          output: accessorToJsArray(gltf.accessors[output])\n        };\n      });\n      var channels = animation.channels.map(function (_ref5) {\n        var sampler = _ref5.sampler,\n            target = _ref5.target;\n        return {\n          sampler: samplers[sampler],\n          target: gltf.nodes[target.node],\n          path: target.path\n        };\n      });\n      return new GLTFAnimation({\n        name: name,\n        channels: channels\n      });\n    });\n  }\n\n  _createClass(GLTFAnimator, [{\n    key: \"animate\",\n    value: function animate(time) {\n      this.setTime(time);\n    }\n  }, {\n    key: \"setTime\",\n    value: function setTime(time) {\n      this.animations.forEach(function (animation) {\n        return animation.animate(time);\n      });\n    }\n  }, {\n    key: \"getAnimations\",\n    value: function getAnimations() {\n      return this.animations;\n    }\n  }]);\n\n  return GLTFAnimator;\n}();\n\nexport { GLTFAnimator as default };","map":{"version":3,"sources":["../../../src/gltf/gltf-animator.js"],"names":["ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","Float32Array","accessor","ArrayType","components","length","byteOffset","array","Array","slicedArray","i","helperMatrix","node","gltfNode","rotationMatrix","quaternion","path","start","target","ratio","stop","t","m0","outTangent0","m1","inTangent1","Math","p0","p1","value","output","maxTime","input","animationTime","time","nextIndex","previousIndex","log","assert","previousTime","nextTime","stepInterpolate","linearInterpolate","tDiff","cubicsplineInterpolate","constructor","Object","absTime","timeMs","interpolate","applyTranslationRotationScale","name","animation","samplers","interpolation","accessorToJsArray","gltf","channels","sampler"],"mappings":"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","sourcesContent":["import {assert, log} from '@luma.gl/webgl';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}