{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Stats } from '@probe.gl/stats';\nimport { RequestScheduler, assert, path } from '@loaders.gl/loader-utils';\nimport TilesetCache from './tileset-cache';\nimport { calculateTransformProps } from './helpers/transform-utils';\nimport { getFrameState } from './helpers/frame-state';\nimport { getZoomFromBoundingVolume } from './helpers/zoom';\nimport Tile3D from './tile-3d';\nimport Tileset3DTraverser from './traversers/tileset-3d-traverser';\nimport TilesetTraverser from './traversers/tileset-traverser';\nimport I3SetTraverser from './traversers/i3s-tileset-traverser';\nimport { TILESET_TYPE } from '../constants';\nvar DEFAULT_PROPS = {\n  description: '',\n  ellipsoid: Ellipsoid.WGS84,\n  modelMatrix: new Matrix4(),\n  throttleRequests: true,\n  maxRequests: 64,\n  maximumMemoryUsage: 32,\n  onTileLoad: function onTileLoad() {},\n  onTileUnload: function onTileUnload() {},\n  onTileError: function onTileError() {},\n  onTraversalComplete: function onTraversalComplete(selectedTiles) {\n    return selectedTiles;\n  },\n  contentLoader: undefined,\n  viewDistanceScale: 1.0,\n  maximumScreenSpaceError: 8,\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: '',\n  i3s: {}\n};\nvar TILES_TOTAL = 'Tiles In Tileset(s)';\nvar TILES_IN_MEMORY = 'Tiles In Memory';\nvar TILES_IN_VIEW = 'Tiles In View';\nvar TILES_RENDERABLE = 'Tiles To Render';\nvar TILES_LOADED = 'Tiles Loaded';\nvar TILES_LOADING = 'Tiles Loading';\nvar TILES_UNLOADED = 'Tiles Unloaded';\nvar TILES_LOAD_FAILED = 'Failed Tile Loads';\nvar POINTS_COUNT = 'Points';\nvar TILES_GPU_MEMORY = 'Tile Memory Use';\n\nvar Tileset3D = /*#__PURE__*/function () {\n  function Tileset3D(json, options) {\n    _classCallCheck(this, Tileset3D);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"loadOptions\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"tileset\", void 0);\n\n    _defineProperty(this, \"loader\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"basePath\", void 0);\n\n    _defineProperty(this, \"modelMatrix\", void 0);\n\n    _defineProperty(this, \"ellipsoid\", void 0);\n\n    _defineProperty(this, \"lodMetricType\", void 0);\n\n    _defineProperty(this, \"lodMetricValue\", void 0);\n\n    _defineProperty(this, \"refine\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"roots\", void 0);\n\n    _defineProperty(this, \"asset\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"extras\", void 0);\n\n    _defineProperty(this, \"attributions\", void 0);\n\n    _defineProperty(this, \"credits\", void 0);\n\n    _defineProperty(this, \"stats\", void 0);\n\n    _defineProperty(this, \"traverseCounter\", void 0);\n\n    _defineProperty(this, \"geometricError\", void 0);\n\n    _defineProperty(this, \"selectedTiles\", void 0);\n\n    _defineProperty(this, \"cartographicCenter\", void 0);\n\n    _defineProperty(this, \"cartesianCenter\", void 0);\n\n    _defineProperty(this, \"zoom\", void 0);\n\n    _defineProperty(this, \"boundingVolume\", void 0);\n\n    _defineProperty(this, \"gpuMemoryUsageInBytes\", void 0);\n\n    _defineProperty(this, \"dynamicScreenSpaceErrorComputedDensity\", void 0);\n\n    _defineProperty(this, \"_traverser\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    _defineProperty(this, \"_requestScheduler\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    _defineProperty(this, \"_queryParamsString\", void 0);\n\n    _defineProperty(this, \"_queryParams\", void 0);\n\n    _defineProperty(this, \"_extensionsUsed\", void 0);\n\n    _defineProperty(this, \"_tiles\", void 0);\n\n    _defineProperty(this, \"_pendingCount\", void 0);\n\n    _defineProperty(this, \"lastUpdatedVieports\", void 0);\n\n    _defineProperty(this, \"_requestedTiles\", void 0);\n\n    _defineProperty(this, \"_emptyTiles\", void 0);\n\n    _defineProperty(this, \"frameStateData\", void 0);\n\n    _defineProperty(this, \"maximumMemoryUsage\", void 0);\n\n    assert(json);\n    this.options = _objectSpread({}, DEFAULT_PROPS, {}, options);\n    this.tileset = json;\n    this.loader = json.loader;\n    this.type = json.type;\n    this.url = json.url;\n    this.basePath = json.basePath || path.dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n    this.lodMetricType = json.lodMetricType;\n    this.lodMetricValue = json.lodMetricValue;\n    this.refine = json.root.refine;\n    this.loadOptions = this.options.loadOptions || {};\n    this.root = null;\n    this.roots = {};\n    this.cartographicCenter = null;\n    this.cartesianCenter = null;\n    this.zoom = 1;\n    this.boundingVolume = null;\n    this.traverseCounter = 0;\n    this.geometricError = 0;\n    this._traverser = this._initializeTraverser();\n    this._cache = new TilesetCache();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    this._frameNumber = 0;\n    this._pendingCount = 0;\n    this._tiles = {};\n    this.selectedTiles = [];\n    this._emptyTiles = [];\n    this._requestedTiles = [];\n    this.frameStateData = {};\n    this.lastUpdatedVieports = null;\n    this._queryParams = {};\n    this._queryParamsString = '';\n    this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;\n    this.gpuMemoryUsageInBytes = 0;\n    this.stats = new Stats({\n      id: this.url\n    });\n\n    this._initializeStats();\n\n    this._extensionsUsed = undefined;\n    this.dynamicScreenSpaceErrorComputedDensity = 0.0;\n    this.extras = null;\n    this.asset = {};\n    this.credits = {};\n    this.description = this.options.description || '';\n\n    this._initializeTileSet(json);\n  }\n\n  _createClass(Tileset3D, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._destroy();\n    }\n  }, {\n    key: \"isLoaded\",\n    value: function isLoaded() {\n      return this._pendingCount === 0 && this._frameNumber !== 0;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this.options = _objectSpread({}, this.options, {}, props);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = _objectSpread({}, this.options, {}, options);\n    }\n  }, {\n    key: \"getTileUrl\",\n    value: function getTileUrl(tilePath) {\n      var isDataUrl = tilePath.startsWith('data:');\n\n      if (isDataUrl) {\n        return tilePath;\n      }\n\n      return \"\".concat(tilePath).concat(this.queryParams);\n    }\n  }, {\n    key: \"hasExtension\",\n    value: function hasExtension(extensionName) {\n      return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);\n    }\n  }, {\n    key: \"update\",\n    value: function update(viewports) {\n      if ('loadTiles' in this.options && !this.options.loadTiles) {\n        return;\n      }\n\n      if (this.traverseCounter > 0) {\n        return;\n      }\n\n      if (!viewports && this.lastUpdatedVieports) {\n        viewports = this.lastUpdatedVieports;\n      } else {\n        this.lastUpdatedVieports = viewports;\n      }\n\n      if (!(viewports instanceof Array)) {\n        viewports = [viewports];\n      }\n\n      this._cache.reset();\n\n      this._frameNumber++;\n      this.traverseCounter = viewports.length;\n      var viewportsToTraverse = [];\n\n      var _iterator = _createForOfIteratorHelper(viewports),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var viewport = _step.value;\n          var id = viewport.id;\n\n          if (this._needTraverse(id)) {\n            viewportsToTraverse.push(id);\n          } else {\n            this.traverseCounter--;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(viewports),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _viewport = _step2.value;\n          var _id = _viewport.id;\n\n          if (!this.roots[_id]) {\n            this.roots[_id] = this._initializeTileHeaders(this.tileset, null);\n          }\n\n          if (!viewportsToTraverse.includes(_id)) {\n            continue;\n          }\n\n          var frameState = getFrameState(_viewport, this._frameNumber);\n\n          this._traverser.traverse(this.roots[_id], frameState, this.options);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_needTraverse\",\n    value: function _needTraverse(viewportId) {\n      var traverserId = viewportId;\n\n      if (this.options.viewportTraversersMap) {\n        traverserId = this.options.viewportTraversersMap[viewportId];\n      }\n\n      if (traverserId !== viewportId) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_onTraversalEnd\",\n    value: function _onTraversalEnd(frameState) {\n      var id = frameState.viewport.id;\n\n      if (!this.frameStateData[id]) {\n        this.frameStateData[id] = {\n          selectedTiles: [],\n          _requestedTiles: [],\n          _emptyTiles: []\n        };\n      }\n\n      var currentFrameStateData = this.frameStateData[id];\n      var selectedTiles = Object.values(this._traverser.selectedTiles);\n      currentFrameStateData.selectedTiles = selectedTiles;\n      currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n      currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n      this.traverseCounter--;\n\n      if (this.traverseCounter > 0) {\n        return;\n      }\n\n      this._updateTiles();\n    }\n  }, {\n    key: \"_updateTiles\",\n    value: function _updateTiles() {\n      this.selectedTiles = [];\n      this._requestedTiles = [];\n      this._emptyTiles = [];\n\n      for (var frameStateKey in this.frameStateData) {\n        var frameStateDataValue = this.frameStateData[frameStateKey];\n        this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n        this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n        this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n      }\n\n      this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n      var _iterator3 = _createForOfIteratorHelper(this.selectedTiles),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var tile = _step3.value;\n          this._tiles[tile.id] = tile;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this._loadTiles();\n\n      this._unloadTiles();\n\n      this._updateStats();\n    }\n  }, {\n    key: \"_tilesChanged\",\n    value: function _tilesChanged(oldSelectedTiles, selectedTiles) {\n      if (oldSelectedTiles.length !== selectedTiles.length) {\n        return true;\n      }\n\n      var set1 = new Set(oldSelectedTiles.map(function (t) {\n        return t.id;\n      }));\n      var set2 = new Set(selectedTiles.map(function (t) {\n        return t.id;\n      }));\n      var changed = oldSelectedTiles.filter(function (x) {\n        return !set2.has(x.id);\n      }).length > 0;\n      changed = changed || selectedTiles.filter(function (x) {\n        return !set1.has(x.id);\n      }).length > 0;\n      return changed;\n    }\n  }, {\n    key: \"_loadTiles\",\n    value: function _loadTiles() {\n      var _iterator4 = _createForOfIteratorHelper(this._requestedTiles),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var tile = _step4.value;\n\n          if (tile.contentUnloaded) {\n            this._loadTile(tile);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_unloadTiles\",\n    value: function _unloadTiles() {\n      this._cache.unloadTiles(this, function (tileset, tile) {\n        return tileset._unloadTile(tile);\n      });\n    }\n  }, {\n    key: \"_updateStats\",\n    value: function _updateStats() {\n      var tilesRenderable = 0;\n      var pointsRenderable = 0;\n\n      var _iterator5 = _createForOfIteratorHelper(this.selectedTiles),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var tile = _step5.value;\n\n          if (tile.contentAvailable && tile.content) {\n            tilesRenderable++;\n\n            if (tile.content.pointCount) {\n              pointsRenderable += tile.content.pointCount;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n      this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n      this.stats.get(POINTS_COUNT).count = pointsRenderable;\n    }\n  }, {\n    key: \"_initializeTileSet\",\n    value: function _initializeTileSet(tilesetJson) {\n      this.root = this._initializeTileHeaders(tilesetJson, null);\n\n      if (this.type === TILESET_TYPE.TILES3D) {\n        this._initializeCesiumTileset(tilesetJson);\n      }\n\n      if (this.type === TILESET_TYPE.I3S) {\n        this._initializeI3STileset();\n      }\n\n      this._calculateViewProps();\n    }\n  }, {\n    key: \"_calculateViewProps\",\n    value: function _calculateViewProps() {\n      var root = this.root;\n      assert(root);\n      var center = root.boundingVolume.center;\n\n      if (!center) {\n        console.warn('center was not pre-calculated for the root tile');\n        this.cartographicCenter = new Vector3();\n        this.zoom = 1;\n        return;\n      }\n\n      this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());\n      this.cartesianCenter = center;\n      this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n    }\n  }, {\n    key: \"_initializeStats\",\n    value: function _initializeStats() {\n      this.stats.get(TILES_TOTAL);\n      this.stats.get(TILES_LOADING);\n      this.stats.get(TILES_IN_MEMORY);\n      this.stats.get(TILES_IN_VIEW);\n      this.stats.get(TILES_RENDERABLE);\n      this.stats.get(TILES_LOADED);\n      this.stats.get(TILES_UNLOADED);\n      this.stats.get(TILES_LOAD_FAILED);\n      this.stats.get(POINTS_COUNT, 'memory');\n      this.stats.get(TILES_GPU_MEMORY, 'memory');\n    }\n  }, {\n    key: \"_initializeTileHeaders\",\n    value: function _initializeTileHeaders(tilesetJson, parentTileHeader) {\n      var rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);\n\n      if (parentTileHeader) {\n        parentTileHeader.children.push(rootTile);\n        rootTile.depth = parentTileHeader.depth + 1;\n      }\n\n      if (this.type === TILESET_TYPE.TILES3D) {\n        var stack = [];\n        stack.push(rootTile);\n\n        while (stack.length > 0) {\n          var tile = stack.pop();\n          this.stats.get(TILES_TOTAL).incrementCount();\n          var children = tile.header.children || [];\n\n          var _iterator6 = _createForOfIteratorHelper(children),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var childHeader = _step6.value;\n              var childTile = new Tile3D(this, childHeader, tile);\n              tile.children.push(childTile);\n              childTile.depth = tile.depth + 1;\n              stack.push(childTile);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      }\n\n      return rootTile;\n    }\n  }, {\n    key: \"_initializeTraverser\",\n    value: function _initializeTraverser() {\n      var TraverserClass;\n      var type = this.type;\n\n      switch (type) {\n        case TILESET_TYPE.TILES3D:\n          TraverserClass = Tileset3DTraverser;\n          break;\n\n        case TILESET_TYPE.I3S:\n          TraverserClass = I3SetTraverser;\n          break;\n\n        default:\n          TraverserClass = TilesetTraverser;\n      }\n\n      return new TraverserClass({\n        basePath: this.basePath,\n        onTraversalEnd: this._onTraversalEnd.bind(this)\n      });\n    }\n  }, {\n    key: \"_destroyTileHeaders\",\n    value: function _destroyTileHeaders(parentTile) {\n      this._destroySubtree(parentTile);\n    }\n  }, {\n    key: \"_loadTile\",\n    value: function () {\n      var _loadTile2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tile) {\n        var loaded;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n\n                this._onStartTileLoading();\n\n                _context.next = 4;\n                return tile.loadContent();\n\n              case 4:\n                loaded = _context.sent;\n                _context.next = 10;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](0);\n\n                this._onTileLoadError(tile, _context.t0);\n\n              case 10:\n                _context.prev = 10;\n\n                this._onEndTileLoading();\n\n                this._onTileLoad(tile, loaded);\n\n                return _context.finish(10);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 7, 10, 14]]);\n      }));\n\n      function _loadTile(_x) {\n        return _loadTile2.apply(this, arguments);\n      }\n\n      return _loadTile;\n    }()\n  }, {\n    key: \"_onTileLoadError\",\n    value: function _onTileLoadError(tile, error) {\n      this.stats.get(TILES_LOAD_FAILED).incrementCount();\n      var message = error.message || error.toString();\n      var url = tile.url;\n      console.error(\"A 3D tile failed to load: \".concat(tile.url, \" \").concat(message));\n      this.options.onTileError(tile, message, url);\n    }\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tile, loaded) {\n      if (!loaded) {\n        return;\n      }\n\n      if (tile && tile.content) {\n        calculateTransformProps(tile, tile.content);\n      }\n\n      this._addTileToCache(tile);\n\n      this.options.onTileLoad(tile);\n    }\n  }, {\n    key: \"_onStartTileLoading\",\n    value: function _onStartTileLoading() {\n      this._pendingCount++;\n      this.stats.get(TILES_LOADING).incrementCount();\n    }\n  }, {\n    key: \"_onEndTileLoading\",\n    value: function _onEndTileLoading() {\n      this._pendingCount--;\n      this.stats.get(TILES_LOADING).decrementCount();\n    }\n  }, {\n    key: \"_addTileToCache\",\n    value: function _addTileToCache(tile) {\n      this._cache.add(this, tile, function (tileset) {\n        return tileset._updateCacheStats(tile);\n      });\n    }\n  }, {\n    key: \"_updateCacheStats\",\n    value: function _updateCacheStats(tile) {\n      this.stats.get(TILES_LOADED).incrementCount();\n      this.stats.get(TILES_IN_MEMORY).incrementCount();\n      this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;\n      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    }\n  }, {\n    key: \"_unloadTile\",\n    value: function _unloadTile(tile) {\n      this.gpuMemoryUsageInBytes -= tile.content && tile.content.byteLength || 0;\n      this.stats.get(TILES_IN_MEMORY).decrementCount();\n      this.stats.get(TILES_UNLOADED).incrementCount();\n      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n      this.options.onTileUnload(tile);\n      tile.unloadContent();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      var stack = [];\n\n      if (this.root) {\n        stack.push(this.root);\n      }\n\n      while (stack.length > 0) {\n        var tile = stack.pop();\n\n        var _iterator7 = _createForOfIteratorHelper(tile.children),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var child = _step7.value;\n            stack.push(child);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        this._destroyTile(tile);\n      }\n\n      this.root = null;\n    }\n  }, {\n    key: \"_destroySubtree\",\n    value: function _destroySubtree(tile) {\n      var root = tile;\n      var stack = [];\n      stack.push(root);\n\n      while (stack.length > 0) {\n        tile = stack.pop();\n\n        var _iterator8 = _createForOfIteratorHelper(tile.children),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var child = _step8.value;\n            stack.push(child);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        if (tile !== root) {\n          this._destroyTile(tile);\n        }\n      }\n\n      root.children = [];\n    }\n  }, {\n    key: \"_destroyTile\",\n    value: function _destroyTile(tile) {\n      this._cache.unloadTile(this, tile);\n\n      this._unloadTile(tile);\n\n      tile.destroy();\n    }\n  }, {\n    key: \"_initializeCesiumTileset\",\n    value: function _initializeCesiumTileset(tilesetJson) {\n      this.asset = tilesetJson.asset;\n\n      if (!this.asset) {\n        throw new Error('Tileset must have an asset property.');\n      }\n\n      if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {\n        throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');\n      }\n\n      if ('tilesetVersion' in this.asset) {\n        this._queryParams.v = this.asset.tilesetVersion;\n      }\n\n      this.credits = {\n        attributions: this.options.attributions || []\n      };\n      this.description = this.options.description || '';\n      this.properties = tilesetJson.properties;\n      this.geometricError = tilesetJson.geometricError;\n      this._extensionsUsed = tilesetJson.extensionsUsed;\n      this.extras = tilesetJson.extras;\n    }\n  }, {\n    key: \"_initializeI3STileset\",\n    value: function _initializeI3STileset() {\n      if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n        this._queryParams.token = this.loadOptions.i3s.token;\n      }\n    }\n  }, {\n    key: \"tiles\",\n    get: function get() {\n      return Object.values(this._tiles);\n    }\n  }, {\n    key: \"frameNumber\",\n    get: function get() {\n      return this._frameNumber;\n    }\n  }, {\n    key: \"queryParams\",\n    get: function get() {\n      if (!this._queryParamsString) {\n        this._queryParamsString = getQueryParamString(this._queryParams);\n      }\n\n      return this._queryParamsString;\n    }\n  }]);\n\n  return Tileset3D;\n}();\n\nexport { Tileset3D as default };\n\nfunction getQueryParamString(queryParams) {\n  var queryParamStrings = [];\n\n  for (var _i = 0, _Object$keys = Object.keys(queryParams); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    queryParamStrings.push(\"\".concat(key, \"=\").concat(queryParams[key]));\n  }\n\n  switch (queryParamStrings.length) {\n    case 0:\n      return '';\n\n    case 1:\n      return \"?\".concat(queryParamStrings[0]);\n\n    default:\n      return \"?\".concat(queryParamStrings.join('&'));\n  }\n}","map":{"version":3,"sources":["../../../src/tileset/tileset-3d.ts"],"names":["DEFAULT_PROPS","description","ellipsoid","Ellipsoid","modelMatrix","throttleRequests","maxRequests","maximumMemoryUsage","onTileLoad","onTileUnload","onTileError","onTraversalComplete","selectedTiles","contentLoader","viewDistanceScale","maximumScreenSpaceError","loadTiles","updateTransforms","viewportTraversersMap","loadOptions","fetch","attributions","basePath","i3s","TILES_TOTAL","TILES_IN_MEMORY","TILES_IN_VIEW","TILES_RENDERABLE","TILES_LOADED","TILES_LOADING","TILES_UNLOADED","TILES_LOAD_FAILED","POINTS_COUNT","TILES_GPU_MEMORY","constructor","assert","options","json","path","id","url","Object","getQueryParamString","props","isDataUrl","tilePath","Boolean","viewports","viewportsToTraverse","viewport","frameState","getFrameState","traverserId","_requestedTiles","_emptyTiles","currentFrameStateData","frameStateDataValue","tile","oldSelectedTiles","set1","t","set2","changed","x","tileset","tilesRenderable","pointsRenderable","TILESET_TYPE","root","center","console","getZoomFromBoundingVolume","rootTile","tilesetJson","parentTileHeader","stack","children","childTile","type","TraverserClass","onTraversalEnd","loaded","message","error","calculateTransformProps","queryParamStrings","key","queryParams"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/*\n\n  The Tileset loading and rendering flow is as below,\n  A rendered (i.e. deck.gl `Tile3DLayer`) triggers `tileset.update()` after a `tileset` is loaded\n  `tileset` starts traversing the tile tree and update `requestTiles` (tiles of which content need\n  to be fetched) and `selectedTiles` (tiles ready for rendering under the current viewport).\n  `Tile3DLayer` will update rendering based on `selectedTiles`.\n  `Tile3DLayer` also listens to `onTileLoad` callback and trigger another round of `update and then traversal`\n  when new tiles are loaded.\n\n  As I3S tileset have stored `tileHeader` file (metadata) and tile content files (geometry, texture, ...) separately.\n  During each traversal, it issues `tilHeader` requests if that `tileHeader` is not yet fetched,\n  after the tile header is fulfilled, it will resume the traversal starting from the tile just fetched (not root).\n\n  Tile3DLayer\n       |\n   await load(tileset)\n       |\n   tileset.update()\n       |                async load tileHeader\n   tileset.traverse() -------------------------- Queued\n       |        resume traversal after fetched  |\n       |----------------------------------------|\n       |\n       |                     async load tile content\n  tilset.requestedTiles  ----------------------------- RequestScheduler\n                                                              |\n  tilset.selectedTiles (ready for rendering)                  |\n       |         Listen to                                    |\n    Tile3DLayer ----------- onTileLoad  ----------------------|\n       |                         |   notify new tile is available\n    updateLayers                 |\n                        tileset.update // trigger another round of update\n*/\n\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {Stats} from '@probe.gl/stats';\nimport {\n  RequestScheduler,\n  assert,\n  path,\n  LoaderWithParser,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport TilesetCache from './tileset-cache';\nimport {calculateTransformProps} from './helpers/transform-utils';\nimport {FrameState, getFrameState} from './helpers/frame-state';\nimport {getZoomFromBoundingVolume} from './helpers/zoom';\nimport Tile3D from './tile-3d';\nimport Tileset3DTraverser from './traversers/tileset-3d-traverser';\nimport TilesetTraverser from './traversers/tileset-traverser';\nimport I3SetTraverser from './traversers/i3s-tileset-traverser';\nimport {TILESET_TYPE} from '../constants';\n\nexport type Tileset3DProps = {\n  // loading\n  throttleRequests?: boolean;\n  maxRequests?: number;\n  loadOptions?: LoaderOptions;\n  loadTiles?: boolean;\n  basePath?: string;\n  maximumMemoryUsage?: number;\n\n  // Metadata\n  description?: string;\n  attributions?: string[];\n\n  // Transforms\n  ellipsoid?: object;\n  modelMatrix?: Matrix4;\n\n  // Traversal\n  maximumScreenSpaceError?: number;\n  viewportTraversersMap?: any;\n  updateTransforms?: boolean;\n  viewDistanceScale?: number;\n\n  // Callbacks\n  onTileLoad?: (tile: Tile3D) => any;\n  onTileUnload?: (tile: Tile3D) => any;\n  onTileError?: (tile: Tile3D, message: string, url: string) => any;\n  contentLoader?: (tile: Tile3D) => Promise<void>;\n  onTraversalComplete?: (selectedTiles: Tile3D[]) => Tile3D[];\n};\n\ntype Props = {\n  description: string;\n  ellipsoid: object;\n  modelMatrix: Matrix4;\n  throttleRequests: boolean;\n  maximumMemoryUsage: number;\n  onTileLoad: (tile: Tile3D) => any;\n  onTileUnload: (tile: Tile3D) => any;\n  onTileError: (tile: Tile3D, message: string, url: string) => any;\n  onTraversalComplete: (selectedTiles: Tile3D[]) => Tile3D[];\n  maximumScreenSpaceError: number;\n  viewportTraversersMap: any;\n  attributions: string[];\n  maxRequests: number;\n  loadTiles: boolean;\n  loadOptions: LoaderOptions;\n  updateTransforms: boolean;\n  viewDistanceScale: number;\n  basePath: string;\n  contentLoader?: (tile: Tile3D) => Promise<void>;\n  i3s: {[key: string]: any};\n};\n\nconst DEFAULT_PROPS: Props = {\n  description: '',\n\n  ellipsoid: Ellipsoid.WGS84,\n  // A 4x4 transformation matrix this transforms the entire tileset.\n  modelMatrix: new Matrix4(),\n\n  // Set to false to disable network request throttling\n  throttleRequests: true,\n\n  // Number of simultaneous requsts, if throttleRequests is true\n  maxRequests: 64,\n\n  maximumMemoryUsage: 32,\n\n  /**\n   * Callback. Indicates this a tile's content was loaded\n   * @param tile {TileHeader}\n   */\n  onTileLoad: () => {},\n  /**\n   * Callback. Indicates this a tile's content was unloaded\n   * @param tile {TileHeader}\n   */\n  onTileUnload: () => {},\n  onTileError: () => {},\n  /**\n   * Callback. Allows post-process selectedTiles right after traversal.\n   * @param selectedTiles {TileHeader[]}\n   * @returns TileHeader[] - output array of tiles to return to deck.gl\n   */\n  onTraversalComplete: (selectedTiles: Tile3D[]) => selectedTiles,\n\n  // Optional async tile content loader\n  contentLoader: undefined,\n\n  // View distance scale modifier\n  viewDistanceScale: 1.0,\n\n  // TODO CESIUM\n  // The maximum screen space error used to drive level of detail refinement.\n  maximumScreenSpaceError: 8,\n\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n\n  loadOptions: {fetch: {}},\n\n  attributions: [],\n  basePath: '',\n\n  i3s: {}\n};\n\n// Tracked Stats\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\n\nexport default class Tileset3D {\n  // props: Tileset3DProps;\n  options: Props;\n  loadOptions: {[key: string]: any};\n\n  type: string;\n  tileset: {[key: string]: any};\n  loader: LoaderWithParser;\n  url: string;\n  basePath: string;\n  modelMatrix: Matrix4;\n  ellipsoid: any;\n  lodMetricType: string;\n  lodMetricValue: number;\n  refine: string;\n  root: Tile3D | null;\n  roots: {[key: string]: Tile3D};\n  asset: {[key: string]: any};\n\n  description: string;\n  properties: any;\n  extras: any;\n  attributions: any;\n  credits: any;\n\n  stats: Stats;\n\n  traverseCounter: number;\n  geometricError: number;\n  selectedTiles: Tile3D[];\n\n  cartographicCenter: Vector3 | null;\n  cartesianCenter: Vector3 | null;\n  zoom: number;\n  boundingVolume: any;\n\n  // METRICS\n  // The maximum amount of GPU memory (in MB) that may be used to cache tiles.\n  // Tiles not in view are unloaded to enforce private\n  // The total amount of GPU memory in bytes used by the tileset.\n  gpuMemoryUsageInBytes: any;\n  dynamicScreenSpaceErrorComputedDensity: any;\n\n  // TRAVERSAL\n  _traverser: TilesetTraverser;\n  private _cache: TilesetCache;\n  _requestScheduler: RequestScheduler;\n\n  _frameNumber: number;\n  private _queryParamsString: string;\n  private _queryParams: any;\n  private _extensionsUsed: any;\n  private _tiles: {[id: string]: Tile3D};\n\n  // counter for tracking tiles requests\n  private _pendingCount: any;\n\n  // HOLD TRAVERSAL RESULTS\n  private lastUpdatedVieports: any[] | null;\n  private _requestedTiles: any;\n  private _emptyTiles: any;\n  private frameStateData: any;\n\n  maximumMemoryUsage: number;\n\n  /**\n   * Create a new Tileset3D\n   * @param json\n   * @param props\n   */\n  // eslint-disable-next-line max-statements\n  constructor(json: any, options?: Tileset3DProps) {\n    assert(json);\n\n    // PUBLIC MEMBERS\n    this.options = {...DEFAULT_PROPS, ...options};\n    // raw data\n    this.tileset = json;\n    this.loader = json.loader;\n    // could be  3d tiles, i3s\n    this.type = json.type;\n    // The url to a tileset JSON file.\n    this.url = json.url;\n    this.basePath = json.basePath || path.dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n\n    // Geometric error when the tree is not rendered at all\n    this.lodMetricType = json.lodMetricType;\n    this.lodMetricValue = json.lodMetricValue;\n    this.refine = json.root.refine;\n\n    this.loadOptions = this.options.loadOptions || {};\n\n    this.root = null;\n    this.roots = {};\n    // view props\n    this.cartographicCenter = null;\n    this.cartesianCenter = null;\n    this.zoom = 1;\n    this.boundingVolume = null;\n\n    // TRAVERSAL\n    this.traverseCounter = 0;\n    this.geometricError = 0;\n    this._traverser = this._initializeTraverser();\n    this._cache = new TilesetCache();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    // update tracker\n    // increase in each update cycle\n    this._frameNumber = 0;\n\n    // counter for tracking tiles requests\n    this._pendingCount = 0;\n\n    // HOLD TRAVERSAL RESULTS\n    this._tiles = {};\n    this.selectedTiles = [];\n    this._emptyTiles = [];\n    this._requestedTiles = [];\n    this.frameStateData = {};\n    this.lastUpdatedVieports = null;\n\n    this._queryParams = {};\n    this._queryParamsString = '';\n\n    // METRICS\n    // The maximum amount of GPU memory (in MB) that may be used to cache tiles.\n    // Tiles not in view are unloaded to enforce this.\n    this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;\n    // The total amount of GPU memory in bytes used by the tileset.\n    this.gpuMemoryUsageInBytes = 0;\n    this.stats = new Stats({id: this.url});\n    this._initializeStats();\n\n    // EXTRACTED FROM TILESET\n    this._extensionsUsed = undefined;\n    this.dynamicScreenSpaceErrorComputedDensity = 0.0; // Updated based on the camera position and direction\n    // Metadata for the entire tileset\n    this.extras = null;\n    this.asset = {};\n    this.credits = {};\n    this.description = this.options.description || '';\n\n    this._initializeTileSet(json);\n  }\n\n  /** Release resources */\n  destroy(): void {\n    this._destroy();\n  }\n\n  /** Is the tileset loaded (update needs to have been called at least once) */\n  isLoaded(): boolean {\n    // Check that `_frameNumber !== 0` which means that update was called at least once\n    return this._pendingCount === 0 && this._frameNumber !== 0;\n  }\n\n  get tiles(): object[] {\n    return Object.values(this._tiles);\n  }\n\n  get frameNumber(): number {\n    return this._frameNumber;\n  }\n\n  get queryParams(): string {\n    if (!this._queryParamsString) {\n      this._queryParamsString = getQueryParamString(this._queryParams);\n    }\n    return this._queryParamsString;\n  }\n\n  setProps(props: Tileset3DProps): void {\n    this.options = {...this.options, ...props};\n  }\n\n  /** @deprecated */\n  setOptions(options: Tileset3DProps): void {\n    this.options = {...this.options, ...options};\n  }\n\n  /**\n   * Return a loadable tile url for a specific tile subpath\n   * @param tilePath a tile subpath\n   */\n  getTileUrl(tilePath: string): string {\n    const isDataUrl = tilePath.startsWith('data:');\n    if (isDataUrl) {\n      return tilePath;\n    }\n    return `${tilePath}${this.queryParams}`;\n  }\n\n  // TODO CESIUM specific\n  hasExtension(extensionName: string): boolean {\n    return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);\n  }\n\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports - list of viewports\n   */\n  // eslint-disable-next-line max-statements, complexity\n  update(viewports: any[]): void {\n    if ('loadTiles' in this.options && !this.options.loadTiles) {\n      return;\n    }\n    if (this.traverseCounter > 0) {\n      return;\n    }\n    if (!viewports && this.lastUpdatedVieports) {\n      viewports = this.lastUpdatedVieports;\n    } else {\n      this.lastUpdatedVieports = viewports;\n    }\n    if (!(viewports instanceof Array)) {\n      viewports = [viewports];\n    }\n\n    this._cache.reset();\n    this._frameNumber++;\n    this.traverseCounter = viewports.length;\n    const viewportsToTraverse: string[] = [];\n    // First loop to decrement traverseCounter\n    for (const viewport of viewports) {\n      const id = viewport.id as string;\n      if (this._needTraverse(id)) {\n        viewportsToTraverse.push(id);\n      } else {\n        this.traverseCounter--;\n      }\n    }\n\n    // Second loop to traverse\n    for (const viewport of viewports) {\n      const id = viewport.id as string;\n      if (!this.roots[id]) {\n        this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n      }\n\n      if (!viewportsToTraverse.includes(id)) {\n        continue; // eslint-disable-line no-continue\n      }\n      const frameState = getFrameState(viewport, this._frameNumber);\n      this._traverser.traverse(this.roots[id], frameState, this.options);\n    }\n  }\n\n  /**\n   * Check if traversal is needed for particular viewport\n   * @param {string} viewportId - id of a viewport\n   * @return {boolean}\n   */\n  _needTraverse(viewportId: string): boolean {\n    let traverserId = viewportId;\n    if (this.options.viewportTraversersMap) {\n      traverserId = this.options.viewportTraversersMap[viewportId];\n    }\n    if (traverserId !== viewportId) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * The callback to post-process tiles after traversal procedure\n   * @param frameState - frame state for tile culling\n   */\n  _onTraversalEnd(frameState: FrameState): void {\n    const id = frameState.viewport.id;\n    if (!this.frameStateData[id]) {\n      this.frameStateData[id] = {selectedTiles: [], _requestedTiles: [], _emptyTiles: []};\n    }\n    const currentFrameStateData = this.frameStateData[id];\n    const selectedTiles = Object.values(this._traverser.selectedTiles);\n    currentFrameStateData.selectedTiles = selectedTiles;\n    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n\n    this.traverseCounter--;\n    if (this.traverseCounter > 0) {\n      return;\n    }\n\n    this._updateTiles();\n  }\n\n  /**\n   * Update tiles relying on data from all traversers\n   */\n  _updateTiles(): void {\n    this.selectedTiles = [];\n    this._requestedTiles = [];\n    this._emptyTiles = [];\n\n    for (const frameStateKey in this.frameStateData) {\n      const frameStateDataValue = this.frameStateData[frameStateKey];\n      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n    }\n\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n    for (const tile of this.selectedTiles) {\n      this._tiles[tile.id] = tile;\n    }\n\n    this._loadTiles();\n    this._unloadTiles();\n    this._updateStats();\n  }\n\n  _tilesChanged(oldSelectedTiles, selectedTiles) {\n    if (oldSelectedTiles.length !== selectedTiles.length) {\n      return true;\n    }\n    const set1 = new Set(oldSelectedTiles.map((t) => t.id));\n    const set2 = new Set(selectedTiles.map((t) => t.id));\n    let changed = oldSelectedTiles.filter((x) => !set2.has(x.id)).length > 0;\n    changed = changed || selectedTiles.filter((x) => !set1.has(x.id)).length > 0;\n    return changed;\n  }\n\n  _loadTiles() {\n    // Sort requests by priority before making any requests.\n    // This makes it less likely this requests will be cancelled after being issued.\n    // requestedTiles.sort((a, b) => a._priority - b._priority);\n    for (const tile of this._requestedTiles) {\n      if (tile.contentUnloaded) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._loadTile(tile);\n      }\n    }\n  }\n\n  _unloadTiles() {\n    // unload tiles from cache when hit maximumMemoryUsage\n    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n  }\n\n  _updateStats() {\n    let tilesRenderable = 0;\n    let pointsRenderable = 0;\n    for (const tile of this.selectedTiles) {\n      if (tile.contentAvailable && tile.content) {\n        tilesRenderable++;\n        if (tile.content.pointCount) {\n          pointsRenderable += tile.content.pointCount;\n        }\n      }\n    }\n\n    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n    this.stats.get(POINTS_COUNT).count = pointsRenderable;\n  }\n\n  _initializeTileSet(tilesetJson) {\n    this.root = this._initializeTileHeaders(tilesetJson, null);\n\n    // TODO CESIUM Specific\n    if (this.type === TILESET_TYPE.TILES3D) {\n      this._initializeCesiumTileset(tilesetJson);\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      this._initializeI3STileset();\n    }\n    // Calculate cartographicCenter & zoom props to help apps center view on tileset\n    this._calculateViewProps();\n  }\n\n  // Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n  _calculateViewProps() {\n    const root = this.root as Tile3D;\n    assert(root);\n    const {center} = root.boundingVolume;\n    // TODO - handle all cases\n    if (!center) {\n      // eslint-disable-next-line\n      console.warn('center was not pre-calculated for the root tile');\n      this.cartographicCenter = new Vector3();\n      this.zoom = 1;\n      return;\n    }\n    this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());\n    this.cartesianCenter = center;\n    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n  }\n\n  _initializeStats() {\n    this.stats.get(TILES_TOTAL);\n    this.stats.get(TILES_LOADING);\n    this.stats.get(TILES_IN_MEMORY);\n    this.stats.get(TILES_IN_VIEW);\n    this.stats.get(TILES_RENDERABLE);\n    this.stats.get(TILES_LOADED);\n    this.stats.get(TILES_UNLOADED);\n    this.stats.get(TILES_LOAD_FAILED);\n    this.stats.get(POINTS_COUNT, 'memory');\n    this.stats.get(TILES_GPU_MEMORY, 'memory');\n  }\n\n  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n  // eslint-disable-next-line max-statements\n  _initializeTileHeaders(tilesetJson, parentTileHeader) {\n    // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.\n    // Get the basePath relative to the external tileset.\n    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader); // resource\n\n    // If there is a parentTileHeader, add the root of the currently loading tileset\n    // to parentTileHeader's children, and update its depth.\n    if (parentTileHeader) {\n      parentTileHeader.children.push(rootTile);\n      rootTile.depth = parentTileHeader.depth + 1;\n    }\n\n    // Cesium 3d tiles knows the hierarchy beforehand\n    if (this.type === TILESET_TYPE.TILES3D) {\n      const stack: Tile3D[] = [];\n      stack.push(rootTile);\n\n      while (stack.length > 0) {\n        const tile = stack.pop() as Tile3D;\n        this.stats.get(TILES_TOTAL).incrementCount();\n        const children = tile.header.children || [];\n        for (const childHeader of children) {\n          const childTile = new Tile3D(this, childHeader, tile);\n          tile.children.push(childTile);\n          childTile.depth = tile.depth + 1;\n          stack.push(childTile);\n        }\n      }\n    }\n\n    return rootTile;\n  }\n\n  _initializeTraverser() {\n    let TraverserClass;\n    const type = this.type;\n    switch (type) {\n      case TILESET_TYPE.TILES3D:\n        TraverserClass = Tileset3DTraverser;\n        break;\n      case TILESET_TYPE.I3S:\n        TraverserClass = I3SetTraverser;\n        break;\n      default:\n        TraverserClass = TilesetTraverser;\n    }\n\n    return new TraverserClass({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n\n  _destroyTileHeaders(parentTile) {\n    this._destroySubtree(parentTile);\n  }\n\n  async _loadTile(tile) {\n    let loaded;\n    try {\n      this._onStartTileLoading();\n      loaded = await tile.loadContent();\n    } catch (error) {\n      this._onTileLoadError(tile, error);\n    } finally {\n      this._onEndTileLoading();\n      this._onTileLoad(tile, loaded);\n    }\n  }\n\n  _onTileLoadError(tile, error) {\n    this.stats.get(TILES_LOAD_FAILED).incrementCount();\n\n    const message = error.message || error.toString();\n    const url = tile.url;\n    // TODO - Allow for probe log to be injected instead of console?\n    console.error(`A 3D tile failed to load: ${tile.url} ${message}`); // eslint-disable-line\n    this.options.onTileError(tile, message, url);\n  }\n\n  _onTileLoad(tile, loaded) {\n    if (!loaded) {\n      return;\n    }\n\n    // add coordinateOrigin and modelMatrix to tile\n    if (tile && tile.content) {\n      calculateTransformProps(tile, tile.content);\n    }\n\n    this._addTileToCache(tile);\n    this.options.onTileLoad(tile);\n  }\n\n  _onStartTileLoading() {\n    this._pendingCount++;\n    this.stats.get(TILES_LOADING).incrementCount();\n  }\n\n  _onEndTileLoading() {\n    this._pendingCount--;\n    this.stats.get(TILES_LOADING).decrementCount();\n  }\n\n  _addTileToCache(tile) {\n    this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));\n  }\n\n  _updateCacheStats(tile) {\n    this.stats.get(TILES_LOADED).incrementCount();\n    this.stats.get(TILES_IN_MEMORY).incrementCount();\n\n    // Good enough? Just use the raw binary ArrayBuffer's byte length.\n    this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n  }\n\n  _unloadTile(tile) {\n    this.gpuMemoryUsageInBytes -= (tile.content && tile.content.byteLength) || 0;\n\n    this.stats.get(TILES_IN_MEMORY).decrementCount();\n    this.stats.get(TILES_UNLOADED).incrementCount();\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n\n    this.options.onTileUnload(tile);\n    tile.unloadContent();\n  }\n\n  // Traverse the tree and destroy all tiles\n  _destroy() {\n    const stack: Tile3D[] = [];\n\n    if (this.root) {\n      stack.push(this.root);\n    }\n\n    while (stack.length > 0) {\n      const tile: Tile3D = stack.pop() as Tile3D;\n\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n\n      this._destroyTile(tile);\n    }\n    this.root = null;\n  }\n\n  // Traverse the tree and destroy all sub tiles\n  _destroySubtree(tile) {\n    const root = tile;\n    const stack: Tile3D[] = [];\n    stack.push(root);\n    while (stack.length > 0) {\n      tile = stack.pop();\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n      if (tile !== root) {\n        this._destroyTile(tile);\n      }\n    }\n    root.children = [];\n  }\n\n  _destroyTile(tile) {\n    this._cache.unloadTile(this, tile);\n    this._unloadTile(tile);\n    tile.destroy();\n  }\n\n  _initializeCesiumTileset(tilesetJson) {\n    this.asset = tilesetJson.asset;\n    if (!this.asset) {\n      throw new Error('Tileset must have an asset property.');\n    }\n    if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {\n      throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');\n    }\n\n    // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)\n    // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version\n    if ('tilesetVersion' in this.asset) {\n      this._queryParams.v = this.asset.tilesetVersion;\n    }\n\n    // TODO - ion resources have a credits property we can use for additional attribution.\n    this.credits = {\n      attributions: this.options.attributions || []\n    };\n    this.description = this.options.description || '';\n\n    // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.\n    this.properties = tilesetJson.properties;\n    this.geometricError = tilesetJson.geometricError;\n    this._extensionsUsed = tilesetJson.extensionsUsed;\n    // Returns the extras property at the top of the tileset JSON (application specific metadata).\n    this.extras = tilesetJson.extras;\n  }\n\n  _initializeI3STileset() {\n    if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n      this._queryParams.token = this.loadOptions.i3s.token;\n    }\n  }\n}\n\nfunction getQueryParamString(queryParams): string {\n  const queryParamStrings: string[] = [];\n  for (const key of Object.keys(queryParams)) {\n    queryParamStrings.push(`${key}=${queryParams[key]}`);\n  }\n  switch (queryParamStrings.length) {\n    case 0:\n      return '';\n    case 1:\n      return `?${queryParamStrings[0]}`;\n    default:\n      return `?${queryParamStrings.join('&')}`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}