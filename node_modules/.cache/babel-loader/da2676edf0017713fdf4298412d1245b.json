{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst TopLeft = 'top-left';\nconst TopRight = 'top-right';\nconst BottomLeft = 'bottom-left';\nconst BottomRight = 'bottom-right';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst X = 'x';\nconst Y = 'y';\nconst Group = 'group';\nconst AxisRole = 'axis';\nconst TitleRole = 'title';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst LegendRole = 'legend';\nconst RowHeader = 'row-header';\nconst RowFooter = 'row-footer';\nconst RowTitle = 'row-title';\nconst ColHeader = 'column-header';\nconst ColFooter = 'column-footer';\nconst ColTitle = 'column-title';\nconst Padding = 'padding';\nconst Symbols = 'symbol';\nconst Fit = 'fit';\nconst FitX = 'fit-x';\nconst FitY = 'fit-y';\nconst Pad = 'pad';\nconst None = 'none';\nconst All = 'all';\nconst Each = 'each';\nconst Flush = 'flush';\nconst Column = 'column';\nconst Row = 'row';\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n          mark = _.mark,\n          type = mark.marktype,\n          entry = Marks[type],\n          bound = entry.bound;\n    let markBounds = mark.bounds,\n        rebound;\n\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes\n\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    } // ensure mark bounds do not exceed any clipping region\n\n\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n\n});\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n\nconst COUNTER_NAME = ':vega_identifier:';\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\n\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\n\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n          as = _.as;\n    let id = counter.value;\n    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);\n    counter.set(this.value = id);\n    return pulse;\n  }\n\n});\n\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\n\n\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value; // acquire mark on first invocation, bind context and group\n\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    } // initialize entering items\n\n\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status\n\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n\n      pulse.reflow();\n    } // bind items array to scenegraph mark\n\n\n    mark.items = pulse.source;\n    return pulse;\n  }\n\n});\n\nfunction lookup(_) {\n  const g = _.groups,\n        p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\n\n\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\n\nconst methods = {\n  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);\n  }\n}; // compute bounding box intersection\n// including padding pixels of separation\n\nconst intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\nconst hasOverlap = (items, pad) => {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\n\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\n\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n\n  b.expand(tolerance || 1);\n  return item => b.encloses(item.bounds);\n}; // reset all items to be fully opaque\n\n\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n}; // add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n\n\nconst reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');\n\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n          sep = _.separation || 0;\n    let source = pulse.materialize(pulse.SOURCE).source,\n        items,\n        test;\n    if (!source || !source.length) return;\n\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n\n      return pulse;\n    } // skip labels with no content\n\n\n    source = source.filter(hasBounds); // early exit, nothing to do\n\n    if (!source.length) return;\n\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n\n    items = reset(source);\n    pulse = reflow(pulse, _);\n\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    } // re-calculate mark bounds\n\n\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n\n});\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\n\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed\n\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n\n});\nconst tempBounds = new Bounds();\n\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [datum.ticks ? index++ : -1, // ticks index\n  datum.labels ? index++ : -1, // labels index\n  index + +datum.domain // title index\n  ];\n}\n\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n      datum = item.datum,\n      delta = item.translate != null ? item.translate : 0.5,\n      orient = item.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      dl = title && multiLineOffset(title),\n      x = 0,\n      y = 0,\n      i,\n      s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title\n\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n\n    default:\n      x = item.x;\n      y = item.y;\n  } // update bounds\n\n\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0,\n        dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n\n  bounds.union(b);\n}\n\nconst min = (a, b) => Math.floor(Math.min(a, b));\n\nconst max = (a, b) => Math.ceil(Math.max(a, b));\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0,\n      mark,\n      items;\n  const views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  }; // layout axes, gather legends, collect bounds\n\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n),\n      xExtent = Array(ncols),\n      xMax = 0,\n      yOffset = Array(n),\n      yExtent = Array(nrows),\n      yMax = 0,\n      dx = Array(n),\n      dy = Array(n),\n      boxes = Array(n),\n      m,\n      i,\n      c,\n      r,\n      b,\n      g,\n      px,\n      py,\n      x,\n      y,\n      offset;\n\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group\n\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  } // set initial alignment offsets\n\n\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  } // enforce column alignment constraints\n\n\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  } // enforce row alignment constraints\n\n\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  } // perform horizontal grid layout\n\n\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  } // perform vertical grid layout\n\n\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  } // perform horizontal centering\n\n\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  } // perform vertical centering\n\n\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  } // position grid relative to anchor\n\n\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n\n  x = Math.round(x);\n  y = Math.round(y); // update mark positions, bounds, dirty\n\n  bounds.clear();\n\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\n\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x,\n      y,\n      x2,\n      y2,\n      anchor,\n      band,\n      offset; // -- initial grid layout\n\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n  // -- layout grid headers and footers --\n  // perform row header layout\n\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  } // perform column header layout\n\n\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  } // perform row footer layout\n\n\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  } // perform column footer layout\n\n\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  } // perform row title layout\n\n\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  } // perform column title layout\n\n\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i,\n      j,\n      k,\n      m,\n      b,\n      h,\n      g,\n      x,\n      y; // if no groups, early exit and return 0\n\n  if (!n) return init; // compute margin\n\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  } // if no headers, return margin calculation\n\n\n  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns\n\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  } // apply offset\n\n\n  init += offset; // clear mark bounds for all headers\n\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  } // layout each header\n\n\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds; // search for nearest group to align to\n    // necessary if table has empty cells\n\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds\n\n\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h); // update current edge of layout bounds\n\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g); // compute title coordinates\n\n  var x = offset,\n      y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds\n\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y; // queue title for redraw\n\n  view.dirty(g);\n}\n\nfunction lookup$1(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n} // if legends specify offset directly, use the maximum specified value\n\n\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup$1(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n\n  return p;\n}\n\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x,\n      y = item.y,\n      w,\n      h; // cache current bounds for later comparison\n\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear(); // adjust legend to accommodate padding and title\n\n  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin\n\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin\n\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n\n      case Right:\n      case Bottom:\n        break;\n\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n\n    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates\n\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {}); // set dimensions of legend entry groups\n\n  entries.forEach(g => {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n      frame = group.frame,\n      orient = group.orient,\n      anchor = group.anchor,\n      offset = group.offset,\n      padding = group.padding,\n      title = group.items[0].items[0],\n      subtitle = group.items[1] && group.items[1].items[0],\n      end = orient === Left || orient === Right ? height : width,\n      start = 0,\n      x = 0,\n      y = 0,\n      sx = 0,\n      sy = 0,\n      pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n\n  tempBounds.union(title.bounds); // position title group\n\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n\n    default:\n      x = group.x;\n      y = group.y;\n  }\n\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n\n  return group.bounds;\n}\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\n\n\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n\n});\n\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [],\n      title,\n      mark,\n      orient,\n      b,\n      i,\n      n; // layout axes, gather legends, collect bounds\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n\n      case TitleRole:\n        title = mark;\n        break;\n\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  } // layout legends, adjust viewBounds\n\n\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    }); // perform grid layout for each orient group\n\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));\n    } // update view bounds\n\n\n    legends.forEach(item => {\n      const b = item.bounds;\n\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n\n        item.bounds = b;\n        view.dirty(item);\n      }\n\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  } // combine bounding boxes\n\n\n  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds\n\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  } // override aggregated view bounds if content is clipped\n\n\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  } // perform size adjustment\n\n\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n        type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  let viewWidth = view._width,\n      viewHeight = view._height,\n      width = Math.max(0, group.width || 0),\n      left = Math.max(0, Math.ceil(-viewBounds.x1)),\n      height = Math.max(0, group.height || 0),\n      top = Math.max(0, Math.ceil(-viewBounds.y1));\n  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\n\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-view-transforms/build/vega-view-transforms.module.js"],"names":["Transform","Marks","boundClip","GroupItem","Item","Bounds","multiLineOffset","boundStroke","inherits","peek","isObject","Top","Left","Right","Bottom","TopLeft","TopRight","BottomLeft","BottomRight","Start","Middle","End","X","Y","Group","AxisRole","TitleRole","FrameRole","ScopeRole","LegendRole","RowHeader","RowFooter","RowTitle","ColHeader","ColFooter","ColTitle","Padding","Symbols","Fit","FitX","FitY","Pad","None","All","Each","Flush","Column","Row","Bound","params","call","transform","_","pulse","view","dataflow","mark","type","marktype","entry","bound","markBounds","bounds","rebound","nested","items","length","dirty","boundItem","forEach","item","clear","union","modified","visit","MOD","role","reflow","changed","REM","ADD","alignsWith","modifies","opt","COUNTER_NAME","Identifier","Definition","counter","getCounter","as","id","value","t","set","_signals","add","Mark","scenegraph","markdef","lookup","index","group","context","source","clip","interactive","Init","zdirty","g","groups","p","parent","size","get","Object","keys","object","Overlap","methods","parity","filter","i","opacity","greedy","sep","a","b","intersect","Math","max","x1","x2","y1","y2","hasOverlap","pad","n","hasBounds","width","height","boundTest","scale","orient","tolerance","range","Infinity","expand","encloses","reset","reduce","method","separation","materialize","SOURCE","test","sort","slice","boundScale","boundTolerance","boundOrient","Render","ALL","fields","tempBounds","property","isYAxis","axisIndices","datum","grid","ticks","labels","domain","axisLayout","axis","delta","translate","indices","offset","position","minExtent","maxExtent","title","titlePadding","dl","x","y","s","min","axisTitleLayout","sign","auto","v","dx","dy","floor","ceil","gridLayoutGroups","views","marks","rowheaders","rowfooters","colheaders","colfooters","rowtitle","coltitle","push","bboxFlush","bboxFull","clone","empty","key","d","undefined","offsetValue","gridLayout","nodirty","bbox","alignCol","align","alignRow","padCol","padding","padRow","ncols","columns","nrows","xOffset","Array","xExtent","xMax","yOffset","yExtent","yMax","boxes","m","c","r","px","py","center","anchor","round","trellisLayout","boundFlush","boundFull","off","cells","band","headerBand","layoutHeaders","footerBand","titleAnchor","titleBand","layoutTitle","field","headers","limit","agg","isX","bf","start","stride","back","init","edge","j","k","h","warn","lookup$1","config","offsets","legends","legendParams","xb","yb","w","mult","column","row","legendLayout","legend","_bounds","legendGroupLayout","legendBounds","legendEntryLayout","ex","ey","tpad","tx","ty","legendTitleOffset","lr","noBar","grad","vgrad","e","u","o","entries","widths","titleLayout","viewBounds","frame","subtitle","end","sx","sy","pos","text","ViewLayout","layout","layoutGroup","shouldReflow","xBounds","yBounds","l","equals","autosize","viewSizeLayout","_autosize","viewWidth","_width","viewHeight","_height","left","top","right","bottom","contains","_resizeView","resize","identifier","overlap","render","viewlayout"],"mappings":"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","sourcesContent":["import { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst TopLeft = 'top-left';\nconst TopRight = 'top-right';\nconst BottomLeft = 'bottom-left';\nconst BottomRight = 'bottom-right';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst X = 'x';\nconst Y = 'y';\nconst Group = 'group';\nconst AxisRole = 'axis';\nconst TitleRole = 'title';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst LegendRole = 'legend';\nconst RowHeader = 'row-header';\nconst RowFooter = 'row-footer';\nconst RowTitle = 'row-title';\nconst ColHeader = 'column-header';\nconst ColFooter = 'column-footer';\nconst ColTitle = 'column-title';\nconst Padding = 'padding';\nconst Symbols = 'symbol';\nconst Fit = 'fit';\nconst FitX = 'fit-x';\nconst FitY = 'fit-y';\nconst Pad = 'pad';\nconst None = 'none';\nconst All = 'all';\nconst Each = 'each';\nconst Flush = 'flush';\nconst Column = 'column';\nconst Row = 'row';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n          mark = _.mark,\n          type = mark.marktype,\n          entry = Marks[type],\n          bound = entry.bound;\n    let markBounds = mark.bounds,\n        rebound;\n\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes\n\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    } // ensure mark bounds do not exceed any clipping region\n\n\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n\n});\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n\nconst COUNTER_NAME = ':vega_identifier:';\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\n\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n          as = _.as;\n    let id = counter.value;\n    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);\n    counter.set(this.value = id);\n    return pulse;\n  }\n\n});\n\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\n\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value; // acquire mark on first invocation, bind context and group\n\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    } // initialize entering items\n\n\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status\n\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n\n      pulse.reflow();\n    } // bind items array to scenegraph mark\n\n\n    mark.items = pulse.source;\n    return pulse;\n  }\n\n});\n\nfunction lookup(_) {\n  const g = _.groups,\n        p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\n\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\nconst methods = {\n  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);\n  }\n}; // compute bounding box intersection\n// including padding pixels of separation\n\nconst intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\nconst hasOverlap = (items, pad) => {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\n\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\n\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n\n  b.expand(tolerance || 1);\n  return item => b.encloses(item.bounds);\n}; // reset all items to be fully opaque\n\n\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n}; // add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n\n\nconst reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');\n\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n          sep = _.separation || 0;\n    let source = pulse.materialize(pulse.SOURCE).source,\n        items,\n        test;\n    if (!source || !source.length) return;\n\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n\n      return pulse;\n    } // skip labels with no content\n\n\n    source = source.filter(hasBounds); // early exit, nothing to do\n\n    if (!source.length) return;\n\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n\n    items = reset(source);\n    pulse = reflow(pulse, _);\n\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    } // re-calculate mark bounds\n\n\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n\n});\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\n\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed\n\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n\n});\n\nconst tempBounds = new Bounds();\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [datum.ticks ? index++ : -1, // ticks index\n  datum.labels ? index++ : -1, // labels index\n  index + +datum.domain // title index\n  ];\n}\n\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n      datum = item.datum,\n      delta = item.translate != null ? item.translate : 0.5,\n      orient = item.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      dl = title && multiLineOffset(title),\n      x = 0,\n      y = 0,\n      i,\n      s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title\n\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n\n    default:\n      x = item.x;\n      y = item.y;\n  } // update bounds\n\n\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0,\n        dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n\n  bounds.union(b);\n}\n\nconst min = (a, b) => Math.floor(Math.min(a, b));\n\nconst max = (a, b) => Math.ceil(Math.max(a, b));\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0,\n      mark,\n      items;\n  const views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  }; // layout axes, gather legends, collect bounds\n\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n),\n      xExtent = Array(ncols),\n      xMax = 0,\n      yOffset = Array(n),\n      yExtent = Array(nrows),\n      yMax = 0,\n      dx = Array(n),\n      dy = Array(n),\n      boxes = Array(n),\n      m,\n      i,\n      c,\n      r,\n      b,\n      g,\n      px,\n      py,\n      x,\n      y,\n      offset;\n\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group\n\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  } // set initial alignment offsets\n\n\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  } // enforce column alignment constraints\n\n\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  } // enforce row alignment constraints\n\n\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  } // perform horizontal grid layout\n\n\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  } // perform vertical grid layout\n\n\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  } // perform horizontal centering\n\n\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  } // perform vertical centering\n\n\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  } // position grid relative to anchor\n\n\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n\n  x = Math.round(x);\n  y = Math.round(y); // update mark positions, bounds, dirty\n\n  bounds.clear();\n\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x,\n      y,\n      x2,\n      y2,\n      anchor,\n      band,\n      offset; // -- initial grid layout\n\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n  // -- layout grid headers and footers --\n  // perform row header layout\n\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  } // perform column header layout\n\n\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  } // perform row footer layout\n\n\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  } // perform column footer layout\n\n\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  } // perform row title layout\n\n\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  } // perform column title layout\n\n\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i,\n      j,\n      k,\n      m,\n      b,\n      h,\n      g,\n      x,\n      y; // if no groups, early exit and return 0\n\n  if (!n) return init; // compute margin\n\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  } // if no headers, return margin calculation\n\n\n  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns\n\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  } // apply offset\n\n\n  init += offset; // clear mark bounds for all headers\n\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  } // layout each header\n\n\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds; // search for nearest group to align to\n    // necessary if table has empty cells\n\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds\n\n\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h); // update current edge of layout bounds\n\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g); // compute title coordinates\n\n  var x = offset,\n      y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds\n\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y; // queue title for redraw\n\n  view.dirty(g);\n}\n\nfunction lookup$1(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n} // if legends specify offset directly, use the maximum specified value\n\n\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup$1(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n\n  return p;\n}\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x,\n      y = item.y,\n      w,\n      h; // cache current bounds for later comparison\n\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear(); // adjust legend to accommodate padding and title\n\n  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin\n\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin\n\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n\n      case Right:\n      case Bottom:\n        break;\n\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n\n    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates\n\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {}); // set dimensions of legend entry groups\n\n  entries.forEach(g => {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n      frame = group.frame,\n      orient = group.orient,\n      anchor = group.anchor,\n      offset = group.offset,\n      padding = group.padding,\n      title = group.items[0].items[0],\n      subtitle = group.items[1] && group.items[1].items[0],\n      end = orient === Left || orient === Right ? height : width,\n      start = 0,\n      x = 0,\n      y = 0,\n      sx = 0,\n      sy = 0,\n      pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n\n  tempBounds.union(title.bounds); // position title group\n\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n\n    default:\n      x = group.x;\n      y = group.y;\n  }\n\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n\n  return group.bounds;\n}\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\n\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n\n});\n\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [],\n      title,\n      mark,\n      orient,\n      b,\n      i,\n      n; // layout axes, gather legends, collect bounds\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n\n      case TitleRole:\n        title = mark;\n        break;\n\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  } // layout legends, adjust viewBounds\n\n\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    }); // perform grid layout for each orient group\n\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));\n    } // update view bounds\n\n\n    legends.forEach(item => {\n      const b = item.bounds;\n\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n\n        item.bounds = b;\n        view.dirty(item);\n      }\n\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  } // combine bounding boxes\n\n\n  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds\n\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  } // override aggregated view bounds if content is clipped\n\n\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  } // perform size adjustment\n\n\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n        type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  let viewWidth = view._width,\n      viewHeight = view._height,\n      width = Math.max(0, group.width || 0),\n      left = Math.max(0, Math.ceil(-viewBounds.x1)),\n      height = Math.max(0, group.height || 0),\n      top = Math.max(0, Math.ceil(-viewBounds.y1));\n  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\n\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };\n"]},"metadata":{},"sourceType":"module"}