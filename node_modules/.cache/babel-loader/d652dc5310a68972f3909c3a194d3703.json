{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { compareArrayBuffers, path } from '@loaders.gl/loader-utils';\nimport { normalizeLoader } from '../loader-utils/normalize-loader';\nimport { log } from '../utils/log';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { getRegisteredLoaders } from './register-loaders';\nimport { isBlob } from '../../javascript-utils/is-type';\nvar EXT_PATTERN = /\\.([^.]+)$/;\nexport function selectLoader(_x) {\n  return _selectLoader.apply(this, arguments);\n}\n\nfunction _selectLoader() {\n  _selectLoader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n    var loaders,\n        options,\n        context,\n        loader,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            loaders = _args.length > 1 && _args[1] !== undefined ? _args[1] : [];\n            options = _args.length > 2 ? _args[2] : undefined;\n            context = _args.length > 3 ? _args[3] : undefined;\n\n            if (validHTTPResponse(data)) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 5:\n            loader = selectLoaderSync(data, loaders, _objectSpread({}, options, {\n              nothrow: true\n            }), context);\n\n            if (!loader) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt(\"return\", loader);\n\n          case 8:\n            if (!isBlob(data)) {\n              _context.next = 13;\n              break;\n            }\n\n            _context.next = 11;\n            return data.slice(0, 10).arrayBuffer();\n\n          case 11:\n            data = _context.sent;\n            loader = selectLoaderSync(data, loaders, options, context);\n\n          case 13:\n            if (!(!loader && !(options !== null && options !== void 0 && options.nothrow))) {\n              _context.next = 15;\n              break;\n            }\n\n            throw new Error(getNoValidLoaderMessage(data));\n\n          case 15:\n            return _context.abrupt(\"return\", loader);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _selectLoader.apply(this, arguments);\n}\n\nexport function selectLoaderSync(data) {\n  var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  var context = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n\n  var candidateLoaders = [];\n\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n\n  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {\n    var _candidateLoaders;\n\n    (_candidateLoaders = candidateLoaders).push.apply(_candidateLoaders, _toConsumableArray(getRegisteredLoaders()));\n  }\n\n  normalizeLoaders(candidateLoaders);\n  var loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\nfunction selectLoaderInternal(data, loaders, options, context) {\n  var _getResourceUrlAndTyp = getResourceUrlAndType(data),\n      url = _getResourceUrlAndTyp.url,\n      type = _getResourceUrlAndTyp.type;\n\n  var testUrl = url || (context === null || context === void 0 ? void 0 : context.url);\n  var loader = null;\n  var reason = '';\n\n  if (options !== null && options !== void 0 && options.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);\n    reason = \"match forced by supplied MIME type \".concat(options === null || options === void 0 ? void 0 : options.mimeType);\n  }\n\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? \"matched url \".concat(testUrl) : '');\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? \"matched MIME type \".concat(type) : '');\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  reason = reason || (loader ? \"matched initial data \".concat(getFirstCharacters(data)) : '');\n  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);\n  reason = reason || (loader ? \"matched fallback MIME type \".concat(type) : '');\n\n  if (reason) {\n    var _loader;\n\n    log.log(1, \"selectLoader selected \".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, \": \").concat(reason, \".\"));\n  }\n\n  return loader;\n}\n\nfunction validHTTPResponse(data) {\n  if (data instanceof Response) {\n    if (data.status === 204) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getNoValidLoaderMessage(data) {\n  var _getResourceUrlAndTyp2 = getResourceUrlAndType(data),\n      url = _getResourceUrlAndTyp2.url,\n      type = _getResourceUrlAndTyp2.type;\n\n  var message = 'No valid loader found (';\n  message += url ? \"\".concat(path.filename(url), \", \") : 'no url provided, ';\n  message += \"MIME type: \".concat(type ? \"\\\"\".concat(type, \"\\\"\") : 'not provided', \", \");\n  var firstCharacters = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? \" first bytes: \\\"\".concat(firstCharacters, \"\\\"\") : 'first bytes: not available';\n  message += ')';\n  return message;\n}\n\nfunction normalizeLoaders(loaders) {\n  var _iterator = _createForOfIteratorHelper(loaders),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var loader = _step.value;\n      normalizeLoader(loader);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction findLoaderByUrl(loaders, url) {\n  var match = url && EXT_PATTERN.exec(url);\n  var extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  var _iterator2 = _createForOfIteratorHelper(loaders),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var loader = _step2.value;\n\n      var _iterator3 = _createForOfIteratorHelper(loader.extensions),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var loaderExtension = _step3.value;\n\n          if (loaderExtension.toLowerCase() === extension) {\n            return loader;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return null;\n}\n\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  var _iterator4 = _createForOfIteratorHelper(loaders),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var loader = _step4.value;\n\n      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n        return loader;\n      }\n\n      if (mimeType === \"application/x.\".concat(loader.id)) {\n        return loader;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return null;\n}\n\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(loaders),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var loader = _step5.value;\n\n      if (typeof data === 'string') {\n        if (testDataAgainstText(data, loader)) {\n          return loader;\n        }\n      } else if (ArrayBuffer.isView(data)) {\n        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n          return loader;\n        }\n      } else if (data instanceof ArrayBuffer) {\n        var byteOffset = 0;\n\n        if (testDataAgainstBinary(data, byteOffset, loader)) {\n          return loader;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return null;\n}\n\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n\n  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(function (test) {\n    return data.startsWith(test);\n  });\n}\n\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(function (test) {\n    return testBinary(data, byteOffset, loader, test);\n  });\n}\n\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n\n    case 'string':\n      var magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    var byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n\n  var dataView = new DataView(arrayBuffer);\n  var magic = '';\n\n  for (var i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n\n  return magic;\n}","map":{"version":3,"sources":["../../../../src/lib/api/select-loader.ts"],"names":["EXT_PATTERN","loaders","validHTTPResponse","loader","selectLoaderSync","nothrow","isBlob","data","options","getNoValidLoaderMessage","Array","normalizeLoader","candidateLoaders","getRegisteredLoaders","normalizeLoaders","selectLoaderInternal","type","getResourceUrlAndType","testUrl","url","context","reason","findLoaderByMIMEType","findLoaderByUrl","findLoaderByInitialBytes","getFirstCharacters","log","message","path","firstCharacters","match","extension","findLoaderByExtension","loaderExtension","mimeType","testDataAgainstText","ArrayBuffer","testDataAgainstBinary","byteOffset","tests","test","testBinary","compareArrayBuffers","magic","getMagicString","length","arrayBuffer","dataView","i","String"],"mappings":"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","sourcesContent":["import type {LoaderContext, LoaderOptions, Loader} from '@loaders.gl/loader-utils';\nimport {compareArrayBuffers, path} from '@loaders.gl/loader-utils';\nimport {normalizeLoader} from '../loader-utils/normalize-loader';\nimport {log} from '../utils/log';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {getRegisteredLoaders} from './register-loaders';\nimport {isBlob} from '../../javascript-utils/is-type';\n\nconst EXT_PATTERN = /\\.([^.]+)$/;\n\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport async function selectLoader(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[] | Loader = [],\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<Loader | null> {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  // First make a sync attempt, disabling exceptions\n  let loader = selectLoaderSync(data, loaders, {...options, nothrow: true}, context);\n  if (loader) {\n    return loader;\n  }\n\n  // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\n  // to see if we can detect by initial content\n  if (isBlob(data)) {\n    data = await (data as Blob).slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport function selectLoaderSync(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[] | Loader = [],\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Loader | null {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  // eslint-disable-next-line complexity\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behavior be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    // TODO - remove support for legacy loaders\n    return normalizeLoader(loaders);\n  }\n\n  // Build list of candidate loaders that will be searched in order for a match\n  let candidateLoaders: Loader[] = [];\n  // First search supplied loaders\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n  // Then fall back to registered loaders\n  if (!options?.ignoreRegisteredLoaders) {\n    candidateLoaders.push(...getRegisteredLoaders());\n  }\n\n  // TODO - remove support for legacy loaders\n  normalizeLoaders(candidateLoaders);\n\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\n/** Implements loaders selection logic */\nfunction selectLoaderInternal(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[],\n  options?: LoaderOptions,\n  context?: LoaderContext\n) {\n  const {url, type} = getResourceUrlAndType(data);\n\n  const testUrl = url || context?.url;\n\n  let loader: Loader | null = null;\n  let reason: string = '';\n\n  // if options.mimeType is supplied, it takes precedence\n  if (options?.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options?.mimeType);\n    reason = `match forced by supplied MIME type ${options?.mimeType}`;\n  }\n\n  // Look up loader by url\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? `matched url ${testUrl}` : '');\n\n  // Look up loader by mime type\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? `matched MIME type ${type}` : '');\n\n  // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');\n\n  // Look up loader by fallback mime type\n  loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);\n  reason = reason || (loader ? `matched fallback MIME type ${type}` : '');\n\n  if (reason) {\n    log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);\n  }\n\n  return loader;\n}\n\n/** Check HTTP Response */\nfunction validHTTPResponse(data: any): boolean {\n  // HANDLE HTTP status\n  if (data instanceof Response) {\n    // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile\n    if (data.status === 204) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** Generate a helpful message to help explain why loader selection failed. */\nfunction getNoValidLoaderMessage(data): string {\n  const {url, type} = getResourceUrlAndType(data);\n\n  let message = 'No valid loader found (';\n  message += url ? `${path.filename(url)}, ` : 'no url provided, ';\n  message += `MIME type: ${type ? `\"${type}\"` : 'not provided'}, `;\n  // First characters are only accessible when called on data (string or arrayBuffer).\n  const firstCharacters: string = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? ` first bytes: \"${firstCharacters}\"` : 'first bytes: not available';\n  message += ')';\n  return message;\n}\n\nfunction normalizeLoaders(loaders: Loader[]): void {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders: Loader[], url?: string): Loader | null {\n  // Get extension\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\n\nfunction findLoaderByExtension(loaders: Loader[], extension: string): Loader | null {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    // Support referring to loaders using the \"unregistered tree\"\n    // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n    if (mimeType === `application/x.${loader.id}`) {\n      return loader;\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some((test) => data.startsWith(test));\n}\n\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some((test) => testBinary(data, byteOffset, loader, test));\n}\n\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n\n    case 'string':\n      // Magic bytes check: If `test` is a string, check if binary data starts with that strings\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data, length: number = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"]},"metadata":{},"sourceType":"module"}