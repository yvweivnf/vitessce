{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport Observable from \"./observable\"; // TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\n\nvar MulticastSubject = /*#__PURE__*/function (_Observable) {\n  _inherits(MulticastSubject, _Observable);\n\n  var _super = _createSuper(MulticastSubject);\n\n  function MulticastSubject() {\n    var _this;\n\n    _classCallCheck(this, MulticastSubject);\n\n    _this = _super.call(this, function (observer) {\n      _this._observers.add(observer);\n\n      return function () {\n        return _this._observers.delete(observer);\n      };\n    });\n    _this._observers = new Set();\n    return _this;\n  }\n\n  _createClass(MulticastSubject, [{\n    key: \"next\",\n    value: function next(value) {\n      var _iterator = _createForOfIteratorHelper(this._observers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var observer = _step.value;\n          observer.next(value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"error\",\n    value: function error(_error) {\n      var _iterator2 = _createForOfIteratorHelper(this._observers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var observer = _step2.value;\n          observer.error(_error);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      var _iterator3 = _createForOfIteratorHelper(this._observers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var observer = _step3.value;\n          observer.complete();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }]);\n\n  return MulticastSubject;\n}(Observable);\n\nexport default MulticastSubject;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/observable-fns/dist.esm/subject.js"],"names":["Observable","MulticastSubject","observer","_observers","add","delete","Set","value","next","error","complete"],"mappings":";;;;;AAAA,OAAOA,UAAP,MAAuB,cAAvB,C,CACA;AACA;AACA;;AACA;;;;;;;;;;IASMC,gB;;;;;AACF,8BAAc;AAAA;;AAAA;;AACV,8BAAM,UAAAC,QAAQ,EAAI;AACd,YAAKC,UAAL,CAAgBC,GAAhB,CAAoBF,QAApB;;AACA,aAAO;AAAA,eAAM,MAAKC,UAAL,CAAgBE,MAAhB,CAAuBH,QAAvB,CAAN;AAAA,OAAP;AACH,KAHD;AAIA,UAAKC,UAAL,GAAkB,IAAIG,GAAJ,EAAlB;AALU;AAMb;;;;yBACIC,K,EAAO;AAAA,iDACe,KAAKJ,UADpB;AAAA;;AAAA;AACR,4DAAwC;AAAA,cAA7BD,QAA6B;AACpCA,UAAAA,QAAQ,CAACM,IAAT,CAAcD,KAAd;AACH;AAHO;AAAA;AAAA;AAAA;AAAA;AAIX;;;0BACKE,M,EAAO;AAAA,kDACc,KAAKN,UADnB;AAAA;;AAAA;AACT,+DAAwC;AAAA,cAA7BD,QAA6B;AACpCA,UAAAA,QAAQ,CAACO,KAAT,CAAeA,MAAf;AACH;AAHQ;AAAA;AAAA;AAAA;AAAA;AAIZ;;;+BACU;AAAA,kDACgB,KAAKN,UADrB;AAAA;;AAAA;AACP,+DAAwC;AAAA,cAA7BD,QAA6B;AACpCA,UAAAA,QAAQ,CAACQ,QAAT;AACH;AAHM;AAAA;AAAA;AAAA;AAAA;AAIV;;;;EAtB0BV,U;;AAwB/B,eAAeC,gBAAf","sourcesContent":["import Observable from \"./observable\";\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nclass MulticastSubject extends Observable {\n    constructor() {\n        super(observer => {\n            this._observers.add(observer);\n            return () => this._observers.delete(observer);\n        });\n        this._observers = new Set();\n    }\n    next(value) {\n        for (const observer of this._observers) {\n            observer.next(value);\n        }\n    }\n    error(error) {\n        for (const observer of this._observers) {\n            observer.error(error);\n        }\n    }\n    complete() {\n        for (const observer of this._observers) {\n            observer.complete();\n        }\n    }\n}\nexport default MulticastSubject;\n"]},"metadata":{},"sourceType":"module"}