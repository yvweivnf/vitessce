{"ast":null,"code":"import { getCode, getVertices, CONTOUR_TYPE } from './marching-squares';\nexport function generateContours(_ref) {\n  let {\n    thresholdData,\n    colors,\n    cellWeights,\n    gridSize,\n    gridOrigin,\n    cellSize\n  } = _ref;\n  const contourSegments = [];\n  const contourPolygons = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {\n      contour\n    } = data;\n    const {\n      threshold\n    } = contour;\n\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        const {\n          code,\n          meanCode\n        } = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts);\n\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts);\n\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    contourSegments,\n    contourPolygons\n  };\n}","map":{"version":3,"sources":["../../../src/contour-layer/contour-utils.js"],"names":["cellSize","contourSegments","contourPolygons","width","gridSize","height","segmentIndex","polygonIndex","contour","threshold","x","y","meanCode","getCode","opts","thresholdData","data","Array","CONTOUR_TYPE","polygons","getVertices","vertices","i","start","end"],"mappings":"AAAA,SAAA,OAAA,EAAA,WAAA,EAAA,YAAA,QAAA,oBAAA;AAIA,OAAO,SAAA,gBAAA,CAAA,IAAA,EAOJ;AAAA,MAP8B;AAAA,IAAA,aAAA;AAAA,IAAA,MAAA;AAAA,IAAA,WAAA;AAAA,IAAA,QAAA;AAAA,IAAA,UAAA;AAM/BA,IAAAA;AAN+B,MAO9B,IAAA;AACD,QAAMC,eAAe,GAArB,EAAA;AACA,QAAMC,eAAe,GAArB,EAAA;AACA,QAAMC,KAAK,GAAGC,QAAQ,CAAtB,CAAsB,CAAtB;AACA,QAAMC,MAAM,GAAGD,QAAQ,CAAvB,CAAuB,CAAvB;AACA,MAAIE,YAAY,GAAhB,CAAA;AACA,MAAIC,YAAY,GAAhB,CAAA;;AAEA,OAAK,MAAL,IAAA,IAAA,aAAA,EAAkC;AAChC,UAAM;AAACC,MAAAA;AAAD,QAAN,IAAA;AACA,UAAM;AAACC,MAAAA;AAAD,QAAN,OAAA;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,CAAA,EAAiBA,CAAC,GAAlB,KAAA,EAA4BA,CAA5B,EAAA,EAAiC;AAC/B,WAAK,IAAIC,CAAC,GAAG,CAAb,CAAA,EAAiBA,CAAC,GAAlB,MAAA,EAA6BA,CAA7B,EAAA,EAAkC;AAEhC,cAAM;AAAA,UAAA,IAAA;AAAOC,UAAAA;AAAP,YAAmBC,OAAO,CAAC;AAAA,UAAA,WAAA;AAAA,UAAA,SAAA;AAAA,UAAA,CAAA;AAAA,UAAA,CAAA;AAAA,UAAA,KAAA;AAM/BR,UAAAA;AAN+B,SAAD,CAAhC;AAQA,cAAMS,IAAI,GAAG;AAAA,UAAA,UAAA;AAAA,UAAA,QAAA;AAAA,UAAA,CAAA;AAAA,UAAA,CAAA;AAAA,UAAA,KAAA;AAAA,UAAA,MAAA;AAAA,UAAA,IAAA;AAAA,UAAA,QAAA;AASXC,UAAAA,aAAa,EAAEC;AATJ,SAAb;;AAWA,YAAIC,KAAK,CAALA,OAAAA,CAAJ,SAAIA,CAAJ,EAA8B;AAC5BH,UAAAA,IAAI,CAAJA,IAAAA,GAAYI,YAAY,CAAxBJ,SAAAA;AACA,gBAAMK,QAAQ,GAAGC,WAAW,CAA5B,IAA4B,CAA5B;;AACA,eAAK,MAAL,OAAA,IAAA,QAAA,EAAgC;AAC9BlB,YAAAA,eAAe,CAACK,YAAhBL,EAAe,CAAfA,GAAkC;AAChCmB,cAAAA,QAAQ,EADwB,OAAA;AAEhCb,cAAAA;AAFgC,aAAlCN;AAID;AARH,SAAA,MASO;AAELY,UAAAA,IAAI,CAAJA,IAAAA,GAAYI,YAAY,CAAxBJ,SAAAA;AACA,gBAAMO,QAAQ,GAAGD,WAAW,CAA5B,IAA4B,CAA5B;;AACA,eAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,QAAQ,CAA5B,MAAA,EAAqCC,CAAC,IAAtC,CAAA,EAA6C;AAC3CrB,YAAAA,eAAe,CAACK,YAAhBL,EAAe,CAAfA,GAAkC;AAChCsB,cAAAA,KAAK,EAAEF,QAAQ,CADiB,CACjB,CADiB;AAEhCG,cAAAA,GAAG,EAAEH,QAAQ,CAACC,CAAC,GAFiB,CAEnB,CAFmB;AAGhCd,cAAAA;AAHgC,aAAlCP;AAKD;AACF;AACF;AACF;AACF;;AACD,SAAO;AAAA,IAAA,eAAA;AAAkBC,IAAAA;AAAlB,GAAP;AACD","sourcesContent":["import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  colors,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}) {\n  const contourSegments = [];\n  const contourPolygons = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts);\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts);\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n"]},"metadata":{},"sourceType":"module"}