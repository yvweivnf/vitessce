{"ast":null,"code":"import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import _objectSpread from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";import _toConsumableArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";/* eslint-disable no-underscore-dangle */import uuidv4 from'uuid/v4';import isNil from'lodash/isNil';import isEqual from'lodash/isEqual';import range from'lodash/range';import{featureCollection as turfFeatureCollection,point as turfPoint}from'@turf/helpers';import centroid from'@turf/centroid';import concaveman from'concaveman';import{HIERARCHICAL_SCHEMAS}from'./constants';import{getDefaultColor,PALETTE}from'../utils';import{pathToKey}from'./utils';/**\n * Alias for the uuidv4 function to make code more readable.\n * @returns {string} UUID.\n */function generateKey(){return uuidv4();}/**\n * Get the set associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {array} The array representing the set associated with the node.\n */export function nodeToSet(currNode){if(!currNode){return[];}if(!currNode.children){return currNode.set||[];}return currNode.children.flatMap(function(c){return nodeToSet(c);});}/**\n * Get the height of a node (the number of levels to reach a leaf).\n * @param {object} currNode A node object.\n * @param {number} level The level that the height will be computed relative to. By default, 0.\n * @returns {number} The height. If the node has a .children property,\n * then the minimum value returned is 1.\n */export function nodeToHeight(currNode){var level=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(!currNode.children){return level;}var newLevel=level+1;var childrenHeights=currNode.children.map(function(c){return nodeToHeight(c,newLevel);});return Math.max.apply(Math,_toConsumableArray(childrenHeights).concat([newLevel]));}/**\n * Get the size associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {number} The length of all the node's children\n */export function getNodeLength(currNode){if(!currNode){return 0;}if(!currNode.children){var _currNode$set;return((_currNode$set=currNode.set)===null||_currNode$set===void 0?void 0:_currNode$set.length)||0;}return currNode.children.reduce(function(acc,curr){return acc+getNodeLength(curr);},0);}/**\n * Find a node with a matching name path, relative to a particular node.\n * @param {object} node A node object.\n * @param {string[]} path The name path for the node of interest.\n * @param {number} currLevelIndex The index of the current hierarchy level.\n * @returns {object|null} A matching node object, or null if none is found.\n */function nodeFindNodeByNamePath(node,path,currLevelIndex){var currNodeName=path[currLevelIndex];if(node.name===currNodeName){if(currLevelIndex===path.length-1){return node;}if(node.children){var foundNodes=node.children.map(function(child){return nodeFindNodeByNamePath(child,path,currLevelIndex+1);}).filter(Boolean);if(foundNodes.length===1){return foundNodes[0];}}}return null;}/**\n * Find a node with a matching name path, relative to the whole tree.\n * @param {object} currTree A tree object.\n * @param {string[]} targetNamePath The name path for the node of interest.\n * @returns {object|null} A matching node object, or null if none is found.\n */export function treeFindNodeByNamePath(currTree,targetNamePath){var foundNodes=currTree.tree.map(function(levelZeroNode){return nodeFindNodeByNamePath(levelZeroNode,targetNamePath,0);}).filter(Boolean);if(foundNodes.length===1){return foundNodes[0];}return null;}/**\n * Transform a node object using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */export function nodeTransform(node,predicate,transform,transformedPaths,currPath){var newPath;if(!currPath){newPath=[node.name];}else{newPath=_toConsumableArray(currPath);}if(predicate(node,newPath)){transformedPaths.push(newPath);return transform(node,newPath);}if(node.children){return _objectSpread({},node,{children:node.children.map(function(child){return nodeTransform(child,predicate,transform,transformedPaths,newPath.concat([child.name]));})});}return node;}/**\n * Transform many node objects using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */export function nodeTransformAll(node,predicate,transform,transformedPaths,currPath){var newPath;if(!currPath){newPath=[node.name];}else{newPath=_toConsumableArray(currPath);}var newNode=node;if(predicate(node,newPath)){transformedPaths.push(newPath);newNode=transform(node,newPath);}if(node.children){return _objectSpread({},newNode,{children:newNode.children.map(function(child){return nodeTransformAll(child,predicate,transform,transformedPaths,newPath.concat([child.name]));})});}return newNode;}/**\n * Append a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */export function nodeAppendChild(currNode,newChild){return _objectSpread({},currNode,{children:[].concat(_toConsumableArray(currNode.children),[newChild])});}/**\n * Prepend a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */export function nodePrependChild(currNode,newChild){return _objectSpread({},currNode,{children:[newChild].concat(_toConsumableArray(currNode.children))});}/**\n * Insert a child to a parent node.\n * @param {object} currNode A node object.\n * @param {*} newChild The child node object.\n * @param {*} insertIndex The index at which to insert the child.\n * @returns {object} The updated node.\n */export function nodeInsertChild(currNode,newChild,insertIndex){var newChildren=Array.from(currNode.children);newChildren.splice(insertIndex,0,newChild);return _objectSpread({},currNode,{children:newChildren});}/**\n * Get an array representing the union of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the union of the sets of checked nodes.\n */export function treeToUnion(currTree,checkedPaths){var nodes=checkedPaths.map(function(path){return treeFindNodeByNamePath(currTree,path);});var nodeSets=nodes.map(function(node){return nodeToSet(node).map(function(_ref){var _ref2=_slicedToArray(_ref,1),cellId=_ref2[0];return cellId;});});return nodeSets.reduce(function(a,h){return a.concat(h.filter(function(hEl){return!a.includes(hEl);}));},nodeSets[0]||[]);}/**\n * Get an array representing the intersection of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the intersection of the sets of checked nodes.\n */export function treeToIntersection(currTree,checkedPaths){var nodes=checkedPaths.map(function(path){return treeFindNodeByNamePath(currTree,path);});var nodeSets=nodes.map(function(node){return nodeToSet(node).map(function(_ref3){var _ref4=_slicedToArray(_ref3,1),cellId=_ref4[0];return cellId;});});return nodeSets.reduce(function(a,h){return h.filter(function(hEl){return a.includes(hEl);});},nodeSets[0]||[]);}/**\n * Get an array representing the complement of the union of the sets of checked nodes.\n * @param {object} currTree\n * @returns {array} An array representing the complement of the\n * union of the sets of checked nodes.\n */export function treeToComplement(currTree,checkedPaths,items){var primaryUnion=treeToUnion(currTree,checkedPaths);return items.filter(function(el){return!primaryUnion.includes(el);});}/**\n * Get an flattened array of descendants at a particular relative\n * level of interest.\n * @param {object} node A node object.\n * @param {number} level The relative level of interest.\n * 0 for this node's children, 1 for grandchildren, etc.\n * @param {boolean} stopEarly Should a node be returned early if no children exist?\n * @returns {object[]} An array of descendants at the specified level,\n * where the level is relative to the node.\n */export function nodeToLevelDescendantNamePaths(node,level,prevPath){var stopEarly=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;if(!node.children){if(!stopEarly){return null;}return[[].concat(_toConsumableArray(prevPath),[node.name])];}if(level===0){return[[].concat(_toConsumableArray(prevPath),[node.name])];}return node.children.flatMap(function(c){return nodeToLevelDescendantNamePaths(c,level-1,[].concat(_toConsumableArray(prevPath),[node.name]),stopEarly);}).filter(Boolean);}/**\n * Export the tree by clearing tree state and all node states.\n * @param {object} currTree A tree object.\n * @returns {object} Tree object with tree and node state removed.\n */export function treeExport(currTree,datatype){return{version:HIERARCHICAL_SCHEMAS[datatype].latestVersion,datatype:datatype,tree:currTree.tree};}/**\n * Export the tree by clearing tree state and all node states,\n * and filter so that only the level zero node of interest is included.\n * @param {object} currTree A tree object.\n * @param {string} nodePath The path of the node of interest.\n * @param {string} dataType Datatype (i.e cell sets)\n * @param {Array} cellSetColors Array of objects of cell set colors and paths\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} { treeToExport, nodeName }\n * Tree with one level zero node, and with state removed.\n */export function treeExportLevelZeroNode(currTree,nodePath,datatype,cellSetColors,theme){var node=treeFindNodeByNamePath(currTree,nodePath);var nodeWithColors=nodeTransformAll(node,function(){return true;},function(n,nPath){var _cellSetColors$find$c,_cellSetColors$find;var nodeColor=(_cellSetColors$find$c=cellSetColors===null||cellSetColors===void 0?void 0:(_cellSetColors$find=cellSetColors.find(function(c){return isEqual(c.path,nPath);}))===null||_cellSetColors$find===void 0?void 0:_cellSetColors$find.color)!==null&&_cellSetColors$find$c!==void 0?_cellSetColors$find$c:getDefaultColor(theme);return _objectSpread({},n,{color:nodeColor.slice(0,3)});},[]);var treeWithOneLevelZeroNode=_objectSpread({},currTree,{tree:[nodeWithColors]});return{treeToExport:treeExport(treeWithOneLevelZeroNode,datatype),nodeName:node.name};}/**\n * Prepare the set of a node of interest for export.\n * @param {object} currTree A tree object.\n * @param {string} nodeKey The key of the node of interest.\n * @returns {object} { setToExport, nodeName } The set as an array.\n */export function treeExportSet(currTree,nodePath){var node=treeFindNodeByNamePath(currTree,nodePath);return{setToExport:nodeToSet(node),nodeName:node.name};}/**\n * Get an empty tree, with a default tree state.\n * @param {string} datatype The type of sets that this tree contains.\n * @returns {object} Empty tree.\n */export function treeInitialize(datatype){return{version:HIERARCHICAL_SCHEMAS[datatype].latestVersion,datatype:datatype,tree:[]};}/**\n * For convenience, get an object with information required\n * to render a node as a component.\n * @param {object} node A node to be rendered.\n * @returns {object} An object containing properties required\n * by the TreeNode render functions.\n */export function nodeToRenderProps(node,path,cellSetColor){var _cellSetColor$find;var level=path.length-1;return{title:node.name,nodeKey:pathToKey(path),path:path,size:getNodeLength(node),color:cellSetColor===null||cellSetColor===void 0?void 0:(_cellSetColor$find=cellSetColor.find(function(d){return isEqual(d.path,path);}))===null||_cellSetColor$find===void 0?void 0:_cellSetColor$find.color,level:level,isLeaf:(!node.children||node.children.length===0)&&Boolean(node.set),height:nodeToHeight(node)};}/**\n * Using a color and a probability, mix the color with an \"uncertainty\" color,\n * for example, gray.\n * Reference: https://github.com/bgrins/TinyColor/blob/80f7225029c428c0de0757f7d98ac15f497bee57/tinycolor.js#L701\n * @param {number[]} originalColor The color assignment for the class.\n * @param {number} p The mixing amount, or level certainty in the originalColor classification,\n * between 0 and 1.\n * @param {number[]} mixingColor The color with which to mix. By default, [128, 128, 128] gray.\n * @returns {number[]} Returns the color after mixing.\n */function colorMixWithUncertainty(originalColor,p){var mixingColor=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[128,128,128];return[(originalColor[0]-mixingColor[0])*p+mixingColor[0],(originalColor[1]-mixingColor[1])*p+mixingColor[1],(originalColor[2]-mixingColor[2])*p+mixingColor[2]];}/**\n * Given a tree with state, get the cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n *  @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} cellSetColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {array} Tuple of [cellIds, cellColors]\n * where cellIds is an array of strings,\n * and cellColors is an object mapping cellIds to color [r,g,b] arrays.\n */export function treeToCellColorsBySetNames(currTree,selectedNamePaths,cellSetColor,theme){var cellColorsArray=[];selectedNamePaths.forEach(function(setNamePath){var node=treeFindNodeByNamePath(currTree,setNamePath);if(node){var _cellSetColor$find2;var nodeSet=nodeToSet(node);var nodeColor=(cellSetColor===null||cellSetColor===void 0?void 0:(_cellSetColor$find2=cellSetColor.find(function(d){return isEqual(d.path,setNamePath);}))===null||_cellSetColor$find2===void 0?void 0:_cellSetColor$find2.color)||getDefaultColor(theme);cellColorsArray=[].concat(_toConsumableArray(cellColorsArray),_toConsumableArray(nodeSet.map(function(_ref5){var _ref6=_slicedToArray(_ref5,2),cellId=_ref6[0],prob=_ref6[1];return[cellId,isNil(prob)?nodeColor:colorMixWithUncertainty(nodeColor,prob)];})));}});return new Map(cellColorsArray);}/**\n * Given a tree with state, get an array of\n * objects with cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme.\n * @returns {object[]} Array of objects with properties\n * `obsId`, `name`, and `color`.\n */export function treeToObjectsBySetNames(currTree,selectedNamePaths,setColor,theme){var cellsArray=[];var _loop=function _loop(i){var setNamePath=selectedNamePaths[i];var node=treeFindNodeByNamePath(currTree,setNamePath);if(node){var _setColor$find;var nodeSet=nodeToSet(node);var nodeColor=(setColor===null||setColor===void 0?void 0:(_setColor$find=setColor.find(function(d){return isEqual(d.path,setNamePath);}))===null||_setColor$find===void 0?void 0:_setColor$find.color)||getDefaultColor(theme);cellsArray=cellsArray.concat(nodeSet.map(function(_ref7){var _ref8=_slicedToArray(_ref7,1),cellId=_ref8[0];return{obsId:cellId,name:node.name,color:nodeColor};}));}};for(var i=0;i<selectedNamePaths.length;i+=1){_loop(i);}return cellsArray;}export function treeToCellPolygonsBySetNames(currTree,cells,mapping,selectedNamePaths,cellSetColor,theme){var cellSetPolygons=[];selectedNamePaths.forEach(function(setNamePath){var node=treeFindNodeByNamePath(currTree,setNamePath);if(node){var _cellSetColor$find3;var nodeSet=nodeToSet(node);var nodeColor=(cellSetColor===null||cellSetColor===void 0?void 0:(_cellSetColor$find3=cellSetColor.find(function(d){return isEqual(d.path,setNamePath);}))===null||_cellSetColor$find3===void 0?void 0:_cellSetColor$find3.color)||getDefaultColor(theme);var cellPositions=nodeSet.map(function(_ref9){var _cells$cellId,_cells$cellId2;var _ref10=_slicedToArray(_ref9,1),cellId=_ref10[0];return[(_cells$cellId=cells[cellId])===null||_cells$cellId===void 0?void 0:_cells$cellId.mappings[mapping][0],-((_cells$cellId2=cells[cellId])===null||_cells$cellId2===void 0?void 0:_cells$cellId2.mappings[mapping][1])];}).filter(function(cell){return cell.every(function(i){return typeof i==='number';});});if(cellPositions.length>2){var points=turfFeatureCollection(cellPositions.map(turfPoint));var concavity=Infinity;var hullCoords=concaveman(cellPositions,concavity);if(hullCoords){var centroidCoords=centroid(points).geometry.coordinates;cellSetPolygons.push({path:setNamePath,name:setNamePath[setNamePath.length-1],hull:hullCoords,color:nodeColor,centroid:centroidCoords});}}}});return cellSetPolygons;}/**\n * Given a tree with state, get the sizes of the\n * sets currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object[]} Array of objects\n * with the properties `name`, `size`, `key`,\n * and `color`.\n */export function treeToSetSizesBySetNames(currTree,selectedNamePaths,setColor,theme){var sizes=[];selectedNamePaths.forEach(function(setNamePath){var node=treeFindNodeByNamePath(currTree,setNamePath);if(node){var _setColor$find2;var nodeSet=nodeToSet(node);var nodeColor=(setColor===null||setColor===void 0?void 0:(_setColor$find2=setColor.find(function(d){return isEqual(d.path,setNamePath);}))===null||_setColor$find2===void 0?void 0:_setColor$find2.color)||getDefaultColor(theme);sizes.push({key:generateKey(),name:node.name,size:nodeSet.length,color:nodeColor});}});return sizes;}/**\n * Find and remove a node from the descendants of the current node.\n * @param {object} node A node to search on.\n * @param {array} prevPath Path of the current node to be searched.\n * @param {array} filterPath The path sought.\n * @returns {object} A new node without a node at filterPath.\n */export function filterNode(node,prevPath,filterPath){if(isEqual([].concat(_toConsumableArray(prevPath),[node.name]),filterPath)){return null;}if(!node.children){return node;}return _objectSpread({},node,{children:node.children.map(function(c){return filterNode(c,[].concat(_toConsumableArray(prevPath),[node.name]),filterPath);}).filter(Boolean)});}export function treeToExpectedCheckedLevel(currTree,checkedPaths){var result=null;if(currTree){currTree.tree.forEach(function(lzn){var levelZeroPath=[lzn.name];var height=nodeToHeight(lzn);range(height).forEach(function(i){var levelIndex=i+1;var levelNodePaths=nodeToLevelDescendantNamePaths(lzn,levelIndex,[],true);if(isEqual(levelNodePaths,checkedPaths)){result={levelZeroPath:levelZeroPath,levelIndex:levelIndex};}});});}return result;}export function treesConflict(cellSets,testCellSets){var paths=[];var testPaths=[];var hasConflict=false;function getPaths(node,prevPath){paths.push([].concat(_toConsumableArray(prevPath),[node.name]));if(node.children){node.children.forEach(function(c){return getPaths(c,[].concat(_toConsumableArray(prevPath),[node.name]));});}}cellSets.tree.forEach(function(lzn){return getPaths(lzn,[]);});function getTestPaths(node,prevPath){testPaths.push([].concat(_toConsumableArray(prevPath),[node.name]));if(node.children){node.children.forEach(function(c){return getPaths(c,[].concat(_toConsumableArray(prevPath),[node.name]));});}}testCellSets.tree.forEach(function(lzn){return getTestPaths(lzn,[]);});testPaths.forEach(function(testPath){if(paths.find(function(p){return isEqual(p,testPath);})){hasConflict=true;}});return hasConflict;}export function initializeCellSetColor(cellSets,cellSetColor){var nextCellSetColor=_toConsumableArray(cellSetColor||[]);var nodeCountPerTreePerLevel=cellSets.tree.map(function(tree){return Array.from({length:nodeToHeight(tree)+1// Need to add one because its an array.\n}).fill(0);});function processNode(node,prevPath,hierarchyLevel,treeIndex){var index=nodeCountPerTreePerLevel[treeIndex][hierarchyLevel];var nodePath=[].concat(_toConsumableArray(prevPath),[node.name]);var nodeColor=nextCellSetColor.find(function(d){return isEqual(d.path,nodePath);});if(!nodeColor){// If there is a color for the node specified via the cell set tree,\n// then use it. Otherwise, use a color from the default color palette.\nvar nodeColorArray=node.color?node.color:PALETTE[index%PALETTE.length];nextCellSetColor.push({path:nodePath,color:nodeColorArray});}nodeCountPerTreePerLevel[treeIndex][hierarchyLevel]+=1;if(node.children){node.children.forEach(function(c){return processNode(c,nodePath,hierarchyLevel+1,treeIndex);});}}cellSets.tree.forEach(function(lzn,treeIndex){return processNode(lzn,[],0,treeIndex);});return nextCellSetColor;}export function getCellSetPolygons(params){var cells=params.cells,mapping=params.mapping,cellSets=params.cellSets,cellSetSelection=params.cellSetSelection,cellSetColor=params.cellSetColor,theme=params.theme;if(cellSetSelection&&cellSetSelection.length>0&&cellSets&&cells){return treeToCellPolygonsBySetNames(cellSets,cells,mapping,cellSetSelection,cellSetColor,theme);}return[];}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/cell-set-utils.js"],"names":["uuidv4","isNil","isEqual","range","featureCollection","turfFeatureCollection","point","turfPoint","centroid","concaveman","HIERARCHICAL_SCHEMAS","getDefaultColor","PALETTE","pathToKey","generateKey","nodeToSet","currNode","children","set","flatMap","c","nodeToHeight","level","newLevel","childrenHeights","map","Math","max","getNodeLength","length","reduce","acc","curr","nodeFindNodeByNamePath","node","path","currLevelIndex","currNodeName","name","foundNodes","child","filter","Boolean","treeFindNodeByNamePath","currTree","targetNamePath","tree","levelZeroNode","nodeTransform","predicate","transform","transformedPaths","currPath","newPath","push","concat","nodeTransformAll","newNode","nodeAppendChild","newChild","nodePrependChild","nodeInsertChild","insertIndex","newChildren","Array","from","splice","treeToUnion","checkedPaths","nodes","nodeSets","cellId","a","h","hEl","includes","treeToIntersection","treeToComplement","items","primaryUnion","el","nodeToLevelDescendantNamePaths","prevPath","stopEarly","treeExport","datatype","version","latestVersion","treeExportLevelZeroNode","nodePath","cellSetColors","theme","nodeWithColors","n","nPath","nodeColor","find","color","slice","treeWithOneLevelZeroNode","treeToExport","nodeName","treeExportSet","setToExport","treeInitialize","nodeToRenderProps","cellSetColor","title","nodeKey","size","d","isLeaf","height","colorMixWithUncertainty","originalColor","p","mixingColor","treeToCellColorsBySetNames","selectedNamePaths","cellColorsArray","forEach","setNamePath","nodeSet","prob","Map","treeToObjectsBySetNames","setColor","cellsArray","i","obsId","treeToCellPolygonsBySetNames","cells","mapping","cellSetPolygons","cellPositions","mappings","cell","every","points","concavity","Infinity","hullCoords","centroidCoords","geometry","coordinates","hull","treeToSetSizesBySetNames","sizes","key","filterNode","filterPath","treeToExpectedCheckedLevel","result","lzn","levelZeroPath","levelIndex","levelNodePaths","treesConflict","cellSets","testCellSets","paths","testPaths","hasConflict","getPaths","getTestPaths","testPath","initializeCellSetColor","nextCellSetColor","nodeCountPerTreePerLevel","fill","processNode","hierarchyLevel","treeIndex","index","nodeColorArray","getCellSetPolygons","params","cellSetSelection"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport uuidv4 from 'uuid/v4';\nimport isNil from 'lodash/isNil';\nimport isEqual from 'lodash/isEqual';\nimport range from 'lodash/range';\nimport { featureCollection as turfFeatureCollection, point as turfPoint } from '@turf/helpers';\nimport centroid from '@turf/centroid';\nimport concaveman from 'concaveman';\nimport {\n  HIERARCHICAL_SCHEMAS,\n} from './constants';\nimport { getDefaultColor, PALETTE } from '../utils';\nimport { pathToKey } from './utils';\n\n/**\n * Alias for the uuidv4 function to make code more readable.\n * @returns {string} UUID.\n */\nfunction generateKey() {\n  return uuidv4();\n}\n\n/**\n * Get the set associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {array} The array representing the set associated with the node.\n */\nexport function nodeToSet(currNode) {\n  if (!currNode) {\n    return [];\n  }\n  if (!currNode.children) {\n    return (currNode.set || []);\n  }\n  return currNode.children.flatMap(c => nodeToSet(c));\n}\n\n/**\n * Get the height of a node (the number of levels to reach a leaf).\n * @param {object} currNode A node object.\n * @param {number} level The level that the height will be computed relative to. By default, 0.\n * @returns {number} The height. If the node has a .children property,\n * then the minimum value returned is 1.\n */\nexport function nodeToHeight(currNode, level = 0) {\n  if (!currNode.children) {\n    return level;\n  }\n  const newLevel = level + 1;\n  const childrenHeights = currNode.children.map(c => nodeToHeight(c, newLevel));\n  return Math.max(...childrenHeights, newLevel);\n}\n\n/**\n * Get the size associated with a particular node.\n * Recursive.\n * @param {object} currNode A node object.\n * @returns {number} The length of all the node's children\n */\nexport function getNodeLength(currNode) {\n  if (!currNode) {\n    return 0;\n  }\n  if (!currNode.children) {\n    return (currNode.set?.length || 0);\n  }\n  return currNode.children.reduce((acc, curr) => acc + getNodeLength(curr), 0);\n}\n\n/**\n * Find a node with a matching name path, relative to a particular node.\n * @param {object} node A node object.\n * @param {string[]} path The name path for the node of interest.\n * @param {number} currLevelIndex The index of the current hierarchy level.\n * @returns {object|null} A matching node object, or null if none is found.\n */\nfunction nodeFindNodeByNamePath(node, path, currLevelIndex) {\n  const currNodeName = path[currLevelIndex];\n  if (node.name === currNodeName) {\n    if (currLevelIndex === path.length - 1) {\n      return node;\n    }\n    if (node.children) {\n      const foundNodes = node.children\n        .map(child => nodeFindNodeByNamePath(child, path, currLevelIndex + 1))\n        .filter(Boolean);\n      if (foundNodes.length === 1) {\n        return foundNodes[0];\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Find a node with a matching name path, relative to the whole tree.\n * @param {object} currTree A tree object.\n * @param {string[]} targetNamePath The name path for the node of interest.\n * @returns {object|null} A matching node object, or null if none is found.\n */\nexport function treeFindNodeByNamePath(currTree, targetNamePath) {\n  const foundNodes = currTree.tree\n    .map(levelZeroNode => nodeFindNodeByNamePath(levelZeroNode, targetNamePath, 0))\n    .filter(Boolean);\n  if (foundNodes.length === 1) {\n    return foundNodes[0];\n  }\n  return null;\n}\n\n/**\n * Transform a node object using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */\nexport function nodeTransform(node, predicate, transform, transformedPaths, currPath) {\n  let newPath;\n  if (!currPath) {\n    newPath = [node.name];\n  } else {\n    newPath = [...currPath];\n  }\n  if (predicate(node, newPath)) {\n    transformedPaths.push(newPath);\n    return transform(node, newPath);\n  }\n  if (node.children) {\n    return {\n      ...node,\n      children: node.children.map(\n        child => nodeTransform(\n          child, predicate, transform, transformedPaths, newPath.concat([child.name]),\n        ),\n      ),\n    };\n  }\n  return node;\n}\n\n/**\n * Transform many node objects using a transform function.\n * @param {object} node A node object.\n * @param {function} predicate Returns true if a node matches a condition of interest.\n * @param {function} transform Takes the node matching the predicate as input, returns\n * a transformed version of the node.\n * @param {array} transformedPaths This array parameter is mutated. The path of\n * each transformed node is appended to this array.\n * @param {string[]} The current path of the node being updated, used internally\n * during recursion.\n * @returns {object} The updated node.\n */\nexport function nodeTransformAll(node, predicate, transform, transformedPaths, currPath) {\n  let newPath;\n  if (!currPath) {\n    newPath = [node.name];\n  } else {\n    newPath = [...currPath];\n  }\n  let newNode = node;\n  if (predicate(node, newPath)) {\n    transformedPaths.push(newPath);\n    newNode = transform(node, newPath);\n  }\n  if (node.children) {\n    return {\n      ...newNode,\n      children: newNode.children.map(\n        child => nodeTransformAll(\n          child, predicate, transform, transformedPaths, newPath.concat([child.name]),\n        ),\n      ),\n    };\n  }\n  return newNode;\n}\n\n/**\n * Append a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */\nexport function nodeAppendChild(currNode, newChild) {\n  return {\n    ...currNode,\n    children: [...currNode.children, newChild],\n  };\n}\n\n/**\n * Prepend a child to a parent node.\n * @param {object} currNode A node object.\n * @param {object} newChild The child node object.\n * @returns {object} The updated node.\n */\nexport function nodePrependChild(currNode, newChild) {\n  return {\n    ...currNode,\n    children: [newChild, ...currNode.children],\n  };\n}\n\n/**\n * Insert a child to a parent node.\n * @param {object} currNode A node object.\n * @param {*} newChild The child node object.\n * @param {*} insertIndex The index at which to insert the child.\n * @returns {object} The updated node.\n */\nexport function nodeInsertChild(currNode, newChild, insertIndex) {\n  const newChildren = Array.from(currNode.children);\n  newChildren.splice(insertIndex, 0, newChild);\n  return {\n    ...currNode,\n    children: newChildren,\n  };\n}\n\n/**\n * Get an array representing the union of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the union of the sets of checked nodes.\n */\nexport function treeToUnion(currTree, checkedPaths) {\n  const nodes = checkedPaths.map(path => treeFindNodeByNamePath(currTree, path));\n  const nodeSets = nodes.map(node => nodeToSet(node).map(([cellId]) => cellId));\n  return nodeSets\n    .reduce((a, h) => a.concat(h.filter(hEl => !a.includes(hEl))), nodeSets[0] || []);\n}\n\n/**\n * Get an array representing the intersection of the sets of checked nodes.\n * @param {object} currTree A tree object.\n * @returns {array} An array representing the intersection of the sets of checked nodes.\n */\nexport function treeToIntersection(currTree, checkedPaths) {\n  const nodes = checkedPaths.map(path => treeFindNodeByNamePath(currTree, path));\n  const nodeSets = nodes.map(node => nodeToSet(node).map(([cellId]) => cellId));\n  return nodeSets\n    .reduce((a, h) => h.filter(hEl => a.includes(hEl)), nodeSets[0] || []);\n}\n\n/**\n * Get an array representing the complement of the union of the sets of checked nodes.\n * @param {object} currTree\n * @returns {array} An array representing the complement of the\n * union of the sets of checked nodes.\n */\nexport function treeToComplement(currTree, checkedPaths, items) {\n  const primaryUnion = treeToUnion(currTree, checkedPaths);\n  return items.filter(el => !primaryUnion.includes(el));\n}\n\n/**\n * Get an flattened array of descendants at a particular relative\n * level of interest.\n * @param {object} node A node object.\n * @param {number} level The relative level of interest.\n * 0 for this node's children, 1 for grandchildren, etc.\n * @param {boolean} stopEarly Should a node be returned early if no children exist?\n * @returns {object[]} An array of descendants at the specified level,\n * where the level is relative to the node.\n */\nexport function nodeToLevelDescendantNamePaths(node, level, prevPath, stopEarly = false) {\n  if (!node.children) {\n    if (!stopEarly) {\n      return null;\n    }\n    return [[...prevPath, node.name]];\n  }\n  if (level === 0) {\n    return [[...prevPath, node.name]];\n  }\n  return node.children\n    .flatMap(c => nodeToLevelDescendantNamePaths(c, level - 1, [...prevPath, node.name], stopEarly))\n    .filter(Boolean);\n}\n\n/**\n * Export the tree by clearing tree state and all node states.\n * @param {object} currTree A tree object.\n * @returns {object} Tree object with tree and node state removed.\n */\nexport function treeExport(currTree, datatype) {\n  return {\n    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n    datatype,\n    tree: currTree.tree,\n  };\n}\n\n/**\n * Export the tree by clearing tree state and all node states,\n * and filter so that only the level zero node of interest is included.\n * @param {object} currTree A tree object.\n * @param {string} nodePath The path of the node of interest.\n * @param {string} dataType Datatype (i.e cell sets)\n * @param {Array} cellSetColors Array of objects of cell set colors and paths\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} { treeToExport, nodeName }\n * Tree with one level zero node, and with state removed.\n */\nexport function treeExportLevelZeroNode(currTree, nodePath, datatype, cellSetColors, theme) {\n  const node = treeFindNodeByNamePath(currTree, nodePath);\n  const nodeWithColors = nodeTransformAll(node, () => true, (n, nPath) => {\n    const nodeColor = cellSetColors?.find(c => isEqual(c.path, nPath))?.color\n      ?? getDefaultColor(theme);\n    return {\n      ...n,\n      color: nodeColor.slice(0, 3),\n    };\n  }, []);\n  const treeWithOneLevelZeroNode = {\n    ...currTree,\n    tree: [nodeWithColors],\n  };\n  return {\n    treeToExport: treeExport(treeWithOneLevelZeroNode, datatype),\n    nodeName: node.name,\n  };\n}\n\n/**\n * Prepare the set of a node of interest for export.\n * @param {object} currTree A tree object.\n * @param {string} nodeKey The key of the node of interest.\n * @returns {object} { setToExport, nodeName } The set as an array.\n */\nexport function treeExportSet(currTree, nodePath) {\n  const node = treeFindNodeByNamePath(currTree, nodePath);\n  return { setToExport: nodeToSet(node), nodeName: node.name };\n}\n\n/**\n * Get an empty tree, with a default tree state.\n * @param {string} datatype The type of sets that this tree contains.\n * @returns {object} Empty tree.\n */\nexport function treeInitialize(datatype) {\n  return {\n    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n    datatype,\n    tree: [],\n  };\n}\n\n/**\n * For convenience, get an object with information required\n * to render a node as a component.\n * @param {object} node A node to be rendered.\n * @returns {object} An object containing properties required\n * by the TreeNode render functions.\n */\nexport function nodeToRenderProps(node, path, cellSetColor) {\n  const level = path.length - 1;\n  return {\n    title: node.name,\n    nodeKey: pathToKey(path),\n    path,\n    size: getNodeLength(node),\n    color: cellSetColor?.find(d => isEqual(d.path, path))?.color,\n    level,\n    isLeaf: (!node.children || node.children.length === 0) && Boolean(node.set),\n    height: nodeToHeight(node),\n  };\n}\n\n/**\n * Using a color and a probability, mix the color with an \"uncertainty\" color,\n * for example, gray.\n * Reference: https://github.com/bgrins/TinyColor/blob/80f7225029c428c0de0757f7d98ac15f497bee57/tinycolor.js#L701\n * @param {number[]} originalColor The color assignment for the class.\n * @param {number} p The mixing amount, or level certainty in the originalColor classification,\n * between 0 and 1.\n * @param {number[]} mixingColor The color with which to mix. By default, [128, 128, 128] gray.\n * @returns {number[]} Returns the color after mixing.\n */\nfunction colorMixWithUncertainty(originalColor, p, mixingColor = [128, 128, 128]) {\n  return [\n    ((originalColor[0] - mixingColor[0]) * p) + mixingColor[0],\n    ((originalColor[1] - mixingColor[1]) * p) + mixingColor[1],\n    ((originalColor[2] - mixingColor[2]) * p) + mixingColor[2],\n  ];\n}\n\n/**\n * Given a tree with state, get the cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n *  @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} cellSetColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {array} Tuple of [cellIds, cellColors]\n * where cellIds is an array of strings,\n * and cellColors is an object mapping cellIds to color [r,g,b] arrays.\n */\nexport function treeToCellColorsBySetNames(currTree, selectedNamePaths, cellSetColor, theme) {\n  let cellColorsArray = [];\n  selectedNamePaths.forEach((setNamePath) => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (\n        cellSetColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme)\n      );\n      cellColorsArray = [\n        ...cellColorsArray,\n        ...nodeSet.map(([cellId, prob]) => [\n          cellId,\n          (isNil(prob) ? nodeColor : colorMixWithUncertainty(nodeColor, prob)),\n        ]),\n      ];\n    }\n  });\n  return new Map(cellColorsArray);\n}\n\n/**\n * Given a tree with state, get an array of\n * objects with cellIds and cellColors,\n * based on the nodes currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme.\n * @returns {object[]} Array of objects with properties\n * `obsId`, `name`, and `color`.\n */\nexport function treeToObjectsBySetNames(currTree, selectedNamePaths, setColor, theme) {\n  let cellsArray = [];\n  for (let i = 0; i < selectedNamePaths.length; i += 1) {\n    const setNamePath = selectedNamePaths[i];\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (\n        setColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme)\n      );\n      cellsArray = cellsArray.concat(nodeSet.map(([cellId]) => ({\n        obsId: cellId,\n        name: node.name,\n        color: nodeColor,\n      })));\n    }\n  }\n  return cellsArray;\n}\n\nexport function treeToCellPolygonsBySetNames(\n  currTree, cells, mapping, selectedNamePaths, cellSetColor, theme,\n) {\n  const cellSetPolygons = [];\n  selectedNamePaths.forEach((setNamePath) => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = (\n        cellSetColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme)\n      );\n      const cellPositions = nodeSet\n        .map(([cellId]) => ([\n          cells[cellId]?.mappings[mapping][0],\n          -cells[cellId]?.mappings[mapping][1],\n        ]))\n        .filter(cell => cell.every(i => typeof i === 'number'));\n\n      if (cellPositions.length > 2) {\n        const points = turfFeatureCollection(\n          cellPositions.map(turfPoint),\n        );\n        const concavity = Infinity;\n        const hullCoords = concaveman(cellPositions, concavity);\n        if (hullCoords) {\n          const centroidCoords = centroid(points).geometry.coordinates;\n          cellSetPolygons.push({\n            path: setNamePath,\n            name: setNamePath[setNamePath.length - 1],\n            hull: hullCoords,\n            color: nodeColor,\n            centroid: centroidCoords,\n          });\n        }\n      }\n    }\n  });\n  return cellSetPolygons;\n}\n\n/**\n * Given a tree with state, get the sizes of the\n * sets currently marked as \"visible\".\n * @param {object} currTree A tree object.\n * @param {array} selectedNamePaths Array of arrays of strings,\n * representing set \"paths\".\n * @param {object[]} setColor Array of objects with the\n * properties `path` and `color`.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object[]} Array of objects\n * with the properties `name`, `size`, `key`,\n * and `color`.\n */\nexport function treeToSetSizesBySetNames(currTree, selectedNamePaths, setColor, theme) {\n  const sizes = [];\n  selectedNamePaths.forEach((setNamePath) => {\n    const node = treeFindNodeByNamePath(currTree, setNamePath);\n    if (node) {\n      const nodeSet = nodeToSet(node);\n      const nodeColor = setColor?.find(d => isEqual(d.path, setNamePath))?.color\n        || getDefaultColor(theme);\n      sizes.push({\n        key: generateKey(),\n        name: node.name,\n        size: nodeSet.length,\n        color: nodeColor,\n      });\n    }\n  });\n  return sizes;\n}\n\n/**\n * Find and remove a node from the descendants of the current node.\n * @param {object} node A node to search on.\n * @param {array} prevPath Path of the current node to be searched.\n * @param {array} filterPath The path sought.\n * @returns {object} A new node without a node at filterPath.\n */\nexport function filterNode(node, prevPath, filterPath) {\n  if (isEqual([...prevPath, node.name], filterPath)) {\n    return null;\n  }\n  if (!node.children) {\n    return node;\n  }\n  return {\n    ...node,\n    children: node.children.map(\n      c => filterNode(c, [...prevPath, node.name], filterPath),\n    ).filter(Boolean),\n  };\n}\n\nexport function treeToExpectedCheckedLevel(currTree, checkedPaths) {\n  let result = null;\n  if (currTree) {\n    currTree.tree.forEach((lzn) => {\n      const levelZeroPath = [lzn.name];\n      const height = nodeToHeight(lzn);\n      range(height).forEach((i) => {\n        const levelIndex = i + 1;\n        const levelNodePaths = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);\n        if (isEqual(levelNodePaths, checkedPaths)) {\n          result = { levelZeroPath, levelIndex };\n        }\n      });\n    });\n  }\n  return result;\n}\n\nexport function treesConflict(cellSets, testCellSets) {\n  const paths = [];\n  const testPaths = [];\n  let hasConflict = false;\n\n  function getPaths(node, prevPath) {\n    paths.push([...prevPath, node.name]);\n    if (node.children) {\n      node.children.forEach(c => getPaths(c, [...prevPath, node.name]));\n    }\n  }\n  cellSets.tree.forEach(lzn => getPaths(lzn, []));\n\n  function getTestPaths(node, prevPath) {\n    testPaths.push([...prevPath, node.name]);\n    if (node.children) {\n      node.children.forEach(c => getPaths(c, [...prevPath, node.name]));\n    }\n  }\n  testCellSets.tree.forEach(lzn => getTestPaths(lzn, []));\n\n  testPaths.forEach((testPath) => {\n    if (paths.find(p => isEqual(p, testPath))) {\n      hasConflict = true;\n    }\n  });\n  return hasConflict;\n}\n\nexport function initializeCellSetColor(cellSets, cellSetColor) {\n  const nextCellSetColor = [...(cellSetColor || [])];\n  const nodeCountPerTreePerLevel = cellSets.tree.map(tree => Array\n    .from({\n      length: nodeToHeight(tree) + 1, // Need to add one because its an array.\n    }).fill(0));\n\n  function processNode(node, prevPath, hierarchyLevel, treeIndex) {\n    const index = nodeCountPerTreePerLevel[treeIndex][hierarchyLevel];\n    const nodePath = [...prevPath, node.name];\n\n    const nodeColor = nextCellSetColor.find(d => isEqual(d.path, nodePath));\n    if (!nodeColor) {\n      // If there is a color for the node specified via the cell set tree,\n      // then use it. Otherwise, use a color from the default color palette.\n      const nodeColorArray = (node.color ? node.color : PALETTE[index % PALETTE.length]);\n      nextCellSetColor.push({\n        path: nodePath,\n        color: nodeColorArray,\n      });\n    }\n    nodeCountPerTreePerLevel[treeIndex][hierarchyLevel] += 1;\n    if (node.children) {\n      node.children.forEach(c => processNode(c, nodePath, hierarchyLevel + 1, treeIndex));\n    }\n  }\n\n  cellSets.tree.forEach((lzn, treeIndex) => processNode(lzn, [], 0, treeIndex));\n  return nextCellSetColor;\n}\n\nexport function getCellSetPolygons(params) {\n  const {\n    cells,\n    mapping,\n    cellSets,\n    cellSetSelection,\n    cellSetColor,\n    theme,\n  } = params;\n  if (cellSetSelection && cellSetSelection.length > 0 && cellSets && cells) {\n    return treeToCellPolygonsBySetNames(\n      cellSets, cells, mapping, cellSetSelection, cellSetColor, theme,\n    );\n  }\n  return [];\n}\n"]},"metadata":{},"sourceType":"module"}