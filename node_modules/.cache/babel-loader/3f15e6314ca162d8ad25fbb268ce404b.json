{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { vgField } from '../../channeldef';\nimport { getTimeUnitParts, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class TimeUnitNode extends DataFlowNode {\n  constructor(parent, formula) {\n    super(parent);\n    this.formula = formula;\n  }\n\n  clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {\n      const {\n        field,\n        timeUnit\n      } = fieldDef;\n\n      if (timeUnit) {\n        const as = vgField(fieldDef, {\n          forAs: true\n        });\n        timeUnitComponent[hash({\n          as,\n          field,\n          timeUnit\n        })] = {\n          as,\n          field,\n          timeUnit\n        };\n      }\n\n      return timeUnitComponent;\n    }, {});\n\n    if (isEmpty(formula)) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  static makeFromTransform(parent, t) {\n    const _a = Object.assign({}, t),\n          {\n      timeUnit\n    } = _a,\n          other = __rest(_a, [\"timeUnit\"]);\n\n    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n    const component = Object.assign(Object.assign({}, other), {\n      timeUnit: normalizedTimeUnit\n    });\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n\n\n  merge(other) {\n    this.formula = Object.assign({}, this.formula); // if the same hash happen twice, merge\n\n    for (const key in other.formula) {\n      if (!this.formula[key]) {\n        // copy if it's not a duplicate\n        this.formula[key] = other.formula[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n  /**\n   * Remove time units coming from the other node.\n   */\n\n\n  removeFormulas(fields) {\n    const newFormula = {};\n\n    for (const [key, timeUnit] of entries(this.formula)) {\n      if (!fields.has(timeUnit.as)) {\n        newFormula[key] = timeUnit;\n      }\n    }\n\n    this.formula = newFormula;\n  }\n\n  producedFields() {\n    return new Set(vals(this.formula).map(f => f.as));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n\n  hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n\n  assemble() {\n    const transforms = [];\n\n    for (const f of vals(this.formula)) {\n      const {\n        field,\n        as,\n        timeUnit\n      } = f;\n\n      const _a = normalizeTimeUnit(timeUnit),\n            {\n        unit,\n        utc\n      } = _a,\n            params = __rest(_a, [\"unit\", \"utc\"]);\n\n      transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({\n        field: replacePathInField(field),\n        type: 'timeunit'\n      }, unit ? {\n        units: getTimeUnitParts(unit)\n      } : {}), utc ? {\n        timezone: 'utc'\n      } : {}), params), {\n        as: [as, `${as}_end`]\n      }));\n    }\n\n    return transforms;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/timeunit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { vgField } from '../../channeldef';\nimport { getTimeUnitParts, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class TimeUnitNode extends DataFlowNode {\n    constructor(parent, formula) {\n        super(parent);\n        this.formula = formula;\n    }\n    clone() {\n        return new TimeUnitNode(null, duplicate(this.formula));\n    }\n    static makeFromEncoding(parent, model) {\n        const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {\n            const { field, timeUnit } = fieldDef;\n            if (timeUnit) {\n                const as = vgField(fieldDef, { forAs: true });\n                timeUnitComponent[hash({\n                    as,\n                    field,\n                    timeUnit\n                })] = {\n                    as,\n                    field,\n                    timeUnit\n                };\n            }\n            return timeUnitComponent;\n        }, {});\n        if (isEmpty(formula)) {\n            return null;\n        }\n        return new TimeUnitNode(parent, formula);\n    }\n    static makeFromTransform(parent, t) {\n        const _a = Object.assign({}, t), { timeUnit } = _a, other = __rest(_a, [\"timeUnit\"]);\n        const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n        const component = Object.assign(Object.assign({}, other), { timeUnit: normalizedTimeUnit });\n        return new TimeUnitNode(parent, {\n            [hash(component)]: component\n        });\n    }\n    /**\n     * Merge together TimeUnitNodes assigning the children of `other` to `this`\n     * and removing `other`.\n     */\n    merge(other) {\n        this.formula = Object.assign({}, this.formula);\n        // if the same hash happen twice, merge\n        for (const key in other.formula) {\n            if (!this.formula[key]) {\n                // copy if it's not a duplicate\n                this.formula[key] = other.formula[key];\n            }\n        }\n        for (const child of other.children) {\n            other.removeChild(child);\n            child.parent = this;\n        }\n        other.remove();\n    }\n    /**\n     * Remove time units coming from the other node.\n     */\n    removeFormulas(fields) {\n        const newFormula = {};\n        for (const [key, timeUnit] of entries(this.formula)) {\n            if (!fields.has(timeUnit.as)) {\n                newFormula[key] = timeUnit;\n            }\n        }\n        this.formula = newFormula;\n    }\n    producedFields() {\n        return new Set(vals(this.formula).map(f => f.as));\n    }\n    dependentFields() {\n        return new Set(vals(this.formula).map(f => f.field));\n    }\n    hash() {\n        return `TimeUnit ${hash(this.formula)}`;\n    }\n    assemble() {\n        const transforms = [];\n        for (const f of vals(this.formula)) {\n            const { field, as, timeUnit } = f;\n            const _a = normalizeTimeUnit(timeUnit), { unit, utc } = _a, params = __rest(_a, [\"unit\", \"utc\"]);\n            transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({ field: replacePathInField(field), type: 'timeunit' }, (unit ? { units: getTimeUnitParts(unit) } : {})), (utc ? { timezone: 'utc' } : {})), params), { as: [as, `${as}_end`] }));\n        }\n        return transforms;\n    }\n}\n//# sourceMappingURL=timeunit.js.map"]},"metadata":{},"sourceType":"module"}