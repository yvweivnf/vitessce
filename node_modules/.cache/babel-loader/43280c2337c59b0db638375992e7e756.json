{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { hasOwnProperty } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { replaceExprRef } from '../../expr';\nimport { PROJECTION_PROPERTIES } from '../../projection';\nimport { GEOJSON } from '../../type';\nimport { deepEqual, duplicate, every } from '../../util';\nimport { isUnitModel } from '../model';\nimport { ProjectionComponent } from './component';\nexport function parseProjection(model) {\n  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\n\nfunction parseUnitProjection(model) {\n  var _a;\n\n  if (model.hasProjection) {\n    var proj = replaceExprRef(model.specifiedProjection);\n    var fit = !(proj && (proj.scale != null || proj.translate != null));\n    var size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n    var data = fit ? gatherFitData(model) : undefined;\n    var projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {}), proj !== null && proj !== void 0 ? proj : {}), size, data);\n\n    if (!projComp.get('type')) {\n      projComp.set('type', 'equalEarth', false);\n    }\n\n    return projComp;\n  }\n\n  return undefined;\n}\n\nfunction gatherFitData(model) {\n  var data = [];\n  var encoding = model.encoding;\n\n  for (var _i = 0, _arr = [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]; _i < _arr.length; _i++) {\n    var posssiblePair = _arr[_i];\n\n    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {\n      data.push({\n        signal: model.getName(\"geojson_\".concat(data.length))\n      });\n    }\n  }\n\n  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {\n    data.push({\n      signal: model.getName(\"geojson_\".concat(data.length))\n    });\n  }\n\n  if (data.length === 0) {\n    // main source is geojson, so we can just use that\n    data.push(model.requestDataName(DataSourceType.Main));\n  }\n\n  return data;\n}\n\nfunction mergeIfNoConflict(first, second) {\n  var allPropertiesShared = every(PROJECTION_PROPERTIES, function (prop) {\n    // neither has the property\n    if (!hasOwnProperty(first.explicit, prop) && !hasOwnProperty(second.explicit, prop)) {\n      return true;\n    } // both have property and an equal value for property\n\n\n    if (hasOwnProperty(first.explicit, prop) && hasOwnProperty(second.explicit, prop) && // some properties might be signals or objects and require hashing for comparison\n    deepEqual(first.get(prop), second.get(prop))) {\n      return true;\n    }\n\n    return false;\n  });\n  var size = deepEqual(first.size, second.size);\n\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (deepEqual(first.explicit, {})) {\n      return second;\n    } else if (deepEqual(second.explicit, {})) {\n      return first;\n    }\n  } // if all properties don't match, let each unit spec have its own projection\n\n\n  return null;\n}\n\nfunction parseNonUnitProjections(model) {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  var nonUnitProjection; // parse all children first\n\n  var _iterator = _createForOfIteratorHelper(model.children),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _child = _step.value;\n      parseProjection(_child);\n    } // analyze parsed projections, attempt to merge\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var mergable = every(model.children, function (child) {\n    var projection = child.component.projection;\n\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      var merge = mergeIfNoConflict(nonUnitProjection, projection);\n\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n\n      return !!merge;\n    }\n  }); // if cached one and all other children share the same projection,\n\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    var name = model.projectionName(true);\n    var modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data)); // rename and assign all others as merged\n\n    var _iterator2 = _createForOfIteratorHelper(model.children),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var child = _step2.value;\n        var projection = child.component.projection;\n\n        if (projection) {\n          if (projection.isFit) {\n            var _modelProjection$data;\n\n            (_modelProjection$data = modelProjection.data).push.apply(_modelProjection$data, _toConsumableArray(child.component.projection.data));\n          }\n\n          child.renameProjection(projection.get('name'), name);\n          projection.merged = true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return modelProjection;\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/projection/parse.ts"],"names":[],"mappings":";;AACA,SAAQ,cAAR,QAA6B,WAA7B;AACA,SAAQ,QAAR,EAAkB,SAAlB,EAA6B,SAA7B,EAAwC,UAAxC,EAAoD,KAApD,QAAgE,eAAhE;AACA,SAAQ,kBAAR,QAAiC,kBAAjC;AACA,SAAQ,cAAR,QAA6B,YAA7B;AACA,SAAQ,cAAR,QAA6B,YAA7B;AACA,SAAQ,qBAAR,QAAoC,kBAApC;AACA,SAAQ,OAAR,QAAsB,YAAtB;AACA,SAAQ,SAAR,EAAmB,SAAnB,EAA8B,KAA9B,QAA0C,YAA1C;AACA,SAAQ,WAAR,QAAiC,UAAjC;AAEA,SAAQ,mBAAR,QAAkC,aAAlC;AAEA,OAAM,SAAU,eAAV,CAA0B,KAA1B,EAAsC;AAC1C,EAAA,KAAK,CAAC,SAAN,CAAgB,UAAhB,GAA6B,WAAW,CAAC,KAAD,CAAX,GAAqB,mBAAmB,CAAC,KAAD,CAAxC,GAAkD,uBAAuB,CAAC,KAAD,CAAtG;AACD;;AAED,SAAS,mBAAT,CAA6B,KAA7B,EAA6C;;;AAC3C,MAAI,KAAK,CAAC,aAAV,EAAyB;AACvB,QAAM,IAAI,GAAG,cAAc,CAAC,KAAK,CAAC,mBAAP,CAA3B;AACA,QAAM,GAAG,GAAG,EAAE,IAAI,KAAK,IAAI,CAAC,KAAL,IAAc,IAAd,IAAsB,IAAI,CAAC,SAAL,IAAkB,IAA7C,CAAN,CAAZ;AACA,QAAM,IAAI,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,gBAAN,CAAuB,OAAvB,CAAD,EAAkC,KAAK,CAAC,gBAAN,CAAuB,QAAvB,CAAlC,CAAH,GAAyE,SAAzF;AACA,QAAM,IAAI,GAAG,GAAG,GAAG,aAAa,CAAC,KAAD,CAAhB,GAA0B,SAA1C;AAEA,QAAM,QAAQ,GAAG,IAAI,mBAAJ,CACf,KAAK,CAAC,cAAN,CAAqB,IAArB,CADe,EACW,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAEpB,CAAA,EAAA,GAAA,cAAc,CAAC,KAAK,CAAC,MAAN,CAAa,UAAd,CAAd,MAAuC,IAAvC,IAAuC,EAAA,KAAA,KAAA,CAAvC,GAAuC,EAAvC,GAA2C,EAFvB,CAAA,EAGpB,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAA,IAAA,GAAQ,EAHY,CADX,EAMf,IANe,EAOf,IAPe,CAAjB;;AAUA,QAAI,CAAC,QAAQ,CAAC,GAAT,CAAa,MAAb,CAAL,EAA2B;AACzB,MAAA,QAAQ,CAAC,GAAT,CAAa,MAAb,EAAqB,YAArB,EAAmC,KAAnC;AACD;;AAED,WAAO,QAAP;AACD;;AAED,SAAO,SAAP;AACD;;AAED,SAAS,aAAT,CAAuB,KAAvB,EAAuC;AACrC,MAAM,IAAI,GAA2B,EAArC;AADqC,MAG9B,QAH8B,GAGlB,KAHkB,CAG9B,QAH8B;;AAKrC,0BAA4B,CAC1B,CAAC,SAAD,EAAY,QAAZ,CAD0B,EAE1B,CAAC,UAAD,EAAa,SAAb,CAF0B,CAA5B,0BAGG;AAHE,QAAM,aAAa,WAAnB;;AAIH,QAAI,kBAAkB,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAD,CAAd,CAAT,CAAlB,IAAkD,kBAAkB,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAD,CAAd,CAAT,CAAxE,EAAsG;AACpG,MAAA,IAAI,CAAC,IAAL,CAAU;AACR,QAAA,MAAM,EAAE,KAAK,CAAC,OAAN,mBAAyB,IAAI,CAAC,MAA9B;AADA,OAAV;AAGD;AACF;;AAED,MAAI,KAAK,CAAC,eAAN,CAAsB,KAAtB,KAAgC,KAAK,CAAC,aAAN,CAAoB,KAApB,EAA2B,IAA3B,KAAoC,OAAxE,EAAiF;AAC/E,IAAA,IAAI,CAAC,IAAL,CAAU;AACR,MAAA,MAAM,EAAE,KAAK,CAAC,OAAN,mBAAyB,IAAI,CAAC,MAA9B;AADA,KAAV;AAGD;;AAED,MAAI,IAAI,CAAC,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACA,IAAA,IAAI,CAAC,IAAL,CAAU,KAAK,CAAC,eAAN,CAAsB,cAAc,CAAC,IAArC,CAAV;AACD;;AAED,SAAO,IAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,KAA3B,EAAuD,MAAvD,EAAkF;AAChF,MAAM,mBAAmB,GAAG,KAAK,CAAC,qBAAD,EAAwB,UAAA,IAAI,EAAG;AAC9D;AACA,QAAI,CAAC,cAAc,CAAC,KAAK,CAAC,QAAP,EAAiB,IAAjB,CAAf,IAAyC,CAAC,cAAc,CAAC,MAAM,CAAC,QAAR,EAAkB,IAAlB,CAA5D,EAAqF;AACnF,aAAO,IAAP;AACD,KAJ6D,CAK9D;;;AACA,QACE,cAAc,CAAC,KAAK,CAAC,QAAP,EAAiB,IAAjB,CAAd,IACA,cAAc,CAAC,MAAM,CAAC,QAAR,EAAkB,IAAlB,CADd,IAEA;AACA,IAAA,SAAS,CAAC,KAAK,CAAC,GAAN,CAAU,IAAV,CAAD,EAAkB,MAAM,CAAC,GAAP,CAAW,IAAX,CAAlB,CAJX,EAKE;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD,GAfgC,CAAjC;AAiBA,MAAM,IAAI,GAAG,SAAS,CAAC,KAAK,CAAC,IAAP,EAAa,MAAM,CAAC,IAApB,CAAtB;;AACA,MAAI,IAAJ,EAAU;AACR,QAAI,mBAAJ,EAAyB;AACvB,aAAO,KAAP;AACD,KAFD,MAEO,IAAI,SAAS,CAAC,KAAK,CAAC,QAAP,EAAiB,EAAjB,CAAb,EAAmC;AACxC,aAAO,MAAP;AACD,KAFM,MAEA,IAAI,SAAS,CAAC,MAAM,CAAC,QAAR,EAAkB,EAAlB,CAAb,EAAoC;AACzC,aAAO,KAAP;AACD;AACF,GA3B+E,CA6BhF;;;AACA,SAAO,IAAP;AACD;;AAED,SAAS,uBAAT,CAAiC,KAAjC,EAA6C;AAC3C,MAAI,KAAK,CAAC,QAAN,CAAe,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,WAAO,SAAP;AACD;;AAED,MAAI,iBAAJ,CAL2C,CAO3C;;AAP2C,6CAQvB,KAAK,CAAC,QARiB;AAAA;;AAAA;AAQ3C,wDAAoC;AAAA,UAAzB,MAAyB;AAClC,MAAA,eAAe,CAAC,MAAD,CAAf;AACD,KAV0C,CAY3C;;AAZ2C;AAAA;AAAA;AAAA;AAAA;;AAa3C,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,QAAP,EAAiB,UAAA,KAAK,EAAG;AAC7C,QAAM,UAAU,GAAG,KAAK,CAAC,SAAN,CAAgB,UAAnC;;AACA,QAAI,CAAC,UAAL,EAAiB;AACf;AACA,aAAO,IAAP;AACD,KAHD,MAGO,IAAI,CAAC,iBAAL,EAAwB;AAC7B;AACA,MAAA,iBAAiB,GAAG,UAApB;AACA,aAAO,IAAP;AACD,KAJM,MAIA;AACL,UAAM,KAAK,GAAG,iBAAiB,CAAC,iBAAD,EAAoB,UAApB,CAA/B;;AACA,UAAI,KAAJ,EAAW;AACT,QAAA,iBAAiB,GAAG,KAApB;AACD;;AACD,aAAO,CAAC,CAAC,KAAT;AACD;AACF,GAhBqB,CAAtB,CAb2C,CA+B3C;;AACA,MAAI,iBAAiB,IAAI,QAAzB,EAAmC;AACjC;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,cAAN,CAAqB,IAArB,CAAb;AACA,QAAM,eAAe,GAAG,IAAI,mBAAJ,CACtB,IADsB,EAEtB,iBAAiB,CAAC,mBAFI,EAGtB,iBAAiB,CAAC,IAHI,EAItB,SAAS,CAAC,iBAAiB,CAAC,IAAnB,CAJa,CAAxB,CAHiC,CAUjC;;AAViC,gDAWb,KAAK,CAAC,QAXO;AAAA;;AAAA;AAWjC,6DAAoC;AAAA,YAAzB,KAAyB;AAClC,YAAM,UAAU,GAAG,KAAK,CAAC,SAAN,CAAgB,UAAnC;;AACA,YAAI,UAAJ,EAAgB;AACd,cAAI,UAAU,CAAC,KAAf,EAAsB;AAAA;;AACpB,qCAAA,eAAe,CAAC,IAAhB,EAAqB,IAArB,iDAA6B,KAAK,CAAC,SAAN,CAAgB,UAAhB,CAA2B,IAAxD;AACD;;AACD,UAAA,KAAK,CAAC,gBAAN,CAAuB,UAAU,CAAC,GAAX,CAAe,MAAf,CAAvB,EAA+C,IAA/C;AACA,UAAA,UAAU,CAAC,MAAX,GAAoB,IAApB;AACD;AACF;AApBgC;AAAA;AAAA;AAAA;AAAA;;AAsBjC,WAAO,eAAP;AACD;;AAED,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["import { hasOwnProperty } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { replaceExprRef } from '../../expr';\nimport { PROJECTION_PROPERTIES } from '../../projection';\nimport { GEOJSON } from '../../type';\nimport { deepEqual, duplicate, every } from '../../util';\nimport { isUnitModel } from '../model';\nimport { ProjectionComponent } from './component';\nexport function parseProjection(model) {\n    model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\nfunction parseUnitProjection(model) {\n    var _a;\n    if (model.hasProjection) {\n        const proj = replaceExprRef(model.specifiedProjection);\n        const fit = !(proj && (proj.scale != null || proj.translate != null));\n        const size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n        const data = fit ? gatherFitData(model) : undefined;\n        const projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, ((_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {})), (proj !== null && proj !== void 0 ? proj : {})), size, data);\n        if (!projComp.get('type')) {\n            projComp.set('type', 'equalEarth', false);\n        }\n        return projComp;\n    }\n    return undefined;\n}\nfunction gatherFitData(model) {\n    const data = [];\n    const { encoding } = model;\n    for (const posssiblePair of [\n        [LONGITUDE, LATITUDE],\n        [LONGITUDE2, LATITUDE2]\n    ]) {\n        if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {\n            data.push({\n                signal: model.getName(`geojson_${data.length}`)\n            });\n        }\n    }\n    if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {\n        data.push({\n            signal: model.getName(`geojson_${data.length}`)\n        });\n    }\n    if (data.length === 0) {\n        // main source is geojson, so we can just use that\n        data.push(model.requestDataName(DataSourceType.Main));\n    }\n    return data;\n}\nfunction mergeIfNoConflict(first, second) {\n    const allPropertiesShared = every(PROJECTION_PROPERTIES, prop => {\n        // neither has the property\n        if (!hasOwnProperty(first.explicit, prop) && !hasOwnProperty(second.explicit, prop)) {\n            return true;\n        }\n        // both have property and an equal value for property\n        if (hasOwnProperty(first.explicit, prop) &&\n            hasOwnProperty(second.explicit, prop) &&\n            // some properties might be signals or objects and require hashing for comparison\n            deepEqual(first.get(prop), second.get(prop))) {\n            return true;\n        }\n        return false;\n    });\n    const size = deepEqual(first.size, second.size);\n    if (size) {\n        if (allPropertiesShared) {\n            return first;\n        }\n        else if (deepEqual(first.explicit, {})) {\n            return second;\n        }\n        else if (deepEqual(second.explicit, {})) {\n            return first;\n        }\n    }\n    // if all properties don't match, let each unit spec have its own projection\n    return null;\n}\nfunction parseNonUnitProjections(model) {\n    if (model.children.length === 0) {\n        return undefined;\n    }\n    let nonUnitProjection;\n    // parse all children first\n    for (const child of model.children) {\n        parseProjection(child);\n    }\n    // analyze parsed projections, attempt to merge\n    const mergable = every(model.children, child => {\n        const projection = child.component.projection;\n        if (!projection) {\n            // child layer does not use a projection\n            return true;\n        }\n        else if (!nonUnitProjection) {\n            // cached 'projection' is null, cache this one\n            nonUnitProjection = projection;\n            return true;\n        }\n        else {\n            const merge = mergeIfNoConflict(nonUnitProjection, projection);\n            if (merge) {\n                nonUnitProjection = merge;\n            }\n            return !!merge;\n        }\n    });\n    // if cached one and all other children share the same projection,\n    if (nonUnitProjection && mergable) {\n        // so we can elevate it to the layer level\n        const name = model.projectionName(true);\n        const modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));\n        // rename and assign all others as merged\n        for (const child of model.children) {\n            const projection = child.component.projection;\n            if (projection) {\n                if (projection.isFit) {\n                    modelProjection.data.push(...child.component.projection.data);\n                }\n                child.renameProjection(projection.get('name'), name);\n                projection.merged = true;\n            }\n        }\n        return modelProjection;\n    }\n    return undefined;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}