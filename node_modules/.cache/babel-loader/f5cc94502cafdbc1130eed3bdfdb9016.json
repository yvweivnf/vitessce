{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nvar DEFAULT_MINCOLOR = [0, 0, 0, 0];\nvar DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nvar COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nvar defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nvar ScreenGridCellLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(ScreenGridCellLayer, _Layer);\n\n  var _super = _createSuper(ScreenGridCellLayer);\n\n  function ScreenGridCellLayer() {\n    _classCallCheck(this, ScreenGridCellLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ScreenGridCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [picking]\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          update: this.calculateInstancePositions\n        },\n        instanceCounts: {\n          size: 4,\n          noAlloc: true\n        }\n      });\n      this.setState({\n        model: this._getModel(gl)\n      });\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      _get(_getPrototypeOf(ScreenGridCellLayer.prototype), \"updateState\", this).call(this, {\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n\n      if (props.numInstances !== oldProps.numInstances) {\n        attributeManager.invalidateAll();\n      } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n        attributeManager.invalidate('instancePositions');\n      }\n\n      this._updateUniforms(oldProps, props, changeFlags);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var _this$props = this.props,\n          parameters = _this$props.parameters,\n          maxTexture = _this$props.maxTexture;\n      var minColor = this.props.minColor || DEFAULT_MINCOLOR;\n      var maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n      var colorDomain = this.props.colorDomain || [1, 0];\n      var model = this.state.model;\n      model.setUniforms(uniforms).setUniforms({\n        minColor: minColor,\n        maxColor: maxColor,\n        maxTexture: maxTexture,\n        colorDomain: colorDomain\n      }).draw({\n        parameters: _objectSpread({\n          depthTest: false,\n          depthMask: false\n        }, parameters)\n      });\n    }\n  }, {\n    key: \"calculateInstancePositions\",\n    value: function calculateInstancePositions(attribute, _ref4) {\n      var numInstances = _ref4.numInstances;\n      var _this$context$viewpor = this.context.viewport,\n          width = _this$context$viewpor.width,\n          height = _this$context$viewpor.height;\n      var cellSizePixels = this.props.cellSizePixels;\n      var numCol = Math.ceil(width / cellSizePixels);\n      var value = attribute.value,\n          size = attribute.size;\n\n      for (var i = 0; i < numInstances; i++) {\n        var x = i % numCol;\n        var y = Math.floor(i / numCol);\n        value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n        value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n        value[i * size + 2] = 0;\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, _objectSpread({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 6,\n          attributes: {\n            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"_shouldUseMinMax\",\n    value: function _shouldUseMinMax() {\n      var _this$props2 = this.props,\n          minColor = _this$props2.minColor,\n          maxColor = _this$props2.maxColor,\n          colorDomain = _this$props2.colorDomain,\n          colorRange = _this$props2.colorRange;\n\n      if (minColor || maxColor) {\n        log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n        return true;\n      }\n\n      if (colorDomain || colorRange) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_updateUniforms\",\n    value: function _updateUniforms(oldProps, props, changeFlags) {\n      var model = this.state.model;\n\n      if (COLOR_PROPS.some(function (key) {\n        return oldProps[key] !== props[key];\n      })) {\n        model.setUniforms({\n          shouldUseMinMax: this._shouldUseMinMax()\n        });\n      }\n\n      if (oldProps.colorRange !== props.colorRange) {\n        model.setUniforms({\n          colorRange: colorRangeToFlatArray(props.colorRange)\n        });\n      }\n\n      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n        var _this$context$viewpor2 = this.context.viewport,\n            width = _this$context$viewpor2.width,\n            height = _this$context$viewpor2.height;\n        var _this$props3 = this.props,\n            cellSizePixels = _this$props3.cellSizePixels,\n            cellMarginPixels = _this$props3.cellMarginPixels;\n        var margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n        var cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n        model.setUniforms({\n          cellScale: cellScale\n        });\n      }\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n    }\n  }]);\n\n  return ScreenGridCellLayer;\n}(Layer);\n\nexport { ScreenGridCellLayer as default };\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/screen-grid-layer/screen-grid-cell-layer.js"],"names":["DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","defaultColorRange","hasFeatures","FEATURES","vs","fs","modules","gl","attributeManager","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","model","changeFlags","oldProps","props","uniforms","maxTexture","minColor","maxColor","parameters","depthTest","depthMask","numInstances","height","numCol","Math","width","i","x","y","id","geometry","drawMode","attributes","positions","isInstanced","log","key","shouldUseMinMax","colorRangeToFlatArray","margin","cellScale","ScreenGridCellLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {Layer, log, picking} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];\n\nconst defaultProps = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({oldProps, props, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    model\n      .setUniforms(uniforms)\n      .setUniforms({\n        minColor,\n        maxColor,\n        maxTexture,\n        colorDomain\n      })\n      .draw({\n        parameters: {\n          depthTest: false,\n          depthMask: false,\n          ...parameters\n        }\n      });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl) {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}