{"ast":null,"code":"export function classifyRings(rings) {\n  const len = rings.length;\n  if (len <= 1) return [rings];\n  const polygons = [];\n  let polygon;\n  let ccw;\n\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n    if (area === 0) continue;\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) polygons.push(polygon);\n      polygon = [rings[i]];\n    } else if (polygon) polygon.push(rings[i]);\n  }\n\n  if (polygon) polygons.push(polygon);\n  return polygons;\n}\nexport function signedArea(ring) {\n  let sum = 0;\n\n  for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n  }\n\n  return sum;\n}\nexport function readFeature(tag, feature, pbf) {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();else if (tag === 2) readTag(pbf, feature);else if (tag === 3) feature.type = pbf.readVarint();else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\nexport function readTag(pbf, feature) {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n\n    const value = feature._values[pbf.readVarint()];\n\n    feature.properties[key] = value;\n  }\n}","map":{"version":3,"sources":["../../../src/helpers/mapbox-util-functions.ts"],"names":["len","rings","polygons","i","area","signedArea","ccw","polygon","sum","j","ring","p1","p2","feature","tag","pbf","readTag","end","key","value"],"mappings":"AASA,OAAO,SAAA,aAAA,CAAA,KAAA,EAAiD;AACtD,QAAMA,GAAG,GAAGC,KAAK,CAAjB,MAAA;AAEA,MAAID,GAAG,IAAP,CAAA,EAAc,OAAO,CAAP,KAAO,CAAP;AAEd,QAAME,QAAsB,GAA5B,EAAA;AACA,MAAA,OAAA;AACA,MAAA,GAAA;;AAEA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,GAAA,EAAyBA,CAAzB,EAAA,EAA8B;AAC5B,UAAMC,IAAI,GAAGC,UAAU,CAACJ,KAAK,CAA7B,CAA6B,CAAN,CAAvB;AACA,QAAIG,IAAI,KAAR,CAAA,EAAgB;AAEhB,QAAIE,GAAG,KAAP,SAAA,EAAuBA,GAAG,GAAGF,IAAI,GAAVE,CAAAA;;AAEvB,QAAIA,GAAG,KAAKF,IAAI,GAAhB,CAAA,EAAsB;AACpB,UAAA,OAAA,EAAaF,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AACbK,MAAAA,OAAO,GAAG,CAACN,KAAK,CAAhBM,CAAgB,CAAN,CAAVA;AAFF,KAAA,MAGO,IAAA,OAAA,EAAaA,OAAO,CAAPA,IAAAA,CAAaN,KAAK,CAAlBM,CAAkB,CAAlBA;AACrB;;AACD,MAAA,OAAA,EAAaL,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AAEb,SAAA,QAAA;AACD;AAOD,OAAO,SAAA,UAAA,CAAA,IAAA,EAAsC;AAC3C,MAAIM,GAAG,GAAP,CAAA;;AACA,OAAK,IAAIL,CAAC,GAAL,CAAA,EAAWM,CAAC,GAAGC,IAAI,CAAJA,MAAAA,GAAf,CAAA,EAAA,EAAA,EAAL,EAAA,EAAiEP,CAAC,GAAGO,IAAI,CAAzE,MAAA,EAAkFD,CAAC,GAAGN,CAAtF,EAAA,EAA2F;AACzFQ,IAAAA,EAAE,GAAGD,IAAI,CAATC,CAAS,CAATA;AACAC,IAAAA,EAAE,GAAGF,IAAI,CAATE,CAAS,CAATA;AACAJ,IAAAA,GAAG,IAAI,CAACI,EAAE,CAAFA,CAAE,CAAFA,GAAQD,EAAE,CAAX,CAAW,CAAX,KAAmBA,EAAE,CAAFA,CAAE,CAAFA,GAAQC,EAAE,CAApCJ,CAAoC,CAA7B,CAAPA;AACD;;AACD,SAAA,GAAA;AACD;AAQD,OAAO,SAAA,WAAA,CAAA,GAAA,EAAA,OAAA,EAAA,GAAA,EAAqF;AAC1F,MAAIK,OAAO,IAAX,GAAA,EAAoB;AAClB,QAAIC,GAAG,KAAP,CAAA,EAAeD,OAAO,CAAPA,EAAAA,GAAaE,GAAG,CAA/B,UAA4BA,EAAbF,CAAf,KACK,IAAIC,GAAG,KAAP,CAAA,EAAeE,OAAO,CAAA,GAAA,EAAtB,OAAsB,CAAPA,CAAf,KACA,IAAIF,GAAG,KAAP,CAAA,EAAeD,OAAO,CAAPA,IAAAA,GAAeE,GAAG,CAAjC,UAA8BA,EAAfF,CAAf,KACA,IAAIC,GAAG,KAAP,CAAA,EAAeD,OAAO,CAAPA,SAAAA,GAAoBE,GAAG,CAAvBF,GAAAA;AACrB;AACF;AAOD,OAAO,SAAA,OAAA,CAAA,GAAA,EAAA,OAAA,EAAkE;AACvE,QAAMI,GAAG,GAAGF,GAAG,CAAHA,UAAAA,KAAmBA,GAAG,CAAlC,GAAA;;AAEA,SAAOA,GAAG,CAAHA,GAAAA,GAAP,GAAA,EAAsB;AACpB,UAAMG,GAAG,GAAGL,OAAO,CAAPA,KAAAA,CAAcE,GAAG,CAA7B,UAA0BA,EAAdF,CAAZ;;AACA,UAAMM,KAAK,GAAGN,OAAO,CAAPA,OAAAA,CAAgBE,GAAG,CAAjC,UAA8BA,EAAhBF,CAAd;;AACAA,IAAAA,OAAO,CAAPA,UAAAA,CAAAA,GAAAA,IAAAA,KAAAA;AACD;AACF","sourcesContent":["import Protobuf from 'pbf';\nimport {MvtMapboxGeometry} from '../lib/types';\nimport VectorTileFeature from '../lib/mapbox-vector-tile/vector-tile-feature';\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings\n * @returns polygons\n */\nexport function classifyRings(rings: MvtMapboxGeometry) {\n  const len = rings.length;\n\n  if (len <= 1) return [rings];\n\n  const polygons: number[][][] = [];\n  let polygon: number[][] | undefined;\n  let ccw: boolean | undefined;\n\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n    if (area === 0) continue; // eslint-disable-line no-continue\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) polygons.push(polygon);\n      polygon = [rings[i]];\n    } else if (polygon) polygon.push(rings[i]);\n  }\n  if (polygon) polygons.push(polygon);\n\n  return polygons;\n}\n\n/**\n *\n * @param ring\n * @returns sum\n */\nexport function signedArea(ring: number[][]) {\n  let sum = 0;\n  for (let i = 0, j = ring.length - 1, p1: number[], p2: number[]; i < ring.length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n  }\n  return sum;\n}\n\n/**\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag: number, feature?: VectorTileFeature, pbf?: Protobuf): void {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = pbf.readVarint();\n    else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n\n/**\n *\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf: Protobuf, feature: VectorTileFeature): void {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}