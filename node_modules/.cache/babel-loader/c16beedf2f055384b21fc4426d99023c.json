{"ast":null,"code":"import _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { FACET_CHANNELS, getPositionScaleChannel, isChannel, isScaleChannel } from '../channel';\nimport { getFieldDef, vgField as _vgField } from '../channeldef';\nimport { DataSourceType } from '../data';\nimport { forEach, reduce } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { isFacetSpec } from '../spec';\nimport { extractCompositionLayout } from '../spec/base';\nimport { extractTitleConfig, isText } from '../title';\nimport { normalizeTransform } from '../transform';\nimport { contains, duplicate, isEmpty, keys, varName } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { assembleAxes as _assembleAxes } from './axis/assemble';\nimport { signalOrValueRef } from './common';\nimport { assembleHeaderGroups, assembleLayoutTitleBand, assembleTitleGroup } from './header/assemble';\nimport { HEADER_CHANNELS } from './header/component';\nimport { sizeExpr } from './layoutsize/assemble';\nimport { getSizeTypeFromLayoutSizeType } from './layoutsize/component';\nimport { assembleLegends as _assembleLegends } from './legend/assemble';\nimport { parseLegend } from './legend/parse';\nimport { assembleProjections as _assembleProjections } from './projection/assemble';\nimport { parseProjection as _parseProjection } from './projection/parse';\nimport { assembleScales } from './scale/assemble';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { parseScales } from './scale/parse';\nimport { Split } from './split';\nexport var NameMap = /*#__PURE__*/function () {\n  function NameMap() {\n    _classCallCheck(this, NameMap);\n\n    this.nameMap = {};\n  }\n\n  _createClass(NameMap, [{\n    key: \"rename\",\n    value: function rename(oldName, newName) {\n      this.nameMap[oldName] = newName;\n    }\n  }, {\n    key: \"has\",\n    value: function has(name) {\n      return this.nameMap[name] !== undefined;\n    }\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      // If the name appears in the _nameMap, we need to read its new name.\n      // We have to loop over the dict just in case the new name also gets renamed.\n      while (this.nameMap[name] && name !== this.nameMap[name]) {\n        name = this.nameMap[name];\n      }\n\n      return name;\n    }\n  }]);\n\n  return NameMap;\n}();\n/*\n  We use type guards instead of `instanceof` as `instanceof` makes\n  different parts of the compiler depend on the actual implementation of\n  the model classes, which in turn depend on different parts of the compiler.\n  Thus, `instanceof` leads to circular dependency problems.\n\n  On the other hand, type guards only make different parts of the compiler\n  depend on the type of the model classes, but not the actual implementation.\n*/\n\nexport function isUnitModel(model) {\n  return (model === null || model === void 0 ? void 0 : model.type) === 'unit';\n}\nexport function isFacetModel(model) {\n  return (model === null || model === void 0 ? void 0 : model.type) === 'facet';\n}\nexport function isConcatModel(model) {\n  return (model === null || model === void 0 ? void 0 : model.type) === 'concat';\n}\nexport function isLayerModel(model) {\n  return (model === null || model === void 0 ? void 0 : model.type) === 'layer';\n}\nexport var Model = /*#__PURE__*/function () {\n  function Model(spec, type, parent, parentGivenName, config, resolve, view) {\n    var _this = this;\n\n    _classCallCheck(this, Model);\n\n    var _a, _b;\n\n    this.type = type;\n    this.parent = parent;\n    this.config = config;\n    /**\n     * Corrects the data references in marks after assemble.\n     */\n\n    this.correctDataNames = function (mark) {\n      // TODO: make this correct\n      var _a, _b, _c; // for normal data references\n\n\n      if ((_a = mark.from) === null || _a === void 0 ? void 0 : _a.data) {\n        mark.from.data = _this.lookupDataSource(mark.from.data);\n      } // for access to facet data\n\n\n      if ((_c = (_b = mark.from) === null || _b === void 0 ? void 0 : _b.facet) === null || _c === void 0 ? void 0 : _c.data) {\n        mark.from.facet.data = _this.lookupDataSource(mark.from.facet.data);\n      }\n\n      return mark;\n    };\n\n    this.parent = parent;\n    this.config = config;\n    this.view = replaceExprRef(view); // If name is not provided, always use parent's givenName to avoid name conflicts.\n\n    this.name = (_a = spec.name) !== null && _a !== void 0 ? _a : parentGivenName;\n    this.title = isText(spec.title) ? {\n      text: spec.title\n    } : spec.title ? replaceExprRef(spec.title) : undefined; // Shared name maps\n\n    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();\n    this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();\n    this.signalNameMap = parent ? parent.signalNameMap : new NameMap();\n    this.data = spec.data;\n    this.description = spec.description;\n    this.transforms = normalizeTransform((_b = spec.transform) !== null && _b !== void 0 ? _b : []);\n    this.layout = type === 'layer' || type === 'unit' ? {} : extractCompositionLayout(spec, type, config);\n    this.component = {\n      data: {\n        sources: parent ? parent.component.data.sources : [],\n        outputNodes: parent ? parent.component.data.outputNodes : {},\n        outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},\n        // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined\n        isFaceted: isFacetSpec(spec) || parent && parent.component.data.isFaceted && spec.data === undefined\n      },\n      layoutSize: new Split(),\n      layoutHeaders: {\n        row: {},\n        column: {},\n        facet: {}\n      },\n      mark: null,\n      resolve: Object.assign({\n        scale: {},\n        axis: {},\n        legend: {}\n      }, resolve ? duplicate(resolve) : {}),\n      selection: null,\n      scales: null,\n      projection: null,\n      axes: {},\n      legends: {}\n    };\n  }\n\n  _createClass(Model, [{\n    key: \"parse\",\n    value: function parse() {\n      this.parseScale();\n      this.parseLayoutSize(); // depends on scale\n\n      this.renameTopLevelLayoutSizeSignal();\n      this.parseSelections();\n      this.parseProjection();\n      this.parseData(); // (pathorder) depends on markDef; selection filters depend on parsed selections; depends on projection because some transforms require the finalized projection name.\n\n      this.parseAxesAndHeaders(); // depends on scale and layout size\n\n      this.parseLegends(); // depends on scale, markDef\n\n      this.parseMarkGroup(); // depends on data name, scale, layout size, axisGroup, and children's scale, axis, legend and mark.\n    }\n  }, {\n    key: \"parseScale\",\n    value: function parseScale() {\n      parseScales(this);\n    }\n  }, {\n    key: \"parseProjection\",\n    value: function parseProjection() {\n      _parseProjection(this);\n    }\n    /**\n     * Rename top-level spec's size to be just width / height, ignoring model name.\n     * This essentially merges the top-level spec's width/height signals with the width/height signals\n     * to help us reduce redundant signals declaration.\n     */\n\n  }, {\n    key: \"renameTopLevelLayoutSizeSignal\",\n    value: function renameTopLevelLayoutSizeSignal() {\n      if (this.getName('width') !== 'width') {\n        this.renameSignal(this.getName('width'), 'width');\n      }\n\n      if (this.getName('height') !== 'height') {\n        this.renameSignal(this.getName('height'), 'height');\n      }\n    }\n  }, {\n    key: \"parseLegends\",\n    value: function parseLegends() {\n      parseLegend(this);\n    }\n  }, {\n    key: \"assembleEncodeFromView\",\n    value: function assembleEncodeFromView(view) {\n      // Exclude \"style\"\n      var _ = view.style,\n          baseView = __rest(view, [\"style\"]);\n\n      var e = {};\n\n      var _iterator = _createForOfIteratorHelper(keys(baseView)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var property = _step.value;\n          var value = baseView[property];\n\n          if (value !== undefined) {\n            e[property] = signalOrValueRef(value);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return e;\n    }\n  }, {\n    key: \"assembleGroupEncodeEntry\",\n    value: function assembleGroupEncodeEntry(isTopLevel) {\n      var encodeEntry = {};\n\n      if (this.view) {\n        encodeEntry = this.assembleEncodeFromView(this.view);\n      }\n\n      if (!isTopLevel) {\n        // Descriptions are already added to the top-level description so we only need to add them to the inner views.\n        if (this.description) {\n          encodeEntry['description'] = signalOrValueRef(this.description);\n        } // For top-level spec, we can set the global width and height signal to adjust the group size.\n        // For other child specs, we have to manually set width and height in the encode entry.\n\n\n        if (this.type === 'unit' || this.type === 'layer') {\n          return Object.assign({\n            width: this.getSizeSignalRef('width'),\n            height: this.getSizeSignalRef('height')\n          }, encodeEntry !== null && encodeEntry !== void 0 ? encodeEntry : {});\n        }\n      }\n\n      return isEmpty(encodeEntry) ? undefined : encodeEntry;\n    }\n  }, {\n    key: \"assembleLayout\",\n    value: function assembleLayout() {\n      if (!this.layout) {\n        return undefined;\n      }\n\n      var _a = this.layout,\n          spacing = _a.spacing,\n          layout = __rest(_a, [\"spacing\"]);\n\n      var component = this.component,\n          config = this.config;\n      var titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);\n      return Object.assign(Object.assign(Object.assign({\n        padding: spacing\n      }, this.assembleDefaultLayout()), layout), titleBand ? {\n        titleBand: titleBand\n      } : {});\n    }\n  }, {\n    key: \"assembleDefaultLayout\",\n    value: function assembleDefaultLayout() {\n      return {};\n    }\n  }, {\n    key: \"assembleHeaderMarks\",\n    value: function assembleHeaderMarks() {\n      var layoutHeaders = this.component.layoutHeaders;\n      var headerMarks = [];\n\n      var _iterator2 = _createForOfIteratorHelper(FACET_CHANNELS),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var channel = _step2.value;\n\n          if (layoutHeaders[channel].title) {\n            headerMarks.push(assembleTitleGroup(this, channel));\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(HEADER_CHANNELS),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _channel = _step3.value;\n          headerMarks = headerMarks.concat(assembleHeaderGroups(this, _channel));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return headerMarks;\n    }\n  }, {\n    key: \"assembleAxes\",\n    value: function assembleAxes() {\n      return _assembleAxes(this.component.axes, this.config);\n    }\n  }, {\n    key: \"assembleLegends\",\n    value: function assembleLegends() {\n      return _assembleLegends(this);\n    }\n  }, {\n    key: \"assembleProjections\",\n    value: function assembleProjections() {\n      return _assembleProjections(this);\n    }\n  }, {\n    key: \"assembleTitle\",\n    value: function assembleTitle() {\n      var _a, _b, _c;\n\n      var _d = (_a = this.title) !== null && _a !== void 0 ? _a : {},\n          encoding = _d.encoding,\n          titleNoEncoding = __rest(_d, [\"encoding\"]);\n\n      var title = Object.assign(Object.assign(Object.assign({}, extractTitleConfig(this.config.title).nonMarkTitleProperties), titleNoEncoding), encoding ? {\n        encode: {\n          update: encoding\n        }\n      } : {});\n\n      if (title.text) {\n        if (contains(['unit', 'layer'], this.type)) {\n          // Unit/Layer\n          if (contains(['middle', undefined], title.anchor)) {\n            (_b = title.frame) !== null && _b !== void 0 ? _b : title.frame = 'group';\n          }\n        } else {\n          // composition with Vega layout\n          // Set title = \"start\" by default for composition as \"middle\" does not look nice\n          // https://github.com/vega/vega/issues/960#issuecomment-471360328\n          (_c = title.anchor) !== null && _c !== void 0 ? _c : title.anchor = 'start';\n        }\n\n        return isEmpty(title) ? undefined : title;\n      }\n\n      return undefined;\n    }\n    /**\n     * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.\n     */\n\n  }, {\n    key: \"assembleGroup\",\n    value: function assembleGroup() {\n      var signals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var group = {};\n      signals = signals.concat(this.assembleSignals());\n\n      if (signals.length > 0) {\n        group.signals = signals;\n      }\n\n      var layout = this.assembleLayout();\n\n      if (layout) {\n        group.layout = layout;\n      }\n\n      group.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks()); // Only include scales if this spec is top-level or if parent is facet.\n      // (Otherwise, it will be merged with upper-level's scope.)\n\n      var scales = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];\n\n      if (scales.length > 0) {\n        group.scales = scales;\n      }\n\n      var axes = this.assembleAxes();\n\n      if (axes.length > 0) {\n        group.axes = axes;\n      }\n\n      var legends = this.assembleLegends();\n\n      if (legends.length > 0) {\n        group.legends = legends;\n      }\n\n      return group;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(text) {\n      return varName((this.name ? \"\".concat(this.name, \"_\") : '') + text);\n    }\n  }, {\n    key: \"getDataName\",\n    value: function getDataName(type) {\n      return this.getName(DataSourceType[type].toLowerCase());\n    }\n    /**\n     * Request a data source name for the given data source type and mark that data source as required.\n     * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().\n     * You can lookup the correct dataset name in assemble with `lookupDataSource`.\n     */\n\n  }, {\n    key: \"requestDataName\",\n    value: function requestDataName(name) {\n      var fullName = this.getDataName(name); // Increase ref count. This is critical because otherwise we won't create a data source.\n      // We also increase the ref counts on OutputNode.getSource() calls.\n\n      var refCounts = this.component.data.outputNodeRefCounts;\n      refCounts[fullName] = (refCounts[fullName] || 0) + 1;\n      return fullName;\n    }\n  }, {\n    key: \"getSizeSignalRef\",\n    value: function getSizeSignalRef(layoutSizeType) {\n      if (isFacetModel(this.parent)) {\n        var sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);\n        var channel = getPositionScaleChannel(sizeType);\n        var scaleComponent = this.component.scales[channel];\n\n        if (scaleComponent && !scaleComponent.merged) {\n          // independent scale\n          var type = scaleComponent.get('type');\n          var range = scaleComponent.get('range');\n\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            var scaleName = scaleComponent.get('name');\n            var domain = assembleDomain(this, channel);\n            var field = getFieldFromDomain(domain);\n\n            if (field) {\n              var fieldRef = _vgField({\n                aggregate: 'distinct',\n                field: field\n              }, {\n                expr: 'datum'\n              });\n\n              return {\n                signal: sizeExpr(scaleName, scaleComponent, fieldRef)\n              };\n            } else {\n              log.warn(log.message.unknownField(channel));\n              return null;\n            }\n          }\n        }\n      }\n\n      return {\n        signal: this.signalNameMap.get(this.getName(layoutSizeType))\n      };\n    }\n    /**\n     * Lookup the name of the datasource for an output node. You probably want to call this in assemble.\n     */\n\n  }, {\n    key: \"lookupDataSource\",\n    value: function lookupDataSource(name) {\n      var node = this.component.data.outputNodes[name];\n\n      if (!node) {\n        // Name not found in map so let's just return what we got.\n        // This can happen if we already have the correct name.\n        return name;\n      }\n\n      return node.getSource();\n    }\n  }, {\n    key: \"getSignalName\",\n    value: function getSignalName(oldSignalName) {\n      return this.signalNameMap.get(oldSignalName);\n    }\n  }, {\n    key: \"renameSignal\",\n    value: function renameSignal(oldName, newName) {\n      this.signalNameMap.rename(oldName, newName);\n    }\n  }, {\n    key: \"renameScale\",\n    value: function renameScale(oldName, newName) {\n      this.scaleNameMap.rename(oldName, newName);\n    }\n  }, {\n    key: \"renameProjection\",\n    value: function renameProjection(oldName, newName) {\n      this.projectionNameMap.rename(oldName, newName);\n    }\n    /**\n     * @return scale name for a given channel after the scale has been parsed and named.\n     */\n\n  }, {\n    key: \"scaleName\",\n    value: function scaleName(originalScaleName, parse) {\n      if (parse) {\n        // During the parse phase always return a value\n        // No need to refer to rename map because a scale can't be renamed\n        // before it has the original name.\n        return this.getName(originalScaleName);\n      } // If there is a scale for the channel, it should either\n      // be in the scale component or exist in the name map\n\n\n      if ( // If there is a scale for the channel, there should be a local scale component for it\n      isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || // in the scale name map (the scale get merged by its parent)\n      this.scaleNameMap.has(this.getName(originalScaleName))) {\n        return this.scaleNameMap.get(this.getName(originalScaleName));\n      }\n\n      return undefined;\n    }\n    /**\n     * @return projection name after the projection has been parsed and named.\n     */\n\n  }, {\n    key: \"projectionName\",\n    value: function projectionName(parse) {\n      if (parse) {\n        // During the parse phase always return a value\n        // No need to refer to rename map because a projection can't be renamed\n        // before it has the original name.\n        return this.getName('projection');\n      }\n\n      if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName('projection'))) {\n        return this.projectionNameMap.get(this.getName('projection'));\n      }\n\n      return undefined;\n    }\n    /**\n     * Traverse a model's hierarchy to get the scale component for a particular channel.\n     */\n\n  }, {\n    key: \"getScaleComponent\",\n    value: function getScaleComponent(channel) {\n      /* istanbul ignore next: This is warning for debugging test */\n      if (!this.component.scales) {\n        throw new Error('getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().');\n      }\n\n      var localScaleComponent = this.component.scales[channel];\n\n      if (localScaleComponent && !localScaleComponent.merged) {\n        return localScaleComponent;\n      }\n\n      return this.parent ? this.parent.getScaleComponent(channel) : undefined;\n    }\n    /**\n     * Traverse a model's hierarchy to get a particular selection component.\n     */\n\n  }, {\n    key: \"getSelectionComponent\",\n    value: function getSelectionComponent(variableName, origName) {\n      var sel = this.component.selection[variableName];\n\n      if (!sel && this.parent) {\n        sel = this.parent.getSelectionComponent(variableName, origName);\n      }\n\n      if (!sel) {\n        throw new Error(log.message.selectionNotFound(origName));\n      }\n\n      return sel;\n    }\n    /**\n     * Returns true if the model has a signalRef for an axis orient.\n     */\n\n  }, {\n    key: \"hasAxisOrientSignalRef\",\n    value: function hasAxisOrientSignalRef() {\n      var _a, _b;\n\n      return ((_a = this.component.axes.x) === null || _a === void 0 ? void 0 : _a.some(function (a) {\n        return a.hasOrientSignalRef();\n      })) || ((_b = this.component.axes.y) === null || _b === void 0 ? void 0 : _b.some(function (a) {\n        return a.hasOrientSignalRef();\n      }));\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.getSizeSignalRef('width');\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.getSizeSignalRef('height');\n    }\n  }]);\n\n  return Model;\n}();\n/** Abstract class for UnitModel and FacetModel. Both of which can contain fieldDefs as a part of its own specification. */\n\nexport var ModelWithField = /*#__PURE__*/function (_Model) {\n  _inherits(ModelWithField, _Model);\n\n  var _super = _createSuper(ModelWithField);\n\n  function ModelWithField() {\n    _classCallCheck(this, ModelWithField);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ModelWithField, [{\n    key: \"vgField\",\n\n    /** Get \"field\" reference for Vega */\n    value: function vgField(channel) {\n      var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fieldDef = this.fieldDef(channel);\n\n      if (!fieldDef) {\n        return undefined;\n      }\n\n      return _vgField(fieldDef, opt);\n    }\n  }, {\n    key: \"reduceFieldDef\",\n    value: function reduceFieldDef(f, init) {\n      return reduce(this.getMapping(), function (acc, cd, c) {\n        var fieldDef = getFieldDef(cd);\n\n        if (fieldDef) {\n          return f(acc, fieldDef, c);\n        }\n\n        return acc;\n      }, init);\n    }\n  }, {\n    key: \"forEachFieldDef\",\n    value: function forEachFieldDef(f, t) {\n      forEach(this.getMapping(), function (cd, c) {\n        var fieldDef = getFieldDef(cd);\n\n        if (fieldDef) {\n          f(fieldDef, c);\n        }\n      }, t);\n    }\n  }]);\n\n  return ModelWithField;\n}(Model);","map":{"version":3,"sources":["../../../src/compile/model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { FACET_CHANNELS, getPositionScaleChannel, isChannel, isScaleChannel } from '../channel';\nimport { getFieldDef, vgField } from '../channeldef';\nimport { DataSourceType } from '../data';\nimport { forEach, reduce } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { isFacetSpec } from '../spec';\nimport { extractCompositionLayout } from '../spec/base';\nimport { extractTitleConfig, isText } from '../title';\nimport { normalizeTransform } from '../transform';\nimport { contains, duplicate, isEmpty, keys, varName } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { assembleAxes } from './axis/assemble';\nimport { signalOrValueRef } from './common';\nimport { assembleHeaderGroups, assembleLayoutTitleBand, assembleTitleGroup } from './header/assemble';\nimport { HEADER_CHANNELS } from './header/component';\nimport { sizeExpr } from './layoutsize/assemble';\nimport { getSizeTypeFromLayoutSizeType } from './layoutsize/component';\nimport { assembleLegends } from './legend/assemble';\nimport { parseLegend } from './legend/parse';\nimport { assembleProjections } from './projection/assemble';\nimport { parseProjection } from './projection/parse';\nimport { assembleScales } from './scale/assemble';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { parseScales } from './scale/parse';\nimport { Split } from './split';\nexport class NameMap {\n    constructor() {\n        this.nameMap = {};\n    }\n    rename(oldName, newName) {\n        this.nameMap[oldName] = newName;\n    }\n    has(name) {\n        return this.nameMap[name] !== undefined;\n    }\n    get(name) {\n        // If the name appears in the _nameMap, we need to read its new name.\n        // We have to loop over the dict just in case the new name also gets renamed.\n        while (this.nameMap[name] && name !== this.nameMap[name]) {\n            name = this.nameMap[name];\n        }\n        return name;\n    }\n}\n/*\n  We use type guards instead of `instanceof` as `instanceof` makes\n  different parts of the compiler depend on the actual implementation of\n  the model classes, which in turn depend on different parts of the compiler.\n  Thus, `instanceof` leads to circular dependency problems.\n\n  On the other hand, type guards only make different parts of the compiler\n  depend on the type of the model classes, but not the actual implementation.\n*/\nexport function isUnitModel(model) {\n    return (model === null || model === void 0 ? void 0 : model.type) === 'unit';\n}\nexport function isFacetModel(model) {\n    return (model === null || model === void 0 ? void 0 : model.type) === 'facet';\n}\nexport function isConcatModel(model) {\n    return (model === null || model === void 0 ? void 0 : model.type) === 'concat';\n}\nexport function isLayerModel(model) {\n    return (model === null || model === void 0 ? void 0 : model.type) === 'layer';\n}\nexport class Model {\n    constructor(spec, type, parent, parentGivenName, config, resolve, view) {\n        var _a, _b;\n        this.type = type;\n        this.parent = parent;\n        this.config = config;\n        /**\n         * Corrects the data references in marks after assemble.\n         */\n        this.correctDataNames = (mark) => {\n            // TODO: make this correct\n            var _a, _b, _c;\n            // for normal data references\n            if ((_a = mark.from) === null || _a === void 0 ? void 0 : _a.data) {\n                mark.from.data = this.lookupDataSource(mark.from.data);\n            }\n            // for access to facet data\n            if ((_c = (_b = mark.from) === null || _b === void 0 ? void 0 : _b.facet) === null || _c === void 0 ? void 0 : _c.data) {\n                mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);\n            }\n            return mark;\n        };\n        this.parent = parent;\n        this.config = config;\n        this.view = replaceExprRef(view);\n        // If name is not provided, always use parent's givenName to avoid name conflicts.\n        this.name = (_a = spec.name) !== null && _a !== void 0 ? _a : parentGivenName;\n        this.title = isText(spec.title) ? { text: spec.title } : spec.title ? replaceExprRef(spec.title) : undefined;\n        // Shared name maps\n        this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();\n        this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();\n        this.signalNameMap = parent ? parent.signalNameMap : new NameMap();\n        this.data = spec.data;\n        this.description = spec.description;\n        this.transforms = normalizeTransform((_b = spec.transform) !== null && _b !== void 0 ? _b : []);\n        this.layout = type === 'layer' || type === 'unit' ? {} : extractCompositionLayout(spec, type, config);\n        this.component = {\n            data: {\n                sources: parent ? parent.component.data.sources : [],\n                outputNodes: parent ? parent.component.data.outputNodes : {},\n                outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},\n                // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined\n                isFaceted: isFacetSpec(spec) || (parent && parent.component.data.isFaceted && spec.data === undefined)\n            },\n            layoutSize: new Split(),\n            layoutHeaders: { row: {}, column: {}, facet: {} },\n            mark: null,\n            resolve: Object.assign({ scale: {}, axis: {}, legend: {} }, (resolve ? duplicate(resolve) : {})),\n            selection: null,\n            scales: null,\n            projection: null,\n            axes: {},\n            legends: {}\n        };\n    }\n    get width() {\n        return this.getSizeSignalRef('width');\n    }\n    get height() {\n        return this.getSizeSignalRef('height');\n    }\n    parse() {\n        this.parseScale();\n        this.parseLayoutSize(); // depends on scale\n        this.renameTopLevelLayoutSizeSignal();\n        this.parseSelections();\n        this.parseProjection();\n        this.parseData(); // (pathorder) depends on markDef; selection filters depend on parsed selections; depends on projection because some transforms require the finalized projection name.\n        this.parseAxesAndHeaders(); // depends on scale and layout size\n        this.parseLegends(); // depends on scale, markDef\n        this.parseMarkGroup(); // depends on data name, scale, layout size, axisGroup, and children's scale, axis, legend and mark.\n    }\n    parseScale() {\n        parseScales(this);\n    }\n    parseProjection() {\n        parseProjection(this);\n    }\n    /**\n     * Rename top-level spec's size to be just width / height, ignoring model name.\n     * This essentially merges the top-level spec's width/height signals with the width/height signals\n     * to help us reduce redundant signals declaration.\n     */\n    renameTopLevelLayoutSizeSignal() {\n        if (this.getName('width') !== 'width') {\n            this.renameSignal(this.getName('width'), 'width');\n        }\n        if (this.getName('height') !== 'height') {\n            this.renameSignal(this.getName('height'), 'height');\n        }\n    }\n    parseLegends() {\n        parseLegend(this);\n    }\n    assembleEncodeFromView(view) {\n        // Exclude \"style\"\n        const { style: _ } = view, baseView = __rest(view, [\"style\"]);\n        const e = {};\n        for (const property of keys(baseView)) {\n            const value = baseView[property];\n            if (value !== undefined) {\n                e[property] = signalOrValueRef(value);\n            }\n        }\n        return e;\n    }\n    assembleGroupEncodeEntry(isTopLevel) {\n        let encodeEntry = {};\n        if (this.view) {\n            encodeEntry = this.assembleEncodeFromView(this.view);\n        }\n        if (!isTopLevel) {\n            // Descriptions are already added to the top-level description so we only need to add them to the inner views.\n            if (this.description) {\n                encodeEntry['description'] = signalOrValueRef(this.description);\n            }\n            // For top-level spec, we can set the global width and height signal to adjust the group size.\n            // For other child specs, we have to manually set width and height in the encode entry.\n            if (this.type === 'unit' || this.type === 'layer') {\n                return Object.assign({ width: this.getSizeSignalRef('width'), height: this.getSizeSignalRef('height') }, (encodeEntry !== null && encodeEntry !== void 0 ? encodeEntry : {}));\n            }\n        }\n        return isEmpty(encodeEntry) ? undefined : encodeEntry;\n    }\n    assembleLayout() {\n        if (!this.layout) {\n            return undefined;\n        }\n        const _a = this.layout, { spacing } = _a, layout = __rest(_a, [\"spacing\"]);\n        const { component, config } = this;\n        const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);\n        return Object.assign(Object.assign(Object.assign({ padding: spacing }, this.assembleDefaultLayout()), layout), (titleBand ? { titleBand } : {}));\n    }\n    assembleDefaultLayout() {\n        return {};\n    }\n    assembleHeaderMarks() {\n        const { layoutHeaders } = this.component;\n        let headerMarks = [];\n        for (const channel of FACET_CHANNELS) {\n            if (layoutHeaders[channel].title) {\n                headerMarks.push(assembleTitleGroup(this, channel));\n            }\n        }\n        for (const channel of HEADER_CHANNELS) {\n            headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));\n        }\n        return headerMarks;\n    }\n    assembleAxes() {\n        return assembleAxes(this.component.axes, this.config);\n    }\n    assembleLegends() {\n        return assembleLegends(this);\n    }\n    assembleProjections() {\n        return assembleProjections(this);\n    }\n    assembleTitle() {\n        var _a, _b, _c;\n        const _d = (_a = this.title) !== null && _a !== void 0 ? _a : {}, { encoding } = _d, titleNoEncoding = __rest(_d, [\"encoding\"]);\n        const title = Object.assign(Object.assign(Object.assign({}, extractTitleConfig(this.config.title).nonMarkTitleProperties), titleNoEncoding), (encoding ? { encode: { update: encoding } } : {}));\n        if (title.text) {\n            if (contains(['unit', 'layer'], this.type)) {\n                // Unit/Layer\n                if (contains(['middle', undefined], title.anchor)) {\n                    (_b = title.frame) !== null && _b !== void 0 ? _b : (title.frame = 'group');\n                }\n            }\n            else {\n                // composition with Vega layout\n                // Set title = \"start\" by default for composition as \"middle\" does not look nice\n                // https://github.com/vega/vega/issues/960#issuecomment-471360328\n                (_c = title.anchor) !== null && _c !== void 0 ? _c : (title.anchor = 'start');\n            }\n            return isEmpty(title) ? undefined : title;\n        }\n        return undefined;\n    }\n    /**\n     * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.\n     */\n    assembleGroup(signals = []) {\n        const group = {};\n        signals = signals.concat(this.assembleSignals());\n        if (signals.length > 0) {\n            group.signals = signals;\n        }\n        const layout = this.assembleLayout();\n        if (layout) {\n            group.layout = layout;\n        }\n        group.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());\n        // Only include scales if this spec is top-level or if parent is facet.\n        // (Otherwise, it will be merged with upper-level's scope.)\n        const scales = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];\n        if (scales.length > 0) {\n            group.scales = scales;\n        }\n        const axes = this.assembleAxes();\n        if (axes.length > 0) {\n            group.axes = axes;\n        }\n        const legends = this.assembleLegends();\n        if (legends.length > 0) {\n            group.legends = legends;\n        }\n        return group;\n    }\n    getName(text) {\n        return varName((this.name ? `${this.name}_` : '') + text);\n    }\n    getDataName(type) {\n        return this.getName(DataSourceType[type].toLowerCase());\n    }\n    /**\n     * Request a data source name for the given data source type and mark that data source as required.\n     * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().\n     * You can lookup the correct dataset name in assemble with `lookupDataSource`.\n     */\n    requestDataName(name) {\n        const fullName = this.getDataName(name);\n        // Increase ref count. This is critical because otherwise we won't create a data source.\n        // We also increase the ref counts on OutputNode.getSource() calls.\n        const refCounts = this.component.data.outputNodeRefCounts;\n        refCounts[fullName] = (refCounts[fullName] || 0) + 1;\n        return fullName;\n    }\n    getSizeSignalRef(layoutSizeType) {\n        if (isFacetModel(this.parent)) {\n            const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);\n            const channel = getPositionScaleChannel(sizeType);\n            const scaleComponent = this.component.scales[channel];\n            if (scaleComponent && !scaleComponent.merged) {\n                // independent scale\n                const type = scaleComponent.get('type');\n                const range = scaleComponent.get('range');\n                if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                    const scaleName = scaleComponent.get('name');\n                    const domain = assembleDomain(this, channel);\n                    const field = getFieldFromDomain(domain);\n                    if (field) {\n                        const fieldRef = vgField({ aggregate: 'distinct', field }, { expr: 'datum' });\n                        return {\n                            signal: sizeExpr(scaleName, scaleComponent, fieldRef)\n                        };\n                    }\n                    else {\n                        log.warn(log.message.unknownField(channel));\n                        return null;\n                    }\n                }\n            }\n        }\n        return {\n            signal: this.signalNameMap.get(this.getName(layoutSizeType))\n        };\n    }\n    /**\n     * Lookup the name of the datasource for an output node. You probably want to call this in assemble.\n     */\n    lookupDataSource(name) {\n        const node = this.component.data.outputNodes[name];\n        if (!node) {\n            // Name not found in map so let's just return what we got.\n            // This can happen if we already have the correct name.\n            return name;\n        }\n        return node.getSource();\n    }\n    getSignalName(oldSignalName) {\n        return this.signalNameMap.get(oldSignalName);\n    }\n    renameSignal(oldName, newName) {\n        this.signalNameMap.rename(oldName, newName);\n    }\n    renameScale(oldName, newName) {\n        this.scaleNameMap.rename(oldName, newName);\n    }\n    renameProjection(oldName, newName) {\n        this.projectionNameMap.rename(oldName, newName);\n    }\n    /**\n     * @return scale name for a given channel after the scale has been parsed and named.\n     */\n    scaleName(originalScaleName, parse) {\n        if (parse) {\n            // During the parse phase always return a value\n            // No need to refer to rename map because a scale can't be renamed\n            // before it has the original name.\n            return this.getName(originalScaleName);\n        }\n        // If there is a scale for the channel, it should either\n        // be in the scale component or exist in the name map\n        if (\n        // If there is a scale for the channel, there should be a local scale component for it\n        (isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName]) ||\n            // in the scale name map (the scale get merged by its parent)\n            this.scaleNameMap.has(this.getName(originalScaleName))) {\n            return this.scaleNameMap.get(this.getName(originalScaleName));\n        }\n        return undefined;\n    }\n    /**\n     * @return projection name after the projection has been parsed and named.\n     */\n    projectionName(parse) {\n        if (parse) {\n            // During the parse phase always return a value\n            // No need to refer to rename map because a projection can't be renamed\n            // before it has the original name.\n            return this.getName('projection');\n        }\n        if ((this.component.projection && !this.component.projection.merged) ||\n            this.projectionNameMap.has(this.getName('projection'))) {\n            return this.projectionNameMap.get(this.getName('projection'));\n        }\n        return undefined;\n    }\n    /**\n     * Traverse a model's hierarchy to get the scale component for a particular channel.\n     */\n    getScaleComponent(channel) {\n        /* istanbul ignore next: This is warning for debugging test */\n        if (!this.component.scales) {\n            throw new Error('getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().');\n        }\n        const localScaleComponent = this.component.scales[channel];\n        if (localScaleComponent && !localScaleComponent.merged) {\n            return localScaleComponent;\n        }\n        return this.parent ? this.parent.getScaleComponent(channel) : undefined;\n    }\n    /**\n     * Traverse a model's hierarchy to get a particular selection component.\n     */\n    getSelectionComponent(variableName, origName) {\n        let sel = this.component.selection[variableName];\n        if (!sel && this.parent) {\n            sel = this.parent.getSelectionComponent(variableName, origName);\n        }\n        if (!sel) {\n            throw new Error(log.message.selectionNotFound(origName));\n        }\n        return sel;\n    }\n    /**\n     * Returns true if the model has a signalRef for an axis orient.\n     */\n    hasAxisOrientSignalRef() {\n        var _a, _b;\n        return (((_a = this.component.axes.x) === null || _a === void 0 ? void 0 : _a.some(a => a.hasOrientSignalRef())) ||\n            ((_b = this.component.axes.y) === null || _b === void 0 ? void 0 : _b.some(a => a.hasOrientSignalRef())));\n    }\n}\n/** Abstract class for UnitModel and FacetModel. Both of which can contain fieldDefs as a part of its own specification. */\nexport class ModelWithField extends Model {\n    /** Get \"field\" reference for Vega */\n    vgField(channel, opt = {}) {\n        const fieldDef = this.fieldDef(channel);\n        if (!fieldDef) {\n            return undefined;\n        }\n        return vgField(fieldDef, opt);\n    }\n    reduceFieldDef(f, init) {\n        return reduce(this.getMapping(), (acc, cd, c) => {\n            const fieldDef = getFieldDef(cd);\n            if (fieldDef) {\n                return f(acc, fieldDef, c);\n            }\n            return acc;\n        }, init);\n    }\n    forEachFieldDef(f, t) {\n        forEach(this.getMapping(), (cd, c) => {\n            const fieldDef = getFieldDef(cd);\n            if (fieldDef) {\n                f(fieldDef, c);\n            }\n        }, t);\n    }\n}\n//# sourceMappingURL=model.js.map"]},"metadata":{},"sourceType":"module"}