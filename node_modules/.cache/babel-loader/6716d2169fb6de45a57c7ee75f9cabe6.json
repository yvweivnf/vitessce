{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport var CoreNormalizer = /*#__PURE__*/function (_SpecMapper) {\n  _inherits(CoreNormalizer, _SpecMapper);\n\n  var _super = _createSuper(CoreNormalizer);\n\n  function CoreNormalizer() {\n    var _this;\n\n    _classCallCheck(this, CoreNormalizer);\n\n    _this = _super.apply(this, arguments);\n    _this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer()];\n    return _this;\n  }\n\n  _createClass(CoreNormalizer, [{\n    key: \"map\",\n    value: function map(spec, params) {\n      // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n      if (isUnitSpec(spec)) {\n        var hasRow = channelHasField(spec.encoding, ROW);\n        var hasColumn = channelHasField(spec.encoding, COLUMN);\n        var hasFacet = channelHasField(spec.encoding, FACET);\n\n        if (hasRow || hasColumn || hasFacet) {\n          return this.mapFacetedUnit(spec, params);\n        }\n      }\n\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"map\", this).call(this, spec, params);\n    } // This is for normalizing non-facet unit\n\n  }, {\n    key: \"mapUnit\",\n    value: function mapUnit(spec, params) {\n      var parentEncoding = params.parentEncoding,\n          parentProjection = params.parentProjection;\n      var encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n      var specWithReplacedEncoding = Object.assign(Object.assign({}, spec), encoding ? {\n        encoding: encoding\n      } : {});\n\n      if (parentEncoding || parentProjection) {\n        return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n      }\n\n      var normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n      var _iterator = _createForOfIteratorHelper(this.nonFacetUnitNormalizers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var unitNormalizer = _step.value;\n\n          if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n            return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return specWithReplacedEncoding;\n    }\n  }, {\n    key: \"mapRepeat\",\n    value: function mapRepeat(spec, params) {\n      if (isLayerRepeatSpec(spec)) {\n        return this.mapLayerRepeat(spec, params);\n      } else {\n        return this.mapNonLayerRepeat(spec, params);\n      }\n    }\n  }, {\n    key: \"mapLayerRepeat\",\n    value: function mapLayerRepeat(spec, params) {\n      var _this2 = this;\n\n      var repeat = spec.repeat,\n          childSpec = spec.spec,\n          rest = __rest(spec, [\"repeat\", \"spec\"]);\n\n      var row = repeat.row,\n          column = repeat.column,\n          layer = repeat.layer;\n      var _params$repeater = params.repeater,\n          repeater = _params$repeater === void 0 ? {} : _params$repeater,\n          _params$repeaterPrefi = params.repeaterPrefix,\n          repeaterPrefix = _params$repeaterPrefi === void 0 ? '' : _params$repeaterPrefi;\n\n      if (row || column) {\n        return this.mapRepeat(Object.assign(Object.assign({}, spec), {\n          repeat: Object.assign(Object.assign({}, row ? {\n            row: row\n          } : {}), column ? {\n            column: column\n          } : {}),\n          spec: {\n            repeat: {\n              layer: layer\n            },\n            spec: childSpec\n          }\n        }), params);\n      } else {\n        return Object.assign(Object.assign({}, rest), {\n          layer: layer.map(function (layerValue) {\n            var childRepeater = Object.assign(Object.assign({}, repeater), {\n              layer: layerValue\n            });\n            var childName = \"\".concat((childSpec.name || '') + repeaterPrefix, \"child__layer_\").concat(varName(layerValue));\n\n            var child = _this2.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), {\n              repeater: childRepeater,\n              repeaterPrefix: childName\n            }));\n\n            child.name = childName;\n            return child;\n          })\n        });\n      }\n    }\n  }, {\n    key: \"mapNonLayerRepeat\",\n    value: function mapNonLayerRepeat(spec, params) {\n      var _a;\n\n      var _spec = spec,\n          repeat = _spec.repeat,\n          childSpec = _spec.spec,\n          data = _spec.data,\n          remainingProperties = __rest(spec, [\"repeat\", \"spec\", \"data\"]);\n\n      if (!isArray(repeat) && spec.columns) {\n        // is repeat with row/column\n        spec = omit(spec, ['columns']);\n        log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n      }\n\n      var concat = [];\n      var _params$repeater2 = params.repeater,\n          repeater = _params$repeater2 === void 0 ? {} : _params$repeater2,\n          _params$repeaterPrefi2 = params.repeaterPrefix,\n          repeaterPrefix = _params$repeaterPrefi2 === void 0 ? '' : _params$repeaterPrefi2;\n      var row = !isArray(repeat) && repeat.row || [repeater ? repeater.row : null];\n      var column = !isArray(repeat) && repeat.column || [repeater ? repeater.column : null];\n      var repeatValues = isArray(repeat) && repeat || [repeater ? repeater.repeat : null]; // cross product\n\n      var _iterator2 = _createForOfIteratorHelper(repeatValues),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var repeatValue = _step2.value;\n\n          var _iterator3 = _createForOfIteratorHelper(row),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var rowValue = _step3.value;\n\n              var _iterator4 = _createForOfIteratorHelper(column),\n                  _step4;\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var columnValue = _step4.value;\n                  var childRepeater = {\n                    repeat: repeatValue,\n                    row: rowValue,\n                    column: columnValue,\n                    layer: repeater.layer\n                  };\n                  var childName = (childSpec.name || '') + repeaterPrefix + 'child__' + (isArray(repeat) ? \"\".concat(varName(repeatValue)) : (repeat.row ? \"row_\".concat(varName(rowValue)) : '') + (repeat.column ? \"column_\".concat(varName(columnValue)) : ''));\n                  var child = this.map(childSpec, Object.assign(Object.assign({}, params), {\n                    repeater: childRepeater,\n                    repeaterPrefix: childName\n                  }));\n                  child.name = childName; // we move data up\n\n                  concat.push(omit(child, ['data']));\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n      return Object.assign(Object.assign({\n        data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data,\n        align: 'all'\n      }, remainingProperties), {\n        columns: columns,\n        concat: concat\n      });\n    }\n  }, {\n    key: \"mapFacet\",\n    value: function mapFacet(spec, params) {\n      var _spec2 = spec,\n          facet = _spec2.facet;\n\n      if (isFacetMapping(facet) && spec.columns) {\n        // is facet with row/column\n        spec = omit(spec, ['columns']);\n        log.warn(log.message.columnsNotSupportByRowCol('facet'));\n      }\n\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"mapFacet\", this).call(this, spec, params);\n    }\n  }, {\n    key: \"mapUnitWithParentEncodingOrProjection\",\n    value: function mapUnitWithParentEncodingOrProjection(spec, params) {\n      var encoding = spec.encoding,\n          projection = spec.projection;\n      var parentEncoding = params.parentEncoding,\n          parentProjection = params.parentProjection,\n          config = params.config;\n      var mergedProjection = mergeProjection({\n        parentProjection: parentProjection,\n        projection: projection\n      });\n      var mergedEncoding = mergeEncoding({\n        parentEncoding: parentEncoding,\n        encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n      });\n      return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {\n        projection: mergedProjection\n      } : {}), mergedEncoding ? {\n        encoding: mergedEncoding\n      } : {}), {\n        config: config\n      });\n    }\n  }, {\n    key: \"mapFacetedUnit\",\n    value: function mapFacetedUnit(spec, normParams) {\n      // New encoding in the inside spec should not contain row / column\n      // as row/column should be moved to facet\n      var _a = spec.encoding,\n          row = _a.row,\n          column = _a.column,\n          facet = _a.facet,\n          encoding = __rest(_a, [\"row\", \"column\", \"facet\"]); // Mark and encoding should be moved into the inner spec\n\n\n      var mark = spec.mark,\n          width = spec.width,\n          projection = spec.projection,\n          height = spec.height,\n          view = spec.view,\n          params = spec.params,\n          _ = spec.encoding,\n          outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"view\", \"params\", \"encoding\"]);\n\n      var _this$getFacetMapping = this.getFacetMappingAndLayout({\n        row: row,\n        column: column,\n        facet: facet\n      }, normParams),\n          facetMapping = _this$getFacetMapping.facetMapping,\n          layout = _this$getFacetMapping.layout;\n\n      var newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n      return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {\n        // row / column has higher precedence than facet\n        facet: facetMapping,\n        spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width ? {\n          width: width\n        } : {}), height ? {\n          height: height\n        } : {}), view ? {\n          view: view\n        } : {}), projection ? {\n          projection: projection\n        } : {}), {\n          mark: mark,\n          encoding: newEncoding\n        }), params ? {\n          params: params\n        } : {})\n      }), normParams);\n    }\n  }, {\n    key: \"getFacetMappingAndLayout\",\n    value: function getFacetMappingAndLayout(facets, params) {\n      var _a;\n\n      var row = facets.row,\n          column = facets.column,\n          facet = facets.facet;\n\n      if (row || column) {\n        if (facet) {\n          log.warn(log.message.facetChannelDropped([].concat(_toConsumableArray(row ? [ROW] : []), _toConsumableArray(column ? [COLUMN] : []))));\n        }\n\n        var facetMapping = {};\n        var layout = {};\n\n        for (var _i = 0, _arr = [ROW, COLUMN]; _i < _arr.length; _i++) {\n          var channel = _arr[_i];\n          var def = facets[channel];\n\n          if (def) {\n            var align = def.align,\n                center = def.center,\n                spacing = def.spacing,\n                columns = def.columns,\n                defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n            facetMapping[channel] = defWithoutLayout;\n\n            for (var _i2 = 0, _arr2 = ['align', 'center', 'spacing']; _i2 < _arr2.length; _i2++) {\n              var prop = _arr2[_i2];\n\n              if (def[prop] !== undefined) {\n                (_a = layout[prop]) !== null && _a !== void 0 ? _a : layout[prop] = {};\n                layout[prop][channel] = def[prop];\n              }\n            }\n          }\n        }\n\n        return {\n          facetMapping: facetMapping,\n          layout: layout\n        };\n      } else {\n        var _align = facet.align,\n            _center = facet.center,\n            _spacing = facet.spacing,\n            _columns = facet.columns,\n            _facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n        return {\n          facetMapping: replaceRepeaterInFacet(_facetMapping, params.repeater),\n          layout: Object.assign(Object.assign(Object.assign(Object.assign({}, _align ? {\n            align: _align\n          } : {}), _center ? {\n            center: _center\n          } : {}), _spacing ? {\n            spacing: _spacing\n          } : {}), _columns ? {\n            columns: _columns\n          } : {})\n        };\n      }\n    }\n  }, {\n    key: \"mapLayer\",\n    value: function mapLayer(spec, _a) {\n      // Special handling for extended layer spec\n      var parentEncoding = _a.parentEncoding,\n          parentProjection = _a.parentProjection,\n          otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n\n      var encoding = spec.encoding,\n          projection = spec.projection,\n          rest = __rest(spec, [\"encoding\", \"projection\"]);\n\n      var params = Object.assign(Object.assign({}, otherParams), {\n        parentEncoding: mergeEncoding({\n          parentEncoding: parentEncoding,\n          encoding: encoding,\n          layer: true\n        }),\n        parentProjection: mergeProjection({\n          parentProjection: parentProjection,\n          projection: projection\n        })\n      });\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"mapLayer\", this).call(this, rest, params);\n    }\n  }]);\n\n  return CoreNormalizer;\n}(SpecMapper);\n\nfunction mergeEncoding(_ref) {\n  var parentEncoding = _ref.parentEncoding,\n      _ref$encoding = _ref.encoding,\n      encoding = _ref$encoding === void 0 ? {} : _ref$encoding,\n      layer = _ref.layer;\n  var merged = {};\n\n  if (parentEncoding) {\n    var channels = new Set([].concat(_toConsumableArray(keys(parentEncoding)), _toConsumableArray(keys(encoding))));\n\n    var _iterator5 = _createForOfIteratorHelper(channels),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var channel = _step5.value;\n        var channelDef = encoding[channel];\n        var parentChannelDef = parentEncoding[channel];\n\n        if (isFieldOrDatumDef(channelDef)) {\n          // Field/Datum Def can inherit properties from its parent\n          // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n          var mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);\n          merged[channel] = mergedChannelDef;\n        } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n          merged[channel] = Object.assign(Object.assign({}, channelDef), {\n            condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition)\n          });\n        } else if (channelDef || channelDef === null) {\n          merged[channel] = channelDef;\n        } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray(parentChannelDef)) {\n          merged[channel] = parentChannelDef;\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  } else {\n    merged = encoding;\n  }\n\n  return !merged || isEmpty(merged) ? undefined : merged;\n}\n\nfunction mergeProjection(opt) {\n  var parentProjection = opt.parentProjection,\n      projection = opt.projection;\n\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection: parentProjection,\n      projection: projection\n    }));\n  }\n\n  return projection !== null && projection !== void 0 ? projection : parentProjection;\n}","map":{"version":3,"sources":["../../../src/normalize/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n    constructor() {\n        super(...arguments);\n        this.nonFacetUnitNormalizers = [\n            boxPlotNormalizer,\n            errorBarNormalizer,\n            errorBandNormalizer,\n            new PathOverlayNormalizer(),\n            new RuleForRangedLineNormalizer()\n        ];\n    }\n    map(spec, params) {\n        // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n        if (isUnitSpec(spec)) {\n            const hasRow = channelHasField(spec.encoding, ROW);\n            const hasColumn = channelHasField(spec.encoding, COLUMN);\n            const hasFacet = channelHasField(spec.encoding, FACET);\n            if (hasRow || hasColumn || hasFacet) {\n                return this.mapFacetedUnit(spec, params);\n            }\n        }\n        return super.map(spec, params);\n    }\n    // This is for normalizing non-facet unit\n    mapUnit(spec, params) {\n        const { parentEncoding, parentProjection } = params;\n        const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n        const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), (encoding ? { encoding } : {}));\n        if (parentEncoding || parentProjection) {\n            return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n        }\n        const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n        for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n            if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n                return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n            }\n        }\n        return specWithReplacedEncoding;\n    }\n    mapRepeat(spec, params) {\n        if (isLayerRepeatSpec(spec)) {\n            return this.mapLayerRepeat(spec, params);\n        }\n        else {\n            return this.mapNonLayerRepeat(spec, params);\n        }\n    }\n    mapLayerRepeat(spec, params) {\n        const { repeat, spec: childSpec } = spec, rest = __rest(spec, [\"repeat\", \"spec\"]);\n        const { row, column, layer } = repeat;\n        const { repeater = {}, repeaterPrefix = '' } = params;\n        if (row || column) {\n            return this.mapRepeat(Object.assign(Object.assign({}, spec), { repeat: Object.assign(Object.assign({}, (row ? { row } : {})), (column ? { column } : {})), spec: {\n                    repeat: { layer },\n                    spec: childSpec\n                } }), params);\n        }\n        else {\n            return Object.assign(Object.assign({}, rest), { layer: layer.map(layerValue => {\n                    const childRepeater = Object.assign(Object.assign({}, repeater), { layer: layerValue });\n                    const childName = `${(childSpec.name || '') + repeaterPrefix}child__layer_${varName(layerValue)}`;\n                    const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));\n                    child.name = childName;\n                    return child;\n                }) });\n        }\n    }\n    mapNonLayerRepeat(spec, params) {\n        var _a;\n        const { repeat, spec: childSpec, data } = spec, remainingProperties = __rest(spec, [\"repeat\", \"spec\", \"data\"]);\n        if (!isArray(repeat) && spec.columns) {\n            // is repeat with row/column\n            spec = omit(spec, ['columns']);\n            log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n        }\n        const concat = [];\n        const { repeater = {}, repeaterPrefix = '' } = params;\n        const row = (!isArray(repeat) && repeat.row) || [repeater ? repeater.row : null];\n        const column = (!isArray(repeat) && repeat.column) || [repeater ? repeater.column : null];\n        const repeatValues = (isArray(repeat) && repeat) || [repeater ? repeater.repeat : null];\n        // cross product\n        for (const repeatValue of repeatValues) {\n            for (const rowValue of row) {\n                for (const columnValue of column) {\n                    const childRepeater = {\n                        repeat: repeatValue,\n                        row: rowValue,\n                        column: columnValue,\n                        layer: repeater.layer\n                    };\n                    const childName = (childSpec.name || '') +\n                        repeaterPrefix +\n                        'child__' +\n                        (isArray(repeat)\n                            ? `${varName(repeatValue)}`\n                            : (repeat.row ? `row_${varName(rowValue)}` : '') +\n                                (repeat.column ? `column_${varName(columnValue)}` : ''));\n                    const child = this.map(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));\n                    child.name = childName;\n                    // we move data up\n                    concat.push(omit(child, ['data']));\n                }\n            }\n        }\n        const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n        return Object.assign(Object.assign({ data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data, align: 'all' }, remainingProperties), { columns,\n            concat });\n    }\n    mapFacet(spec, params) {\n        const { facet } = spec;\n        if (isFacetMapping(facet) && spec.columns) {\n            // is facet with row/column\n            spec = omit(spec, ['columns']);\n            log.warn(log.message.columnsNotSupportByRowCol('facet'));\n        }\n        return super.mapFacet(spec, params);\n    }\n    mapUnitWithParentEncodingOrProjection(spec, params) {\n        const { encoding, projection } = spec;\n        const { parentEncoding, parentProjection, config } = params;\n        const mergedProjection = mergeProjection({ parentProjection, projection });\n        const mergedEncoding = mergeEncoding({\n            parentEncoding,\n            encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n        });\n        return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), (mergedProjection ? { projection: mergedProjection } : {})), (mergedEncoding ? { encoding: mergedEncoding } : {})), { config });\n    }\n    mapFacetedUnit(spec, normParams) {\n        // New encoding in the inside spec should not contain row / column\n        // as row/column should be moved to facet\n        const _a = spec.encoding, { row, column, facet } = _a, encoding = __rest(_a, [\"row\", \"column\", \"facet\"]);\n        // Mark and encoding should be moved into the inner spec\n        const { mark, width, projection, height, view, params, encoding: _ } = spec, outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"view\", \"params\", \"encoding\"]);\n        const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, normParams);\n        const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n        return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), { \n            // row / column has higher precedence than facet\n            facet: facetMapping, spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (width ? { width } : {})), (height ? { height } : {})), (view ? { view } : {})), (projection ? { projection } : {})), { mark, encoding: newEncoding }), (params ? { params } : {})) }), normParams);\n    }\n    getFacetMappingAndLayout(facets, params) {\n        var _a;\n        const { row, column, facet } = facets;\n        if (row || column) {\n            if (facet) {\n                log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n            }\n            const facetMapping = {};\n            const layout = {};\n            for (const channel of [ROW, COLUMN]) {\n                const def = facets[channel];\n                if (def) {\n                    const { align, center, spacing, columns } = def, defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n                    facetMapping[channel] = defWithoutLayout;\n                    for (const prop of ['align', 'center', 'spacing']) {\n                        if (def[prop] !== undefined) {\n                            (_a = layout[prop]) !== null && _a !== void 0 ? _a : (layout[prop] = {});\n                            layout[prop][channel] = def[prop];\n                        }\n                    }\n                }\n            }\n            return { facetMapping, layout };\n        }\n        else {\n            const { align, center, spacing, columns } = facet, facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n            return {\n                facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n                layout: Object.assign(Object.assign(Object.assign(Object.assign({}, (align ? { align } : {})), (center ? { center } : {})), (spacing ? { spacing } : {})), (columns ? { columns } : {}))\n            };\n        }\n    }\n    mapLayer(spec, _a) {\n        // Special handling for extended layer spec\n        var { parentEncoding, parentProjection } = _a, otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n        const { encoding, projection } = spec, rest = __rest(spec, [\"encoding\", \"projection\"]);\n        const params = Object.assign(Object.assign({}, otherParams), { parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }), parentProjection: mergeProjection({ parentProjection, projection }) });\n        return super.mapLayer(rest, params);\n    }\n}\nfunction mergeEncoding({ parentEncoding, encoding = {}, layer }) {\n    let merged = {};\n    if (parentEncoding) {\n        const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n        for (const channel of channels) {\n            const channelDef = encoding[channel];\n            const parentChannelDef = parentEncoding[channel];\n            if (isFieldOrDatumDef(channelDef)) {\n                // Field/Datum Def can inherit properties from its parent\n                // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n                const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);\n                merged[channel] = mergedChannelDef;\n            }\n            else if (hasConditionalFieldOrDatumDef(channelDef)) {\n                merged[channel] = Object.assign(Object.assign({}, channelDef), { condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition) });\n            }\n            else if (channelDef || channelDef === null) {\n                merged[channel] = channelDef;\n            }\n            else if (layer ||\n                isValueDef(parentChannelDef) ||\n                isSignalRef(parentChannelDef) ||\n                isFieldOrDatumDef(parentChannelDef) ||\n                isArray(parentChannelDef)) {\n                merged[channel] = parentChannelDef;\n            }\n        }\n    }\n    else {\n        merged = encoding;\n    }\n    return !merged || isEmpty(merged) ? undefined : merged;\n}\nfunction mergeProjection(opt) {\n    const { parentProjection, projection } = opt;\n    if (parentProjection && projection) {\n        log.warn(log.message.projectionOverridden({ parentProjection, projection }));\n    }\n    return projection !== null && projection !== void 0 ? projection : parentProjection;\n}\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"module"}