{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n  var config = model.config,\n      markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid) {\n    var signal = allFieldsInvalidPredicate(model, {\n      channels: POSITION_SCALE_CHANNELS\n    });\n\n    if (signal) {\n      return {\n        defined: {\n          signal: signal\n        }\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction allFieldsInvalidPredicate(model, _ref) {\n  var _ref$invalid = _ref.invalid,\n      invalid = _ref$invalid === void 0 ? false : _ref$invalid,\n      channels = _ref.channels;\n  var filterIndex = channels.reduce(function (aggregator, channel) {\n    var scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      var scaleType = scaleComponent.get('type');\n      var field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  var fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    var op = invalid ? '||' : '&&';\n    return fields.map(function (field) {\n      return fieldInvalidPredicate(field, invalid);\n    }).join(\" \".concat(op, \" \"));\n  }\n\n  return undefined;\n}\n\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return _defineProperty({}, prop, signalOrValueRef(value));\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/defined.ts"],"names":[],"mappings":";AAAA,SAAQ,uBAAR,QAAsC,kBAAtC;AAGA,SAAQ,mBAAR,QAAkC,gBAAlC;AACA,SAAc,IAAd,QAAyB,eAAzB;AAEA,SAAQ,mBAAR,EAA6B,gBAA7B,QAAoD,cAApD;AAEA,SAAQ,qBAAR,QAAoC,YAApC;AAEA,OAAM,SAAU,OAAV,CAAkB,KAAlB,EAAkC;AAAA,MAC/B,MAD+B,GACZ,KADY,CAC/B,MAD+B;AAAA,MACvB,OADuB,GACZ,KADY,CACvB,OADuB;AAGtC,MAAM,OAAO,GAAG,mBAAmB,CAAC,SAAD,EAAY,OAAZ,EAAqB,MAArB,CAAnC;;AACA,MAAI,OAAJ,EAAa;AACX,QAAM,MAAM,GAAG,yBAAyB,CAAC,KAAD,EAAQ;AAAC,MAAA,QAAQ,EAAE;AAAX,KAAR,CAAxC;;AAEA,QAAI,MAAJ,EAAY;AACV,aAAO;AAAC,QAAA,OAAO,EAAE;AAAC,UAAA,MAAM,EAAN;AAAD;AAAV,OAAP;AACD;AACF;;AACD,SAAO,EAAP;AACD;;AAED,SAAS,yBAAT,CACE,KADF,QAE4E;AAAA,0BAAzE,OAAyE;AAAA,MAAzE,OAAyE,6BAA/D,KAA+D;AAAA,MAAxD,QAAwD,QAAxD,QAAwD;AAE1E,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAC,UAAD,EAAyB,OAAzB,EAAoC;AACtE,QAAM,cAAc,GAAG,KAAK,CAAC,iBAAN,CAAwB,OAAxB,CAAvB;;AACA,QAAI,cAAJ,EAAoB;AAClB,UAAM,SAAS,GAAG,cAAc,CAAC,GAAf,CAAmB,MAAnB,CAAlB;AACA,UAAM,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB;AAAC,QAAA,IAAI,EAAE;AAAP,OAAvB,CAAd,CAFkB,CAIlB;;AACA,UAAI,KAAK,IAAI,mBAAmB,CAAC,SAAD,CAAhC,EAA6C;AAC3C,QAAA,UAAU,CAAC,KAAD,CAAV,GAAoB,IAApB;AACD;AACF;;AACD,WAAO,UAAP;AACD,GAZmB,EAYjB,EAZiB,CAApB;AAcA,MAAM,MAAM,GAAG,IAAI,CAAC,WAAD,CAAnB;;AACA,MAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AACrB,QAAM,EAAE,GAAG,OAAO,GAAG,IAAH,GAAU,IAA5B;AACA,WAAO,MAAM,CAAC,GAAP,CAAW,UAAA,KAAK;AAAA,aAAI,qBAAqB,CAAC,KAAD,EAAQ,OAAR,CAAzB;AAAA,KAAhB,EAA2D,IAA3D,YAAoE,EAApE,OAAP;AACD;;AACD,SAAO,SAAP;AACD;;AAED,OAAM,SAAU,cAAV,CAAyB,IAAzB,EAAuC,KAAvC,EAAmD;AACvD,MAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,+BAAS,IAAT,EAAgB,gBAAgB,CAAC,KAAD,CAAhC;AACD;;AACD,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["import { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n    const { config, markDef } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid) {\n        const signal = allFieldsInvalidPredicate(model, { channels: POSITION_SCALE_CHANNELS });\n        if (signal) {\n            return { defined: { signal } };\n        }\n    }\n    return {};\n}\nfunction allFieldsInvalidPredicate(model, { invalid = false, channels }) {\n    const filterIndex = channels.reduce((aggregator, channel) => {\n        const scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n            const scaleType = scaleComponent.get('type');\n            const field = model.vgField(channel, { expr: 'datum' });\n            // While discrete domain scales can handle invalid values, continuous scales can't.\n            if (field && hasContinuousDomain(scaleType)) {\n                aggregator[field] = true;\n            }\n        }\n        return aggregator;\n    }, {});\n    const fields = keys(filterIndex);\n    if (fields.length > 0) {\n        const op = invalid ? '||' : '&&';\n        return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n    }\n    return undefined;\n}\nexport function valueIfDefined(prop, value) {\n    if (value !== undefined) {\n        return { [prop]: signalOrValueRef(value) };\n    }\n    return undefined;\n}\n//# sourceMappingURL=defined.js.map"]},"metadata":{},"sourceType":"module"}