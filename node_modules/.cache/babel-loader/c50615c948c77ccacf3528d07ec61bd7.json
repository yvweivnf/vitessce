{"ast":null,"code":"import { OrthographicView } from 'deck.gl';\nimport clamp from 'lodash/clamp'; // Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\n// Reference: https://observablehq.com/@bmschmidt/dot-density-election-maps-with-webgl\n\nexport function getPointSizeDevicePixels(devicePixelRatio, zoom, xRange, yRange, width, height) {\n  // Size of a point, in units of the diagonal axis.\n  const pointSize = 0.001; // Point size maximum, in screen pixels.\n\n  const pointScreenSizeMax = 10; // Point size minimum, in screen pixels.\n\n  const pointScreenSizeMin = 1 / devicePixelRatio;\n  const scaleFactor = 2 ** zoom;\n  const xAxisRange = 2.0 / (xRange * scaleFactor / width);\n  const yAxisRange = 2.0 / (yRange * scaleFactor / height); // The diagonal screen size as a fraction of the current diagonal axis range,\n  // then converted to device pixels.\n\n  const diagonalScreenSize = Math.sqrt(width ** 2 + height ** 2);\n  const diagonalAxisRange = Math.sqrt(xAxisRange ** 2 + yAxisRange ** 2);\n  const diagonalFraction = pointSize / diagonalAxisRange;\n  const deviceSize = diagonalFraction * diagonalScreenSize;\n  const pointSizeDevicePixels = clamp(deviceSize, pointScreenSizeMin, pointScreenSizeMax);\n  return pointSizeDevicePixels;\n} // Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\n\nexport function getPointOpacity(zoom, xRange, yRange, width, height, numCells, avgFillDensity) {\n  const N = numCells;\n  const [minX, minY, maxX, maxY] = new OrthographicView({\n    zoom\n  }).makeViewport({\n    height,\n    width,\n    viewState: {\n      zoom,\n      target: [0, 0, 0]\n    }\n  }).getBounds();\n  const X = maxY - minY;\n  const Y = maxX - minX;\n  const X0 = xRange;\n  const Y0 = yRange;\n  const W = width;\n  const H = height;\n  let rho = avgFillDensity;\n\n  if (!rho) {\n    rho = Math.min(1, 1 / 10 ** (Math.log10(N) - 3));\n  } // p in the calculation is the pixel length/width of a given point, which for us is 1\n  // so it does not factor into our calculation here.\n\n\n  const alpha = rho * W * H / N * (Y0 / Y) * (X0 / X);\n  const pointOpacity = clamp(alpha, 1.01 / 255, 1.0);\n  return pointOpacity;\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/shared-spatial-scatterplot/dynamic-opacity.js"],"names":["OrthographicView","clamp","getPointSizeDevicePixels","devicePixelRatio","zoom","xRange","yRange","width","height","pointSize","pointScreenSizeMax","pointScreenSizeMin","scaleFactor","xAxisRange","yAxisRange","diagonalScreenSize","Math","sqrt","diagonalAxisRange","diagonalFraction","deviceSize","pointSizeDevicePixels","getPointOpacity","numCells","avgFillDensity","N","minX","minY","maxX","maxY","makeViewport","viewState","target","getBounds","X","Y","X0","Y0","W","H","rho","min","log10","alpha","pointOpacity"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,SAAjC;AACA,OAAOC,KAAP,MAAkB,cAAlB,C,CAEA;AACA;;AACA,OAAO,SAASC,wBAAT,CAAkCC,gBAAlC,EAAoDC,IAApD,EAA0DC,MAA1D,EAAkEC,MAAlE,EAA0EC,KAA1E,EAAiFC,MAAjF,EAAyF;AAC9F;AACA,QAAMC,SAAS,GAAG,KAAlB,CAF8F,CAG9F;;AACA,QAAMC,kBAAkB,GAAG,EAA3B,CAJ8F,CAM9F;;AACA,QAAMC,kBAAkB,GAAG,IAAIR,gBAA/B;AAEA,QAAMS,WAAW,GAAG,KAAKR,IAAzB;AACA,QAAMS,UAAU,GAAG,OAAQR,MAAM,GAAGO,WAAV,GAAyBL,KAAhC,CAAnB;AACA,QAAMO,UAAU,GAAG,OAAQR,MAAM,GAAGM,WAAV,GAAyBJ,MAAhC,CAAnB,CAX8F,CAa9F;AACA;;AACA,QAAMO,kBAAkB,GAAGC,IAAI,CAACC,IAAL,CAAWV,KAAK,IAAI,CAAV,GAAgBC,MAAM,IAAI,CAApC,CAA3B;AACA,QAAMU,iBAAiB,GAAGF,IAAI,CAACC,IAAL,CAAWJ,UAAU,IAAI,CAAf,GAAqBC,UAAU,IAAI,CAA7C,CAA1B;AACA,QAAMK,gBAAgB,GAAGV,SAAS,GAAGS,iBAArC;AACA,QAAME,UAAU,GAAGD,gBAAgB,GAAGJ,kBAAtC;AAEA,QAAMM,qBAAqB,GAAGpB,KAAK,CACjCmB,UADiC,EAEjCT,kBAFiC,EAGjCD,kBAHiC,CAAnC;AAKA,SAAOW,qBAAP;AACD,C,CAED;;AACA,OAAO,SAASC,eAAT,CAAyBlB,IAAzB,EAA+BC,MAA/B,EAAuCC,MAAvC,EAA+CC,KAA/C,EAAsDC,MAAtD,EAA8De,QAA9D,EAAwEC,cAAxE,EAAwF;AAC7F,QAAMC,CAAC,GAAGF,QAAV;AACA,QAAM,CAACG,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBC,IAAnB,IAA2B,IAAI7B,gBAAJ,CAAqB;AAAEI,IAAAA;AAAF,GAArB,EAA+B0B,YAA/B,CAA4C;AAC3EtB,IAAAA,MAD2E;AAE3ED,IAAAA,KAF2E;AAG3EwB,IAAAA,SAAS,EAAE;AAAE3B,MAAAA,IAAF;AAAQ4B,MAAAA,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;AAAhB;AAHgE,GAA5C,EAI9BC,SAJ8B,EAAjC;AAKA,QAAMC,CAAC,GAAGL,IAAI,GAAGF,IAAjB;AACA,QAAMQ,CAAC,GAAGP,IAAI,GAAGF,IAAjB;AACA,QAAMU,EAAE,GAAG/B,MAAX;AACA,QAAMgC,EAAE,GAAG/B,MAAX;AACA,QAAMgC,CAAC,GAAG/B,KAAV;AACA,QAAMgC,CAAC,GAAG/B,MAAV;AAEA,MAAIgC,GAAG,GAAGhB,cAAV;;AACA,MAAI,CAACgB,GAAL,EAAU;AACRA,IAAAA,GAAG,GAAGxB,IAAI,CAACyB,GAAL,CAAS,CAAT,EAAY,IAAK,OAAOzB,IAAI,CAAC0B,KAAL,CAAWjB,CAAX,IAAgB,CAAvB,CAAjB,CAAN;AACD,GAjB4F,CAkB7F;AACA;;;AACA,QAAMkB,KAAK,GAAKH,GAAG,GAAGF,CAAN,GAAUC,CAAX,GAAgBd,CAAjB,IAAuBY,EAAE,GAAGF,CAA5B,KAAkCC,EAAE,GAAGF,CAAvC,CAAd;AACA,QAAMU,YAAY,GAAG3C,KAAK,CAAC0C,KAAD,EAAQ,OAAO,GAAf,EAAoB,GAApB,CAA1B;AACA,SAAOC,YAAP;AACD","sourcesContent":["import { OrthographicView } from 'deck.gl';\nimport clamp from 'lodash/clamp';\n\n// Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\n// Reference: https://observablehq.com/@bmschmidt/dot-density-election-maps-with-webgl\nexport function getPointSizeDevicePixels(devicePixelRatio, zoom, xRange, yRange, width, height) {\n  // Size of a point, in units of the diagonal axis.\n  const pointSize = 0.001;\n  // Point size maximum, in screen pixels.\n  const pointScreenSizeMax = 10;\n\n  // Point size minimum, in screen pixels.\n  const pointScreenSizeMin = 1 / devicePixelRatio;\n\n  const scaleFactor = 2 ** zoom;\n  const xAxisRange = 2.0 / ((xRange * scaleFactor) / width);\n  const yAxisRange = 2.0 / ((yRange * scaleFactor) / height);\n\n  // The diagonal screen size as a fraction of the current diagonal axis range,\n  // then converted to device pixels.\n  const diagonalScreenSize = Math.sqrt((width ** 2) + (height ** 2));\n  const diagonalAxisRange = Math.sqrt((xAxisRange ** 2) + (yAxisRange ** 2));\n  const diagonalFraction = pointSize / diagonalAxisRange;\n  const deviceSize = diagonalFraction * diagonalScreenSize;\n\n  const pointSizeDevicePixels = clamp(\n    deviceSize,\n    pointScreenSizeMin,\n    pointScreenSizeMax,\n  );\n  return pointSizeDevicePixels;\n}\n\n// Reference: https://observablehq.com/@rreusser/selecting-the-right-opacity-for-2d-point-clouds\nexport function getPointOpacity(zoom, xRange, yRange, width, height, numCells, avgFillDensity) {\n  const N = numCells;\n  const [minX, minY, maxX, maxY] = new OrthographicView({ zoom }).makeViewport({\n    height,\n    width,\n    viewState: { zoom, target: [0, 0, 0] },\n  }).getBounds();\n  const X = maxY - minY;\n  const Y = maxX - minX;\n  const X0 = xRange;\n  const Y0 = yRange;\n  const W = width;\n  const H = height;\n\n  let rho = avgFillDensity;\n  if (!rho) {\n    rho = Math.min(1, 1 / (10 ** (Math.log10(N) - 3)));\n  }\n  // p in the calculation is the pixel length/width of a given point, which for us is 1\n  // so it does not factor into our calculation here.\n  const alpha = ((rho * W * H) / N) * (Y0 / Y) * (X0 / X);\n  const pointOpacity = clamp(alpha, 1.01 / 255, 1.0);\n  return pointOpacity;\n}\n"]},"metadata":{},"sourceType":"module"}