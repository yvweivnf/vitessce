{"ast":null,"code":"import GL from '@luma.gl/constants'; // eslint-disable-line import/no-extraneous-dependencies\n\nimport { project32, picking } from '@deck.gl/core'; // eslint-disable-line import/no-extraneous-dependencies\n\nimport { Texture2D, isWebGL2 } from '@luma.gl/core';\nimport { XRLayer } from '@hms-dbmi/viv';\nimport { fs, vs } from './bitmask-layer-shaders';\nimport { GLSL_COLORMAPS, GLSL_COLORMAP_DEFAULT, COLORMAP_SHADER_PLACEHOLDER } from './constants';\n\nfunction padWithDefault(arr, defaultValue, padWidth) {\n  const newArr = [...arr];\n\n  for (let i = 0; i < padWidth; i += 1) {\n    newArr.push(defaultValue);\n  }\n\n  return newArr;\n}\n\nconst defaultProps = {\n  hoveredCell: {\n    type: 'number',\n    value: null,\n    compare: true\n  },\n  cellColorData: {\n    type: 'object',\n    value: null,\n    compare: true\n  },\n  colormap: {\n    type: 'string',\n    value: GLSL_COLORMAP_DEFAULT,\n    compare: true\n  },\n  expressionData: {\n    type: 'object',\n    value: null,\n    compare: true\n  }\n};\n/**\n * A BitmapLayer that performs aggregation in the fragment shader,\n * and renders its texture from a Uint8Array rather than an ImageData.\n */\n\nexport default class BitmaskLayer extends XRLayer {\n  // eslint-disable-next-line class-methods-use-this\n  getShaders() {\n    const {\n      colormap\n    } = this.props;\n    return {\n      fs,\n      vs,\n      modules: [project32, picking],\n      defines: {\n        [COLORMAP_SHADER_PLACEHOLDER]: GLSL_COLORMAPS.includes(colormap) ? colormap : GLSL_COLORMAP_DEFAULT\n      }\n    };\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    super.updateState({\n      props,\n      oldProps,\n      changeFlags\n    });\n\n    if (props.cellColorData !== oldProps.cellColorData) {\n      this.setColorTexture();\n    }\n\n    if (props.expressionData !== oldProps.expressionData) {\n      const {\n        expressionData,\n        cellTexHeight,\n        cellTexWidth\n      } = this.props;\n      const expressionTex = this.dataToTexture(expressionData, cellTexWidth, cellTexHeight);\n      this.setState({\n        expressionTex\n      });\n    }\n\n    if (props.colormap !== oldProps.colormap) {\n      const {\n        gl\n      } = this.context;\n\n      if (this.state.model) {\n        this.state.model.delete();\n      } // eslint-disable-next-line no-underscore-dangle\n\n\n      this.setState({\n        model: this._getModel(gl)\n      });\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  setColorTexture() {\n    const {\n      cellColorData: data,\n      cellTexHeight: height,\n      cellTexWidth: width\n    } = this.props;\n    const colorTex = new Texture2D(this.context.gl, {\n      width,\n      height,\n      // Only use Float32 so we don't have to write two shaders\n      data,\n      // we don't want or need mimaps\n      mipmaps: false,\n      parameters: {\n        // NEAREST for integer data\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        // CLAMP_TO_EDGE to remove tile artifacts\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      format: GL.RGB,\n      dataFormat: GL.RGB,\n      type: GL.UNSIGNED_BYTE\n    });\n    this.setState({\n      colorTex\n    });\n  }\n\n  draw(opts) {\n    const {\n      uniforms\n    } = opts;\n    const {\n      channelsVisible,\n      hoveredCell,\n      colorScaleLo,\n      colorScaleHi,\n      isExpressionMode\n    } = this.props;\n    const {\n      textures,\n      model,\n      colorTex,\n      expressionTex\n    } = this.state; // Render the image\n\n    if (textures && model && colorTex) {\n      model.setUniforms(Object.assign({}, uniforms, {\n        hovered: hoveredCell || 0,\n        colorTex,\n        expressionTex,\n        colorTexHeight: colorTex.height,\n        colorTexWidth: colorTex.width,\n        channelsVisible: padWithDefault(channelsVisible, false, // There are six texture entries on the shaders\n        6 - channelsVisible.length),\n        uColorScaleRange: [colorScaleLo, colorScaleHi],\n        uIsExpressionMode: isExpressionMode,\n        ...textures\n      })).draw();\n    }\n  }\n  /**\n   * This function creates textures from the data\n   */\n\n\n  dataToTexture(data, width, height) {\n    const isWebGL2On = isWebGL2(this.context.gl);\n    return new Texture2D(this.context.gl, {\n      width,\n      height,\n      // Only use Float32 so we don't have to write two shaders\n      data: new Float32Array(data),\n      // we don't want or need mimaps\n      mipmaps: false,\n      parameters: {\n        // NEAREST for integer data\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        // CLAMP_TO_EDGE to remove tile artifacts\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      format: isWebGL2On ? GL.R32F : GL.LUMINANCE,\n      dataFormat: isWebGL2On ? GL.RED : GL.LUMINANCE,\n      type: GL.FLOAT\n    });\n  }\n\n}\nBitmaskLayer.layerName = 'BitmaskLayer';\nBitmaskLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/layers/BitmaskLayer.js"],"names":["GL","project32","picking","Texture2D","isWebGL2","XRLayer","fs","vs","GLSL_COLORMAPS","GLSL_COLORMAP_DEFAULT","COLORMAP_SHADER_PLACEHOLDER","padWithDefault","arr","defaultValue","padWidth","newArr","i","push","defaultProps","hoveredCell","type","value","compare","cellColorData","colormap","expressionData","BitmaskLayer","getShaders","props","modules","defines","includes","updateState","oldProps","changeFlags","setColorTexture","cellTexHeight","cellTexWidth","expressionTex","dataToTexture","setState","gl","context","state","model","delete","_getModel","getAttributeManager","invalidateAll","data","height","width","colorTex","mipmaps","parameters","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","format","RGB","dataFormat","UNSIGNED_BYTE","draw","opts","uniforms","channelsVisible","colorScaleLo","colorScaleHi","isExpressionMode","textures","setUniforms","Object","assign","hovered","colorTexHeight","colorTexWidth","length","uColorScaleRange","uIsExpressionMode","isWebGL2On","Float32Array","R32F","LUMINANCE","RED","FLOAT","layerName"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants'; // eslint-disable-line import/no-extraneous-dependencies\nimport { project32, picking } from '@deck.gl/core'; // eslint-disable-line import/no-extraneous-dependencies\nimport { Texture2D, isWebGL2 } from '@luma.gl/core';\nimport { XRLayer } from '@hms-dbmi/viv';\nimport { fs, vs } from './bitmask-layer-shaders';\nimport {\n  GLSL_COLORMAPS,\n  GLSL_COLORMAP_DEFAULT,\n  COLORMAP_SHADER_PLACEHOLDER,\n} from './constants';\n\nfunction padWithDefault(arr, defaultValue, padWidth) {\n  const newArr = [...arr];\n  for (let i = 0; i < padWidth; i += 1) {\n    newArr.push(defaultValue);\n  }\n  return newArr;\n}\n\nconst defaultProps = {\n  hoveredCell: { type: 'number', value: null, compare: true },\n  cellColorData: { type: 'object', value: null, compare: true },\n  colormap: { type: 'string', value: GLSL_COLORMAP_DEFAULT, compare: true },\n  expressionData: { type: 'object', value: null, compare: true },\n};\n\n/**\n * A BitmapLayer that performs aggregation in the fragment shader,\n * and renders its texture from a Uint8Array rather than an ImageData.\n */\nexport default class BitmaskLayer extends XRLayer {\n  // eslint-disable-next-line class-methods-use-this\n  getShaders() {\n    const { colormap } = this.props;\n    return {\n      fs,\n      vs,\n      modules: [project32, picking],\n      defines: {\n        [COLORMAP_SHADER_PLACEHOLDER]: GLSL_COLORMAPS.includes(colormap)\n          ? colormap\n          : GLSL_COLORMAP_DEFAULT,\n      },\n    };\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    super.updateState({ props, oldProps, changeFlags });\n    if (props.cellColorData !== oldProps.cellColorData) {\n      this.setColorTexture();\n    }\n    if (props.expressionData !== oldProps.expressionData) {\n      const { expressionData, cellTexHeight, cellTexWidth } = this.props;\n      const expressionTex = this.dataToTexture(\n        expressionData,\n        cellTexWidth,\n        cellTexHeight,\n      );\n      this.setState({ expressionTex });\n    }\n    if (props.colormap !== oldProps.colormap) {\n      const { gl } = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      // eslint-disable-next-line no-underscore-dangle\n      this.setState({ model: this._getModel(gl) });\n\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  setColorTexture() {\n    const {\n      cellColorData: data,\n      cellTexHeight: height,\n      cellTexWidth: width,\n    } = this.props;\n    const colorTex = new Texture2D(this.context.gl, {\n      width,\n      height,\n      // Only use Float32 so we don't have to write two shaders\n      data,\n      // we don't want or need mimaps\n      mipmaps: false,\n      parameters: {\n        // NEAREST for integer data\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        // CLAMP_TO_EDGE to remove tile artifacts\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n      },\n      format: GL.RGB,\n      dataFormat: GL.RGB,\n      type: GL.UNSIGNED_BYTE,\n    });\n    this.setState({ colorTex });\n  }\n\n  draw(opts) {\n    const { uniforms } = opts;\n    const {\n      channelsVisible,\n      hoveredCell,\n      colorScaleLo,\n      colorScaleHi,\n      isExpressionMode,\n    } = this.props;\n    const {\n      textures, model, colorTex, expressionTex,\n    } = this.state;\n    // Render the image\n    if (textures && model && colorTex) {\n      model\n        .setUniforms(\n          Object.assign({}, uniforms, {\n            hovered: hoveredCell || 0,\n            colorTex,\n            expressionTex,\n            colorTexHeight: colorTex.height,\n            colorTexWidth: colorTex.width,\n            channelsVisible: padWithDefault(\n              channelsVisible,\n              false,\n              // There are six texture entries on the shaders\n              6 - channelsVisible.length,\n            ),\n            uColorScaleRange: [colorScaleLo, colorScaleHi],\n            uIsExpressionMode: isExpressionMode,\n            ...textures,\n          }),\n        )\n        .draw();\n    }\n  }\n\n  /**\n   * This function creates textures from the data\n   */\n  dataToTexture(data, width, height) {\n    const isWebGL2On = isWebGL2(this.context.gl);\n    return new Texture2D(this.context.gl, {\n      width,\n      height,\n      // Only use Float32 so we don't have to write two shaders\n      data: new Float32Array(data),\n      // we don't want or need mimaps\n      mipmaps: false,\n      parameters: {\n        // NEAREST for integer data\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        // CLAMP_TO_EDGE to remove tile artifacts\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n      },\n      format: isWebGL2On ? GL.R32F : GL.LUMINANCE,\n      dataFormat: isWebGL2On ? GL.RED : GL.LUMINANCE,\n      type: GL.FLOAT,\n    });\n  }\n}\nBitmaskLayer.layerName = 'BitmaskLayer';\nBitmaskLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}