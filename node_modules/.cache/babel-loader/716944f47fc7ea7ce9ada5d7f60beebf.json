{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  var tooltip = oldEncoding.tooltip,\n      filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n\n  if (!tooltip) {\n    return {\n      filteredEncoding: filteredEncoding\n    };\n  }\n\n  var customTooltipWithAggregatedField;\n  var customTooltipWithoutAggregatedField;\n\n  if (isArray(tooltip)) {\n    var _iterator = _createForOfIteratorHelper(tooltip),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var t = _step.value;\n\n        if (t.aggregate) {\n          if (!customTooltipWithAggregatedField) {\n            customTooltipWithAggregatedField = [];\n          }\n\n          customTooltipWithAggregatedField.push(t);\n        } else {\n          if (!customTooltipWithoutAggregatedField) {\n            customTooltipWithoutAggregatedField = [];\n          }\n\n          customTooltipWithoutAggregatedField.push(t);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n\n  return {\n    customTooltipWithoutAggregatedField: customTooltipWithoutAggregatedField,\n    filteredEncoding: filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis) {\n  var withFieldName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n\n  var fiveSummaryTooltip = tooltipSummary.map(function (_ref) {\n    var fieldPrefix = _ref.fieldPrefix,\n        titlePrefix = _ref.titlePrefix;\n    var mainTitle = withFieldName ? \" of \".concat(getTitle(continuousAxisChannelDef)) : '';\n    return {\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: isSignalRef(titlePrefix) ? {\n        signal: \"\".concat(titlePrefix, \"\\\"\").concat(escape(mainTitle), \"\\\"\")\n      } : titlePrefix + mainTitle\n    };\n  });\n  var tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n  return {\n    tooltip: [].concat(_toConsumableArray(fiveSummaryTooltip), _toConsumableArray(unique(tooltipFieldDefs, hash)))\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  var title = continuousAxisChannelDef.title,\n      field = continuousAxisChannelDef.field;\n  return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  var scale = continuousAxisChannelDef.scale,\n      axis = continuousAxisChannelDef.axis;\n  return function (_ref2) {\n    var partName = _ref2.partName,\n        mark = _ref2.mark,\n        positionPrefix = _ref2.positionPrefix,\n        _ref2$endPositionPref = _ref2.endPositionPrefix,\n        endPositionPrefix = _ref2$endPositionPref === void 0 ? undefined : _ref2$endPositionPref,\n        _ref2$extraEncoding = _ref2.extraEncoding,\n        extraEncoding = _ref2$extraEncoding === void 0 ? {} : _ref2$extraEncoding;\n    var title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark: mark,\n      encoding: Object.assign(Object.assign(Object.assign(_defineProperty({}, continuousAxis, Object.assign(Object.assign(Object.assign({\n        field: \"\".concat(positionPrefix, \"_\").concat(continuousAxisChannelDef.field),\n        type: continuousAxisChannelDef.type\n      }, title !== undefined ? {\n        title: title\n      } : {}), scale !== undefined ? {\n        scale: scale\n      } : {}), axis !== undefined ? {\n        axis: axis\n      } : {})), isString(endPositionPrefix) ? _defineProperty({}, \"\".concat(continuousAxis, \"2\"), {\n        field: \"\".concat(endPositionPrefix, \"_\").concat(continuousAxisChannelDef.field)\n      }) : {}), sharedEncoding), extraEncoding)\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  var clip = markDef.clip,\n      color = markDef.color,\n      opacity = markDef.opacity;\n  var mark = markDef.type;\n\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [Object.assign(Object.assign({}, partBaseSpec), {\n      mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? {\n        clip: clip\n      } : {}), color ? {\n        color: color\n      } : {}), opacity ? {\n        opacity: opacity\n      } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n        type: partBaseSpec.mark\n      }), {\n        style: \"\".concat(mark, \"-\").concat(part)\n      }), isBoolean(markDef[part]) ? {} : markDef[part])\n    })];\n  }\n\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  var encoding = spec.encoding;\n  var continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  var continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n\n  var continuousAxisChannelDef2 = encoding[\"\".concat(continuousAxis, \"2\")];\n  var continuousAxisChannelDefError = encoding[\"\".concat(continuousAxis, \"Error\")];\n  var continuousAxisChannelDefError2 = encoding[\"\".concat(continuousAxis, \"Error2\")];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis: continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {\n    var aggregate = continuousAxisChannelDef.aggregate,\n        continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient(spec, compositeMark) {\n  var mark = spec.mark,\n      encoding = spec.encoding;\n  var x = encoding.x,\n      y = encoding.y;\n\n  if (isMarkDef(mark) && mark.orient) {\n    return mark.orient;\n  }\n\n  if (isContinuousFieldOrDatumDef(x)) {\n    // x is continuous\n    if (isContinuousFieldOrDatumDef(y)) {\n      // both x and y are continuous\n      var xAggregate = isFieldDef(x) && x.aggregate;\n      var yAggregate = isFieldDef(y) && y.aggregate;\n\n      if (!xAggregate && yAggregate === compositeMark) {\n        return 'vertical';\n      } else if (!yAggregate && xAggregate === compositeMark) {\n        return 'horizontal';\n      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n          // y is temporal but x is not\n          return 'horizontal';\n        } // default orientation for two continuous\n\n\n        return 'vertical';\n      }\n    }\n\n    return 'horizontal';\n  } else if (isContinuousFieldOrDatumDef(y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error(\"Need a valid continuous axis for \".concat(compositeMark, \"s\"));\n  }\n}","map":{"version":3,"sources":["../../../src/compositemark/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n    const { tooltip } = oldEncoding, filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n    if (!tooltip) {\n        return { filteredEncoding };\n    }\n    let customTooltipWithAggregatedField;\n    let customTooltipWithoutAggregatedField;\n    if (isArray(tooltip)) {\n        for (const t of tooltip) {\n            if (t.aggregate) {\n                if (!customTooltipWithAggregatedField) {\n                    customTooltipWithAggregatedField = [];\n                }\n                customTooltipWithAggregatedField.push(t);\n            }\n            else {\n                if (!customTooltipWithoutAggregatedField) {\n                    customTooltipWithoutAggregatedField = [];\n                }\n                customTooltipWithoutAggregatedField.push(t);\n            }\n        }\n        if (customTooltipWithAggregatedField) {\n            filteredEncoding.tooltip = customTooltipWithAggregatedField;\n        }\n    }\n    else {\n        if (tooltip['aggregate']) {\n            filteredEncoding.tooltip = tooltip;\n        }\n        else {\n            customTooltipWithoutAggregatedField = tooltip;\n        }\n    }\n    if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n        customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n    }\n    return { customTooltipWithoutAggregatedField, filteredEncoding };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {\n    if ('tooltip' in encodingWithoutContinuousAxis) {\n        return { tooltip: encodingWithoutContinuousAxis.tooltip };\n    }\n    const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {\n        const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n        return {\n            field: fieldPrefix + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type,\n            title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}\"${escape(mainTitle)}\"` } : titlePrefix + mainTitle\n        };\n    });\n    const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n    return {\n        tooltip: [\n            ...fiveSummaryTooltip,\n            // need to cast because TextFieldDef supports fewer types of bin\n            ...unique(tooltipFieldDefs, hash)\n        ]\n    };\n}\nexport function getTitle(continuousAxisChannelDef) {\n    const { title, field } = continuousAxisChannelDef;\n    return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n    const { scale, axis } = continuousAxisChannelDef;\n    return ({ partName, mark, positionPrefix, endPositionPrefix = undefined, extraEncoding = {} }) => {\n        const title = getTitle(continuousAxisChannelDef);\n        return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n            mark,\n            encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: `${positionPrefix}_${continuousAxisChannelDef.field}`, type: continuousAxisChannelDef.type }, (title !== undefined ? { title } : {})), (scale !== undefined ? { scale } : {})), (axis !== undefined ? { axis } : {})) }, (isString(endPositionPrefix)\n                ? {\n                    [`${continuousAxis}2`]: {\n                        field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n                    }\n                }\n                : {})), sharedEncoding), extraEncoding)\n        });\n    };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n    const { clip, color, opacity } = markDef;\n    const mark = markDef.type;\n    if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n        return [\n            Object.assign(Object.assign({}, partBaseSpec), { mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), (clip ? { clip } : {})), (color ? { color } : {})), (opacity ? { opacity } : {})), (isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark })), { style: `${mark}-${part}` }), (isBoolean(markDef[part]) ? {} : markDef[part])) })\n        ];\n    }\n    return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n    const { encoding } = spec;\n    const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n    const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n    const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];\n    const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];\n    const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];\n    return {\n        continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n        continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n        continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n        continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n        continuousAxis\n    };\n}\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n    if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {\n        const { aggregate } = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n        if (aggregate !== compositeMark) {\n            log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n        }\n        return continuousAxisWithoutAggregate;\n    }\n    else {\n        return continuousAxisChannelDef;\n    }\n}\nexport function compositeMarkOrient(spec, compositeMark) {\n    const { mark, encoding } = spec;\n    const { x, y } = encoding;\n    if (isMarkDef(mark) && mark.orient) {\n        return mark.orient;\n    }\n    if (isContinuousFieldOrDatumDef(x)) {\n        // x is continuous\n        if (isContinuousFieldOrDatumDef(y)) {\n            // both x and y are continuous\n            const xAggregate = isFieldDef(x) && x.aggregate;\n            const yAggregate = isFieldDef(y) && y.aggregate;\n            if (!xAggregate && yAggregate === compositeMark) {\n                return 'vertical';\n            }\n            else if (!yAggregate && xAggregate === compositeMark) {\n                return 'horizontal';\n            }\n            else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n                throw new Error('Both x and y cannot have aggregate');\n            }\n            else {\n                if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n                    // y is temporal but x is not\n                    return 'horizontal';\n                }\n                // default orientation for two continuous\n                return 'vertical';\n            }\n        }\n        return 'horizontal';\n    }\n    else if (isContinuousFieldOrDatumDef(y)) {\n        // y is continuous but x is not\n        return 'vertical';\n    }\n    else {\n        // Neither x nor y is continuous.\n        throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n    }\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}