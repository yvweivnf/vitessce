{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _constants = _interopRequireDefault(require(\"@luma.gl/constants\"));\n\nvar _core = require(\"@luma.gl/core\");\n\nvar _outline = _interopRequireDefault(require(\"../../shaderlib/outline/outline\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // TODO - this should be built into assembleShaders\n\n\nfunction injectShaderCode(_ref) {\n  var source = _ref.source,\n      _ref$code = _ref.code,\n      code = _ref$code === void 0 ? '' : _ref$code;\n  var INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nvar VS_CODE = \"  outline_setUV(gl_Position);\\n  outline_setZLevel(instanceZLevel);\\n\";\nvar FS_CODE = \"  gl_FragColor = outline_filterColor(gl_FragColor);\\n\";\nvar defaultProps = {\n  getZLevel: {\n    type: 'accessor',\n    value: 0\n  }\n};\n\nvar PathOutlineLayer = /*#__PURE__*/function (_PathLayer) {\n  _inherits(PathOutlineLayer, _PathLayer);\n\n  var _super = _createSuper(PathOutlineLayer);\n\n  function PathOutlineLayer() {\n    _classCallCheck(this, PathOutlineLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PathOutlineLayer, [{\n    key: \"getShaders\",\n    // Override getShaders to inject the outline module\n    value: function getShaders() {\n      var shaders = _get(_getPrototypeOf(PathOutlineLayer.prototype), \"getShaders\", this).call(this);\n\n      return Object.assign({}, shaders, {\n        modules: shaders.modules.concat([_outline[\"default\"]]),\n        vs: injectShaderCode({\n          source: shaders.vs,\n          code: VS_CODE\n        }),\n        fs: injectShaderCode({\n          source: shaders.fs,\n          code: FS_CODE\n        })\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState(context) {\n      _get(_getPrototypeOf(PathOutlineLayer.prototype), \"initializeState\", this).call(this, context); // Create an outline \"shadow\" map\n      // TODO - we should create a single outlineMap for all layers\n\n\n      this.setState({\n        outlineFramebuffer: new _core.Framebuffer(context.gl),\n        dummyTexture: new _core.Texture2D(context.gl)\n      }); // Create an attribute manager\n\n      this.state.attributeManager.addInstanced({\n        instanceZLevel: {\n          size: 1,\n          type: _constants[\"default\"].UNSIGNED_BYTE,\n          update: this.calculateZLevels,\n          accessor: 'getZLevel'\n        }\n      });\n    } // Override draw to add render module\n\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var _ref2$moduleParameter = _ref2.moduleParameters,\n          moduleParameters = _ref2$moduleParameter === void 0 ? {} : _ref2$moduleParameter,\n          parameters = _ref2.parameters,\n          uniforms = _ref2.uniforms,\n          context = _ref2.context; // Need to calculate same uniforms as base layer\n\n      var _this$props = this.props,\n          rounded = _this$props.rounded,\n          miterLimit = _this$props.miterLimit,\n          widthScale = _this$props.widthScale,\n          widthMinPixels = _this$props.widthMinPixels,\n          widthMaxPixels = _this$props.widthMaxPixels,\n          dashJustified = _this$props.dashJustified;\n      uniforms = Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        alignMode: Number(dashJustified),\n        widthScale: widthScale,\n        miterLimit: miterLimit,\n        widthMinPixels: widthMinPixels,\n        widthMaxPixels: widthMaxPixels\n      }); // Render the outline shadowmap (based on segment z orders)\n\n      var _this$state = this.state,\n          outlineFramebuffer = _this$state.outlineFramebuffer,\n          dummyTexture = _this$state.dummyTexture;\n      outlineFramebuffer.resize();\n      outlineFramebuffer.clear({\n        color: true,\n        depth: true\n      });\n      this.state.model.updateModuleSettings({\n        outlineEnabled: true,\n        outlineRenderShadowmap: true,\n        outlineShadowmap: dummyTexture\n      });\n      this.state.model.draw({\n        uniforms: Object.assign({}, uniforms, {\n          jointType: 0,\n          widthScale: this.props.widthScale * 1.3\n        }),\n        parameters: {\n          depthTest: false,\n          // Biggest value needs to go into buffer\n          blendEquation: _constants[\"default\"].MAX\n        },\n        framebuffer: outlineFramebuffer\n      }); // Now use the outline shadowmap to render the lines (with outlines)\n\n      this.state.model.updateModuleSettings({\n        outlineEnabled: true,\n        outlineRenderShadowmap: false,\n        outlineShadowmap: outlineFramebuffer\n      });\n      this.state.model.draw({\n        uniforms: Object.assign({}, uniforms, {\n          jointType: Number(rounded),\n          widthScale: this.props.widthScale\n        }),\n        parameters: {\n          depthTest: false\n        }\n      });\n    }\n  }, {\n    key: \"calculateZLevels\",\n    value: function calculateZLevels(attribute) {\n      var getZLevel = this.props.getZLevel;\n      var pathTesselator = this.state.pathTesselator;\n      attribute.value = pathTesselator._updateAttribute({\n        target: attribute.value,\n        size: 1,\n        getValue: function getValue(object, index) {\n          return [getZLevel(object, index) || 0];\n        }\n      });\n    }\n  }]);\n\n  return PathOutlineLayer;\n}(_layers.PathLayer);\n\nexports[\"default\"] = PathOutlineLayer;\n\n_defineProperty(PathOutlineLayer, \"layerName\", 'PathOutlineLayer');\n\n_defineProperty(PathOutlineLayer, \"defaultProps\", defaultProps);","map":{"version":3,"sources":["../../../src/layers/path-outline-layer/path-outline-layer.ts"],"names":["source","code","INJECT_CODE","VS_CODE","FS_CODE","defaultProps","getZLevel","type","value","PathOutlineLayer","PathLayer","shaders","modules","outline","vs","injectShaderCode","fs","context","outlineFramebuffer","Framebuffer","dummyTexture","Texture2D","instanceZLevel","size","GL","update","accessor","moduleParameters","parameters","uniforms","rounded","miterLimit","widthScale","widthMinPixels","widthMaxPixels","dashJustified","jointType","Number","alignMode","color","depth","outlineEnabled","outlineRenderShadowmap","outlineShadowmap","depthTest","blendEquation","MAX","framebuffer","attribute","pathTesselator","target","getValue"],"mappings":"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","sourcesContent":["import { PathLayer } from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport { Framebuffer, Texture2D } from '@luma.gl/core';\nimport outline from '../../shaderlib/outline/outline';\n\n// TODO - this should be built into assembleShaders\nfunction injectShaderCode({ source, code = '' }) {\n  const INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nconst VS_CODE = `\\\n  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n`;\n\nconst FS_CODE = `\\\n  gl_FragColor = outline_filterColor(gl_FragColor);\n`;\n\nconst defaultProps = {\n  getZLevel: { type: 'accessor', value: 0 },\n};\n\nexport default class PathOutlineLayer extends PathLayer<any> {\n  static layerName = 'PathOutlineLayer';\n  static defaultProps = defaultProps;\n\n  // Override getShaders to inject the outline module\n  getShaders() {\n    const shaders = super.getShaders();\n    return Object.assign({}, shaders, {\n      modules: shaders.modules.concat([outline]),\n      vs: injectShaderCode({ source: shaders.vs, code: VS_CODE }),\n      fs: injectShaderCode({ source: shaders.fs, code: FS_CODE }),\n    });\n  }\n\n  initializeState(context: any) {\n    super.initializeState(context);\n\n    // Create an outline \"shadow\" map\n    // TODO - we should create a single outlineMap for all layers\n    this.setState({\n      outlineFramebuffer: new Framebuffer(context.gl),\n      dummyTexture: new Texture2D(context.gl),\n    });\n\n    // Create an attribute manager\n    this.state.attributeManager.addInstanced({\n      instanceZLevel: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateZLevels,\n        accessor: 'getZLevel',\n      },\n    });\n  }\n\n  // Override draw to add render module\n  draw({ moduleParameters = {}, parameters, uniforms, context }) {\n    // Need to calculate same uniforms as base layer\n    const {\n      rounded,\n      miterLimit,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n      dashJustified,\n    } = this.props;\n\n    uniforms = Object.assign({}, uniforms, {\n      jointType: Number(rounded),\n      alignMode: Number(dashJustified),\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels,\n    });\n\n    // Render the outline shadowmap (based on segment z orders)\n    const { outlineFramebuffer, dummyTexture } = this.state;\n    outlineFramebuffer.resize();\n    outlineFramebuffer.clear({ color: true, depth: true });\n\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: true,\n      outlineShadowmap: dummyTexture,\n    });\n\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: 0,\n        widthScale: this.props.widthScale * 1.3,\n      }),\n      parameters: {\n        depthTest: false,\n        // Biggest value needs to go into buffer\n        blendEquation: GL.MAX,\n      },\n      framebuffer: outlineFramebuffer,\n    });\n\n    // Now use the outline shadowmap to render the lines (with outlines)\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: false,\n      outlineShadowmap: outlineFramebuffer,\n    });\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        widthScale: this.props.widthScale,\n      }),\n      parameters: {\n        depthTest: false,\n      },\n    });\n  }\n\n  calculateZLevels(attribute) {\n    const { getZLevel } = this.props;\n    const { pathTesselator } = this.state;\n\n    attribute.value = pathTesselator._updateAttribute({\n      target: attribute.value,\n      size: 1,\n      getValue: (object, index) => [getZLevel(object, index) || 0],\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}