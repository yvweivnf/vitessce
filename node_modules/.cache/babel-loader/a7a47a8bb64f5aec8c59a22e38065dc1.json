{"ast":null,"code":"import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import _objectSpread from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";import Ajv from'ajv';import isNil from'lodash/isNil';import{dsvFormat}from'd3-dsv';import{parse as json2csv}from'json2csv';import{colorArrayToString,colorStringToArray}from'./utils';import{nodeTransform}from'./cell-set-utils';import{getDefaultColor}from'../utils';import{HIERARCHICAL_SCHEMAS,TABULAR_SCHEMAS,MIME_TYPE_JSON,MIME_TYPE_TABULAR,SEPARATOR_TABULAR,NA_VALUE_TABULAR}from'./constants';/**\n * Check if an imported tree has an old schema version that we know how to\n * \"upgrade\" to the latest schema version.  Validate against the schema.\n * @param {object} currTree A hierarchical tree object with a .version property,\n * which has already passed schema validation, but may not have the latest schema version.\n * @param {string} datatype The data type of the items in the schema.\n */export function tryUpgradeTreeToLatestSchema(currTree,datatype){var validate=new Ajv().compile(HIERARCHICAL_SCHEMAS[datatype].schema);var valid=validate(currTree);if(!valid){var failureReason=JSON.stringify(validate.errors,null,2);throw new Error(\"Tree validation failed: \".concat(failureReason));}else if(currTree.datatype!==datatype){throw new Error(\"The data type does not match the expected data type of '\".concat(datatype,\"'.\"));}if(currTree.version==='0.1.2'){// To upgrade from cell-sets schema 0.1.2 to 0.1.3,\n// add a confidence value of null for each cell ID.\nreturn _objectSpread({},currTree,{version:HIERARCHICAL_SCHEMAS[datatype].latestVersion,tree:currTree.tree.map(function(levelZeroNode){return nodeTransform(levelZeroNode,function(n){return!n.children&&Array.isArray(n.set);},function(n){return _objectSpread({},n,{set:n.set.map(function(itemId){return[itemId,null];})});},[]);})});}return currTree;}/**\n * Handler for JSON imports. Validates and upgrades against the hierarchical sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */ // eslint-disable-next-line no-unused-vars\nexport function handleImportJSON(result,datatype,theme){var importData=JSON.parse(result);// Validate the imported file.\nimportData=tryUpgradeTreeToLatestSchema(importData,datatype);return importData;}/**\n * Handler for tabular imports. Validates against the tabular sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */export function handleImportTabular(result,datatype,theme){var dsvParser=dsvFormat(SEPARATOR_TABULAR);var importData=dsvParser.parse(result,function(row){return{groupName:row.groupName,setName:row.setName,setColor:row.setColor?colorStringToArray(row.setColor):getDefaultColor(theme),obsId:row.obsId,predictionScore:isNil(row.predictionScore)||row.predictionScore===NA_VALUE_TABULAR?null:+row.predictionScore};});// Validate the imported file.\nvar validate=new Ajv().compile(TABULAR_SCHEMAS[datatype].schema);var valid=validate(importData);if(!valid){var failureReason=JSON.stringify(validate.errors,null,2);throw new Error(\"Import validation failed: \".concat(failureReason));}else{// Convert the validated array to a tree representation.\nvar treeToImport={version:HIERARCHICAL_SCHEMAS[datatype].latestVersion,datatype:datatype,tree:[]};var uniqueGroupNames=Array.from(new Set(importData.map(function(d){return d.groupName;})));uniqueGroupNames.forEach(function(groupName){var levelZeroNode={name:groupName,children:[]};var groupRows=importData.filter(function(d){return d.groupName===groupName;});var uniqueSetNames=Array.from(new Set(groupRows.map(function(d){return d.setName;})));uniqueSetNames.forEach(function(setName){var setRows=groupRows.filter(function(d){return d.setName===setName;});var setColor=setRows[0].setColor;var levelOneNode={name:setName,color:setColor,set:setRows.map(function(d){return[d.obsId,d.predictionScore];})};levelZeroNode.children.push(levelOneNode);});treeToImport.tree.push(levelZeroNode);});return treeToImport;}}/**\n * Convert a tree object to a JSON representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */export function handleExportJSON(result){var jsonString=JSON.stringify(result);var dataString=\"data:\".concat(MIME_TYPE_JSON,\";charset=utf-8,\").concat(encodeURIComponent(jsonString));return dataString;}/**\n * Convert a tree object with one level (height === 1) to a tabular representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */export function handleExportTabular(result){// Convert a tree object to an array of JSON objects.\nvar exportData=[];result.tree.forEach(function(levelZeroNode){levelZeroNode.children.forEach(function(levelOneNode){if(levelOneNode.set){levelOneNode.set.forEach(function(_ref){var _ref2=_slicedToArray(_ref,2),obsId=_ref2[0],prob=_ref2[1];exportData.push({groupName:levelZeroNode.name,setName:levelOneNode.name,setColor:colorArrayToString(levelOneNode.color),obsId:obsId,predictionScore:isNil(prob)?NA_VALUE_TABULAR:prob});});}});});var csvString=json2csv(exportData,{fields:['groupName','setName','setColor','obsId','predictionScore'],delimiter:SEPARATOR_TABULAR});var dataString=\"data:\".concat(MIME_TYPE_TABULAR,\";charset=utf-8,\").concat(encodeURIComponent(csvString));return dataString;}/**\n * Download a file. Appends and removes an anchor node in the DOM.\n * @param {string} dataString The function that converts the data to a string.\n * @param {string} fileName The name of the file to be downloaded.\n */export function downloadForUser(dataString,fileName){var downloadAnchorNode=document.createElement('a');downloadAnchorNode.setAttribute('href',dataString);downloadAnchorNode.setAttribute('download',fileName);document.body.appendChild(downloadAnchorNode);// required for firefox\ndownloadAnchorNode.click();downloadAnchorNode.remove();}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/sets/io.js"],"names":["Ajv","isNil","dsvFormat","parse","json2csv","colorArrayToString","colorStringToArray","nodeTransform","getDefaultColor","HIERARCHICAL_SCHEMAS","TABULAR_SCHEMAS","MIME_TYPE_JSON","MIME_TYPE_TABULAR","SEPARATOR_TABULAR","NA_VALUE_TABULAR","tryUpgradeTreeToLatestSchema","currTree","datatype","validate","compile","schema","valid","failureReason","JSON","stringify","errors","Error","version","latestVersion","tree","map","levelZeroNode","n","children","Array","isArray","set","itemId","handleImportJSON","result","theme","importData","handleImportTabular","dsvParser","row","groupName","setName","setColor","obsId","predictionScore","treeToImport","uniqueGroupNames","from","Set","d","forEach","name","groupRows","filter","uniqueSetNames","setRows","levelOneNode","color","push","handleExportJSON","jsonString","dataString","encodeURIComponent","handleExportTabular","exportData","prob","csvString","fields","delimiter","downloadForUser","fileName","downloadAnchorNode","document","createElement","setAttribute","body","appendChild","click","remove"],"mappings":"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","sourcesContent":["import Ajv from 'ajv';\nimport isNil from 'lodash/isNil';\nimport { dsvFormat } from 'd3-dsv';\nimport { parse as json2csv } from 'json2csv';\nimport { colorArrayToString, colorStringToArray } from './utils';\nimport { nodeTransform } from './cell-set-utils';\nimport { getDefaultColor } from '../utils';\nimport {\n  HIERARCHICAL_SCHEMAS, TABULAR_SCHEMAS,\n  MIME_TYPE_JSON, MIME_TYPE_TABULAR,\n  SEPARATOR_TABULAR, NA_VALUE_TABULAR,\n} from './constants';\n\n/**\n * Check if an imported tree has an old schema version that we know how to\n * \"upgrade\" to the latest schema version.  Validate against the schema.\n * @param {object} currTree A hierarchical tree object with a .version property,\n * which has already passed schema validation, but may not have the latest schema version.\n * @param {string} datatype The data type of the items in the schema.\n */\nexport function tryUpgradeTreeToLatestSchema(currTree, datatype) {\n  const validate = new Ajv().compile(HIERARCHICAL_SCHEMAS[datatype].schema);\n  const valid = validate(currTree);\n  if (!valid) {\n    const failureReason = JSON.stringify(validate.errors, null, 2);\n    throw new Error(`Tree validation failed: ${failureReason}`);\n  } else if (currTree.datatype !== datatype) {\n    throw new Error(\n      `The data type does not match the expected data type of '${datatype}'.`,\n    );\n  }\n  if (currTree.version === '0.1.2') {\n    // To upgrade from cell-sets schema 0.1.2 to 0.1.3,\n    // add a confidence value of null for each cell ID.\n    return {\n      ...currTree,\n      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n      tree: currTree.tree.map(levelZeroNode => nodeTransform(\n        levelZeroNode,\n        n => !n.children && Array.isArray(n.set),\n        n => ({ ...n, set: n.set.map(itemId => ([itemId, null])) }), [],\n      )),\n    };\n  }\n  return currTree;\n}\n\n/**\n * Handler for JSON imports. Validates and upgrades against the hierarchical sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */\n// eslint-disable-next-line no-unused-vars\nexport function handleImportJSON(result, datatype, theme) {\n  let importData = JSON.parse(result);\n  // Validate the imported file.\n  importData = tryUpgradeTreeToLatestSchema(importData, datatype);\n  return importData;\n}\n\n/**\n * Handler for tabular imports. Validates against the tabular sets schema.\n * @param {string} result The data passed from the FileReader as a string.\n * @param {string} datatype The data type to validate against.\n * @param {string} theme \"light\" or \"dark\" for the vitessce theme\n * @returns {object} The imported tree object.\n * @throws {Error} Throws error if validation fails or if the datatype does not match.\n */\nexport function handleImportTabular(result, datatype, theme) {\n  const dsvParser = dsvFormat(SEPARATOR_TABULAR);\n  const importData = dsvParser.parse(result, row => ({\n    groupName: row.groupName,\n    setName: row.setName,\n    setColor: (row.setColor ? colorStringToArray(row.setColor) : getDefaultColor(theme)),\n    obsId: row.obsId,\n    predictionScore: (\n      (\n        isNil(row.predictionScore)\n        || row.predictionScore === NA_VALUE_TABULAR\n      )\n        ? null\n        : +row.predictionScore\n    ),\n  }));\n  // Validate the imported file.\n  const validate = new Ajv().compile(TABULAR_SCHEMAS[datatype].schema);\n  const valid = validate(importData);\n  if (!valid) {\n    const failureReason = JSON.stringify(validate.errors, null, 2);\n    throw new Error(`Import validation failed: ${failureReason}`);\n  } else {\n    // Convert the validated array to a tree representation.\n    const treeToImport = {\n      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,\n      datatype,\n      tree: [],\n    };\n    const uniqueGroupNames = Array.from(new Set(importData.map(d => d.groupName)));\n    uniqueGroupNames.forEach((groupName) => {\n      const levelZeroNode = {\n        name: groupName,\n        children: [],\n      };\n      const groupRows = importData.filter(d => d.groupName === groupName);\n      const uniqueSetNames = Array.from(new Set(groupRows.map(d => d.setName)));\n      uniqueSetNames.forEach((setName) => {\n        const setRows = groupRows.filter(d => d.setName === setName);\n        const { setColor } = setRows[0];\n        const levelOneNode = {\n          name: setName,\n          color: setColor,\n          set: setRows.map(d => ([d.obsId, d.predictionScore])),\n        };\n        levelZeroNode.children.push(levelOneNode);\n      });\n      treeToImport.tree.push(levelZeroNode);\n    });\n    return treeToImport;\n  }\n}\n\n/**\n * Convert a tree object to a JSON representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */\nexport function handleExportJSON(result) {\n  const jsonString = JSON.stringify(result);\n  const dataString = `data:${MIME_TYPE_JSON};charset=utf-8,${encodeURIComponent(jsonString)}`;\n  return dataString;\n}\n\n/**\n * Convert a tree object with one level (height === 1) to a tabular representation.\n * @param {object} result The object to export.\n * @returns {string} The data in a string representation.\n */\nexport function handleExportTabular(result) {\n  // Convert a tree object to an array of JSON objects.\n  const exportData = [];\n  result.tree.forEach((levelZeroNode) => {\n    levelZeroNode.children.forEach((levelOneNode) => {\n      if (levelOneNode.set) {\n        levelOneNode.set.forEach(([obsId, prob]) => {\n          exportData.push({\n            groupName: levelZeroNode.name,\n            setName: levelOneNode.name,\n            setColor: colorArrayToString(levelOneNode.color),\n            obsId,\n            predictionScore: isNil(prob) ? NA_VALUE_TABULAR : prob,\n          });\n        });\n      }\n    });\n  });\n  const csvString = json2csv(exportData, {\n    fields: ['groupName', 'setName', 'setColor', 'obsId', 'predictionScore'],\n    delimiter: SEPARATOR_TABULAR,\n  });\n  const dataString = `data:${MIME_TYPE_TABULAR};charset=utf-8,${encodeURIComponent(csvString)}`;\n  return dataString;\n}\n\n/**\n * Download a file. Appends and removes an anchor node in the DOM.\n * @param {string} dataString The function that converts the data to a string.\n * @param {string} fileName The name of the file to be downloaded.\n */\nexport function downloadForUser(dataString, fileName) {\n  const downloadAnchorNode = document.createElement('a');\n  downloadAnchorNode.setAttribute('href', dataString);\n  downloadAnchorNode.setAttribute('download', fileName);\n  document.body.appendChild(downloadAnchorNode); // required for firefox\n  downloadAnchorNode.click();\n  downloadAnchorNode.remove();\n}\n"]},"metadata":{},"sourceType":"module"}