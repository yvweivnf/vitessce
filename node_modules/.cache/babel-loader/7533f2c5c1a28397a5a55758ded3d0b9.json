{"ast":null,"code":"/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { keys } from './util'; // Facet\n\nexport const ROW = 'row';\nexport const COLUMN = 'column';\nexport const FACET = 'facet'; // Position\n\nexport const X = 'x';\nexport const Y = 'y';\nexport const X2 = 'x2';\nexport const Y2 = 'y2'; // Arc-Position\n\nexport const RADIUS = 'radius';\nexport const RADIUS2 = 'radius2';\nexport const THETA = 'theta';\nexport const THETA2 = 'theta2'; // Geo Position\n\nexport const LATITUDE = 'latitude';\nexport const LONGITUDE = 'longitude';\nexport const LATITUDE2 = 'latitude2';\nexport const LONGITUDE2 = 'longitude2'; // Mark property with scale\n\nexport const COLOR = 'color';\nexport const FILL = 'fill';\nexport const STROKE = 'stroke';\nexport const SHAPE = 'shape';\nexport const SIZE = 'size';\nexport const ANGLE = 'angle';\nexport const OPACITY = 'opacity';\nexport const FILLOPACITY = 'fillOpacity';\nexport const STROKEOPACITY = 'strokeOpacity';\nexport const STROKEWIDTH = 'strokeWidth';\nexport const STROKEDASH = 'strokeDash'; // Non-scale channel\n\nexport const TEXT = 'text';\nexport const ORDER = 'order';\nexport const DETAIL = 'detail';\nexport const KEY = 'key';\nexport const TOOLTIP = 'tooltip';\nexport const HREF = 'href';\nexport const URL = 'url';\nexport const DESCRIPTION = 'description';\nconst POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nconst POLAR_POSITION_CHANNEL_INDEX = {\n  theta: 1,\n  theta2: 1,\n  radius: 1,\n  radius2: 1\n};\nexport function isPolarPositionChannel(c) {\n  return c in POLAR_POSITION_CHANNEL_INDEX;\n}\nconst GEO_POSIITON_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\nexport function getPositionChannelFromLatLong(channel) {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n\n    case LATITUDE2:\n      return 'y2';\n\n    case LONGITUDE:\n      return 'x';\n\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\nexport function isGeoPositionChannel(c) {\n  return c in GEO_POSIITON_CHANNEL_INDEX;\n}\nexport const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\nconst UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), {\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1,\n  strokeDash: 1,\n  size: 1,\n  angle: 1,\n  shape: 1,\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1,\n  description: 1\n});\nexport function isColorChannel(channel) {\n  return channel === COLOR || channel === FILL || channel === STROKE;\n}\nconst FACET_CHANNEL_INDEX = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nconst CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);\nexport const CHANNELS = keys(CHANNEL_INDEX);\n\nconst {\n  order: _o,\n  detail: _d,\n  tooltip: _tt1\n} = CHANNEL_INDEX,\n      SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, [\"order\", \"detail\", \"tooltip\"]);\n\nconst {\n  row: _r,\n  column: _c,\n  facet: _f\n} = SINGLE_DEF_CHANNEL_INDEX,\n      SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, [\"row\", \"column\", \"facet\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\n\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\nexport function isChannel(str) {\n  return !!CHANNEL_INDEX[str];\n}\nexport const SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\nexport function isSecondaryRangeChannel(c) {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getMainRangeChannel(channel) {\n  switch (channel) {\n    case X2:\n      return X;\n\n    case Y2:\n      return Y;\n\n    case LATITUDE2:\n      return LATITUDE;\n\n    case LONGITUDE2:\n      return LONGITUDE;\n\n    case THETA2:\n      return THETA;\n\n    case RADIUS2:\n      return RADIUS;\n  }\n\n  return channel;\n}\nexport function getVgPositionChannel(channel) {\n  if (isPolarPositionChannel(channel)) {\n    switch (channel) {\n      case THETA:\n        return 'startAngle';\n\n      case THETA2:\n        return 'endAngle';\n\n      case RADIUS:\n        return 'outerRadius';\n\n      case RADIUS2:\n        return 'innerRadius';\n    }\n  }\n\n  return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getSecondaryRangeChannel(channel) {\n  switch (channel) {\n    case X:\n      return X2;\n\n    case Y:\n      return Y2;\n\n    case LATITUDE:\n      return LATITUDE2;\n\n    case LONGITUDE:\n      return LONGITUDE2;\n\n    case THETA:\n      return THETA2;\n\n    case RADIUS:\n      return RADIUS2;\n  }\n\n  return undefined;\n}\nexport function getSizeChannel(channel) {\n  switch (channel) {\n    case X:\n    case X2:\n      return 'width';\n\n    case Y:\n    case Y2:\n      return 'height';\n  }\n\n  return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getOffsetChannel(channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n\n    case Y:\n      return 'yOffset';\n\n    case X2:\n      return 'x2Offset';\n\n    case Y2:\n      return 'y2Offset';\n\n    case THETA:\n      return 'thetaOffset';\n\n    case RADIUS:\n      return 'radiusOffset';\n\n    case THETA2:\n      return 'theta2Offset';\n\n    case RADIUS2:\n      return 'radius2Offset';\n  }\n\n  return undefined;\n} // CHANNELS without COLUMN, ROW\n\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX); // NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\n\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  theta: _theta,\n  theta2: _theta2,\n  radius: _radius,\n  radius2: _radius2\n} = UNIT_CHANNEL_INDEX,\n      // The rest of unit channels then have scale\nNONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\", \"theta\", \"theta2\", \"radius\", \"radius2\"]);\n\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nexport const POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n};\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function isXorY(channel) {\n  return channel in POSITION_SCALE_CHANNEL_INDEX;\n}\nexport const POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n  theta: 1,\n  radius: 1\n};\nexport const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport function getPositionScaleChannel(sizeType) {\n  return sizeType === 'width' ? X : Y;\n} // NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\n\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  url: _u,\n  description: _al,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo\n} = NONPOSITION_CHANNEL_INDEX,\n      NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"url\", \"description\", \"detail\", \"key\", \"order\"]);\n\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\n\nexport function supportLegend(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n    case STROKEDASH:\n      return true;\n\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case ANGLE:\n      return false;\n  }\n} // Declare SCALE_CHANNEL_INDEX\n\nconst SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\n\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\n\nexport function supportMark(channel, mark) {\n  return getSupportedMark(channel)[mark];\n}\nconst ALL_MARKS = {\n  // all marks\n  arc: 'always',\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nconst {\n  geoshape: _g\n} = ALL_MARKS,\n      ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, [\"geoshape\"]);\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\n\n\nfunction getSupportedMark(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE: // falls through\n\n    case DESCRIPTION:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH: // falls through\n\n    case FACET:\n    case ROW: // falls through\n\n    case COLUMN:\n      return ALL_MARKS;\n\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n\n    case STROKEDASH:\n      return {\n        line: 'always',\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        geoshape: 'always'\n      };\n\n    case SHAPE:\n      return {\n        point: 'always',\n        geoshape: 'always'\n      };\n\n    case TEXT:\n      return {\n        text: 'always'\n      };\n\n    case ANGLE:\n      return {\n        point: 'always',\n        square: 'always',\n        text: 'always'\n      };\n\n    case URL:\n      return {\n        image: 'always'\n      };\n\n    case THETA:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n\n    case RADIUS:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n\n    case THETA2:\n    case RADIUS2:\n      return {\n        arc: 'always'\n      };\n  }\n}\n\nexport function rangeType(channel) {\n  switch (channel) {\n    case X:\n    case Y:\n    case THETA:\n    case RADIUS:\n    case SIZE:\n    case ANGLE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n\n    case X2:\n    case Y2:\n    case THETA2:\n    case RADIUS2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    case STROKEDASH: // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case DESCRIPTION:\n      return 'discrete';\n    // Color can be either continuous or discrete, depending on scale type.\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}","map":{"version":3,"sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { keys } from './util';\n// Facet\nexport const ROW = 'row';\nexport const COLUMN = 'column';\nexport const FACET = 'facet';\n// Position\nexport const X = 'x';\nexport const Y = 'y';\nexport const X2 = 'x2';\nexport const Y2 = 'y2';\n// Arc-Position\nexport const RADIUS = 'radius';\nexport const RADIUS2 = 'radius2';\nexport const THETA = 'theta';\nexport const THETA2 = 'theta2';\n// Geo Position\nexport const LATITUDE = 'latitude';\nexport const LONGITUDE = 'longitude';\nexport const LATITUDE2 = 'latitude2';\nexport const LONGITUDE2 = 'longitude2';\n// Mark property with scale\nexport const COLOR = 'color';\nexport const FILL = 'fill';\nexport const STROKE = 'stroke';\nexport const SHAPE = 'shape';\nexport const SIZE = 'size';\nexport const ANGLE = 'angle';\nexport const OPACITY = 'opacity';\nexport const FILLOPACITY = 'fillOpacity';\nexport const STROKEOPACITY = 'strokeOpacity';\nexport const STROKEWIDTH = 'strokeWidth';\nexport const STROKEDASH = 'strokeDash';\n// Non-scale channel\nexport const TEXT = 'text';\nexport const ORDER = 'order';\nexport const DETAIL = 'detail';\nexport const KEY = 'key';\nexport const TOOLTIP = 'tooltip';\nexport const HREF = 'href';\nexport const URL = 'url';\nexport const DESCRIPTION = 'description';\nconst POSITION_CHANNEL_INDEX = {\n    x: 1,\n    y: 1,\n    x2: 1,\n    y2: 1\n};\nconst POLAR_POSITION_CHANNEL_INDEX = {\n    theta: 1,\n    theta2: 1,\n    radius: 1,\n    radius2: 1\n};\nexport function isPolarPositionChannel(c) {\n    return c in POLAR_POSITION_CHANNEL_INDEX;\n}\nconst GEO_POSIITON_CHANNEL_INDEX = {\n    longitude: 1,\n    longitude2: 1,\n    latitude: 1,\n    latitude2: 1\n};\nexport function getPositionChannelFromLatLong(channel) {\n    switch (channel) {\n        case LATITUDE:\n            return 'y';\n        case LATITUDE2:\n            return 'y2';\n        case LONGITUDE:\n            return 'x';\n        case LONGITUDE2:\n            return 'x2';\n    }\n}\nexport function isGeoPositionChannel(c) {\n    return c in GEO_POSIITON_CHANNEL_INDEX;\n}\nexport const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\nconst UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), { \n    // color\n    color: 1, fill: 1, stroke: 1, \n    // other non-position with scale\n    opacity: 1, fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, strokeDash: 1, size: 1, angle: 1, shape: 1, \n    // channels without scales\n    order: 1, text: 1, detail: 1, key: 1, tooltip: 1, href: 1, url: 1, description: 1 });\nexport function isColorChannel(channel) {\n    return channel === COLOR || channel === FILL || channel === STROKE;\n}\nconst FACET_CHANNEL_INDEX = {\n    row: 1,\n    column: 1,\n    facet: 1\n};\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nconst CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);\nexport const CHANNELS = keys(CHANNEL_INDEX);\nconst { order: _o, detail: _d, tooltip: _tt1 } = CHANNEL_INDEX, SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, [\"order\", \"detail\", \"tooltip\"]);\nconst { row: _r, column: _c, facet: _f } = SINGLE_DEF_CHANNEL_INDEX, SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, [\"row\", \"column\", \"facet\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n    return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\nexport function isChannel(str) {\n    return !!CHANNEL_INDEX[str];\n}\nexport const SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\nexport function isSecondaryRangeChannel(c) {\n    const main = getMainRangeChannel(c);\n    return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel(channel) {\n    switch (channel) {\n        case X2:\n            return X;\n        case Y2:\n            return Y;\n        case LATITUDE2:\n            return LATITUDE;\n        case LONGITUDE2:\n            return LONGITUDE;\n        case THETA2:\n            return THETA;\n        case RADIUS2:\n            return RADIUS;\n    }\n    return channel;\n}\nexport function getVgPositionChannel(channel) {\n    if (isPolarPositionChannel(channel)) {\n        switch (channel) {\n            case THETA:\n                return 'startAngle';\n            case THETA2:\n                return 'endAngle';\n            case RADIUS:\n                return 'outerRadius';\n            case RADIUS2:\n                return 'innerRadius';\n        }\n    }\n    return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getSecondaryRangeChannel(channel) {\n    switch (channel) {\n        case X:\n            return X2;\n        case Y:\n            return Y2;\n        case LATITUDE:\n            return LATITUDE2;\n        case LONGITUDE:\n            return LONGITUDE2;\n        case THETA:\n            return THETA2;\n        case RADIUS:\n            return RADIUS2;\n    }\n    return undefined;\n}\nexport function getSizeChannel(channel) {\n    switch (channel) {\n        case X:\n        case X2:\n            return 'width';\n        case Y:\n        case Y2:\n            return 'height';\n    }\n    return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetChannel(channel) {\n    switch (channel) {\n        case X:\n            return 'xOffset';\n        case Y:\n            return 'yOffset';\n        case X2:\n            return 'x2Offset';\n        case Y2:\n            return 'y2Offset';\n        case THETA:\n            return 'thetaOffset';\n        case RADIUS:\n            return 'radiusOffset';\n        case THETA2:\n            return 'theta2Offset';\n        case RADIUS2:\n            return 'radius2Offset';\n    }\n    return undefined;\n}\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst { x: _x, y: _y, \n// x2 and y2 share the same scale as x and y\nx2: _x2, y2: _y2, latitude: _latitude, longitude: _longitude, latitude2: _latitude2, longitude2: _longitude2, theta: _theta, theta2: _theta2, radius: _radius, radius2: _radius2 } = UNIT_CHANNEL_INDEX, \n// The rest of unit channels then have scale\nNONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\", \"theta\", \"theta2\", \"radius\", \"radius2\"]);\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nexport const POSITION_SCALE_CHANNEL_INDEX = {\n    x: 1,\n    y: 1\n};\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function isXorY(channel) {\n    return channel in POSITION_SCALE_CHANNEL_INDEX;\n}\nexport const POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n    theta: 1,\n    radius: 1\n};\nexport const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport function getPositionScaleChannel(sizeType) {\n    return sizeType === 'width' ? X : Y;\n}\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nconst { \n// x2 and y2 share the same scale as x and y\n// text and tooltip have format instead of scale,\n// href has neither format, nor scale\ntext: _t, tooltip: _tt, href: _hr, url: _u, description: _al, \n// detail and order have no scale\ndetail: _dd, key: _k, order: _oo } = NONPOSITION_CHANNEL_INDEX, NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"url\", \"description\", \"detail\", \"key\", \"order\"]);\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n    return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel) {\n    switch (channel) {\n        case COLOR:\n        case FILL:\n        case STROKE:\n        case SIZE:\n        case SHAPE:\n        case OPACITY:\n        case STROKEWIDTH:\n        case STROKEDASH:\n            return true;\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        case ANGLE:\n            return false;\n    }\n}\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n    return !!SCALE_CHANNEL_INDEX[channel];\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel, mark) {\n    return getSupportedMark(channel)[mark];\n}\nconst ALL_MARKS = {\n    // all marks\n    arc: 'always',\n    area: 'always',\n    bar: 'always',\n    circle: 'always',\n    geoshape: 'always',\n    image: 'always',\n    line: 'always',\n    rule: 'always',\n    point: 'always',\n    rect: 'always',\n    square: 'always',\n    trail: 'always',\n    text: 'always',\n    tick: 'always'\n};\nconst { geoshape: _g } = ALL_MARKS, ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, [\"geoshape\"]);\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case COLOR:\n        case FILL:\n        case STROKE:\n        // falls through\n        case DESCRIPTION:\n        case DETAIL:\n        case KEY:\n        case TOOLTIP:\n        case HREF:\n        case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        case STROKEWIDTH:\n        // falls through\n        case FACET:\n        case ROW: // falls through\n        case COLUMN:\n            return ALL_MARKS;\n        case X:\n        case Y:\n        case LATITUDE:\n        case LONGITUDE:\n            // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n            return ALL_MARKS_EXCEPT_GEOSHAPE;\n        case X2:\n        case Y2:\n        case LATITUDE2:\n        case LONGITUDE2:\n            return {\n                area: 'always',\n                bar: 'always',\n                image: 'always',\n                rect: 'always',\n                rule: 'always',\n                circle: 'binned',\n                point: 'binned',\n                square: 'binned',\n                tick: 'binned',\n                line: 'binned',\n                trail: 'binned'\n            };\n        case SIZE:\n            return {\n                point: 'always',\n                tick: 'always',\n                rule: 'always',\n                circle: 'always',\n                square: 'always',\n                bar: 'always',\n                text: 'always',\n                line: 'always',\n                trail: 'always'\n            };\n        case STROKEDASH:\n            return {\n                line: 'always',\n                point: 'always',\n                tick: 'always',\n                rule: 'always',\n                circle: 'always',\n                square: 'always',\n                bar: 'always',\n                geoshape: 'always'\n            };\n        case SHAPE:\n            return { point: 'always', geoshape: 'always' };\n        case TEXT:\n            return { text: 'always' };\n        case ANGLE:\n            return { point: 'always', square: 'always', text: 'always' };\n        case URL:\n            return { image: 'always' };\n        case THETA:\n            return { text: 'always', arc: 'always' };\n        case RADIUS:\n            return { text: 'always', arc: 'always' };\n        case THETA2:\n        case RADIUS2:\n            return { arc: 'always' };\n    }\n}\nexport function rangeType(channel) {\n    switch (channel) {\n        case X:\n        case Y:\n        case THETA:\n        case RADIUS:\n        case SIZE:\n        case ANGLE:\n        case STROKEWIDTH:\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n        case X2:\n        case Y2:\n        case THETA2:\n        case RADIUS2:\n            return undefined;\n        case FACET:\n        case ROW:\n        case COLUMN:\n        case SHAPE:\n        case STROKEDASH:\n        // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n        case TEXT:\n        case TOOLTIP:\n        case HREF:\n        case URL:\n        case DESCRIPTION:\n            return 'discrete';\n        // Color can be either continuous or discrete, depending on scale type.\n        case COLOR:\n        case FILL:\n        case STROKE:\n            return 'flexible';\n        // No scale, no range type.\n        case LATITUDE:\n        case LONGITUDE:\n        case LATITUDE2:\n        case LONGITUDE2:\n        case DETAIL:\n        case KEY:\n        case ORDER:\n            return undefined;\n    }\n}\n//# sourceMappingURL=channel.js.map"]},"metadata":{},"sourceType":"module"}