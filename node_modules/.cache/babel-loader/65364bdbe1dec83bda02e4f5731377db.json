{"ast":null,"code":"import { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class SourceNode extends DataFlowNode {\n  constructor(data) {\n    super(null); // source cannot have parent\n\n    data !== null && data !== void 0 ? data : data = {\n      name: 'source'\n    };\n    let format;\n\n    if (!isGenerator(data)) {\n      format = data.format ? Object.assign({}, omit(data.format, ['parse'])) : {};\n    }\n\n    if (isInlineData(data)) {\n      this._data = {\n        values: data.values\n      };\n    } else if (isUrlData(data)) {\n      this._data = {\n        url: data.url\n      };\n\n      if (!format.type) {\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n\n        if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        } // defaultExtension has type string but we ensure that it is DataFormatType above\n\n\n        format.type = defaultExtension;\n      }\n    } else if (isSphereGenerator(data)) {\n      // hardwire GeoJSON sphere data into output specification\n      this._data = {\n        values: [{\n          type: 'Sphere'\n        }]\n      };\n    } else if (isNamedData(data) || isGenerator(data)) {\n      this._data = {};\n    } // set flag to check if generator\n\n\n    this._generator = isGenerator(data); // any dataset can be named\n\n    if (data.name) {\n      this._name = data.name;\n    }\n\n    if (format && !isEmpty(format)) {\n      this._data.format = format;\n    }\n  }\n\n  dependentFields() {\n    return new Set();\n  }\n\n  producedFields() {\n    return undefined; // we don't know what this source produces\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  hasName() {\n    return !!this._name;\n  }\n\n  get isGenerator() {\n    return this._generator;\n  }\n\n  get dataName() {\n    return this._name;\n  }\n\n  set dataName(name) {\n    this._name = name;\n  }\n\n  set parent(parent) {\n    throw new Error('Source nodes have to be roots.');\n  }\n\n  remove() {\n    throw new Error('Source nodes are roots and cannot be removed.');\n  }\n\n  hash() {\n    throw new Error('Cannot hash sources');\n  }\n\n  assemble() {\n    return Object.assign(Object.assign({\n      name: this._name\n    }, this._data), {\n      transform: []\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class SourceNode extends DataFlowNode {\n    constructor(data) {\n        super(null); // source cannot have parent\n        data !== null && data !== void 0 ? data : (data = { name: 'source' });\n        let format;\n        if (!isGenerator(data)) {\n            format = data.format ? Object.assign({}, omit(data.format, ['parse'])) : {};\n        }\n        if (isInlineData(data)) {\n            this._data = { values: data.values };\n        }\n        else if (isUrlData(data)) {\n            this._data = { url: data.url };\n            if (!format.type) {\n                // Extract extension from URL using snippet from\n                // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n                let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n                if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n                    defaultExtension = 'json';\n                }\n                // defaultExtension has type string but we ensure that it is DataFormatType above\n                format.type = defaultExtension;\n            }\n        }\n        else if (isSphereGenerator(data)) {\n            // hardwire GeoJSON sphere data into output specification\n            this._data = { values: [{ type: 'Sphere' }] };\n        }\n        else if (isNamedData(data) || isGenerator(data)) {\n            this._data = {};\n        }\n        // set flag to check if generator\n        this._generator = isGenerator(data);\n        // any dataset can be named\n        if (data.name) {\n            this._name = data.name;\n        }\n        if (format && !isEmpty(format)) {\n            this._data.format = format;\n        }\n    }\n    dependentFields() {\n        return new Set();\n    }\n    producedFields() {\n        return undefined; // we don't know what this source produces\n    }\n    get data() {\n        return this._data;\n    }\n    hasName() {\n        return !!this._name;\n    }\n    get isGenerator() {\n        return this._generator;\n    }\n    get dataName() {\n        return this._name;\n    }\n    set dataName(name) {\n        this._name = name;\n    }\n    set parent(parent) {\n        throw new Error('Source nodes have to be roots.');\n    }\n    remove() {\n        throw new Error('Source nodes are roots and cannot be removed.');\n    }\n    hash() {\n        throw new Error('Cannot hash sources');\n    }\n    assemble() {\n        return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });\n    }\n}\n//# sourceMappingURL=source.js.map"]},"metadata":{},"sourceType":"module"}