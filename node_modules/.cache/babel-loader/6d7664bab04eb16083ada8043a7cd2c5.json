{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nimport { openArray, slice } from 'zarr';\nimport { extent } from 'd3-array';\nimport LoaderResult from '../LoaderResult';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\n\nconst normalize = arr => {\n  const [min, max] = extent(arr);\n  const ratio = 255 / (max - min);\n  const data = new Uint8Array(arr.map(i => Math.floor((i - min) * ratio)));\n  return {\n    data\n  };\n};\n\nconst concatenateColumnVectors = arr => {\n  const numCols = arr.length;\n  const numRows = arr[0].length;\n  const {\n    BYTES_PER_ELEMENT\n  } = arr[0];\n  const view = new DataView(new ArrayBuffer(numCols * numRows * BYTES_PER_ELEMENT));\n  const TypedArray = arr[0].constructor;\n  const dtype = TypedArray.name.replace('Array', '');\n\n  for (let i = 0; i < numCols; i += 1) {\n    for (let j = 0; j < numRows; j += 1) {\n      view[`set${dtype}`](BYTES_PER_ELEMENT * (j * numCols + i), arr[i][j], true);\n    }\n  }\n\n  return new TypedArray(view.buffer);\n};\n/**\n * Loader for converting zarr into the a cell x gene matrix for use in Genes/Heatmap components.\n */\n\n\nexport default class MatrixZarrLoader extends AbstractTwoStepLoader {\n  /**\n   * Class method for loading the genes list from AnnData.var,\n   * filtered if a there is a `geneFilterZarr` present in the view config.\n   * @returns {Promise} A promise for the zarr array contianing the gene names.\n   */\n  async loadFilteredGeneNames() {\n    if (this.filteredGeneNames) {\n      return this.filteredGeneNames;\n    }\n\n    const {\n      geneFilter: geneFilterZarr,\n      geneAlias\n    } = this.options;\n\n    const getFilterFn = async () => {\n      if (!geneFilterZarr) return data => data;\n      const geneFilter = await this.dataSource.getFlatArrDecompressed(geneFilterZarr);\n      return data => data.filter((_, j) => geneFilter[j]);\n    };\n\n    const geneNamesPromise = geneAlias ? this.dataSource.loadVarAlias(geneAlias) : this.dataSource.loadVarIndex();\n    this.filteredGeneNames = Promise.all([geneNamesPromise, getFilterFn()]).then(([data, filter]) => filter(data));\n    return this.filteredGeneNames;\n  }\n  /**\n   * Class method for loading a filtered subset of the genes list\n   * @param {String} filterZarr A location in the zarr store to fetch a boolean array from.\n   * @returns {Array} A list of filtered genes.\n   */\n\n\n  async _getFilteredGenes(filterZarr) {\n    const filter = await this.dataSource.getFlatArrDecompressed(filterZarr);\n    const geneNames = await this.loadFilteredGeneNames();\n    const genes = geneNames.filter((_, i) => filter[i]);\n    return genes;\n  }\n  /**\n   * Class method for getting the integer indices of a selection of genes within a list.\n   * @param {Array} selection A list of gene names.\n   * @returns {Array} A list of integer indices.\n   */\n\n\n  async _getGeneIndices(selection) {\n    const geneNames = await this.loadFilteredGeneNames();\n    return selection.map(gene => geneNames.indexOf(gene));\n  }\n  /**\n   * Class method for getting the number of cells i.e entries in `obs`.\n   * @returns {Number} The number of cells.\n   */\n\n\n  async _getNumCells() {\n    const cells = await this.dataSource.loadObsIndex();\n    return cells.length;\n  }\n  /**\n   * Class method for getting the number of genes i.e entries in `var`,\n   * potentially filtered by `genesFilter`.\n   * @returns {Number} The number of genes.\n   */\n\n\n  async _getNumGenes() {\n    const genes = await this.loadFilteredGeneNames();\n    return genes.length;\n  }\n  /**\n   * Class method for opening the sparse matrix arrays in zarr.\n   * @returns {Array} A list of promises pointing to the indptr, indices, and data of the matrix.\n   */\n\n\n  async _openSparseArrays() {\n    const {\n      options: {\n        matrix\n      }\n    } = this;\n    const {\n      store\n    } = this.dataSource;\n\n    if (this.sparseArrays) {\n      return this.sparseArrays;\n    }\n\n    this.sparseArrays = Promise.all(['indptr', 'indices', 'data'].map(name => openArray({\n      store,\n      path: `${matrix}/${name}`,\n      mode: 'r'\n    })));\n    return this.sparseArrays;\n  }\n  /**\n   * Class method for loading a gene selection from a CSC matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */\n\n\n  async _loadCSCGeneSelection(selection) {\n    const indices = await this._getGeneIndices(selection);\n    const [indptrArr, indexArr, cellXGeneArr] = await this._openSparseArrays();\n    const numCells = await this._getNumCells();\n    const {\n      data: cols\n    } = await indptrArr.getRaw(null); // If there is not change in the column indexer, then the data is all zeros\n\n    return Promise.all(indices.map(async index => {\n      const startRowIndex = cols[index];\n      const endRowIndex = cols[index + 1];\n      const isColumnAllZeros = startRowIndex === endRowIndex;\n      const geneData = new Float32Array(numCells).fill(0);\n\n      if (isColumnAllZeros) {\n        return geneData;\n      }\n\n      const {\n        data: rowIndices\n      } = await indexArr.get([slice(startRowIndex, endRowIndex)]);\n      const {\n        data: cellXGeneData\n      } = await cellXGeneArr.get([slice(startRowIndex, endRowIndex)]);\n\n      for (let rowIndex = 0; rowIndex < rowIndices.length; rowIndex += 1) {\n        geneData[rowIndices[rowIndex]] = cellXGeneData[rowIndex];\n      }\n\n      return geneData;\n    }));\n  }\n  /**\n   * Class method for loading a gene selection from a CSR matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */\n\n\n  async _loadCSRGeneSelection(selection) {\n    const indices = await this._getGeneIndices(selection);\n    const numGenes = await this._getNumGenes();\n    const numCells = await this._getNumCells();\n    const cellXGene = await this._loadCSRSparseCellXGene();\n    return indices.map(index => {\n      const geneData = new Float32Array(numCells).fill(0);\n\n      for (let i = 0; i < numCells; i += 1) {\n        geneData[i] = cellXGene[i * numGenes + index];\n      }\n\n      return geneData;\n    });\n  }\n  /**\n   * Class method for loading row oriented (CSR) sparse data from zarr.\n   *\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */\n\n\n  async _loadCSRSparseCellXGene() {\n    if (this._sparseMatrix) {\n      return this._sparseMatrix;\n    }\n\n    this._sparseMatrix = this._openSparseArrays().then(async sparseArrays => {\n      const {\n        options: {\n          matrix\n        }\n      } = this;\n      const {\n        shape\n      } = await this.dataSource.getJson(`${matrix}/.zattrs`);\n      const [rows, cols, cellXGene] = await Promise.all(sparseArrays.map(async arr => {\n        const {\n          data\n        } = await arr.getRaw(null);\n        return data;\n      }));\n      const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);\n      let row = 0;\n      rows.forEach((_, index) => {\n        const rowStart = rows[index];\n        const rowEnd = rows[index + 1];\n\n        for (let i = rowStart; i < rowEnd; i += 1) {\n          const val = cellXGene[i];\n          const col = cols[i];\n          cellXGeneMatrix[row * shape[1] + col] = val;\n        }\n\n        row += 1;\n      });\n      return cellXGeneMatrix;\n    });\n    return this._sparseMatrix;\n  }\n  /**\n   * Class method for loading column oriented (CSC) sparse data from zarr.\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */\n\n\n  async _loadCSCSparseCellXGene() {\n    if (this._sparseMatrix) {\n      return this._sparseMatrix;\n    }\n\n    this._sparseMatrix = this._openSparseArrays().then(async sparseArrays => {\n      const {\n        options: {\n          matrix\n        }\n      } = this;\n      const {\n        shape\n      } = await this.dataSource.getJson(`${matrix}/.zattrs`);\n      const [cols, rows, cellXGene] = await Promise.all(sparseArrays.map(async arr => {\n        const {\n          data\n        } = await arr.getRaw(null);\n        return data;\n      }));\n      const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);\n      let col = 0;\n      cols.forEach((_, index) => {\n        const colStart = cols[index];\n        const colEnd = cols[index + 1];\n\n        for (let i = colStart; i < colEnd; i += 1) {\n          const val = cellXGene[i];\n          const row = rows[i];\n          cellXGeneMatrix[row * shape[1] + col] = val;\n        }\n\n        col += 1;\n      });\n      return cellXGeneMatrix;\n    });\n    return this._sparseMatrix;\n  }\n  /**\n   * Class method for loading the cell x gene matrix.\n   * @returns {Promise} A promise for the zarr array contianing the cell x gene data.\n   */\n\n\n  async loadCellXGene() {\n    const {\n      store\n    } = this.dataSource;\n\n    if (this.cellXGene) {\n      return this.cellXGene;\n    }\n\n    const {\n      options: {\n        matrix,\n        matrixGeneFilter\n      }\n    } = this;\n\n    if (!this._matrixZattrs) {\n      this._matrixZattrs = await this.dataSource.getJson(`${matrix}/.zattrs`);\n    }\n\n    const encodingType = this._matrixZattrs['encoding-type'];\n\n    if (!matrixGeneFilter) {\n      if (encodingType === 'csr_matrix') {\n        this.cellXGene = this._loadCSRSparseCellXGene().then(data => normalize(data));\n      } else if (encodingType === 'csc_matrix') {\n        this.cellXGene = this._loadCSCSparseCellXGene().then(data => normalize(data));\n      } else {\n        if (!this.arr) {\n          this.arr = openArray({\n            store,\n            path: matrix,\n            mode: 'r'\n          });\n        }\n\n        this.cellXGene = this.arr.then(z => z.getRaw(null).then(({\n          data\n        }) => normalize(data)));\n      }\n    } else if (encodingType === 'csr_matrix') {\n      this.cellXGene = this._loadCSRSparseCellXGene().then(async cellXGene => {\n        const filteredGenes = await this._getFilteredGenes(matrixGeneFilter);\n        const numGenesFiltered = filteredGenes.length;\n        const geneNames = await this.loadFilteredGeneNames();\n        const numGenes = geneNames.length;\n        const numCells = await this._getNumCells();\n        const cellXGeneMatrixFiltered = new Float32Array(numCells * numGenesFiltered).fill(0);\n\n        for (let i = 0; i < numGenesFiltered; i += 1) {\n          const index = geneNames.indexOf(filteredGenes[i]);\n\n          for (let j = 0; j < numCells; j += 1) {\n            cellXGeneMatrixFiltered[j * numGenesFiltered + i] = cellXGene[j * numGenes + index];\n          }\n        }\n\n        return normalize(cellXGeneMatrixFiltered);\n      });\n    } else {\n      const genes = await this._getFilteredGenes(matrixGeneFilter);\n      this.cellXGene = this.loadGeneSelection({\n        selection: genes,\n        shouldNormalize: false\n      }).then(({\n        data\n      }) => normalize(concatenateColumnVectors(data)));\n    }\n\n    return this.cellXGene;\n  }\n  /**\n   * Class method for loading a gene selection.\n   * @param {Object} args\n   * @param {Array} args.selection A list of gene names whose data should be fetched.\n   * @param {Boolean} args.shouldNormalize A list of gene names whose data should be fetched.\n   * @returns {Object} { data } containing an array of gene expression data.\n   */\n\n\n  async loadGeneSelection({\n    selection,\n    shouldNormalize = true\n  }) {\n    const {\n      options: {\n        matrix\n      }\n    } = this;\n    const {\n      store\n    } = this.dataSource;\n\n    if (!this._matrixZattrs) {\n      this._matrixZattrs = await this.dataSource.getJson(`${matrix}/.zattrs`);\n    }\n\n    const encodingType = this._matrixZattrs['encoding-type'];\n    let genes;\n\n    if (encodingType === 'csc_matrix') {\n      genes = await this._loadCSCGeneSelection(selection);\n    } else if (encodingType === 'csr_matrix') {\n      genes = await this._loadCSRGeneSelection(selection);\n    } else {\n      if (!this.arr) {\n        this.arr = openArray({\n          store,\n          path: matrix,\n          mode: 'r'\n        });\n      }\n\n      const indices = await this._getGeneIndices(selection); // We can index directly into a normal dense array zarr store via `get`.\n\n      genes = await Promise.all(indices.map(index => this.arr.then(z => z.get([null, index])).then(({\n        data\n      }) => data)));\n    }\n\n    return {\n      data: genes.map(i => shouldNormalize ? normalize(i).data : i),\n      url: null\n    };\n  }\n  /**\n   * Class method for loading only attributes i.e rows and columns\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Object} { data: { rows, cols }, url } containing row and col labels for the matrix.\n   */\n\n\n  loadAttrs() {\n    return Promise.all([this.dataSource.loadObsIndex(), this.loadFilteredGeneNames()]).then(d => {\n      const [cellNames, geneNames] = d;\n      const attrs = {\n        rows: cellNames,\n        cols: geneNames\n      };\n      return {\n        data: attrs,\n        url: null\n      };\n    });\n  }\n\n  load() {\n    return Promise.all([this.loadAttrs(), this.loadCellXGene()]).then(async d => {\n      const [{\n        data: attrs\n      }, cellXGene] = d;\n      const {\n        options: {\n          matrixGeneFilter: matrixGeneFilterZarr\n        }\n      } = this; // In order to return the correct gene list with the heatmap data,\n      // we need to filter the columns of attrs so it matches the cellXGene data.\n\n      if (matrixGeneFilterZarr) {\n        const matrixGeneFilter = await this.dataSource.getFlatArrDecompressed(matrixGeneFilterZarr);\n        attrs.cols = attrs.cols.filter((_, i) => matrixGeneFilter[i]);\n      }\n\n      return Promise.resolve(new LoaderResult([attrs, cellXGene], null));\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/anndata-loaders/MatrixZarrLoader.js"],"names":["openArray","slice","extent","LoaderResult","AbstractTwoStepLoader","normalize","arr","min","max","ratio","data","Uint8Array","map","i","Math","floor","concatenateColumnVectors","numCols","length","numRows","BYTES_PER_ELEMENT","view","DataView","ArrayBuffer","TypedArray","constructor","dtype","name","replace","j","buffer","MatrixZarrLoader","loadFilteredGeneNames","filteredGeneNames","geneFilter","geneFilterZarr","geneAlias","options","getFilterFn","dataSource","getFlatArrDecompressed","filter","_","geneNamesPromise","loadVarAlias","loadVarIndex","Promise","all","then","_getFilteredGenes","filterZarr","geneNames","genes","_getGeneIndices","selection","gene","indexOf","_getNumCells","cells","loadObsIndex","_getNumGenes","_openSparseArrays","matrix","store","sparseArrays","path","mode","_loadCSCGeneSelection","indices","indptrArr","indexArr","cellXGeneArr","numCells","cols","getRaw","index","startRowIndex","endRowIndex","isColumnAllZeros","geneData","Float32Array","fill","rowIndices","get","cellXGeneData","rowIndex","_loadCSRGeneSelection","numGenes","cellXGene","_loadCSRSparseCellXGene","_sparseMatrix","shape","getJson","rows","cellXGeneMatrix","row","forEach","rowStart","rowEnd","val","col","_loadCSCSparseCellXGene","colStart","colEnd","loadCellXGene","matrixGeneFilter","_matrixZattrs","encodingType","z","filteredGenes","numGenesFiltered","cellXGeneMatrixFiltered","loadGeneSelection","shouldNormalize","url","loadAttrs","d","cellNames","attrs","load","matrixGeneFilterZarr","resolve"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { openArray, slice } from 'zarr';\nimport { extent } from 'd3-array';\nimport LoaderResult from '../LoaderResult';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\n\nconst normalize = (arr) => {\n  const [min, max] = extent(arr);\n  const ratio = 255 / (max - min);\n  const data = new Uint8Array(\n    arr.map(i => Math.floor((i - min) * ratio)),\n  );\n  return { data };\n};\n\nconst concatenateColumnVectors = (arr) => {\n  const numCols = arr.length;\n  const numRows = arr[0].length;\n  const { BYTES_PER_ELEMENT } = arr[0];\n  const view = new DataView(new ArrayBuffer(numCols * numRows * BYTES_PER_ELEMENT));\n  const TypedArray = arr[0].constructor;\n  const dtype = TypedArray.name.replace('Array', '');\n  for (let i = 0; i < numCols; i += 1) {\n    for (let j = 0; j < numRows; j += 1) {\n      view[`set${dtype}`](BYTES_PER_ELEMENT * (j * numCols + i), arr[i][j], true);\n    }\n  }\n  return new TypedArray(view.buffer);\n};\n\n/**\n * Loader for converting zarr into the a cell x gene matrix for use in Genes/Heatmap components.\n */\nexport default class MatrixZarrLoader extends AbstractTwoStepLoader {\n  /**\n   * Class method for loading the genes list from AnnData.var,\n   * filtered if a there is a `geneFilterZarr` present in the view config.\n   * @returns {Promise} A promise for the zarr array contianing the gene names.\n   */\n  async loadFilteredGeneNames() {\n    if (this.filteredGeneNames) {\n      return this.filteredGeneNames;\n    }\n    const { geneFilter: geneFilterZarr, geneAlias } = this.options;\n    const getFilterFn = async () => {\n      if (!geneFilterZarr) return data => data;\n      const geneFilter = await this.dataSource.getFlatArrDecompressed(geneFilterZarr);\n      return data => data.filter((_, j) => geneFilter[j]);\n    };\n    const geneNamesPromise = geneAlias\n      ? this.dataSource.loadVarAlias(geneAlias)\n      : this.dataSource.loadVarIndex();\n    this.filteredGeneNames = Promise.all([\n      geneNamesPromise,\n      getFilterFn(),\n    ]).then(([data, filter]) => filter(data));\n    return this.filteredGeneNames;\n  }\n\n  /**\n   * Class method for loading a filtered subset of the genes list\n   * @param {String} filterZarr A location in the zarr store to fetch a boolean array from.\n   * @returns {Array} A list of filtered genes.\n   */\n  async _getFilteredGenes(filterZarr) {\n    const filter = await this.dataSource.getFlatArrDecompressed(filterZarr);\n    const geneNames = await this.loadFilteredGeneNames();\n    const genes = geneNames.filter((_, i) => filter[i]);\n    return genes;\n  }\n\n  /**\n   * Class method for getting the integer indices of a selection of genes within a list.\n   * @param {Array} selection A list of gene names.\n   * @returns {Array} A list of integer indices.\n   */\n  async _getGeneIndices(selection) {\n    const geneNames = await this.loadFilteredGeneNames();\n    return selection.map(gene => geneNames.indexOf(gene));\n  }\n\n  /**\n   * Class method for getting the number of cells i.e entries in `obs`.\n   * @returns {Number} The number of cells.\n   */\n  async _getNumCells() {\n    const cells = await this.dataSource.loadObsIndex();\n    return cells.length;\n  }\n\n  /**\n   * Class method for getting the number of genes i.e entries in `var`,\n   * potentially filtered by `genesFilter`.\n   * @returns {Number} The number of genes.\n   */\n  async _getNumGenes() {\n    const genes = await this.loadFilteredGeneNames();\n    return genes.length;\n  }\n\n  /**\n   * Class method for opening the sparse matrix arrays in zarr.\n   * @returns {Array} A list of promises pointing to the indptr, indices, and data of the matrix.\n   */\n  async _openSparseArrays() {\n    const { options: { matrix } } = this;\n    const { store } = this.dataSource;\n    if (this.sparseArrays) {\n      return this.sparseArrays;\n    }\n    this.sparseArrays = Promise.all(\n      ['indptr', 'indices', 'data'].map(name => openArray({ store, path: `${matrix}/${name}`, mode: 'r' })),\n    );\n    return this.sparseArrays;\n  }\n\n  /**\n   * Class method for loading a gene selection from a CSC matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */\n  async _loadCSCGeneSelection(selection) {\n    const indices = await this._getGeneIndices(selection);\n    const [indptrArr, indexArr, cellXGeneArr] = await this._openSparseArrays();\n    const numCells = await this._getNumCells();\n    const { data: cols } = await indptrArr.getRaw(null);\n    // If there is not change in the column indexer, then the data is all zeros\n    return Promise.all(\n      indices.map(async (index) => {\n        const startRowIndex = cols[index];\n        const endRowIndex = cols[index + 1];\n        const isColumnAllZeros = startRowIndex === endRowIndex;\n        const geneData = new Float32Array(numCells).fill(0);\n        if (isColumnAllZeros) {\n          return geneData;\n        }\n        const { data: rowIndices } = await indexArr.get([\n          slice(startRowIndex, endRowIndex),\n        ]);\n        const { data: cellXGeneData } = await cellXGeneArr.get([\n          slice(startRowIndex, endRowIndex),\n        ]);\n        for (let rowIndex = 0; rowIndex < rowIndices.length; rowIndex += 1) {\n          geneData[rowIndices[rowIndex]] = cellXGeneData[rowIndex];\n        }\n        return geneData;\n      }),\n    );\n  }\n\n  /**\n   * Class method for loading a gene selection from a CSR matrix.\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Promise} A Promise.all array of promises containing Uint8Arrays, one per selection.\n   */\n  async _loadCSRGeneSelection(selection) {\n    const indices = await this._getGeneIndices(selection);\n    const numGenes = await this._getNumGenes();\n    const numCells = await this._getNumCells();\n    const cellXGene = await this._loadCSRSparseCellXGene();\n    return indices.map((index) => {\n      const geneData = new Float32Array(numCells).fill(0);\n      for (let i = 0; i < numCells; i += 1) {\n        geneData[i] = cellXGene[i * numGenes + index];\n      }\n      return geneData;\n    });\n  }\n\n  /**\n   * Class method for loading row oriented (CSR) sparse data from zarr.\n   *\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */\n  async _loadCSRSparseCellXGene() {\n    if (this._sparseMatrix) {\n      return this._sparseMatrix;\n    }\n    this._sparseMatrix = this._openSparseArrays().then(async (sparseArrays) => {\n      const { options: { matrix } } = this;\n      const { shape } = await this.dataSource.getJson(`${matrix}/.zattrs`);\n      const [rows, cols, cellXGene] = await Promise.all(\n        sparseArrays.map(async (arr) => {\n          const { data } = await arr.getRaw(null);\n          return data;\n        }),\n      );\n      const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);\n      let row = 0;\n      rows.forEach((_, index) => {\n        const rowStart = rows[index];\n        const rowEnd = rows[index + 1];\n        for (let i = rowStart; i < rowEnd; i += 1) {\n          const val = cellXGene[i];\n          const col = cols[i];\n          cellXGeneMatrix[row * shape[1] + col] = val;\n        }\n        row += 1;\n      });\n      return cellXGeneMatrix;\n    });\n    return this._sparseMatrix;\n  }\n\n  /**\n   * Class method for loading column oriented (CSC) sparse data from zarr.\n   * @returns {Object} A { data: Float32Array } contianing the CellXGene matrix.\n   */\n  async _loadCSCSparseCellXGene() {\n    if (this._sparseMatrix) {\n      return this._sparseMatrix;\n    }\n    this._sparseMatrix = this._openSparseArrays().then(async (sparseArrays) => {\n      const { options: { matrix } } = this;\n      const { shape } = await this.dataSource.getJson(`${matrix}/.zattrs`);\n      const [cols, rows, cellXGene] = await Promise.all(\n        sparseArrays.map(async (arr) => {\n          const { data } = await arr.getRaw(null);\n          return data;\n        }),\n      );\n      const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);\n      let col = 0;\n      cols.forEach((_, index) => {\n        const colStart = cols[index];\n        const colEnd = cols[index + 1];\n        for (let i = colStart; i < colEnd; i += 1) {\n          const val = cellXGene[i];\n          const row = rows[i];\n          cellXGeneMatrix[row * shape[1] + col] = val;\n        }\n        col += 1;\n      });\n      return cellXGeneMatrix;\n    });\n    return this._sparseMatrix;\n  }\n\n  /**\n   * Class method for loading the cell x gene matrix.\n   * @returns {Promise} A promise for the zarr array contianing the cell x gene data.\n   */\n  async loadCellXGene() {\n    const { store } = this.dataSource;\n    if (this.cellXGene) {\n      return this.cellXGene;\n    }\n    const { options: { matrix, matrixGeneFilter } } = this;\n    if (!this._matrixZattrs) {\n      this._matrixZattrs = await this.dataSource.getJson(`${matrix}/.zattrs`);\n    }\n    const encodingType = this._matrixZattrs['encoding-type'];\n    if (!matrixGeneFilter) {\n      if (encodingType === 'csr_matrix') {\n        this.cellXGene = this._loadCSRSparseCellXGene().then(data => normalize(data));\n      } else if (encodingType === 'csc_matrix') {\n        this.cellXGene = this._loadCSCSparseCellXGene().then(data => normalize(data));\n      } else {\n        if (!this.arr) {\n          this.arr = openArray({ store, path: matrix, mode: 'r' });\n        }\n        this.cellXGene = this.arr.then(z => z.getRaw(null).then(({ data }) => normalize(data)));\n      }\n    } else if (encodingType === 'csr_matrix') {\n      this.cellXGene = this._loadCSRSparseCellXGene().then(\n        async (cellXGene) => {\n          const filteredGenes = await this._getFilteredGenes(matrixGeneFilter);\n          const numGenesFiltered = filteredGenes.length;\n          const geneNames = await this.loadFilteredGeneNames();\n          const numGenes = geneNames.length;\n          const numCells = await this._getNumCells();\n          const cellXGeneMatrixFiltered = new Float32Array(\n            numCells * numGenesFiltered,\n          ).fill(0);\n          for (let i = 0; i < numGenesFiltered; i += 1) {\n            const index = geneNames.indexOf(filteredGenes[i]);\n            for (let j = 0; j < numCells; j += 1) {\n              cellXGeneMatrixFiltered[j * numGenesFiltered + i] = cellXGene[j * numGenes + index];\n            }\n          }\n          return normalize(cellXGeneMatrixFiltered);\n        },\n      );\n    } else {\n      const genes = await this._getFilteredGenes(matrixGeneFilter);\n      this.cellXGene = this.loadGeneSelection({ selection: genes, shouldNormalize: false })\n        .then(({ data }) => (normalize(concatenateColumnVectors(data))));\n    }\n    return this.cellXGene;\n  }\n\n  /**\n   * Class method for loading a gene selection.\n   * @param {Object} args\n   * @param {Array} args.selection A list of gene names whose data should be fetched.\n   * @param {Boolean} args.shouldNormalize A list of gene names whose data should be fetched.\n   * @returns {Object} { data } containing an array of gene expression data.\n   */\n  async loadGeneSelection({ selection, shouldNormalize = true }) {\n    const { options: { matrix } } = this;\n    const { store } = this.dataSource;\n    if (!this._matrixZattrs) {\n      this._matrixZattrs = await this.dataSource.getJson(`${matrix}/.zattrs`);\n    }\n    const encodingType = this._matrixZattrs['encoding-type'];\n    let genes;\n    if (encodingType === 'csc_matrix') {\n      genes = await this._loadCSCGeneSelection(selection);\n    } else if (encodingType === 'csr_matrix') {\n      genes = await this._loadCSRGeneSelection(selection);\n    } else {\n      if (!this.arr) {\n        this.arr = openArray({ store, path: matrix, mode: 'r' });\n      }\n      const indices = await this._getGeneIndices(selection);\n      // We can index directly into a normal dense array zarr store via `get`.\n      genes = await Promise.all(\n        indices.map(index => this.arr.then(z => z.get([null, index])).then(({ data }) => data)),\n      );\n    }\n    return { data: genes.map(i => (shouldNormalize ? normalize(i).data : i)), url: null };\n  }\n\n  /**\n   * Class method for loading only attributes i.e rows and columns\n   * @param {Array} selection A list of gene names whose data should be fetched.\n   * @returns {Object} { data: { rows, cols }, url } containing row and col labels for the matrix.\n   */\n  loadAttrs() {\n    return Promise.all([this.dataSource.loadObsIndex(), this.loadFilteredGeneNames()])\n      .then((d) => {\n        const [cellNames, geneNames] = d;\n        const attrs = { rows: cellNames, cols: geneNames };\n        return {\n          data: attrs,\n          url: null,\n        };\n      });\n  }\n\n  load() {\n    return Promise.all([this.loadAttrs(), this.loadCellXGene()]).then(\n      async (d) => {\n        const [{ data: attrs }, cellXGene] = d;\n        const {\n          options: { matrixGeneFilter: matrixGeneFilterZarr },\n        } = this;\n        // In order to return the correct gene list with the heatmap data,\n        // we need to filter the columns of attrs so it matches the cellXGene data.\n        if (matrixGeneFilterZarr) {\n          const matrixGeneFilter = await this.dataSource.getFlatArrDecompressed(\n            matrixGeneFilterZarr,\n          );\n          attrs.cols = attrs.cols.filter((_, i) => matrixGeneFilter[i]);\n        }\n        return Promise.resolve(new LoaderResult([attrs, cellXGene], null));\n      },\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}