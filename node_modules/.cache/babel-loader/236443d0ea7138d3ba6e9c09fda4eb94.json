{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport log from '../utils/log';\nimport { createMat4, getCameraPosition, getFrustumPlanes as _getFrustumPlanes } from '../utils/math-utils';\nimport { Matrix4, Vector3, equals as _equals } from 'math.gl';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { getDistanceScales as _getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from '../lib/constants';\nvar DEGREES_TO_RADIANS = Math.PI / 180;\nvar IDENTITY = createMat4();\nvar ZERO_VECTOR = [0, 0, 0];\nvar DEFAULT_ZOOM = 0;\nvar DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\nvar Viewport = /*#__PURE__*/function () {\n  function Viewport() {\n    _classCallCheck(this, Viewport);\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _opts$id = opts.id,\n        id = _opts$id === void 0 ? null : _opts$id,\n        _opts$x = opts.x,\n        x = _opts$x === void 0 ? 0 : _opts$x,\n        _opts$y = opts.y,\n        y = _opts$y === void 0 ? 0 : _opts$y,\n        _opts$width = opts.width,\n        width = _opts$width === void 0 ? 1 : _opts$width,\n        _opts$height = opts.height,\n        height = _opts$height === void 0 ? 1 : _opts$height;\n    this.id = id || this.constructor.displayName || 'viewport';\n    this.x = x;\n    this.y = y;\n    this.width = width || 1;\n    this.height = height || 1;\n    this._frustumPlanes = {};\n\n    this._initViewMatrix(opts);\n\n    this._initProjectionMatrix(opts);\n\n    this._initPixelMatrices();\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  _createClass(Viewport, [{\n    key: \"equals\",\n    value: function equals(viewport) {\n      if (!(viewport instanceof Viewport)) {\n        return false;\n      }\n\n      if (this === viewport) {\n        return true;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && _equals(viewport.projectionMatrix, this.projectionMatrix) && _equals(viewport.viewMatrix, this.viewMatrix);\n    }\n  }, {\n    key: \"project\",\n    value: function project(xyz) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref4$topLeft = _ref4.topLeft,\n          topLeft = _ref4$topLeft === void 0 ? true : _ref4$topLeft;\n\n      var worldPosition = this.projectPosition(xyz);\n      var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n      var _coord = _slicedToArray(coord, 2),\n          x = _coord[0],\n          y = _coord[1];\n\n      var y2 = topLeft ? y : this.height - y;\n      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(xyz) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref5$topLeft = _ref5.topLeft,\n          topLeft = _ref5$topLeft === void 0 ? true : _ref5$topLeft,\n          targetZ = _ref5.targetZ;\n\n      var _xyz = _slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          z = _xyz[2];\n\n      var y2 = topLeft ? y : this.height - y;\n      var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n          _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3),\n          X = _this$unprojectPositi2[0],\n          Y = _this$unprojectPositi2[1],\n          Z = _this$unprojectPositi2[2];\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: \"projectPosition\",\n    value: function projectPosition(xyz) {\n      var _this$projectFlat = this.projectFlat(xyz),\n          _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2),\n          X = _this$projectFlat2[0],\n          Y = _this$projectFlat2[1];\n\n      var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"unprojectPosition\",\n    value: function unprojectPosition(xyz) {\n      var _this$unprojectFlat = this.unprojectFlat(xyz),\n          _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2),\n          X = _this$unprojectFlat2[0],\n          Y = _this$unprojectFlat2[1];\n\n      var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz) {\n      if (this.isGeospatial) {\n        return lngLatToWorld(xyz);\n      }\n\n      return xyz;\n    }\n  }, {\n    key: \"unprojectFlat\",\n    value: function unprojectFlat(xyz) {\n      if (this.isGeospatial) {\n        return worldToLngLat(xyz);\n      }\n\n      return xyz;\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var unprojectOption = {\n        targetZ: options.z || 0\n      };\n      var topLeft = this.unproject([0, 0], unprojectOption);\n      var topRight = this.unproject([this.width, 0], unprojectOption);\n      var bottomLeft = this.unproject([0, this.height], unprojectOption);\n      var bottomRight = this.unproject([this.width, this.height], unprojectOption);\n      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n    }\n  }, {\n    key: \"getDistanceScales\",\n    value: function getDistanceScales() {\n      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (coordinateOrigin) {\n        return _getDistanceScales({\n          longitude: coordinateOrigin[0],\n          latitude: coordinateOrigin[1],\n          highPrecision: true\n        });\n      }\n\n      return this.distanceScales;\n    }\n  }, {\n    key: \"containsPixel\",\n    value: function containsPixel(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          _ref$width = _ref.width,\n          width = _ref$width === void 0 ? 1 : _ref$width,\n          _ref$height = _ref.height,\n          height = _ref$height === void 0 ? 1 : _ref$height;\n      return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n    }\n  }, {\n    key: \"getFrustumPlanes\",\n    value: function getFrustumPlanes() {\n      if (this._frustumPlanes.near) {\n        return this._frustumPlanes;\n      }\n\n      Object.assign(this._frustumPlanes, _getFrustumPlanes(this.viewProjectionMatrix));\n      return this._frustumPlanes;\n    }\n  }, {\n    key: \"panByPosition\",\n    value: function panByPosition(coords, pixel) {\n      return null;\n    }\n  }, {\n    key: \"getCameraPosition\",\n    value: function getCameraPosition() {\n      return this.cameraPosition;\n    }\n  }, {\n    key: \"getCameraDirection\",\n    value: function getCameraDirection() {\n      return this.cameraDirection;\n    }\n  }, {\n    key: \"getCameraUp\",\n    value: function getCameraUp() {\n      return this.cameraUp;\n    }\n  }, {\n    key: \"_createProjectionMatrix\",\n    value: function _createProjectionMatrix(_ref2) {\n      var orthographic = _ref2.orthographic,\n          fovyRadians = _ref2.fovyRadians,\n          aspect = _ref2.aspect,\n          focalDistance = _ref2.focalDistance,\n          near = _ref2.near,\n          far = _ref2.far;\n      return orthographic ? new Matrix4().orthographic({\n        fovy: fovyRadians,\n        aspect: aspect,\n        focalDistance: focalDistance,\n        near: near,\n        far: far\n      }) : new Matrix4().perspective({\n        fovy: fovyRadians,\n        aspect: aspect,\n        near: near,\n        far: far\n      });\n    }\n  }, {\n    key: \"_initViewMatrix\",\n    value: function _initViewMatrix(opts) {\n      var _opts$viewMatrix = opts.viewMatrix,\n          viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY : _opts$viewMatrix,\n          _opts$longitude = opts.longitude,\n          longitude = _opts$longitude === void 0 ? null : _opts$longitude,\n          _opts$latitude = opts.latitude,\n          latitude = _opts$latitude === void 0 ? null : _opts$latitude,\n          _opts$zoom = opts.zoom,\n          zoom = _opts$zoom === void 0 ? null : _opts$zoom,\n          _opts$position = opts.position,\n          position = _opts$position === void 0 ? null : _opts$position,\n          _opts$modelMatrix = opts.modelMatrix,\n          modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix,\n          _opts$focalDistance = opts.focalDistance,\n          focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance,\n          _opts$distanceScales = opts.distanceScales,\n          distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales;\n      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n      this.zoom = zoom;\n\n      if (!Number.isFinite(this.zoom)) {\n        this.zoom = this.isGeospatial ? getMeterZoom({\n          latitude: latitude\n        }) + Math.log2(focalDistance) : DEFAULT_ZOOM;\n      }\n\n      var scale = Math.pow(2, this.zoom);\n      this.scale = scale;\n      this.distanceScales = this.isGeospatial ? _getDistanceScales({\n        latitude: latitude,\n        longitude: longitude\n      }) : distanceScales || DEFAULT_DISTANCE_SCALES;\n      this.focalDistance = focalDistance;\n      this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);\n      this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);\n      this.position = ZERO_VECTOR;\n      this.meterOffset = ZERO_VECTOR;\n\n      if (position) {\n        this.position = position;\n        this.modelMatrix = modelMatrix;\n        this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n      }\n\n      if (this.isGeospatial) {\n        this.longitude = longitude;\n        this.latitude = latitude;\n        this.center = this._getCenterInWorld({\n          longitude: longitude,\n          latitude: latitude\n        });\n      } else {\n        this.center = position ? this.projectPosition(position) : [0, 0, 0];\n      }\n\n      this.viewMatrixUncentered = viewMatrix;\n      this.viewMatrix = new Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new Vector3(this.center || ZERO_VECTOR).negate());\n    }\n  }, {\n    key: \"_getCenterInWorld\",\n    value: function _getCenterInWorld(_ref3) {\n      var longitude = _ref3.longitude,\n          latitude = _ref3.latitude;\n      var meterOffset = this.meterOffset,\n          distanceScales = this.distanceScales;\n      var center = new Vector3(this.projectPosition([longitude, latitude, 0]));\n\n      if (meterOffset) {\n        var commonPosition = new Vector3(meterOffset).scale(distanceScales.unitsPerMeter);\n        center.add(commonPosition);\n      }\n\n      return center;\n    }\n  }, {\n    key: \"_initProjectionMatrix\",\n    value: function _initProjectionMatrix(opts) {\n      var _opts$projectionMatri = opts.projectionMatrix,\n          projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri,\n          _opts$orthographic = opts.orthographic,\n          orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic,\n          fovyRadians = opts.fovyRadians,\n          _opts$fovy = opts.fovy,\n          fovy = _opts$fovy === void 0 ? 75 : _opts$fovy,\n          _opts$near = opts.near,\n          near = _opts$near === void 0 ? 0.1 : _opts$near,\n          _opts$far = opts.far,\n          far = _opts$far === void 0 ? 1000 : _opts$far,\n          _opts$focalDistance2 = opts.focalDistance,\n          focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2;\n      this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({\n        orthographic: orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        aspect: this.width / this.height,\n        focalDistance: focalDistance,\n        near: near,\n        far: far\n      });\n    }\n  }, {\n    key: \"_initPixelMatrices\",\n    value: function _initPixelMatrices() {\n      var vpm = createMat4();\n      mat4.multiply(vpm, vpm, this.projectionMatrix);\n      mat4.multiply(vpm, vpm, this.viewMatrix);\n      this.viewProjectionMatrix = vpm;\n      this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n      this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n      var viewportMatrix = createMat4();\n      var pixelProjectionMatrix = createMat4();\n      mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n      mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n      mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n      this.pixelProjectionMatrix = pixelProjectionMatrix;\n      this.viewportMatrix = viewportMatrix;\n      this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n\n      if (!this.pixelUnprojectionMatrix) {\n        log.warn('Pixel project matrix not invertible')();\n      }\n    }\n  }, {\n    key: \"metersPerPixel\",\n    get: function get() {\n      return this.distanceScales.metersPerUnit[2] / this.scale;\n    }\n  }, {\n    key: \"projectionMode\",\n    get: function get() {\n      if (this.isGeospatial) {\n        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n      }\n\n      return PROJECTION_MODE.IDENTITY;\n    }\n  }]);\n\n  return Viewport;\n}();\n\nexport { Viewport as default };\nViewport.displayName = 'Viewport';","map":{"version":3,"sources":["../../../src/viewports/viewport.js"],"names":["getFrustumPlanes","equals","getDistanceScales","DEGREES_TO_RADIANS","Math","IDENTITY","createMat4","ZERO_VECTOR","DEFAULT_ZOOM","DEFAULT_DISTANCE_SCALES","unitsPerMeter","metersPerUnit","constructor","opts","id","x","y","width","height","PROJECTION_MODE","viewport","topLeft","worldPosition","coord","worldToPixels","y2","xyz","targetZ","targetZWorld","pixelsToWorld","Number","Z","lngLatToWorld","worldToLngLat","options","unprojectOption","topRight","bottomLeft","bottomRight","coordinateOrigin","longitude","latitude","highPrecision","Object","far","orthographic","fovy","aspect","focalDistance","near","viewMatrix","zoom","position","modelMatrix","distanceScales","scale","center","commonPosition","projectionMatrix","fovyRadians","vpm","mat4","getCameraPosition","viewportMatrix","pixelProjectionMatrix","log","Viewport"],"mappings":";;;AAoBA,OAAA,GAAA,MAAA,cAAA;AACA,SAAA,UAAA,EAAA,iBAAA,EAAuCA,gBAAvC,IAAuCA,iBAAvC,QAAA,qBAAA;AAEA,SAAA,OAAA,EAAA,OAAA,EAA0BC,MAA1B,IAA0BA,OAA1B,QAAA,SAAA;AACA,OAAO,KAAP,IAAA,MAAA,gBAAA;AAEA,SACEC,iBADF,IACEA,kBADF,EAAA,YAAA,EAAA,aAAA,EAAA,aAAA,EAAA,aAAA,EAAA,aAAA,QAAA,uBAAA;AASA,SAAA,eAAA,QAAA,kBAAA;AAEA,IAAMC,kBAAkB,GAAGC,IAAI,CAAJA,EAAAA,GAA3B,GAAA;AAEA,IAAMC,QAAQ,GAAGC,UAAjB,EAAA;AAEA,IAAMC,WAAW,GAAG,CAAA,CAAA,EAAA,CAAA,EAApB,CAAoB,CAApB;AAEA,IAAMC,YAAY,GAAlB,CAAA;AAEA,IAAMC,uBAAuB,GAAG;AAC9BC,EAAAA,aAAa,EAAE,CAAA,CAAA,EAAA,CAAA,EADe,CACf,CADe;AAE9BC,EAAAA,aAAa,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA;AAFe,CAAhC;;IAKe,Q;AAQbC,sBAAuB;AAAA;;AAAA,QAAXC,IAAW,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAAA,mBACrB,IADqB,CAEnBC,EAFmB;AAAA,QAEnBA,EAFmB,yBACf,IADe;AAAA,kBACrB,IADqB,CAInBC,CAJmB;AAAA,QAInBA,CAJmB,wBACf,CADe;AAAA,kBACrB,IADqB,CAKnBC,CALmB;AAAA,QAKnBA,CALmB,wBACf,CADe;AAAA,sBACrB,IADqB,CAMnBC,KANmB;AAAA,QAMnBA,KANmB,4BACf,CADe;AAAA,uBACrB,IADqB,CAOnBC,MAPmB;AAAA,QAOnBA,MAPmB,6BAOV,CAPU;AAUrB,SAAA,EAAA,GAAUJ,EAAE,IAAI,KAAA,WAAA,CAANA,WAAAA,IAAV,UAAA;AAEA,SAAA,CAAA,GAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA;AAEA,SAAA,KAAA,GAAaG,KAAK,IAAlB,CAAA;AACA,SAAA,MAAA,GAAcC,MAAM,IAApB,CAAA;AACA,SAAA,cAAA,GAAA,EAAA;;AAEA,SAAA,eAAA,CAAA,IAAA;;AACA,SAAA,qBAAA,CAAA,IAAA;;AACA,SAAA,kBAAA;;AAGA,SAAA,MAAA,GAAc,KAAA,MAAA,CAAA,IAAA,CAAd,IAAc,CAAd;AACA,SAAA,OAAA,GAAe,KAAA,OAAA,CAAA,IAAA,CAAf,IAAe,CAAf;AACA,SAAA,SAAA,GAAiB,KAAA,SAAA,CAAA,IAAA,CAAjB,IAAiB,CAAjB;AACA,SAAA,eAAA,GAAuB,KAAA,eAAA,CAAA,IAAA,CAAvB,IAAuB,CAAvB;AACA,SAAA,iBAAA,GAAyB,KAAA,iBAAA,CAAA,IAAA,CAAzB,IAAyB,CAAzB;AACA,SAAA,WAAA,GAAmB,KAAA,WAAA,CAAA,IAAA,CAAnB,IAAmB,CAAnB;AACA,SAAA,aAAA,GAAqB,KAAA,aAAA,CAAA,IAAA,CAArB,IAAqB,CAArB;AACD;;;;2BAiBK,Q,EAAW;AACf,UAAI,EAAEE,QAAQ,YAAd,QAAI,CAAJ,EAAqC;AACnC,eAAA,KAAA;AACD;;AACD,UAAI,SAAJ,QAAA,EAAuB;AACrB,eAAA,IAAA;AACD;;AAED,aACEA,QAAQ,CAARA,KAAAA,KAAmB,KAAnBA,KAAAA,IACAA,QAAQ,CAARA,MAAAA,KAAoB,KADpBA,MAAAA,IAEAA,QAAQ,CAARA,KAAAA,KAAmB,KAFnBA,KAAAA,IAGAnB,OAAM,CAACmB,QAAQ,CAAT,gBAAA,EAA4B,KAHlCA,gBAGM,CAHNA,IAIAnB,OAAM,CAACmB,QAAQ,CAAT,UAAA,EAAsB,KAL9B,UAKQ,CALR;AAQD;;;4BAcM,G,EAA6B;AAAA,kBAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAAA,gCAAtBC,OAAsB;AAAA,UAAtBA,OAAsB,8BAAZ,IAAY;;AAClC,UAAMC,aAAa,GAAG,KAAA,eAAA,CAAtB,GAAsB,CAAtB;AACA,UAAMC,KAAK,GAAGC,aAAa,CAAA,aAAA,EAAgB,KAA3C,qBAA2B,CAA3B;;AAFkC,kCAIlC,KAJkC;AAAA,UAI5B,CAJ4B;AAAA,UAI5B,CAJ4B;;AAKlC,UAAMC,EAAE,GAAGJ,OAAO,GAAA,CAAA,GAAO,KAAA,MAAA,GAAzB,CAAA;AACA,aAAOK,GAAG,CAAHA,MAAAA,KAAAA,CAAAA,GAAmB,CAAA,CAAA,EAAnBA,EAAmB,CAAnBA,GAA6B,CAAA,CAAA,EAAA,EAAA,EAAQH,KAAK,CAAjD,CAAiD,CAAb,CAApC;AACD;;;8BAYQ,G,EAAsC;AAAA,kBAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAAA,gCAA/BF,OAA+B;AAAA,UAA/BA,OAA+B,8BAAhC,IAAgC;AAAA,UAAfM,OAAe,SAAfA,OAAe;;AAAA,gCAC7C,GAD6C;AAAA,UACvC,CADuC;AAAA,UACvC,CADuC;AAAA,UACvC,CADuC;;AAG7C,UAAMF,EAAE,GAAGJ,OAAO,GAAA,CAAA,GAAO,KAAA,MAAA,GAAzB,CAAA;AACA,UAAMO,YAAY,GAAGD,OAAO,IAAIA,OAAO,GAAG,KAAA,cAAA,CAAA,aAAA,CAA1C,CAA0C,CAA1C;AACA,UAAMJ,KAAK,GAAGM,aAAa,CAAC,CAAA,CAAA,EAAA,EAAA,EAAD,CAAC,CAAD,EAAa,KAAb,uBAAA,EAA3B,YAA2B,CAA3B;;AAL6C,kCAM3B,KAAA,iBAAA,CAAlB,KAAkB,CAN2B;AAAA;AAAA,UAMvC,CANuC;AAAA,UAMvC,CANuC;AAAA,UAMvC,CANuC;;AAQ7C,UAAIC,MAAM,CAANA,QAAAA,CAAJ,CAAIA,CAAJ,EAAwB;AACtB,eAAO,CAAA,CAAA,EAAA,CAAA,EAAP,CAAO,CAAP;AACD;;AACD,aAAOA,MAAM,CAANA,QAAAA,CAAAA,OAAAA,IAA2B,CAAA,CAAA,EAAA,CAAA,EAA3BA,OAA2B,CAA3BA,GAA6C,CAAA,CAAA,EAApD,CAAoD,CAApD;AACD;;;oCAKc,G,EAAM;AAAA,8BACJ,KAAA,WAAA,CAAf,GAAe,CADI;AAAA;AAAA,UACb,CADa;AAAA,UACb,CADa;;AAEnB,UAAMC,CAAC,GAAG,CAACL,GAAG,CAAHA,CAAG,CAAHA,IAAD,CAAA,IAAgB,KAAA,cAAA,CAAA,aAAA,CAA1B,CAA0B,CAA1B;AACA,aAAO,CAAA,CAAA,EAAA,CAAA,EAAP,CAAO,CAAP;AACD;;;sCAEgB,G,EAAM;AAAA,gCACN,KAAA,aAAA,CAAf,GAAe,CADM;AAAA;AAAA,UACf,CADe;AAAA,UACf,CADe;;AAErB,UAAMK,CAAC,GAAG,CAACL,GAAG,CAAHA,CAAG,CAAHA,IAAD,CAAA,IAAgB,KAAA,cAAA,CAAA,aAAA,CAA1B,CAA0B,CAA1B;AACA,aAAO,CAAA,CAAA,EAAA,CAAA,EAAP,CAAO,CAAP;AACD;;;gCAWU,G,EAAM;AACf,UAAI,KAAJ,YAAA,EAAuB;AACrB,eAAOM,aAAa,CAApB,GAAoB,CAApB;AACD;;AACD,aAAA,GAAA;AACD;;;kCAUY,G,EAAM;AACjB,UAAI,KAAJ,YAAA,EAAuB;AACrB,eAAOC,aAAa,CAApB,GAAoB,CAApB;AACD;;AACD,aAAA,GAAA;AACD;;;gCAEuB;AAAA,UAAdC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AACtB,UAAMC,eAAe,GAAG;AAACR,QAAAA,OAAO,EAAEO,OAAO,CAAPA,CAAAA,IAAa;AAAvB,OAAxB;AAEA,UAAMb,OAAO,GAAG,KAAA,SAAA,CAAe,CAAA,CAAA,EAAf,CAAe,CAAf,EAAhB,eAAgB,CAAhB;AACA,UAAMe,QAAQ,GAAG,KAAA,SAAA,CAAe,CAAC,KAAD,KAAA,EAAf,CAAe,CAAf,EAAjB,eAAiB,CAAjB;AACA,UAAMC,UAAU,GAAG,KAAA,SAAA,CAAe,CAAA,CAAA,EAAI,KAAnB,MAAe,CAAf,EAAnB,eAAmB,CAAnB;AACA,UAAMC,WAAW,GAAG,KAAA,SAAA,CAAe,CAAC,KAAD,KAAA,EAAa,KAA5B,MAAe,CAAf,EAApB,eAAoB,CAApB;AAEA,aAAO,CACLlC,IAAI,CAAJA,GAAAA,CAASiB,OAAO,CAAhBjB,CAAgB,CAAhBA,EAAqBgC,QAAQ,CAA7BhC,CAA6B,CAA7BA,EAAkCiC,UAAU,CAA5CjC,CAA4C,CAA5CA,EAAiDkC,WAAW,CADvD,CACuD,CAA5DlC,CADK,EAELA,IAAI,CAAJA,GAAAA,CAASiB,OAAO,CAAhBjB,CAAgB,CAAhBA,EAAqBgC,QAAQ,CAA7BhC,CAA6B,CAA7BA,EAAkCiC,UAAU,CAA5CjC,CAA4C,CAA5CA,EAAiDkC,WAAW,CAFvD,CAEuD,CAA5DlC,CAFK,EAGLA,IAAI,CAAJA,GAAAA,CAASiB,OAAO,CAAhBjB,CAAgB,CAAhBA,EAAqBgC,QAAQ,CAA7BhC,CAA6B,CAA7BA,EAAkCiC,UAAU,CAA5CjC,CAA4C,CAA5CA,EAAiDkC,WAAW,CAHvD,CAGuD,CAA5DlC,CAHK,EAILA,IAAI,CAAJA,GAAAA,CAASiB,OAAO,CAAhBjB,CAAgB,CAAhBA,EAAqBgC,QAAQ,CAA7BhC,CAA6B,CAA7BA,EAAkCiC,UAAU,CAA5CjC,CAA4C,CAA5CA,EAAiDkC,WAAW,CAJ9D,CAI8D,CAA5DlC,CAJK,CAAP;AAMD;;;wCAE0C;AAAA,UAAzBmC,gBAAyB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM;;AACzC,UAAA,gBAAA,EAAsB;AACpB,eAAOrC,kBAAiB,CAAC;AACvBsC,UAAAA,SAAS,EAAED,gBAAgB,CADJ,CACI,CADJ;AAEvBE,UAAAA,QAAQ,EAAEF,gBAAgB,CAFH,CAEG,CAFH;AAGvBG,UAAAA,aAAa,EAAE;AAHQ,SAAD,CAAxB;AAKD;;AACD,aAAO,KAAP,cAAA;AACD;;;kCAEY,I,EAAgC;AAAA,UAA/B,CAA+B,GAAA,IAAA,CAA/B,CAA+B;AAAA,UAA/B,CAA+B,GAAA,IAAA,CAA/B,CAA+B;AAAA,uBAAA,IAAA,CAAxBzB,KAAwB;AAAA,UAAxBA,KAAwB,2BAA/B,CAA+B;AAAA,wBAAA,IAAA,CAAbC,MAAa;AAAA,UAAbA,MAAa,4BAAJ,CAAI;AAC3C,aACEH,CAAC,GAAG,KAAA,CAAA,GAAS,KAAbA,KAAAA,IACA,KAAA,CAAA,GAASA,CAAC,GADVA,KAAAA,IAEAC,CAAC,GAAG,KAAA,CAAA,GAAS,KAFbD,MAAAA,IAGA,KAAA,CAAA,GAASC,CAAC,GAJZ,MAAA;AAMD;;;uCAGkB;AACjB,UAAI,KAAA,cAAA,CAAJ,IAAA,EAA8B;AAC5B,eAAO,KAAP,cAAA;AACD;;AAED2B,MAAAA,MAAM,CAANA,MAAAA,CAAc,KAAdA,cAAAA,EAAmC3C,iBAAgB,CAAC,KAApD2C,oBAAmD,CAAnDA;AAEA,aAAO,KAAP,cAAA;AACD;;;kCAYY,M,EAAA,K,EAAgB;AAC3B,aAAA,IAAA;AACD;;;wCAEmB;AAClB,aAAO,KAAP,cAAA;AACD;;;yCAEoB;AACnB,aAAO,KAAP,eAAA;AACD;;;kCAEa;AACZ,aAAO,KAAP,QAAA;AACD;;;4CAIsB,K,EAAgE;AAAA,UAA/D,YAA+D,GAAA,KAAA,CAA/D,YAA+D;AAAA,UAA/D,WAA+D,GAAA,KAAA,CAA/D,WAA+D;AAAA,UAA/D,MAA+D,GAAA,KAAA,CAA/D,MAA+D;AAAA,UAA/D,aAA+D,GAAA,KAAA,CAA/D,aAA+D;AAAA,UAA/D,IAA+D,GAAA,KAAA,CAA/D,IAA+D;AAAA,UAANC,GAAM,GAAA,KAAA,CAANA,GAAM;AACrF,aAAOC,YAAY,GACf,IAAA,OAAA,GAAA,YAAA,CAA2B;AAACC,QAAAA,IAAI,EAAL,WAAA;AAAoBC,QAAAA,MAApB,EAAoBA,MAApB;AAA4BC,QAAAA,aAA5B,EAA4BA,aAA5B;AAA2CC,QAAAA,IAA3C,EAA2CA,IAA3C;AAAiDL,QAAAA,GAAAA,EAAAA;AAAjD,OAA3B,CADe,GAEf,IAAA,OAAA,GAAA,WAAA,CAA0B;AAACE,QAAAA,IAAI,EAAL,WAAA;AAAoBC,QAAAA,MAApB,EAAoBA,MAApB;AAA4BE,QAAAA,IAA5B,EAA4BA,IAA5B;AAAkCL,QAAAA,GAAAA,EAAAA;AAAlC,OAA1B,CAFJ;AAGD;;;oCAGc,I,EAAO;AAAA,6BACpB,IADoB,CAGlBM,UAHkB;AAAA,UAGlBA,UAHkB,iCACd,QADc;AAAA,4BACpB,IADoB,CAKlBV,SALkB;AAAA,UAKlBA,SALkB,gCACd,IADc;AAAA,2BACpB,IADoB,CAMlBC,QANkB;AAAA,UAMlBA,QANkB,+BACd,IADc;AAAA,uBACpB,IADoB,CAOlBU,IAPkB;AAAA,UAOlBA,IAPkB,2BACd,IADc;AAAA,2BACpB,IADoB,CASlBC,QATkB;AAAA,UASlBA,QATkB,+BACd,IADc;AAAA,8BACpB,IADoB,CAUlBC,WAVkB;AAAA,UAUlBA,WAVkB,kCACd,IADc;AAAA,gCACpB,IADoB,CAWlBL,aAXkB;AAAA,UAWlBA,aAXkB,oCACd,CADc;AAAA,iCACpB,IADoB,CAalBM,cAbkB;AAAA,UAalBA,cAbkB,qCAaD,IAbC;AAiBpB,WAAA,YAAA,GAAoBxB,MAAM,CAANA,QAAAA,CAAAA,QAAAA,KAA6BA,MAAM,CAANA,QAAAA,CAAjD,SAAiDA,CAAjD;AAEA,WAAA,IAAA,GAAA,IAAA;;AACA,UAAI,CAACA,MAAM,CAANA,QAAAA,CAAgB,KAArB,IAAKA,CAAL,EAAiC;AAC/B,aAAA,IAAA,GAAY,KAAA,YAAA,GACR,YAAY,CAAC;AAACW,UAAAA,QAAAA,EAAAA;AAAD,SAAD,CAAZ,GAA2BrC,IAAI,CAAJA,IAAAA,CADnB,aACmBA,CADnB,GAAZ,YAAA;AAGD;;AACD,UAAMmD,KAAK,GAAGnD,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAY,KAA1B,IAAcA,CAAd;AACA,WAAA,KAAA,GAAA,KAAA;AAGA,WAAA,cAAA,GAAsB,KAAA,YAAA,GAClBF,kBAAiB,CAAC;AAACuC,QAAAA,QAAD,EAACA,QAAD;AAAWD,QAAAA,SAAAA,EAAAA;AAAX,OAAD,CADC,GAElBc,cAAc,IAFlB,uBAAA;AAIA,WAAA,aAAA,GAAA,aAAA;AAEA,WAAA,cAAA,CAAA,aAAA,GAAoC,IAAA,OAAA,CAAY,KAAA,cAAA,CAAhD,aAAoC,CAApC;AACA,WAAA,cAAA,CAAA,aAAA,GAAoC,IAAA,OAAA,CAAY,KAAA,cAAA,CAAhD,aAAoC,CAApC;AAEA,WAAA,QAAA,GAAA,WAAA;AACA,WAAA,WAAA,GAAA,WAAA;;AACA,UAAA,QAAA,EAAc;AAEZ,aAAA,QAAA,GAAA,QAAA;AACA,aAAA,WAAA,GAAA,WAAA;AACA,aAAA,WAAA,GAAmBD,WAAW,GAAGA,WAAW,CAAXA,eAAAA,CAAH,QAAGA,CAAH,GAA9B,QAAA;AACD;;AAED,UAAI,KAAJ,YAAA,EAAuB;AAErB,aAAA,SAAA,GAAA,SAAA;AACA,aAAA,QAAA,GAAA,QAAA;AACA,aAAA,MAAA,GAAc,KAAA,iBAAA,CAAuB;AAACb,UAAAA,SAAD,EAACA,SAAD;AAAYC,UAAAA,QAAAA,EAAAA;AAAZ,SAAvB,CAAd;AAJF,OAAA,MAKO;AACL,aAAA,MAAA,GAAcW,QAAQ,GAAG,KAAA,eAAA,CAAH,QAAG,CAAH,GAAoC,CAAA,CAAA,EAAA,CAAA,EAA1D,CAA0D,CAA1D;AACD;;AACD,WAAA,oBAAA,GAAA,UAAA;AAEA,WAAA,UAAA,GAAkB,IAAA,OAAA,GAAA,aAAA,CAED,KAFC,oBAAA,EAAA,SAAA,CAIL,IAAA,OAAA,CAAY,KAAA,MAAA,IAAZ,WAAA,EAJb,MAIa,EAJK,CAAlB;AAKD;;;sCAGgB,K,EAAwB;AAAA,UAAvB,SAAuB,GAAA,KAAA,CAAvB,SAAuB;AAAA,UAAXX,QAAW,GAAA,KAAA,CAAXA,QAAW;AAAA,UACjC,WADiC,GACvC,IADuC,CACjC,WADiC;AAAA,UACnBa,cADmB,GACvC,IADuC,CACnBA,cADmB;AAIvC,UAAME,MAAM,GAAG,IAAA,OAAA,CAAY,KAAA,eAAA,CAAqB,CAAA,SAAA,EAAA,QAAA,EAAhD,CAAgD,CAArB,CAAZ,CAAf;;AAEA,UAAA,WAAA,EAAiB;AACf,YAAMC,cAAc,GAAG,IAAA,OAAA,CAAA,WAAA,EAAA,KAAA,CAEdH,cAAc,CAFvB,aAAuB,CAAvB;AAGAE,QAAAA,MAAM,CAANA,GAAAA,CAAAA,cAAAA;AACD;;AAED,aAAA,MAAA;AACD;;;0CAEoB,I,EAAO;AAAA,kCAC1B,IAD0B,CAGxBE,gBAHwB;AAAA,UAGxBA,gBAHwB,sCACpB,IADoB;AAAA,+BAC1B,IAD0B,CAMxBb,YANwB;AAAA,UAMxBA,YANwB,mCACpB,KADoB;AAAA,UACpB,WADoB,GAC1B,IAD0B,CACpB,WADoB;AAAA,uBAC1B,IAD0B,CAQxBC,IARwB;AAAA,UAQxBA,IARwB,2BACpB,EADoB;AAAA,uBAC1B,IAD0B,CASxBG,IATwB;AAAA,UASxBA,IATwB,2BACpB,GADoB;AAAA,sBAC1B,IAD0B,CAUxBL,GAVwB;AAAA,UAUxBA,GAVwB,0BACpB,IADoB;AAAA,iCAC1B,IAD0B,CAWxBI,aAXwB;AAAA,UAWxBA,aAXwB,qCAWR,CAXQ;AAc1B,WAAA,gBAAA,GACEU,gBAAgB,IAChB,KAAA,uBAAA,CAA6B;AAC3Bb,QAAAA,YAD2B,EAC3BA,YAD2B;AAE3Bc,QAAAA,WAAW,EAAEA,WAAW,IAAIb,IAAI,GAFL,kBAAA;AAG3BC,QAAAA,MAAM,EAAE,KAAA,KAAA,GAAa,KAHM,MAAA;AAI3BC,QAAAA,aAJ2B,EAI3BA,aAJ2B;AAK3BC,QAAAA,IAL2B,EAK3BA,IAL2B;AAM3BL,QAAAA,GAAAA,EAAAA;AAN2B,OAA7B,CAFF;AAUD;;;yCAEoB;AAGnB,UAAMgB,GAAG,GAAGtD,UAAZ,EAAA;AACAuD,MAAAA,IAAI,CAAJA,QAAAA,CAAAA,GAAAA,EAAAA,GAAAA,EAAwB,KAAxBA,gBAAAA;AACAA,MAAAA,IAAI,CAAJA,QAAAA,CAAAA,GAAAA,EAAAA,GAAAA,EAAwB,KAAxBA,UAAAA;AACA,WAAA,oBAAA,GAAA,GAAA;AAKA,WAAA,iBAAA,GAAyBA,IAAI,CAAJA,MAAAA,CAAAA,EAAAA,EAAgB,KAAhBA,UAAAA,KAAoC,KAA7D,UAAA;AAGA,WAAA,cAAA,GAAsBC,iBAAiB,CAAC,KAAxC,iBAAuC,CAAvC;AAaA,UAAMC,cAAc,GAAGzD,UAAvB,EAAA;AACA,UAAM0D,qBAAqB,GAAG1D,UAA9B,EAAA;AACAuD,MAAAA,IAAI,CAAJA,KAAAA,CAAAA,cAAAA,EAAAA,cAAAA,EAA2C,CAAC,KAAA,KAAA,GAAD,CAAA,EAAiB,CAAC,KAAD,MAAA,GAAjB,CAAA,EAA3CA,CAA2C,CAA3CA;AACAA,MAAAA,IAAI,CAAJA,SAAAA,CAAAA,cAAAA,EAAAA,cAAAA,EAA+C,CAAA,CAAA,EAAI,CAAJ,CAAA,EAA/CA,CAA+C,CAA/CA;AACAA,MAAAA,IAAI,CAAJA,QAAAA,CAAAA,qBAAAA,EAAAA,cAAAA,EAAqD,KAArDA,oBAAAA;AACA,WAAA,qBAAA,GAAA,qBAAA;AACA,WAAA,cAAA,GAAA,cAAA;AAEA,WAAA,uBAAA,GAA+BA,IAAI,CAAJA,MAAAA,CAAYvD,UAAZuD,EAAAA,EAA0B,KAAzD,qBAA+BA,CAA/B;;AACA,UAAI,CAAC,KAAL,uBAAA,EAAmC;AACjCI,QAAAA,GAAG,CAAHA,IAAAA,CAAAA,qCAAAA;AAED;AACF;;;wBAjWoB;AACnB,aAAO,KAAA,cAAA,CAAA,aAAA,CAAA,CAAA,IAAuC,KAA9C,KAAA;AACD;;;wBAEoB;AACnB,UAAI,KAAJ,YAAA,EAAuB;AACrB,eAAO,KAAA,IAAA,GAAA,EAAA,GACH9C,eAAe,CADZ,YAAA,GAEHA,eAAe,CAFnB,wBAAA;AAGD;;AACD,aAAOA,eAAe,CAAtB,QAAA;AACD;;;;;;SApDY,Q;AA6Yf+C,QAAQ,CAARA,WAAAA,GAAAA,UAAAA","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport {createMat4, getCameraPosition, getFrustumPlanes} from '../utils/math-utils';\n\nimport {Matrix4, Vector3, equals} from 'math.gl';\nimport * as mat4 from 'gl-matrix/mat4';\n\nimport {\n  getDistanceScales,\n  getMeterZoom,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  pixelsToWorld\n} from '@math.gl/web-mercator';\n\nimport {PROJECTION_MODE} from '../lib/constants';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nconst IDENTITY = createMat4();\n\nconst ZERO_VECTOR = [0, 0, 0];\n\nconst DEFAULT_ZOOM = 0;\n\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\nexport default class Viewport {\n  /**\n   * @classdesc\n   * Manages coordinate system transformations for deck.gl.\n   *\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  constructor(opts = {}) {\n    const {\n      id = null,\n      // Window width/height in pixels (for pixel projection)\n      x = 0,\n      y = 0,\n      width = 1,\n      height = 1\n    } = opts;\n\n    this.id = id || this.constructor.displayName || 'viewport';\n\n    this.x = x;\n    this.y = y;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = width || 1;\n    this.height = height || 1;\n    this._frustumPlanes = {};\n\n    this._initViewMatrix(opts);\n    this._initProjectionMatrix(opts);\n    this._initPixelMatrices();\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12\n        ? PROJECTION_MODE.WEB_MERCATOR\n        : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      viewport.scale === this.scale &&\n      equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      equals(viewport.viewMatrix, this.viewMatrix)\n    );\n    // TODO - check distance scales?\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz, {topLeft = true} = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(xyz, {topLeft = true, targetZ} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      return lngLatToWorld(xyz);\n    }\n    return xyz;\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz;\n  }\n\n  getBounds(options = {}) {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n\n    return [\n      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),\n      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])\n    ];\n  }\n\n  getDistanceScales(coordinateOrigin = null) {\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n\n  containsPixel({x, y, width = 1, height = 1}) {\n    return (\n      x < this.x + this.width &&\n      this.x < x + width &&\n      y < this.y + this.height &&\n      this.y < y + height\n    );\n  }\n\n  // Extract frustum planes in common space\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n\n    return this._frustumPlanes;\n  }\n\n  // EXPERIMENTAL METHODS\n\n  /**\n   * Needed by panning and linear transition\n   * Pan the viewport to place a given world coordinate at screen point [x, y]\n   *\n   * @param {Array} coords - world coordinates\n   * @param {Array} pixel - [x,y] coordinates on screen\n   * @return {Object} props of the new viewport\n   */\n  panByPosition(coords, pixel) {\n    return null;\n  }\n\n  getCameraPosition() {\n    return this.cameraPosition;\n  }\n\n  getCameraDirection() {\n    return this.cameraDirection;\n  }\n\n  getCameraUp() {\n    return this.cameraUp;\n  }\n\n  // INTERNAL METHODS\n\n  _createProjectionMatrix({orthographic, fovyRadians, aspect, focalDistance, near, far}) {\n    return orthographic\n      ? new Matrix4().orthographic({fovy: fovyRadians, aspect, focalDistance, near, far})\n      : new Matrix4().perspective({fovy: fovyRadians, aspect, near, far});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  _initViewMatrix(opts) {\n    const {\n      // view matrix\n      viewMatrix = IDENTITY,\n\n      longitude = null, // Anchor: lng lat zoom makes viewport work w/ geospatial coordinate systems\n      latitude = null,\n      zoom = null,\n\n      position = null, // Anchor position offset (in meters for geospatial viewports)\n      modelMatrix = null, // A model matrix to be applied to position, to match the layer props API\n      focalDistance = 1, // Only needed for orthographic views\n\n      distanceScales = null\n    } = opts;\n\n    // Check if we have a geospatial anchor\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n\n    this.zoom = zoom;\n    if (!Number.isFinite(this.zoom)) {\n      this.zoom = this.isGeospatial\n        ? getMeterZoom({latitude}) + Math.log2(focalDistance)\n        : DEFAULT_ZOOM;\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n\n    // Calculate distance scales if lng/lat/zoom are provided\n    this.distanceScales = this.isGeospatial\n      ? getDistanceScales({latitude, longitude})\n      : distanceScales || DEFAULT_DISTANCE_SCALES;\n\n    this.focalDistance = focalDistance;\n\n    this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);\n    this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);\n\n    this.position = ZERO_VECTOR;\n    this.meterOffset = ZERO_VECTOR;\n    if (position) {\n      // Apply model matrix if supplied\n      this.position = position;\n      this.modelMatrix = modelMatrix;\n      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n    }\n\n    if (this.isGeospatial) {\n      // Determine camera center\n      this.longitude = longitude;\n      this.latitude = latitude;\n      this.center = this._getCenterInWorld({longitude, latitude});\n    } else {\n      this.center = position ? this.projectPosition(position) : [0, 0, 0];\n    }\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n      // Apply the uncentered view matrix\n      .multiplyRight(this.viewMatrixUncentered)\n      // And center it\n      .translate(new Vector3(this.center || ZERO_VECTOR).negate());\n  }\n  /* eslint-enable complexity, max-statements */\n\n  _getCenterInWorld({longitude, latitude}) {\n    const {meterOffset, distanceScales} = this;\n\n    // Make a centered version of the matrix for projection modes without an offset\n    const center = new Vector3(this.projectPosition([longitude, latitude, 0]));\n\n    if (meterOffset) {\n      const commonPosition = new Vector3(meterOffset)\n        // Convert to pixels in current zoom\n        .scale(distanceScales.unitsPerMeter);\n      center.add(commonPosition);\n    }\n\n    return center;\n  }\n\n  _initProjectionMatrix(opts) {\n    const {\n      // Projection matrix\n      projectionMatrix = null,\n\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1, // Distance of near clipping plane\n      far = 1000, // Distance of far clipping plane\n      focalDistance = 1\n    } = opts;\n\n    this.projectionMatrix =\n      projectionMatrix ||\n      this._createProjectionMatrix({\n        orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        aspect: this.width / this.height,\n        focalDistance,\n        near,\n        far\n      });\n  }\n\n  _initPixelMatrices() {\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n\n    // Decompose camera parameters\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.viewportMatrix = viewportMatrix;\n\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\n\nViewport.displayName = 'Viewport';\n"]},"metadata":{},"sourceType":"module"}