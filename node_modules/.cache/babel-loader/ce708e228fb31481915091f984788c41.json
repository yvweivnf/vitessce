{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, getSizeChannel, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, Y, Y2 } from './channel';\nimport { getMarkConfig, getMarkPropOrConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { hasDiscreteDomain, isContinuousToDiscrete, SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, stringify, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalParameter(c) {\n  return c['param'];\n}\nexport function isRepeatRef(field) {\n  return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n  var field = fieldDef.field,\n      timeUnit = fieldDef.timeUnit,\n      bin = fieldDef.bin,\n      aggregate = fieldDef.aggregate;\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? {\n    timeUnit: timeUnit\n  } : {}), bin ? {\n    bin: bin\n  } : {}), aggregate ? {\n    aggregate: aggregate\n  } : {}), {\n    field: field\n  });\n}\nexport function isSortableFieldDef(fieldDef) {\n  return 'sort' in fieldDef;\n}\nexport function getBandPosition(_ref) {\n  var fieldDef = _ref.fieldDef,\n      fieldDef2 = _ref.fieldDef2,\n      mark = _ref.markDef,\n      config = _ref.config;\n\n  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== undefined) {\n    return fieldDef.bandPosition;\n  }\n\n  if (isFieldDef(fieldDef)) {\n    var timeUnit = fieldDef.timeUnit,\n        bin = fieldDef.bin;\n\n    if (timeUnit && !fieldDef2) {\n      return isRectBasedMark(mark.type) ? 0 : getMarkConfig('timeUnitBandPosition', mark, config);\n    } else if (isBinning(bin)) {\n      return 0.5;\n    }\n  }\n\n  return undefined;\n}\nexport function getBandSize(_ref2) {\n  var channel = _ref2.channel,\n      fieldDef = _ref2.fieldDef,\n      fieldDef2 = _ref2.fieldDef2,\n      mark = _ref2.markDef,\n      config = _ref2.config,\n      scaleType = _ref2.scaleType,\n      useVlSizeChannel = _ref2.useVlSizeChannel;\n\n  var _a, _b, _c;\n\n  var sizeChannel = getSizeChannel(channel);\n  var size = getMarkPropOrConfig(useVlSizeChannel ? 'size' : sizeChannel, mark, config, {\n    vgChannel: sizeChannel\n  });\n\n  if (size !== undefined) {\n    return size;\n  }\n\n  if (isFieldDef(fieldDef)) {\n    var timeUnit = fieldDef.timeUnit,\n        bin = fieldDef.bin;\n\n    if (timeUnit && !fieldDef2) {\n      return {\n        band: getMarkConfig('timeUnitBandSize', mark, config)\n      };\n    } else if (isBinning(bin) && !hasDiscreteDomain(scaleType)) {\n      return {\n        band: 1\n      };\n    }\n  }\n\n  if (isRectBasedMark(mark.type)) {\n    if (scaleType) {\n      if (hasDiscreteDomain(scaleType)) {\n        return ((_a = config[mark.type]) === null || _a === void 0 ? void 0 : _a.discreteBandSize) || {\n          band: 1\n        };\n      } else {\n        return (_b = config[mark.type]) === null || _b === void 0 ? void 0 : _b.continuousBandSize;\n      }\n    }\n\n    return (_c = config[mark.type]) === null || _c === void 0 ? void 0 : _c.discreteBandSize;\n  }\n\n  return undefined;\n}\nexport function hasBandEnd(fieldDef, fieldDef2, markDef, config) {\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal') {\n    // Need to check bandPosition because non-rect marks (e.g., point) with timeUnit\n    // doesn't have to use bandEnd if there is no bandPosition.\n    return getBandPosition({\n      fieldDef: fieldDef,\n      fieldDef2: fieldDef2,\n      markDef: markDef,\n      config: config\n    }) !== undefined;\n  }\n\n  return false;\n}\nexport function isConditionalDef(channelDef) {\n  return channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\n\nexport function hasConditionalFieldDef(channelDef) {\n  var condition = channelDef && channelDef['condition'];\n  return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n  var condition = channelDef && channelDef['condition'];\n  return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n  var condition = channelDef && channelDef['condition'];\n  return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n  // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n  return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n  return channelDef && channelDef['type'];\n}\nexport function isDatumDef(channelDef) {\n  return channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);\n}\nexport function isQuantitativeFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return channelDefType(cd) === 'quantitative' || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n  return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n  return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n  return channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n  return channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n  return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n  return channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n  return channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n  // omit properties that don't exist in string field defs\n  return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\n\nfunction isOpFieldDef(fieldDef) {\n  return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\n\n\nexport function vgField(fieldDef) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a, _b, _c;\n\n  var field = fieldDef.field;\n  var prefix = opt.prefix;\n  var suffix = opt.suffix;\n  var argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n\n  if (isCount(fieldDef)) {\n    field = internalField('count');\n  } else {\n    var fn;\n\n    if (!opt.nofn) {\n      if (isOpFieldDef(fieldDef)) {\n        fn = fieldDef.op;\n      } else {\n        var bin = fieldDef.bin,\n            aggregate = fieldDef.aggregate,\n            timeUnit = fieldDef.timeUnit;\n\n        if (isBinning(bin)) {\n          fn = binToString(bin);\n          suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : '') + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : '');\n        } else if (aggregate) {\n          if (isArgmaxDef(aggregate)) {\n            argAccessor = \"[\\\"\".concat(field, \"\\\"]\");\n            field = \"argmax_\".concat(aggregate.argmax);\n          } else if (isArgminDef(aggregate)) {\n            argAccessor = \"[\\\"\".concat(field, \"\\\"]\");\n            field = \"argmin_\".concat(aggregate.argmin);\n          } else {\n            fn = String(aggregate);\n          }\n        } else if (timeUnit) {\n          fn = timeUnitToString(timeUnit);\n          suffix = (!['range', 'mid'].includes(opt.binSuffix) && opt.binSuffix || '') + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : '');\n        }\n      }\n    }\n\n    if (fn) {\n      field = field ? \"\".concat(fn, \"_\").concat(field) : fn;\n    }\n  }\n\n  if (suffix) {\n    field = \"\".concat(field, \"_\").concat(suffix);\n  }\n\n  if (prefix) {\n    field = \"\".concat(prefix, \"_\").concat(field);\n  }\n\n  if (opt.forAs) {\n    return removePathFromField(field);\n  } else if (opt.expr) {\n    // Expression to access flattened field. No need to escape dots.\n    return flatAccessWithDatum(field, opt.expr) + argAccessor;\n  } else {\n    // We flattened all fields so paths should have become dot.\n    return replacePathInField(field) + argAccessor;\n  }\n}\nexport function isDiscrete(def) {\n  switch (def.type) {\n    case 'nominal':\n    case 'ordinal':\n    case 'geojson':\n      return true;\n\n    case 'quantitative':\n      return isFieldDef(def) && !!def.bin;\n\n    case 'temporal':\n      return false;\n  }\n\n  throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isDiscretizing(def) {\n  var _a;\n\n  return isScaleFieldDef(def) && isContinuousToDiscrete((_a = def.scale) === null || _a === void 0 ? void 0 : _a.type);\n}\nexport function isCount(fieldDef) {\n  return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n  var _a;\n\n  var field = fieldDef.field,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit,\n      aggregate = fieldDef.aggregate;\n\n  if (aggregate === 'count') {\n    return config.countTitle;\n  } else if (isBinning(bin)) {\n    return \"\".concat(field, \" (binned)\");\n  } else if (timeUnit) {\n    var unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n\n    if (unit) {\n      return \"\".concat(field, \" (\").concat(getTimeUnitParts(unit).join('-'), \")\");\n    }\n  } else if (aggregate) {\n    if (isArgmaxDef(aggregate)) {\n      return \"\".concat(field, \" for max \").concat(aggregate.argmax);\n    } else if (isArgminDef(aggregate)) {\n      return \"\".concat(field, \" for min \").concat(aggregate.argmin);\n    } else {\n      return \"\".concat(titleCase(aggregate), \" of \").concat(field);\n    }\n  }\n\n  return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n  var aggregate = fieldDef.aggregate,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit,\n      field = fieldDef.field;\n\n  if (isArgmaxDef(aggregate)) {\n    return \"\".concat(field, \" for argmax(\").concat(aggregate.argmax, \")\");\n  } else if (isArgminDef(aggregate)) {\n    return \"\".concat(field, \" for argmin(\").concat(aggregate.argmin, \")\");\n  }\n\n  var timeUnitParams = normalizeTimeUnit(timeUnit);\n  var fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && 'timeunit' || isBinning(bin) && 'bin';\n\n  if (fn) {\n    return \"\".concat(fn.toUpperCase(), \"(\").concat(field, \")\");\n  } else {\n    return field;\n  }\n}\nexport var defaultTitleFormatter = function defaultTitleFormatter(fieldDef, config) {\n  switch (config.fieldTitle) {\n    case 'plain':\n      return fieldDef.field;\n\n    case 'functional':\n      return functionalTitleFormatter(fieldDef);\n\n    default:\n      return verbalTitleFormatter(fieldDef, config);\n  }\n};\nvar titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n  titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n  setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, _ref3) {\n  var allowDisabling = _ref3.allowDisabling,\n      _ref3$includeDefault = _ref3.includeDefault,\n      includeDefault = _ref3$includeDefault === void 0 ? true : _ref3$includeDefault;\n\n  var _a, _b;\n\n  var guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;\n\n  if (!isFieldDef(fieldOrDatumDef)) {\n    return guideTitle;\n  }\n\n  var fieldDef = fieldOrDatumDef;\n  var def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n\n  if (allowDisabling) {\n    return getFirstDefined(guideTitle, fieldDef.title, def);\n  } else {\n    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def;\n  }\n}\nexport function getGuide(fieldDef) {\n  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n    return fieldDef.axis;\n  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n    return fieldDef.legend;\n  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n    return fieldDef.header;\n  }\n\n  return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n  return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n  var _a;\n\n  if (isStringFieldOrDatumDef(fieldDef)) {\n    var format = fieldDef.format,\n        formatType = fieldDef.formatType;\n    return {\n      format: format,\n      formatType: formatType\n    };\n  } else {\n    var guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};\n    var _format = guide.format,\n        _formatType = guide.formatType;\n    return {\n      format: _format,\n      formatType: _formatType\n    };\n  }\n}\nexport function defaultType(fieldDef, channel) {\n  var _a;\n\n  switch (channel) {\n    case 'latitude':\n    case 'longitude':\n      return 'quantitative';\n\n    case 'row':\n    case 'column':\n    case 'facet':\n    case 'shape':\n    case 'strokeDash':\n      return 'nominal';\n\n    case 'order':\n      return 'ordinal';\n  }\n\n  if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n    return 'ordinal';\n  }\n\n  var aggregate = fieldDef.aggregate,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit;\n\n  if (timeUnit) {\n    return 'temporal';\n  }\n\n  if (bin || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    return 'quantitative';\n  }\n\n  if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {\n    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n      case 'numeric':\n      case 'discretizing':\n        return 'quantitative';\n\n      case 'time':\n        return 'temporal';\n    }\n  }\n\n  return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\n\nexport function getFieldDef(channelDef) {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n\n  return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n  if (isFieldOrDatumDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return channelDef.condition;\n  }\n\n  return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\n\nexport function initChannelDef(channelDef, channel, config) {\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n    var primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n    log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n    return {\n      value: channelDef\n    };\n  } // If a fieldDef contains a field, we need type.\n\n\n  if (isFieldOrDatumDef(channelDef)) {\n    return initFieldOrDatumDef(channelDef, channel, config, opt);\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return Object.assign(Object.assign({}, channelDef), {\n      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)\n    });\n  }\n\n  return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n  if (isStringFieldOrDatumDef(fd)) {\n    var format = fd.format,\n        formatType = fd.formatType,\n        rest = __rest(fd, [\"format\", \"formatType\"]);\n\n    if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n      log.warn(log.message.customFormatTypeNotAllowed(channel));\n      return initFieldOrDatumDef(rest, channel, config, opt);\n    }\n  } else {\n    var guideType = isPositionFieldOrDatumDef(fd) ? 'axis' : isMarkPropFieldOrDatumDef(fd) ? 'legend' : isFacetFieldDef(fd) ? 'header' : null;\n\n    if (guideType && fd[guideType]) {\n      var _a = fd[guideType],\n          _format2 = _a.format,\n          _formatType2 = _a.formatType,\n          newGuide = __rest(_a, [\"format\", \"formatType\"]);\n\n      if (isCustomFormatType(_formatType2) && !config.customFormatTypes) {\n        log.warn(log.message.customFormatTypeNotAllowed(channel));\n        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), _defineProperty({}, guideType, newGuide)), channel, config, opt);\n      }\n    }\n  }\n\n  if (isFieldDef(fd)) {\n    return initFieldDef(fd, channel, opt);\n  }\n\n  return initDatumDef(fd);\n}\n\nfunction initDatumDef(datumDef) {\n  var type = datumDef['type'];\n\n  if (type) {\n    return datumDef;\n  }\n\n  var datum = datumDef.datum;\n  type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n  return Object.assign(Object.assign({}, datumDef), {\n    type: type\n  });\n}\n\nexport function initFieldDef(fd, channel) {\n  var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref4$compositeMark = _ref4.compositeMark,\n      compositeMark = _ref4$compositeMark === void 0 ? false : _ref4$compositeMark;\n\n  var aggregate = fd.aggregate,\n      timeUnit = fd.timeUnit,\n      bin = fd.bin,\n      field = fd.field;\n  var fieldDef = Object.assign({}, fd); // Drop invalid aggregate\n\n  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    log.warn(log.message.invalidAggregate(aggregate));\n    delete fieldDef.aggregate;\n  } // Normalize Time Unit\n\n\n  if (timeUnit) {\n    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n  }\n\n  if (field) {\n    fieldDef.field = \"\".concat(field);\n  } // Normalize bin\n\n\n  if (isBinning(bin)) {\n    fieldDef.bin = normalizeBin(bin, channel);\n  }\n\n  if (isBinned(bin) && !isXorY(channel)) {\n    log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n  } // Normalize Type\n\n\n  if (isTypedFieldDef(fieldDef)) {\n    var type = fieldDef.type;\n    var fullType = getFullName(type);\n\n    if (type !== fullType) {\n      // convert short type to full type\n      fieldDef.type = fullType;\n    }\n\n    if (type !== 'quantitative') {\n      if (isCountingAggregateOp(aggregate)) {\n        log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n        fieldDef.type = 'quantitative';\n      }\n    }\n  } else if (!isSecondaryRangeChannel(channel)) {\n    // If type is empty / invalid, then augment with default type\n    var newType = defaultType(fieldDef, channel);\n    fieldDef['type'] = newType;\n  }\n\n  if (isTypedFieldDef(fieldDef)) {\n    var _ref5 = channelCompatibility(fieldDef, channel) || {},\n        compatible = _ref5.compatible,\n        warning = _ref5.warning;\n\n    if (compatible === false) {\n      log.warn(warning);\n    }\n  }\n\n  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n    var sort = fieldDef.sort;\n\n    if (isSortByChannel(sort)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sort\n        }\n      });\n    }\n\n    var sub = sort.substr(1);\n\n    if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sub,\n          order: 'descending'\n        }\n      });\n    }\n  }\n\n  if (isFacetFieldDef(fieldDef)) {\n    var header = fieldDef.header;\n\n    if (header) {\n      var orient = header.orient,\n          rest = __rest(header, [\"orient\"]);\n\n      if (orient) {\n        return Object.assign(Object.assign({}, fieldDef), {\n          header: Object.assign(Object.assign({}, rest), {\n            labelOrient: header.labelOrient || orient,\n            titleOrient: header.titleOrient || orient\n          })\n        });\n      }\n    }\n  }\n\n  return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n  if (isBoolean(bin)) {\n    return {\n      maxbins: autoMaxBins(channel)\n    };\n  } else if (bin === 'binned') {\n    return {\n      binned: true\n    };\n  } else if (!bin.maxbins && !bin.step) {\n    return Object.assign(Object.assign({}, bin), {\n      maxbins: autoMaxBins(channel)\n    });\n  } else {\n    return bin;\n  }\n}\nvar COMPATIBLE = {\n  compatible: true\n};\nexport function channelCompatibility(fieldDef, channel) {\n  var type = fieldDef.type;\n\n  if (type === 'geojson' && channel !== 'shape') {\n    return {\n      compatible: false,\n      warning: \"Channel \".concat(channel, \" should not be used with a geojson data.\")\n    };\n  }\n\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case FACET:\n      if (!isDiscrete(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscrete(channel)\n        };\n      }\n\n      return COMPATIBLE;\n\n    case X:\n    case Y:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case TEXT:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case ANGLE:\n    case THETA:\n    case RADIUS:\n    case DESCRIPTION:\n      return COMPATIBLE;\n\n    case LONGITUDE:\n    case LONGITUDE2:\n    case LATITUDE:\n    case LATITUDE2:\n      if (type !== QUANTITATIVE) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should be used with a quantitative field only, not \").concat(fieldDef.type, \" field.\")\n        };\n      }\n\n      return COMPATIBLE;\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    case SIZE:\n    case THETA2:\n    case RADIUS2:\n    case X2:\n    case Y2:\n      if (type === 'nominal' && !fieldDef['sort']) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should not be used with an unsorted discrete field.\")\n        };\n      }\n\n      return COMPATIBLE;\n\n    case SHAPE:\n    case STROKEDASH:\n      if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscreteOrDiscretizing(channel)\n        };\n      }\n\n      return COMPATIBLE;\n\n    case ORDER:\n      if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n        return {\n          compatible: false,\n          warning: \"Channel order is inappropriate for nominal field, which has no inherent order.\"\n        };\n      }\n\n      return COMPATIBLE;\n  }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\n\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n  var _getFormatMixins = getFormatMixins(fieldOrDatumDef),\n      formatType = _getFormatMixins.formatType;\n\n  return formatType === 'time' || !formatType && isTimeFieldDef(fieldOrDatumDef);\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\n\nexport function isTimeFieldDef(def) {\n  return def && (def['type'] === 'temporal' || isFieldDef(def) && !!def.timeUnit);\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\n\nexport function valueExpr(v, _ref6) {\n  var timeUnit = _ref6.timeUnit,\n      type = _ref6.type,\n      wrapTime = _ref6.wrapTime,\n      undefinedIfExprNotRequired = _ref6.undefinedIfExprNotRequired;\n\n  var _a;\n\n  var unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);\n  var isTime = unit || type === 'temporal';\n  var expr;\n\n  if (isExprRef(v)) {\n    expr = v.expr;\n  } else if (isSignalRef(v)) {\n    expr = v.signal;\n  } else if (isDateTime(v)) {\n    isTime = true;\n    expr = dateTimeToExpr(v);\n  } else if (isString(v) || isNumber(v)) {\n    if (isTime) {\n      expr = \"datetime(\".concat(stringify(v), \")\");\n\n      if (isLocalSingleTimeUnit(unit)) {\n        // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n        if (isNumber(v) && v < 10000 || isString(v) && isNaN(Date.parse(v))) {\n          expr = dateTimeToExpr(_defineProperty({}, unit, v));\n        }\n      }\n    }\n  }\n\n  if (expr) {\n    return wrapTime && isTime ? \"time(\".concat(expr, \")\") : expr;\n  } // number or boolean or normal string\n\n\n  return undefinedIfExprNotRequired ? undefined : stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\n\nexport function valueArray(fieldOrDatumDef, values) {\n  var type = fieldOrDatumDef.type;\n  return values.map(function (v) {\n    var expr = valueExpr(v, {\n      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : undefined,\n      type: type,\n      undefinedIfExprNotRequired: true\n    }); // return signal for the expression if we need an expression\n\n    if (expr !== undefined) {\n      return {\n        signal: expr\n      };\n    } // otherwise just return the original value\n\n\n    return v;\n  });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\n\nexport function binRequiresRange(fieldDef, channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only call this method for binned field defs.');\n    return false;\n  } // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n\n\n  return isScaleChannel(channel) && ['ordinal', 'nominal'].includes(fieldDef.type);\n}","map":{"version":3,"sources":["../../src/channeldef.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, getSizeChannel, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, Y, Y2 } from './channel';\nimport { getMarkConfig, getMarkPropOrConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { hasDiscreteDomain, isContinuousToDiscrete, SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, stringify, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalParameter(c) {\n    return c['param'];\n}\nexport function isRepeatRef(field) {\n    return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n    const { field, timeUnit, bin, aggregate } = fieldDef;\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, (timeUnit ? { timeUnit } : {})), (bin ? { bin } : {})), (aggregate ? { aggregate } : {})), { field });\n}\nexport function isSortableFieldDef(fieldDef) {\n    return 'sort' in fieldDef;\n}\nexport function getBandPosition({ fieldDef, fieldDef2, markDef: mark, config }) {\n    if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== undefined) {\n        return fieldDef.bandPosition;\n    }\n    if (isFieldDef(fieldDef)) {\n        const { timeUnit, bin } = fieldDef;\n        if (timeUnit && !fieldDef2) {\n            return isRectBasedMark(mark.type) ? 0 : getMarkConfig('timeUnitBandPosition', mark, config);\n        }\n        else if (isBinning(bin)) {\n            return 0.5;\n        }\n    }\n    return undefined;\n}\nexport function getBandSize({ channel, fieldDef, fieldDef2, markDef: mark, config, scaleType, useVlSizeChannel }) {\n    var _a, _b, _c;\n    const sizeChannel = getSizeChannel(channel);\n    const size = getMarkPropOrConfig(useVlSizeChannel ? 'size' : sizeChannel, mark, config, {\n        vgChannel: sizeChannel\n    });\n    if (size !== undefined) {\n        return size;\n    }\n    if (isFieldDef(fieldDef)) {\n        const { timeUnit, bin } = fieldDef;\n        if (timeUnit && !fieldDef2) {\n            return { band: getMarkConfig('timeUnitBandSize', mark, config) };\n        }\n        else if (isBinning(bin) && !hasDiscreteDomain(scaleType)) {\n            return { band: 1 };\n        }\n    }\n    if (isRectBasedMark(mark.type)) {\n        if (scaleType) {\n            if (hasDiscreteDomain(scaleType)) {\n                return ((_a = config[mark.type]) === null || _a === void 0 ? void 0 : _a.discreteBandSize) || { band: 1 };\n            }\n            else {\n                return (_b = config[mark.type]) === null || _b === void 0 ? void 0 : _b.continuousBandSize;\n            }\n        }\n        return (_c = config[mark.type]) === null || _c === void 0 ? void 0 : _c.discreteBandSize;\n    }\n    return undefined;\n}\nexport function hasBandEnd(fieldDef, fieldDef2, markDef, config) {\n    if (isBinning(fieldDef.bin) || (fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal')) {\n        // Need to check bandPosition because non-rect marks (e.g., point) with timeUnit\n        // doesn't have to use bandEnd if there is no bandPosition.\n        return getBandPosition({ fieldDef, fieldDef2, markDef, config }) !== undefined;\n    }\n    return false;\n}\nexport function isConditionalDef(channelDef) {\n    return channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nexport function hasConditionalFieldDef(channelDef) {\n    const condition = channelDef && channelDef['condition'];\n    return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n    const condition = channelDef && channelDef['condition'];\n    return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n    const condition = channelDef && channelDef['condition'];\n    return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n    // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n    return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n    return channelDef && channelDef['type'];\n}\nexport function isDatumDef(channelDef) {\n    return channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n    // TODO: make datum support DateTime object\n    return (isTypedFieldDef(cd) && !isDiscrete(cd)) || isNumericDataDef(cd);\n}\nexport function isQuantitativeFieldOrDatumDef(cd) {\n    // TODO: make datum support DateTime object\n    return channelDefType(cd) === 'quantitative' || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n    return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n    return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n    return channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n    return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n    return channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n    return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n    return channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n    return channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n    // omit properties that don't exist in string field defs\n    return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\nfunction isOpFieldDef(fieldDef) {\n    return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\nexport function vgField(fieldDef, opt = {}) {\n    var _a, _b, _c;\n    let field = fieldDef.field;\n    const prefix = opt.prefix;\n    let suffix = opt.suffix;\n    let argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n    if (isCount(fieldDef)) {\n        field = internalField('count');\n    }\n    else {\n        let fn;\n        if (!opt.nofn) {\n            if (isOpFieldDef(fieldDef)) {\n                fn = fieldDef.op;\n            }\n            else {\n                const { bin, aggregate, timeUnit } = fieldDef;\n                if (isBinning(bin)) {\n                    fn = binToString(bin);\n                    suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : '') + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : '');\n                }\n                else if (aggregate) {\n                    if (isArgmaxDef(aggregate)) {\n                        argAccessor = `[\"${field}\"]`;\n                        field = `argmax_${aggregate.argmax}`;\n                    }\n                    else if (isArgminDef(aggregate)) {\n                        argAccessor = `[\"${field}\"]`;\n                        field = `argmin_${aggregate.argmin}`;\n                    }\n                    else {\n                        fn = String(aggregate);\n                    }\n                }\n                else if (timeUnit) {\n                    fn = timeUnitToString(timeUnit);\n                    suffix = ((!['range', 'mid'].includes(opt.binSuffix) && opt.binSuffix) || '') + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : '');\n                }\n            }\n        }\n        if (fn) {\n            field = field ? `${fn}_${field}` : fn;\n        }\n    }\n    if (suffix) {\n        field = `${field}_${suffix}`;\n    }\n    if (prefix) {\n        field = `${prefix}_${field}`;\n    }\n    if (opt.forAs) {\n        return removePathFromField(field);\n    }\n    else if (opt.expr) {\n        // Expression to access flattened field. No need to escape dots.\n        return flatAccessWithDatum(field, opt.expr) + argAccessor;\n    }\n    else {\n        // We flattened all fields so paths should have become dot.\n        return replacePathInField(field) + argAccessor;\n    }\n}\nexport function isDiscrete(def) {\n    switch (def.type) {\n        case 'nominal':\n        case 'ordinal':\n        case 'geojson':\n            return true;\n        case 'quantitative':\n            return isFieldDef(def) && !!def.bin;\n        case 'temporal':\n            return false;\n    }\n    throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isDiscretizing(def) {\n    var _a;\n    return isScaleFieldDef(def) && isContinuousToDiscrete((_a = def.scale) === null || _a === void 0 ? void 0 : _a.type);\n}\nexport function isCount(fieldDef) {\n    return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n    var _a;\n    const { field, bin, timeUnit, aggregate } = fieldDef;\n    if (aggregate === 'count') {\n        return config.countTitle;\n    }\n    else if (isBinning(bin)) {\n        return `${field} (binned)`;\n    }\n    else if (timeUnit) {\n        const unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n        if (unit) {\n            return `${field} (${getTimeUnitParts(unit).join('-')})`;\n        }\n    }\n    else if (aggregate) {\n        if (isArgmaxDef(aggregate)) {\n            return `${field} for max ${aggregate.argmax}`;\n        }\n        else if (isArgminDef(aggregate)) {\n            return `${field} for min ${aggregate.argmin}`;\n        }\n        else {\n            return `${titleCase(aggregate)} of ${field}`;\n        }\n    }\n    return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n    const { aggregate, bin, timeUnit, field } = fieldDef;\n    if (isArgmaxDef(aggregate)) {\n        return `${field} for argmax(${aggregate.argmax})`;\n    }\n    else if (isArgminDef(aggregate)) {\n        return `${field} for argmin(${aggregate.argmin})`;\n    }\n    const timeUnitParams = normalizeTimeUnit(timeUnit);\n    const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || ((timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && 'timeunit') || (isBinning(bin) && 'bin');\n    if (fn) {\n        return `${fn.toUpperCase()}(${field})`;\n    }\n    else {\n        return field;\n    }\n}\nexport const defaultTitleFormatter = (fieldDef, config) => {\n    switch (config.fieldTitle) {\n        case 'plain':\n            return fieldDef.field;\n        case 'functional':\n            return functionalTitleFormatter(fieldDef);\n        default:\n            return verbalTitleFormatter(fieldDef, config);\n    }\n};\nlet titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n    titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n    setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {\n    var _a, _b;\n    const guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;\n    if (!isFieldDef(fieldOrDatumDef)) {\n        return guideTitle;\n    }\n    const fieldDef = fieldOrDatumDef;\n    const def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n    if (allowDisabling) {\n        return getFirstDefined(guideTitle, fieldDef.title, def);\n    }\n    else {\n        return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def;\n    }\n}\nexport function getGuide(fieldDef) {\n    if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n        return fieldDef.axis;\n    }\n    else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n        return fieldDef.legend;\n    }\n    else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n        return fieldDef.header;\n    }\n    return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n    return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n    var _a;\n    if (isStringFieldOrDatumDef(fieldDef)) {\n        const { format, formatType } = fieldDef;\n        return { format, formatType };\n    }\n    else {\n        const guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};\n        const { format, formatType } = guide;\n        return { format, formatType };\n    }\n}\nexport function defaultType(fieldDef, channel) {\n    var _a;\n    switch (channel) {\n        case 'latitude':\n        case 'longitude':\n            return 'quantitative';\n        case 'row':\n        case 'column':\n        case 'facet':\n        case 'shape':\n        case 'strokeDash':\n            return 'nominal';\n        case 'order':\n            return 'ordinal';\n    }\n    if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n        return 'ordinal';\n    }\n    const { aggregate, bin, timeUnit } = fieldDef;\n    if (timeUnit) {\n        return 'temporal';\n    }\n    if (bin || (aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate))) {\n        return 'quantitative';\n    }\n    if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {\n        switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n            case 'numeric':\n            case 'discretizing':\n                return 'quantitative';\n            case 'time':\n                return 'temporal';\n        }\n    }\n    return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nexport function getFieldDef(channelDef) {\n    if (isFieldDef(channelDef)) {\n        return channelDef;\n    }\n    else if (hasConditionalFieldDef(channelDef)) {\n        return channelDef.condition;\n    }\n    return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n    if (isFieldOrDatumDef(channelDef)) {\n        return channelDef;\n    }\n    else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        return channelDef.condition;\n    }\n    return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function initChannelDef(channelDef, channel, config, opt = {}) {\n    if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n        const primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n        log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n        return { value: channelDef };\n    }\n    // If a fieldDef contains a field, we need type.\n    if (isFieldOrDatumDef(channelDef)) {\n        return initFieldOrDatumDef(channelDef, channel, config, opt);\n    }\n    else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        return Object.assign(Object.assign({}, channelDef), { \n            // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n            condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt) });\n    }\n    return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n    if (isStringFieldOrDatumDef(fd)) {\n        const { format, formatType } = fd, rest = __rest(fd, [\"format\", \"formatType\"]);\n        if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n            log.warn(log.message.customFormatTypeNotAllowed(channel));\n            return initFieldOrDatumDef(rest, channel, config, opt);\n        }\n    }\n    else {\n        const guideType = isPositionFieldOrDatumDef(fd)\n            ? 'axis'\n            : isMarkPropFieldOrDatumDef(fd)\n                ? 'legend'\n                : isFacetFieldDef(fd)\n                    ? 'header'\n                    : null;\n        if (guideType && fd[guideType]) {\n            const _a = fd[guideType], { format, formatType } = _a, newGuide = __rest(_a, [\"format\", \"formatType\"]);\n            if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n                log.warn(log.message.customFormatTypeNotAllowed(channel));\n                return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), { [guideType]: newGuide }), channel, config, opt);\n            }\n        }\n    }\n    if (isFieldDef(fd)) {\n        return initFieldDef(fd, channel, opt);\n    }\n    return initDatumDef(fd);\n}\nfunction initDatumDef(datumDef) {\n    let type = datumDef['type'];\n    if (type) {\n        return datumDef;\n    }\n    const { datum } = datumDef;\n    type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n    return Object.assign(Object.assign({}, datumDef), { type });\n}\nexport function initFieldDef(fd, channel, { compositeMark = false } = {}) {\n    const { aggregate, timeUnit, bin, field } = fd;\n    const fieldDef = Object.assign({}, fd);\n    // Drop invalid aggregate\n    if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n        log.warn(log.message.invalidAggregate(aggregate));\n        delete fieldDef.aggregate;\n    }\n    // Normalize Time Unit\n    if (timeUnit) {\n        fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n    }\n    if (field) {\n        fieldDef.field = `${field}`;\n    }\n    // Normalize bin\n    if (isBinning(bin)) {\n        fieldDef.bin = normalizeBin(bin, channel);\n    }\n    if (isBinned(bin) && !isXorY(channel)) {\n        log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n    }\n    // Normalize Type\n    if (isTypedFieldDef(fieldDef)) {\n        const { type } = fieldDef;\n        const fullType = getFullName(type);\n        if (type !== fullType) {\n            // convert short type to full type\n            fieldDef.type = fullType;\n        }\n        if (type !== 'quantitative') {\n            if (isCountingAggregateOp(aggregate)) {\n                log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n                fieldDef.type = 'quantitative';\n            }\n        }\n    }\n    else if (!isSecondaryRangeChannel(channel)) {\n        // If type is empty / invalid, then augment with default type\n        const newType = defaultType(fieldDef, channel);\n        fieldDef['type'] = newType;\n    }\n    if (isTypedFieldDef(fieldDef)) {\n        const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};\n        if (compatible === false) {\n            log.warn(warning);\n        }\n    }\n    if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n        const { sort } = fieldDef;\n        if (isSortByChannel(sort)) {\n            return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sort } });\n        }\n        const sub = sort.substr(1);\n        if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n            return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sub, order: 'descending' } });\n        }\n    }\n    if (isFacetFieldDef(fieldDef)) {\n        const { header } = fieldDef;\n        if (header) {\n            const { orient } = header, rest = __rest(header, [\"orient\"]);\n            if (orient) {\n                return Object.assign(Object.assign({}, fieldDef), { header: Object.assign(Object.assign({}, rest), { labelOrient: header.labelOrient || orient, titleOrient: header.titleOrient || orient }) });\n            }\n        }\n    }\n    return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n    if (isBoolean(bin)) {\n        return { maxbins: autoMaxBins(channel) };\n    }\n    else if (bin === 'binned') {\n        return {\n            binned: true\n        };\n    }\n    else if (!bin.maxbins && !bin.step) {\n        return Object.assign(Object.assign({}, bin), { maxbins: autoMaxBins(channel) });\n    }\n    else {\n        return bin;\n    }\n}\nconst COMPATIBLE = { compatible: true };\nexport function channelCompatibility(fieldDef, channel) {\n    const type = fieldDef.type;\n    if (type === 'geojson' && channel !== 'shape') {\n        return {\n            compatible: false,\n            warning: `Channel ${channel} should not be used with a geojson data.`\n        };\n    }\n    switch (channel) {\n        case ROW:\n        case COLUMN:\n        case FACET:\n            if (!isDiscrete(fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: log.message.channelShouldBeDiscrete(channel)\n                };\n            }\n            return COMPATIBLE;\n        case X:\n        case Y:\n        case COLOR:\n        case FILL:\n        case STROKE:\n        case TEXT:\n        case DETAIL:\n        case KEY:\n        case TOOLTIP:\n        case HREF:\n        case URL:\n        case ANGLE:\n        case THETA:\n        case RADIUS:\n        case DESCRIPTION:\n            return COMPATIBLE;\n        case LONGITUDE:\n        case LONGITUDE2:\n        case LATITUDE:\n        case LATITUDE2:\n            if (type !== QUANTITATIVE) {\n                return {\n                    compatible: false,\n                    warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`\n                };\n            }\n            return COMPATIBLE;\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        case STROKEWIDTH:\n        case SIZE:\n        case THETA2:\n        case RADIUS2:\n        case X2:\n        case Y2:\n            if (type === 'nominal' && !fieldDef['sort']) {\n                return {\n                    compatible: false,\n                    warning: `Channel ${channel} should not be used with an unsorted discrete field.`\n                };\n            }\n            return COMPATIBLE;\n        case SHAPE:\n        case STROKEDASH:\n            if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: log.message.channelShouldBeDiscreteOrDiscretizing(channel)\n                };\n            }\n            return COMPATIBLE;\n        case ORDER:\n            if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n                };\n            }\n            return COMPATIBLE;\n    }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n    const { formatType } = getFormatMixins(fieldOrDatumDef);\n    return formatType === 'time' || (!formatType && isTimeFieldDef(fieldOrDatumDef));\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\nexport function isTimeFieldDef(def) {\n    return def && (def['type'] === 'temporal' || (isFieldDef(def) && !!def.timeUnit));\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\nexport function valueExpr(v, { timeUnit, type, wrapTime, undefinedIfExprNotRequired }) {\n    var _a;\n    const unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);\n    let isTime = unit || type === 'temporal';\n    let expr;\n    if (isExprRef(v)) {\n        expr = v.expr;\n    }\n    else if (isSignalRef(v)) {\n        expr = v.signal;\n    }\n    else if (isDateTime(v)) {\n        isTime = true;\n        expr = dateTimeToExpr(v);\n    }\n    else if (isString(v) || isNumber(v)) {\n        if (isTime) {\n            expr = `datetime(${stringify(v)})`;\n            if (isLocalSingleTimeUnit(unit)) {\n                // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n                if ((isNumber(v) && v < 10000) || (isString(v) && isNaN(Date.parse(v)))) {\n                    expr = dateTimeToExpr({ [unit]: v });\n                }\n            }\n        }\n    }\n    if (expr) {\n        return wrapTime && isTime ? `time(${expr})` : expr;\n    }\n    // number or boolean or normal string\n    return undefinedIfExprNotRequired ? undefined : stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\nexport function valueArray(fieldOrDatumDef, values) {\n    const { type } = fieldOrDatumDef;\n    return values.map(v => {\n        const expr = valueExpr(v, {\n            timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : undefined,\n            type,\n            undefinedIfExprNotRequired: true\n        });\n        // return signal for the expression if we need an expression\n        if (expr !== undefined) {\n            return { signal: expr };\n        }\n        // otherwise just return the original value\n        return v;\n    });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef, channel) {\n    if (!isBinning(fieldDef.bin)) {\n        console.warn('Only call this method for binned field defs.');\n        return false;\n    }\n    // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n    // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n    return isScaleChannel(channel) && ['ordinal', 'nominal'].includes(fieldDef.type);\n}\n//# sourceMappingURL=channeldef.js.map"]},"metadata":{},"sourceType":"module"}