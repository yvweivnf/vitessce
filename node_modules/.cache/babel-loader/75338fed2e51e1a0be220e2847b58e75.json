{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { canvas } from 'vega-canvas';\nimport { rederive, Transform } from 'vega-dataflow';\nimport { Marks, textMetrics } from 'vega-scenegraph';\nimport { inherits, isFunction, error, array } from 'vega-util';\nvar ALPHA_MASK = 0xff000000; // alpha value equivalent to opacity 0.0625\n\nvar INSIDE_OPACITY_IN_ALPHA = 0x10000000;\nvar INSIDE_OPACITY = 0.0625;\n\nfunction baseBitmaps($, data) {\n  var bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\n\n  (data || []).forEach(function (d) {\n    return bitmap.set($(d.boundary[0]), $(d.boundary[3]));\n  });\n  return [bitmap, undefined];\n}\n\nfunction markBitmaps($, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  var width = $.width,\n      height = $.height,\n      border = labelInside || isGroupArea,\n      context = canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\n\n  avoidMarks.forEach(function (items) {\n    return draw(context, items, border);\n  }); // get canvas buffer, create bitmaps\n\n  var buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),\n      layer1 = $.bitmap(),\n      layer2 = border && $.bitmap(); // populate bitmap layers\n\n  var x, y, u, v, alpha;\n\n  for (y = 0; y < height; ++y) {\n    for (x = 0; x < width; ++x) {\n      alpha = buffer[y * width + x] & ALPHA_MASK;\n\n      if (alpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea) layer1.set(u, v); // update interior bitmap\n\n        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  var type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(function (group) {\n      group.items.forEach(function (mark) {\n        return draw(context, mark.items, interior);\n      });\n    });\n  } else {\n    Marks[type].draw(context, {\n      items: interior ? items.map(prepare) : items\n    });\n  }\n}\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\n\n\nfunction prepare(source) {\n  var item = rederive(source, {});\n\n  if (item.stroke) {\n    item.strokeOpacity = 1;\n  }\n\n  if (item.fill) {\n    item.fillOpacity = INSIDE_OPACITY;\n    item.stroke = '#000';\n    item.strokeOpacity = 1;\n    item.strokeWidth = 2;\n  }\n\n  return item;\n}\n\nvar DIV = 5,\n    // bit shift from x, y index to bit vector array index\nMOD = 31,\n    // bit mask for index lookup within a bit vector\nSIZE = 32,\n    // individual bit vector size\nRIGHT0 = new Uint32Array(SIZE + 1),\n    // left-anchored bit vectors, full -> 0\nRIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\n\nfor (var i = 1; i <= SIZE; ++i) {\n  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nfunction Bitmap(w, h) {\n  var array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n    get: function get(x, y) {\n      var index = y * w + x;\n      return array[index >>> DIV] & 1 << (index & MOD);\n    },\n    set: function set(x, y) {\n      var index = y * w + x;\n\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n    clear: function clear(x, y) {\n      var index = y * w + x;\n\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n    getRange: function getRange(x, y, x2, y2) {\n      var r = y2,\n          start,\n          end,\n          indexStart,\n          indexEnd;\n\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n\n          for (var _i = indexStart + 1; _i < indexEnd; ++_i) {\n            if (array[_i]) return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    setRange: function setRange(x, y, x2, y2) {\n      var start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) {\n            _set(i, 0xffffffff);\n          }\n        }\n      }\n    },\n    clearRange: function clearRange(x, y, x2, y2) {\n      var start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) {\n            _clear(i, 0);\n          }\n        }\n      }\n    },\n    outOfBounds: function outOfBounds(x, y, x2, y2) {\n      return x < 0 || y < 0 || y2 >= h || x2 >= w;\n    }\n  };\n}\n\nfunction scaler(width, height, padding) {\n  var ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\n      w = ~~((width + 2 * padding + ratio) / ratio),\n      h = ~~((height + 2 * padding + ratio) / ratio),\n      scale = function scale(_) {\n    return ~~((_ + padding) / ratio);\n  };\n\n  scale.invert = function (_) {\n    return _ * ratio - padding;\n  };\n\n  scale.bitmap = function () {\n    return Bitmap(w, h);\n  };\n\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n  return scale;\n}\n\nfunction placeAreaLabelNaive($, bitmaps, avoidBaseMark, markIndex) {\n  var width = $.width,\n      height = $.height; // try to place a label within an input area mark\n\n  return function (d) {\n    var items = d.datum.datum.items[markIndex].items,\n        // area points\n    n = items.length,\n        // number of points\n    textHeight = d.datum.fontSize,\n        // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    var maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        areaWidth; // for each area sample point\n\n    for (var _i2 = 0; _i2 < n; ++_i2) {\n      x1 = items[_i2].x;\n      y1 = items[_i2].y;\n      x2 = items[_i2].x2 === undefined ? x1 : items[_i2].x2;\n      y2 = items[_i2].y2 === undefined ? y1 : items[_i2].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n    d.align = 'center';\n\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n\nfunction outOfBounds(x, y, textWidth, textHeight, width, height) {\n  var r = textWidth / 2;\n  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\n}\n\nfunction _outOfBounds() {\n  return false;\n}\n\nfunction collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  var w = textWidth * h / (textHeight * 2),\n      x1 = $(x - w),\n      x2 = $(x + w),\n      y1 = $(y - (h = h / 2)),\n      y2 = $(y + h);\n  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\n\nfunction _collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  var w = textWidth * h / (textHeight * 2);\n  var x1 = $(x - w),\n      x2 = $(x + w),\n      y1 = $(y - (h = h / 2)),\n      y2 = $(y + h);\n  x1 = x1 > 0 ? x1 : 0;\n  y1 = y1 > 0 ? y1 : 0;\n  x2 = x2 < $.width ? x2 : $.width - 1;\n  y2 = y2 < $.height ? y2 : $.height - 1;\n  return bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\n\nfunction getTests(infPadding) {\n  return infPadding ? [_collision, _outOfBounds] : [collision, outOfBounds];\n}\n\nfunction placeAreaLabelReducedSearch($, bitmaps, avoidBaseMark, markIndex, infPadding) {\n  var width = $.width,\n      height = $.height,\n      _getTests = getTests(infPadding),\n      _getTests2 = _slicedToArray(_getTests, 2),\n      collision = _getTests2[0],\n      outOfBounds = _getTests2[1],\n      bm0 = bitmaps[0],\n      bm1 = bitmaps[1]; // area outlines\n\n\n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    var x = $.invert(_x),\n        y = $.invert(_y);\n    var lo = maxSize,\n        hi = height,\n        mid;\n\n    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      } // place label if current lower bound exceeds prior max font size\n\n\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  } // try to place a label within an input area mark\n\n\n  return function (d) {\n    var items = d.datum.datum.items[markIndex].items,\n        // area points\n    n = items.length,\n        // number of points\n    textHeight = d.datum.fontSize,\n        // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    var maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        _x1,\n        _xMid,\n        _x2,\n        _y1,\n        _yMid,\n        _y2,\n        areaWidth,\n        result,\n        swapTmp; // for each area sample point\n\n\n    for (var _i3 = 0; _i3 < n; ++_i3) {\n      x1 = items[_i3].x;\n      y1 = items[_i3].y;\n      x2 = items[_i3].x2 === undefined ? x1 : items[_i3].x2;\n      y2 = items[_i3].y2 === undefined ? y1 : items[_i3].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\n\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            var _result = result;\n\n            var _result2 = _slicedToArray(_result, 4);\n\n            d.x = _result2[0];\n            d.y = _result2[1];\n            maxSize = _result2[2];\n            labelPlaced = _result2[3];\n          }\n        }\n      } // search along the line from mid point between the 2 border to upper border\n\n\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            var _result3 = result;\n\n            var _result4 = _slicedToArray(_result3, 4);\n\n            d.x = _result4[0];\n            d.y = _result4[1];\n            maxSize = _result4[2];\n            labelPlaced = _result4[3];\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nvar X_DIR = [-1, -1, 1, 1];\nvar Y_DIR = [-1, 1, -1, 1];\n\nfunction placeAreaLabelFloodFill($, bitmaps, avoidBaseMark, markIndex, infPadding) {\n  var width = $.width,\n      height = $.height,\n      _getTests3 = getTests(infPadding),\n      _getTests4 = _slicedToArray(_getTests3, 2),\n      collision = _getTests4[0],\n      outOfBounds = _getTests4[1],\n      bm0 = bitmaps[0],\n      bm1 = bitmaps[1],\n      bm2 = $.bitmap(); // flood-fill visitations\n  // try to place a label within an input area mark\n\n\n  return function (d) {\n    var items = d.datum.datum.items[markIndex].items,\n        // area points\n    n = items.length,\n        // number of points\n    textHeight = d.datum.fontSize,\n        // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text),\n        // label height\n    stack = []; // flood fill stack\n\n    var maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        lo,\n        hi,\n        mid,\n        areaWidth; // for each area sample point\n\n\n    for (var _i4 = 0; _i4 < n; ++_i4) {\n      x1 = items[_i4].x;\n      y1 = items[_i4].y;\n      x2 = items[_i4].x2 === undefined ? x1 : items[_i4].x2;\n      y2 = items[_i4].y2 === undefined ? y1 : items[_i4].y2; // add scaled center point to stack\n\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\n\n      while (stack.length) {\n        var _stack$pop = stack.pop();\n\n        var _stack$pop2 = _slicedToArray(_stack$pop, 2);\n\n        _x = _stack$pop2[0];\n        _y = _stack$pop2[1];\n        // exit if point already marked\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n\n        bm2.set(_x, _y);\n\n        for (var j = 0; j < 4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        } // unscale point back to x, y space\n\n\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          } // place label if current lower bound exceeds prior max font size\n\n\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nvar Aligns = ['right', 'center', 'left'],\n    Baselines = ['bottom', 'middle', 'top'];\n\nfunction placeMarkLabel($, bitmaps, anchors, offsets, infPadding) {\n  var width = $.width,\n      height = $.height,\n      bm0 = bitmaps[0],\n      bm1 = bitmaps[1],\n      n = offsets.length;\n  return function (d) {\n    var boundary = d.boundary,\n        textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\n\n    if (!infPadding && (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height)) {\n      return false;\n    }\n\n    var textWidth = 0,\n        dx,\n        dy,\n        isInside,\n        sizeFactor,\n        insideFactor,\n        x1,\n        x2,\n        y1,\n        y2,\n        xc,\n        yc,\n        _x1,\n        _x2,\n        _y1,\n        _y2; // for each anchor and offset\n\n\n    for (var _i5 = 0; _i5 < n; ++_i5) {\n      dx = (anchors[_i5] & 0x3) - 1;\n      dy = (anchors[_i5] >>> 0x2 & 0x3) - 1;\n      isInside = dx === 0 && dy === 0 || offsets[_i5] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[_i5] < 0 ? -1 : 1;\n      x1 = boundary[1 + dx] + offsets[_i5] * dx * sizeFactor;\n      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[_i5] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (infPadding) {\n        _x1 = _x1 < 0 ? 0 : _x1;\n        _y1 = _y1 < 0 ? 0 : _y1;\n        _y2 = _y2 >= $.height ? $.height - 1 : _y2;\n      }\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + insideFactor * textWidth * dx / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (infPadding) {\n        _x1 = _x1 < 0 ? 0 : _x1;\n        _x2 = _x2 >= $.width ? $.width - 1 : _x2;\n      }\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n} // Test if a label with the given dimensions can be added without overlap\n\n\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));\n}\n\nfunction isInMarkBound(x1, y1, x2, y2, boundary) {\n  return boundary[0] <= x1 && x2 <= boundary[2] && boundary[3] <= y1 && y2 <= boundary[5];\n}\n\nvar TOP = 0x0,\n    MIDDLE = 0x4,\n    BOTTOM = 0x8,\n    LEFT = 0x0,\n    CENTER = 0x1,\n    RIGHT = 0x2; // Mapping from text anchor to number representation\n\nvar anchorCode = {\n  'top-left': TOP + LEFT,\n  'top': TOP + CENTER,\n  'top-right': TOP + RIGHT,\n  'left': MIDDLE + LEFT,\n  'middle': MIDDLE + CENTER,\n  'right': MIDDLE + RIGHT,\n  'bottom-left': BOTTOM + LEFT,\n  'bottom': BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\nvar placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\n\nfunction labelLayout(texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\n  // early exit for empty data\n  if (!texts.length) return texts;\n  var positions = Math.max(offset.length, anchor.length),\n      offsets = getOffsets(offset, positions),\n      anchors = getAnchors(anchor, positions),\n      marktype = markType(texts[0].datum),\n      grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n      isGroupArea = grouptype === 'area',\n      boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n      infPadding = padding === null || padding === Infinity,\n      $ = scaler(size[0], size[1], infPadding ? 0 : padding),\n      isNaiveGroupArea = isGroupArea && method === 'naive'; // prepare text mark data for placing\n\n  var data = texts.map(function (d) {\n    return {\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d)\n    };\n  });\n  var bitmaps;\n\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort(function (a, b) {\n        return compare(a.datum, b.datum);\n      });\n    } // flag indicating if label can be placed inside its base mark\n\n\n    var labelInside = false;\n\n    for (var _i6 = 0; _i6 < anchors.length && !labelInside; ++_i6) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[_i6] === 0x5 || offsets[_i6] < 0;\n    } // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n\n\n    if (marktype && (avoidBaseMark || isGroupArea)) {\n      avoidMarks = [texts.map(function (d) {\n        return d.datum;\n      })].concat(avoidMarks);\n    } // generate bitmaps for layout calculation\n\n\n    bitmaps = avoidMarks.length ? markBitmaps($, avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\n  } // generate label placement function\n\n\n  var place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex, infPadding) : placeMarkLabel($, bitmaps, anchors, offsets, infPadding); // place all labels\n\n  data.forEach(function (d) {\n    return d.opacity = +place(d);\n  });\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  var offsets = new Float64Array(count),\n      n = _.length;\n\n  for (var _i7 = 0; _i7 < n; ++_i7) {\n    offsets[_i7] = _[_i7] || 0;\n  }\n\n  for (var _i8 = n; _i8 < count; ++_i8) {\n    offsets[_i8] = offsets[n - 1];\n  }\n\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  var anchors = new Int8Array(count),\n      n = _.length;\n\n  for (var _i9 = 0; _i9 < n; ++_i9) {\n    anchors[_i9] |= anchorCode[_[_i9]];\n  }\n\n  for (var _i10 = n; _i10 < count; ++_i10) {\n    anchors[_i10] = anchors[n - 1];\n  }\n\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the beginning or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\n\n\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  var xy = function xy(d) {\n    return [d.x, d.x, d.x, d.y, d.y, d.y];\n  };\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  } else if (marktype === 'line' || marktype === 'area') {\n    return function (d) {\n      return xy(d.datum);\n    };\n  } else if (grouptype === 'line') {\n    return function (d) {\n      var items = d.datum.items[markIndex].items;\n      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\n        x: NaN,\n        y: NaN\n      });\n    };\n  } else {\n    return function (d) {\n      var b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n\nvar Output = ['x', 'y', 'opacity', 'align', 'baseline'];\nvar Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\n\nfunction Label(params) {\n  Transform.call(this, null, params);\n}\n\nLabel.Definition = {\n  type: 'Label',\n  metadata: {\n    modifies: true\n  },\n  params: [{\n    name: 'size',\n    type: 'number',\n    array: true,\n    length: 2,\n    required: true\n  }, {\n    name: 'sort',\n    type: 'compare'\n  }, {\n    name: 'anchor',\n    type: 'string',\n    array: true,\n    default: Anchors\n  }, {\n    name: 'offset',\n    type: 'number',\n    array: true,\n    default: [1]\n  }, {\n    name: 'padding',\n    type: 'number',\n    default: 0,\n    null: true\n  }, {\n    name: 'lineAnchor',\n    type: 'string',\n    values: ['start', 'end'],\n    default: 'end'\n  }, {\n    name: 'markIndex',\n    type: 'number',\n    default: 0\n  }, {\n    name: 'avoidBaseMark',\n    type: 'boolean',\n    default: true\n  }, {\n    name: 'avoidMarks',\n    type: 'data',\n    array: true\n  }, {\n    name: 'method',\n    type: 'string',\n    default: 'naive'\n  }, {\n    name: 'as',\n    type: 'string',\n    array: true,\n    length: Output.length,\n    default: Output\n  }]\n};\ninherits(Label, Transform, {\n  transform: function transform(_, pulse) {\n    function modp(param) {\n      var p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    var mod = _.modified();\n\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    var as = _.as || Output; // run label layout\n\n    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(function (l) {\n      // write layout results to data stream\n      var t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n    return pulse.reflow(mod).modifies(as);\n  }\n});\nexport { Label as label };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-label/build/vega-label.module.js"],"names":["canvas","rederive","Transform","Marks","textMetrics","inherits","isFunction","error","array","ALPHA_MASK","INSIDE_OPACITY_IN_ALPHA","INSIDE_OPACITY","baseBitmaps","$","data","bitmap","forEach","d","set","boundary","undefined","markBitmaps","avoidMarks","labelInside","isGroupArea","width","height","border","context","getContext","items","draw","buffer","Uint32Array","getImageData","layer1","layer2","x","y","u","v","alpha","interior","length","type","mark","marktype","group","map","prepare","source","item","stroke","strokeOpacity","fill","fillOpacity","strokeWidth","DIV","MOD","SIZE","RIGHT0","RIGHT1","i","Bitmap","w","h","_set","index","mask","_clear","get","clear","getRange","x2","y2","r","start","end","indexStart","indexEnd","setRange","clearRange","outOfBounds","scaler","padding","ratio","Math","max","sqrt","scale","_","invert","placeAreaLabelNaive","bitmaps","avoidBaseMark","markIndex","datum","n","textHeight","fontSize","textWidth","text","maxAreaWidth","x1","y1","areaWidth","abs","align","baseline","_outOfBounds","collision","bm0","bm1","_collision","getTests","infPadding","placeAreaLabelReducedSearch","tryLabel","_x","_y","maxSize","lo","hi","mid","labelPlaced","labelPlaced2","_x1","_xMid","_x2","_y1","_yMid","_y2","result","swapTmp","X_DIR","Y_DIR","placeAreaLabelFloodFill","bm2","stack","push","pop","j","Aligns","Baselines","placeMarkLabel","anchors","offsets","dx","dy","isInside","sizeFactor","insideFactor","xc","yc","SQRT1_2","test","isInMarkBound","TOP","MIDDLE","BOTTOM","LEFT","CENTER","RIGHT","anchorCode","placeAreaLabel","labelLayout","texts","size","compare","offset","anchor","lineAnchor","method","positions","getOffsets","getAnchors","markType","grouptype","markBoundary","Infinity","isNaiveGroupArea","opacity","sort","a","b","concat","place","count","Float64Array","Int8Array","xy","NaN","bounds","Output","Anchors","Label","params","call","Definition","metadata","modifies","name","required","default","null","values","transform","pulse","modp","param","p","modified","fields","mod","changed","ADD_REM","as","materialize","SOURCE","l","t","reflow","label"],"mappings":";AAAA,SAASA,MAAT,QAAuB,aAAvB;AACA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,eAApC;AACA,SAASC,KAAT,EAAgBC,WAAhB,QAAmC,iBAAnC;AACA,SAASC,QAAT,EAAmBC,UAAnB,EAA+BC,KAA/B,EAAsCC,KAAtC,QAAmD,WAAnD;AAEA,IAAMC,UAAU,GAAG,UAAnB,C,CAA+B;;AAE/B,IAAMC,uBAAuB,GAAG,UAAhC;AACA,IAAMC,cAAc,GAAG,MAAvB;;AACA,SAASC,WAAT,CAAqBC,CAArB,EAAwBC,IAAxB,EAA8B;AAC5B,MAAMC,MAAM,GAAGF,CAAC,CAACE,MAAF,EAAf,CAD4B,CACD;;AAE3B,GAACD,IAAI,IAAI,EAAT,EAAaE,OAAb,CAAqB,UAAAC,CAAC;AAAA,WAAIF,MAAM,CAACG,GAAP,CAAWL,CAAC,CAACI,CAAC,CAACE,QAAF,CAAW,CAAX,CAAD,CAAZ,EAA6BN,CAAC,CAACI,CAAC,CAACE,QAAF,CAAW,CAAX,CAAD,CAA9B,CAAJ;AAAA,GAAtB;AACA,SAAO,CAACJ,MAAD,EAASK,SAAT,CAAP;AACD;;AACD,SAASC,WAAT,CAAqBR,CAArB,EAAwBS,UAAxB,EAAoCC,WAApC,EAAiDC,WAAjD,EAA8D;AAC5D;AACA,MAAMC,KAAK,GAAGZ,CAAC,CAACY,KAAhB;AAAA,MACMC,MAAM,GAAGb,CAAC,CAACa,MADjB;AAAA,MAEMC,MAAM,GAAGJ,WAAW,IAAIC,WAF9B;AAAA,MAGMI,OAAO,GAAG5B,MAAM,CAACyB,KAAD,EAAQC,MAAR,CAAN,CAAsBG,UAAtB,CAAiC,IAAjC,CAHhB,CAF4D,CAKJ;;AAExDP,EAAAA,UAAU,CAACN,OAAX,CAAmB,UAAAc,KAAK;AAAA,WAAIC,IAAI,CAACH,OAAD,EAAUE,KAAV,EAAiBH,MAAjB,CAAR;AAAA,GAAxB,EAP4D,CAOD;;AAE3D,MAAMK,MAAM,GAAG,IAAIC,WAAJ,CAAgBL,OAAO,CAACM,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2BT,KAA3B,EAAkCC,MAAlC,EAA0CZ,IAA1C,CAA+CkB,MAA/D,CAAf;AAAA,MACMG,MAAM,GAAGtB,CAAC,CAACE,MAAF,EADf;AAAA,MAEMqB,MAAM,GAAGT,MAAM,IAAId,CAAC,CAACE,MAAF,EAFzB,CAT4D,CAWvB;;AAErC,MAAIsB,CAAJ,EAAOC,CAAP,EAAUC,CAAV,EAAaC,CAAb,EAAgBC,KAAhB;;AAEA,OAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,MAAhB,EAAwB,EAAEY,CAA1B,EAA6B;AAC3B,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,KAAhB,EAAuB,EAAEY,CAAzB,EAA4B;AAC1BI,MAAAA,KAAK,GAAGT,MAAM,CAACM,CAAC,GAAGb,KAAJ,GAAYY,CAAb,CAAN,GAAwB5B,UAAhC;;AAEA,UAAIgC,KAAJ,EAAW;AACTF,QAAAA,CAAC,GAAG1B,CAAC,CAACwB,CAAD,CAAL;AACAG,QAAAA,CAAC,GAAG3B,CAAC,CAACyB,CAAD,CAAL;AACA,YAAI,CAACd,WAAL,EAAkBW,MAAM,CAACjB,GAAP,CAAWqB,CAAX,EAAcC,CAAd,EAHT,CAG2B;;AAEpC,YAAIb,MAAM,IAAIc,KAAK,GAAG/B,uBAAtB,EAA+C0B,MAAM,CAAClB,GAAP,CAAWqB,CAAX,EAAcC,CAAd,EALtC,CAKwD;AAClE;AACF;AACF;;AAED,SAAO,CAACL,MAAD,EAASC,MAAT,CAAP;AACD;;AAED,SAASL,IAAT,CAAcH,OAAd,EAAuBE,KAAvB,EAA8BY,QAA9B,EAAwC;AACtC,MAAI,CAACZ,KAAK,CAACa,MAAX,EAAmB;AACnB,MAAMC,IAAI,GAAGd,KAAK,CAAC,CAAD,CAAL,CAASe,IAAT,CAAcC,QAA3B;;AAEA,MAAIF,IAAI,KAAK,OAAb,EAAsB;AACpBd,IAAAA,KAAK,CAACd,OAAN,CAAc,UAAA+B,KAAK,EAAI;AACrBA,MAAAA,KAAK,CAACjB,KAAN,CAAYd,OAAZ,CAAoB,UAAA6B,IAAI;AAAA,eAAId,IAAI,CAACH,OAAD,EAAUiB,IAAI,CAACf,KAAf,EAAsBY,QAAtB,CAAR;AAAA,OAAxB;AACD,KAFD;AAGD,GAJD,MAIO;AACLvC,IAAAA,KAAK,CAACyC,IAAD,CAAL,CAAYb,IAAZ,CAAiBH,OAAjB,EAA0B;AACxBE,MAAAA,KAAK,EAAEY,QAAQ,GAAGZ,KAAK,CAACkB,GAAN,CAAUC,OAAV,CAAH,GAAwBnB;AADf,KAA1B;AAGD;AACF;AACD;;;;;;;AAOA,SAASmB,OAAT,CAAiBC,MAAjB,EAAyB;AACvB,MAAMC,IAAI,GAAGlD,QAAQ,CAACiD,MAAD,EAAS,EAAT,CAArB;;AAEA,MAAIC,IAAI,CAACC,MAAT,EAAiB;AACfD,IAAAA,IAAI,CAACE,aAAL,GAAqB,CAArB;AACD;;AAED,MAAIF,IAAI,CAACG,IAAT,EAAe;AACbH,IAAAA,IAAI,CAACI,WAAL,GAAmB5C,cAAnB;AACAwC,IAAAA,IAAI,CAACC,MAAL,GAAc,MAAd;AACAD,IAAAA,IAAI,CAACE,aAAL,GAAqB,CAArB;AACAF,IAAAA,IAAI,CAACK,WAAL,GAAmB,CAAnB;AACD;;AAED,SAAOL,IAAP;AACD;;AAED,IAAMM,GAAG,GAAG,CAAZ;AAAA,IACM;AACNC,GAAG,GAAG,EAFN;AAAA,IAGM;AACNC,IAAI,GAAG,EAJP;AAAA,IAKM;AACNC,MAAM,GAAG,IAAI3B,WAAJ,CAAgB0B,IAAI,GAAG,CAAvB,CANT;AAAA,IAOM;AACNE,MAAM,GAAG,IAAI5B,WAAJ,CAAgB0B,IAAI,GAAG,CAAvB,CART,C,CAQoC;;AAEpCE,MAAM,CAAC,CAAD,CAAN,GAAY,CAAZ;AACAD,MAAM,CAAC,CAAD,CAAN,GAAY,CAACC,MAAM,CAAC,CAAD,CAAnB;;AAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,IAArB,EAA2B,EAAEG,CAA7B,EAAgC;AAC9BD,EAAAA,MAAM,CAACC,CAAD,CAAN,GAAYD,MAAM,CAACC,CAAC,GAAG,CAAL,CAAN,IAAiB,CAAjB,GAAqB,CAAjC;AACAF,EAAAA,MAAM,CAACE,CAAD,CAAN,GAAY,CAACD,MAAM,CAACC,CAAD,CAAnB;AACD;;AAED,SAASC,MAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACrB,MAAMzD,KAAK,GAAG,IAAIyB,WAAJ,CAAgB,CAAC,EAAE,CAAC+B,CAAC,GAAGC,CAAJ,GAAQN,IAAT,IAAiBA,IAAnB,CAAjB,CAAd;;AAEA,WAASO,IAAT,CAAcC,KAAd,EAAqBC,IAArB,EAA2B;AACzB5D,IAAAA,KAAK,CAAC2D,KAAD,CAAL,IAAgBC,IAAhB;AACD;;AAED,WAASC,MAAT,CAAgBF,KAAhB,EAAuBC,IAAvB,EAA6B;AAC3B5D,IAAAA,KAAK,CAAC2D,KAAD,CAAL,IAAgBC,IAAhB;AACD;;AAED,SAAO;AACL5D,IAAAA,KAAK,EAAEA,KADF;AAEL8D,IAAAA,GAAG,EAAE,aAACjC,CAAD,EAAIC,CAAJ,EAAU;AACb,UAAM6B,KAAK,GAAG7B,CAAC,GAAG0B,CAAJ,GAAQ3B,CAAtB;AACA,aAAO7B,KAAK,CAAC2D,KAAK,KAAKV,GAAX,CAAL,GAAuB,MAAMU,KAAK,GAAGT,GAAd,CAA9B;AACD,KALI;AAMLxC,IAAAA,GAAG,EAAE,aAACmB,CAAD,EAAIC,CAAJ,EAAU;AACb,UAAM6B,KAAK,GAAG7B,CAAC,GAAG0B,CAAJ,GAAQ3B,CAAtB;;AAEA6B,MAAAA,IAAI,CAACC,KAAK,KAAKV,GAAX,EAAgB,MAAMU,KAAK,GAAGT,GAAd,CAAhB,CAAJ;AACD,KAVI;AAWLa,IAAAA,KAAK,EAAE,eAAClC,CAAD,EAAIC,CAAJ,EAAU;AACf,UAAM6B,KAAK,GAAG7B,CAAC,GAAG0B,CAAJ,GAAQ3B,CAAtB;;AAEAgC,MAAAA,MAAM,CAACF,KAAK,KAAKV,GAAX,EAAgB,EAAE,MAAMU,KAAK,GAAGT,GAAd,CAAF,CAAhB,CAAN;AACD,KAfI;AAgBLc,IAAAA,QAAQ,EAAE,kBAACnC,CAAD,EAAIC,CAAJ,EAAOmC,EAAP,EAAWC,EAAX,EAAkB;AAC1B,UAAIC,CAAC,GAAGD,EAAR;AAAA,UACIE,KADJ;AAAA,UAEIC,GAFJ;AAAA,UAGIC,UAHJ;AAAA,UAIIC,QAJJ;;AAMA,aAAOJ,CAAC,IAAIrC,CAAZ,EAAe,EAAEqC,CAAjB,EAAoB;AAClBC,QAAAA,KAAK,GAAGD,CAAC,GAAGX,CAAJ,GAAQ3B,CAAhB;AACAwC,QAAAA,GAAG,GAAGF,CAAC,GAAGX,CAAJ,GAAQS,EAAd;AACAK,QAAAA,UAAU,GAAGF,KAAK,KAAKnB,GAAvB;AACAsB,QAAAA,QAAQ,GAAGF,GAAG,KAAKpB,GAAnB;;AAEA,YAAIqB,UAAU,KAAKC,QAAnB,EAA6B;AAC3B,cAAIvE,KAAK,CAACsE,UAAD,CAAL,GAAoBlB,MAAM,CAACgB,KAAK,GAAGlB,GAAT,CAA1B,GAA0CG,MAAM,CAAC,CAACgB,GAAG,GAAGnB,GAAP,IAAc,CAAf,CAApD,EAAuE;AACrE,mBAAO,IAAP;AACD;AACF,SAJD,MAIO;AACL,cAAIlD,KAAK,CAACsE,UAAD,CAAL,GAAoBlB,MAAM,CAACgB,KAAK,GAAGlB,GAAT,CAA9B,EAA6C,OAAO,IAAP;AAC7C,cAAIlD,KAAK,CAACuE,QAAD,CAAL,GAAkBlB,MAAM,CAAC,CAACgB,GAAG,GAAGnB,GAAP,IAAc,CAAf,CAA5B,EAA+C,OAAO,IAAP;;AAE/C,eAAK,IAAII,EAAC,GAAGgB,UAAU,GAAG,CAA1B,EAA6BhB,EAAC,GAAGiB,QAAjC,EAA2C,EAAEjB,EAA7C,EAAgD;AAC9C,gBAAItD,KAAK,CAACsD,EAAD,CAAT,EAAc,OAAO,IAAP;AACf;AACF;AACF;;AAED,aAAO,KAAP;AACD,KA5CI;AA6CLkB,IAAAA,QAAQ,EAAE,kBAAC3C,CAAD,EAAIC,CAAJ,EAAOmC,EAAP,EAAWC,EAAX,EAAkB;AAC1B,UAAIE,KAAJ,EAAWC,GAAX,EAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCjB,CAAtC;;AAEA,aAAOxB,CAAC,IAAIoC,EAAZ,EAAgB,EAAEpC,CAAlB,EAAqB;AACnBsC,QAAAA,KAAK,GAAGtC,CAAC,GAAG0B,CAAJ,GAAQ3B,CAAhB;AACAwC,QAAAA,GAAG,GAAGvC,CAAC,GAAG0B,CAAJ,GAAQS,EAAd;AACAK,QAAAA,UAAU,GAAGF,KAAK,KAAKnB,GAAvB;AACAsB,QAAAA,QAAQ,GAAGF,GAAG,KAAKpB,GAAnB;;AAEA,YAAIqB,UAAU,KAAKC,QAAnB,EAA6B;AAC3Bb,UAAAA,IAAI,CAACY,UAAD,EAAalB,MAAM,CAACgB,KAAK,GAAGlB,GAAT,CAAN,GAAsBG,MAAM,CAAC,CAACgB,GAAG,GAAGnB,GAAP,IAAc,CAAf,CAAzC,CAAJ;AACD,SAFD,MAEO;AACLQ,UAAAA,IAAI,CAACY,UAAD,EAAalB,MAAM,CAACgB,KAAK,GAAGlB,GAAT,CAAnB,CAAJ;;AAEAQ,UAAAA,IAAI,CAACa,QAAD,EAAWlB,MAAM,CAAC,CAACgB,GAAG,GAAGnB,GAAP,IAAc,CAAf,CAAjB,CAAJ;;AAEA,eAAKI,CAAC,GAAGgB,UAAU,GAAG,CAAtB,EAAyBhB,CAAC,GAAGiB,QAA7B,EAAuC,EAAEjB,CAAzC;AAA4CI,YAAAA,IAAI,CAACJ,CAAD,EAAI,UAAJ,CAAJ;AAA5C;AACD;AACF;AACF,KAhEI;AAiELmB,IAAAA,UAAU,EAAE,oBAAC5C,CAAD,EAAIC,CAAJ,EAAOmC,EAAP,EAAWC,EAAX,EAAkB;AAC5B,UAAIE,KAAJ,EAAWC,GAAX,EAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCjB,CAAtC;;AAEA,aAAOxB,CAAC,IAAIoC,EAAZ,EAAgB,EAAEpC,CAAlB,EAAqB;AACnBsC,QAAAA,KAAK,GAAGtC,CAAC,GAAG0B,CAAJ,GAAQ3B,CAAhB;AACAwC,QAAAA,GAAG,GAAGvC,CAAC,GAAG0B,CAAJ,GAAQS,EAAd;AACAK,QAAAA,UAAU,GAAGF,KAAK,KAAKnB,GAAvB;AACAsB,QAAAA,QAAQ,GAAGF,GAAG,KAAKpB,GAAnB;;AAEA,YAAIqB,UAAU,KAAKC,QAAnB,EAA6B;AAC3BV,UAAAA,MAAM,CAACS,UAAD,EAAajB,MAAM,CAACe,KAAK,GAAGlB,GAAT,CAAN,GAAsBE,MAAM,CAAC,CAACiB,GAAG,GAAGnB,GAAP,IAAc,CAAf,CAAzC,CAAN;AACD,SAFD,MAEO;AACLW,UAAAA,MAAM,CAACS,UAAD,EAAajB,MAAM,CAACe,KAAK,GAAGlB,GAAT,CAAnB,CAAN;;AAEAW,UAAAA,MAAM,CAACU,QAAD,EAAWnB,MAAM,CAAC,CAACiB,GAAG,GAAGnB,GAAP,IAAc,CAAf,CAAjB,CAAN;;AAEA,eAAKI,CAAC,GAAGgB,UAAU,GAAG,CAAtB,EAAyBhB,CAAC,GAAGiB,QAA7B,EAAuC,EAAEjB,CAAzC;AAA4CO,YAAAA,MAAM,CAACP,CAAD,EAAI,CAAJ,CAAN;AAA5C;AACD;AACF;AACF,KApFI;AAqFLoB,IAAAA,WAAW,EAAE,qBAAC7C,CAAD,EAAIC,CAAJ,EAAOmC,EAAP,EAAWC,EAAX;AAAA,aAAkBrC,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBoC,EAAE,IAAIT,CAAxB,IAA6BQ,EAAE,IAAIT,CAArD;AAAA;AArFR,GAAP;AAuFD;;AAED,SAASmB,MAAT,CAAiB1D,KAAjB,EAAwBC,MAAxB,EAAgC0D,OAAhC,EAAyC;AACvC,MAAMC,KAAK,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACE,IAAL,CAAU/D,KAAK,GAAGC,MAAR,GAAiB,GAA3B,CAAZ,CAAd;AAAA,MACMsC,CAAC,GAAG,CAAC,EAAE,CAACvC,KAAK,GAAG,IAAI2D,OAAZ,GAAsBC,KAAvB,IAAgCA,KAAlC,CADX;AAAA,MAEMpB,CAAC,GAAG,CAAC,EAAE,CAACvC,MAAM,GAAG,IAAI0D,OAAb,GAAuBC,KAAxB,IAAiCA,KAAnC,CAFX;AAAA,MAGMI,KAAK,GAAG,SAARA,KAAQ,CAAAC,CAAC;AAAA,WAAI,CAAC,EAAE,CAACA,CAAC,GAAGN,OAAL,IAAgBC,KAAlB,CAAL;AAAA,GAHf;;AAKAI,EAAAA,KAAK,CAACE,MAAN,GAAe,UAAAD,CAAC;AAAA,WAAIA,CAAC,GAAGL,KAAJ,GAAYD,OAAhB;AAAA,GAAhB;;AAEAK,EAAAA,KAAK,CAAC1E,MAAN,GAAe;AAAA,WAAMgD,MAAM,CAACC,CAAD,EAAIC,CAAJ,CAAZ;AAAA,GAAf;;AAEAwB,EAAAA,KAAK,CAACJ,KAAN,GAAcA,KAAd;AACAI,EAAAA,KAAK,CAACL,OAAN,GAAgBA,OAAhB;AACAK,EAAAA,KAAK,CAAChE,KAAN,GAAcA,KAAd;AACAgE,EAAAA,KAAK,CAAC/D,MAAN,GAAeA,MAAf;AACA,SAAO+D,KAAP;AACD;;AAED,SAASG,mBAAT,CAA8B/E,CAA9B,EAAiCgF,OAAjC,EAA0CC,aAA1C,EAAyDC,SAAzD,EAAoE;AAClE,MAAMtE,KAAK,GAAGZ,CAAC,CAACY,KAAhB;AAAA,MACMC,MAAM,GAAGb,CAAC,CAACa,MADjB,CADkE,CAEzC;;AAEzB,SAAO,UAAUT,CAAV,EAAa;AAClB,QAAMa,KAAK,GAAGb,CAAC,CAAC+E,KAAF,CAAQA,KAAR,CAAclE,KAAd,CAAoBiE,SAApB,EAA+BjE,KAA7C;AAAA,QACM;AACNmE,IAAAA,CAAC,GAAGnE,KAAK,CAACa,MAFV;AAAA,QAGM;AACNuD,IAAAA,UAAU,GAAGjF,CAAC,CAAC+E,KAAF,CAAQG,QAJrB;AAAA,QAKM;AACNC,IAAAA,SAAS,GAAGhG,WAAW,CAACqB,KAAZ,CAAkBR,CAAC,CAAC+E,KAApB,EAA2B/E,CAAC,CAAC+E,KAAF,CAAQK,IAAnC,CANZ,CADkB,CAOoC;;AAEtD,QAAIC,YAAY,GAAG,CAAnB;AAAA,QACIC,EADJ;AAAA,QAEI9B,EAFJ;AAAA,QAGI+B,EAHJ;AAAA,QAII9B,EAJJ;AAAA,QAKIrC,CALJ;AAAA,QAMIC,CANJ;AAAA,QAOImE,SAPJ,CATkB,CAgBH;;AAEf,SAAK,IAAI3C,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGmC,CAApB,EAAuB,EAAEnC,GAAzB,EAA4B;AAC1ByC,MAAAA,EAAE,GAAGzE,KAAK,CAACgC,GAAD,CAAL,CAASzB,CAAd;AACAmE,MAAAA,EAAE,GAAG1E,KAAK,CAACgC,GAAD,CAAL,CAASxB,CAAd;AACAmC,MAAAA,EAAE,GAAG3C,KAAK,CAACgC,GAAD,CAAL,CAASW,EAAT,KAAgBrD,SAAhB,GAA4BmF,EAA5B,GAAiCzE,KAAK,CAACgC,GAAD,CAAL,CAASW,EAA/C;AACAC,MAAAA,EAAE,GAAG5C,KAAK,CAACgC,GAAD,CAAL,CAASY,EAAT,KAAgBtD,SAAhB,GAA4BoF,EAA5B,GAAiC1E,KAAK,CAACgC,GAAD,CAAL,CAASY,EAA/C;AACArC,MAAAA,CAAC,GAAG,CAACkE,EAAE,GAAG9B,EAAN,IAAY,CAAhB;AACAnC,MAAAA,CAAC,GAAG,CAACkE,EAAE,GAAG9B,EAAN,IAAY,CAAhB;AACA+B,MAAAA,SAAS,GAAGnB,IAAI,CAACoB,GAAL,CAASjC,EAAE,GAAG8B,EAAL,GAAU7B,EAAV,GAAe8B,EAAxB,CAAZ;;AAEA,UAAIC,SAAS,IAAIH,YAAjB,EAA+B;AAC7BA,QAAAA,YAAY,GAAGG,SAAf;AACAxF,QAAAA,CAAC,CAACoB,CAAF,GAAMA,CAAN;AACApB,QAAAA,CAAC,CAACqB,CAAF,GAAMA,CAAN;AACD;AACF;;AAEDD,IAAAA,CAAC,GAAG+D,SAAS,GAAG,CAAhB;AACA9D,IAAAA,CAAC,GAAG4D,UAAU,GAAG,CAAjB;AACAK,IAAAA,EAAE,GAAGtF,CAAC,CAACoB,CAAF,GAAMA,CAAX;AACAoC,IAAAA,EAAE,GAAGxD,CAAC,CAACoB,CAAF,GAAMA,CAAX;AACAmE,IAAAA,EAAE,GAAGvF,CAAC,CAACqB,CAAF,GAAMA,CAAX;AACAoC,IAAAA,EAAE,GAAGzD,CAAC,CAACqB,CAAF,GAAMA,CAAX;AACArB,IAAAA,CAAC,CAAC0F,KAAF,GAAU,QAAV;;AAEA,QAAIJ,EAAE,GAAG,CAAL,IAAU9B,EAAE,IAAIhD,KAApB,EAA2B;AACzBR,MAAAA,CAAC,CAAC0F,KAAF,GAAU,MAAV;AACD,KAFD,MAEO,IAAI,KAAKJ,EAAL,IAAW9E,KAAK,GAAGgD,EAAvB,EAA2B;AAChCxD,MAAAA,CAAC,CAAC0F,KAAF,GAAU,OAAV;AACD;;AAED1F,IAAAA,CAAC,CAAC2F,QAAF,GAAa,QAAb;;AAEA,QAAIJ,EAAE,GAAG,CAAL,IAAU9B,EAAE,IAAIhD,MAApB,EAA4B;AAC1BT,MAAAA,CAAC,CAAC2F,QAAF,GAAa,KAAb;AACD,KAFD,MAEO,IAAI,KAAKJ,EAAL,IAAW9E,MAAM,GAAGgD,EAAxB,EAA4B;AACjCzD,MAAAA,CAAC,CAAC2F,QAAF,GAAa,QAAb;AACD;;AAED,WAAO,IAAP;AACD,GAzDD;AA0DD;;AAED,SAAS1B,WAAT,CAAqB7C,CAArB,EAAwBC,CAAxB,EAA2B8D,SAA3B,EAAsCF,UAAtC,EAAkDzE,KAAlD,EAAyDC,MAAzD,EAAiE;AAC/D,MAAIiD,CAAC,GAAGyB,SAAS,GAAG,CAApB;AACA,SAAO/D,CAAC,GAAGsC,CAAJ,GAAQ,CAAR,IAAatC,CAAC,GAAGsC,CAAJ,GAAQlD,KAArB,IAA8Ba,CAAC,IAAIqC,CAAC,GAAGuB,UAAU,GAAG,CAArB,CAAD,GAA2B,CAAzD,IAA8D5D,CAAC,GAAGqC,CAAJ,GAAQjD,MAA7E;AACD;;AAED,SAASmF,YAAT,GAAwB;AACtB,SAAO,KAAP;AACD;;AAED,SAASC,SAAT,CAAmBjG,CAAnB,EAAsBwB,CAAtB,EAAyBC,CAAzB,EAA4B4D,UAA5B,EAAwCE,SAAxC,EAAmDnC,CAAnD,EAAsD8C,GAAtD,EAA2DC,GAA3D,EAAgE;AAC9D,MAAMhD,CAAC,GAAGoC,SAAS,GAAGnC,CAAZ,IAAiBiC,UAAU,GAAG,CAA9B,CAAV;AAAA,MACMK,EAAE,GAAG1F,CAAC,CAACwB,CAAC,GAAG2B,CAAL,CADZ;AAAA,MAEMS,EAAE,GAAG5D,CAAC,CAACwB,CAAC,GAAG2B,CAAL,CAFZ;AAAA,MAGMwC,EAAE,GAAG3F,CAAC,CAACyB,CAAC,IAAI2B,CAAC,GAAGA,CAAC,GAAG,CAAZ,CAAF,CAHZ;AAAA,MAIMS,EAAE,GAAG7D,CAAC,CAACyB,CAAC,GAAG2B,CAAL,CAJZ;AAKA,SAAO8C,GAAG,CAAC7B,WAAJ,CAAgBqB,EAAhB,EAAoBC,EAApB,EAAwB/B,EAAxB,EAA4BC,EAA5B,KAAmCqC,GAAG,CAACvC,QAAJ,CAAa+B,EAAb,EAAiBC,EAAjB,EAAqB/B,EAArB,EAAyBC,EAAzB,CAAnC,IAAmEsC,GAAG,IAAIA,GAAG,CAACxC,QAAJ,CAAa+B,EAAb,EAAiBC,EAAjB,EAAqB/B,EAArB,EAAyBC,EAAzB,CAAjF;AACD;;AAED,SAASuC,UAAT,CAAoBpG,CAApB,EAAuBwB,CAAvB,EAA0BC,CAA1B,EAA6B4D,UAA7B,EAAyCE,SAAzC,EAAoDnC,CAApD,EAAuD8C,GAAvD,EAA4DC,GAA5D,EAAiE;AAC/D,MAAMhD,CAAC,GAAGoC,SAAS,GAAGnC,CAAZ,IAAiBiC,UAAU,GAAG,CAA9B,CAAV;AACA,MAAIK,EAAE,GAAG1F,CAAC,CAACwB,CAAC,GAAG2B,CAAL,CAAV;AAAA,MACIS,EAAE,GAAG5D,CAAC,CAACwB,CAAC,GAAG2B,CAAL,CADV;AAAA,MAEIwC,EAAE,GAAG3F,CAAC,CAACyB,CAAC,IAAI2B,CAAC,GAAGA,CAAC,GAAG,CAAZ,CAAF,CAFV;AAAA,MAGIS,EAAE,GAAG7D,CAAC,CAACyB,CAAC,GAAG2B,CAAL,CAHV;AAIAsC,EAAAA,EAAE,GAAGA,EAAE,GAAG,CAAL,GAASA,EAAT,GAAc,CAAnB;AACAC,EAAAA,EAAE,GAAGA,EAAE,GAAG,CAAL,GAASA,EAAT,GAAc,CAAnB;AACA/B,EAAAA,EAAE,GAAGA,EAAE,GAAG5D,CAAC,CAACY,KAAP,GAAegD,EAAf,GAAoB5D,CAAC,CAACY,KAAF,GAAU,CAAnC;AACAiD,EAAAA,EAAE,GAAGA,EAAE,GAAG7D,CAAC,CAACa,MAAP,GAAgBgD,EAAhB,GAAqB7D,CAAC,CAACa,MAAF,GAAW,CAArC;AACA,SAAOqF,GAAG,CAACvC,QAAJ,CAAa+B,EAAb,EAAiBC,EAAjB,EAAqB/B,EAArB,EAAyBC,EAAzB,KAAgCsC,GAAG,IAAIA,GAAG,CAACxC,QAAJ,CAAa+B,EAAb,EAAiBC,EAAjB,EAAqB/B,EAArB,EAAyBC,EAAzB,CAA9C;AACD;;AAED,SAASwC,QAAT,CAAkBC,UAAlB,EAA8B;AAC5B,SAAOA,UAAU,GAAG,CAACF,UAAD,EAAaJ,YAAb,CAAH,GAAgC,CAACC,SAAD,EAAY5B,WAAZ,CAAjD;AACD;;AAED,SAASkC,2BAAT,CAAsCvG,CAAtC,EAAyCgF,OAAzC,EAAkDC,aAAlD,EAAiEC,SAAjE,EAA4EoB,UAA5E,EAAwF;AAChF,MAAA1F,KAAK,GAAGZ,CAAC,CAACY,KAAV;AAAA,MACAC,MADA,GACSb,CAAC,CAACa,MADX;AAAA,kBAE2BwF,QAAQ,CAACC,UAAD,CAFnC;AAAA;AAAA,MAECL,SAFD;AAAA,MAEY5B,WAFZ;AAAA,MAGA6B,GAHA,GAGMlB,OAAO,CAAC,CAAD,CAHb;AAAA,MAKNmB,GALM,GAKAnB,OAAO,CAAC,CAAD,CALP,CADgF,CAMpE;;;AAElB,WAASwB,QAAT,CAAkBC,EAAlB,EAAsBC,EAAtB,EAA0BC,OAA1B,EAAmCpB,SAAnC,EAA8CF,UAA9C,EAA0D;AACxD,QAAM7D,CAAC,GAAGxB,CAAC,CAAC8E,MAAF,CAAS2B,EAAT,CAAV;AAAA,QACMhF,CAAC,GAAGzB,CAAC,CAAC8E,MAAF,CAAS4B,EAAT,CADV;AAEA,QAAIE,EAAE,GAAGD,OAAT;AAAA,QACIE,EAAE,GAAGhG,MADT;AAAA,QAEIiG,GAFJ;;AAIA,QAAI,CAACzC,WAAW,CAAC7C,CAAD,EAAIC,CAAJ,EAAO8D,SAAP,EAAkBF,UAAlB,EAA8BzE,KAA9B,EAAqCC,MAArC,CAAZ,IAA4D,CAACoF,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCqB,EAAjC,EAAqCV,GAArC,EAA0CC,GAA1C,CAAtE,IAAwH,CAACF,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCF,UAAjC,EAA6Ca,GAA7C,EAAkD,IAAlD,CAAtI,EAA+L;AAC7L;AACA;AACA,aAAOW,EAAE,GAAGD,EAAL,IAAW,CAAlB,EAAqB;AACnBE,QAAAA,GAAG,GAAG,CAACF,EAAE,GAAGC,EAAN,IAAY,CAAlB;;AAEA,YAAIZ,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCuB,GAAjC,EAAsCZ,GAAtC,EAA2CC,GAA3C,CAAb,EAA8D;AAC5DU,UAAAA,EAAE,GAAGC,GAAL;AACD,SAFD,MAEO;AACLF,UAAAA,EAAE,GAAGE,GAAL;AACD;AACF,OAX4L,CAW3L;;;AAGF,UAAIF,EAAE,GAAGD,OAAT,EAAkB;AAChB,eAAO,CAACnF,CAAD,EAAIC,CAAJ,EAAOmF,EAAP,EAAW,IAAX,CAAP;AACD;AACF;AACF,GAjCqF,CAiCpF;;;AAGF,SAAO,UAAUxG,CAAV,EAAa;AAClB,QAAMa,KAAK,GAAGb,CAAC,CAAC+E,KAAF,CAAQA,KAAR,CAAclE,KAAd,CAAoBiE,SAApB,EAA+BjE,KAA7C;AAAA,QACM;AACNmE,IAAAA,CAAC,GAAGnE,KAAK,CAACa,MAFV;AAAA,QAGM;AACNuD,IAAAA,UAAU,GAAGjF,CAAC,CAAC+E,KAAF,CAAQG,QAJrB;AAAA,QAKM;AACNC,IAAAA,SAAS,GAAGhG,WAAW,CAACqB,KAAZ,CAAkBR,CAAC,CAAC+E,KAApB,EAA2B/E,CAAC,CAAC+E,KAAF,CAAQK,IAAnC,CANZ,CADkB,CAOoC;;AAEtD,QAAImB,OAAO,GAAG1B,aAAa,GAAGI,UAAH,GAAgB,CAA3C;AAAA,QACI0B,WAAW,GAAG,KADlB;AAAA,QAEIC,YAAY,GAAG,KAFnB;AAAA,QAGIvB,YAAY,GAAG,CAHnB;AAAA,QAIIC,EAJJ;AAAA,QAKI9B,EALJ;AAAA,QAMI+B,EANJ;AAAA,QAOI9B,EAPJ;AAAA,QAQIrC,CARJ;AAAA,QASIC,CATJ;AAAA,QAUIgF,EAVJ;AAAA,QAWIC,EAXJ;AAAA,QAYIO,GAZJ;AAAA,QAaIC,KAbJ;AAAA,QAcIC,GAdJ;AAAA,QAeIC,GAfJ;AAAA,QAgBIC,KAhBJ;AAAA,QAiBIC,GAjBJ;AAAA,QAkBI1B,SAlBJ;AAAA,QAmBI2B,MAnBJ;AAAA,QAoBIC,OApBJ,CATkB,CA6BL;;;AAGb,SAAK,IAAIvE,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGmC,CAApB,EAAuB,EAAEnC,GAAzB,EAA4B;AAC1ByC,MAAAA,EAAE,GAAGzE,KAAK,CAACgC,GAAD,CAAL,CAASzB,CAAd;AACAmE,MAAAA,EAAE,GAAG1E,KAAK,CAACgC,GAAD,CAAL,CAASxB,CAAd;AACAmC,MAAAA,EAAE,GAAG3C,KAAK,CAACgC,GAAD,CAAL,CAASW,EAAT,KAAgBrD,SAAhB,GAA4BmF,EAA5B,GAAiCzE,KAAK,CAACgC,GAAD,CAAL,CAASW,EAA/C;AACAC,MAAAA,EAAE,GAAG5C,KAAK,CAACgC,GAAD,CAAL,CAASY,EAAT,KAAgBtD,SAAhB,GAA4BoF,EAA5B,GAAiC1E,KAAK,CAACgC,GAAD,CAAL,CAASY,EAA/C;;AAEA,UAAI6B,EAAE,GAAG9B,EAAT,EAAa;AACX4D,QAAAA,OAAO,GAAG9B,EAAV;AACAA,QAAAA,EAAE,GAAG9B,EAAL;AACAA,QAAAA,EAAE,GAAG4D,OAAL;AACD;;AAED,UAAI7B,EAAE,GAAG9B,EAAT,EAAa;AACX2D,QAAAA,OAAO,GAAG7B,EAAV;AACAA,QAAAA,EAAE,GAAG9B,EAAL;AACAA,QAAAA,EAAE,GAAG2D,OAAL;AACD;;AAEDP,MAAAA,GAAG,GAAGjH,CAAC,CAAC0F,EAAD,CAAP;AACAyB,MAAAA,GAAG,GAAGnH,CAAC,CAAC4D,EAAD,CAAP;AACAsD,MAAAA,KAAK,GAAG,CAAC,EAAE,CAACD,GAAG,GAAGE,GAAP,IAAc,CAAhB,CAAT;AACAC,MAAAA,GAAG,GAAGpH,CAAC,CAAC2F,EAAD,CAAP;AACA2B,MAAAA,GAAG,GAAGtH,CAAC,CAAC6D,EAAD,CAAP;AACAwD,MAAAA,KAAK,GAAG,CAAC,EAAE,CAACD,GAAG,GAAGE,GAAP,IAAc,CAAhB,CAAT,CAvB0B,CAuBG;;AAE7B,WAAKb,EAAE,GAAGS,KAAV,EAAiBT,EAAE,IAAIQ,GAAvB,EAA4B,EAAER,EAA9B,EAAkC;AAChC,aAAKC,EAAE,GAAGW,KAAV,EAAiBX,EAAE,IAAIU,GAAvB,EAA4B,EAAEV,EAA9B,EAAkC;AAChCa,UAAAA,MAAM,GAAGf,QAAQ,CAACC,EAAD,EAAKC,EAAL,EAASC,OAAT,EAAkBpB,SAAlB,EAA6BF,UAA7B,CAAjB;;AAEA,cAAIkC,MAAJ,EAAY;AAAA,0BACyBA,MADzB;;AAAA;;AACTnH,YAAAA,CAAC,CAACoB,CADO;AACJpB,YAAAA,CAAC,CAACqB,CADE;AACCkF,YAAAA,OADD;AACUI,YAAAA,WADV;AAEX;AACF;AACF,OAjCyB,CAiCxB;;;AAGF,WAAKN,EAAE,GAAGS,KAAV,EAAiBT,EAAE,IAAIU,GAAvB,EAA4B,EAAEV,EAA9B,EAAkC;AAChC,aAAKC,EAAE,GAAGW,KAAV,EAAiBX,EAAE,IAAIY,GAAvB,EAA4B,EAAEZ,EAA9B,EAAkC;AAChCa,UAAAA,MAAM,GAAGf,QAAQ,CAACC,EAAD,EAAKC,EAAL,EAASC,OAAT,EAAkBpB,SAAlB,EAA6BF,UAA7B,CAAjB;;AAEA,cAAIkC,MAAJ,EAAY;AAAA,2BACyBA,MADzB;;AAAA;;AACTnH,YAAAA,CAAC,CAACoB,CADO;AACJpB,YAAAA,CAAC,CAACqB,CADE;AACCkF,YAAAA,OADD;AACUI,YAAAA,WADV;AAEX;AACF;AACF,OA5CyB,CA4CxB;AACF;;;AAGA,UAAI,CAACA,WAAD,IAAgB,CAAC9B,aAArB,EAAoC;AAClC;AACAW,QAAAA,SAAS,GAAGnB,IAAI,CAACoB,GAAL,CAASjC,EAAE,GAAG8B,EAAL,GAAU7B,EAAV,GAAe8B,EAAxB,CAAZ;AACAnE,QAAAA,CAAC,GAAG,CAACkE,EAAE,GAAG9B,EAAN,IAAY,CAAhB;AACAnC,QAAAA,CAAC,GAAG,CAACkE,EAAE,GAAG9B,EAAN,IAAY,CAAhB,CAJkC,CAIf;;AAEnB,YAAI+B,SAAS,IAAIH,YAAb,IAA6B,CAACpB,WAAW,CAAC7C,CAAD,EAAIC,CAAJ,EAAO8D,SAAP,EAAkBF,UAAlB,EAA8BzE,KAA9B,EAAqCC,MAArC,CAAzC,IAAyF,CAACoF,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCF,UAAjC,EAA6Ca,GAA7C,EAAkD,IAAlD,CAAvG,EAAgK;AAC9JT,UAAAA,YAAY,GAAGG,SAAf;AACAxF,UAAAA,CAAC,CAACoB,CAAF,GAAMA,CAAN;AACApB,UAAAA,CAAC,CAACqB,CAAF,GAAMA,CAAN;AACAuF,UAAAA,YAAY,GAAG,IAAf;AACD;AACF;AACF,KA7FiB,CA6FhB;;;AAGF,QAAID,WAAW,IAAIC,YAAnB,EAAiC;AAC/BxF,MAAAA,CAAC,GAAG+D,SAAS,GAAG,CAAhB;AACA9D,MAAAA,CAAC,GAAG4D,UAAU,GAAG,CAAjB;AACAa,MAAAA,GAAG,CAAC/B,QAAJ,CAAanE,CAAC,CAACI,CAAC,CAACoB,CAAF,GAAMA,CAAP,CAAd,EAAyBxB,CAAC,CAACI,CAAC,CAACqB,CAAF,GAAMA,CAAP,CAA1B,EAAqCzB,CAAC,CAACI,CAAC,CAACoB,CAAF,GAAMA,CAAP,CAAtC,EAAiDxB,CAAC,CAACI,CAAC,CAACqB,CAAF,GAAMA,CAAP,CAAlD;AACArB,MAAAA,CAAC,CAAC0F,KAAF,GAAU,QAAV;AACA1F,MAAAA,CAAC,CAAC2F,QAAF,GAAa,QAAb;AACA,aAAO,IAAP;AACD,KAPD,MAOO;AACL,aAAO,KAAP;AACD;AACF,GA1GD;AA2GD;;AAED,IAAM0B,KAAK,GAAG,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,EAAS,CAAT,EAAY,CAAZ,CAAd;AACA,IAAMC,KAAK,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAC,CAAT,EAAY,CAAZ,CAAd;;AACA,SAASC,uBAAT,CAAkC3H,CAAlC,EAAqCgF,OAArC,EAA8CC,aAA9C,EAA6DC,SAA7D,EAAwEoB,UAAxE,EAAoF;AAC5E,MAAA1F,KAAK,GAAGZ,CAAC,CAACY,KAAV;AAAA,MACAC,MADA,GACSb,CAAC,CAACa,MADX;AAAA,mBAE2BwF,QAAQ,CAACC,UAAD,CAFnC;AAAA;AAAA,MAECL,SAFD;AAAA,MAEY5B,WAFZ;AAAA,MAGA6B,GAHA,GAGMlB,OAAO,CAAC,CAAD,CAHb;AAAA,MAKNmB,GALM,GAKAnB,OAAO,CAAC,CAAD,CALP;AAAA,MAON4C,GAPM,GAOA5H,CAAC,CAACE,MAAF,EAPA,CAD4E,CAQhE;AAClB;;;AAEA,SAAO,UAAUE,CAAV,EAAa;AAClB,QAAMa,KAAK,GAAGb,CAAC,CAAC+E,KAAF,CAAQA,KAAR,CAAclE,KAAd,CAAoBiE,SAApB,EAA+BjE,KAA7C;AAAA,QACM;AACNmE,IAAAA,CAAC,GAAGnE,KAAK,CAACa,MAFV;AAAA,QAGM;AACNuD,IAAAA,UAAU,GAAGjF,CAAC,CAAC+E,KAAF,CAAQG,QAJrB;AAAA,QAKM;AACNC,IAAAA,SAAS,GAAGhG,WAAW,CAACqB,KAAZ,CAAkBR,CAAC,CAAC+E,KAApB,EAA2B/E,CAAC,CAAC+E,KAAF,CAAQK,IAAnC,CANZ;AAAA,QAOM;AACNqC,IAAAA,KAAK,GAAG,EARR,CADkB,CASN;;AAEZ,QAAIlB,OAAO,GAAG1B,aAAa,GAAGI,UAAH,GAAgB,CAA3C;AAAA,QACI0B,WAAW,GAAG,KADlB;AAAA,QAEIC,YAAY,GAAG,KAFnB;AAAA,QAGIvB,YAAY,GAAG,CAHnB;AAAA,QAIIC,EAJJ;AAAA,QAKI9B,EALJ;AAAA,QAMI+B,EANJ;AAAA,QAOI9B,EAPJ;AAAA,QAQIrC,CARJ;AAAA,QASIC,CATJ;AAAA,QAUIgF,EAVJ;AAAA,QAWIC,EAXJ;AAAA,QAYIE,EAZJ;AAAA,QAaIC,EAbJ;AAAA,QAcIC,GAdJ;AAAA,QAeIlB,SAfJ,CAXkB,CA0BH;;;AAGf,SAAK,IAAI3C,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGmC,CAApB,EAAuB,EAAEnC,GAAzB,EAA4B;AAC1ByC,MAAAA,EAAE,GAAGzE,KAAK,CAACgC,GAAD,CAAL,CAASzB,CAAd;AACAmE,MAAAA,EAAE,GAAG1E,KAAK,CAACgC,GAAD,CAAL,CAASxB,CAAd;AACAmC,MAAAA,EAAE,GAAG3C,KAAK,CAACgC,GAAD,CAAL,CAASW,EAAT,KAAgBrD,SAAhB,GAA4BmF,EAA5B,GAAiCzE,KAAK,CAACgC,GAAD,CAAL,CAASW,EAA/C;AACAC,MAAAA,EAAE,GAAG5C,KAAK,CAACgC,GAAD,CAAL,CAASY,EAAT,KAAgBtD,SAAhB,GAA4BoF,EAA5B,GAAiC1E,KAAK,CAACgC,GAAD,CAAL,CAASY,EAA/C,CAJ0B,CAIyB;;AAEnDgE,MAAAA,KAAK,CAACC,IAAN,CAAW,CAAC9H,CAAC,CAAC,CAAC0F,EAAE,GAAG9B,EAAN,IAAY,CAAb,CAAF,EAAmB5D,CAAC,CAAC,CAAC2F,EAAE,GAAG9B,EAAN,IAAY,CAAb,CAApB,CAAX,EAN0B,CAMwB;;AAElD,aAAOgE,KAAK,CAAC/F,MAAb,EAAqB;AAAA,yBACR+F,KAAK,CAACE,GAAN,EADQ;;AAAA;;AAClBtB,QAAAA,EADkB;AACdC,QAAAA,EADc;AACK;AAExB,YAAIR,GAAG,CAACzC,GAAJ,CAAQgD,EAAR,EAAYC,EAAZ,KAAmBP,GAAG,CAAC1C,GAAJ,CAAQgD,EAAR,EAAYC,EAAZ,CAAnB,IAAsCkB,GAAG,CAACnE,GAAJ,CAAQgD,EAAR,EAAYC,EAAZ,CAA1C,EAA2D,SAHxC,CAGkD;AACrE;;AAEAkB,QAAAA,GAAG,CAACvH,GAAJ,CAAQoG,EAAR,EAAYC,EAAZ;;AAEA,aAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;AAC1BxG,UAAAA,CAAC,GAAGiF,EAAE,GAAGgB,KAAK,CAACO,CAAD,CAAd;AACAvG,UAAAA,CAAC,GAAGiF,EAAE,GAAGgB,KAAK,CAACM,CAAD,CAAd;AACA,cAAI,CAACJ,GAAG,CAACvD,WAAJ,CAAgB7C,CAAhB,EAAmBC,CAAnB,EAAsBD,CAAtB,EAAyBC,CAAzB,CAAL,EAAkCoG,KAAK,CAACC,IAAN,CAAW,CAACtG,CAAD,EAAIC,CAAJ,CAAX;AACnC,SAZkB,CAYjB;;;AAGFD,QAAAA,CAAC,GAAGxB,CAAC,CAAC8E,MAAF,CAAS2B,EAAT,CAAJ;AACAhF,QAAAA,CAAC,GAAGzB,CAAC,CAAC8E,MAAF,CAAS4B,EAAT,CAAJ;AACAE,QAAAA,EAAE,GAAGD,OAAL;AACAE,QAAAA,EAAE,GAAGhG,MAAL,CAlBmB,CAkBN;;AAEb,YAAI,CAACwD,WAAW,CAAC7C,CAAD,EAAIC,CAAJ,EAAO8D,SAAP,EAAkBF,UAAlB,EAA8BzE,KAA9B,EAAqCC,MAArC,CAAZ,IAA4D,CAACoF,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCqB,EAAjC,EAAqCV,GAArC,EAA0CC,GAA1C,CAAtE,IAAwH,CAACF,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCF,UAAjC,EAA6Ca,GAA7C,EAAkD,IAAlD,CAAtI,EAA+L;AAC7L;AACA;AACA,iBAAOW,EAAE,GAAGD,EAAL,IAAW,CAAlB,EAAqB;AACnBE,YAAAA,GAAG,GAAG,CAACF,EAAE,GAAGC,EAAN,IAAY,CAAlB;;AAEA,gBAAIZ,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCuB,GAAjC,EAAsCZ,GAAtC,EAA2CC,GAA3C,CAAb,EAA8D;AAC5DU,cAAAA,EAAE,GAAGC,GAAL;AACD,aAFD,MAEO;AACLF,cAAAA,EAAE,GAAGE,GAAL;AACD;AACF,WAX4L,CAW3L;;;AAGF,cAAIF,EAAE,GAAGD,OAAT,EAAkB;AAChBvG,YAAAA,CAAC,CAACoB,CAAF,GAAMA,CAAN;AACApB,YAAAA,CAAC,CAACqB,CAAF,GAAMA,CAAN;AACAkF,YAAAA,OAAO,GAAGC,EAAV;AACAG,YAAAA,WAAW,GAAG,IAAd;AACD;AACF;AACF,OAjDyB,CAiDxB;AACF;;;AAGA,UAAI,CAACA,WAAD,IAAgB,CAAC9B,aAArB,EAAoC;AAClC;AACAW,QAAAA,SAAS,GAAGnB,IAAI,CAACoB,GAAL,CAASjC,EAAE,GAAG8B,EAAL,GAAU7B,EAAV,GAAe8B,EAAxB,CAAZ;AACAnE,QAAAA,CAAC,GAAG,CAACkE,EAAE,GAAG9B,EAAN,IAAY,CAAhB;AACAnC,QAAAA,CAAC,GAAG,CAACkE,EAAE,GAAG9B,EAAN,IAAY,CAAhB,CAJkC,CAIf;;AAEnB,YAAI+B,SAAS,IAAIH,YAAb,IAA6B,CAACpB,WAAW,CAAC7C,CAAD,EAAIC,CAAJ,EAAO8D,SAAP,EAAkBF,UAAlB,EAA8BzE,KAA9B,EAAqCC,MAArC,CAAzC,IAAyF,CAACoF,SAAS,CAACjG,CAAD,EAAIwB,CAAJ,EAAOC,CAAP,EAAU4D,UAAV,EAAsBE,SAAtB,EAAiCF,UAAjC,EAA6Ca,GAA7C,EAAkD,IAAlD,CAAvG,EAAgK;AAC9JT,UAAAA,YAAY,GAAGG,SAAf;AACAxF,UAAAA,CAAC,CAACoB,CAAF,GAAMA,CAAN;AACApB,UAAAA,CAAC,CAACqB,CAAF,GAAMA,CAAN;AACAuF,UAAAA,YAAY,GAAG,IAAf;AACD;AACF;AACF,KA/FiB,CA+FhB;;;AAGF,QAAID,WAAW,IAAIC,YAAnB,EAAiC;AAC/BxF,MAAAA,CAAC,GAAG+D,SAAS,GAAG,CAAhB;AACA9D,MAAAA,CAAC,GAAG4D,UAAU,GAAG,CAAjB;AACAa,MAAAA,GAAG,CAAC/B,QAAJ,CAAanE,CAAC,CAACI,CAAC,CAACoB,CAAF,GAAMA,CAAP,CAAd,EAAyBxB,CAAC,CAACI,CAAC,CAACqB,CAAF,GAAMA,CAAP,CAA1B,EAAqCzB,CAAC,CAACI,CAAC,CAACoB,CAAF,GAAMA,CAAP,CAAtC,EAAiDxB,CAAC,CAACI,CAAC,CAACqB,CAAF,GAAMA,CAAP,CAAlD;AACArB,MAAAA,CAAC,CAAC0F,KAAF,GAAU,QAAV;AACA1F,MAAAA,CAAC,CAAC2F,QAAF,GAAa,QAAb;AACA,aAAO,IAAP;AACD,KAPD,MAOO;AACL,aAAO,KAAP;AACD;AACF,GA5GD;AA6GD;;AAED,IAAMkC,MAAM,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,MAApB,CAAf;AAAA,IACMC,SAAS,GAAG,CAAC,QAAD,EAAW,QAAX,EAAqB,KAArB,CADlB;;AAEA,SAASC,cAAT,CAAyBnI,CAAzB,EAA4BgF,OAA5B,EAAqCoD,OAArC,EAA8CC,OAA9C,EAAuD/B,UAAvD,EAAmE;AACjE,MAAM1F,KAAK,GAAGZ,CAAC,CAACY,KAAhB;AAAA,MACMC,MAAM,GAAGb,CAAC,CAACa,MADjB;AAAA,MAEMqF,GAAG,GAAGlB,OAAO,CAAC,CAAD,CAFnB;AAAA,MAGMmB,GAAG,GAAGnB,OAAO,CAAC,CAAD,CAHnB;AAAA,MAIMI,CAAC,GAAGiD,OAAO,CAACvG,MAJlB;AAKA,SAAO,UAAU1B,CAAV,EAAa;AAClB,QAAME,QAAQ,GAAGF,CAAC,CAACE,QAAnB;AAAA,QACM+E,UAAU,GAAGjF,CAAC,CAAC+E,KAAF,CAAQG,QAD3B,CADkB,CAEmB;;AAErC,QAAI,CAACgB,UAAD,KAAgBhG,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAd,IAAmBA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAjC,IAAsCA,QAAQ,CAAC,CAAD,CAAR,GAAcM,KAApD,IAA6DN,QAAQ,CAAC,CAAD,CAAR,GAAcO,MAA3F,CAAJ,EAAwG;AACtG,aAAO,KAAP;AACD;;AAED,QAAI0E,SAAS,GAAG,CAAhB;AAAA,QACI+C,EADJ;AAAA,QAEIC,EAFJ;AAAA,QAGIC,QAHJ;AAAA,QAIIC,UAJJ;AAAA,QAKIC,YALJ;AAAA,QAMIhD,EANJ;AAAA,QAOI9B,EAPJ;AAAA,QAQI+B,EARJ;AAAA,QASI9B,EATJ;AAAA,QAUI8E,EAVJ;AAAA,QAWIC,EAXJ;AAAA,QAYI3B,GAZJ;AAAA,QAaIE,GAbJ;AAAA,QAcIC,GAdJ;AAAA,QAeIE,GAfJ,CARkB,CAuBT;;;AAGT,SAAK,IAAIrE,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGmC,CAApB,EAAuB,EAAEnC,GAAzB,EAA4B;AAC1BqF,MAAAA,EAAE,GAAG,CAACF,OAAO,CAACnF,GAAD,CAAP,GAAa,GAAd,IAAqB,CAA1B;AACAsF,MAAAA,EAAE,GAAG,CAACH,OAAO,CAACnF,GAAD,CAAP,KAAe,GAAf,GAAqB,GAAtB,IAA6B,CAAlC;AACAuF,MAAAA,QAAQ,GAAGF,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAnB,IAAwBF,OAAO,CAACpF,GAAD,CAAP,GAAa,CAAhD;AACAwF,MAAAA,UAAU,GAAGH,EAAE,IAAIC,EAAN,GAAW9D,IAAI,CAACoE,OAAhB,GAA0B,CAAvC;AACAH,MAAAA,YAAY,GAAGL,OAAO,CAACpF,GAAD,CAAP,GAAa,CAAb,GAAiB,CAAC,CAAlB,GAAsB,CAArC;AACAyC,MAAAA,EAAE,GAAGpF,QAAQ,CAAC,IAAIgI,EAAL,CAAR,GAAmBD,OAAO,CAACpF,GAAD,CAAP,GAAaqF,EAAb,GAAkBG,UAA1C;AACAG,MAAAA,EAAE,GAAGtI,QAAQ,CAAC,IAAIiI,EAAL,CAAR,GAAmBG,YAAY,GAAGrD,UAAf,GAA4BkD,EAA5B,GAAiC,CAApD,GAAwDF,OAAO,CAACpF,GAAD,CAAP,GAAasF,EAAb,GAAkBE,UAA/E;AACA9C,MAAAA,EAAE,GAAGiD,EAAE,GAAGvD,UAAU,GAAG,CAAvB;AACAxB,MAAAA,EAAE,GAAG+E,EAAE,GAAGvD,UAAU,GAAG,CAAvB;AACA4B,MAAAA,GAAG,GAAGjH,CAAC,CAAC0F,EAAD,CAAP;AACA0B,MAAAA,GAAG,GAAGpH,CAAC,CAAC2F,EAAD,CAAP;AACA2B,MAAAA,GAAG,GAAGtH,CAAC,CAAC6D,EAAD,CAAP;;AAEA,UAAIyC,UAAJ,EAAgB;AACdW,QAAAA,GAAG,GAAGA,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcA,GAApB;AACAG,QAAAA,GAAG,GAAGA,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcA,GAApB;AACAE,QAAAA,GAAG,GAAGA,GAAG,IAAItH,CAAC,CAACa,MAAT,GAAkBb,CAAC,CAACa,MAAF,GAAW,CAA7B,GAAiCyG,GAAvC;AACD;;AAED,UAAI,CAAC/B,SAAL,EAAgB;AACd;AACA,YAAI,CAACuD,IAAI,CAAC7B,GAAD,EAAMA,GAAN,EAAWG,GAAX,EAAgBE,GAAhB,EAAqBpB,GAArB,EAA0BC,GAA1B,EAA+BT,EAA/B,EAAmCA,EAAnC,EAAuCC,EAAvC,EAA2C9B,EAA3C,EAA+CvD,QAA/C,EAAyDkI,QAAzD,CAAT,EAA6E;AAC3E;AACA;AACD,SAHD,MAGO;AACL;AACAjD,UAAAA,SAAS,GAAGhG,WAAW,CAACqB,KAAZ,CAAkBR,CAAC,CAAC+E,KAApB,EAA2B/E,CAAC,CAAC+E,KAAF,CAAQK,IAAnC,CAAZ;AACD;AACF;;AAEDmD,MAAAA,EAAE,GAAGjD,EAAE,GAAGgD,YAAY,GAAGnD,SAAf,GAA2B+C,EAA3B,GAAgC,CAA1C;AACA5C,MAAAA,EAAE,GAAGiD,EAAE,GAAGpD,SAAS,GAAG,CAAtB;AACA3B,MAAAA,EAAE,GAAG+E,EAAE,GAAGpD,SAAS,GAAG,CAAtB;AACA0B,MAAAA,GAAG,GAAGjH,CAAC,CAAC0F,EAAD,CAAP;AACAyB,MAAAA,GAAG,GAAGnH,CAAC,CAAC4D,EAAD,CAAP;;AAEA,UAAI0C,UAAJ,EAAgB;AACdW,QAAAA,GAAG,GAAGA,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcA,GAApB;AACAE,QAAAA,GAAG,GAAGA,GAAG,IAAInH,CAAC,CAACY,KAAT,GAAiBZ,CAAC,CAACY,KAAF,GAAU,CAA3B,GAA+BuG,GAArC;AACD;;AAED,UAAI2B,IAAI,CAAC7B,GAAD,EAAME,GAAN,EAAWC,GAAX,EAAgBE,GAAhB,EAAqBpB,GAArB,EAA0BC,GAA1B,EAA+BT,EAA/B,EAAmC9B,EAAnC,EAAuC+B,EAAvC,EAA2C9B,EAA3C,EAA+CvD,QAA/C,EAAyDkI,QAAzD,CAAR,EAA4E;AAC1E;AACApI,QAAAA,CAAC,CAACoB,CAAF,GAAM,CAAC8G,EAAD,GAAMK,EAAN,GAAWL,EAAE,GAAGI,YAAL,GAAoB,CAApB,GAAwB9E,EAAxB,GAA6B8B,EAA9C;AACAtF,QAAAA,CAAC,CAACqB,CAAF,GAAM,CAAC8G,EAAD,GAAMK,EAAN,GAAWL,EAAE,GAAGG,YAAL,GAAoB,CAApB,GAAwB7E,EAAxB,GAA6B8B,EAA9C;AACAvF,QAAAA,CAAC,CAAC0F,KAAF,GAAUmC,MAAM,CAACK,EAAE,GAAGI,YAAL,GAAoB,CAArB,CAAhB;AACAtI,QAAAA,CAAC,CAAC2F,QAAF,GAAamC,SAAS,CAACK,EAAE,GAAGG,YAAL,GAAoB,CAArB,CAAtB;AACAxC,QAAAA,GAAG,CAAC/B,QAAJ,CAAa8C,GAAb,EAAkBG,GAAlB,EAAuBD,GAAvB,EAA4BG,GAA5B;AACA,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD,GAhFD;AAiFD,C,CAAC;;;AAEF,SAASwB,IAAT,CAAc7B,GAAd,EAAmBE,GAAnB,EAAwBC,GAAxB,EAA6BE,GAA7B,EAAkCpB,GAAlC,EAAuCC,GAAvC,EAA4CT,EAA5C,EAAgD9B,EAAhD,EAAoD+B,EAApD,EAAwD9B,EAAxD,EAA4DvD,QAA5D,EAAsEkI,QAAtE,EAAgF;AAC9E,SAAO,EAAEtC,GAAG,CAAC7B,WAAJ,CAAgB4C,GAAhB,EAAqBG,GAArB,EAA0BD,GAA1B,EAA+BG,GAA/B,MAAwCkB,QAAQ,IAAIrC,GAAZ,GAAkBA,GAAG,CAACxC,QAAJ,CAAasD,GAAb,EAAkBG,GAAlB,EAAuBD,GAAvB,EAA4BG,GAA5B,KAAoC,CAACyB,aAAa,CAACrD,EAAD,EAAKC,EAAL,EAAS/B,EAAT,EAAaC,EAAb,EAAiBvD,QAAjB,CAApE,GAAiG4F,GAAG,CAACvC,QAAJ,CAAasD,GAAb,EAAkBG,GAAlB,EAAuBD,GAAvB,EAA4BG,GAA5B,CAAzI,CAAF,CAAP;AACD;;AAED,SAASyB,aAAT,CAAuBrD,EAAvB,EAA2BC,EAA3B,EAA+B/B,EAA/B,EAAmCC,EAAnC,EAAuCvD,QAAvC,EAAiD;AAC/C,SAAOA,QAAQ,CAAC,CAAD,CAAR,IAAeoF,EAAf,IAAqB9B,EAAE,IAAItD,QAAQ,CAAC,CAAD,CAAnC,IAA0CA,QAAQ,CAAC,CAAD,CAAR,IAAeqF,EAAzD,IAA+D9B,EAAE,IAAIvD,QAAQ,CAAC,CAAD,CAApF;AACD;;AAED,IAAM0I,GAAG,GAAG,GAAZ;AAAA,IACMC,MAAM,GAAG,GADf;AAAA,IAEMC,MAAM,GAAG,GAFf;AAAA,IAGMC,IAAI,GAAG,GAHb;AAAA,IAIMC,MAAM,GAAG,GAJf;AAAA,IAKMC,KAAK,GAAG,GALd,C,CAKmB;;AAEnB,IAAMC,UAAU,GAAG;AACjB,cAAYN,GAAG,GAAGG,IADD;AAEjB,SAAOH,GAAG,GAAGI,MAFI;AAGjB,eAAaJ,GAAG,GAAGK,KAHF;AAIjB,UAAQJ,MAAM,GAAGE,IAJA;AAKjB,YAAUF,MAAM,GAAGG,MALF;AAMjB,WAASH,MAAM,GAAGI,KAND;AAOjB,iBAAeH,MAAM,GAAGC,IAPP;AAQjB,YAAUD,MAAM,GAAGE,MARF;AASjB,kBAAgBF,MAAM,GAAGG;AATR,CAAnB;AAWA,IAAME,cAAc,GAAG;AACrB,WAASxE,mBADY;AAErB,oBAAkBwB,2BAFG;AAGrB,eAAaoB;AAHQ,CAAvB;;AAKA,SAAS6B,WAAT,CAAsBC,KAAtB,EAA6BC,IAA7B,EAAmCC,OAAnC,EAA4CC,MAA5C,EAAoDC,MAApD,EAA4DpJ,UAA5D,EAAwEwE,aAAxE,EAAuF6E,UAAvF,EAAmG5E,SAAnG,EAA8GX,OAA9G,EAAuHwF,MAAvH,EAA+H;AAC7H;AACA,MAAI,CAACN,KAAK,CAAC3H,MAAX,EAAmB,OAAO2H,KAAP;AACnB,MAAMO,SAAS,GAAGvF,IAAI,CAACC,GAAL,CAASkF,MAAM,CAAC9H,MAAhB,EAAwB+H,MAAM,CAAC/H,MAA/B,CAAlB;AAAA,MACMuG,OAAO,GAAG4B,UAAU,CAACL,MAAD,EAASI,SAAT,CAD1B;AAAA,MAEM5B,OAAO,GAAG8B,UAAU,CAACL,MAAD,EAASG,SAAT,CAF1B;AAAA,MAGM/H,QAAQ,GAAGkI,QAAQ,CAACV,KAAK,CAAC,CAAD,CAAL,CAAStE,KAAV,CAHzB;AAAA,MAIMiF,SAAS,GAAGnI,QAAQ,KAAK,OAAb,IAAwBwH,KAAK,CAAC,CAAD,CAAL,CAAStE,KAAT,CAAelE,KAAf,CAAqBiE,SAArB,EAAgCjD,QAJ1E;AAAA,MAKMtB,WAAW,GAAGyJ,SAAS,KAAK,MALlC;AAAA,MAMM9J,QAAQ,GAAG+J,YAAY,CAACpI,QAAD,EAAWmI,SAAX,EAAsBN,UAAtB,EAAkC5E,SAAlC,CAN7B;AAAA,MAOMoB,UAAU,GAAG/B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK+F,QAPnD;AAAA,MAQMtK,CAAC,GAAGsE,MAAM,CAACoF,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,EAAmBpD,UAAU,GAAG,CAAH,GAAO/B,OAApC,CARhB;AAAA,MASMgG,gBAAgB,GAAG5J,WAAW,IAAIoJ,MAAM,KAAK,OATnD,CAH6H,CAYjE;;AAE5D,MAAM9J,IAAI,GAAGwJ,KAAK,CAACtH,GAAN,CAAU,UAAA/B,CAAC;AAAA,WAAK;AAC3B+E,MAAAA,KAAK,EAAE/E,CADoB;AAE3BoK,MAAAA,OAAO,EAAE,CAFkB;AAG3BhJ,MAAAA,CAAC,EAAEjB,SAHwB;AAI3BkB,MAAAA,CAAC,EAAElB,SAJwB;AAK3BuF,MAAAA,KAAK,EAAEvF,SALoB;AAM3BwF,MAAAA,QAAQ,EAAExF,SANiB;AAO3BD,MAAAA,QAAQ,EAAEA,QAAQ,CAACF,CAAD;AAPS,KAAL;AAAA,GAAX,CAAb;AASA,MAAI4E,OAAJ;;AAEA,MAAI,CAACuF,gBAAL,EAAuB;AACrB;AACA,QAAIZ,OAAJ,EAAa;AACX1J,MAAAA,IAAI,CAACwK,IAAL,CAAU,UAACC,CAAD,EAAIC,CAAJ;AAAA,eAAUhB,OAAO,CAACe,CAAC,CAACvF,KAAH,EAAUwF,CAAC,CAACxF,KAAZ,CAAjB;AAAA,OAAV;AACD,KAJoB,CAInB;;;AAGF,QAAIzE,WAAW,GAAG,KAAlB;;AAEA,SAAK,IAAIuC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGmF,OAAO,CAACtG,MAAZ,IAAsB,CAACpB,WAAvC,EAAoD,EAAEuC,GAAtD,EAAyD;AACvD;AACA;AACAvC,MAAAA,WAAW,GAAG0H,OAAO,CAACnF,GAAD,CAAP,KAAe,GAAf,IAAsBoF,OAAO,CAACpF,GAAD,CAAP,GAAa,CAAjD;AACD,KAboB,CAanB;AACF;;;AAGA,QAAIhB,QAAQ,KAAKgD,aAAa,IAAItE,WAAtB,CAAZ,EAAgD;AAC9CF,MAAAA,UAAU,GAAG,CAACgJ,KAAK,CAACtH,GAAN,CAAU,UAAA/B,CAAC;AAAA,eAAIA,CAAC,CAAC+E,KAAN;AAAA,OAAX,CAAD,EAA0ByF,MAA1B,CAAiCnK,UAAjC,CAAb;AACD,KAnBoB,CAmBnB;;;AAGFuE,IAAAA,OAAO,GAAGvE,UAAU,CAACqB,MAAX,GAAoBtB,WAAW,CAACR,CAAD,EAAIS,UAAJ,EAAgBC,WAAhB,EAA6BC,WAA7B,CAA/B,GAA2EZ,WAAW,CAACC,CAAD,EAAIiF,aAAa,IAAIhF,IAArB,CAAhG;AACD,GAhD4H,CAgD3H;;;AAGF,MAAM4K,KAAK,GAAGlK,WAAW,GAAG4I,cAAc,CAACQ,MAAD,CAAd,CAAuB/J,CAAvB,EAA0BgF,OAA1B,EAAmCC,aAAnC,EAAkDC,SAAlD,EAA6DoB,UAA7D,CAAH,GAA8E6B,cAAc,CAACnI,CAAD,EAAIgF,OAAJ,EAAaoD,OAAb,EAAsBC,OAAtB,EAA+B/B,UAA/B,CAArH,CAnD6H,CAmDoC;;AAEjKrG,EAAAA,IAAI,CAACE,OAAL,CAAa,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACoK,OAAF,GAAY,CAACK,KAAK,CAACzK,CAAD,CAAtB;AAAA,GAAd;AACA,SAAOH,IAAP;AACD;;AAED,SAASgK,UAAT,CAAoBpF,CAApB,EAAuBiG,KAAvB,EAA8B;AAC5B,MAAMzC,OAAO,GAAG,IAAI0C,YAAJ,CAAiBD,KAAjB,CAAhB;AAAA,MACM1F,CAAC,GAAGP,CAAC,CAAC/C,MADZ;;AAGA,OAAK,IAAImB,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGmC,CAApB,EAAuB,EAAEnC,GAAzB;AAA4BoF,IAAAA,OAAO,CAACpF,GAAD,CAAP,GAAa4B,CAAC,CAAC5B,GAAD,CAAD,IAAQ,CAArB;AAA5B;;AAEA,OAAK,IAAIA,GAAC,GAAGmC,CAAb,EAAgBnC,GAAC,GAAG6H,KAApB,EAA2B,EAAE7H,GAA7B;AAAgCoF,IAAAA,OAAO,CAACpF,GAAD,CAAP,GAAaoF,OAAO,CAACjD,CAAC,GAAG,CAAL,CAApB;AAAhC;;AAEA,SAAOiD,OAAP;AACD;;AAED,SAAS6B,UAAT,CAAoBrF,CAApB,EAAuBiG,KAAvB,EAA8B;AAC5B,MAAM1C,OAAO,GAAG,IAAI4C,SAAJ,CAAcF,KAAd,CAAhB;AAAA,MACM1F,CAAC,GAAGP,CAAC,CAAC/C,MADZ;;AAGA,OAAK,IAAImB,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGmC,CAApB,EAAuB,EAAEnC,GAAzB;AAA4BmF,IAAAA,OAAO,CAACnF,GAAD,CAAP,IAAcqG,UAAU,CAACzE,CAAC,CAAC5B,GAAD,CAAF,CAAxB;AAA5B;;AAEA,OAAK,IAAIA,IAAC,GAAGmC,CAAb,EAAgBnC,IAAC,GAAG6H,KAApB,EAA2B,EAAE7H,IAA7B;AAAgCmF,IAAAA,OAAO,CAACnF,IAAD,CAAP,GAAamF,OAAO,CAAChD,CAAC,GAAG,CAAL,CAApB;AAAhC;;AAEA,SAAOgD,OAAP;AACD;;AAED,SAAS+B,QAAT,CAAkB7H,IAAlB,EAAwB;AACtB,SAAOA,IAAI,IAAIA,IAAI,CAACN,IAAb,IAAqBM,IAAI,CAACN,IAAL,CAAUC,QAAtC;AACD;AACD;;;;;;;;;AASA,SAASoI,YAAT,CAAsBpI,QAAtB,EAAgCmI,SAAhC,EAA2CN,UAA3C,EAAuD5E,SAAvD,EAAkE;AAChE,MAAM+F,EAAE,GAAG,SAALA,EAAK,CAAA7K,CAAC;AAAA,WAAI,CAACA,CAAC,CAACoB,CAAH,EAAMpB,CAAC,CAACoB,CAAR,EAAWpB,CAAC,CAACoB,CAAb,EAAgBpB,CAAC,CAACqB,CAAlB,EAAqBrB,CAAC,CAACqB,CAAvB,EAA0BrB,CAAC,CAACqB,CAA5B,CAAJ;AAAA,GAAZ;;AAEA,MAAI,CAACQ,QAAL,EAAe;AACb,WAAOgJ,EAAP,CADa,CACF;AACZ,GAFD,MAEO,IAAIhJ,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,MAAxC,EAAgD;AACrD,WAAO,UAAA7B,CAAC;AAAA,aAAI6K,EAAE,CAAC7K,CAAC,CAAC+E,KAAH,CAAN;AAAA,KAAR;AACD,GAFM,MAEA,IAAIiF,SAAS,KAAK,MAAlB,EAA0B;AAC/B,WAAO,UAAAhK,CAAC,EAAI;AACV,UAAMa,KAAK,GAAGb,CAAC,CAAC+E,KAAF,CAAQlE,KAAR,CAAciE,SAAd,EAAyBjE,KAAvC;AACA,aAAOgK,EAAE,CAAChK,KAAK,CAACa,MAAN,GAAeb,KAAK,CAAC6I,UAAU,KAAK,OAAf,GAAyB,CAAzB,GAA6B7I,KAAK,CAACa,MAAN,GAAe,CAA7C,CAApB,GAAsE;AAC9EN,QAAAA,CAAC,EAAE0J,GAD2E;AAE9EzJ,QAAAA,CAAC,EAAEyJ;AAF2E,OAAvE,CAAT;AAID,KAND;AAOD,GARM,MAQA;AACL,WAAO,UAAA9K,CAAC,EAAI;AACV,UAAMuK,CAAC,GAAGvK,CAAC,CAAC+E,KAAF,CAAQgG,MAAlB;AACA,aAAO,CAACR,CAAC,CAACjF,EAAH,EAAO,CAACiF,CAAC,CAACjF,EAAF,GAAOiF,CAAC,CAAC/G,EAAV,IAAgB,CAAvB,EAA0B+G,CAAC,CAAC/G,EAA5B,EAAgC+G,CAAC,CAAChF,EAAlC,EAAsC,CAACgF,CAAC,CAAChF,EAAF,GAAOgF,CAAC,CAAC9G,EAAV,IAAgB,CAAtD,EAAyD8G,CAAC,CAAC9G,EAA3D,CAAP;AACD,KAHD;AAID;AACF;;AAED,IAAMuH,MAAM,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,SAAX,EAAsB,OAAtB,EAA+B,UAA/B,CAAf;AACA,IAAMC,OAAO,GAAG,CAAC,UAAD,EAAa,MAAb,EAAqB,aAArB,EAAoC,KAApC,EAA2C,QAA3C,EAAqD,WAArD,EAAkE,OAAlE,EAA2E,cAA3E,CAAhB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAASC,KAAT,CAAeC,MAAf,EAAuB;AACrBlM,EAAAA,SAAS,CAACmM,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDD,KAAK,CAACG,UAAN,GAAmB;AACjB1J,EAAAA,IAAI,EAAE,OADW;AAEjB2J,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AADF,GAFO;AAKjBJ,EAAAA,MAAM,EAAE,CAAC;AACPK,IAAAA,IAAI,EAAE,MADC;AAEP7J,IAAAA,IAAI,EAAE,QAFC;AAGPpC,IAAAA,KAAK,EAAE,IAHA;AAIPmC,IAAAA,MAAM,EAAE,CAJD;AAKP+J,IAAAA,QAAQ,EAAE;AALH,GAAD,EAML;AACDD,IAAAA,IAAI,EAAE,MADL;AAED7J,IAAAA,IAAI,EAAE;AAFL,GANK,EASL;AACD6J,IAAAA,IAAI,EAAE,QADL;AAED7J,IAAAA,IAAI,EAAE,QAFL;AAGDpC,IAAAA,KAAK,EAAE,IAHN;AAIDmM,IAAAA,OAAO,EAAET;AAJR,GATK,EAcL;AACDO,IAAAA,IAAI,EAAE,QADL;AAED7J,IAAAA,IAAI,EAAE,QAFL;AAGDpC,IAAAA,KAAK,EAAE,IAHN;AAIDmM,IAAAA,OAAO,EAAE,CAAC,CAAD;AAJR,GAdK,EAmBL;AACDF,IAAAA,IAAI,EAAE,SADL;AAED7J,IAAAA,IAAI,EAAE,QAFL;AAGD+J,IAAAA,OAAO,EAAE,CAHR;AAIDC,IAAAA,IAAI,EAAE;AAJL,GAnBK,EAwBL;AACDH,IAAAA,IAAI,EAAE,YADL;AAED7J,IAAAA,IAAI,EAAE,QAFL;AAGDiK,IAAAA,MAAM,EAAE,CAAC,OAAD,EAAU,KAAV,CAHP;AAIDF,IAAAA,OAAO,EAAE;AAJR,GAxBK,EA6BL;AACDF,IAAAA,IAAI,EAAE,WADL;AAED7J,IAAAA,IAAI,EAAE,QAFL;AAGD+J,IAAAA,OAAO,EAAE;AAHR,GA7BK,EAiCL;AACDF,IAAAA,IAAI,EAAE,eADL;AAED7J,IAAAA,IAAI,EAAE,SAFL;AAGD+J,IAAAA,OAAO,EAAE;AAHR,GAjCK,EAqCL;AACDF,IAAAA,IAAI,EAAE,YADL;AAED7J,IAAAA,IAAI,EAAE,MAFL;AAGDpC,IAAAA,KAAK,EAAE;AAHN,GArCK,EAyCL;AACDiM,IAAAA,IAAI,EAAE,QADL;AAED7J,IAAAA,IAAI,EAAE,QAFL;AAGD+J,IAAAA,OAAO,EAAE;AAHR,GAzCK,EA6CL;AACDF,IAAAA,IAAI,EAAE,IADL;AAED7J,IAAAA,IAAI,EAAE,QAFL;AAGDpC,IAAAA,KAAK,EAAE,IAHN;AAIDmC,IAAAA,MAAM,EAAEsJ,MAAM,CAACtJ,MAJd;AAKDgK,IAAAA,OAAO,EAAEV;AALR,GA7CK;AALS,CAAnB;AA0DA5L,QAAQ,CAAC8L,KAAD,EAAQjM,SAAR,EAAmB;AACzB4M,EAAAA,SADyB,qBACfpH,CADe,EACZqH,KADY,EACL;AAClB,aAASC,IAAT,CAAcC,KAAd,EAAqB;AACnB,UAAMC,CAAC,GAAGxH,CAAC,CAACuH,KAAD,CAAX;AACA,aAAO3M,UAAU,CAAC4M,CAAD,CAAV,IAAiBH,KAAK,CAACI,QAAN,CAAeD,CAAC,CAACE,MAAjB,CAAxB;AACD;;AAED,QAAMC,GAAG,GAAG3H,CAAC,CAACyH,QAAF,EAAZ;;AAEA,QAAI,EAAEE,GAAG,IAAIN,KAAK,CAACO,OAAN,CAAcP,KAAK,CAACQ,OAApB,CAAP,IAAuCP,IAAI,CAAC,MAAD,CAA7C,CAAJ,EAA4D;;AAE5D,QAAI,CAACtH,CAAC,CAAC6E,IAAH,IAAW7E,CAAC,CAAC6E,IAAF,CAAO5H,MAAP,KAAkB,CAAjC,EAAoC;AAClCpC,MAAAA,KAAK,CAAC,gEAAD,CAAL;AACD;;AAED,QAAMiN,EAAE,GAAG9H,CAAC,CAAC8H,EAAF,IAAQvB,MAAnB,CAdkB,CAcS;;AAE3B5B,IAAAA,WAAW,CAAC0C,KAAK,CAACU,WAAN,CAAkBV,KAAK,CAACW,MAAxB,EAAgCxK,MAAhC,IAA0C,EAA3C,EAA+CwC,CAAC,CAAC6E,IAAjD,EAAuD7E,CAAC,CAAC4F,IAAzD,EAA+D9K,KAAK,CAACkF,CAAC,CAAC+E,MAAF,IAAY,IAAZ,GAAmB,CAAnB,GAAuB/E,CAAC,CAAC+E,MAA1B,CAApE,EAAuGjK,KAAK,CAACkF,CAAC,CAACgF,MAAF,IAAYwB,OAAb,CAA5G,EAAmIxG,CAAC,CAACpE,UAAF,IAAgB,EAAnJ,EAAuJoE,CAAC,CAACI,aAAF,KAAoB,KAA3K,EAAkLJ,CAAC,CAACiF,UAAF,IAAgB,KAAlM,EAAyMjF,CAAC,CAACK,SAAF,IAAe,CAAxN,EAA2NL,CAAC,CAACN,OAAF,KAAchE,SAAd,GAA0B,CAA1B,GAA8BsE,CAAC,CAACN,OAA3P,EAAoQM,CAAC,CAACkF,MAAF,IAAY,OAAhR,CAAX,CAAoS5J,OAApS,CAA4S,UAAA2M,CAAC,EAAI;AAC/S;AACA,UAAMC,CAAC,GAAGD,CAAC,CAAC3H,KAAZ;AACA4H,MAAAA,CAAC,CAACJ,EAAE,CAAC,CAAD,CAAH,CAAD,GAAWG,CAAC,CAACtL,CAAb;AACAuL,MAAAA,CAAC,CAACJ,EAAE,CAAC,CAAD,CAAH,CAAD,GAAWG,CAAC,CAACrL,CAAb;AACAsL,MAAAA,CAAC,CAACJ,EAAE,CAAC,CAAD,CAAH,CAAD,GAAWG,CAAC,CAACtC,OAAb;AACAuC,MAAAA,CAAC,CAACJ,EAAE,CAAC,CAAD,CAAH,CAAD,GAAWG,CAAC,CAAChH,KAAb;AACAiH,MAAAA,CAAC,CAACJ,EAAE,CAAC,CAAD,CAAH,CAAD,GAAWG,CAAC,CAAC/G,QAAb;AACD,KARD;AASA,WAAOmG,KAAK,CAACc,MAAN,CAAaR,GAAb,EAAkBb,QAAlB,CAA2BgB,EAA3B,CAAP;AACD;AA3BwB,CAAnB,CAAR;AA+BA,SAASrB,KAAK,IAAI2B,KAAlB","sourcesContent":["import { canvas } from 'vega-canvas';\nimport { rederive, Transform } from 'vega-dataflow';\nimport { Marks, textMetrics } from 'vega-scenegraph';\nimport { inherits, isFunction, error, array } from 'vega-util';\n\nconst ALPHA_MASK = 0xff000000; // alpha value equivalent to opacity 0.0625\n\nconst INSIDE_OPACITY_IN_ALPHA = 0x10000000;\nconst INSIDE_OPACITY = 0.0625;\nfunction baseBitmaps($, data) {\n  const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\n\n  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n  return [bitmap, undefined];\n}\nfunction markBitmaps($, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  const width = $.width,\n        height = $.height,\n        border = labelInside || isGroupArea,\n        context = canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\n\n  avoidMarks.forEach(items => draw(context, items, border)); // get canvas buffer, create bitmaps\n\n  const buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),\n        layer1 = $.bitmap(),\n        layer2 = border && $.bitmap(); // populate bitmap layers\n\n  let x, y, u, v, alpha;\n\n  for (y = 0; y < height; ++y) {\n    for (x = 0; x < width; ++x) {\n      alpha = buffer[y * width + x] & ALPHA_MASK;\n\n      if (alpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea) layer1.set(u, v); // update interior bitmap\n\n        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  const type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(group => {\n      group.items.forEach(mark => draw(context, mark.items, interior));\n    });\n  } else {\n    Marks[type].draw(context, {\n      items: interior ? items.map(prepare) : items\n    });\n  }\n}\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\n\n\nfunction prepare(source) {\n  const item = rederive(source, {});\n\n  if (item.stroke) {\n    item.strokeOpacity = 1;\n  }\n\n  if (item.fill) {\n    item.fillOpacity = INSIDE_OPACITY;\n    item.stroke = '#000';\n    item.strokeOpacity = 1;\n    item.strokeWidth = 2;\n  }\n\n  return item;\n}\n\nconst DIV = 5,\n      // bit shift from x, y index to bit vector array index\nMOD = 31,\n      // bit mask for index lookup within a bit vector\nSIZE = 32,\n      // individual bit vector size\nRIGHT0 = new Uint32Array(SIZE + 1),\n      // left-anchored bit vectors, full -> 0\nRIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\n\nfor (let i = 1; i <= SIZE; ++i) {\n  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nfunction Bitmap (w, h) {\n  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n    get: (x, y) => {\n      const index = y * w + x;\n      return array[index >>> DIV] & 1 << (index & MOD);\n    },\n    set: (x, y) => {\n      const index = y * w + x;\n\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n    clear: (x, y) => {\n      const index = y * w + x;\n\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n    getRange: (x, y, x2, y2) => {\n      let r = y2,\n          start,\n          end,\n          indexStart,\n          indexEnd;\n\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n\n          for (let i = indexStart + 1; i < indexEnd; ++i) {\n            if (array[i]) return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    setRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n        }\n      }\n    },\n    clearRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n        }\n      }\n    },\n    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n  };\n}\n\nfunction scaler (width, height, padding) {\n  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\n        w = ~~((width + 2 * padding + ratio) / ratio),\n        h = ~~((height + 2 * padding + ratio) / ratio),\n        scale = _ => ~~((_ + padding) / ratio);\n\n  scale.invert = _ => _ * ratio - padding;\n\n  scale.bitmap = () => Bitmap(w, h);\n\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n  return scale;\n}\n\nfunction placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height; // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        areaWidth; // for each area sample point\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n    d.align = 'center';\n\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n\nfunction outOfBounds(x, y, textWidth, textHeight, width, height) {\n  let r = textWidth / 2;\n  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\n}\n\nfunction _outOfBounds() {\n  return false;\n}\n\nfunction collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = textWidth * h / (textHeight * 2),\n        x1 = $(x - w),\n        x2 = $(x + w),\n        y1 = $(y - (h = h / 2)),\n        y2 = $(y + h);\n  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\n\nfunction _collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = textWidth * h / (textHeight * 2);\n  let x1 = $(x - w),\n      x2 = $(x + w),\n      y1 = $(y - (h = h / 2)),\n      y2 = $(y + h);\n  x1 = x1 > 0 ? x1 : 0;\n  y1 = y1 > 0 ? y1 : 0;\n  x2 = x2 < $.width ? x2 : $.width - 1;\n  y2 = y2 < $.height ? y2 : $.height - 1;\n  return bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\n\nfunction getTests(infPadding) {\n  return infPadding ? [_collision, _outOfBounds] : [collision, outOfBounds];\n}\n\nfunction placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex, infPadding) {\n  const width = $.width,\n        height = $.height,\n        [collision, outOfBounds] = getTests(infPadding),\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1]; // area outlines\n\n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    const x = $.invert(_x),\n          y = $.invert(_y);\n    let lo = maxSize,\n        hi = height,\n        mid;\n\n    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      } // place label if current lower bound exceeds prior max font size\n\n\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  } // try to place a label within an input area mark\n\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        _x1,\n        _xMid,\n        _x2,\n        _y1,\n        _yMid,\n        _y2,\n        areaWidth,\n        result,\n        swapTmp; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\n\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // search along the line from mid point between the 2 border to upper border\n\n\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst X_DIR = [-1, -1, 1, 1];\nconst Y_DIR = [-1, 1, -1, 1];\nfunction placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex, infPadding) {\n  const width = $.width,\n        height = $.height,\n        [collision, outOfBounds] = getTests(infPadding),\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1],\n        // area outlines\n  bm2 = $.bitmap(); // flood-fill visitations\n  // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text),\n          // label height\n    stack = []; // flood fill stack\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        lo,\n        hi,\n        mid,\n        areaWidth; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack\n\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\n\n      while (stack.length) {\n        [_x, _y] = stack.pop(); // exit if point already marked\n\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n\n        bm2.set(_x, _y);\n\n        for (let j = 0; j < 4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        } // unscale point back to x, y space\n\n\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          } // place label if current lower bound exceeds prior max font size\n\n\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst Aligns = ['right', 'center', 'left'],\n      Baselines = ['bottom', 'middle', 'top'];\nfunction placeMarkLabel ($, bitmaps, anchors, offsets, infPadding) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        bm1 = bitmaps[1],\n        n = offsets.length;\n  return function (d) {\n    const boundary = d.boundary,\n          textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\n\n    if (!infPadding && (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height)) {\n      return false;\n    }\n\n    let textWidth = 0,\n        dx,\n        dy,\n        isInside,\n        sizeFactor,\n        insideFactor,\n        x1,\n        x2,\n        y1,\n        y2,\n        xc,\n        yc,\n        _x1,\n        _x2,\n        _y1,\n        _y2; // for each anchor and offset\n\n\n    for (let i = 0; i < n; ++i) {\n      dx = (anchors[i] & 0x3) - 1;\n      dy = (anchors[i] >>> 0x2 & 0x3) - 1;\n      isInside = dx === 0 && dy === 0 || offsets[i] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[i] < 0 ? -1 : 1;\n      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (infPadding) {\n        _x1 = _x1 < 0 ? 0 : _x1;\n        _y1 = _y1 < 0 ? 0 : _y1;\n        _y2 = _y2 >= $.height ? $.height - 1 : _y2;\n      }\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + insideFactor * textWidth * dx / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (infPadding) {\n        _x1 = _x1 < 0 ? 0 : _x1;\n        _x2 = _x2 >= $.width ? $.width - 1 : _x2;\n      }\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n} // Test if a label with the given dimensions can be added without overlap\n\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));\n}\n\nfunction isInMarkBound(x1, y1, x2, y2, boundary) {\n  return boundary[0] <= x1 && x2 <= boundary[2] && boundary[3] <= y1 && y2 <= boundary[5];\n}\n\nconst TOP = 0x0,\n      MIDDLE = 0x4,\n      BOTTOM = 0x8,\n      LEFT = 0x0,\n      CENTER = 0x1,\n      RIGHT = 0x2; // Mapping from text anchor to number representation\n\nconst anchorCode = {\n  'top-left': TOP + LEFT,\n  'top': TOP + CENTER,\n  'top-right': TOP + RIGHT,\n  'left': MIDDLE + LEFT,\n  'middle': MIDDLE + CENTER,\n  'right': MIDDLE + RIGHT,\n  'bottom-left': BOTTOM + LEFT,\n  'bottom': BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\nconst placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\nfunction labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\n  // early exit for empty data\n  if (!texts.length) return texts;\n  const positions = Math.max(offset.length, anchor.length),\n        offsets = getOffsets(offset, positions),\n        anchors = getAnchors(anchor, positions),\n        marktype = markType(texts[0].datum),\n        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n        isGroupArea = grouptype === 'area',\n        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n        infPadding = padding === null || padding === Infinity,\n        $ = scaler(size[0], size[1], infPadding ? 0 : padding),\n        isNaiveGroupArea = isGroupArea && method === 'naive'; // prepare text mark data for placing\n\n  const data = texts.map(d => ({\n    datum: d,\n    opacity: 0,\n    x: undefined,\n    y: undefined,\n    align: undefined,\n    baseline: undefined,\n    boundary: boundary(d)\n  }));\n  let bitmaps;\n\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort((a, b) => compare(a.datum, b.datum));\n    } // flag indicating if label can be placed inside its base mark\n\n\n    let labelInside = false;\n\n    for (let i = 0; i < anchors.length && !labelInside; ++i) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n    } // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n\n\n    if (marktype && (avoidBaseMark || isGroupArea)) {\n      avoidMarks = [texts.map(d => d.datum)].concat(avoidMarks);\n    } // generate bitmaps for layout calculation\n\n\n    bitmaps = avoidMarks.length ? markBitmaps($, avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\n  } // generate label placement function\n\n\n  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex, infPadding) : placeMarkLabel($, bitmaps, anchors, offsets, infPadding); // place all labels\n\n  data.forEach(d => d.opacity = +place(d));\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  const offsets = new Float64Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;\n\n  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];\n\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  const anchors = new Int8Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];\n\n  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];\n\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the beginning or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\n\n\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  } else if (marktype === 'line' || marktype === 'area') {\n    return d => xy(d.datum);\n  } else if (grouptype === 'line') {\n    return d => {\n      const items = d.datum.items[markIndex].items;\n      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\n        x: NaN,\n        y: NaN\n      });\n    };\n  } else {\n    return d => {\n      const b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n\nconst Output = ['x', 'y', 'opacity', 'align', 'baseline'];\nconst Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\n\nfunction Label(params) {\n  Transform.call(this, null, params);\n}\nLabel.Definition = {\n  type: 'Label',\n  metadata: {\n    modifies: true\n  },\n  params: [{\n    name: 'size',\n    type: 'number',\n    array: true,\n    length: 2,\n    required: true\n  }, {\n    name: 'sort',\n    type: 'compare'\n  }, {\n    name: 'anchor',\n    type: 'string',\n    array: true,\n    default: Anchors\n  }, {\n    name: 'offset',\n    type: 'number',\n    array: true,\n    default: [1]\n  }, {\n    name: 'padding',\n    type: 'number',\n    default: 0,\n    null: true\n  }, {\n    name: 'lineAnchor',\n    type: 'string',\n    values: ['start', 'end'],\n    default: 'end'\n  }, {\n    name: 'markIndex',\n    type: 'number',\n    default: 0\n  }, {\n    name: 'avoidBaseMark',\n    type: 'boolean',\n    default: true\n  }, {\n    name: 'avoidMarks',\n    type: 'data',\n    array: true\n  }, {\n    name: 'method',\n    type: 'string',\n    default: 'naive'\n  }, {\n    name: 'as',\n    type: 'string',\n    array: true,\n    length: Output.length,\n    default: Output\n  }]\n};\ninherits(Label, Transform, {\n  transform(_, pulse) {\n    function modp(param) {\n      const p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    const mod = _.modified();\n\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    const as = _.as || Output; // run label layout\n\n    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {\n      // write layout results to data stream\n      const t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n    return pulse.reflow(mod).modifies(as);\n  }\n\n});\n\nexport { Label as label };\n"]},"metadata":{},"sourceType":"module"}