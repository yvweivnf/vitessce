{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { load } from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\nimport { getLodStatus } from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nvar I3STilesetTraverser = /*#__PURE__*/function (_TilesetTraverser) {\n  _inherits(I3STilesetTraverser, _TilesetTraverser);\n\n  var _super = _createSuper(I3STilesetTraverser);\n\n  function I3STilesetTraverser(options) {\n    var _this;\n\n    _classCallCheck(this, I3STilesetTraverser);\n\n    _this = _super.call(this, options);\n\n    _defineProperty(_assertThisInitialized(_this), \"_tileManager\", void 0);\n\n    _this._tileManager = new I3STileManager();\n    return _this;\n  }\n\n  _createClass(I3STilesetTraverser, [{\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState) {\n      tile._lodJudge = getLodStatus(tile, frameState);\n      return tile._lodJudge === 'DIG';\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var _this2 = this;\n\n      var children = tile.header.children || [];\n      var childTiles = tile.children;\n      var tileset = tile.tileset;\n\n      var _iterator = _createForOfIteratorHelper(children),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var child = _step.value;\n          var extendedId = \"\".concat(child.id, \"-\").concat(frameState.viewport.id);\n          var childTile = childTiles && childTiles.find(function (t) {\n            return t.id === extendedId;\n          });\n\n          if (!childTile) {\n            var request = function request() {\n              return _this2._loadTile(child.id, tileset);\n            };\n\n            var cachedRequest = _this2._tileManager.find(extendedId);\n\n            if (!cachedRequest) {\n              if (tileset.tileset.nodePages) {\n                request = function request() {\n                  return tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n                };\n              }\n\n              _this2._tileManager.add(request, extendedId, function (header) {\n                return _this2._onTileLoad(header, tile, extendedId);\n              }, frameState);\n            } else {\n              _this2._tileManager.update(extendedId, frameState);\n            }\n          } else if (childTile) {\n            _this2.updateTile(childTile, frameState);\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_loadTile\",\n    value: function () {\n      var _loadTile2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(nodeId, tileset) {\n        var loader, nodeUrl, options;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                loader = tileset.loader;\n                nodeUrl = tileset.getTileUrl(\"\".concat(tileset.url, \"/nodes/\").concat(nodeId));\n                options = _objectSpread({}, tileset.loadOptions, {\n                  i3s: _objectSpread({}, tileset.loadOptions.i3s, {\n                    isTileHeader: true,\n                    loadContent: false\n                  })\n                });\n                _context.next = 5;\n                return load(nodeUrl, loader, options);\n\n              case 5:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function _loadTile(_x, _x2) {\n        return _loadTile2.apply(this, arguments);\n      }\n\n      return _loadTile;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(header, tile, extendedId) {\n      var childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n      tile.children.push(childTile);\n\n      var frameState = this._tileManager.find(childTile.id).frameState;\n\n      this.updateTile(childTile, frameState);\n\n      if (this._frameNumber === frameState.frameNumber) {\n        this.executeTraversal(childTile, frameState);\n      }\n    }\n  }]);\n\n  return I3STilesetTraverser;\n}(TilesetTraverser);\n\nexport { I3STilesetTraverser as default };","map":{"version":3,"sources":["../../../../src/tileset/traversers/i3s-tileset-traverser.ts"],"names":["constructor","tile","getLodStatus","children","childTiles","tileset","extendedId","child","frameState","childTile","t","request","cachedRequest","header","loader","nodeUrl","options","i3s","isTileHeader","loadContent","load"],"mappings":"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","sourcesContent":["import {load} from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\n\nimport {getLodStatus} from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  private _tileManager: I3STileManager;\n\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState): boolean {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(\n            request,\n            extendedId,\n            (header) => this._onTileLoad(header, tile, extendedId),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n\n    return await load(nodeUrl, loader, options);\n  }\n\n  /**\n   * The callback to init TileHeader instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {TileHeader} tile - the parent TileHeader instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}