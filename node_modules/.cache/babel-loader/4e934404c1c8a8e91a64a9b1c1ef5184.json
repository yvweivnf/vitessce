{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nconst point = {\n  defined: selCmpt => selCmpt.type === 'point',\n  signals: (model, selCmpt, signals) => {\n    var _a;\n\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n    const values = project.items.map(p => {\n      const fieldDef = model.fieldDef(p.channel); // Binned fields should capture extents, for a range test against the raw field.\n\n      return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` + `${datum}[${stringValue(model.vgField(p.channel, {\n        binSuffix: 'end'\n      }))}]]` : `${datum}[${stringValue(p.field)}]`;\n    }).join(', '); // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n    const events = selCmpt.events;\n    const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((acc, cmpt) => {\n      return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n    }, []).map(b => `indexof(item().mark.name, '${b}') < 0`).join(' && ');\n    const test = `datum && item().mark.marktype !== 'group'` + (brushes ? ` && ${brushes}` : '');\n    return signals.concat([{\n      name: name + TUPLE,\n      on: events ? [{\n        events,\n        update: `${test} ? {${update}: [${values}]} : null`,\n        force: true\n      }] : []\n    }]);\n  }\n};\nexport default point;","map":{"version":3,"sources":["../../../../src/compile/selection/point.ts"],"names":[],"mappings":"AACA,SAAQ,WAAR,QAA0B,WAA1B;AACA,SAA2B,KAA3B,EAAkC,QAAlC,QAAiD,GAAjD;AACA,SAAQ,IAAR,QAAmB,YAAnB;AACA,SAAQ,KAAR,QAAoB,YAApB;AACA,SAAQ,YAAR,QAA2B,WAA3B;AAEA,MAAM,KAAK,GAA+B;AACxC,EAAA,OAAO,EAAE,OAAO,IAAI,OAAO,CAAC,IAAR,KAAiB,OADG;AAGxC,EAAA,OAAO,EAAE,CAAC,KAAD,EAAQ,OAAR,EAAiB,OAAjB,KAA4B;;;AACnC,UAAM,IAAI,GAAG,OAAO,CAAC,IAArB;AACA,UAAM,QAAQ,GAAG,IAAI,GAAG,YAAxB;AACA,UAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;AACA,UAAM,KAAK,GAAG,0CAAd;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,KAAR,CACZ,GADY,CACR,CAAC,IAAG;AACP,YAAM,QAAQ,GAAG,KAAK,CAAC,QAAN,CAAe,CAAC,CAAC,OAAjB,CAAjB,CADO,CAEP;;AACA,aAAO,CAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,GAAV,IACH,IAAI,KAAK,IAAI,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB,EAAzB,CAAD,CAA8B,KAAtD,GACE,GAAG,KAAK,IAAI,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB;AAAC,QAAA,SAAS,EAAE;AAAZ,OAAzB,CAAD,CAA8C,IAFpE,GAGH,GAAG,KAAK,IAAI,WAAW,CAAC,CAAC,CAAC,KAAH,CAAS,GAHpC;AAID,KARY,EASZ,IATY,CASP,IATO,CAAf,CALmC,CAgBnC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAM,MAAM,GAAG,SAAS,QAAQ,CAAC,KAAD,CAAO,aAAa,QAAQ,UAA5D;AAEA,UAAM,MAAM,GAAa,OAAO,CAAC,MAAjC;AAEA,UAAM,OAAO,GAAG,IAAI,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,SAAN,CAAgB,SAAhB,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,EAAzB,GAA6B,EAA9B,CAAJ,CACb,MADa,CACN,CAAC,GAAD,EAAM,IAAN,KAAc;AACpB,aAAO,IAAI,CAAC,IAAL,KAAc,UAAd,GAA2B,GAAG,CAAC,MAAJ,CAAW,IAAI,CAAC,IAAL,GAAY,KAAvB,CAA3B,GAA2D,GAAlE;AACD,KAHa,EAGX,EAHW,EAIb,GAJa,CAIT,CAAC,IAAI,8BAA8B,CAAC,QAJ3B,EAKb,IALa,CAKR,MALQ,CAAhB;AAOA,UAAM,IAAI,GAAG,2CAAA,IAA+C,OAAO,GAAG,OAAO,OAAO,EAAjB,GAAsB,EAA5E,CAAb;AAEA,WAAO,OAAO,CAAC,MAAR,CAAe,CACpB;AACE,MAAA,IAAI,EAAE,IAAI,GAAG,KADf;AAEE,MAAA,EAAE,EAAE,MAAM,GACN,CACE;AACE,QAAA,MADF;AAEE,QAAA,MAAM,EAAE,GAAG,IAAI,OAAO,MAAM,MAAM,MAAM,WAF1C;AAGE,QAAA,KAAK,EAAE;AAHT,OADF,CADM,GAQN;AAVN,KADoB,CAAf,CAAP;AAcD;AArDuC,CAA1C;AAwDA,eAAe,KAAf","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nconst point = {\n    defined: selCmpt => selCmpt.type === 'point',\n    signals: (model, selCmpt, signals) => {\n        var _a;\n        const name = selCmpt.name;\n        const fieldsSg = name + TUPLE_FIELDS;\n        const project = selCmpt.project;\n        const datum = '(item().isVoronoi ? datum.datum : datum)';\n        const values = project.items\n            .map(p => {\n            const fieldDef = model.fieldDef(p.channel);\n            // Binned fields should capture extents, for a range test against the raw field.\n            return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin)\n                ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n                    `${datum}[${stringValue(model.vgField(p.channel, { binSuffix: 'end' }))}]]`\n                : `${datum}[${stringValue(p.field)}]`;\n        })\n            .join(', ');\n        // Only add a discrete selection to the store if a datum is present _and_\n        // the interaction isn't occurring on a group mark. This guards against\n        // polluting interactive state with invalid values in faceted displays\n        // as the group marks are also data-driven. We force the update to account\n        // for constant null states but varying toggles (e.g., shift-click in\n        // whitespace followed by a click in whitespace; the store should only\n        // be cleared on the second click).\n        const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n        const events = selCmpt.events;\n        const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})\n            .reduce((acc, cmpt) => {\n            return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n        }, [])\n            .map(b => `indexof(item().mark.name, '${b}') < 0`)\n            .join(' && ');\n        const test = `datum && item().mark.marktype !== 'group'` + (brushes ? ` && ${brushes}` : '');\n        return signals.concat([\n            {\n                name: name + TUPLE,\n                on: events\n                    ? [\n                        {\n                            events,\n                            update: `${test} ? {${update}: [${values}]} : null`,\n                            force: true\n                        }\n                    ]\n                    : []\n            }\n        ]);\n    }\n};\nexport default point;\n//# sourceMappingURL=point.js.map"]},"metadata":{},"sourceType":"module"}