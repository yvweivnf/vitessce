{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _toArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toArray\";\nimport _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/wrapNativeSuper\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(product);\n\nvar registry = new Map();\n\nfunction addCodec(id, importFn) {\n  registry.set(id, importFn);\n}\n\nfunction getCodec(_x) {\n  return _getCodec.apply(this, arguments);\n}\n\nfunction _getCodec() {\n  _getCodec = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee46(config) {\n    var codec;\n    return _regeneratorRuntime.wrap(function _callee46$(_context50) {\n      while (1) {\n        switch (_context50.prev = _context50.next) {\n          case 0:\n            if (registry.has(config.id)) {\n              _context50.next = 2;\n              break;\n            }\n\n            throw new Error(\"Compression codec \".concat(config.id, \" is not supported by Zarr.js yet.\"));\n\n          case 2:\n            _context50.next = 4;\n            return registry.get(config.id)();\n\n          case 4:\n            codec = _context50.sent;\n            return _context50.abrupt(\"return\", codec.fromConfig(config));\n\n          case 6:\n          case \"end\":\n            return _context50.stop();\n        }\n      }\n    }, _callee46);\n  }));\n  return _getCodec.apply(this, arguments);\n}\n\nfunction createProxy(mapping) {\n  return new Proxy(mapping, {\n    set: function set(target, key, value, _receiver) {\n      return target.setItem(key, value);\n    },\n    get: function get(target, key, _receiver) {\n      return target.getItem(key);\n    },\n    deleteProperty: function deleteProperty(target, key) {\n      return target.deleteItem(key);\n    },\n    has: function has(target, key) {\n      return target.containsItem(key);\n    }\n  });\n}\n\nfunction isZarrError(err) {\n  return typeof err === 'object' && err !== null && '__zarr__' in err;\n}\n\nfunction isKeyError(o) {\n  return isZarrError(o) && o.__zarr__ === 'KeyError';\n} // Custom error messages, note we have to patch the prototype of the\n// errors to fix `instanceof` calls, see:\n// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n\n\nvar ContainsArrayError = /*#__PURE__*/function (_Error) {\n  _inherits(ContainsArrayError, _Error);\n\n  var _super = _createSuper(ContainsArrayError);\n\n  function ContainsArrayError(path) {\n    var _this;\n\n    _classCallCheck(this, ContainsArrayError);\n\n    _this = _super.call(this, \"path \".concat(path, \" contains an array\"));\n    _this.__zarr__ = 'ContainsArrayError';\n    Object.setPrototypeOf(_assertThisInitialized(_this), ContainsArrayError.prototype);\n    return _this;\n  }\n\n  return ContainsArrayError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ContainsGroupError = /*#__PURE__*/function (_Error2) {\n  _inherits(ContainsGroupError, _Error2);\n\n  var _super2 = _createSuper(ContainsGroupError);\n\n  function ContainsGroupError(path) {\n    var _this2;\n\n    _classCallCheck(this, ContainsGroupError);\n\n    _this2 = _super2.call(this, \"path \".concat(path, \" contains a group\"));\n    _this2.__zarr__ = 'ContainsGroupError';\n    Object.setPrototypeOf(_assertThisInitialized(_this2), ContainsGroupError.prototype);\n    return _this2;\n  }\n\n  return ContainsGroupError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ArrayNotFoundError = /*#__PURE__*/function (_Error3) {\n  _inherits(ArrayNotFoundError, _Error3);\n\n  var _super3 = _createSuper(ArrayNotFoundError);\n\n  function ArrayNotFoundError(path) {\n    var _this3;\n\n    _classCallCheck(this, ArrayNotFoundError);\n\n    _this3 = _super3.call(this, \"array not found at path \".concat(path));\n    _this3.__zarr__ = 'ArrayNotFoundError';\n    Object.setPrototypeOf(_assertThisInitialized(_this3), ArrayNotFoundError.prototype);\n    return _this3;\n  }\n\n  return ArrayNotFoundError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar GroupNotFoundError = /*#__PURE__*/function (_Error4) {\n  _inherits(GroupNotFoundError, _Error4);\n\n  var _super4 = _createSuper(GroupNotFoundError);\n\n  function GroupNotFoundError(path) {\n    var _this4;\n\n    _classCallCheck(this, GroupNotFoundError);\n\n    _this4 = _super4.call(this, \"ground not found at path \".concat(path));\n    _this4.__zarr__ = 'GroupNotFoundError';\n    Object.setPrototypeOf(_assertThisInitialized(_this4), GroupNotFoundError.prototype);\n    return _this4;\n  }\n\n  return GroupNotFoundError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar PathNotFoundError = /*#__PURE__*/function (_Error5) {\n  _inherits(PathNotFoundError, _Error5);\n\n  var _super5 = _createSuper(PathNotFoundError);\n\n  function PathNotFoundError(path) {\n    var _this5;\n\n    _classCallCheck(this, PathNotFoundError);\n\n    _this5 = _super5.call(this, \"nothing not found at path \".concat(path));\n    _this5.__zarr__ = 'PathNotFoundError';\n    Object.setPrototypeOf(_assertThisInitialized(_this5), PathNotFoundError.prototype);\n    return _this5;\n  }\n\n  return PathNotFoundError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar PermissionError = /*#__PURE__*/function (_Error6) {\n  _inherits(PermissionError, _Error6);\n\n  var _super6 = _createSuper(PermissionError);\n\n  function PermissionError(message) {\n    var _this6;\n\n    _classCallCheck(this, PermissionError);\n\n    _this6 = _super6.call(this, message);\n    _this6.__zarr__ = 'PermissionError';\n    Object.setPrototypeOf(_assertThisInitialized(_this6), PermissionError.prototype);\n    return _this6;\n  }\n\n  return PermissionError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar KeyError = /*#__PURE__*/function (_Error7) {\n  _inherits(KeyError, _Error7);\n\n  var _super7 = _createSuper(KeyError);\n\n  function KeyError(key) {\n    var _this7;\n\n    _classCallCheck(this, KeyError);\n\n    _this7 = _super7.call(this, \"key \".concat(key, \" not present\"));\n    _this7.__zarr__ = 'KeyError';\n    Object.setPrototypeOf(_assertThisInitialized(_this7), KeyError.prototype);\n    return _this7;\n  }\n\n  return KeyError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar TooManyIndicesError = /*#__PURE__*/function (_RangeError) {\n  _inherits(TooManyIndicesError, _RangeError);\n\n  var _super8 = _createSuper(TooManyIndicesError);\n\n  function TooManyIndicesError(selection, shape) {\n    var _this8;\n\n    _classCallCheck(this, TooManyIndicesError);\n\n    _this8 = _super8.call(this, \"too many indices for array; expected \".concat(shape.length, \", got \").concat(selection.length));\n    _this8.__zarr__ = 'TooManyIndicesError';\n    Object.setPrototypeOf(_assertThisInitialized(_this8), TooManyIndicesError.prototype);\n    return _this8;\n  }\n\n  return TooManyIndicesError;\n}( /*#__PURE__*/_wrapNativeSuper(RangeError));\n\nvar BoundsCheckError = /*#__PURE__*/function (_RangeError2) {\n  _inherits(BoundsCheckError, _RangeError2);\n\n  var _super9 = _createSuper(BoundsCheckError);\n\n  function BoundsCheckError(message) {\n    var _this9;\n\n    _classCallCheck(this, BoundsCheckError);\n\n    _this9 = _super9.call(this, message);\n    _this9.__zarr__ = 'BoundsCheckError';\n    Object.setPrototypeOf(_assertThisInitialized(_this9), BoundsCheckError.prototype);\n    return _this9;\n  }\n\n  return BoundsCheckError;\n}( /*#__PURE__*/_wrapNativeSuper(RangeError));\n\nvar InvalidSliceError = /*#__PURE__*/function (_RangeError3) {\n  _inherits(InvalidSliceError, _RangeError3);\n\n  var _super10 = _createSuper(InvalidSliceError);\n\n  function InvalidSliceError(from, to, stepSize, reason) {\n    var _this10;\n\n    _classCallCheck(this, InvalidSliceError);\n\n    _this10 = _super10.call(this, \"slice arguments slice(\".concat(from, \", \").concat(to, \", \").concat(stepSize, \") invalid: \").concat(reason));\n    _this10.__zarr__ = 'InvalidSliceError';\n    Object.setPrototypeOf(_assertThisInitialized(_this10), InvalidSliceError.prototype);\n    return _this10;\n  }\n\n  return InvalidSliceError;\n}( /*#__PURE__*/_wrapNativeSuper(RangeError));\n\nvar NegativeStepError = /*#__PURE__*/function (_Error8) {\n  _inherits(NegativeStepError, _Error8);\n\n  var _super11 = _createSuper(NegativeStepError);\n\n  function NegativeStepError() {\n    var _this11;\n\n    _classCallCheck(this, NegativeStepError);\n\n    _this11 = _super11.call(this, \"Negative step size is not supported when indexing.\");\n    _this11.__zarr__ = 'NegativeStepError';\n    Object.setPrototypeOf(_assertThisInitialized(_this11), NegativeStepError.prototype);\n    return _this11;\n  }\n\n  return NegativeStepError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ValueError = /*#__PURE__*/function (_Error9) {\n  _inherits(ValueError, _Error9);\n\n  var _super12 = _createSuper(ValueError);\n\n  function ValueError(message) {\n    var _this12;\n\n    _classCallCheck(this, ValueError);\n\n    _this12 = _super12.call(this, message);\n    _this12.__zarr__ = 'ValueError';\n    Object.setPrototypeOf(_assertThisInitialized(_this12), ValueError.prototype);\n    return _this12;\n  }\n\n  return ValueError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar HTTPError = /*#__PURE__*/function (_Error10) {\n  _inherits(HTTPError, _Error10);\n\n  var _super13 = _createSuper(HTTPError);\n\n  function HTTPError(code) {\n    var _this13;\n\n    _classCallCheck(this, HTTPError);\n\n    _this13 = _super13.call(this, code);\n    _this13.__zarr__ = 'HTTPError';\n    Object.setPrototypeOf(_assertThisInitialized(_this13), HTTPError.prototype);\n    return _this13;\n  }\n\n  return HTTPError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction slice(start) {\n  var stop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  // tslint:disable-next-line: strict-type-predicates\n  if (start === undefined) {\n    // Not possible in typescript\n    throw new InvalidSliceError(start, stop, step, \"The first argument must not be undefined\");\n  }\n\n  if (typeof start === \"string\" && start !== \":\" || typeof stop === \"string\" && stop !== \":\") {\n    // Note in typescript this will never happen with type checking.\n    throw new InvalidSliceError(start, stop, step, \"Arguments can only be integers, \\\":\\\" or null\");\n  } // slice(5) === slice(null, 5)\n\n\n  if (stop === undefined) {\n    stop = start;\n    start = null;\n  } // if (start !== null && stop !== null && start > stop) {\n  //     throw new InvalidSliceError(start, stop, step, \"to is higher than from\");\n  // }\n\n\n  return {\n    start: start === \":\" ? null : start,\n    stop: stop === \":\" ? null : stop,\n    step: step,\n    _slice: true\n  };\n}\n/**\r\n * Port of adjustIndices\r\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L243\r\n */\n\n\nfunction adjustIndices(start, stop, step, length) {\n  if (start < 0) {\n    start += length;\n\n    if (start < 0) {\n      start = step < 0 ? -1 : 0;\n    }\n  } else if (start >= length) {\n    start = step < 0 ? length - 1 : length;\n  }\n\n  if (stop < 0) {\n    stop += length;\n\n    if (stop < 0) {\n      stop = step < 0 ? -1 : 0;\n    }\n  } else if (stop >= length) {\n    stop = step < 0 ? length - 1 : length;\n  }\n\n  if (step < 0) {\n    if (stop < start) {\n      var _length = Math.floor((start - stop - 1) / -step + 1);\n\n      return [start, stop, step, _length];\n    }\n  } else {\n    if (start < stop) {\n      var _length2 = Math.floor((stop - start - 1) / step + 1);\n\n      return [start, stop, step, _length2];\n    }\n  }\n\n  return [start, stop, step, 0];\n}\n/**\r\n * Port of slice.indices(n) and PySlice_Unpack\r\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L166\r\n *  https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L198\r\n *\r\n * Behaviour might be slightly different as it's a weird hybrid implementation.\r\n */\n\n\nfunction sliceIndices(slice, length) {\n  var start;\n  var stop;\n  var step;\n\n  if (slice.step === null) {\n    step = 1;\n  } else {\n    step = slice.step;\n  }\n\n  if (slice.start === null) {\n    start = step < 0 ? Number.MAX_SAFE_INTEGER : 0;\n  } else {\n    start = slice.start;\n\n    if (start < 0) {\n      start += length;\n    }\n  }\n\n  if (slice.stop === null) {\n    stop = step < 0 ? -Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;\n  } else {\n    stop = slice.stop;\n\n    if (stop < 0) {\n      stop += length;\n    }\n  } // This clips out of bounds slices\n\n\n  var s = adjustIndices(start, stop, step, length);\n  start = s[0];\n  stop = s[1];\n  step = s[2]; // The output length\n\n  length = s[3]; // With out of bounds slicing these two assertions are not useful.\n  // if (stop > length) throw new Error(\"Stop greater than length\");\n  // if (start >= length) throw new Error(\"Start greater than or equal to length\");\n\n  if (step === 0) throw new Error(\"Step size 0 is invalid\");\n  return [start, stop, step, length];\n}\n\nfunction ensureArray(selection) {\n  if (!Array.isArray(selection)) {\n    return [selection];\n  }\n\n  return selection;\n}\n\nfunction checkSelectionLength(selection, shape) {\n  if (selection.length > shape.length) {\n    throw new TooManyIndicesError(selection, shape);\n  }\n}\n/**\r\n * Returns both the sliceIndices per dimension and the output shape after slicing.\r\n */\n\n\nfunction selectionToSliceIndices(selection, shape) {\n  var sliceIndicesResult = [];\n  var outShape = [];\n\n  for (var i = 0; i < selection.length; i++) {\n    var s = selection[i];\n\n    if (typeof s === \"number\") {\n      sliceIndicesResult.push(s);\n    } else {\n      var x = sliceIndices(s, shape[i]);\n      var dimLength = x[3];\n      outShape.push(dimLength);\n      sliceIndicesResult.push(x);\n    }\n  }\n\n  return [sliceIndicesResult, outShape];\n}\n/**\r\n * This translates \"...\", \":\", null into a list of slices or non-negative integer selections of length shape\r\n */\n\n\nfunction normalizeArraySelection(selection, shape) {\n  var convertIntegerSelectionToSlices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  selection = replaceEllipsis(selection, shape);\n\n  for (var i = 0; i < selection.length; i++) {\n    var dimSelection = selection[i];\n\n    if (typeof dimSelection === \"number\") {\n      if (convertIntegerSelectionToSlices) {\n        selection[i] = slice(dimSelection, dimSelection + 1, 1);\n      } else {\n        selection[i] = normalizeIntegerSelection(dimSelection, shape[i]);\n      }\n    } else if (isIntegerArray(dimSelection)) {\n      throw new TypeError(\"Integer array selections are not supported (yet)\");\n    } else if (dimSelection === \":\" || dimSelection === null) {\n      selection[i] = slice(null, null, 1);\n    }\n  }\n\n  return selection;\n}\n\nfunction replaceEllipsis(selection, shape) {\n  selection = ensureArray(selection);\n  var ellipsisIndex = -1;\n  var numEllipsis = 0;\n\n  for (var i = 0; i < selection.length; i++) {\n    if (selection[i] === \"...\") {\n      ellipsisIndex = i;\n      numEllipsis += 1;\n    }\n  }\n\n  if (numEllipsis > 1) {\n    throw new RangeError(\"an index can only have a single ellipsis ('...')\");\n  }\n\n  if (numEllipsis === 1) {\n    // count how many items to left and right of ellipsis\n    var numItemsLeft = ellipsisIndex;\n    var numItemsRight = selection.length - (numItemsLeft + 1);\n    var numItems = selection.length - 1; // All non-ellipsis items\n\n    if (numItems >= shape.length) {\n      // Ellipsis does nothing, just remove it\n      selection = selection.filter(function (x) {\n        return x !== \"...\";\n      });\n    } else {\n      // Replace ellipsis with as many slices are needed for number of dims\n      var numNewItems = shape.length - numItems;\n      var newItem = selection.slice(0, numItemsLeft).concat(new Array(numNewItems).fill(null));\n\n      if (numItemsRight > 0) {\n        newItem = newItem.concat(selection.slice(selection.length - numItemsRight));\n      }\n\n      selection = newItem;\n    }\n  } // Fill out selection if not completely specified\n\n\n  if (selection.length < shape.length) {\n    var numMissing = shape.length - selection.length;\n    selection = selection.concat(new Array(numMissing).fill(null));\n  }\n\n  checkSelectionLength(selection, shape);\n  return selection;\n}\n\nfunction normalizeIntegerSelection(dimSelection, dimLength) {\n  // Note: Maybe we should convert to integer or warn if dimSelection is not an integer\n  // handle wraparound\n  if (dimSelection < 0) {\n    dimSelection = dimLength + dimSelection;\n  } // handle out of bounds\n\n\n  if (dimSelection >= dimLength || dimSelection < 0) {\n    throw new BoundsCheckError(\"index out of bounds for dimension with length \".concat(dimLength));\n  }\n\n  return dimSelection;\n}\n\nfunction isInteger(s) {\n  return typeof s === \"number\";\n}\n\nfunction isIntegerArray(s) {\n  if (!Array.isArray(s)) {\n    return false;\n  }\n\n  var _iterator = _createForOfIteratorHelper(s),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var e = _step.value;\n\n      if (typeof e !== \"number\") {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return true;\n}\n\nfunction isSlice(s) {\n  if (s !== null && s[\"_slice\"] === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isContiguousSlice(s) {\n  return isSlice(s) && (s.step === null || s.step === 1);\n}\n\nfunction isContiguousSelection(selection) {\n  selection = ensureArray(selection);\n\n  for (var i = 0; i < selection.length; i++) {\n    var s = selection[i];\n\n    if (!(isIntegerArray(s) || isContiguousSlice(s) || s === \"...\")) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction product() {\n  var _len,\n      iterables,\n      _key,\n      iterators,\n      results,\n      i,\n      _args = arguments;\n\n  return _regeneratorRuntime.wrap(function product$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          for (_len = _args.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n            iterables[_key] = _args[_key];\n          }\n\n          if (!(iterables.length === 0)) {\n            _context.next = 3;\n            break;\n          }\n\n          return _context.abrupt(\"return\");\n\n        case 3:\n          // make a list of iterators from the iterables\n          iterators = iterables.map(function (it) {\n            return it();\n          });\n          results = iterators.map(function (it) {\n            return it.next();\n          }); // Disabled to allow empty inputs\n          // if (results.some(r => r.done)) {\n          //     throw new Error(\"Input contains an empty iterator.\");\n          // }\n\n          i = 0;\n\n        case 6:\n          if (!results[i].done) {\n            _context.next = 13;\n            break;\n          }\n\n          // reset the current iterator\n          iterators[i] = iterables[i]();\n          results[i] = iterators[i].next(); // advance, and exit if we've reached the end\n\n          if (!(++i >= iterators.length)) {\n            _context.next = 11;\n            break;\n          }\n\n          return _context.abrupt(\"return\");\n\n        case 11:\n          _context.next = 16;\n          break;\n\n        case 13:\n          _context.next = 15;\n          return results.map(function (_ref) {\n            var value = _ref.value;\n            return value;\n          });\n\n        case 15:\n          i = 0;\n\n        case 16:\n          results[i] = iterators[i].next();\n\n        case 17:\n          _context.next = 6;\n          break;\n\n        case 19:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nvar BasicIndexer = /*#__PURE__*/function () {\n  function BasicIndexer(selection, array) {\n    _classCallCheck(this, BasicIndexer);\n\n    selection = normalizeArraySelection(selection, array.shape); // Setup per-dimension indexers\n\n    this.dimIndexers = [];\n    var arrayShape = array.shape;\n\n    for (var i = 0; i < arrayShape.length; i++) {\n      var dimSelection = selection[i];\n      var dimLength = arrayShape[i];\n      var dimChunkLength = array.chunks[i];\n\n      if (dimSelection === null) {\n        dimSelection = slice(null);\n      }\n\n      if (isInteger(dimSelection)) {\n        this.dimIndexers.push(new IntDimIndexer(dimSelection, dimLength, dimChunkLength));\n      } else if (isSlice(dimSelection)) {\n        this.dimIndexers.push(new SliceDimIndexer(dimSelection, dimLength, dimChunkLength));\n      } else {\n        throw new RangeError(\"Unspported selection item for basic indexing; expected integer or slice, got \".concat(dimSelection));\n      }\n    }\n\n    this.shape = [];\n\n    var _iterator2 = _createForOfIteratorHelper(this.dimIndexers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var d = _step2.value;\n\n        if (d instanceof SliceDimIndexer) {\n          this.shape.push(d.numItems);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this.dropAxes = null;\n  }\n\n  _createClass(BasicIndexer, [{\n    key: \"iter\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function iter() {\n      var dimIndexerIterables, dimIndexerProduct, _iterator3, _step3, dimProjections, chunkCoords, chunkSelection, outSelection, _iterator4, _step4, p;\n\n      return _regeneratorRuntime.wrap(function iter$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              dimIndexerIterables = this.dimIndexers.map(function (x) {\n                return function () {\n                  return x.iter();\n                };\n              });\n              dimIndexerProduct = product.apply(void 0, _toConsumableArray(dimIndexerIterables));\n              _iterator3 = _createForOfIteratorHelper(dimIndexerProduct);\n              _context2.prev = 3;\n\n              _iterator3.s();\n\n            case 5:\n              if ((_step3 = _iterator3.n()).done) {\n                _context2.next = 16;\n                break;\n              }\n\n              dimProjections = _step3.value;\n              // TODO fix this, I think the product outputs too many combinations\n              chunkCoords = [];\n              chunkSelection = [];\n              outSelection = [];\n              _iterator4 = _createForOfIteratorHelper(dimProjections);\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  p = _step4.value;\n                  chunkCoords.push(p.dimChunkIndex);\n                  chunkSelection.push(p.dimChunkSelection);\n\n                  if (p.dimOutSelection !== null) {\n                    outSelection.push(p.dimOutSelection);\n                  }\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n\n              _context2.next = 14;\n              return {\n                chunkCoords: chunkCoords,\n                chunkSelection: chunkSelection,\n                outSelection: outSelection\n              };\n\n            case 14:\n              _context2.next = 5;\n              break;\n\n            case 16:\n              _context2.next = 21;\n              break;\n\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](3);\n\n              _iterator3.e(_context2.t0);\n\n            case 21:\n              _context2.prev = 21;\n\n              _iterator3.f();\n\n              return _context2.finish(21);\n\n            case 24:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, iter, this, [[3, 18, 21, 24]]);\n    })\n  }]);\n\n  return BasicIndexer;\n}();\n\nvar IntDimIndexer = /*#__PURE__*/function () {\n  function IntDimIndexer(dimSelection, dimLength, dimChunkLength) {\n    _classCallCheck(this, IntDimIndexer);\n\n    dimSelection = normalizeIntegerSelection(dimSelection, dimLength);\n    this.dimSelection = dimSelection;\n    this.dimLength = dimLength;\n    this.dimChunkLength = dimChunkLength;\n    this.numItems = 1;\n  }\n\n  _createClass(IntDimIndexer, [{\n    key: \"iter\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function iter() {\n      var dimChunkIndex, dimOffset, dimChunkSelection, dimOutSelection;\n      return _regeneratorRuntime.wrap(function iter$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              dimChunkIndex = Math.floor(this.dimSelection / this.dimChunkLength);\n              dimOffset = dimChunkIndex * this.dimChunkLength;\n              dimChunkSelection = this.dimSelection - dimOffset;\n              dimOutSelection = null;\n              _context3.next = 6;\n              return {\n                dimChunkIndex: dimChunkIndex,\n                dimChunkSelection: dimChunkSelection,\n                dimOutSelection: dimOutSelection\n              };\n\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, iter, this);\n    })\n  }]);\n\n  return IntDimIndexer;\n}();\n\nvar SliceDimIndexer = /*#__PURE__*/function () {\n  function SliceDimIndexer(dimSelection, dimLength, dimChunkLength) {\n    _classCallCheck(this, SliceDimIndexer);\n\n    // Normalize\n    var _sliceIndices = sliceIndices(dimSelection, dimLength),\n        _sliceIndices2 = _slicedToArray(_sliceIndices, 3),\n        start = _sliceIndices2[0],\n        stop = _sliceIndices2[1],\n        step = _sliceIndices2[2];\n\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n\n    if (this.step < 1) {\n      throw new NegativeStepError();\n    }\n\n    this.dimLength = dimLength;\n    this.dimChunkLength = dimChunkLength;\n    this.numItems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n    this.numChunks = Math.ceil(this.dimLength / this.dimChunkLength);\n  }\n\n  _createClass(SliceDimIndexer, [{\n    key: \"iter\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function iter() {\n      var dimChunkIndexFrom, dimChunkIndexTo, dimChunkIndex, dimOffset, dimLimit, dimChunkLength, dimChunkSelStart, dimChunkSelStop, dimOutOffset, remainder, dimChunkSelection, dimChunkNumItems, dimOutSelection;\n      return _regeneratorRuntime.wrap(function iter$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              dimChunkIndexFrom = Math.floor(this.start / this.dimChunkLength);\n              dimChunkIndexTo = Math.ceil(this.stop / this.dimChunkLength); // Iterate over chunks in range\n\n              dimChunkIndex = dimChunkIndexFrom;\n\n            case 3:\n              if (!(dimChunkIndex < dimChunkIndexTo)) {\n                _context4.next = 20;\n                break;\n              }\n\n              // Compute offsets for chunk within overall array\n              dimOffset = dimChunkIndex * this.dimChunkLength;\n              dimLimit = Math.min(this.dimLength, (dimChunkIndex + 1) * this.dimChunkLength); // Determine chunk length, accounting for trailing chunk\n\n              dimChunkLength = dimLimit - dimOffset;\n              dimChunkSelStart = void 0;\n              dimChunkSelStop = void 0;\n              dimOutOffset = void 0;\n\n              if (this.start < dimOffset) {\n                // Selection starts before current chunk\n                dimChunkSelStart = 0;\n                remainder = (dimOffset - this.start) % this.step;\n\n                if (remainder > 0) {\n                  dimChunkSelStart += this.step - remainder;\n                } // Compute number of previous items, provides offset into output array\n\n\n                dimOutOffset = Math.ceil((dimOffset - this.start) / this.step);\n              } else {\n                // Selection starts within current chunk\n                dimChunkSelStart = this.start - dimOffset;\n                dimOutOffset = 0;\n              }\n\n              if (this.stop > dimLimit) {\n                // Selection ends after current chunk\n                dimChunkSelStop = dimChunkLength;\n              } else {\n                // Selection ends within current chunk\n                dimChunkSelStop = this.stop - dimOffset;\n              }\n\n              dimChunkSelection = slice(dimChunkSelStart, dimChunkSelStop, this.step);\n              dimChunkNumItems = Math.ceil((dimChunkSelStop - dimChunkSelStart) / this.step);\n              dimOutSelection = slice(dimOutOffset, dimOutOffset + dimChunkNumItems);\n              _context4.next = 17;\n              return {\n                dimChunkIndex: dimChunkIndex,\n                dimChunkSelection: dimChunkSelection,\n                dimOutSelection: dimOutSelection\n              };\n\n            case 17:\n              dimChunkIndex++;\n              _context4.next = 3;\n              break;\n\n            case 20:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, iter, this);\n    })\n  }]);\n\n  return SliceDimIndexer;\n}();\n/**\r\n * This should be true only if this javascript is getting executed in Node.\r\n */\n\n\nvar IS_NODE = typeof process !== \"undefined\" && process.versions && process.versions.node; // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction normalizeStoragePath(path) {\n  if (path === null) {\n    return \"\";\n  }\n\n  if (path instanceof String) {\n    path = path.valueOf();\n  } // convert backslash to forward slash\n\n\n  path = path.replace(/\\\\/g, \"/\"); // ensure no leading slash\n\n  while (path.length > 0 && path[0] === '/') {\n    path = path.slice(1);\n  } // ensure no trailing slash\n\n\n  while (path.length > 0 && path[path.length - 1] === '/') {\n    path = path.slice(0, path.length - 1);\n  } // collapse any repeated slashes\n\n\n  path = path.replace(/\\/\\/+/g, \"/\"); // don't allow path segments with just '.' or '..'\n\n  var segments = path.split('/');\n\n  var _iterator5 = _createForOfIteratorHelper(segments),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var s = _step5.value;\n\n      if (s === \".\" || s === \"..\") {\n        throw Error(\"path containing '.' or '..' segment not allowed\");\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return path;\n}\n\nfunction normalizeShape(shape) {\n  if (typeof shape === \"number\") {\n    shape = [shape];\n  }\n\n  return shape.map(function (x) {\n    return Math.floor(x);\n  });\n}\n\nfunction normalizeChunks(chunks, shape) {\n  // Assume shape is already normalized\n  if (chunks === null || chunks === true) {\n    throw new Error(\"Chunk guessing is not supported yet\");\n  }\n\n  if (chunks === false) {\n    return shape;\n  }\n\n  if (typeof chunks === \"number\") {\n    chunks = [chunks];\n  } // handle underspecified chunks\n\n\n  if (chunks.length < shape.length) {\n    // assume chunks across remaining dimensions\n    chunks = chunks.concat(shape.slice(chunks.length));\n  }\n\n  return chunks.map(function (x, idx) {\n    // handle null or -1 in chunks\n    if (x === -1 || x === null) {\n      return shape[idx];\n    } else {\n      return Math.floor(x);\n    }\n  });\n}\n\nfunction normalizeOrder(order) {\n  order = order.toUpperCase();\n  return order;\n}\n\nfunction normalizeDtype(dtype) {\n  return dtype;\n}\n\nfunction normalizeFillValue(fillValue) {\n  return fillValue;\n}\n/**\r\n * Determine whether `item` specifies a complete slice of array with the\r\n *  given `shape`. Used to optimize __setitem__ operations on chunks\r\n * @param item\r\n * @param shape\r\n */\n\n\nfunction isTotalSlice(item, shape) {\n  if (item === null) {\n    return true;\n  }\n\n  if (!Array.isArray(item)) {\n    item = [item];\n  }\n\n  for (var i = 0; i < Math.min(item.length, shape.length); i++) {\n    var it = item[i];\n    if (it === null) continue;\n\n    if (isSlice(it)) {\n      var s = it;\n      var isStepOne = s.step === 1 || s.step === null;\n\n      if (s.start === null && s.stop === null && isStepOne) {\n        continue;\n      }\n\n      if (s.stop - s.start === shape[i] && isStepOne) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return false; // } else {\n    //     console.error(`isTotalSlice unexpected non-slice, got ${it}`);\n    //     return false;\n    // }\n  }\n\n  return true;\n}\n/**\r\n * Checks for === equality of all elements.\r\n */\n\n\nfunction arrayEquals1D(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*\r\n * Determines \"C\" order strides for a given shape array.\r\n * Strides provide integer steps in each dimention to traverse an ndarray.\r\n *\r\n * NOTE: - These strides here are distinct from numpy.ndarray.strides, which describe actual byte steps.\r\n *       - Strides are assumed to be contiguous, so initial step is 1. Thus, output will always be [XX, XX, 1].\r\n */\n\n\nfunction getStrides(shape) {\n  // adapted from https://github.com/scijs/ndarray/blob/master/ndarray.js#L326-L330\n  var ndim = shape.length;\n  var strides = Array(ndim);\n  var step = 1; // init step\n\n  for (var i = ndim - 1; i >= 0; i--) {\n    strides[i] = step;\n    step *= shape[i];\n  }\n\n  return strides;\n}\n/**\r\n * Preserves (double) slashes earlier in the path, so this works better\r\n * for URLs. From https://stackoverflow.com/a/46427607/4178400\r\n * @param args parts of a path or URL to join.\r\n */\n\n\nfunction joinUrlParts() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return args.map(function (part, i) {\n    if (i === 0) {\n      return part.trim().replace(/[\\/]*$/g, '');\n    } else {\n      return part.trim().replace(/(^[\\/]*|[\\/]*$)/g, '');\n    }\n  }).filter(function (x) {\n    return x.length;\n  }).join('/');\n}\n/**\r\n * Swaps byte order in-place for a given TypedArray.\r\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\r\n * @param src TypedArray\r\n */\n\n\nfunction byteSwapInplace(src) {\n  var b = src.BYTES_PER_ELEMENT;\n  if (b === 1) return; // no swapping needed\n\n  if (IS_NODE) {\n    // Use builtin methods for swapping if in Node environment\n    var bytes = Buffer.from(src.buffer, src.byteOffset, src.length * b);\n    if (b === 2) bytes.swap16();\n    if (b === 4) bytes.swap32();\n    if (b === 8) bytes.swap64();\n    return;\n  } // In browser, need to flip manually\n  // Adapted from https://github.com/zbjornson/node-bswap/blob/master/bswap.js\n\n\n  var flipper = new Uint8Array(src.buffer, src.byteOffset, src.length * b);\n  var numFlips = b / 2;\n  var endByteIndex = b - 1;\n  var t;\n\n  for (var i = 0; i < flipper.length; i += b) {\n    for (var j = 0; j < numFlips; j++) {\n      t = flipper[i + j];\n      flipper[i + j] = flipper[i + endByteIndex - j];\n      flipper[i + endByteIndex - j] = t;\n    }\n  }\n}\n/**\r\n * Creates a copy of a TypedArray and swaps bytes.\r\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\r\n * @param src TypedArray\r\n */\n\n\nfunction byteSwap(src) {\n  var copy = src.slice();\n  byteSwapInplace(copy);\n  return copy;\n}\n\nvar ARRAY_META_KEY = \".zarray\";\nvar GROUP_META_KEY = \".zgroup\";\nvar ATTRS_META_KEY = \".zattrs\";\n/**\r\n * Return true if the store contains an array at the given logical path.\r\n */\n\nfunction containsArray(_x2) {\n  return _containsArray.apply(this, arguments);\n}\n/**\r\n * Return true if the store contains a group at the given logical path.\r\n */\n\n\nfunction _containsArray() {\n  _containsArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee47(store) {\n    var path,\n        prefix,\n        key,\n        _args51 = arguments;\n    return _regeneratorRuntime.wrap(function _callee47$(_context51) {\n      while (1) {\n        switch (_context51.prev = _context51.next) {\n          case 0:\n            path = _args51.length > 1 && _args51[1] !== undefined ? _args51[1] : null;\n            path = normalizeStoragePath(path);\n            prefix = pathToPrefix(path);\n            key = prefix + ARRAY_META_KEY;\n            return _context51.abrupt(\"return\", store.containsItem(key));\n\n          case 5:\n          case \"end\":\n            return _context51.stop();\n        }\n      }\n    }, _callee47);\n  }));\n  return _containsArray.apply(this, arguments);\n}\n\nfunction containsGroup(_x3) {\n  return _containsGroup.apply(this, arguments);\n}\n\nfunction _containsGroup() {\n  _containsGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee48(store) {\n    var path,\n        prefix,\n        key,\n        _args52 = arguments;\n    return _regeneratorRuntime.wrap(function _callee48$(_context52) {\n      while (1) {\n        switch (_context52.prev = _context52.next) {\n          case 0:\n            path = _args52.length > 1 && _args52[1] !== undefined ? _args52[1] : null;\n            path = normalizeStoragePath(path);\n            prefix = pathToPrefix(path);\n            key = prefix + GROUP_META_KEY;\n            return _context52.abrupt(\"return\", store.containsItem(key));\n\n          case 5:\n          case \"end\":\n            return _context52.stop();\n        }\n      }\n    }, _callee48);\n  }));\n  return _containsGroup.apply(this, arguments);\n}\n\nfunction pathToPrefix(path) {\n  // assume path already normalized\n  if (path.length > 0) {\n    return path + '/';\n  }\n\n  return '';\n}\n\nfunction requireParentGroup(_x4, _x5, _x6, _x7) {\n  return _requireParentGroup.apply(this, arguments);\n}\n\nfunction _requireParentGroup() {\n  _requireParentGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee49(store, path, chunkStore, overwrite) {\n    var segments, p, _iterator14, _step14, s;\n\n    return _regeneratorRuntime.wrap(function _callee49$(_context53) {\n      while (1) {\n        switch (_context53.prev = _context53.next) {\n          case 0:\n            if (!(path.length === 0)) {\n              _context53.next = 2;\n              break;\n            }\n\n            return _context53.abrupt(\"return\");\n\n          case 2:\n            segments = path.split(\"/\");\n            p = \"\";\n            _iterator14 = _createForOfIteratorHelper(segments.slice(0, segments.length - 1));\n            _context53.prev = 5;\n\n            _iterator14.s();\n\n          case 7:\n            if ((_step14 = _iterator14.n()).done) {\n              _context53.next = 25;\n              break;\n            }\n\n            s = _step14.value;\n            p += s;\n            _context53.next = 12;\n            return containsArray(store, p);\n\n          case 12:\n            if (!_context53.sent) {\n              _context53.next = 17;\n              break;\n            }\n\n            _context53.next = 15;\n            return initGroupMetadata(store, p, overwrite);\n\n          case 15:\n            _context53.next = 22;\n            break;\n\n          case 17:\n            _context53.next = 19;\n            return containsGroup(store, p);\n\n          case 19:\n            if (_context53.sent) {\n              _context53.next = 22;\n              break;\n            }\n\n            _context53.next = 22;\n            return initGroupMetadata(store, p);\n\n          case 22:\n            p += \"/\";\n\n          case 23:\n            _context53.next = 7;\n            break;\n\n          case 25:\n            _context53.next = 30;\n            break;\n\n          case 27:\n            _context53.prev = 27;\n            _context53.t0 = _context53[\"catch\"](5);\n\n            _iterator14.e(_context53.t0);\n\n          case 30:\n            _context53.prev = 30;\n\n            _iterator14.f();\n\n            return _context53.finish(30);\n\n          case 33:\n          case \"end\":\n            return _context53.stop();\n        }\n      }\n    }, _callee49, null, [[5, 27, 30, 33]]);\n  }));\n  return _requireParentGroup.apply(this, arguments);\n}\n\nfunction initGroupMetadata(_x8) {\n  return _initGroupMetadata.apply(this, arguments);\n}\n/**\r\n *  Initialize a group store. Note that this is a low-level function and there should be no\r\n *  need to call this directly from user code.\r\n */\n\n\nfunction _initGroupMetadata() {\n  _initGroupMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee50(store) {\n    var path,\n        overwrite,\n        metadata,\n        key,\n        _args54 = arguments;\n    return _regeneratorRuntime.wrap(function _callee50$(_context54) {\n      while (1) {\n        switch (_context54.prev = _context54.next) {\n          case 0:\n            path = _args54.length > 1 && _args54[1] !== undefined ? _args54[1] : null;\n            overwrite = _args54.length > 2 && _args54[2] !== undefined ? _args54[2] : false;\n            path = normalizeStoragePath(path); // Guard conditions\n\n            if (!overwrite) {\n              _context54.next = 7;\n              break;\n            }\n\n            throw Error(\"Group overwriting not implemented yet :(\");\n\n          case 7:\n            _context54.next = 9;\n            return containsArray(store, path);\n\n          case 9:\n            if (!_context54.sent) {\n              _context54.next = 13;\n              break;\n            }\n\n            throw new ContainsArrayError(path);\n\n          case 13:\n            _context54.next = 15;\n            return containsGroup(store, path);\n\n          case 15:\n            if (!_context54.sent) {\n              _context54.next = 17;\n              break;\n            }\n\n            throw new ContainsGroupError(path);\n\n          case 17:\n            metadata = {\n              zarr_format: 2\n            };\n            key = pathToPrefix(path) + GROUP_META_KEY;\n            _context54.next = 21;\n            return store.setItem(key, JSON.stringify(metadata));\n\n          case 21:\n          case \"end\":\n            return _context54.stop();\n        }\n      }\n    }, _callee50);\n  }));\n  return _initGroupMetadata.apply(this, arguments);\n}\n\nfunction initGroup(_x9) {\n  return _initGroup.apply(this, arguments);\n}\n\nfunction _initGroup() {\n  _initGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee51(store) {\n    var path,\n        chunkStore,\n        overwrite,\n        _args55 = arguments;\n    return _regeneratorRuntime.wrap(function _callee51$(_context55) {\n      while (1) {\n        switch (_context55.prev = _context55.next) {\n          case 0:\n            path = _args55.length > 1 && _args55[1] !== undefined ? _args55[1] : null;\n            chunkStore = _args55.length > 2 && _args55[2] !== undefined ? _args55[2] : null;\n            overwrite = _args55.length > 3 && _args55[3] !== undefined ? _args55[3] : false;\n            path = normalizeStoragePath(path);\n            _context55.next = 6;\n            return requireParentGroup(store, path, chunkStore, overwrite);\n\n          case 6:\n            _context55.next = 8;\n            return initGroupMetadata(store, path, overwrite);\n\n          case 8:\n          case \"end\":\n            return _context55.stop();\n        }\n      }\n    }, _callee51);\n  }));\n  return _initGroup.apply(this, arguments);\n}\n\nfunction initArrayMetadata(_x10, _x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18, _x19, _x20, _x21) {\n  return _initArrayMetadata.apply(this, arguments);\n}\n/**\r\n *\r\n * Initialize an array store with the given configuration. Note that this is a low-level\r\n * function and there should be no need to call this directly from user code\r\n */\n\n\nfunction _initArrayMetadata() {\n  _initArrayMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee52(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator) {\n    var serializedFillValue, metadata, metaKey;\n    return _regeneratorRuntime.wrap(function _callee52$(_context56) {\n      while (1) {\n        switch (_context56.prev = _context56.next) {\n          case 0:\n            if (!overwrite) {\n              _context56.next = 4;\n              break;\n            }\n\n            throw Error(\"Array overwriting not implemented yet :(\");\n\n          case 4:\n            _context56.next = 6;\n            return containsArray(store, path);\n\n          case 6:\n            if (!_context56.sent) {\n              _context56.next = 10;\n              break;\n            }\n\n            throw new ContainsArrayError(path);\n\n          case 10:\n            _context56.next = 12;\n            return containsGroup(store, path);\n\n          case 12:\n            if (!_context56.sent) {\n              _context56.next = 14;\n              break;\n            }\n\n            throw new ContainsGroupError(path);\n\n          case 14:\n            // Normalize metadata,  does type checking too.\n            dtype = normalizeDtype(dtype);\n            shape = normalizeShape(shape);\n            chunks = normalizeChunks(chunks, shape);\n            order = normalizeOrder(order);\n            fillValue = normalizeFillValue(fillValue);\n\n            if (!(filters !== null && filters.length > 0)) {\n              _context56.next = 21;\n              break;\n            }\n\n            throw Error(\"Filters are not supported yet\");\n\n          case 21:\n            serializedFillValue = fillValue;\n\n            if (typeof fillValue === \"number\") {\n              if (Number.isNaN(fillValue)) serializedFillValue = \"NaN\";\n              if (Number.POSITIVE_INFINITY === fillValue) serializedFillValue = \"Infinity\";\n              if (Number.NEGATIVE_INFINITY === fillValue) serializedFillValue = \"-Infinity\";\n            }\n\n            filters = null;\n            metadata = {\n              zarr_format: 2,\n              shape: shape,\n              chunks: chunks,\n              dtype: dtype,\n              fill_value: serializedFillValue,\n              order: order,\n              compressor: compressor,\n              filters: filters\n            };\n\n            if (dimensionSeparator) {\n              metadata.dimension_separator = dimensionSeparator;\n            }\n\n            metaKey = pathToPrefix(path) + ARRAY_META_KEY;\n            _context56.next = 29;\n            return store.setItem(metaKey, JSON.stringify(metadata));\n\n          case 29:\n          case \"end\":\n            return _context56.stop();\n        }\n      }\n    }, _callee52);\n  }));\n  return _initArrayMetadata.apply(this, arguments);\n}\n\nfunction initArray(_x22, _x23, _x24, _x25) {\n  return _initArray.apply(this, arguments);\n}\n\nfunction _initArray() {\n  _initArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee53(store, shape, chunks, dtype) {\n    var path,\n        compressor,\n        fillValue,\n        order,\n        overwrite,\n        chunkStore,\n        filters,\n        dimensionSeparator,\n        _args57 = arguments;\n    return _regeneratorRuntime.wrap(function _callee53$(_context57) {\n      while (1) {\n        switch (_context57.prev = _context57.next) {\n          case 0:\n            path = _args57.length > 4 && _args57[4] !== undefined ? _args57[4] : null;\n            compressor = _args57.length > 5 && _args57[5] !== undefined ? _args57[5] : null;\n            fillValue = _args57.length > 6 && _args57[6] !== undefined ? _args57[6] : null;\n            order = _args57.length > 7 && _args57[7] !== undefined ? _args57[7] : \"C\";\n            overwrite = _args57.length > 8 && _args57[8] !== undefined ? _args57[8] : false;\n            chunkStore = _args57.length > 9 && _args57[9] !== undefined ? _args57[9] : null;\n            filters = _args57.length > 10 && _args57[10] !== undefined ? _args57[10] : null;\n            dimensionSeparator = _args57.length > 11 ? _args57[11] : undefined;\n            path = normalizeStoragePath(path);\n            _context57.next = 11;\n            return requireParentGroup(store, path, chunkStore, overwrite);\n\n          case 11:\n            _context57.next = 13;\n            return initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n\n          case 13:\n          case \"end\":\n            return _context57.stop();\n        }\n      }\n    }, _callee53);\n  }));\n  return _initArray.apply(this, arguments);\n}\n\nfunction parseMetadata(s) {\n  // Here we allow that a store may return an already-parsed metadata object,\n  // or a string of JSON that we will parse here. We allow for an already-parsed\n  // object to accommodate a consolidated metadata store, where all the metadata for\n  // all groups and arrays will already have been parsed from JSON.\n  if (typeof s !== 'string') {\n    // tslint:disable-next-line: strict-type-predicates\n    if (IS_NODE && Buffer.isBuffer(s)) {\n      return JSON.parse(s.toString());\n    } else if (s instanceof ArrayBuffer) {\n      var utf8Decoder = new TextDecoder();\n      var bytes = new Uint8Array(s);\n      return JSON.parse(utf8Decoder.decode(bytes));\n    } else {\n      return s;\n    }\n  }\n\n  return JSON.parse(s);\n}\n/**\r\n * Class providing access to user attributes on an array or group. Should not be\r\n * instantiated directly, will be available via the `.attrs` property of an array or\r\n * group.\r\n */\n\n\nvar Attributes = /*#__PURE__*/function () {\n  function Attributes(store, key, readOnly) {\n    var cache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    _classCallCheck(this, Attributes);\n\n    this.store = store;\n    this.key = key;\n    this.readOnly = readOnly;\n    this.cache = cache;\n    this.cachedValue = null;\n  }\n  /**\r\n   * Retrieve all attributes as a JSON object.\r\n   */\n\n\n  _createClass(Attributes, [{\n    key: \"asObject\",\n    value: function () {\n      var _asObject = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var o;\n        return _regeneratorRuntime.wrap(function _callee$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(this.cache && this.cachedValue !== null)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", this.cachedValue);\n\n              case 2:\n                _context5.next = 4;\n                return this.getNoSync();\n\n              case 4:\n                o = _context5.sent;\n\n                if (this.cache) {\n                  this.cachedValue = o;\n                }\n\n                return _context5.abrupt(\"return\", o);\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function asObject() {\n        return _asObject.apply(this, arguments);\n      }\n\n      return asObject;\n    }()\n  }, {\n    key: \"getNoSync\",\n    value: function () {\n      var _getNoSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return this.store.getItem(this.key);\n\n              case 3:\n                data = _context6.sent;\n                return _context6.abrupt(\"return\", parseMetadata(data));\n\n              case 7:\n                _context6.prev = 7;\n                _context6.t0 = _context6[\"catch\"](0);\n                return _context6.abrupt(\"return\", {});\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee2, this, [[0, 7]]);\n      }));\n\n      function getNoSync() {\n        return _getNoSync.apply(this, arguments);\n      }\n\n      return getNoSync;\n    }()\n  }, {\n    key: \"setNoSync\",\n    value: function () {\n      var _setNoSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, value) {\n        var d;\n        return _regeneratorRuntime.wrap(function _callee3$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.getNoSync();\n\n              case 2:\n                d = _context7.sent;\n                d[key] = value;\n                _context7.next = 6;\n                return this.putNoSync(d);\n\n              case 6:\n                return _context7.abrupt(\"return\", true);\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function setNoSync(_x26, _x27) {\n        return _setNoSync.apply(this, arguments);\n      }\n\n      return setNoSync;\n    }()\n  }, {\n    key: \"putNoSync\",\n    value: function () {\n      var _putNoSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(m) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.store.setItem(this.key, JSON.stringify(m));\n\n              case 2:\n                if (this.cache) {\n                  this.cachedValue = m;\n                }\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function putNoSync(_x28) {\n        return _putNoSync.apply(this, arguments);\n      }\n\n      return putNoSync;\n    }()\n  }, {\n    key: \"delNoSync\",\n    value: function () {\n      var _delNoSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(key) {\n        var d;\n        return _regeneratorRuntime.wrap(function _callee5$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.getNoSync();\n\n              case 2:\n                d = _context9.sent;\n                delete d[key];\n                _context9.next = 6;\n                return this.putNoSync(d);\n\n              case 6:\n                return _context9.abrupt(\"return\", true);\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function delNoSync(_x29) {\n        return _delNoSync.apply(this, arguments);\n      }\n\n      return delNoSync;\n    }()\n    /**\r\n     * Overwrite all attributes with the provided object in a single operation\r\n     */\n\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(d) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!this.readOnly) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new PermissionError(\"attributes are read-only\");\n\n              case 2:\n                return _context10.abrupt(\"return\", this.putNoSync(d));\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function put(_x30) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"setItem\",\n    value: function () {\n      var _setItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(key, value) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!this.readOnly) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new PermissionError(\"attributes are read-only\");\n\n              case 2:\n                return _context11.abrupt(\"return\", this.setNoSync(key, value));\n\n              case 3:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function setItem(_x31, _x32) {\n        return _setItem.apply(this, arguments);\n      }\n\n      return setItem;\n    }()\n  }, {\n    key: \"getItem\",\n    value: function () {\n      var _getItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(key) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.asObject();\n\n              case 2:\n                _context12.t0 = key;\n                return _context12.abrupt(\"return\", _context12.sent[_context12.t0]);\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getItem(_x33) {\n        return _getItem.apply(this, arguments);\n      }\n\n      return getItem;\n    }()\n  }, {\n    key: \"deleteItem\",\n    value: function () {\n      var _deleteItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(key) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!this.readOnly) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                throw new PermissionError(\"attributes are read-only\");\n\n              case 2:\n                return _context13.abrupt(\"return\", this.delNoSync(key));\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function deleteItem(_x34) {\n        return _deleteItem.apply(this, arguments);\n      }\n\n      return deleteItem;\n    }()\n  }, {\n    key: \"containsItem\",\n    value: function () {\n      var _containsItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(key) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.asObject();\n\n              case 2:\n                _context14.t0 = key;\n                _context14.t1 = _context14.sent[_context14.t0];\n                _context14.t2 = undefined;\n                return _context14.abrupt(\"return\", _context14.t1 !== _context14.t2);\n\n              case 6:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function containsItem(_x35) {\n        return _containsItem.apply(this, arguments);\n      }\n\n      return containsItem;\n    }()\n  }, {\n    key: \"proxy\",\n    value: function proxy() {\n      return createProxy(this);\n    }\n  }]);\n\n  return Attributes;\n}();\n\nvar DTYPE_TYPEDARRAY_MAPPING = {\n  '|b': Int8Array,\n  '|B': Uint8Array,\n  '|u1': Uint8Array,\n  '|i1': Int8Array,\n  '<b': Int8Array,\n  '<B': Uint8Array,\n  '<u1': Uint8Array,\n  '<i1': Int8Array,\n  '<u2': Uint16Array,\n  '<i2': Int16Array,\n  '<u4': Uint32Array,\n  '<i4': Int32Array,\n  '<f4': Float32Array,\n  '<f8': Float64Array,\n  '>b': Int8Array,\n  '>B': Uint8Array,\n  '>u1': Uint8Array,\n  '>i1': Int8Array,\n  '>u2': Uint16Array,\n  '>i2': Int16Array,\n  '>u4': Uint32Array,\n  '>i4': Int32Array,\n  '>f4': Float32Array,\n  '>f8': Float64Array\n};\n\nfunction getTypedArrayCtr(dtype) {\n  var ctr = DTYPE_TYPEDARRAY_MAPPING[dtype];\n\n  if (!ctr) {\n    throw Error(\"Dtype not recognized or not supported in zarr.js, got \".concat(dtype, \".\"));\n  }\n\n  return ctr;\n}\n/*\r\n * Called by NestedArray and RawArray constructors only.\r\n * We byte-swap the buffer of a store after decoding\r\n * since TypedArray views are little endian only.\r\n *\r\n * This means NestedArrays and RawArrays will always be little endian,\r\n * unless a numpy-like library comes around and can handle endianess\r\n * for buffer views.\r\n */\n\n\nfunction getTypedArrayDtypeString(t) {\n  // Favour the types below instead of small and big B\n  if (t instanceof Uint8Array) return '|u1';\n  if (t instanceof Int8Array) return '|i1';\n  if (t instanceof Uint16Array) return '<u2';\n  if (t instanceof Int16Array) return '<i2';\n  if (t instanceof Uint32Array) return '<u4';\n  if (t instanceof Int32Array) return '<i4';\n  if (t instanceof Float32Array) return '<f4';\n  if (t instanceof Float64Array) return '<f8';\n  throw new ValueError('Mapping for TypedArray to Dtypestring not known');\n}\n/**\r\n * Digs down into the dimensions of given array to find the TypedArray and returns its constructor.\r\n * Better to use sparingly.\r\n */\n\n\nfunction getNestedArrayConstructor(arr) {\n  // TODO fix typing\n  // tslint:disable-next-line: strict-type-predicates\n  if (arr.byteLength !== undefined) {\n    return arr.constructor;\n  }\n\n  return getNestedArrayConstructor(arr[0]);\n}\n/**\r\n * Returns both the slice result and new output shape\r\n * @param arr NestedArray to slice\r\n * @param shape The shape of the NestedArray\r\n * @param selection\r\n */\n\n\nfunction sliceNestedArray(arr, shape, selection) {\n  // This translates \"...\", \":\", null into a list of slices or integer selections\n  var normalizedSelection = normalizeArraySelection(selection, shape);\n\n  var _selectionToSliceIndi = selectionToSliceIndices(normalizedSelection, shape),\n      _selectionToSliceIndi2 = _slicedToArray(_selectionToSliceIndi, 2),\n      sliceIndices = _selectionToSliceIndi2[0],\n      outShape = _selectionToSliceIndi2[1];\n\n  var outArray = _sliceNestedArray(arr, shape, sliceIndices);\n\n  return [outArray, outShape];\n}\n\nfunction _sliceNestedArray(arr, shape, selection) {\n  var currentSlice = selection[0]; // Is this necessary?\n  // // This is possible when a slice list is passed shorter than the amount of dimensions\n  // // tslint:disable-next-line: strict-type-predicates\n  // if (currentSlice === undefined) {\n  //     return arr.slice();\n  // }\n  // When a number is passed that dimension is squeezed\n\n  if (typeof currentSlice === \"number\") {\n    // Assume already normalized integer selection here.\n    if (shape.length === 1) {\n      return arr[currentSlice];\n    } else {\n      return _sliceNestedArray(arr[currentSlice], shape.slice(1), selection.slice(1));\n    }\n  }\n\n  var _currentSlice = _slicedToArray(currentSlice, 4),\n      from = _currentSlice[0],\n      to = _currentSlice[1],\n      step = _currentSlice[2],\n      outputSize = _currentSlice[3];\n\n  if (outputSize === 0) {\n    return new (getNestedArrayConstructor(arr))(0);\n  }\n\n  if (shape.length === 1) {\n    if (step === 1) {\n      return arr.slice(from, to);\n    }\n\n    var newArrData = new arr.constructor(outputSize);\n\n    for (var i = 0; i < outputSize; i++) {\n      newArrData[i] = arr[from + i * step];\n    }\n\n    return newArrData;\n  }\n\n  var newArr = new Array(outputSize);\n\n  for (var _i = 0; _i < outputSize; _i++) {\n    newArr[_i] = _sliceNestedArray(arr[from + _i * step], shape.slice(1), selection.slice(1));\n  } // This is necessary to ensure that the return value is a NestedArray if the last dimension is squeezed\n  // e.g. shape [2,1] with slice [:, 0] would otherwise result in a list of numbers instead of a valid NestedArray\n\n\n  if (outputSize > 0 && typeof newArr[0] === \"number\") {\n    var typedArrayConstructor = arr[0].constructor;\n    newArr = typedArrayConstructor.from(newArr);\n  }\n\n  return newArr;\n}\n\nfunction setNestedArrayToScalar(dstArr, value, destShape, selection) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  var normalizedSelection = normalizeArraySelection(selection, destShape, true); // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n\n  var _selectionToSliceIndi3 = selectionToSliceIndices(normalizedSelection, destShape),\n      _selectionToSliceIndi4 = _slicedToArray(_selectionToSliceIndi3, 2),\n      sliceIndices = _selectionToSliceIndi4[0],\n      _outShape = _selectionToSliceIndi4[1];\n\n  _setNestedArrayToScalar(dstArr, value, destShape, sliceIndices);\n}\n\nfunction setNestedArray(dstArr, sourceArr, destShape, sourceShape, selection) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  var normalizedSelection = normalizeArraySelection(selection, destShape, false);\n\n  var _selectionToSliceIndi5 = selectionToSliceIndices(normalizedSelection, destShape),\n      _selectionToSliceIndi6 = _slicedToArray(_selectionToSliceIndi5, 2),\n      sliceIndices = _selectionToSliceIndi6[0],\n      outShape = _selectionToSliceIndi6[1]; // TODO: replace with non stringify equality check\n\n\n  if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n    throw new ValueError(\"Shape mismatch in target and source NestedArray: \".concat(outShape, \" and \").concat(sourceShape));\n  }\n\n  _setNestedArray(dstArr, sourceArr, destShape, sliceIndices);\n}\n\nfunction _setNestedArray(dstArr, sourceArr, shape, selection) {\n  var currentSlice = selection[0];\n\n  if (typeof sourceArr === \"number\") {\n    _setNestedArrayToScalar(dstArr, sourceArr, shape, selection.map(function (x) {\n      return typeof x === \"number\" ? [x, x + 1, 1, 1] : x;\n    }));\n\n    return;\n  } // This dimension is squeezed.\n\n\n  if (typeof currentSlice === \"number\") {\n    _setNestedArray(dstArr[currentSlice], sourceArr, shape.slice(1), selection.slice(1));\n\n    return;\n  }\n\n  var _currentSlice2 = _slicedToArray(currentSlice, 4),\n      from = _currentSlice2[0],\n      _to = _currentSlice2[1],\n      step = _currentSlice2[2],\n      outputSize = _currentSlice2[3];\n\n  if (shape.length === 1) {\n    if (step === 1) {\n      dstArr.set(sourceArr, from);\n    } else {\n      for (var i = 0; i < outputSize; i++) {\n        dstArr[from + i * step] = sourceArr[i];\n      }\n    }\n\n    return;\n  }\n\n  for (var _i2 = 0; _i2 < outputSize; _i2++) {\n    _setNestedArray(dstArr[from + _i2 * step], sourceArr[_i2], shape.slice(1), selection.slice(1));\n  }\n}\n\nfunction _setNestedArrayToScalar(dstArr, value, shape, selection) {\n  var currentSlice = selection[0];\n\n  var _currentSlice3 = _slicedToArray(currentSlice, 4),\n      from = _currentSlice3[0],\n      to = _currentSlice3[1],\n      step = _currentSlice3[2],\n      outputSize = _currentSlice3[3];\n\n  if (shape.length === 1) {\n    if (step === 1) {\n      dstArr.fill(value, from, to);\n    } else {\n      for (var i = 0; i < outputSize; i++) {\n        dstArr[from + i * step] = value;\n      }\n    }\n\n    return;\n  }\n\n  for (var _i3 = 0; _i3 < outputSize; _i3++) {\n    _setNestedArrayToScalar(dstArr[from + _i3 * step], value, shape.slice(1), selection.slice(1));\n  }\n}\n\nfunction flattenNestedArray(arr, shape, constr) {\n  if (constr === undefined) {\n    constr = getNestedArrayConstructor(arr);\n  }\n\n  var size = shape.reduce(function (x, y) {\n    return x * y;\n  }, 1);\n  var outArr = new constr(size);\n\n  _flattenNestedArray(arr, shape, outArr, 0);\n\n  return outArr;\n}\n\nfunction _flattenNestedArray(arr, shape, outArr, offset) {\n  if (shape.length === 1) {\n    // This is only ever reached if called with rank 1 shape, never reached through recursion.\n    // We just slice set the array directly from one level above to save some function calls.\n    outArr.set(arr, offset);\n    return;\n  }\n\n  if (shape.length === 2) {\n    for (var i = 0; i < shape[0]; i++) {\n      outArr.set(arr[i], offset + shape[1] * i);\n    }\n\n    return arr;\n  }\n\n  var nextShape = shape.slice(1); // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n\n  var mult = nextShape.reduce(function (x, y) {\n    return x * y;\n  }, 1);\n\n  for (var _i4 = 0; _i4 < shape[0]; _i4++) {\n    _flattenNestedArray(arr[_i4], nextShape, outArr, offset + mult * _i4);\n  }\n\n  return arr;\n}\n\nvar NestedArray = /*#__PURE__*/function () {\n  function NestedArray(data, shape, dtype) {\n    _classCallCheck(this, NestedArray);\n\n    var dataIsTypedArray = data !== null && !!data.BYTES_PER_ELEMENT;\n\n    if (shape === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n      }\n\n      shape = [data.length];\n    }\n\n    if (dtype === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n      }\n\n      dtype = getTypedArrayDtypeString(data);\n    }\n\n    shape = normalizeShape(shape);\n    this.shape = shape;\n    this.dtype = dtype;\n\n    if (dataIsTypedArray && shape.length !== 1) {\n      data = data.buffer;\n    } // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n\n\n    if (this.shape.length === 0) {\n      this.data = new (getTypedArrayCtr(dtype))(1);\n    } else if ( // tslint:disable-next-line: strict-type-predicates\n    IS_NODE && Buffer.isBuffer(data) || data instanceof ArrayBuffer || data === null || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n    ) {\n      // Create from ArrayBuffer or Buffer\n      var numShapeElements = shape.reduce(function (x, y) {\n        return x * y;\n      }, 1);\n\n      if (data === null) {\n        data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n      }\n\n      var numDataElements = data.byteLength / parseInt(dtype[dtype.length - 1], 10);\n\n      if (numShapeElements !== numDataElements) {\n        throw new Error(\"Buffer has \".concat(numDataElements, \" of dtype \").concat(dtype, \", shape is too large or small \").concat(shape, \" (flat=\").concat(numShapeElements, \")\"));\n      }\n\n      var typeConstructor = getTypedArrayCtr(dtype);\n      this.data = createNestedArray(data, typeConstructor, shape);\n    } else {\n      this.data = data;\n    }\n  }\n\n  _createClass(NestedArray, [{\n    key: \"get\",\n    value: function get(selection) {\n      var _sliceNestedArray2 = sliceNestedArray(this.data, this.shape, selection),\n          _sliceNestedArray3 = _slicedToArray(_sliceNestedArray2, 2),\n          sliceResult = _sliceNestedArray3[0],\n          outShape = _sliceNestedArray3[1];\n\n      if (outShape.length === 0) {\n        return sliceResult;\n      } else {\n        return new NestedArray(sliceResult, outShape, this.dtype);\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set() {\n      var selection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var value = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (selection === null) {\n        selection = [slice(null)];\n      }\n\n      if (typeof value === \"number\") {\n        if (this.shape.length === 0) {\n          // Zero dimension array..\n          this.data[0] = value;\n        } else {\n          setNestedArrayToScalar(this.data, value, this.shape, selection);\n        }\n      } else {\n        setNestedArray(this.data, value.data, this.shape, value.shape, selection);\n      }\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten() {\n      if (this.shape.length === 1) {\n        return this.data;\n      }\n\n      return flattenNestedArray(this.data, this.shape, getTypedArrayCtr(this.dtype));\n    }\n    /**\r\n     * Currently only supports a single integer as the size, TODO: support start, stop, step.\r\n     */\n\n  }], [{\n    key: \"arange\",\n    value: function arange(size) {\n      var dtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"<i4\";\n      var constr = getTypedArrayCtr(dtype);\n      var data = rangeTypedArray([size], constr);\n      return new NestedArray(data, [size], dtype);\n    }\n  }]);\n\n  return NestedArray;\n}();\n/**\r\n * Creates a TypedArray with values 0 through N where N is the product of the shape.\r\n */\n\n\nfunction rangeTypedArray(shape, tContructor) {\n  var size = shape.reduce(function (x, y) {\n    return x * y;\n  }, 1);\n  var data = new tContructor(size);\n  data.set(_toConsumableArray(Array(size).keys())); // Sets range 0,1,2,3,4,5\n\n  return data;\n}\n/**\r\n * Creates multi-dimensional (rank > 1) array given input data and shape recursively.\r\n * What it does is create a Array<Array<...<Array<Uint8Array>>> or some other typed array.\r\n * This is for internal use, there should be no need to call this from user code.\r\n * @param data a buffer containing the data for this array.\r\n * @param t constructor for the datatype of choice\r\n * @param shape list of numbers describing the size in each dimension\r\n * @param offset in bytes for this dimension\r\n */\n\n\nfunction createNestedArray(data, t, shape) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (shape.length === 1) {\n    // This is only ever reached if called with rank 1 shape, never reached through recursion.\n    // We just slice set the array directly from one level above to save some function calls.\n    return new t(data.slice(offset, offset + shape[0] * t.BYTES_PER_ELEMENT));\n  }\n\n  var arr = new Array(shape[0]);\n\n  if (shape.length === 2) {\n    for (var i = 0; i < shape[0]; i++) {\n      arr[i] = new t(data.slice(offset + shape[1] * i * t.BYTES_PER_ELEMENT, offset + shape[1] * (i + 1) * t.BYTES_PER_ELEMENT));\n    }\n\n    return arr;\n  }\n\n  var nextShape = shape.slice(1); // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n\n  var mult = nextShape.reduce(function (x, y) {\n    return x * y;\n  }, 1);\n\n  for (var _i5 = 0; _i5 < shape[0]; _i5++) {\n    arr[_i5] = createNestedArray(data, t, nextShape, offset + mult * _i5 * t.BYTES_PER_ELEMENT);\n  }\n\n  return arr;\n}\n\nfunction setRawArrayToScalar(dstArr, dstStrides, dstShape, dstSelection, value) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  var normalizedSelection = normalizeArraySelection(dstSelection, dstShape, true);\n\n  var _selectionToSliceIndi7 = selectionToSliceIndices(normalizedSelection, dstShape),\n      _selectionToSliceIndi8 = _slicedToArray(_selectionToSliceIndi7, 1),\n      sliceIndices = _selectionToSliceIndi8[0]; // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n\n\n  _setRawArrayToScalar(value, dstArr, dstStrides, sliceIndices);\n}\n\nfunction setRawArray(dstArr, dstStrides, dstShape, dstSelection, sourceArr, sourceStrides, sourceShape) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  var normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, false);\n\n  var _selectionToSliceIndi9 = selectionToSliceIndices(normalizedDstSelection, dstShape),\n      _selectionToSliceIndi10 = _slicedToArray(_selectionToSliceIndi9, 2),\n      dstSliceIndices = _selectionToSliceIndi10[0],\n      outShape = _selectionToSliceIndi10[1]; // TODO: replace with non stringify equality check\n\n\n  if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n    throw new ValueError(\"Shape mismatch in target and source RawArray: \".concat(outShape, \" and \").concat(sourceShape));\n  }\n\n  _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides);\n}\n\nfunction setRawArrayFromChunkItem(dstArr, dstStrides, dstShape, dstSelection, sourceArr, sourceStrides, sourceShape, sourceSelection) {\n  // This translates \"...\", \":\", null, etc into a list of slices.\n  var normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, true); // Above we force the results to be dstSliceIndices only, without integer selections making this cast is safe.\n\n  var _selectionToSliceIndi11 = selectionToSliceIndices(normalizedDstSelection, dstShape),\n      _selectionToSliceIndi12 = _slicedToArray(_selectionToSliceIndi11, 1),\n      dstSliceIndices = _selectionToSliceIndi12[0];\n\n  var normalizedSourceSelection = normalizeArraySelection(sourceSelection, sourceShape, false);\n\n  var _selectionToSliceIndi13 = selectionToSliceIndices(normalizedSourceSelection, sourceShape),\n      _selectionToSliceIndi14 = _slicedToArray(_selectionToSliceIndi13, 1),\n      sourceSliceIndicies = _selectionToSliceIndi14[0]; // TODO check to ensure chunk and dest selection are same shape?\n  // As is, this only gets called in ZarrArray.getRaw where this condition should be ensured, and check might hinder performance.\n\n\n  _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides, sourceSliceIndicies);\n}\n\nfunction _setRawArrayToScalar(value, dstArr, dstStrides, dstSliceIndices) {\n  var _dstSliceIndices = _toArray(dstSliceIndices),\n      currentDstSlice = _dstSliceIndices[0],\n      nextDstSliceIndices = _dstSliceIndices.slice(1);\n\n  var _dstStrides = _toArray(dstStrides),\n      currentDstStride = _dstStrides[0],\n      nextDstStrides = _dstStrides.slice(1);\n\n  var _currentDstSlice = _slicedToArray(currentDstSlice, 4),\n      from = _currentDstSlice[0],\n      _to = _currentDstSlice[1],\n      step = _currentDstSlice[2],\n      outputSize = _currentDstSlice[3];\n\n  if (dstStrides.length === 1) {\n    if (step === 1 && currentDstStride === 1) {\n      dstArr.fill(value, from, from + outputSize);\n    } else {\n      for (var i = 0; i < outputSize; i++) {\n        dstArr[currentDstStride * (from + step * i)] = value;\n      }\n    }\n\n    return;\n  }\n\n  for (var _i6 = 0; _i6 < outputSize; _i6++) {\n    _setRawArrayToScalar(value, dstArr.subarray(currentDstStride * (from + step * _i6)), nextDstStrides, nextDstSliceIndices);\n  }\n}\n\nfunction _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides) {\n  if (dstSliceIndices.length === 0) {\n    dstArr.set(sourceArr);\n    return;\n  }\n\n  var _dstSliceIndices2 = _toArray(dstSliceIndices),\n      currentDstSlice = _dstSliceIndices2[0],\n      nextDstSliceIndices = _dstSliceIndices2.slice(1);\n\n  var _dstStrides2 = _toArray(dstStrides),\n      currentDstStride = _dstStrides2[0],\n      nextDstStrides = _dstStrides2.slice(1); // This dimension is squeezed.\n\n\n  if (typeof currentDstSlice === \"number\") {\n    _setRawArray(dstArr.subarray(currentDstSlice * currentDstStride), nextDstStrides, nextDstSliceIndices, sourceArr, sourceStrides);\n\n    return;\n  }\n\n  var _sourceStrides = _toArray(sourceStrides),\n      currentSourceStride = _sourceStrides[0],\n      nextSourceStrides = _sourceStrides.slice(1);\n\n  var _currentDstSlice2 = _slicedToArray(currentDstSlice, 4),\n      from = _currentDstSlice2[0],\n      _to = _currentDstSlice2[1],\n      step = _currentDstSlice2[2],\n      outputSize = _currentDstSlice2[3];\n\n  if (dstStrides.length === 1) {\n    if (step === 1 && currentDstStride === 1 && currentSourceStride === 1) {\n      dstArr.set(sourceArr.subarray(0, outputSize), from);\n    } else {\n      for (var i = 0; i < outputSize; i++) {\n        dstArr[currentDstStride * (from + step * i)] = sourceArr[currentSourceStride * i];\n      }\n    }\n\n    return;\n  }\n\n  for (var _i7 = 0; _i7 < outputSize; _i7++) {\n    // Apply strides as above, using both destination and source-specific strides.\n    _setRawArray(dstArr.subarray(currentDstStride * (from + _i7 * step)), nextDstStrides, nextDstSliceIndices, sourceArr.subarray(currentSourceStride * _i7), nextSourceStrides);\n  }\n}\n\nfunction _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides, sourceSliceIndices) {\n  if (sourceSliceIndices.length === 0) {\n    // Case when last source dimension is squeezed\n    dstArr.set(sourceArr.subarray(0, dstArr.length));\n    return;\n  } // Get current indicies and strides for both destination and source arrays\n\n\n  var _dstSliceIndices3 = _toArray(dstSliceIndices),\n      currentDstSlice = _dstSliceIndices3[0],\n      nextDstSliceIndices = _dstSliceIndices3.slice(1);\n\n  var _sourceSliceIndices = _toArray(sourceSliceIndices),\n      currentSourceSlice = _sourceSliceIndices[0],\n      nextSourceSliceIndices = _sourceSliceIndices.slice(1);\n\n  var _dstStrides3 = _toArray(dstStrides),\n      currentDstStride = _dstStrides3[0],\n      nextDstStrides = _dstStrides3.slice(1);\n\n  var _sourceStrides2 = _toArray(sourceStrides),\n      currentSourceStride = _sourceStrides2[0],\n      nextSourceStrides = _sourceStrides2.slice(1); // This source dimension is squeezed\n\n\n  if (typeof currentSourceSlice === \"number\") {\n    /*\r\n    Sets dimension offset for squeezed dimension.\r\n     Ex. if 0th dimension is squeezed to 2nd index (numpy : arr[2,i])\r\n         sourceArr[stride[0]* 2 + i] --> sourceArr.subarray(stride[0] * 2)[i] (sourceArr[i] in next call)\r\n     Thus, subsequent squeezed dims are appended to the source offset.\r\n    */\n    _setRawArrayFromChunkItem( // Don't update destination offset/slices, just source\n    dstArr, dstStrides, dstSliceIndices, sourceArr.subarray(currentSourceStride * currentSourceSlice), nextSourceStrides, nextSourceSliceIndices);\n\n    return;\n  }\n\n  var _currentDstSlice3 = _slicedToArray(currentDstSlice, 4),\n      from = _currentDstSlice3[0],\n      _to = _currentDstSlice3[1],\n      step = _currentDstSlice3[2],\n      outputSize = _currentDstSlice3[3]; // just need start and size\n\n\n  var _currentSourceSlice = _slicedToArray(currentSourceSlice, 4),\n      sfrom = _currentSourceSlice[0],\n      _sto = _currentSourceSlice[1],\n      sstep = _currentSourceSlice[2],\n      _soutputSize = _currentSourceSlice[3]; // Will always be subset of dst, so don't need output size just start\n\n\n  if (dstStrides.length === 1 && sourceStrides.length === 1) {\n    if (step === 1 && currentDstStride === 1 && sstep === 1 && currentSourceStride === 1) {\n      dstArr.set(sourceArr.subarray(sfrom, sfrom + outputSize), from);\n    } else {\n      for (var i = 0; i < outputSize; i++) {\n        dstArr[currentDstStride * (from + step * i)] = sourceArr[currentSourceStride * (sfrom + sstep * i)];\n      }\n    }\n\n    return;\n  }\n\n  for (var _i8 = 0; _i8 < outputSize; _i8++) {\n    // Apply strides as above, using both destination and source-specific strides.\n    _setRawArrayFromChunkItem(dstArr.subarray(currentDstStride * (from + _i8 * step)), nextDstStrides, nextDstSliceIndices, sourceArr.subarray(currentSourceStride * (sfrom + _i8 * sstep)), nextSourceStrides, nextSourceSliceIndices);\n  }\n}\n\nvar RawArray = /*#__PURE__*/function () {\n  function RawArray(data, shape, dtype, strides) {\n    _classCallCheck(this, RawArray);\n\n    var dataIsTypedArray = data !== null && !!data.BYTES_PER_ELEMENT;\n\n    if (shape === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n      }\n\n      shape = [data.length];\n    }\n\n    shape = normalizeShape(shape);\n\n    if (dtype === undefined) {\n      if (!dataIsTypedArray) {\n        throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n      }\n\n      dtype = getTypedArrayDtypeString(data);\n    }\n\n    if (strides === undefined) {\n      strides = getStrides(shape);\n    }\n\n    this.shape = shape;\n    this.dtype = dtype;\n    this.strides = strides;\n\n    if (dataIsTypedArray && shape.length !== 1) {\n      data = data.buffer;\n    } // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n\n\n    if (this.shape.length === 0) {\n      this.data = new (getTypedArrayCtr(dtype))(1);\n    } else if ( // tslint:disable-next-line: strict-type-predicates\n    IS_NODE && Buffer.isBuffer(data) || data instanceof ArrayBuffer || data === null || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n    ) {\n      // Create from ArrayBuffer or Buffer\n      var numShapeElements = shape.reduce(function (x, y) {\n        return x * y;\n      }, 1);\n\n      if (data === null) {\n        data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n      }\n\n      var numDataElements = data.byteLength / parseInt(dtype[dtype.length - 1], 10);\n\n      if (numShapeElements !== numDataElements) {\n        throw new Error(\"Buffer has \".concat(numDataElements, \" of dtype \").concat(dtype, \", shape is too large or small \").concat(shape, \" (flat=\").concat(numShapeElements, \")\"));\n      }\n\n      var typeConstructor = getTypedArrayCtr(dtype);\n      this.data = new typeConstructor(data);\n    } else {\n      this.data = data;\n    }\n  }\n\n  _createClass(RawArray, [{\n    key: \"set\",\n    value: function set() {\n      var selection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var value = arguments.length > 1 ? arguments[1] : undefined;\n      var chunkSelection = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (selection === null) {\n        selection = [slice(null)];\n      }\n\n      if (typeof value === \"number\") {\n        if (this.shape.length === 0) {\n          // Zero dimension array..\n          this.data[0] = value;\n        } else {\n          setRawArrayToScalar(this.data, this.strides, this.shape, selection, value);\n        }\n      } else if (value instanceof RawArray && chunkSelection) {\n        // Copy directly from decoded chunk to destination array\n        setRawArrayFromChunkItem(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape, chunkSelection);\n      } else {\n        setRawArray(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape);\n      }\n    }\n  }]);\n\n  return RawArray;\n}();\n\nfunction createCommonjsModule(fn) {\n  var module = {\n    exports: {}\n  };\n  return fn(module, module.exports), module.exports;\n}\n\nvar eventemitter3 = createCommonjsModule(function (module) {\n  var has = Object.prototype.hasOwnProperty,\n      prefix = '~';\n  /**\n   * Constructor to create a storage for our `EE` objects.\n   * An `Events` instance is a plain object whose properties are event names.\n   *\n   * @constructor\n   * @private\n   */\n\n  function Events() {} //\n  // We try to not inherit from `Object.prototype`. In some engines creating an\n  // instance in this way is faster than calling `Object.create(null)` directly.\n  // If `Object.create(null)` is not supported we prefix the event names with a\n  // character to make sure that the built-in object properties are not\n  // overridden or used as an attack vector.\n  //\n\n\n  if (Object.create) {\n    Events.prototype = Object.create(null); //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n\n    if (!new Events().__proto__) prefix = false;\n  }\n  /**\n   * Representation of a single event listener.\n   *\n   * @param {Function} fn The listener function.\n   * @param {*} context The context to invoke the listener with.\n   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n   * @constructor\n   * @private\n   */\n\n\n  function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n  }\n  /**\n   * Add a listener for a given event.\n   *\n   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} context The context to invoke the listener with.\n   * @param {Boolean} once Specify if the listener is a one-time listener.\n   * @returns {EventEmitter}\n   * @private\n   */\n\n\n  function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The listener must be a function');\n    }\n\n    var listener = new EE(fn, context || emitter, once),\n        evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];\n    return emitter;\n  }\n  /**\n   * Clear event by name.\n   *\n   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n   * @param {(String|Symbol)} evt The Event name.\n   * @private\n   */\n\n\n  function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];\n  }\n  /**\n   * Minimal `EventEmitter` interface that is molded against the Node.js\n   * `EventEmitter` interface.\n   *\n   * @constructor\n   * @public\n   */\n\n\n  function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   *\n   * @returns {Array}\n   * @public\n   */\n\n\n  EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [],\n        events,\n        name;\n    if (this._eventsCount === 0) return names;\n\n    for (name in events = this._events) {\n      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n\n    return names;\n  };\n  /**\n   * Return the listeners registered for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Array} The registered listeners.\n   * @public\n   */\n\n\n  EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event,\n        handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [handlers.fn];\n\n    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n      ee[i] = handlers[i].fn;\n    }\n\n    return ee;\n  };\n  /**\n   * Return the number of listeners listening to a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Number} The number of listeners.\n   * @public\n   */\n\n\n  EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event,\n        listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n  };\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Boolean} `true` if the event had listeners, else `false`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt],\n        len = arguments.length,\n        args,\n        i;\n\n    if (listeners.fn) {\n      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n      switch (len) {\n        case 1:\n          return listeners.fn.call(listeners.context), true;\n\n        case 2:\n          return listeners.fn.call(listeners.context, a1), true;\n\n        case 3:\n          return listeners.fn.call(listeners.context, a1, a2), true;\n\n        case 4:\n          return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\n        case 5:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\n        case 6:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n      }\n\n      for (i = 1, args = new Array(len - 1); i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      listeners.fn.apply(listeners.context, args);\n    } else {\n      var length = listeners.length,\n          j;\n\n      for (i = 0; i < length; i++) {\n        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n        switch (len) {\n          case 1:\n            listeners[i].fn.call(listeners[i].context);\n            break;\n\n          case 2:\n            listeners[i].fn.call(listeners[i].context, a1);\n            break;\n\n          case 3:\n            listeners[i].fn.call(listeners[i].context, a1, a2);\n            break;\n\n          case 4:\n            listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n            break;\n\n          default:\n            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n              args[j - 1] = arguments[j];\n            }\n            listeners[i].fn.apply(listeners[i].context, args);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Add a listener for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n  };\n  /**\n   * Add a one-time listener for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n  };\n  /**\n   * Remove the listeners of a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn Only remove the listeners that match this function.\n   * @param {*} context Only remove the listeners that have this context.\n   * @param {Boolean} once Only remove one-time listeners.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return this;\n\n    if (!fn) {\n      clearEvent(this, evt);\n      return this;\n    }\n\n    var listeners = this._events[evt];\n\n    if (listeners.fn) {\n      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n        clearEvent(this, evt);\n      }\n    } else {\n      for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n          events.push(listeners[i]);\n        }\n      } //\n      // Reset the array, or remove it completely if we have no more listeners.\n      //\n\n\n      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);\n    }\n\n    return this;\n  };\n  /**\n   * Remove all listeners, or those of the specified event.\n   *\n   * @param {(String|Symbol)} [event] The event name.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n\n\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n\n    if (event) {\n      evt = prefix ? prefix + event : event;\n      if (this._events[evt]) clearEvent(this, evt);\n    } else {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n\n    return this;\n  }; //\n  // Alias methods names because people roll like that.\n  //\n\n\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on; //\n  // Expose the prefix.\n  //\n\n  EventEmitter.prefixed = prefix; //\n  // Allow `EventEmitter` to be imported as module namespace.\n  //\n\n  EventEmitter.EventEmitter = EventEmitter; //\n  // Expose the module.\n  //\n\n  {\n    module.exports = EventEmitter;\n  }\n});\n\nvar pFinally = function pFinally(promise, onFinally) {\n  onFinally = onFinally || function () {};\n\n  return promise.then(function (val) {\n    return new Promise(function (resolve) {\n      resolve(onFinally());\n    }).then(function () {\n      return val;\n    });\n  }, function (err) {\n    return new Promise(function (resolve) {\n      resolve(onFinally());\n    }).then(function () {\n      throw err;\n    });\n  });\n};\n\nvar TimeoutError = /*#__PURE__*/function (_Error11) {\n  _inherits(TimeoutError, _Error11);\n\n  var _super14 = _createSuper(TimeoutError);\n\n  function TimeoutError(message) {\n    var _this14;\n\n    _classCallCheck(this, TimeoutError);\n\n    _this14 = _super14.call(this, message);\n    _this14.name = 'TimeoutError';\n    return _this14;\n  }\n\n  return TimeoutError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar pTimeout = function pTimeout(promise, milliseconds, fallback) {\n  return new Promise(function (resolve, reject) {\n    if (typeof milliseconds !== 'number' || milliseconds < 0) {\n      throw new TypeError('Expected `milliseconds` to be a positive number');\n    }\n\n    if (milliseconds === Infinity) {\n      resolve(promise);\n      return;\n    }\n\n    var timer = setTimeout(function () {\n      if (typeof fallback === 'function') {\n        try {\n          resolve(fallback());\n        } catch (error) {\n          reject(error);\n        }\n\n        return;\n      }\n\n      var message = typeof fallback === 'string' ? fallback : \"Promise timed out after \".concat(milliseconds, \" milliseconds\");\n      var timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n      if (typeof promise.cancel === 'function') {\n        promise.cancel();\n      }\n\n      reject(timeoutError);\n    }, milliseconds); // TODO: Use native `finally` keyword when targeting Node.js 10\n\n    pFinally( // eslint-disable-next-line promise/prefer-await-to-then\n    promise.then(resolve, reject), function () {\n      clearTimeout(timer);\n    });\n  });\n};\n\nvar pTimeout_1 = pTimeout; // TODO: Remove this for the next major release\n\nvar _default$3 = pTimeout;\nvar TimeoutError_1 = TimeoutError;\npTimeout_1.default = _default$3;\npTimeout_1.TimeoutError = TimeoutError_1; // Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\n\nfunction lowerBound(array, value, comparator) {\n  var first = 0;\n  var count = array.length;\n\n  while (count > 0) {\n    var step = count / 2 | 0;\n    var it = first + step;\n\n    if (comparator(array[it], value) <= 0) {\n      first = ++it;\n      count -= step + 1;\n    } else {\n      count = step;\n    }\n  }\n\n  return first;\n}\n\nvar _default$2 = lowerBound;\nvar lowerBound_1 = /*#__PURE__*/Object.defineProperty({\n  default: _default$2\n}, '__esModule', {\n  value: true\n});\n\nvar PriorityQueue = /*#__PURE__*/function () {\n  function PriorityQueue() {\n    _classCallCheck(this, PriorityQueue);\n\n    this._queue = [];\n  }\n\n  _createClass(PriorityQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(run, options) {\n      options = Object.assign({\n        priority: 0\n      }, options);\n      var element = {\n        priority: options.priority,\n        run: run\n      };\n\n      if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n        this._queue.push(element);\n\n        return;\n      }\n\n      var index = lowerBound_1.default(this._queue, element, function (a, b) {\n        return b.priority - a.priority;\n      });\n\n      this._queue.splice(index, 0, element);\n    }\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      var item = this._queue.shift();\n\n      return item && item.run;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._queue.length;\n    }\n  }]);\n\n  return PriorityQueue;\n}();\n\nvar _default$1 = PriorityQueue;\nvar priorityQueue = /*#__PURE__*/Object.defineProperty({\n  default: _default$1\n}, '__esModule', {\n  value: true\n});\n\nvar empty$1 = function empty$1() {};\n\nvar timeoutError = new pTimeout_1.default.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\n\nvar PQueue = /*#__PURE__*/function (_eventemitter) {\n  _inherits(PQueue, _eventemitter);\n\n  var _super15 = _createSuper(PQueue);\n\n  function PQueue(options) {\n    var _this15;\n\n    _classCallCheck(this, PQueue);\n\n    _this15 = _super15.call(this);\n    _this15._intervalCount = 0;\n    _this15._intervalEnd = 0;\n    _this15._pendingCount = 0;\n    _this15._resolveEmpty = empty$1;\n    _this15._resolveIdle = empty$1; // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n\n    options = Object.assign({\n      carryoverConcurrencyCount: false,\n      intervalCap: Infinity,\n      interval: 0,\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: priorityQueue.default\n    }, options // TODO: Remove this `as`.\n    );\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(\"Expected `intervalCap` to be a number from 1 and up, got `\".concat(options.intervalCap, \"` (\").concat(typeof options.intervalCap, \")\"));\n    }\n\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(\"Expected `interval` to be a finite number >= 0, got `\".concat(options.interval, \"` (\").concat(typeof options.interval, \")\"));\n    }\n\n    _this15._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    _this15._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n    _this15._intervalCap = options.intervalCap;\n    _this15._interval = options.interval;\n    _this15._queue = new options.queueClass();\n    _this15._queueClass = options.queueClass;\n    _this15.concurrency = options.concurrency;\n    _this15._timeout = options.timeout;\n    _this15._throwOnTimeout = options.throwOnTimeout === true;\n    _this15._isPaused = options.autoStart === false;\n    return _this15;\n  }\n\n  _createClass(PQueue, [{\n    key: \"_next\",\n    value: function _next() {\n      this._pendingCount--;\n\n      this._tryToStartAnother();\n    }\n  }, {\n    key: \"_resolvePromises\",\n    value: function _resolvePromises() {\n      this._resolveEmpty();\n\n      this._resolveEmpty = empty$1;\n\n      if (this._pendingCount === 0) {\n        this._resolveIdle();\n\n        this._resolveIdle = empty$1;\n      }\n    }\n  }, {\n    key: \"_onResumeInterval\",\n    value: function _onResumeInterval() {\n      this._onInterval();\n\n      this._initializeIntervalIfNeeded();\n\n      this._timeoutId = undefined;\n    }\n  }, {\n    key: \"_isIntervalPaused\",\n    value: function _isIntervalPaused() {\n      var _this16 = this;\n\n      var now = Date.now();\n\n      if (this._intervalId === undefined) {\n        var delay = this._intervalEnd - now;\n\n        if (delay < 0) {\n          // Act as the interval was done\n          // We don't need to resume it here because it will be resumed on line 160\n          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        } else {\n          // Act as the interval is pending\n          if (this._timeoutId === undefined) {\n            this._timeoutId = setTimeout(function () {\n              _this16._onResumeInterval();\n            }, delay);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_tryToStartAnother\",\n    value: function _tryToStartAnother() {\n      if (this._queue.size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (this._intervalId) {\n          clearInterval(this._intervalId);\n        }\n\n        this._intervalId = undefined;\n\n        this._resolvePromises();\n\n        return false;\n      }\n\n      if (!this._isPaused) {\n        var canInitializeInterval = !this._isIntervalPaused();\n\n        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n          this.emit('active');\n\n          this._queue.dequeue()();\n\n          if (canInitializeInterval) {\n            this._initializeIntervalIfNeeded();\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_initializeIntervalIfNeeded\",\n    value: function _initializeIntervalIfNeeded() {\n      var _this17 = this;\n\n      if (this._isIntervalIgnored || this._intervalId !== undefined) {\n        return;\n      }\n\n      this._intervalId = setInterval(function () {\n        _this17._onInterval();\n      }, this._interval);\n      this._intervalEnd = Date.now() + this._interval;\n    }\n  }, {\n    key: \"_onInterval\",\n    value: function _onInterval() {\n      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n        clearInterval(this._intervalId);\n        this._intervalId = undefined;\n      }\n\n      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n      this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n\n  }, {\n    key: \"_processQueue\",\n    value: function _processQueue() {\n      // eslint-disable-next-line no-empty\n      while (this._tryToStartAnother()) {}\n    }\n  }, {\n    key: \"add\",\n\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(fn) {\n        var _this18 = this;\n\n        var options,\n            _args16 = arguments;\n        return _regeneratorRuntime.wrap(function _callee12$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                options = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};\n                return _context16.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var run = /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n                      var operation;\n                      return _regeneratorRuntime.wrap(function _callee11$(_context15) {\n                        while (1) {\n                          switch (_context15.prev = _context15.next) {\n                            case 0:\n                              _this18._pendingCount++;\n                              _this18._intervalCount++;\n                              _context15.prev = 2;\n                              operation = _this18._timeout === undefined && options.timeout === undefined ? fn() : pTimeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? _this18._timeout : options.timeout, function () {\n                                if (options.throwOnTimeout === undefined ? _this18._throwOnTimeout : options.throwOnTimeout) {\n                                  reject(timeoutError);\n                                }\n\n                                return undefined;\n                              });\n                              _context15.t0 = resolve;\n                              _context15.next = 7;\n                              return operation;\n\n                            case 7:\n                              _context15.t1 = _context15.sent;\n                              (0, _context15.t0)(_context15.t1);\n                              _context15.next = 14;\n                              break;\n\n                            case 11:\n                              _context15.prev = 11;\n                              _context15.t2 = _context15[\"catch\"](2);\n                              reject(_context15.t2);\n\n                            case 14:\n                              _this18._next();\n\n                            case 15:\n                            case \"end\":\n                              return _context15.stop();\n                          }\n                        }\n                      }, _callee11, null, [[2, 11]]);\n                    }));\n\n                    return function run() {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }();\n\n                  _this18._queue.enqueue(run, options);\n\n                  _this18._tryToStartAnother();\n                }));\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      function add(_x36) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n     @returns A promise that resolves when all functions are resolved.\n    */\n\n  }, {\n    key: \"addAll\",\n    value: function () {\n      var _addAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(functions, options) {\n        var _this19 = this;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                return _context18.abrupt(\"return\", Promise.all(functions.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(function_) {\n                    return _regeneratorRuntime.wrap(function _callee13$(_context17) {\n                      while (1) {\n                        switch (_context17.prev = _context17.next) {\n                          case 0:\n                            return _context17.abrupt(\"return\", _this19.add(function_, options));\n\n                          case 1:\n                          case \"end\":\n                            return _context17.stop();\n                        }\n                      }\n                    }, _callee13);\n                  }));\n\n                  return function (_x39) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }())));\n\n              case 1:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee14);\n      }));\n\n      function addAll(_x37, _x38) {\n        return _addAll.apply(this, arguments);\n      }\n\n      return addAll;\n    }()\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (!this._isPaused) {\n        return this;\n      }\n\n      this._isPaused = false;\n\n      this._processQueue();\n\n      return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n     @returns A promise that settles when the queue becomes empty.\n    */\n\n  }, {\n    key: \"onEmpty\",\n    value: function () {\n      var _onEmpty = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        var _this20 = this;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                if (!(this._queue.size === 0)) {\n                  _context19.next = 2;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\");\n\n              case 2:\n                return _context19.abrupt(\"return\", new Promise(function (resolve) {\n                  var existingResolve = _this20._resolveEmpty;\n\n                  _this20._resolveEmpty = function () {\n                    existingResolve();\n                    resolve();\n                  };\n                }));\n\n              case 3:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function onEmpty() {\n        return _onEmpty.apply(this, arguments);\n      }\n\n      return onEmpty;\n    }()\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n     @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n\n  }, {\n    key: \"onIdle\",\n    value: function () {\n      var _onIdle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var _this21 = this;\n\n        return _regeneratorRuntime.wrap(function _callee16$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!(this._pendingCount === 0 && this._queue.size === 0)) {\n                  _context20.next = 2;\n                  break;\n                }\n\n                return _context20.abrupt(\"return\");\n\n              case 2:\n                return _context20.abrupt(\"return\", new Promise(function (resolve) {\n                  var existingResolve = _this21._resolveIdle;\n\n                  _this21._resolveIdle = function () {\n                    existingResolve();\n                    resolve();\n                  };\n                }));\n\n              case 3:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function onIdle() {\n        return _onIdle.apply(this, arguments);\n      }\n\n      return onIdle;\n    }()\n    /**\n    Size of the queue.\n    */\n\n  }, {\n    key: \"_doesIntervalAllowAnother\",\n    get: function get() {\n      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n  }, {\n    key: \"_doesConcurrentAllowAnother\",\n    get: function get() {\n      return this._pendingCount < this._concurrency;\n    }\n  }, {\n    key: \"concurrency\",\n    get: function get() {\n      return this._concurrency;\n    },\n    set: function set(newConcurrency) {\n      if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n        throw new TypeError(\"Expected `concurrency` to be a number from 1 and up, got `\".concat(newConcurrency, \"` (\").concat(typeof newConcurrency, \")\"));\n      }\n\n      this._concurrency = newConcurrency;\n\n      this._processQueue();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._queue.size;\n    }\n    /**\n    Number of pending promises.\n    */\n\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return this._isPaused;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n\n  }, {\n    key: \"timeout\",\n    set: function set(milliseconds) {\n      this._timeout = milliseconds;\n    },\n    get: function get() {\n      return this._timeout;\n    }\n  }]);\n\n  return PQueue;\n}(eventemitter3);\n\nvar _default = PQueue;\n\nvar ZarrArray = /*#__PURE__*/function () {\n  /**\r\n   * Instantiate an array from an initialized store.\r\n   * @param store Array store, already initialized.\r\n   * @param path Storage path.\r\n   * @param metadata The initial value for the metadata\r\n   * @param readOnly True if array should be protected against modification.\r\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\r\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\r\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\r\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\r\n   */\n  function ZarrArray(store) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var metadata = arguments.length > 2 ? arguments[2] : undefined;\n    var readOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var chunkStore = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var cacheMetadata = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var cacheAttrs = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n\n    _classCallCheck(this, ZarrArray);\n\n    // N.B., expect at this point store is fully initialized with all\n    // configuration metadata fully specified and normalized\n    this.store = store;\n    this._chunkStore = chunkStore;\n    this.path = normalizeStoragePath(path);\n    this.keyPrefix = pathToPrefix(this.path);\n    this.readOnly = readOnly;\n    this.cacheMetadata = cacheMetadata;\n    this.cacheAttrs = cacheAttrs;\n    this.meta = metadata;\n\n    if (this.meta.compressor !== null) {\n      this.compressor = getCodec(this.meta.compressor);\n    } else {\n      this.compressor = null;\n    }\n\n    var attrKey = this.keyPrefix + ATTRS_META_KEY;\n    this.attrs = new Attributes(this.store, attrKey, this.readOnly, cacheAttrs);\n  }\n  /**\r\n   * A `Store` providing the underlying storage for array chunks.\r\n   */\n\n\n  _createClass(ZarrArray, [{\n    key: \"reloadMetadata\",\n\n    /**\r\n     * (Re)load metadata from store\r\n     */\n    value: function () {\n      var _reloadMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        var metaKey, metaStoreValue;\n        return _regeneratorRuntime.wrap(function _callee17$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                metaKey = this.keyPrefix + ARRAY_META_KEY;\n                metaStoreValue = this.store.getItem(metaKey);\n                _context21.t0 = parseMetadata;\n                _context21.next = 5;\n                return metaStoreValue;\n\n              case 5:\n                _context21.t1 = _context21.sent;\n                this.meta = (0, _context21.t0)(_context21.t1);\n                return _context21.abrupt(\"return\", this.meta);\n\n              case 8:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function reloadMetadata() {\n        return _reloadMetadata.apply(this, arguments);\n      }\n\n      return reloadMetadata;\n    }()\n  }, {\n    key: \"refreshMetadata\",\n    value: function () {\n      var _refreshMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        return _regeneratorRuntime.wrap(function _callee18$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (this.cacheMetadata) {\n                  _context22.next = 3;\n                  break;\n                }\n\n                _context22.next = 3;\n                return this.reloadMetadata();\n\n              case 3:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function refreshMetadata() {\n        return _refreshMetadata.apply(this, arguments);\n      }\n\n      return refreshMetadata;\n    }()\n  }, {\n    key: \"get\",\n    value: function get() {\n      var selection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.getBasicSelection(selection, false, opts);\n    }\n  }, {\n    key: \"getRaw\",\n    value: function getRaw() {\n      var selection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.getBasicSelection(selection, true, opts);\n    }\n  }, {\n    key: \"getBasicSelection\",\n    value: function () {\n      var _getBasicSelection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(selection) {\n        var asRaw,\n            _ref4,\n            _ref4$concurrencyLimi,\n            concurrencyLimit,\n            progressCallback,\n            _args23 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee19$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                asRaw = _args23.length > 1 && _args23[1] !== undefined ? _args23[1] : false;\n                _ref4 = _args23.length > 2 && _args23[2] !== undefined ? _args23[2] : {}, _ref4$concurrencyLimi = _ref4.concurrencyLimit, concurrencyLimit = _ref4$concurrencyLimi === void 0 ? 10 : _ref4$concurrencyLimi, progressCallback = _ref4.progressCallback;\n\n                if (this.cacheMetadata) {\n                  _context23.next = 5;\n                  break;\n                }\n\n                _context23.next = 5;\n                return this.reloadMetadata();\n\n              case 5:\n                if (!(this.shape === [])) {\n                  _context23.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Shape [] indexing is not supported yet\");\n\n              case 9:\n                return _context23.abrupt(\"return\", this.getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback));\n\n              case 10:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function getBasicSelection(_x40) {\n        return _getBasicSelection.apply(this, arguments);\n      }\n\n      return getBasicSelection;\n    }()\n  }, {\n    key: \"getBasicSelectionND\",\n    value: function getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback) {\n      var indexer = new BasicIndexer(selection, this);\n      return this.getSelection(indexer, asRaw, concurrencyLimit, progressCallback);\n    }\n  }, {\n    key: \"getSelection\",\n    value: function () {\n      var _getSelection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(indexer, asRaw, concurrencyLimit, progressCallback) {\n        var _this22 = this;\n\n        var outDtype, outShape, outSize, itr, proj, chunkProjection, _out, out, queue, _iterator8, _step8, _loop2;\n\n        return _regeneratorRuntime.wrap(function _callee21$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                // We iterate over all chunks which overlap the selection and thus contain data\n                // that needs to be extracted. Each chunk is processed in turn, extracting the\n                // necessary data and storing into the correct location in the output array.\n                // N.B., it is an important optimisation that we only visit chunks which overlap\n                // the selection. This minimises the number of iterations in the main for loop.\n                // check fields are sensible (TODO?)\n                outDtype = this.dtype;\n                outShape = indexer.shape;\n                outSize = indexer.shape.reduce(function (x, y) {\n                  return x * y;\n                }, 1);\n\n                if (!(asRaw && outSize === this.chunkSize)) {\n                  _context25.next = 12;\n                  break;\n                }\n\n                // Optimization: if output strided array _is_ chunk exactly,\n                // decode directly as new TypedArray and return\n                itr = indexer.iter();\n                proj = itr.next(); // ensure there is only one projection\n\n                if (!(proj.done === false && itr.next().done === true)) {\n                  _context25.next = 12;\n                  break;\n                }\n\n                chunkProjection = proj.value;\n                _context25.next = 10;\n                return this.decodeDirectToRawArray(chunkProjection, outShape, outSize);\n\n              case 10:\n                _out = _context25.sent;\n                return _context25.abrupt(\"return\", _out);\n\n              case 12:\n                out = asRaw ? new RawArray(null, outShape, outDtype) : new NestedArray(null, outShape, outDtype);\n\n                if (!(outSize === 0)) {\n                  _context25.next = 15;\n                  break;\n                }\n\n                return _context25.abrupt(\"return\", out);\n\n              case 15:\n                // create promise queue with concurrency control\n                queue = new _default({\n                  concurrency: concurrencyLimit\n                });\n\n                if (progressCallback) {\n                  (function () {\n                    var progress = 0;\n                    var queueSize = 0;\n\n                    var _iterator6 = _createForOfIteratorHelper(indexer.iter()),\n                        _step6;\n\n                    try {\n                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                        var _ = _step6.value;\n                        queueSize += 1;\n                      }\n                    } catch (err) {\n                      _iterator6.e(err);\n                    } finally {\n                      _iterator6.f();\n                    }\n\n                    progressCallback({\n                      progress: 0,\n                      queueSize: queueSize\n                    });\n\n                    var _iterator7 = _createForOfIteratorHelper(indexer.iter()),\n                        _step7;\n\n                    try {\n                      var _loop = function _loop() {\n                        var proj = _step7.value;\n\n                        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n                          return _regeneratorRuntime.wrap(function _callee20$(_context24) {\n                            while (1) {\n                              switch (_context24.prev = _context24.next) {\n                                case 0:\n                                  _context24.next = 2;\n                                  return queue.add(function () {\n                                    return _this22.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes);\n                                  });\n\n                                case 2:\n                                  progress += 1;\n                                  progressCallback({\n                                    progress: progress,\n                                    queueSize: queueSize\n                                  });\n\n                                case 4:\n                                case \"end\":\n                                  return _context24.stop();\n                              }\n                            }\n                          }, _callee20);\n                        }))();\n                      };\n\n                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                        _loop();\n                      }\n                    } catch (err) {\n                      _iterator7.e(err);\n                    } finally {\n                      _iterator7.f();\n                    }\n                  })();\n                } else {\n                  _iterator8 = _createForOfIteratorHelper(indexer.iter());\n\n                  try {\n                    _loop2 = function _loop2() {\n                      var proj = _step8.value;\n                      queue.add(function () {\n                        return _this22.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes);\n                      });\n                    };\n\n                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                      _loop2();\n                    }\n                  } catch (err) {\n                    _iterator8.e(err);\n                  } finally {\n                    _iterator8.f();\n                  }\n                } // guarantees that all work on queue has finished\n\n\n                _context25.next = 19;\n                return queue.onIdle();\n\n              case 19:\n                if (!(out.shape.length === 0)) {\n                  _context25.next = 21;\n                  break;\n                }\n\n                return _context25.abrupt(\"return\", out.data[0]);\n\n              case 21:\n                return _context25.abrupt(\"return\", out);\n\n              case 22:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function getSelection(_x41, _x42, _x43, _x44) {\n        return _getSelection.apply(this, arguments);\n      }\n\n      return getSelection;\n    }()\n    /**\r\n     * Obtain part or whole of a chunk.\r\n     * @param chunkCoords Indices of the chunk.\r\n     * @param chunkSelection Location of region within the chunk to extract.\r\n     * @param out Array to store result in.\r\n     * @param outSelection Location of region within output array to store results in.\r\n     * @param dropAxes Axes to squeeze out of the chunk.\r\n     */\n\n  }, {\n    key: \"chunkGetItem\",\n    value: function () {\n      var _chunkGetItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(chunkCoords, chunkSelection, out, outSelection, dropAxes) {\n        var cKey, cdata, decodedChunk, chunk, tmp;\n        return _regeneratorRuntime.wrap(function _callee22$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                if (!(chunkCoords.length !== this._chunkDataShape.length)) {\n                  _context26.next = 2;\n                  break;\n                }\n\n                throw new ValueError(\"Inconsistent shapes: chunkCoordsLength: \".concat(chunkCoords.length, \", cDataShapeLength: \").concat(this.chunkDataShape.length));\n\n              case 2:\n                cKey = this.chunkKey(chunkCoords);\n                _context26.prev = 3;\n                _context26.next = 6;\n                return this.chunkStore.getItem(cKey);\n\n              case 6:\n                cdata = _context26.sent;\n                _context26.next = 9;\n                return this.decodeChunk(cdata);\n\n              case 9:\n                decodedChunk = _context26.sent;\n\n                if (!(out instanceof NestedArray)) {\n                  _context26.next = 21;\n                  break;\n                }\n\n                if (!(isContiguousSelection(outSelection) && isTotalSlice(chunkSelection, this.chunks) && !this.meta.filters)) {\n                  _context26.next = 14;\n                  break;\n                }\n\n                // Optimization: we want the whole chunk, and the destination is\n                // contiguous, so we can decompress directly from the chunk\n                // into the destination array\n                // TODO check order\n                // TODO filters..\n                out.set(outSelection, this.toNestedArray(decodedChunk));\n                return _context26.abrupt(\"return\");\n\n              case 14:\n                // Decode chunk\n                chunk = this.toNestedArray(decodedChunk);\n                tmp = chunk.get(chunkSelection);\n\n                if (!(dropAxes !== null)) {\n                  _context26.next = 18;\n                  break;\n                }\n\n                throw new Error(\"Drop axes is not supported yet\");\n\n              case 18:\n                out.set(outSelection, tmp);\n                _context26.next = 22;\n                break;\n\n              case 21:\n                /* RawArray\r\n                Copies chunk by index directly into output. Doesn't matter if selection is contiguous\r\n                since store/output are different shapes/strides.\r\n                */\n                out.set(outSelection, this.chunkBufferToRawArray(decodedChunk), chunkSelection);\n\n              case 22:\n                _context26.next = 31;\n                break;\n\n              case 24:\n                _context26.prev = 24;\n                _context26.t0 = _context26[\"catch\"](3);\n\n                if (!isKeyError(_context26.t0)) {\n                  _context26.next = 30;\n                  break;\n                }\n\n                // fill with scalar if cKey doesn't exist in store\n                if (this.fillValue !== null) {\n                  out.set(outSelection, this.fillValue);\n                }\n\n                _context26.next = 31;\n                break;\n\n              case 30:\n                throw _context26.t0;\n\n              case 31:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee22, this, [[3, 24]]);\n      }));\n\n      function chunkGetItem(_x45, _x46, _x47, _x48, _x49) {\n        return _chunkGetItem.apply(this, arguments);\n      }\n\n      return chunkGetItem;\n    }()\n  }, {\n    key: \"getRawChunk\",\n    value: function () {\n      var _getRawChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(chunkCoords, opts) {\n        var i, dimLength, cKey, cdata, buffer, outShape;\n        return _regeneratorRuntime.wrap(function _callee23$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                if (!(chunkCoords.length !== this.shape.length)) {\n                  _context27.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Chunk coordinates \".concat(chunkCoords.join(\".\"), \" do not correspond to shape \").concat(this.shape, \".\"));\n\n              case 2:\n                _context27.prev = 2;\n\n                for (i = 0; i < chunkCoords.length; i++) {\n                  dimLength = Math.ceil(this.shape[i] / this.chunks[i]);\n                  chunkCoords[i] = normalizeIntegerSelection(chunkCoords[i], dimLength);\n                }\n\n                _context27.next = 13;\n                break;\n\n              case 6:\n                _context27.prev = 6;\n                _context27.t0 = _context27[\"catch\"](2);\n\n                if (!(_context27.t0 instanceof BoundsCheckError)) {\n                  _context27.next = 12;\n                  break;\n                }\n\n                throw new BoundsCheckError(\"index \".concat(chunkCoords.join(\".\"), \" is out of bounds for shape: \").concat(this.shape, \" and chunks \").concat(this.chunks));\n\n              case 12:\n                throw _context27.t0;\n\n              case 13:\n                cKey = this.chunkKey(chunkCoords);\n                cdata = this.chunkStore.getItem(cKey, opts === null || opts === void 0 ? void 0 : opts.storeOptions);\n                _context27.t1 = this;\n                _context27.next = 18;\n                return cdata;\n\n              case 18:\n                _context27.t2 = _context27.sent;\n                _context27.next = 21;\n                return _context27.t1.decodeChunk.call(_context27.t1, _context27.t2);\n\n              case 21:\n                buffer = _context27.sent;\n                outShape = this.chunks.filter(function (d) {\n                  return d !== 1;\n                }); // squeeze chunk dim if 1\n\n                return _context27.abrupt(\"return\", new RawArray(buffer, outShape, this.dtype));\n\n              case 24:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee23, this, [[2, 6]]);\n      }));\n\n      function getRawChunk(_x50, _x51) {\n        return _getRawChunk.apply(this, arguments);\n      }\n\n      return getRawChunk;\n    }()\n  }, {\n    key: \"chunkKey\",\n    value: function chunkKey(chunkCoords) {\n      var _a;\n\n      var sep = (_a = this.meta.dimension_separator) !== null && _a !== void 0 ? _a : \".\";\n      return this.keyPrefix + chunkCoords.join(sep);\n    }\n  }, {\n    key: \"ensureByteArray\",\n    value: function ensureByteArray(chunkData) {\n      if (typeof chunkData === \"string\") {\n        return new Uint8Array(Buffer.from(chunkData).buffer);\n      }\n\n      return new Uint8Array(chunkData);\n    }\n  }, {\n    key: \"toTypedArray\",\n    value: function toTypedArray(buffer) {\n      return new (getTypedArrayCtr(this.dtype))(buffer);\n    }\n  }, {\n    key: \"toNestedArray\",\n    value: function toNestedArray(data) {\n      var buffer = this.ensureByteArray(data).buffer;\n      return new NestedArray(buffer, this.chunks, this.dtype);\n    }\n  }, {\n    key: \"decodeChunk\",\n    value: function () {\n      var _decodeChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(chunkData) {\n        var bytes;\n        return _regeneratorRuntime.wrap(function _callee24$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                bytes = this.ensureByteArray(chunkData);\n\n                if (!(this.compressor !== null)) {\n                  _context28.next = 7;\n                  break;\n                }\n\n                _context28.next = 4;\n                return this.compressor;\n\n              case 4:\n                _context28.next = 6;\n                return _context28.sent.decode(bytes);\n\n              case 6:\n                bytes = _context28.sent;\n\n              case 7:\n                if (this.dtype.includes('>')) {\n                  // Need to flip bytes for Javascript TypedArrays\n                  // We flip bytes in-place to avoid creating an extra copy of the decoded buffer.\n                  byteSwapInplace(this.toTypedArray(bytes.buffer));\n                } // TODO filtering etc\n\n\n                return _context28.abrupt(\"return\", bytes.buffer);\n\n              case 9:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function decodeChunk(_x52) {\n        return _decodeChunk.apply(this, arguments);\n      }\n\n      return decodeChunk;\n    }()\n  }, {\n    key: \"chunkBufferToRawArray\",\n    value: function chunkBufferToRawArray(buffer) {\n      return new RawArray(buffer, this.chunks, this.dtype);\n    }\n  }, {\n    key: \"decodeDirectToRawArray\",\n    value: function () {\n      var _decodeDirectToRawArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(_ref6, outShape, outSize) {\n        var chunkCoords, cKey, cdata, data;\n        return _regeneratorRuntime.wrap(function _callee25$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                chunkCoords = _ref6.chunkCoords;\n                cKey = this.chunkKey(chunkCoords);\n                _context29.prev = 2;\n                _context29.next = 5;\n                return this.chunkStore.getItem(cKey);\n\n              case 5:\n                cdata = _context29.sent;\n                _context29.t0 = RawArray;\n                _context29.next = 9;\n                return this.decodeChunk(cdata);\n\n              case 9:\n                _context29.t1 = _context29.sent;\n                _context29.t2 = outShape;\n                _context29.t3 = this.dtype;\n                return _context29.abrupt(\"return\", new _context29.t0(_context29.t1, _context29.t2, _context29.t3));\n\n              case 15:\n                _context29.prev = 15;\n                _context29.t4 = _context29[\"catch\"](2);\n\n                if (!isKeyError(_context29.t4)) {\n                  _context29.next = 22;\n                  break;\n                }\n\n                // fill with scalar if item doesn't exist\n                data = new (getTypedArrayCtr(this.dtype))(outSize);\n                return _context29.abrupt(\"return\", new RawArray(data.fill(this.fillValue), outShape));\n\n              case 22:\n                throw _context29.t4;\n\n              case 23:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee25, this, [[2, 15]]);\n      }));\n\n      function decodeDirectToRawArray(_x53, _x54, _x55) {\n        return _decodeDirectToRawArray.apply(this, arguments);\n      }\n\n      return decodeDirectToRawArray;\n    }()\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {\n        var selection,\n            value,\n            opts,\n            _args30 = arguments;\n        return _regeneratorRuntime.wrap(function _callee26$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                selection = _args30.length > 0 && _args30[0] !== undefined ? _args30[0] : null;\n                value = _args30.length > 1 ? _args30[1] : undefined;\n                opts = _args30.length > 2 && _args30[2] !== undefined ? _args30[2] : {};\n                _context30.next = 5;\n                return this.setBasicSelection(selection, value, opts);\n\n              case 5:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function set() {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }()\n  }, {\n    key: \"setBasicSelection\",\n    value: function () {\n      var _setBasicSelection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(selection, value) {\n        var _ref7,\n            _ref7$concurrencyLimi,\n            concurrencyLimit,\n            progressCallback,\n            _args31 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee27$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _ref7 = _args31.length > 2 && _args31[2] !== undefined ? _args31[2] : {}, _ref7$concurrencyLimi = _ref7.concurrencyLimit, concurrencyLimit = _ref7$concurrencyLimi === void 0 ? 10 : _ref7$concurrencyLimi, progressCallback = _ref7.progressCallback;\n\n                if (!this.readOnly) {\n                  _context31.next = 3;\n                  break;\n                }\n\n                throw new PermissionError(\"Object is read only\");\n\n              case 3:\n                if (this.cacheMetadata) {\n                  _context31.next = 6;\n                  break;\n                }\n\n                _context31.next = 6;\n                return this.reloadMetadata();\n\n              case 6:\n                if (!(this.shape === [])) {\n                  _context31.next = 10;\n                  break;\n                }\n\n                throw new Error(\"Shape [] indexing is not supported yet\");\n\n              case 10:\n                _context31.next = 12;\n                return this.setBasicSelectionND(selection, value, concurrencyLimit, progressCallback);\n\n              case 12:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function setBasicSelection(_x56, _x57) {\n        return _setBasicSelection.apply(this, arguments);\n      }\n\n      return setBasicSelection;\n    }()\n  }, {\n    key: \"setBasicSelectionND\",\n    value: function () {\n      var _setBasicSelectionND = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28(selection, value, concurrencyLimit, progressCallback) {\n        var indexer;\n        return _regeneratorRuntime.wrap(function _callee28$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                indexer = new BasicIndexer(selection, this);\n                _context32.next = 3;\n                return this.setSelection(indexer, value, concurrencyLimit, progressCallback);\n\n              case 3:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function setBasicSelectionND(_x58, _x59, _x60, _x61) {\n        return _setBasicSelectionND.apply(this, arguments);\n      }\n\n      return setBasicSelectionND;\n    }()\n  }, {\n    key: \"getChunkValue\",\n    value: function getChunkValue(proj, indexer, value, selectionShape) {\n      var chunkValue;\n\n      if (selectionShape === []) {\n        chunkValue = value;\n      } else if (typeof value === \"number\") {\n        chunkValue = value;\n      } else {\n        chunkValue = value.get(proj.outSelection); // tslint:disable-next-line: strict-type-predicates\n\n        if (indexer.dropAxes !== null) {\n          throw new Error(\"Handling drop axes not supported yet\");\n        }\n      }\n\n      return chunkValue;\n    }\n  }, {\n    key: \"setSelection\",\n    value: function () {\n      var _setSelection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(indexer, value, concurrencyLimit, progressCallback) {\n        var _this23 = this;\n\n        var selectionShape, queue, _iterator11, _step11, _loop4;\n\n        return _regeneratorRuntime.wrap(function _callee30$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                // We iterate over all chunks which overlap the selection and thus contain data\n                // that needs to be replaced. Each chunk is processed in turn, extracting the\n                // necessary data from the value array and storing into the chunk array.\n                // N.B., it is an important optimisation that we only visit chunks which overlap\n                // the selection. This minimises the number of iterations in the main for loop.\n                // TODO? check fields are sensible\n                // Determine indices of chunks overlapping the selection\n                selectionShape = indexer.shape; // Check value shape\n\n                if (!(selectionShape === [])) {\n                  _context34.next = 5;\n                  break;\n                }\n\n                ;\n                _context34.next = 15;\n                break;\n\n              case 5:\n                if (!(typeof value === \"number\")) {\n                  _context34.next = 9;\n                  break;\n                }\n\n                ;\n                _context34.next = 15;\n                break;\n\n              case 9:\n                if (!(value instanceof NestedArray)) {\n                  _context34.next = 14;\n                  break;\n                }\n\n                if (arrayEquals1D(value.shape, selectionShape)) {\n                  _context34.next = 12;\n                  break;\n                }\n\n                throw new ValueError(\"Shape mismatch in source NestedArray and set selection: \".concat(value.shape, \" and \").concat(selectionShape));\n\n              case 12:\n                _context34.next = 15;\n                break;\n\n              case 14:\n                throw new Error(\"Unknown data type for setting :(\");\n\n              case 15:\n                queue = new _default({\n                  concurrency: concurrencyLimit\n                });\n\n                if (progressCallback) {\n                  (function () {\n                    var queueSize = 0;\n\n                    var _iterator9 = _createForOfIteratorHelper(indexer.iter()),\n                        _step9;\n\n                    try {\n                      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                        var _ = _step9.value;\n                        queueSize += 1;\n                      }\n                    } catch (err) {\n                      _iterator9.e(err);\n                    } finally {\n                      _iterator9.f();\n                    }\n\n                    var progress = 0;\n                    progressCallback({\n                      progress: 0,\n                      queueSize: queueSize\n                    });\n\n                    var _iterator10 = _createForOfIteratorHelper(indexer.iter()),\n                        _step10;\n\n                    try {\n                      var _loop3 = function _loop3() {\n                        var proj = _step10.value;\n\n                        var chunkValue = _this23.getChunkValue(proj, indexer, value, selectionShape);\n\n                        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {\n                          return _regeneratorRuntime.wrap(function _callee29$(_context33) {\n                            while (1) {\n                              switch (_context33.prev = _context33.next) {\n                                case 0:\n                                  _context33.next = 2;\n                                  return queue.add(function () {\n                                    return _this23.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue);\n                                  });\n\n                                case 2:\n                                  progress += 1;\n                                  progressCallback({\n                                    progress: progress,\n                                    queueSize: queueSize\n                                  });\n\n                                case 4:\n                                case \"end\":\n                                  return _context33.stop();\n                              }\n                            }\n                          }, _callee29);\n                        }))();\n                      };\n\n                      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                        _loop3();\n                      }\n                    } catch (err) {\n                      _iterator10.e(err);\n                    } finally {\n                      _iterator10.f();\n                    }\n                  })();\n                } else {\n                  _iterator11 = _createForOfIteratorHelper(indexer.iter());\n\n                  try {\n                    _loop4 = function _loop4() {\n                      var proj = _step11.value;\n\n                      var chunkValue = _this23.getChunkValue(proj, indexer, value, selectionShape);\n\n                      queue.add(function () {\n                        return _this23.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue);\n                      });\n                    };\n\n                    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                      _loop4();\n                    }\n                  } catch (err) {\n                    _iterator11.e(err);\n                  } finally {\n                    _iterator11.f();\n                  }\n                } // guarantees that all work on queue has finished\n\n\n                _context34.next = 19;\n                return queue.onIdle();\n\n              case 19:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee30);\n      }));\n\n      function setSelection(_x62, _x63, _x64, _x65) {\n        return _setSelection.apply(this, arguments);\n      }\n\n      return setSelection;\n    }()\n  }, {\n    key: \"chunkSetItem\",\n    value: function () {\n      var _chunkSetItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31(chunkCoords, chunkSelection, value) {\n        var chunkKey, chunk, dtypeConstr, chunkSize, _chunkData, chunkStoreData, dBytes, chunkNestedArray, chunkData;\n\n        return _regeneratorRuntime.wrap(function _callee31$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                // Obtain key for chunk storage\n                chunkKey = this.chunkKey(chunkCoords);\n                chunk = null;\n                dtypeConstr = getTypedArrayCtr(this.dtype);\n                chunkSize = this.chunkSize;\n\n                if (!isTotalSlice(chunkSelection, this.chunks)) {\n                  _context35.next = 8;\n                  break;\n                }\n\n                // Totally replace chunk\n                // Optimization: we are completely replacing the chunk, so no need\n                // to access the existing chunk data\n                if (typeof value === \"number\") {\n                  // TODO get the right type here\n                  chunk = new dtypeConstr(chunkSize);\n                  chunk.fill(value);\n                } else {\n                  chunk = value.flatten();\n                }\n\n                _context35.next = 29;\n                break;\n\n              case 8:\n                _context35.prev = 8;\n                _context35.next = 11;\n                return this.chunkStore.getItem(chunkKey);\n\n              case 11:\n                chunkStoreData = _context35.sent;\n                _context35.next = 14;\n                return this.decodeChunk(chunkStoreData);\n\n              case 14:\n                dBytes = _context35.sent;\n                _chunkData = this.toTypedArray(dBytes);\n                _context35.next = 26;\n                break;\n\n              case 18:\n                _context35.prev = 18;\n                _context35.t0 = _context35[\"catch\"](8);\n\n                if (!isKeyError(_context35.t0)) {\n                  _context35.next = 25;\n                  break;\n                }\n\n                // Chunk is not initialized\n                _chunkData = new dtypeConstr(chunkSize);\n\n                if (this.fillValue !== null) {\n                  _chunkData.fill(this.fillValue);\n                }\n\n                _context35.next = 26;\n                break;\n\n              case 25:\n                throw _context35.t0;\n\n              case 26:\n                chunkNestedArray = new NestedArray(_chunkData, this.chunks, this.dtype);\n                chunkNestedArray.set(chunkSelection, value);\n                chunk = chunkNestedArray.flatten();\n\n              case 29:\n                _context35.next = 31;\n                return this.encodeChunk(chunk);\n\n              case 31:\n                chunkData = _context35.sent;\n                this.chunkStore.setItem(chunkKey, chunkData);\n\n              case 33:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee31, this, [[8, 18]]);\n      }));\n\n      function chunkSetItem(_x66, _x67, _x68) {\n        return _chunkSetItem.apply(this, arguments);\n      }\n\n      return chunkSetItem;\n    }()\n  }, {\n    key: \"encodeChunk\",\n    value: function () {\n      var _encodeChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(chunk) {\n        var bytes, cbytes;\n        return _regeneratorRuntime.wrap(function _callee32$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                if (this.dtype.includes('>')) {\n                  /*\r\n                   * If big endian, flip bytes before applying compression and setting store.\r\n                   *\r\n                   * Here we create a copy (not in-place byteswapping) to avoid flipping the\r\n                   * bytes in the buffers of user-created Raw- and NestedArrays.\r\n                  */\n                  chunk = byteSwap(chunk);\n                }\n\n                if (!(this.compressor !== null)) {\n                  _context36.next = 9;\n                  break;\n                }\n\n                bytes = new Uint8Array(chunk.buffer);\n                _context36.next = 5;\n                return this.compressor;\n\n              case 5:\n                _context36.next = 7;\n                return _context36.sent.encode(bytes);\n\n              case 7:\n                cbytes = _context36.sent;\n                return _context36.abrupt(\"return\", cbytes.buffer);\n\n              case 9:\n                return _context36.abrupt(\"return\", chunk.buffer);\n\n              case 10:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n\n      function encodeChunk(_x69) {\n        return _encodeChunk.apply(this, arguments);\n      }\n\n      return encodeChunk;\n    }()\n  }, {\n    key: \"chunkStore\",\n    get: function get() {\n      if (this._chunkStore) {\n        return this._chunkStore;\n      }\n\n      return this.store;\n    }\n    /**\r\n     * Array name following h5py convention.\r\n     */\n\n  }, {\n    key: \"name\",\n    get: function get() {\n      if (this.path.length > 0) {\n        if (this.path[0] !== \"/\") {\n          return \"/\" + this.path;\n        }\n\n        return this.path;\n      }\n\n      return null;\n    }\n    /**\r\n     * Final component of name.\r\n     */\n\n  }, {\n    key: \"basename\",\n    get: function get() {\n      var name = this.name;\n\n      if (name === null) {\n        return null;\n      }\n\n      var parts = name.split(\"/\");\n      return parts[parts.length - 1];\n    }\n    /**\r\n     * \"A list of integers describing the length of each dimension of the array.\r\n     */\n\n  }, {\n    key: \"shape\",\n    get: function get() {\n      // this.refreshMetadata();\n      return this.meta.shape;\n    }\n    /**\r\n     * A list of integers describing the length of each dimension of a chunk of the array.\r\n     */\n\n  }, {\n    key: \"chunks\",\n    get: function get() {\n      return this.meta.chunks;\n    }\n    /**\r\n     * Integer describing how many element a chunk contains\r\n     */\n\n  }, {\n    key: \"chunkSize\",\n    get: function get() {\n      return this.chunks.reduce(function (x, y) {\n        return x * y;\n      }, 1);\n    }\n    /**\r\n     *  The NumPy data type.\r\n     */\n\n  }, {\n    key: \"dtype\",\n    get: function get() {\n      return this.meta.dtype;\n    }\n    /**\r\n     *  A value used for uninitialized portions of the array.\r\n     */\n\n  }, {\n    key: \"fillValue\",\n    get: function get() {\n      var fillTypeValue = this.meta.fill_value; // TODO extract into function\n\n      if (fillTypeValue === \"NaN\") {\n        return NaN;\n      } else if (fillTypeValue === \"Infinity\") {\n        return Infinity;\n      } else if (fillTypeValue === \"-Infinity\") {\n        return -Infinity;\n      }\n\n      return this.meta.fill_value;\n    }\n    /**\r\n     *  Number of dimensions.\r\n     */\n\n  }, {\n    key: \"nDims\",\n    get: function get() {\n      return this.meta.shape.length;\n    }\n    /**\r\n     *  The total number of elements in the array.\r\n     */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      // this.refreshMetadata()\n      return this.meta.shape.reduce(function (x, y) {\n        return x * y;\n      }, 1);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.shape[0];\n    }\n  }, {\n    key: \"_chunkDataShape\",\n    get: function get() {\n      if (this.shape === []) {\n        return [1];\n      } else {\n        var s = [];\n\n        for (var i = 0; i < this.shape.length; i++) {\n          s[i] = Math.ceil(this.shape[i] / this.chunks[i]);\n        }\n\n        return s;\n      }\n    }\n    /**\r\n     * A tuple of integers describing the number of chunks along each\r\n     * dimension of the array.\r\n     */\n\n  }, {\n    key: \"chunkDataShape\",\n    get: function get() {\n      // this.refreshMetadata();\n      return this._chunkDataShape;\n    }\n    /**\r\n     * Total number of chunks.\r\n     */\n\n  }, {\n    key: \"numChunks\",\n    get: function get() {\n      // this.refreshMetadata();\n      return this.chunkDataShape.reduce(function (x, y) {\n        return x * y;\n      }, 1);\n    }\n    /**\r\n     * Instantiate an array from an initialized store.\r\n     * @param store Array store, already initialized.\r\n     * @param path Storage path.\r\n     * @param readOnly True if array should be protected against modification.\r\n     * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n     * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\r\n     * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\r\n     * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\r\n     * If false, user attributes are reloaded from the store prior to all attribute read operations.\r\n     */\n\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33(store) {\n        var path,\n            readOnly,\n            chunkStore,\n            cacheMetadata,\n            cacheAttrs,\n            metadata,\n            _args37 = arguments;\n        return _regeneratorRuntime.wrap(function _callee33$(_context37) {\n          while (1) {\n            switch (_context37.prev = _context37.next) {\n              case 0:\n                path = _args37.length > 1 && _args37[1] !== undefined ? _args37[1] : null;\n                readOnly = _args37.length > 2 && _args37[2] !== undefined ? _args37[2] : false;\n                chunkStore = _args37.length > 3 && _args37[3] !== undefined ? _args37[3] : null;\n                cacheMetadata = _args37.length > 4 && _args37[4] !== undefined ? _args37[4] : true;\n                cacheAttrs = _args37.length > 5 && _args37[5] !== undefined ? _args37[5] : true;\n                _context37.next = 7;\n                return this.loadMetadataForConstructor(store, path);\n\n              case 7:\n                metadata = _context37.sent;\n                return _context37.abrupt(\"return\", new ZarrArray(store, path, metadata, readOnly, chunkStore, cacheMetadata, cacheAttrs));\n\n              case 9:\n              case \"end\":\n                return _context37.stop();\n            }\n          }\n        }, _callee33, this);\n      }));\n\n      function create(_x70) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"loadMetadataForConstructor\",\n    value: function () {\n      var _loadMetadataForConstructor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(store, path) {\n        var keyPrefix, metaStoreValue;\n        return _regeneratorRuntime.wrap(function _callee34$(_context38) {\n          while (1) {\n            switch (_context38.prev = _context38.next) {\n              case 0:\n                _context38.prev = 0;\n                path = normalizeStoragePath(path);\n                keyPrefix = pathToPrefix(path);\n                _context38.next = 5;\n                return store.getItem(keyPrefix + ARRAY_META_KEY);\n\n              case 5:\n                metaStoreValue = _context38.sent;\n                return _context38.abrupt(\"return\", parseMetadata(metaStoreValue));\n\n              case 9:\n                _context38.prev = 9;\n                _context38.t0 = _context38[\"catch\"](0);\n                _context38.next = 13;\n                return containsGroup(store, path);\n\n              case 13:\n                if (!_context38.sent) {\n                  _context38.next = 15;\n                  break;\n                }\n\n                throw new ContainsGroupError(path !== null && path !== void 0 ? path : '');\n\n              case 15:\n                throw new Error(\"Failed to load metadata for ZarrArray:\" + _context38.t0.toString());\n\n              case 16:\n              case \"end\":\n                return _context38.stop();\n            }\n          }\n        }, _callee34, null, [[0, 9]]);\n      }));\n\n      function loadMetadataForConstructor(_x71, _x72) {\n        return _loadMetadataForConstructor.apply(this, arguments);\n      }\n\n      return loadMetadataForConstructor;\n    }()\n  }]);\n\n  return ZarrArray;\n}();\n\nvar MemoryStore = /*#__PURE__*/function () {\n  function MemoryStore() {\n    var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MemoryStore);\n\n    this.root = root;\n  }\n\n  _createClass(MemoryStore, [{\n    key: \"proxy\",\n    value: function proxy() {\n      return createProxy(this);\n    }\n  }, {\n    key: \"getParent\",\n    value: function getParent(item) {\n      var parent = this.root;\n      var segments = item.split('/'); // find the parent container\n\n      var _iterator12 = _createForOfIteratorHelper(segments.slice(0, segments.length - 1)),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var k = _step12.value;\n          parent = parent[k];\n\n          if (!parent) {\n            throw Error(item);\n          } // if not isinstance(parent, self.cls):\n          //     raise KeyError(item)\n\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return [parent, segments[segments.length - 1]];\n    }\n  }, {\n    key: \"requireParent\",\n    value: function requireParent(item) {\n      var parent = this.root;\n      var segments = item.split('/'); // require the parent container\n\n      var _iterator13 = _createForOfIteratorHelper(segments.slice(0, segments.length - 1)),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var k = _step13.value;\n\n          // TODO: verify correct implementation\n          if (parent[k] === undefined) {\n            parent[k] = {};\n          }\n\n          parent = parent[k];\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return [parent, segments[segments.length - 1]];\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(item) {\n      var _this$getParent = this.getParent(item),\n          _this$getParent2 = _slicedToArray(_this$getParent, 2),\n          parent = _this$getParent2[0],\n          key = _this$getParent2[1];\n\n      var value = parent[key];\n\n      if (value === undefined) {\n        throw new KeyError(item);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"setItem\",\n    value: function setItem(item, value) {\n      var _this$requireParent = this.requireParent(item),\n          _this$requireParent2 = _slicedToArray(_this$requireParent, 2),\n          parent = _this$requireParent2[0],\n          key = _this$requireParent2[1];\n\n      parent[key] = value;\n      return true;\n    }\n  }, {\n    key: \"deleteItem\",\n    value: function deleteItem(item) {\n      var _this$getParent3 = this.getParent(item),\n          _this$getParent4 = _slicedToArray(_this$getParent3, 2),\n          parent = _this$getParent4[0],\n          key = _this$getParent4[1];\n\n      return delete parent[key];\n    }\n  }, {\n    key: \"containsItem\",\n    value: function containsItem(item) {\n      // TODO: more sane implementation\n      try {\n        return this.getItem(item) !== undefined;\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      throw new Error(\"Method not implemented.\");\n    }\n  }]);\n\n  return MemoryStore;\n}();\n\nvar HTTPMethod;\n\n(function (HTTPMethod) {\n  HTTPMethod[\"HEAD\"] = \"HEAD\";\n  HTTPMethod[\"GET\"] = \"GET\";\n  HTTPMethod[\"PUT\"] = \"PUT\";\n})(HTTPMethod || (HTTPMethod = {}));\n\nvar DEFAULT_METHODS = [HTTPMethod.HEAD, HTTPMethod.GET, HTTPMethod.PUT];\n\nvar HTTPStore = /*#__PURE__*/function () {\n  function HTTPStore(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, HTTPStore);\n\n    this.url = url;\n    var _options$fetchOptions = options.fetchOptions,\n        fetchOptions = _options$fetchOptions === void 0 ? {} : _options$fetchOptions,\n        _options$supportedMet = options.supportedMethods,\n        supportedMethods = _options$supportedMet === void 0 ? DEFAULT_METHODS : _options$supportedMet;\n    this.fetchOptions = fetchOptions;\n    this.supportedMethods = new Set(supportedMethods);\n  }\n\n  _createClass(HTTPStore, [{\n    key: \"keys\",\n    value: function keys() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"getItem\",\n    value: function () {\n      var _getItem2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35(item, opts) {\n        var url, value;\n        return _regeneratorRuntime.wrap(function _callee35$(_context39) {\n          while (1) {\n            switch (_context39.prev = _context39.next) {\n              case 0:\n                url = joinUrlParts(this.url, item);\n                _context39.next = 3;\n                return fetch(url, _objectSpread({}, this.fetchOptions, {}, opts));\n\n              case 3:\n                value = _context39.sent;\n\n                if (!(value.status === 404)) {\n                  _context39.next = 8;\n                  break;\n                }\n\n                throw new KeyError(item);\n\n              case 8:\n                if (!(value.status !== 200)) {\n                  _context39.next = 10;\n                  break;\n                }\n\n                throw new HTTPError(String(value.status));\n\n              case 10:\n                if (!IS_NODE) {\n                  _context39.next = 18;\n                  break;\n                }\n\n                _context39.t0 = Buffer;\n                _context39.next = 14;\n                return value.arrayBuffer();\n\n              case 14:\n                _context39.t1 = _context39.sent;\n                return _context39.abrupt(\"return\", _context39.t0.from.call(_context39.t0, _context39.t1));\n\n              case 18:\n                return _context39.abrupt(\"return\", value.arrayBuffer());\n\n              case 19:\n              case \"end\":\n                return _context39.stop();\n            }\n          }\n        }, _callee35, this);\n      }));\n\n      function getItem(_x73, _x74) {\n        return _getItem2.apply(this, arguments);\n      }\n\n      return getItem;\n    }()\n  }, {\n    key: \"setItem\",\n    value: function () {\n      var _setItem2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee36(item, value) {\n        var url, set;\n        return _regeneratorRuntime.wrap(function _callee36$(_context40) {\n          while (1) {\n            switch (_context40.prev = _context40.next) {\n              case 0:\n                if (this.supportedMethods.has(HTTPMethod.PUT)) {\n                  _context40.next = 2;\n                  break;\n                }\n\n                throw new Error('HTTP PUT no a supported method for store.');\n\n              case 2:\n                url = joinUrlParts(this.url, item);\n\n                if (typeof value === 'string') {\n                  value = new TextEncoder().encode(value).buffer;\n                }\n\n                _context40.next = 6;\n                return fetch(url, _objectSpread({}, this.fetchOptions, {\n                  method: HTTPMethod.PUT,\n                  body: value\n                }));\n\n              case 6:\n                set = _context40.sent;\n                return _context40.abrupt(\"return\", set.status.toString()[0] === '2');\n\n              case 8:\n              case \"end\":\n                return _context40.stop();\n            }\n          }\n        }, _callee36, this);\n      }));\n\n      function setItem(_x75, _x76) {\n        return _setItem2.apply(this, arguments);\n      }\n\n      return setItem;\n    }()\n  }, {\n    key: \"deleteItem\",\n    value: function deleteItem(_item) {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"containsItem\",\n    value: function () {\n      var _containsItem2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee37(item) {\n        var url, method, value;\n        return _regeneratorRuntime.wrap(function _callee37$(_context41) {\n          while (1) {\n            switch (_context41.prev = _context41.next) {\n              case 0:\n                url = joinUrlParts(this.url, item); // Just check headers if HEAD method supported\n\n                method = this.supportedMethods.has(HTTPMethod.HEAD) ? HTTPMethod.HEAD : HTTPMethod.GET;\n                _context41.next = 4;\n                return fetch(url, _objectSpread({}, this.fetchOptions, {\n                  method: method\n                }));\n\n              case 4:\n                value = _context41.sent;\n                return _context41.abrupt(\"return\", value.status === 200);\n\n              case 6:\n              case \"end\":\n                return _context41.stop();\n            }\n          }\n        }, _callee37, this);\n      }));\n\n      function containsItem(_x77) {\n        return _containsItem2.apply(this, arguments);\n      }\n\n      return containsItem;\n    }()\n  }]);\n\n  return HTTPStore;\n}();\n/**\r\n *\r\n * @param shape Array shape.\r\n * @param chunks  Chunk shape. If `true`, will be guessed from `shape` and `dtype`. If\r\n *      `false`, will be set to `shape`, i.e., single chunk for the whole array.\r\n *      If an int, the chunk size in each dimension will be given by the value\r\n *      of `chunks`. Default is `true`.\r\n * @param dtype NumPy dtype.\r\n * @param compressor Primary compressor.\r\n * @param fillValue Default value to use for uninitialized portions of the array.\r\n * @param order Memory layout to be used within each chunk.\r\n * @param store Store or path to directory in file system or name of zip file.\r\n * @param overwrite  If True, delete all pre-existing data in `store` at `path` before creating the array.\r\n * @param path Path under which array is stored.\r\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n * @param filters Sequence of filters to use to encode chunk data prior to compression.\r\n * @param cacheMetadata If `true` (default), array configuration metadata will be cached for the\r\n *      lifetime of the object. If `false`, array metadata will be reloaded\r\n *      prior to all data access and modification operations (may incur\r\n *      overhead depending on storage and data access pattern).\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read\r\n *      operations. If `false`, user attributes are reloaded from the store prior\r\n *      to all attribute read operations.\r\n * @param readOnly `true` if array should be protected against modification, defaults to `false`.\r\n * @param dimensionSeparator if specified, defines an alternate string separator placed between the dimension chunks.\r\n */\n\n\nfunction create(_x78) {\n  return _create2.apply(this, arguments);\n}\n/**\r\n * Create an empty array.\r\n */\n\n\nfunction _create2() {\n  _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee54(_ref9) {\n    var shape, _ref9$chunks, chunks, _ref9$dtype, dtype, _ref9$compressor, compressor, _ref9$fillValue, fillValue, _ref9$order, order, store, _ref9$overwrite, overwrite, path, chunkStore, filters, _ref9$cacheMetadata, cacheMetadata, _ref9$cacheAttrs, cacheAttrs, _ref9$readOnly, readOnly, dimensionSeparator, z;\n\n    return _regeneratorRuntime.wrap(function _callee54$(_context58) {\n      while (1) {\n        switch (_context58.prev = _context58.next) {\n          case 0:\n            shape = _ref9.shape, _ref9$chunks = _ref9.chunks, chunks = _ref9$chunks === void 0 ? true : _ref9$chunks, _ref9$dtype = _ref9.dtype, dtype = _ref9$dtype === void 0 ? \"<i4\" : _ref9$dtype, _ref9$compressor = _ref9.compressor, compressor = _ref9$compressor === void 0 ? null : _ref9$compressor, _ref9$fillValue = _ref9.fillValue, fillValue = _ref9$fillValue === void 0 ? null : _ref9$fillValue, _ref9$order = _ref9.order, order = _ref9$order === void 0 ? \"C\" : _ref9$order, store = _ref9.store, _ref9$overwrite = _ref9.overwrite, overwrite = _ref9$overwrite === void 0 ? false : _ref9$overwrite, path = _ref9.path, chunkStore = _ref9.chunkStore, filters = _ref9.filters, _ref9$cacheMetadata = _ref9.cacheMetadata, cacheMetadata = _ref9$cacheMetadata === void 0 ? true : _ref9$cacheMetadata, _ref9$cacheAttrs = _ref9.cacheAttrs, cacheAttrs = _ref9$cacheAttrs === void 0 ? true : _ref9$cacheAttrs, _ref9$readOnly = _ref9.readOnly, readOnly = _ref9$readOnly === void 0 ? false : _ref9$readOnly, dimensionSeparator = _ref9.dimensionSeparator;\n            store = normalizeStoreArgument(store);\n            _context58.next = 4;\n            return initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n\n          case 4:\n            _context58.next = 6;\n            return ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n\n          case 6:\n            z = _context58.sent;\n            return _context58.abrupt(\"return\", z);\n\n          case 8:\n          case \"end\":\n            return _context58.stop();\n        }\n      }\n    }, _callee54);\n  }));\n  return _create2.apply(this, arguments);\n}\n\nfunction _empty2(_x79) {\n  return _empty.apply(this, arguments);\n}\n/**\r\n * Create an array, with zero being used as the default value for\r\n * uninitialized portions of the array.\r\n */\n\n\nfunction _empty() {\n  _empty = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee55(shape) {\n    var opts,\n        _args59 = arguments;\n    return _regeneratorRuntime.wrap(function _callee55$(_context59) {\n      while (1) {\n        switch (_context59.prev = _context59.next) {\n          case 0:\n            opts = _args59.length > 1 && _args59[1] !== undefined ? _args59[1] : {};\n            opts.fillValue = null;\n            return _context59.abrupt(\"return\", create(_objectSpread({\n              shape: shape\n            }, opts)));\n\n          case 3:\n          case \"end\":\n            return _context59.stop();\n        }\n      }\n    }, _callee55);\n  }));\n  return _empty.apply(this, arguments);\n}\n\nfunction _zeros2(_x80) {\n  return _zeros.apply(this, arguments);\n}\n/**\r\n * Create an array, with one being used as the default value for\r\n * uninitialized portions of the array.\r\n */\n\n\nfunction _zeros() {\n  _zeros = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee56(shape) {\n    var opts,\n        _args60 = arguments;\n    return _regeneratorRuntime.wrap(function _callee56$(_context60) {\n      while (1) {\n        switch (_context60.prev = _context60.next) {\n          case 0:\n            opts = _args60.length > 1 && _args60[1] !== undefined ? _args60[1] : {};\n            opts.fillValue = 0;\n            return _context60.abrupt(\"return\", create(_objectSpread({\n              shape: shape\n            }, opts)));\n\n          case 3:\n          case \"end\":\n            return _context60.stop();\n        }\n      }\n    }, _callee56);\n  }));\n  return _zeros.apply(this, arguments);\n}\n\nfunction _ones2(_x81) {\n  return _ones.apply(this, arguments);\n}\n/**\r\n * Create an array, with `fill_value` being used as the default value for\r\n * uninitialized portions of the array\r\n */\n\n\nfunction _ones() {\n  _ones = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee57(shape) {\n    var opts,\n        _args61 = arguments;\n    return _regeneratorRuntime.wrap(function _callee57$(_context61) {\n      while (1) {\n        switch (_context61.prev = _context61.next) {\n          case 0:\n            opts = _args61.length > 1 && _args61[1] !== undefined ? _args61[1] : {};\n            opts.fillValue = 1;\n            return _context61.abrupt(\"return\", create(_objectSpread({\n              shape: shape\n            }, opts)));\n\n          case 3:\n          case \"end\":\n            return _context61.stop();\n        }\n      }\n    }, _callee57);\n  }));\n  return _ones.apply(this, arguments);\n}\n\nfunction _full2(_x82, _x83) {\n  return _full.apply(this, arguments);\n}\n\nfunction _full() {\n  _full = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee58(shape, fillValue) {\n    var opts,\n        _args62 = arguments;\n    return _regeneratorRuntime.wrap(function _callee58$(_context62) {\n      while (1) {\n        switch (_context62.prev = _context62.next) {\n          case 0:\n            opts = _args62.length > 2 && _args62[2] !== undefined ? _args62[2] : {};\n            opts.fillValue = fillValue;\n            return _context62.abrupt(\"return\", create(_objectSpread({\n              shape: shape\n            }, opts)));\n\n          case 3:\n          case \"end\":\n            return _context62.stop();\n        }\n      }\n    }, _callee58);\n  }));\n  return _full.apply(this, arguments);\n}\n\nfunction _array2(_x84) {\n  return _array.apply(this, arguments);\n}\n\nfunction _array() {\n  _array = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee59(data) {\n    var opts,\n        shape,\n        wasReadOnly,\n        z,\n        _args63 = arguments;\n    return _regeneratorRuntime.wrap(function _callee59$(_context63) {\n      while (1) {\n        switch (_context63.prev = _context63.next) {\n          case 0:\n            opts = _args63.length > 1 && _args63[1] !== undefined ? _args63[1] : {};\n            // TODO: infer chunks?\n            shape = null;\n\n            if (data instanceof NestedArray) {\n              shape = data.shape;\n              opts.dtype = opts.dtype === undefined ? data.dtype : opts.dtype;\n            } else {\n              shape = data.byteLength; // TODO: infer datatype\n            } // TODO: support TypedArray\n\n\n            wasReadOnly = opts.readOnly === undefined ? false : opts.readOnly;\n            opts.readOnly = false;\n            _context63.next = 7;\n            return create(_objectSpread({\n              shape: shape\n            }, opts));\n\n          case 7:\n            z = _context63.sent;\n            _context63.next = 10;\n            return z.set(null, data);\n\n          case 10:\n            z.readOnly = wasReadOnly;\n            return _context63.abrupt(\"return\", z);\n\n          case 12:\n          case \"end\":\n            return _context63.stop();\n        }\n      }\n    }, _callee59);\n  }));\n  return _array.apply(this, arguments);\n}\n\nfunction openArray() {\n  return _openArray.apply(this, arguments);\n}\n\nfunction _openArray() {\n  _openArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee60() {\n    var _ref10,\n        shape,\n        _ref10$mode,\n        mode,\n        _ref10$chunks,\n        chunks,\n        _ref10$dtype,\n        dtype,\n        _ref10$compressor,\n        compressor,\n        _ref10$fillValue,\n        fillValue,\n        _ref10$order,\n        order,\n        store,\n        _ref10$overwrite,\n        overwrite,\n        _ref10$path,\n        path,\n        chunkStore,\n        filters,\n        _ref10$cacheMetadata,\n        cacheMetadata,\n        _ref10$cacheAttrs,\n        cacheAttrs,\n        dimensionSeparator,\n        readOnly,\n        _args64 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee60$(_context64) {\n      while (1) {\n        switch (_context64.prev = _context64.next) {\n          case 0:\n            _ref10 = _args64.length > 0 && _args64[0] !== undefined ? _args64[0] : {}, shape = _ref10.shape, _ref10$mode = _ref10.mode, mode = _ref10$mode === void 0 ? \"a\" : _ref10$mode, _ref10$chunks = _ref10.chunks, chunks = _ref10$chunks === void 0 ? true : _ref10$chunks, _ref10$dtype = _ref10.dtype, dtype = _ref10$dtype === void 0 ? \"<i4\" : _ref10$dtype, _ref10$compressor = _ref10.compressor, compressor = _ref10$compressor === void 0 ? null : _ref10$compressor, _ref10$fillValue = _ref10.fillValue, fillValue = _ref10$fillValue === void 0 ? null : _ref10$fillValue, _ref10$order = _ref10.order, order = _ref10$order === void 0 ? \"C\" : _ref10$order, store = _ref10.store, _ref10$overwrite = _ref10.overwrite, overwrite = _ref10$overwrite === void 0 ? false : _ref10$overwrite, _ref10$path = _ref10.path, path = _ref10$path === void 0 ? null : _ref10$path, chunkStore = _ref10.chunkStore, filters = _ref10.filters, _ref10$cacheMetadata = _ref10.cacheMetadata, cacheMetadata = _ref10$cacheMetadata === void 0 ? true : _ref10$cacheMetadata, _ref10$cacheAttrs = _ref10.cacheAttrs, cacheAttrs = _ref10$cacheAttrs === void 0 ? true : _ref10$cacheAttrs, dimensionSeparator = _ref10.dimensionSeparator;\n            store = normalizeStoreArgument(store);\n\n            if (chunkStore === undefined) {\n              chunkStore = normalizeStoreArgument(store);\n            }\n\n            path = normalizeStoragePath(path);\n\n            if (!(mode === \"r\" || mode === \"r+\")) {\n              _context64.next = 15;\n              break;\n            }\n\n            _context64.next = 7;\n            return containsArray(store, path);\n\n          case 7:\n            if (_context64.sent) {\n              _context64.next = 13;\n              break;\n            }\n\n            _context64.next = 10;\n            return containsGroup(store, path);\n\n          case 10:\n            if (!_context64.sent) {\n              _context64.next = 12;\n              break;\n            }\n\n            throw new ContainsGroupError(path);\n\n          case 12:\n            throw new ArrayNotFoundError(path);\n\n          case 13:\n            _context64.next = 56;\n            break;\n\n          case 15:\n            if (!(mode === \"w\")) {\n              _context64.next = 22;\n              break;\n            }\n\n            if (!(shape === undefined)) {\n              _context64.next = 18;\n              break;\n            }\n\n            throw new ValueError(\"Shape can not be undefined when creating a new array\");\n\n          case 18:\n            _context64.next = 20;\n            return initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n\n          case 20:\n            _context64.next = 56;\n            break;\n\n          case 22:\n            if (!(mode === \"a\")) {\n              _context64.next = 36;\n              break;\n            }\n\n            _context64.next = 25;\n            return containsArray(store, path);\n\n          case 25:\n            if (_context64.sent) {\n              _context64.next = 34;\n              break;\n            }\n\n            _context64.next = 28;\n            return containsGroup(store, path);\n\n          case 28:\n            if (!_context64.sent) {\n              _context64.next = 30;\n              break;\n            }\n\n            throw new ContainsGroupError(path);\n\n          case 30:\n            if (!(shape === undefined)) {\n              _context64.next = 32;\n              break;\n            }\n\n            throw new ValueError(\"Shape can not be undefined when creating a new array\");\n\n          case 32:\n            _context64.next = 34;\n            return initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n\n          case 34:\n            _context64.next = 56;\n            break;\n\n          case 36:\n            if (!(mode === \"w-\" || mode === \"x\")) {\n              _context64.next = 55;\n              break;\n            }\n\n            _context64.next = 39;\n            return containsArray(store, path);\n\n          case 39:\n            if (!_context64.sent) {\n              _context64.next = 43;\n              break;\n            }\n\n            throw new ContainsArrayError(path);\n\n          case 43:\n            _context64.next = 45;\n            return containsGroup(store, path);\n\n          case 45:\n            if (!_context64.sent) {\n              _context64.next = 49;\n              break;\n            }\n\n            throw new ContainsGroupError(path);\n\n          case 49:\n            if (!(shape === undefined)) {\n              _context64.next = 51;\n              break;\n            }\n\n            throw new ValueError(\"Shape can not be undefined when creating a new array\");\n\n          case 51:\n            _context64.next = 53;\n            return initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n\n          case 53:\n            _context64.next = 56;\n            break;\n\n          case 55:\n            throw new ValueError(\"Invalid mode argument: \".concat(mode));\n\n          case 56:\n            readOnly = mode === \"r\";\n            return _context64.abrupt(\"return\", ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs));\n\n          case 58:\n          case \"end\":\n            return _context64.stop();\n        }\n      }\n    }, _callee60);\n  }));\n  return _openArray.apply(this, arguments);\n}\n\nfunction normalizeStoreArgument(store) {\n  if (store === undefined) {\n    return new MemoryStore();\n  } else if (typeof store === \"string\") {\n    return new HTTPStore(store);\n  }\n\n  return store;\n}\n\nvar Group = /*#__PURE__*/function () {\n  function Group(store) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var metadata = arguments.length > 2 ? arguments[2] : undefined;\n    var readOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var chunkStore = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var cacheAttrs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    _classCallCheck(this, Group);\n\n    this.store = store;\n    this._chunkStore = chunkStore;\n    this.path = normalizeStoragePath(path);\n    this.keyPrefix = pathToPrefix(this.path);\n    this.readOnly = readOnly;\n    this.meta = metadata; // Initialize attributes\n\n    var attrKey = this.keyPrefix + ATTRS_META_KEY;\n    this.attrs = new Attributes(this.store, attrKey, this.readOnly, cacheAttrs);\n  }\n  /**\r\n   * Group name following h5py convention.\r\n   */\n\n\n  _createClass(Group, [{\n    key: \"itemPath\",\n    value: function itemPath(item) {\n      var absolute = typeof item === \"string\" && item.length > 0 && item[0] === '/';\n      var path = normalizeStoragePath(item); // Absolute path\n\n      if (!absolute && this.path.length > 0) {\n        return this.keyPrefix + path;\n      }\n\n      return path;\n    }\n    /**\r\n     * Create a sub-group.\r\n     */\n\n  }, {\n    key: \"createGroup\",\n    value: function () {\n      var _createGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee38(name) {\n        var overwrite,\n            path,\n            _args42 = arguments;\n        return _regeneratorRuntime.wrap(function _callee38$(_context42) {\n          while (1) {\n            switch (_context42.prev = _context42.next) {\n              case 0:\n                overwrite = _args42.length > 1 && _args42[1] !== undefined ? _args42[1] : false;\n\n                if (!this.readOnly) {\n                  _context42.next = 3;\n                  break;\n                }\n\n                throw new PermissionError(\"group is read only\");\n\n              case 3:\n                path = this.itemPath(name);\n                _context42.next = 6;\n                return initGroup(this.store, path, this._chunkStore, overwrite);\n\n              case 6:\n                return _context42.abrupt(\"return\", Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache));\n\n              case 7:\n              case \"end\":\n                return _context42.stop();\n            }\n          }\n        }, _callee38, this);\n      }));\n\n      function createGroup(_x85) {\n        return _createGroup.apply(this, arguments);\n      }\n\n      return createGroup;\n    }()\n    /**\r\n     * Obtain a sub-group, creating one if it doesn't exist.\r\n     */\n\n  }, {\n    key: \"requireGroup\",\n    value: function () {\n      var _requireGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee39(name) {\n        var overwrite,\n            path,\n            _args43 = arguments;\n        return _regeneratorRuntime.wrap(function _callee39$(_context43) {\n          while (1) {\n            switch (_context43.prev = _context43.next) {\n              case 0:\n                overwrite = _args43.length > 1 && _args43[1] !== undefined ? _args43[1] : false;\n\n                if (!this.readOnly) {\n                  _context43.next = 3;\n                  break;\n                }\n\n                throw new PermissionError(\"group is read only\");\n\n              case 3:\n                path = this.itemPath(name);\n                _context43.next = 6;\n                return containsGroup(this.store, path);\n\n              case 6:\n                if (_context43.sent) {\n                  _context43.next = 9;\n                  break;\n                }\n\n                _context43.next = 9;\n                return initGroup(this.store, path, this._chunkStore, overwrite);\n\n              case 9:\n                return _context43.abrupt(\"return\", Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache));\n\n              case 10:\n              case \"end\":\n                return _context43.stop();\n            }\n          }\n        }, _callee39, this);\n      }));\n\n      function requireGroup(_x86) {\n        return _requireGroup.apply(this, arguments);\n      }\n\n      return requireGroup;\n    }()\n  }, {\n    key: \"getOptsForArrayCreation\",\n    value: function getOptsForArrayCreation(name) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var path = this.itemPath(name);\n      opts.path = path;\n\n      if (opts.cacheAttrs === undefined) {\n        opts.cacheAttrs = this.attrs.cache;\n      }\n\n      opts.store = this.store;\n      opts.chunkStore = this.chunkStore;\n      return opts;\n    }\n    /**\r\n     * Creates an array\r\n     */\n\n  }, {\n    key: \"array\",\n    value: function array(name, data, opts, overwrite) {\n      if (this.readOnly) {\n        throw new PermissionError(\"group is read only\");\n      }\n\n      opts = this.getOptsForArrayCreation(name, opts);\n      opts.overwrite = overwrite === undefined ? opts.overwrite : overwrite;\n      return _array2(data, opts);\n    }\n  }, {\n    key: \"empty\",\n    value: function empty(name, shape) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this.readOnly) {\n        throw new PermissionError(\"group is read only\");\n      }\n\n      opts = this.getOptsForArrayCreation(name, opts);\n      return _empty2(shape, opts);\n    }\n  }, {\n    key: \"zeros\",\n    value: function zeros(name, shape) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this.readOnly) {\n        throw new PermissionError(\"group is read only\");\n      }\n\n      opts = this.getOptsForArrayCreation(name, opts);\n      return _zeros2(shape, opts);\n    }\n  }, {\n    key: \"ones\",\n    value: function ones(name, shape) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this.readOnly) {\n        throw new PermissionError(\"group is read only\");\n      }\n\n      opts = this.getOptsForArrayCreation(name, opts);\n      return _ones2(shape, opts);\n    }\n  }, {\n    key: \"full\",\n    value: function full(name, shape, fillValue) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (this.readOnly) {\n        throw new PermissionError(\"group is read only\");\n      }\n\n      opts = this.getOptsForArrayCreation(name, opts);\n      return _full2(shape, fillValue, opts);\n    }\n  }, {\n    key: \"createDataset\",\n    value: function createDataset(name, shape, data, opts) {\n      if (this.readOnly) {\n        throw new PermissionError(\"group is read only\");\n      }\n\n      opts = this.getOptsForArrayCreation(name, opts);\n      var z;\n\n      if (data === undefined) {\n        if (shape === undefined) {\n          throw new ValueError(\"Shape must be set if no data is passed to CreateDataset\");\n        }\n\n        z = create(_objectSpread({\n          shape: shape\n        }, opts));\n      } else {\n        z = _array2(data, opts);\n      }\n\n      return z;\n    }\n  }, {\n    key: \"getItem\",\n    value: function () {\n      var _getItem3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee40(item) {\n        var path;\n        return _regeneratorRuntime.wrap(function _callee40$(_context44) {\n          while (1) {\n            switch (_context44.prev = _context44.next) {\n              case 0:\n                path = this.itemPath(item);\n                _context44.next = 3;\n                return containsArray(this.store, path);\n\n              case 3:\n                if (!_context44.sent) {\n                  _context44.next = 7;\n                  break;\n                }\n\n                return _context44.abrupt(\"return\", ZarrArray.create(this.store, path, this.readOnly, this.chunkStore, undefined, this.attrs.cache));\n\n              case 7:\n                _context44.next = 9;\n                return containsGroup(this.store, path);\n\n              case 9:\n                if (!_context44.sent) {\n                  _context44.next = 11;\n                  break;\n                }\n\n                return _context44.abrupt(\"return\", Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache));\n\n              case 11:\n                throw new KeyError(item);\n\n              case 12:\n              case \"end\":\n                return _context44.stop();\n            }\n          }\n        }, _callee40, this);\n      }));\n\n      function getItem(_x87) {\n        return _getItem3.apply(this, arguments);\n      }\n\n      return getItem;\n    }()\n  }, {\n    key: \"setItem\",\n    value: function () {\n      var _setItem3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee41(item, value) {\n        return _regeneratorRuntime.wrap(function _callee41$(_context45) {\n          while (1) {\n            switch (_context45.prev = _context45.next) {\n              case 0:\n                _context45.next = 2;\n                return this.array(item, value, {}, true);\n\n              case 2:\n                return _context45.abrupt(\"return\", true);\n\n              case 3:\n              case \"end\":\n                return _context45.stop();\n            }\n          }\n        }, _callee41, this);\n      }));\n\n      function setItem(_x88, _x89) {\n        return _setItem3.apply(this, arguments);\n      }\n\n      return setItem;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"deleteItem\",\n    value: function () {\n      var _deleteItem2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee42(_item) {\n        return _regeneratorRuntime.wrap(function _callee42$(_context46) {\n          while (1) {\n            switch (_context46.prev = _context46.next) {\n              case 0:\n                if (!this.readOnly) {\n                  _context46.next = 2;\n                  break;\n                }\n\n                throw new PermissionError(\"group is read only\");\n\n              case 2:\n                throw new Error(\"Method not implemented.\");\n\n              case 3:\n              case \"end\":\n                return _context46.stop();\n            }\n          }\n        }, _callee42, this);\n      }));\n\n      function deleteItem(_x90) {\n        return _deleteItem2.apply(this, arguments);\n      }\n\n      return deleteItem;\n    }()\n  }, {\n    key: \"containsItem\",\n    value: function () {\n      var _containsItem3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee43(item) {\n        var path;\n        return _regeneratorRuntime.wrap(function _callee43$(_context47) {\n          while (1) {\n            switch (_context47.prev = _context47.next) {\n              case 0:\n                path = this.itemPath(item);\n                _context47.next = 3;\n                return containsArray(this.store, path);\n\n              case 3:\n                _context47.t0 = _context47.sent;\n\n                if (_context47.t0) {\n                  _context47.next = 6;\n                  break;\n                }\n\n                _context47.t0 = containsGroup(this.store, path);\n\n              case 6:\n                return _context47.abrupt(\"return\", _context47.t0);\n\n              case 7:\n              case \"end\":\n                return _context47.stop();\n            }\n          }\n        }, _callee43, this);\n      }));\n\n      function containsItem(_x91) {\n        return _containsItem3.apply(this, arguments);\n      }\n\n      return containsItem;\n    }()\n  }, {\n    key: \"proxy\",\n    value: function proxy() {\n      return createProxy(this);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      if (this.path.length > 0) {\n        if (this.path[0] !== \"/\") {\n          return \"/\" + this.path;\n        }\n\n        return this.path;\n      }\n\n      return \"/\";\n    }\n    /**\r\n     * Final component of name.\r\n     */\n\n  }, {\n    key: \"basename\",\n    get: function get() {\n      var parts = this.name.split(\"/\");\n      return parts[parts.length - 1];\n    }\n    /**\r\n     * A `Store` providing the underlying storage for array chunks.\r\n     */\n\n  }, {\n    key: \"chunkStore\",\n    get: function get() {\n      if (this._chunkStore) {\n        return this._chunkStore;\n      }\n\n      return this.store;\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee44(store) {\n        var path,\n            readOnly,\n            chunkStore,\n            cacheAttrs,\n            metadata,\n            _args48 = arguments;\n        return _regeneratorRuntime.wrap(function _callee44$(_context48) {\n          while (1) {\n            switch (_context48.prev = _context48.next) {\n              case 0:\n                path = _args48.length > 1 && _args48[1] !== undefined ? _args48[1] : null;\n                readOnly = _args48.length > 2 && _args48[2] !== undefined ? _args48[2] : false;\n                chunkStore = _args48.length > 3 && _args48[3] !== undefined ? _args48[3] : null;\n                cacheAttrs = _args48.length > 4 && _args48[4] !== undefined ? _args48[4] : true;\n                _context48.next = 6;\n                return this.loadMetadataForConstructor(store, path);\n\n              case 6:\n                metadata = _context48.sent;\n                return _context48.abrupt(\"return\", new Group(store, path, metadata, readOnly, chunkStore, cacheAttrs));\n\n              case 8:\n              case \"end\":\n                return _context48.stop();\n            }\n          }\n        }, _callee44, this);\n      }));\n\n      function create(_x92) {\n        return _create3.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"loadMetadataForConstructor\",\n    value: function () {\n      var _loadMetadataForConstructor2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee45(store, path) {\n        var keyPrefix, metaStoreValue;\n        return _regeneratorRuntime.wrap(function _callee45$(_context49) {\n          while (1) {\n            switch (_context49.prev = _context49.next) {\n              case 0:\n                path = normalizeStoragePath(path);\n                keyPrefix = pathToPrefix(path);\n                _context49.prev = 2;\n                _context49.next = 5;\n                return store.getItem(keyPrefix + GROUP_META_KEY);\n\n              case 5:\n                metaStoreValue = _context49.sent;\n                return _context49.abrupt(\"return\", parseMetadata(metaStoreValue));\n\n              case 9:\n                _context49.prev = 9;\n                _context49.t0 = _context49[\"catch\"](2);\n                _context49.next = 13;\n                return containsArray(store, path);\n\n              case 13:\n                if (!_context49.sent) {\n                  _context49.next = 15;\n                  break;\n                }\n\n                throw new ContainsArrayError(path);\n\n              case 15:\n                throw new GroupNotFoundError(path);\n\n              case 16:\n              case \"end\":\n                return _context49.stop();\n            }\n          }\n        }, _callee45, null, [[2, 9]]);\n      }));\n\n      function loadMetadataForConstructor(_x93, _x94) {\n        return _loadMetadataForConstructor2.apply(this, arguments);\n      }\n\n      return loadMetadataForConstructor;\n    }()\n  }]);\n\n  return Group;\n}();\n/**\r\n * Create a group.\r\n * @param store Store or path to directory in file system.\r\n * @param path Group path within store.\r\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n * @param overwrite If `true`, delete any pre-existing data in `store` at `path` before creating the group.\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations.\r\n *   If `false`, user attributes are reloaded from the store prior to all attribute read operations.\r\n */\n\n\nfunction group(_x95) {\n  return _group.apply(this, arguments);\n}\n/**\r\n * Open a group using file-mode-like semantics.\r\n * @param store Store or path to directory in file system or name of zip file.\r\n * @param path Group path within store.\r\n * @param mode Persistence mode, see `PersistenceMode` type.\r\n * @param chunkStore Store or path to directory in file system or name of zip file.\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations\r\n *   If False, user attributes are reloaded from the store prior to all attribute read operations.\r\n *\r\n */\n\n\nfunction _group() {\n  _group = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee61(store) {\n    var path,\n        chunkStore,\n        overwrite,\n        cacheAttrs,\n        _args65 = arguments;\n    return _regeneratorRuntime.wrap(function _callee61$(_context65) {\n      while (1) {\n        switch (_context65.prev = _context65.next) {\n          case 0:\n            path = _args65.length > 1 && _args65[1] !== undefined ? _args65[1] : null;\n            chunkStore = _args65.length > 2 ? _args65[2] : undefined;\n            overwrite = _args65.length > 3 && _args65[3] !== undefined ? _args65[3] : false;\n            cacheAttrs = _args65.length > 4 && _args65[4] !== undefined ? _args65[4] : true;\n            store = normalizeStoreArgument(store);\n            path = normalizeStoragePath(path);\n            _context65.t0 = overwrite;\n\n            if (_context65.t0) {\n              _context65.next = 11;\n              break;\n            }\n\n            _context65.next = 10;\n            return containsGroup(store);\n\n          case 10:\n            _context65.t0 = _context65.sent;\n\n          case 11:\n            if (!_context65.t0) {\n              _context65.next = 14;\n              break;\n            }\n\n            _context65.next = 14;\n            return initGroup(store, path, chunkStore, overwrite);\n\n          case 14:\n            return _context65.abrupt(\"return\", Group.create(store, path, false, chunkStore, cacheAttrs));\n\n          case 15:\n          case \"end\":\n            return _context65.stop();\n        }\n      }\n    }, _callee61);\n  }));\n  return _group.apply(this, arguments);\n}\n\nfunction openGroup(_x96) {\n  return _openGroup.apply(this, arguments);\n}\n\nfunction _openGroup() {\n  _openGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee62(store) {\n    var path,\n        mode,\n        chunkStore,\n        cacheAttrs,\n        readOnly,\n        _args66 = arguments;\n    return _regeneratorRuntime.wrap(function _callee62$(_context66) {\n      while (1) {\n        switch (_context66.prev = _context66.next) {\n          case 0:\n            path = _args66.length > 1 && _args66[1] !== undefined ? _args66[1] : null;\n            mode = _args66.length > 2 && _args66[2] !== undefined ? _args66[2] : \"a\";\n            chunkStore = _args66.length > 3 ? _args66[3] : undefined;\n            cacheAttrs = _args66.length > 4 && _args66[4] !== undefined ? _args66[4] : true;\n            store = normalizeStoreArgument(store);\n\n            if (chunkStore !== undefined) {\n              chunkStore = normalizeStoreArgument(store);\n            }\n\n            path = normalizeStoragePath(path);\n\n            if (!(mode === \"r\" || mode === \"r+\")) {\n              _context66.next = 18;\n              break;\n            }\n\n            _context66.next = 10;\n            return containsGroup(store, path);\n\n          case 10:\n            if (_context66.sent) {\n              _context66.next = 16;\n              break;\n            }\n\n            _context66.next = 13;\n            return containsArray(store, path);\n\n          case 13:\n            if (!_context66.sent) {\n              _context66.next = 15;\n              break;\n            }\n\n            throw new ContainsArrayError(path);\n\n          case 15:\n            throw new GroupNotFoundError(path);\n\n          case 16:\n            _context66.next = 53;\n            break;\n\n          case 18:\n            if (!(mode === \"w\")) {\n              _context66.next = 23;\n              break;\n            }\n\n            _context66.next = 21;\n            return initGroup(store, path, chunkStore, true);\n\n          case 21:\n            _context66.next = 53;\n            break;\n\n          case 23:\n            if (!(mode === \"a\")) {\n              _context66.next = 35;\n              break;\n            }\n\n            _context66.next = 26;\n            return containsGroup(store, path);\n\n          case 26:\n            if (_context66.sent) {\n              _context66.next = 33;\n              break;\n            }\n\n            _context66.next = 29;\n            return containsArray(store, path);\n\n          case 29:\n            if (!_context66.sent) {\n              _context66.next = 31;\n              break;\n            }\n\n            throw new ContainsArrayError(path);\n\n          case 31:\n            _context66.next = 33;\n            return initGroup(store, path, chunkStore);\n\n          case 33:\n            _context66.next = 53;\n            break;\n\n          case 35:\n            if (!(mode === \"w-\" || mode === \"x\")) {\n              _context66.next = 52;\n              break;\n            }\n\n            _context66.next = 38;\n            return containsArray(store, path);\n\n          case 38:\n            if (!_context66.sent) {\n              _context66.next = 42;\n              break;\n            }\n\n            throw new ContainsArrayError(path);\n\n          case 42:\n            _context66.next = 44;\n            return containsGroup(store, path);\n\n          case 44:\n            if (!_context66.sent) {\n              _context66.next = 48;\n              break;\n            }\n\n            throw new ContainsGroupError(path);\n\n          case 48:\n            _context66.next = 50;\n            return initGroup(store, path, chunkStore);\n\n          case 50:\n            _context66.next = 53;\n            break;\n\n          case 52:\n            throw new ValueError(\"Invalid mode argument: \".concat(mode));\n\n          case 53:\n            readOnly = mode === \"r\";\n            return _context66.abrupt(\"return\", Group.create(store, path, readOnly, chunkStore, cacheAttrs));\n\n          case 55:\n          case \"end\":\n            return _context66.stop();\n        }\n      }\n    }, _callee62);\n  }));\n  return _openGroup.apply(this, arguments);\n}\n\nvar ObjectStore = /*#__PURE__*/function () {\n  function ObjectStore() {\n    _classCallCheck(this, ObjectStore);\n\n    this.object = {};\n  }\n\n  _createClass(ObjectStore, [{\n    key: \"getItem\",\n    value: function getItem(item) {\n      if (!Object.prototype.hasOwnProperty.call(this.object, item)) {\n        throw new KeyError(item);\n      }\n\n      return this.object[item];\n    }\n  }, {\n    key: \"setItem\",\n    value: function setItem(item, value) {\n      this.object[item] = value;\n      return true;\n    }\n  }, {\n    key: \"deleteItem\",\n    value: function deleteItem(item) {\n      return delete this.object[item];\n    }\n  }, {\n    key: \"containsItem\",\n    value: function containsItem(item) {\n      return Object.prototype.hasOwnProperty.call(this.object, item);\n    }\n  }, {\n    key: \"proxy\",\n    value: function proxy() {\n      return createProxy(this);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return Object.getOwnPropertyNames(this.object);\n    }\n  }]);\n\n  return ObjectStore;\n}();\n\nexport { ArrayNotFoundError, BoundsCheckError, ContainsArrayError, ContainsGroupError, Group, GroupNotFoundError, HTTPError, HTTPStore, InvalidSliceError, KeyError, MemoryStore, NegativeStepError, NestedArray, ObjectStore, PathNotFoundError, PermissionError, TooManyIndicesError, ValueError, ZarrArray, addCodec, _array2 as array, create, createProxy, _empty2 as empty, _full2 as full, getCodec, getTypedArrayCtr, getTypedArrayDtypeString, group, isKeyError, normalizeStoreArgument, _ones2 as ones, openArray, openGroup, rangeTypedArray, slice, sliceIndices, _zeros2 as zeros };","map":{"version":3,"sources":["../src/compression/registry.ts","../src/mutableMapping.ts","../src/errors.ts","../src/core/slice.ts","../src/core/indexing.ts","../src/util.ts","../src/names.ts","../src/storage/index.ts","../src/metadata.ts","../src/attributes.ts","../src/nestedArray/types.ts","../src/nestedArray/ops.ts","../src/nestedArray/index.ts","../src/rawArray/ops.ts","../src/rawArray/index.ts","../node_modules/eventemitter3/index.js","../node_modules/p-finally/index.js","../node_modules/p-timeout/index.js","../node_modules/p-queue/dist/lower-bound.js","../node_modules/p-queue/dist/priority-queue.js","../node_modules/p-queue/dist/index.js","../src/core/index.ts","../src/storage/memoryStore.ts","../src/storage/httpStore.ts","../src/creation.ts","../src/hierarchy.ts","../src/storage/objectStore.ts"],"names":["lower_bound_1","empty","p_timeout_1","EventEmitter","priority_queue_1","PQueue"],"mappings":";;;;;;;;;;;;;;oDIoLU,O;;AJ/KV,IAAM,QAAQ,GAA+B,IAAI,GAAJ,EAA7C;;SAEgB,Q,CAAS,E,EAAY,Q,EAAuB;AAC1D,EAAA,QAAQ,CAAC,GAAT,CAAa,EAAb,EAAiB,QAAjB;AACD;;SAEqB,Q;;;;;uEAAf,mBAAwB,MAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBACA,QAAQ,CAAC,GAAT,CAAa,MAAM,CAAC,EAApB,CADA;AAAA;AAAA;AAAA;;AAAA,kBAEG,IAAI,KAAJ,6BAA+B,MAAM,CAAC,EAAtC,uCAFH;;AAAA;AAAA;AAAA,mBAIe,QAAQ,CAAC,GAAT,CAAa,MAAM,CAAC,EAApB,GAJf;;AAAA;AAIC,YAAA,KAJD;AAAA,+CAKE,KAAK,CAAC,UAAN,CAAiB,MAAjB,CALF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SC6BS,W,CAAkB,O,EAA+D;AAC7F,SAAO,IAAI,KAAJ,CAAU,OAAV,EAA0B;AAC7B,IAAA,GAD6B,eACzB,MADyB,EACjB,GADiB,EACZ,KADY,EACL,SADK,EACI;AAC7B,aAAO,MAAM,CAAC,OAAP,CAAe,GAAf,EAA8B,KAA9B,CAAP;AACH,KAH4B;AAI7B,IAAA,GAJ6B,eAIzB,MAJyB,EAIjB,GAJiB,EAIZ,SAJY,EAIH;AACtB,aAAO,MAAM,CAAC,OAAP,CAAe,GAAf,CAAP;AACH,KAN4B;AAO7B,IAAA,cAP6B,0BAOd,MAPc,EAON,GAPM,EAOH;AACtB,aAAO,MAAM,CAAC,UAAP,CAAkB,GAAlB,CAAP;AACH,KAT4B;AAU7B,IAAA,GAV6B,eAUzB,MAVyB,EAUjB,GAViB,EAUd;AACX,aAAO,MAAM,CAAC,YAAP,CAAoB,GAApB,CAAP;AACH;AAZ4B,GAA1B,CAAP;AAcJ;;ACnDA,SAAS,WAAT,CAAqB,GAArB,EAAiC;AAC7B,SAAO,OAAO,GAAP,KAAe,QAAf,IAA2B,GAAG,KAAK,IAAnC,IAA2C,cAAc,GAAhE;AACH;;SAEe,U,CAAW,C,EAAU;AACjC,SAAO,WAAW,CAAC,CAAD,CAAX,IAAkB,CAAC,CAAC,QAAF,KAAe,UAAxC;AACH,C,CAED;AACA;AACA;;;IACa,kB;;;;;AAET,8BAAY,IAAZ,EAAwB;AAAA;;AAAA;;AACpB,6CAAc,IAAd;AAFJ,UAAA,QAAA,GAAW,oBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,gCAA4B,kBAAkB,CAAC,SAA/C;AAFoB;AAGvB;;;iCALmC,K;;IAQ3B,kB;;;;;AAET,8BAAY,IAAZ,EAAwB;AAAA;;AAAA;;AACpB,+CAAc,IAAd;AAFJ,WAAA,QAAA,GAAW,oBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,kBAAkB,CAAC,SAA/C;AAFoB;AAGvB;;;iCALmC,K;;IAQ3B,kB;;;;;AAET,8BAAY,IAAZ,EAAwB;AAAA;;AAAA;;AACpB,kEAAiC,IAAjC;AAFJ,WAAA,QAAA,GAAW,oBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,kBAAkB,CAAC,SAA/C;AAFoB;AAGvB;;;iCALmC,K;;IAQ3B,kB;;;;;AAET,8BAAY,IAAZ,EAAwB;AAAA;;AAAA;;AACpB,mEAAkC,IAAlC;AAFJ,WAAA,QAAA,GAAW,oBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,kBAAkB,CAAC,SAA/C;AAFoB;AAGvB;;;iCALmC,K;;IAQ3B,iB;;;;;AAET,6BAAY,IAAZ,EAAwB;AAAA;;AAAA;;AACpB,oEAAmC,IAAnC;AAFJ,WAAA,QAAA,GAAW,mBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,iBAAiB,CAAC,SAA9C;AAFoB;AAGvB;;;iCALkC,K;;IAQ1B,e;;;;;AAET,2BAAY,OAAZ,EAA2B;AAAA;;AAAA;;AACvB,gCAAM,OAAN;AAFJ,WAAA,QAAA,GAAW,iBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,eAAe,CAAC,SAA5C;AAFuB;AAG1B;;;iCALgC,K;;IAQxB,Q;;;;;AAET,oBAAY,GAAZ,EAAuB;AAAA;;AAAA;;AACnB,8CAAa,GAAb;AAFJ,WAAA,QAAA,GAAW,UAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,QAAQ,CAAC,SAArC;AAFmB;AAGtB;;;iCALyB,K;;IAQjB,mB;;;;;AAET,+BAAY,SAAZ,EAA8B,KAA9B,EAA6C;AAAA;;AAAA;;AACzC,+EAA8C,KAAK,CAAC,MAApD,mBAAmE,SAAS,CAAC,MAA7E;AAFJ,WAAA,QAAA,GAAW,qBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,mBAAmB,CAAC,SAAhD;AAFyC;AAG5C;;;iCALoC,U;;IAQ5B,gB;;;;;AAET,4BAAY,OAAZ,EAA2B;AAAA;;AAAA;;AACvB,gCAAM,OAAN;AAFJ,WAAA,QAAA,GAAW,kBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,iCAA4B,gBAAgB,CAAC,SAA7C;AAFuB;AAG1B;;;iCALiC,U;;IAQzB,iB;;;;;AAET,6BAAY,IAAZ,EAAuB,EAAvB,EAAgC,QAAhC,EAA+C,MAA/C,EAA0D;AAAA;;AAAA;;AACtD,kEAA+B,IAA/B,eAAwC,EAAxC,eAA+C,QAA/C,wBAAqE,MAArE;AAFJ,YAAA,QAAA,GAAW,mBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,kCAA4B,iBAAiB,CAAC,SAA9C;AAFsD;AAGzD;;;iCALkC,U;;IAQ1B,iB;;;;;AAET,+BAAA;AAAA;;AAAA;;AACI;AAFJ,YAAA,QAAA,GAAW,mBAAX;AAGI,IAAA,MAAM,CAAC,cAAP,kCAA4B,iBAAiB,CAAC,SAA9C;AAFJ;AAGC;;;iCALkC,K;;IAQ1B,U;;;;;AAET,sBAAY,OAAZ,EAA2B;AAAA;;AAAA;;AACvB,kCAAM,OAAN;AAFJ,YAAA,QAAA,GAAW,YAAX;AAGI,IAAA,MAAM,CAAC,cAAP,kCAA4B,UAAU,CAAC,SAAvC;AAFuB;AAG1B;;;iCAL2B,K;;IAQnB,S;;;;;AAET,qBAAY,IAAZ,EAAwB;AAAA;;AAAA;;AACpB,kCAAM,IAAN;AAFJ,YAAA,QAAA,GAAW,WAAX;AAGI,IAAA,MAAM,CAAC,cAAP,kCAA4B,SAAS,CAAC,SAAtC;AAFoB;AAGvB;;;iCAL0B,K;;SC3Gf,K,CAAM,K,EAA6F;AAAA,MAAvE,IAAuE,uEAArC,SAAqC;AAAA,MAA1B,IAA0B,uEAAJ,IAAI;;;AAE/G,MAAI,KAAK,KAAK,SAAd,EAAyB;AAAA;AACrB,UAAM,IAAI,iBAAJ,CAAsB,KAAtB,EAA6B,IAA7B,EAAmC,IAAnC,EAAyC,0CAAzC,CAAN;AACH;;AAED,MAAK,OAAO,KAAP,KAAiB,QAAjB,IAA6B,KAAK,KAAK,GAAxC,IAAiD,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,KAAK,GAA1F,EAAgG;AAAA;AAC5F,UAAM,IAAI,iBAAJ,CAAsB,KAAtB,EAA6B,IAA7B,EAAmC,IAAnC,EAAyC,+CAAzC,CAAN;AACH,GAR8G,C;;;AAW/G,MAAI,IAAI,KAAK,SAAb,EAAwB;AACpB,IAAA,IAAI,GAAG,KAAP;AACA,IAAA,KAAK,GAAG,IAAR;AACH,GAd8G,C;;;;;AAoB/G,SAAO;AACH,IAAA,KAAK,EAAE,KAAK,KAAK,GAAV,GAAgB,IAAhB,GAAuB,KAD3B;AAEH,IAAA,IAAI,EAAE,IAAI,KAAK,GAAT,GAAe,IAAf,GAAsB,IAFzB;AAGH,IAAA,IAAI,EAAJ,IAHG;AAIH,IAAA,MAAM,EAAE;AAJL,GAAP;AAMH;AAGD;;;;;;AAIA,SAAS,aAAT,CAAuB,KAAvB,EAAsC,IAAtC,EAAoD,IAApD,EAAkE,MAAlE,EAAgF;AAC5E,MAAI,KAAK,GAAG,CAAZ,EAAe;AACX,IAAA,KAAK,IAAI,MAAT;;AACA,QAAI,KAAK,GAAG,CAAZ,EAAe;AACX,MAAA,KAAK,GAAI,IAAI,GAAG,CAAR,GAAa,CAAC,CAAd,GAAkB,CAA1B;AACH;AACJ,GALD,MAKO,IAAI,KAAK,IAAI,MAAb,EAAqB;AACxB,IAAA,KAAK,GAAI,IAAI,GAAG,CAAR,GAAa,MAAM,GAAG,CAAtB,GAA0B,MAAlC;AACH;;AAED,MAAI,IAAI,GAAG,CAAX,EAAc;AACV,IAAA,IAAI,IAAI,MAAR;;AACA,QAAI,IAAI,GAAG,CAAX,EAAc;AACV,MAAA,IAAI,GAAI,IAAI,GAAG,CAAR,GAAa,CAAC,CAAd,GAAkB,CAAzB;AACH;AACJ,GALD,MAKO,IAAI,IAAI,IAAI,MAAZ,EAAoB;AACvB,IAAA,IAAI,GAAI,IAAI,GAAG,CAAR,GAAa,MAAM,GAAG,CAAtB,GAA0B,MAAjC;AACH;;AAED,MAAI,IAAI,GAAG,CAAX,EAAc;AACV,QAAI,IAAI,GAAG,KAAX,EAAkB;AACd,UAAM,OAAM,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,KAAK,GAAG,IAAR,GAAe,CAAhB,IAAsB,CAAC,IAAvB,GAA+B,CAA1C,CAAf;;AACA,aAAO,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,OAApB,CAAP;AACH;AACJ,GALD,MAKO;AACH,QAAI,KAAK,GAAG,IAAZ,EAAkB;AACd,UAAM,QAAM,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,IAAI,GAAG,KAAP,GAAe,CAAhB,IAAqB,IAArB,GAA4B,CAAvC,CAAf;;AACA,aAAO,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,QAApB,CAAP;AACH;AACJ;;AACD,SAAO,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,CAApB,CAAP;AACH;AAED;;;;;;;;;SAOgB,Y,CAAa,K,EAAc,M,EAAc;AACrD,MAAI,KAAJ;AACA,MAAI,IAAJ;AACA,MAAI,IAAJ;;AAEA,MAAI,KAAK,CAAC,IAAN,KAAe,IAAnB,EAAyB;AACrB,IAAA,IAAI,GAAG,CAAP;AACH,GAFD,MAEO;AACH,IAAA,IAAI,GAAG,KAAK,CAAC,IAAb;AACH;;AAED,MAAI,KAAK,CAAC,KAAN,KAAgB,IAApB,EAA0B;AACtB,IAAA,KAAK,GAAG,IAAI,GAAG,CAAP,GAAW,MAAM,CAAC,gBAAlB,GAAqC,CAA7C;AACH,GAFD,MAEO;AACH,IAAA,KAAK,GAAG,KAAK,CAAC,KAAd;;AACA,QAAI,KAAK,GAAG,CAAZ,EAAe;AACX,MAAA,KAAK,IAAI,MAAT;AACH;AACJ;;AAED,MAAI,KAAK,CAAC,IAAN,KAAe,IAAnB,EAAyB;AACrB,IAAA,IAAI,GAAG,IAAI,GAAG,CAAP,GAAW,CAAC,MAAM,CAAC,gBAAnB,GAAsC,MAAM,CAAC,gBAApD;AACH,GAFD,MAEO;AACH,IAAA,IAAI,GAAG,KAAK,CAAC,IAAb;;AACA,QAAI,IAAI,GAAG,CAAX,EAAc;AACV,MAAA,IAAI,IAAI,MAAR;AACH;AACJ,GA3BoD,C;;;AA8BrD,MAAM,CAAC,GAAG,aAAa,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,MAApB,CAAvB;AACA,EAAA,KAAK,GAAG,CAAC,CAAC,CAAD,CAAT;AACA,EAAA,IAAI,GAAG,CAAC,CAAC,CAAD,CAAR;AACA,EAAA,IAAI,GAAG,CAAC,CAAC,CAAD,CAAR,CAjCqD,C;;AAmCrD,EAAA,MAAM,GAAG,CAAC,CAAC,CAAD,CAAV,CAnCqD,C;;;;AA0CrD,MAAI,IAAI,KAAK,CAAb,EAAgB,MAAM,IAAI,KAAJ,CAAU,wBAAV,CAAN;AAEhB,SAAO,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,MAApB,CAAP;AACJ;;ACrHA,SAAS,WAAT,CAAqB,SAArB,EAA8C;AAC1C,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,SAAd,CAAL,EAA+B;AAC3B,WAAO,CAAC,SAAD,CAAP;AACH;;AACD,SAAO,SAAP;AACH;;AAED,SAAS,oBAAT,CAA8B,SAA9B,EAAoE,KAApE,EAAmF;AAC/E,MAAI,SAAS,CAAC,MAAV,GAAmB,KAAK,CAAC,MAA7B,EAAqC;AACjC,UAAM,IAAI,mBAAJ,CAAwB,SAAxB,EAAmC,KAAnC,CAAN;AACH;AACJ;AAED;;;;;SAGgB,uB,CAAwB,S,EAAqC,K,EAAe;AACxF,MAAM,kBAAkB,GAAG,EAA3B;AACA,MAAM,QAAQ,GAAG,EAAjB;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACvC,QAAM,CAAC,GAAG,SAAS,CAAC,CAAD,CAAnB;;AACA,QAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B;AACvB,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,CAAxB;AACH,KAFD,MAEO;AACH,UAAM,CAAC,GAAG,YAAY,CAAC,CAAD,EAAI,KAAK,CAAC,CAAD,CAAT,CAAtB;AACA,UAAM,SAAS,GAAG,CAAC,CAAC,CAAD,CAAnB;AAEA,MAAA,QAAQ,CAAC,IAAT,CAAc,SAAd;AACA,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,CAAxB;AACH;AACJ;;AAED,SAAO,CAAC,kBAAD,EAAqB,QAArB,CAAP;AACH;AAED;;;;;SAGgB,uB,CAAwB,S,EAAoC,K,EAAwD;AAAA,MAAvC,+BAAuC,uEAAL,KAAK;AAChI,EAAA,SAAS,GAAG,eAAe,CAAC,SAAD,EAAY,KAAZ,CAA3B;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACvC,QAAM,YAAY,GAAG,SAAS,CAAC,CAAD,CAA9B;;AAEA,QAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AAClC,UAAI,+BAAJ,EAAqC;AACjC,QAAA,SAAS,CAAC,CAAD,CAAT,GAAe,KAAK,CAAC,YAAD,EAAe,YAAY,GAAG,CAA9B,EAAiC,CAAjC,CAApB;AACH,OAFD,MAEO;AACH,QAAA,SAAS,CAAC,CAAD,CAAT,GAAe,yBAAyB,CAAC,YAAD,EAAe,KAAK,CAAC,CAAD,CAApB,CAAxC;AACH;AACJ,KAND,MAMO,IAAI,cAAc,CAAC,YAAD,CAAlB,EAAkC;AACrC,YAAM,IAAI,SAAJ,CAAc,kDAAd,CAAN;AACH,KAFM,MAEA,IAAI,YAAY,KAAK,GAAjB,IAAwB,YAAY,KAAK,IAA7C,EAAmD;AACtD,MAAA,SAAS,CAAC,CAAD,CAAT,GAAe,KAAK,CAAC,IAAD,EAAO,IAAP,EAAa,CAAb,CAApB;AACH;AACJ;;AAED,SAAO,SAAP;AACH;;SAEe,e,CAAgB,S,EAAoC,K,EAAe;AAC/E,EAAA,SAAS,GAAG,WAAW,CAAC,SAAD,CAAvB;AAEA,MAAI,aAAa,GAAG,CAAC,CAArB;AACA,MAAI,WAAW,GAAG,CAAlB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACvC,QAAI,SAAS,CAAC,CAAD,CAAT,KAAiB,KAArB,EAA4B;AACxB,MAAA,aAAa,GAAG,CAAhB;AACA,MAAA,WAAW,IAAI,CAAf;AACH;AACJ;;AAED,MAAI,WAAW,GAAG,CAAlB,EAAqB;AACjB,UAAM,IAAI,UAAJ,CAAe,kDAAf,CAAN;AACH;;AACD,MAAI,WAAW,KAAK,CAApB,EAAuB;;AAEnB,QAAM,YAAY,GAAG,aAArB;AACA,QAAM,aAAa,GAAG,SAAS,CAAC,MAAV,IAAoB,YAAY,GAAG,CAAnC,CAAtB;AACA,QAAM,QAAQ,GAAG,SAAS,CAAC,MAAV,GAAmB,CAApC,CAJmB,CAImB;;AACtC,QAAI,QAAQ,IAAI,KAAK,CAAC,MAAtB,EAA8B;;AAE1B,MAAA,SAAS,GAAG,SAAS,CAAC,MAAV,CAAiB,UAAC,CAAD;AAAA,eAAO,CAAC,KAAK,KAAb;AAAA,OAAjB,CAAZ;AACH,KAHD,MAGO;;AAEH,UAAM,WAAW,GAAG,KAAK,CAAC,MAAN,GAAe,QAAnC;AACA,UAAI,OAAO,GAAG,SAAS,CAAC,KAAV,CAAgB,CAAhB,EAAmB,YAAnB,EAAiC,MAAjC,CAAwC,IAAI,KAAJ,CAAU,WAAV,EAAuB,IAAvB,CAA4B,IAA5B,CAAxC,CAAd;;AACA,UAAI,aAAa,GAAG,CAApB,EAAuB;AACnB,QAAA,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,SAAS,CAAC,KAAV,CAAgB,SAAS,CAAC,MAAV,GAAmB,aAAnC,CAAf,CAAV;AACH;;AACD,MAAA,SAAS,GAAG,OAAZ;AACH;AACJ,GAhC8E,C;;;AAkC/E,MAAI,SAAS,CAAC,MAAV,GAAmB,KAAK,CAAC,MAA7B,EAAqC;AACjC,QAAM,UAAU,GAAG,KAAK,CAAC,MAAN,GAAe,SAAS,CAAC,MAA5C;AACA,IAAA,SAAS,GAAG,SAAS,CAAC,MAAV,CAAiB,IAAI,KAAJ,CAAU,UAAV,EAAsB,IAAtB,CAA2B,IAA3B,CAAjB,CAAZ;AACH;;AAED,EAAA,oBAAoB,CAAC,SAAD,EAAY,KAAZ,CAApB;AACA,SAAO,SAAP;AACH;;SAEe,yB,CAA0B,Y,EAAsB,S,EAAiB;;;AAI7E,MAAI,YAAY,GAAG,CAAnB,EAAsB;AAClB,IAAA,YAAY,GAAG,SAAS,GAAG,YAA3B;AACH,GAN4E,C;;;AAS7E,MAAI,YAAY,IAAI,SAAhB,IAA6B,YAAY,GAAG,CAAhD,EAAmD;AAC/C,UAAM,IAAI,gBAAJ,yDAAsE,SAAtE,EAAN;AACH;;AAED,SAAO,YAAP;AACH;;AAED,SAAS,SAAT,CAAmB,CAAnB,EAAyB;AACrB,SAAO,OAAO,CAAP,KAAa,QAApB;AACH;;SAEe,c,CAAe,C,EAAM;AACjC,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,CAAd,CAAL,EAAuB;AACnB,WAAO,KAAP;AACH;;AAHgC,6CAIjB,CAJiB;AAAA;;AAAA;AAIjC,wDAAmB;AAAA,UAAR,CAAQ;;AACf,UAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B;AACvB,eAAO,KAAP;AACH;AACJ;AARgC;AAAA;AAAA;AAAA;AAAA;;AASjC,SAAO,IAAP;AACH;;SAEe,O,CAAQ,C,EAAmD;AACvE,MAAI,CAAC,KAAK,IAAN,IAAe,CAAS,CAAC,QAAD,CAAT,KAAwB,IAA3C,EAAiD;AAC7C,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AAED,SAAS,iBAAT,CAA2B,CAA3B,EAA8E;AAC1E,SAAO,OAAO,CAAC,CAAD,CAAP,KAAgB,CAAW,CAAC,IAAZ,KAAqB,IAArB,IAA8B,CAAW,CAAC,IAAZ,KAAqB,CAAnE,CAAP;AACH;;SAMe,qB,CAAsB,S,EAAyB;AAC3D,EAAA,SAAS,GAAG,WAAW,CAAC,SAAD,CAAvB;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACvC,QAAM,CAAC,GAAG,SAAS,CAAC,CAAD,CAAnB;;AACA,QAAI,EAAE,cAAc,CAAC,CAAD,CAAd,IAAqB,iBAAiB,CAAC,CAAD,CAAtC,IAA6C,CAAC,KAAK,KAArD,CAAJ,EAAiE;AAC7D,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;;AAcD,SAAU,OAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oCAAwB,SAAxB;AAAwB,YAAA,SAAxB;AAAA;;AAAA,gBACQ,SAAS,CAAC,MAAV,KAAqB,CAD7B;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAGU,UAAA,SAHV,GAGsB,SAAS,CAAC,GAAV,CAAc,UAAA,EAAE;AAAA,mBAAI,EAAE,EAAN;AAAA,WAAhB,CAHtB;AAIU,UAAA,OAJV,GAIoB,SAAS,CAAC,GAAV,CAAc,UAAA,EAAE;AAAA,mBAAI,EAAE,CAAC,IAAH,EAAJ;AAAA,WAAhB,CAJpB,E;;;;;AAWa,UAAA,CAXb,GAWiB,CAXjB;;AAAA;AAAA,eAYY,OAAO,CAAC,CAAD,CAAP,CAAW,IAZvB;AAAA;AAAA;AAAA;;;AAcY,UAAA,SAAS,CAAC,CAAD,CAAT,GAAe,SAAS,CAAC,CAAD,CAAT,EAAf;AACA,UAAA,OAAO,CAAC,CAAD,CAAP,GAAa,SAAS,CAAC,CAAD,CAAT,CAAa,IAAb,EAAb,CAfZ,C;;AAAA,gBAiBgB,EAAE,CAAF,IAAO,SAAS,CAAC,MAjBjC;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAmBY,iBAAM,OAAO,CAAC,GAAR,CAAY;AAAA,gBAAG,KAAH,QAAG,KAAH;AAAA,mBAAe,KAAf;AAAA,WAAZ,CAAN;;AAnBZ;AAoBY,UAAA,CAAC,GAAG,CAAJ;;AApBZ;AAsBQ,UAAA,OAAO,CAAC,CAAD,CAAP,GAAa,SAAS,CAAC,CAAD,CAAT,CAAa,IAAb,EAAb;;AAtBR;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;IA0Ba,Y;AAKT,wBAAY,SAAZ,EAAuC,KAAvC,EAAuD;AAAA;;AACnD,IAAA,SAAS,GAAG,uBAAuB,CAAC,SAAD,EAAY,KAAK,CAAC,KAAlB,CAAnC,CADmD,C;;AAInD,SAAK,WAAL,GAAmB,EAAnB;AACA,QAAM,UAAU,GAAG,KAAK,CAAC,KAAzB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,MAA/B,EAAuC,CAAC,EAAxC,EAA4C;AACxC,UAAI,YAAY,GAAG,SAAS,CAAC,CAAD,CAA5B;AACA,UAAM,SAAS,GAAG,UAAU,CAAC,CAAD,CAA5B;AACA,UAAM,cAAc,GAAG,KAAK,CAAC,MAAN,CAAa,CAAb,CAAvB;;AAEA,UAAI,YAAY,KAAK,IAArB,EAA2B;AACvB,QAAA,YAAY,GAAG,KAAK,CAAC,IAAD,CAApB;AACH;;AAGD,UAAI,SAAS,CAAC,YAAD,CAAb,EAA6B;AACzB,aAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAI,aAAJ,CAAkB,YAAlB,EAA0C,SAA1C,EAAqD,cAArD,CAAtB;AACH,OAFD,MAEO,IAAI,OAAO,CAAC,YAAD,CAAX,EAA2B;AAC9B,aAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAI,eAAJ,CAAoB,YAApB,EAA2C,SAA3C,EAAsD,cAAtD,CAAtB;AACH,OAFM,MAEA;AACH,cAAM,IAAI,UAAJ,wFAA+F,YAA/F,EAAN;AACH;AACJ;;AAED,SAAK,KAAL,GAAa,EAAb;;AAzBmD,gDA0BnC,KAAK,WA1B8B;AAAA;;AAAA;AA0BnD,6DAAkC;AAAA,YAAvB,CAAuB;;AAC9B,YAAI,CAAC,YAAY,eAAjB,EAAkC;AAC9B,eAAK,KAAL,CAAW,IAAX,CAAgB,CAAC,CAAC,QAAlB;AACH;AACJ;AA9BkD;AAAA;AAAA;AAAA;AAAA;;AA+BnD,SAAK,QAAL,GAAgB,IAAhB;AACH;;;;;;;;;;;AAGS,cAAA,mB,GAAsB,KAAK,WAAL,CAAiB,GAAjB,CAAqB,UAAA,CAAC;AAAA,uBAAK;AAAA,yBAAM,CAAC,CAAC,IAAF,EAAN;AAAA,iBAAL;AAAA,eAAtB,C;AACtB,cAAA,iB,GAAoB,OAAO,MAAP,4BAAW,mBAAX,E;sDAEG,iB;;;;;;;;;;;AAAlB,cAAA,c;;AAED,cAAA,W,GAAc,E;AACd,cAAA,c,GAAiB,E;AACjB,cAAA,Y,GAAe,E;sDAEL,c;;;AAAhB,uEAAgC;AAArB,kBAAA,CAAqB;AAC5B,kBAAA,WAAW,CAAC,IAAZ,CAAkB,CAAD,CAAI,aAArB;AACA,kBAAA,cAAc,CAAC,IAAf,CAAqB,CAAD,CAAI,iBAAxB;;AACA,sBAAK,CAAD,CAAI,eAAJ,KAAwB,IAA5B,EAAkC;AAC9B,oBAAA,YAAY,CAAC,IAAb,CAAmB,CAAD,CAAI,eAAtB;AACH;AACJ;;;;;;;;AAED,qBAAO;AACH,gBAAA,WAAW,EAAX,WADG;AAEH,gBAAA,cAAc,EAAd,cAFG;AAGH,gBAAA,YAAY,EAAZ;AAHG,eAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAUN,a;AAMF,yBAAY,YAAZ,EAAkC,SAAlC,EAAqD,cAArD,EAA2E;AAAA;;AACvE,IAAA,YAAY,GAAG,yBAAyB,CAAC,YAAD,EAAe,SAAf,CAAxC;AACA,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,SAAL,GAAiB,SAAjB;AACA,SAAK,cAAL,GAAsB,cAAtB;AACA,SAAK,QAAL,GAAgB,CAAhB;AACH;;;;;;;;;;AAGS,cAAA,a,GAAgB,IAAI,CAAC,KAAL,CAAW,KAAK,YAAL,GAAoB,KAAK,cAApC,C;AAChB,cAAA,S,GAAY,aAAa,GAAG,KAAK,c;AACjC,cAAA,iB,GAAoB,KAAK,YAAL,GAAoB,S;AACxC,cAAA,e,GAAkB,I;;AACxB,qBAAM;AACF,gBAAA,aAAa,EAAb,aADE;AAEF,gBAAA,iBAAiB,EAAjB,iBAFE;AAGF,gBAAA,eAAe,EAAf;AAHE,eAAN;;;;;;;;;;;;;;IAQF,e;AAUF,2BAAY,YAAZ,EAAiC,SAAjC,EAAoD,cAApD,EAA0E;AAAA;;;AAAA,wBAE1C,YAAY,CAAC,YAAD,EAAe,SAAf,CAF8B;AAAA;AAAA,QAE/D,KAF+D;AAAA,QAExD,IAFwD;AAAA,QAElD,IAFkD;;AAGtE,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,IAAL,GAAY,IAAZ;;AACA,QAAI,KAAK,IAAL,GAAY,CAAhB,EAAmB;AACf,YAAM,IAAI,iBAAJ,EAAN;AACH;;AAED,SAAK,SAAL,GAAiB,SAAjB;AACA,SAAK,cAAL,GAAsB,cAAtB;AACA,SAAK,QAAL,GAAgB,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,CAAC,KAAK,IAAL,GAAY,KAAK,KAAlB,IAA2B,KAAK,IAA1C,CAAZ,CAAhB;AACA,SAAK,SAAL,GAAiB,IAAI,CAAC,IAAL,CAAU,KAAK,SAAL,GAAiB,KAAK,cAAhC,CAAjB;AACH;;;;;;;;;;AAGS,cAAA,iB,GAAoB,IAAI,CAAC,KAAL,CAAW,KAAK,KAAL,GAAa,KAAK,cAA7B,C;AACpB,cAAA,e,GAAkB,IAAI,CAAC,IAAL,CAAU,KAAK,IAAL,GAAY,KAAK,cAA3B,C;;AAGf,cAAA,a,GAAgB,iB;;;oBAAmB,aAAa,GAAG,e;;;;;;AAGlD,cAAA,S,GAAY,aAAa,GAAG,KAAK,c;AACjC,cAAA,Q,GAAW,IAAI,CAAC,GAAL,CAAS,KAAK,SAAd,EAAyB,CAAC,aAAa,GAAG,CAAjB,IAAsB,KAAK,cAApD,C;;AAGX,cAAA,c,GAAiB,QAAQ,GAAG,S;AAE9B,cAAA,gB;AACA,cAAA,e;AACA,cAAA,Y;;AAEJ,kBAAI,KAAK,KAAL,GAAa,SAAjB,EAA4B;;AAGxB,gBAAA,gBAAgB,GAAG,CAAnB;AACM,gBAAA,SAJkB,GAIN,CAAC,SAAS,GAAG,KAAK,KAAlB,IAA2B,KAAK,IAJ1B;;AAKxB,oBAAI,SAAS,GAAG,CAAhB,EAAmB;AACf,kBAAA,gBAAgB,IAAI,KAAK,IAAL,GAAY,SAAhC;AACH,iBAPuB,C;;;AASxB,gBAAA,YAAY,GAAG,IAAI,CAAC,IAAL,CAAU,CAAC,SAAS,GAAG,KAAK,KAAlB,IAA2B,KAAK,IAA1C,CAAf;AACH,eAVD,MAUO;;AAEH,gBAAA,gBAAgB,GAAG,KAAK,KAAL,GAAa,SAAhC;AACA,gBAAA,YAAY,GAAG,CAAf;AACH;;AAED,kBAAI,KAAK,IAAL,GAAY,QAAhB,EAA0B;;AAEtB,gBAAA,eAAe,GAAG,cAAlB;AACH,eAHD,MAGO;;AAEH,gBAAA,eAAe,GAAG,KAAK,IAAL,GAAY,SAA9B;AACH;;AAEK,cAAA,iB,GAAoB,KAAK,CAAC,gBAAD,EAAmB,eAAnB,EAAoC,KAAK,IAAzC,C;AACzB,cAAA,gB,GAAmB,IAAI,CAAC,IAAL,CAAU,CAAC,eAAe,GAAG,gBAAnB,IAAuC,KAAK,IAAtD,C;AACnB,cAAA,e,GAAkB,KAAK,CAAC,YAAD,EAAe,YAAY,GAAG,gBAA9B,C;;AAC7B,qBAAM;AACF,gBAAA,aAAa,EAAb,aADE;AAEF,gBAAA,iBAAiB,EAAjB,iBAFE;AAGF,gBAAA,eAAe,EAAf;AAHE,eAAN;;;AAxCyE,cAAA,aAAa,E;;;;;;;;;;;;;;;ACrUlG;;;;;AAGO,IAAM,OAAO,GAAG,OAAO,OAAP,KAAmB,WAAnB,IAAkC,OAAO,CAAC,QAA1C,IAAsD,OAAO,CAAC,QAAR,CAAiB,IAAvF,C,CAqBP;;SACgB,oB,CAAqB,I,EAA4B;AAC7D,MAAI,IAAI,KAAK,IAAb,EAAmB;AACf,WAAO,EAAP;AACH;;AAED,MAAI,IAAI,YAAY,MAApB,EAA4B;AACxB,IAAA,IAAI,GAAG,IAAI,CAAC,OAAL,EAAP;AACH,GAP4D,C;;;AAU7D,EAAA,IAAI,GAAG,IAAI,CAAC,OAAL,CAAa,KAAb,EAAoB,GAApB,CAAP,CAV6D,C;;AAY7D,SAAO,IAAI,CAAC,MAAL,GAAc,CAAd,IAAmB,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAtC,EAA2C;AACvC,IAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,CAAP;AACH,GAd4D,C;;;AAiB7D,SAAO,IAAI,CAAC,MAAL,GAAc,CAAd,IAAmB,IAAI,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAJ,KAA0B,GAApD,EAAyD;AACrD,IAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,IAAI,CAAC,MAAL,GAAc,CAA5B,CAAP;AACH,GAnB4D,C;;;AAuB7D,EAAA,IAAI,GAAG,IAAI,CAAC,OAAL,CAAa,QAAb,EAAuB,GAAvB,CAAP,CAvB6D,C;;AA0B7D,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAjB;;AA1B6D,8CA4B7C,QA5B6C;AAAA;;AAAA;AA4B7D,2DAA0B;AAAA,UAAf,CAAe;;AACtB,UAAI,CAAC,KAAK,GAAN,IAAa,CAAC,KAAK,IAAvB,EAA6B;AACzB,cAAM,KAAK,CAAC,iDAAD,CAAX;AACH;AACJ;AAhC4D;AAAA;AAAA;AAAA;AAAA;;AAiC7D,SAAO,IAAP;AACH;;SAEe,c,CAAe,K,EAAwB;AACnD,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,IAAA,KAAK,GAAG,CAAC,KAAD,CAAR;AACH;;AACD,SAAO,KAAK,CAAC,GAAN,CAAU,UAAA,CAAC;AAAA,WAAI,IAAI,CAAC,KAAL,CAAW,CAAX,CAAJ;AAAA,GAAX,CAAP;AACH;;SAEe,e,CAAgB,M,EAAwB,K,EAAe;;AAGnE,MAAI,MAAM,KAAK,IAAX,IAAmB,MAAM,KAAK,IAAlC,EAAwC;AACpC,UAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACH;;AAED,MAAI,MAAM,KAAK,KAAf,EAAsB;AAClB,WAAO,KAAP;AACH;;AAED,MAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,IAAA,MAAM,GAAG,CAAC,MAAD,CAAT;AACH,GAbkE,C;;;AAgBnE,MAAI,MAAM,CAAC,MAAP,GAAgB,KAAK,CAAC,MAA1B,EAAkC;;AAE9B,IAAA,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,KAAK,CAAC,KAAN,CAAY,MAAM,CAAC,MAAnB,CAAd,CAAT;AACH;;AAED,SAAO,MAAM,CAAC,GAAP,CAAW,UAAC,CAAD,EAAI,GAAJ,EAAO;;AAErB,QAAI,CAAC,KAAK,CAAC,CAAP,IAAY,CAAC,KAAK,IAAtB,EAA4B;AACxB,aAAO,KAAK,CAAC,GAAD,CAAZ;AACH,KAFD,MAEO;AACH,aAAO,IAAI,CAAC,KAAL,CAAW,CAAX,CAAP;AACH;AACJ,GAPM,CAAP;AAQH;;SAEe,c,CAAe,K,EAAa;AACxC,EAAA,KAAK,GAAG,KAAK,CAAC,WAAN,EAAR;AACA,SAAO,KAAP;AACH;;SAEe,c,CAAe,K,EAAkB;AAC7C,SAAO,KAAP;AACH;;SAEe,kB,CAAmB,S,EAAmB;AAClD,SAAO,SAAP;AACH;AAED;;;;;;;;SAMgB,Y,CAAa,I,EAAiD,K,EAAe;AACzF,MAAI,IAAI,KAAK,IAAb,EAAmB;AACf,WAAO,IAAP;AACH;;AACD,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,IAAd,CAAL,EAA0B;AACtB,IAAA,IAAI,GAAG,CAAC,IAAD,CAAP;AACH;;AAED,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,MAAd,EAAsB,KAAK,CAAC,MAA5B,CAApB,EAAyD,CAAC,EAA1D,EAA8D;AAC1D,QAAM,EAAE,GAAG,IAAI,CAAC,CAAD,CAAf;AACA,QAAI,EAAE,KAAK,IAAX,EAAiB;;AAEjB,QAAI,OAAO,CAAC,EAAD,CAAX,EAAiB;AACb,UAAM,CAAC,GAAG,EAAV;AACA,UAAM,SAAS,GAAG,CAAC,CAAC,IAAF,KAAW,CAAX,IAAgB,CAAC,CAAC,IAAF,KAAW,IAA7C;;AAEA,UAAI,CAAC,CAAC,KAAF,KAAY,IAAZ,IAAoB,CAAC,CAAC,IAAF,KAAW,IAA/B,IAAuC,SAA3C,EAAsD;AAClD;AACH;;AACD,UAAM,CAAC,CAAC,IAAF,GAAqB,CAAC,CAAC,KAAzB,KAA+C,KAAK,CAAC,CAAD,CAApD,IAA2D,SAA/D,EAA0E;AACtE;AACH;;AACD,aAAO,KAAP;AACH;;AACD,WAAO,KAAP,CAhB0D,C;;;;AAuB7D;;AACD,SAAO,IAAP;AACH;AAED;;;;;SAGgB,a,CAAc,C,EAAmB,C,EAAiB;AAC9D,MAAI,CAAC,CAAC,MAAF,KAAa,CAAC,CAAC,MAAnB,EAA2B;AACvB,WAAO,KAAP;AACH;;AAED,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,MAAtB,EAA8B,CAAC,EAA/B,EAAmC;AAC/B,QAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAAd,EAAmB;AACf,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;AAED;;;;;;;;;SAOgB,U,CAAW,K,EAAe;;AAEtC,MAAM,IAAI,GAAG,KAAK,CAAC,MAAnB;AACA,MAAM,OAAO,GAAG,KAAK,CAAC,IAAD,CAArB;AACA,MAAI,IAAI,GAAG,CAAX,CAJsC,CAIzB;;AACb,OAAK,IAAI,CAAC,GAAG,IAAI,GAAG,CAApB,EAAuB,CAAC,IAAI,CAA5B,EAA+B,CAAC,EAAhC,EAAoC;AAChC,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,IAAb;AACA,IAAA,IAAI,IAAI,KAAK,CAAC,CAAD,CAAb;AACH;;AACD,SAAO,OAAP;AACH;AAED;;;;;;;SAKgB,Y,GAA8B;AAAA,qCAAd,IAAc;AAAd,IAAA,IAAc;AAAA;;AAC1C,SAAO,IAAI,CAAC,GAAL,CAAS,UAAC,IAAD,EAAO,CAAP,EAAQ;AACpB,QAAI,CAAC,KAAK,CAAV,EAAa;AACX,aAAO,IAAI,CAAC,IAAL,GAAY,OAAZ,CAAoB,SAApB,EAA+B,EAA/B,CAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAI,CAAC,IAAL,GAAY,OAAZ,CAAoB,kBAApB,EAAwC,EAAxC,CAAP;AACD;AACF,GANI,EAMF,MANE,CAMK,UAAA,CAAC;AAAA,WAAE,CAAC,CAAC,MAAJ;AAAA,GANN,EAMkB,IANlB,CAMuB,GANvB,CAAP;AAOH;AAGD;;;;;;;SAKgB,e,CAAgB,G,EAAe;AAC7C,MAAM,CAAC,GAAG,GAAG,CAAC,iBAAd;AACA,MAAI,CAAC,KAAK,CAAV,EAAa,OAFgC,CAEzB;;AACpB,MAAI,OAAJ,EAAa;;AAEX,QAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,GAAG,CAAC,MAAhB,EAAwB,GAAG,CAAC,UAA5B,EAAwC,GAAG,CAAC,MAAJ,GAAa,CAArD,CAAd;AACA,QAAI,CAAC,KAAK,CAAV,EAAa,KAAK,CAAC,MAAN;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,KAAK,CAAC,MAAN;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,KAAK,CAAC,MAAN;AACb;AACD,GAV4C,C;;;;AAa7C,MAAM,OAAO,GAAG,IAAI,UAAJ,CAAe,GAAG,CAAC,MAAnB,EAA2B,GAAG,CAAC,UAA/B,EAA2C,GAAG,CAAC,MAAJ,GAAa,CAAxD,CAAhB;AACA,MAAM,QAAQ,GAAG,CAAC,GAAG,CAArB;AACA,MAAM,YAAY,GAAG,CAAC,GAAG,CAAzB;AACA,MAAI,CAAJ;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,IAAI,CAAzC,EAA4C;AAC1C,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,CAAC,EAA/B,EAAmC;AACjC,MAAA,CAAC,GAAG,OAAO,CAAC,CAAC,GAAG,CAAL,CAAX;AACA,MAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,OAAO,CAAC,CAAC,GAAG,YAAJ,GAAmB,CAApB,CAAxB;AACA,MAAA,OAAO,CAAC,CAAC,GAAG,YAAJ,GAAmB,CAApB,CAAP,GAAgC,CAAhC;AACD;AACF;AACF;AAED;;;;;;;SAKgB,Q,CAAS,G,EAAe;AACpC,MAAM,IAAI,GAAG,GAAG,CAAC,KAAJ,EAAb;AACA,EAAA,eAAe,CAAC,IAAD,CAAf;AACA,SAAO,IAAP;AACJ;;AC1PO,IAAM,cAAc,GAAG,SAAvB;AACA,IAAM,cAAc,GAAG,SAAvB;AACA,IAAM,cAAc,GAAG,SAAvB;ACKP;;;;SAGsB,a;;;AAOtB;;;;;;4EAPO,mBAA6B,KAA7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C,YAAA,IAA3C,iEAAiE,IAAjE;AACH,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;AACM,YAAA,MAFH,GAEY,YAAY,CAAC,IAAD,CAFxB;AAGG,YAAA,GAHH,GAGS,MAAM,GAAG,cAHlB;AAAA,+CAII,KAAK,CAAC,YAAN,CAAmB,GAAnB,CAJJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAUe,a;;;;;4EAAf,mBAA6B,KAA7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C,YAAA,IAA3C,iEAAiE,IAAjE;AACH,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;AACM,YAAA,MAFH,GAEY,YAAY,CAAC,IAAD,CAFxB;AAGG,YAAA,GAHH,GAGS,MAAM,GAAG,cAHlB;AAAA,+CAII,KAAK,CAAC,YAAN,CAAmB,GAAnB,CAJJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAQS,Y,CAAa,I,EAAY;;AAErC,MAAI,IAAI,CAAC,MAAL,GAAc,CAAlB,EAAqB;AACjB,WAAO,IAAI,GAAG,GAAd;AACH;;AACD,SAAO,EAAP;AACH;;SAiBc,kB;;;;;iFAAf,mBAAkC,KAAlC,EAAgD,IAAhD,EAA8D,UAA9D,EAAwF,SAAxF;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kBAEQ,IAAI,CAAC,MAAL,KAAgB,CAFxB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAMU,YAAA,QANV,GAMqB,IAAI,CAAC,KAAL,CAAW,GAAX,CANrB;AAOQ,YAAA,CAPR,GAOY,EAPZ;AAAA,qDAQoB,QAAQ,CAAC,KAAT,CAAe,CAAf,EAAkB,QAAQ,CAAC,MAAT,GAAkB,CAApC,CARpB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQe,YAAA,CARf;AASQ,YAAA,CAAC,IAAI,CAAL;AATR;AAAA,mBAUkB,aAAa,CAAC,KAAD,EAAQ,CAAR,CAV/B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAWkB,iBAAiB,CAAC,KAAD,EAAQ,CAAR,EAAW,SAAX,CAXnC;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,mBAY0B,aAAa,CAAC,KAAD,EAAQ,CAAR,CAZvC;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAakB,iBAAiB,CAAC,KAAD,EAAQ,CAAR,CAbnC;;AAAA;AAeQ,YAAA,CAAC,IAAI,GAAL;;AAfR;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAkCe,iB;;;AAgBf;;;;;;;gFAhBA,mBAAiC,KAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C,YAAA,IAA/C,iEAAqE,IAArE;AAA2E,YAAA,SAA3E,iEAAuF,KAAvF;AACI,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B,CADJ,C;;AAAA,iBAIQ,SAJR;AAAA;AAAA;AAAA;;AAAA,kBAKc,KAAK,CAAC,0CAAD,CALnB;;AAAA;AAAA;AAAA,mBAMqB,aAAa,CAAC,KAAD,EAAQ,IAAR,CANlC;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAOc,IAAI,kBAAJ,CAAuB,IAAvB,CAPd;;AAAA;AAAA;AAAA,mBAQqB,aAAa,CAAC,KAAD,EAAQ,IAAR,CARlC;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBASc,IAAI,kBAAJ,CAAuB,IAAvB,CATd;;AAAA;AAYU,YAAA,QAZV,GAYwC;AAAE,cAAA,WAAW,EAAE;AAAf,aAZxC;AAaU,YAAA,GAbV,GAagB,YAAY,CAAC,IAAD,CAAZ,GAAqB,cAbrC;AAAA;AAAA,mBAcU,KAAK,CAAC,OAAN,CAAc,GAAd,EAAmB,IAAI,CAAC,SAAL,CAAe,QAAf,CAAnB,CAdV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAoBsB,S;;;;;wEAAf,mBAAyB,KAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC,YAAA,IAAvC,iEAA6D,IAA7D;AAAmE,YAAA,UAAnE,iEAA8F,IAA9F;AAAoG,YAAA,SAApG,iEAAgH,KAAhH;AACH,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;AADG;AAAA,mBAEG,kBAAkB,CAAC,KAAD,EAAQ,IAAR,EAAc,UAAd,EAA0B,SAA1B,CAFrB;;AAAA;AAAA;AAAA,mBAGG,iBAAiB,CAAC,KAAD,EAAQ,IAAR,EAAc,SAAd,CAHpB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAMQ,iB;;;AA6Df;;;;;;;;gFA7DA,mBACI,KADJ,EAEI,KAFJ,EAGI,MAHJ,EAII,KAJJ,EAKI,IALJ,EAMI,UANJ,EAOI,SAPJ,EAQI,KARJ,EASI,SATJ,EAUI,UAVJ,EAWI,OAXJ,EAYI,kBAZJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAeQ,SAfR;AAAA;AAAA;AAAA;;AAAA,kBAgBc,KAAK,CAAC,0CAAD,CAhBnB;;AAAA;AAAA;AAAA,mBAiBqB,aAAa,CAAC,KAAD,EAAQ,IAAR,CAjBlC;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAkBc,IAAI,kBAAJ,CAAuB,IAAvB,CAlBd;;AAAA;AAAA;AAAA,mBAmBqB,aAAa,CAAC,KAAD,EAAQ,IAAR,CAnBlC;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAoBc,IAAI,kBAAJ,CAAuB,IAAvB,CApBd;;AAAA;;AAwBI,YAAA,KAAK,GAAG,cAAc,CAAC,KAAD,CAAtB;AACA,YAAA,KAAK,GAAG,cAAc,CAAC,KAAD,CAAtB;AACA,YAAA,MAAM,GAAG,eAAe,CAAC,MAAD,EAAS,KAAT,CAAxB;AACA,YAAA,KAAK,GAAG,cAAc,CAAC,KAAD,CAAtB;AACA,YAAA,SAAS,GAAG,kBAAkB,CAAC,SAAD,CAA9B;;AA5BJ,kBA8BQ,OAAO,KAAK,IAAZ,IAAoB,OAAO,CAAC,MAAR,GAAiB,CA9B7C;AAAA;AAAA;AAAA;;AAAA,kBA+Bc,KAAK,CAAC,+BAAD,CA/BnB;;AAAA;AAkCQ,YAAA,mBAlCR,GAkCkD,SAlClD;;AAoCI,gBAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,kBAAI,MAAM,CAAC,KAAP,CAAa,SAAb,CAAJ,EAA6B,mBAAmB,GAAG,KAAtB;AAC7B,kBAAI,MAAM,CAAC,iBAAP,KAA6B,SAAjC,EAA4C,mBAAmB,GAAG,UAAtB;AAC5C,kBAAI,MAAM,CAAC,iBAAP,KAA6B,SAAjC,EAA4C,mBAAmB,GAAG,WAAtB;AAC/C;;AAED,YAAA,OAAO,GAAG,IAAV;AAEM,YAAA,QA5CV,GA4CwC;AAChC,cAAA,WAAW,EAAE,CADmB;AAEhC,cAAA,KAAK,EAAE,KAFyB;AAGhC,cAAA,MAAM,EAAE,MAHwB;AAIhC,cAAA,KAAK,EAAE,KAJyB;AAKhC,cAAA,UAAU,EAAE,mBALoB;AAMhC,cAAA,KAAK,EAAE,KANyB;AAOhC,cAAA,UAAU,EAAE,UAPoB;AAQhC,cAAA,OAAO,EAAE;AARuB,aA5CxC;;AAsDI,gBAAI,kBAAJ,EAAwB;AACpB,cAAA,QAAQ,CAAC,mBAAT,GAA+B,kBAA/B;AACH;;AACK,YAAA,OAzDV,GAyDoB,YAAY,CAAC,IAAD,CAAZ,GAAqB,cAzDzC;AAAA;AAAA,mBA0DU,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,IAAI,CAAC,SAAL,CAAe,QAAf,CAAvB,CA1DV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAkEsB,S;;;;;wEAAf,mBACH,KADG,EAEH,KAFG,EAGH,MAHG,EAIH,KAJG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKH,YAAA,IALG,iEAKmB,IALnB;AAMH,YAAA,UANG,iEAMmC,IANnC;AAOH,YAAA,SAPG,iEAOmB,IAPnB;AAQH,YAAA,KARG,iEAQY,GARZ;AASH,YAAA,SATG,iEASS,KATT;AAUH,YAAA,UAVG,iEAUwB,IAVxB;AAWH,YAAA,OAXG,oEAWwB,IAXxB;AAYH,YAAA,kBAZG;AAeH,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;AAfG;AAAA,mBAgBG,kBAAkB,CAAC,KAAD,EAAQ,IAAR,EAAc,UAAd,EAA0B,SAA1B,CAhBrB;;AAAA;AAAA;AAAA,mBAiBG,iBAAiB,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B,IAA9B,EAAoC,UAApC,EAAgD,SAAhD,EAA2D,KAA3D,EAAkE,SAAlE,EAA6E,UAA7E,EAAyF,OAAzF,EAAkG,kBAAlG,CAjBpB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SC7KS,a,CACZ,C,EAAoC;;;;;AAMpC,MAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B;;AAEvB,QAAI,OAAO,IAAI,MAAM,CAAC,QAAP,CAAgB,CAAhB,CAAf,EAAmC;AAC/B,aAAO,IAAI,CAAC,KAAL,CAAW,CAAC,CAAC,QAAF,EAAX,CAAP;AACH,KAFD,MAEO,IAAI,CAAC,YAAY,WAAjB,EAA8B;AACjC,UAAM,WAAW,GAAG,IAAI,WAAJ,EAApB;AACA,UAAM,KAAK,GAAG,IAAI,UAAJ,CAAe,CAAf,CAAd;AACA,aAAO,IAAI,CAAC,KAAL,CAAW,WAAW,CAAC,MAAZ,CAAmB,KAAnB,CAAX,CAAP;AACH,KAJM,MAIA;AACH,aAAO,CAAP;AACH;AACJ;;AACD,SAAO,IAAI,CAAC,KAAL,CAAW,CAAX,CAAP;AACJ;AClBA;;;;;;;IAKa,U;AAOT,sBAAY,KAAZ,EAA0B,GAA1B,EAAuC,QAAvC,EAAsE;AAAA,QAAZ,KAAY,uEAAJ,IAAI;;AAAA;;AAClE,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,GAAL,GAAW,GAAX;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,WAAL,GAAmB,IAAnB;AACH;;;;;;;;;;;;;;;sBAMO,KAAK,KAAL,IAAc,KAAK,WAAL,KAAqB,I;;;;;kDAC5B,KAAK,W;;;;uBAEA,KAAK,SAAL,E;;;AAAV,gBAAA,C;;AACN,oBAAI,KAAK,KAAT,EAAgB;AACZ,uBAAK,WAAL,GAAmB,CAAnB;AACH;;kDACM,C;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAKgB,KAAK,KAAL,CAAW,OAAX,CAAmB,KAAK,GAAxB,C;;;AAAb,gBAAA,I;kDAEC,aAAa,CAAC,IAAD,C;;;;;kDAEb,E;;;;;;;;;;;;;;;;;;;kGAIS,G,EAAa,K;;;;;;;uBACjB,KAAK,SAAL,E;;;AAAV,gBAAA,C;AACL,gBAAA,CAAS,CAAC,GAAD,CAAT,GAAiB,KAAjB;;uBACK,KAAK,SAAL,CAAe,CAAf,C;;;kDACC,I;;;;;;;;;;;;;;;;;;;kGAGa,C;;;;;;uBACd,KAAK,KAAL,CAAW,OAAX,CAAmB,KAAK,GAAxB,EAA6B,IAAI,CAAC,SAAL,CAAe,CAAf,CAA7B,C;;;AACN,oBAAI,KAAK,KAAT,EAAgB;AACZ,uBAAK,WAAL,GAAmB,CAAnB;AACH;;;;;;;;;;;;;;;;;;;kGAGmB,G;;;;;;;uBACJ,KAAK,SAAL,E;;;AAAV,gBAAA,C;AACN,uBAAQ,CAAS,CAAC,GAAD,CAAjB;;uBACM,KAAK,SAAL,CAAe,CAAf,C;;;kDACC,I;;;;;;;;;;;;;;;;;;;;;;;4FAMD,C;;;;;qBACF,KAAK,Q;;;;;sBACC,IAAI,eAAJ,CAAoB,0BAApB,C;;;mDAEH,KAAK,SAAL,CAAe,CAAf,C;;;;;;;;;;;;;;;;;;;gGAGG,G,EAAa,K;;;;;qBACnB,KAAK,Q;;;;;sBACC,IAAI,eAAJ,CAAoB,0BAApB,C;;;mDAEH,KAAK,SAAL,CAAe,GAAf,EAAoB,KAApB,C;;;;;;;;;;;;;;;;;;;gGAGG,G;;;;;;uBACK,KAAK,QAAL,E;;;gCAAyB,G;;;;;;;;;;;;;;;;;;;;mGAG3B,G;;;;;qBACT,KAAK,Q;;;;;sBACC,IAAI,eAAJ,CAAoB,0BAApB,C;;;mDAEH,KAAK,SAAL,CAAe,GAAf,C;;;;;;;;;;;;;;;;;;;sGAGQ,G;;;;;;uBACA,KAAK,QAAL,E;;;gCAAyB,G;;gCAAS,S;;;;;;;;;;;;;;;;;;;4BAGhD;AACD,aAAO,WAAW,CAAC,IAAD,CAAlB;AACH;;;;;;AC1EL,IAAM,wBAAwB,GAA8D;AAC1F,QAAM,SADoF;AAE1F,QAAM,UAFoF;AAG1F,SAAO,UAHmF;AAI1F,SAAO,SAJmF;AAK1F,QAAM,SALoF;AAM1F,QAAM,UANoF;AAO1F,SAAO,UAPmF;AAQ1F,SAAO,SARmF;AAS1F,SAAO,WATmF;AAU1F,SAAO,UAVmF;AAW1F,SAAO,WAXmF;AAY1F,SAAO,UAZmF;AAa1F,SAAO,YAbmF;AAc1F,SAAO,YAdmF;AAe1F,QAAM,SAfoF;AAgB1F,QAAM,UAhBoF;AAiB1F,SAAO,UAjBmF;AAkB1F,SAAO,SAlBmF;AAmB1F,SAAO,WAnBmF;AAoB1F,SAAO,UApBmF;AAqB1F,SAAO,WArBmF;AAsB1F,SAAO,UAtBmF;AAuB1F,SAAO,YAvBmF;AAwB1F,SAAO;AAxBmF,CAA5F;;SA4BgB,gB,CAAiB,K,EAAkB;AACjD,MAAM,GAAG,GAAG,wBAAwB,CAAC,KAAD,CAApC;;AACA,MAAI,CAAC,GAAL,EAAU;AACR,UAAM,KAAK,iEAA0D,KAA1D,OAAX;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;SASgB,wB,CAAyB,C,EAAa;;AAEpD,MAAI,CAAC,YAAY,UAAjB,EAA6B,OAAO,KAAP;AAC7B,MAAI,CAAC,YAAY,SAAjB,EAA4B,OAAO,KAAP;AAC5B,MAAI,CAAC,YAAY,WAAjB,EAA8B,OAAO,KAAP;AAC9B,MAAI,CAAC,YAAY,UAAjB,EAA6B,OAAO,KAAP;AAC7B,MAAI,CAAC,YAAY,WAAjB,EAA8B,OAAO,KAAP;AAC9B,MAAI,CAAC,YAAY,UAAjB,EAA6B,OAAO,KAAP;AAC7B,MAAI,CAAC,YAAY,YAAjB,EAA+B,OAAO,KAAP;AAC/B,MAAI,CAAC,YAAY,YAAjB,EAA+B,OAAO,KAAP;AAC/B,QAAM,IAAI,UAAJ,CAAe,iDAAf,CAAN;AACF;AClFA;;;;;;SAIgB,yB,CAAgD,G,EAAQ;;;AAGpE,MAAK,GAAkB,CAAC,UAAnB,KAAkC,SAAvC,EAAkD;AAC9C,WAAQ,GAAD,CAAM,WAAb;AACH;;AACD,SAAO,yBAAyB,CAAC,GAAG,CAAC,CAAD,CAAJ,CAAhC;AACH;AAED;;;;;;;;SAMgB,gB,CAAiB,G,EAAsB,K,EAAiB,S,EAAkC;;AAEtG,MAAM,mBAAmB,GAAG,uBAAuB,CAAC,SAAD,EAAY,KAAZ,CAAnD;;AAFsG,8BAGrE,uBAAuB,CAAC,mBAAD,EAAsB,KAAtB,CAH8C;AAAA;AAAA,MAG/F,YAH+F;AAAA,MAGjF,QAHiF;;AAItG,MAAM,QAAQ,GAAG,iBAAiB,CAAC,GAAD,EAAM,KAAN,EAAa,YAAb,CAAlC;;AACA,SAAO,CAAC,QAAD,EAAW,QAAX,CAAP;AACH;;AAED,SAAS,iBAAT,CAAiD,GAAjD,EAAuE,KAAvE,EAAwF,SAAxF,EAA4H;AACxH,MAAM,YAAY,GAAG,SAAS,CAAC,CAAD,CAA9B,CADwH,C;;;;;;;;AAWxH,MAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;;AAElC,QAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,aAAO,GAAG,CAAC,YAAD,CAAV;AACH,KAFD,MAEO;AACH,aAAO,iBAAiB,CAAC,GAAG,CAAC,YAAD,CAAJ,EAAuC,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAvC,EAAuD,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAvD,CAAxB;AACH;AACJ;;AAlBuH,qCAmBnF,YAnBmF;AAAA,MAmBjH,IAnBiH;AAAA,MAmB3G,EAnB2G;AAAA,MAmBvG,IAnBuG;AAAA,MAmBjG,UAnBiG;;AAqBxH,MAAI,UAAU,KAAK,CAAnB,EAAsB;AAClB,WAAO,KAAK,yBAAyB,CAAC,GAAD,CAA9B,EAAqC,CAArC,CAAP;AACH;;AAED,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,QAAI,IAAI,KAAK,CAAb,EAAgB;AACZ,aAAQ,GAAkB,CAAC,KAAnB,CAAyB,IAAzB,EAA+B,EAA/B,CAAR;AACH;;AAED,QAAM,UAAU,GAAG,IAAK,GAAG,CAAC,WAAT,CAAkD,UAAlD,CAAnB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,MAAA,UAAU,CAAC,CAAD,CAAV,GAAiB,GAAkB,CAAC,IAAI,GAAG,CAAC,GAAG,IAAZ,CAAnC;AACH;;AACD,WAAO,UAAP;AACH;;AAED,MAAI,MAAM,GAAG,IAAI,KAAJ,CAAU,UAAV,CAAb;;AAEA,OAAK,IAAI,EAAC,GAAG,CAAb,EAAgB,EAAC,GAAG,UAApB,EAAgC,EAAC,EAAjC,EAAqC;AACjC,IAAA,MAAM,CAAC,EAAD,CAAN,GAAY,iBAAiB,CAAC,GAAG,CAAC,IAAI,GAAG,EAAC,GAAG,IAAZ,CAAJ,EAA0C,KAAK,CAAC,KAAN,CAAY,CAAZ,CAA1C,EAA0D,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAA1D,CAA7B;AACH,GAzCuH,C;;;;AA6CxH,MAAI,UAAU,GAAG,CAAb,IAAkB,OAAO,MAAM,CAAC,CAAD,CAAb,KAAqB,QAA3C,EAAqD;AACjD,QAAM,qBAAqB,GAAI,GAAG,CAAC,CAAD,CAAH,CAAsB,WAArD;AACA,IAAA,MAAM,GAAI,qBAA6B,CAAC,IAA9B,CAAmC,MAAnC,CAAV;AACH;;AAED,SAAO,MAAP;AACH;;SAKe,sB,CAAuB,M,EAAyB,K,EAAe,S,EAAqB,S,EAAkC;;AAElI,MAAM,mBAAmB,GAAG,uBAAuB,CAAC,SAAD,EAAY,SAAZ,EAAuB,IAAvB,CAAnD,CAFkI,C;;AAAA,+BAKhG,uBAAuB,CAAC,mBAAD,EAAsB,SAAtB,CALyE;AAAA;AAAA,MAK3H,YAL2H;AAAA,MAK7G,SAL6G;;AAMlI,EAAA,uBAAuB,CAAC,MAAD,EAAS,KAAT,EAAgB,SAAhB,EAA2B,YAA3B,CAAvB;AACH;;SAEe,c,CAAe,M,EAAyB,S,EAA4B,S,EAAqB,W,EAAuB,S,EAAkC;;AAE9J,MAAM,mBAAmB,GAAG,uBAAuB,CAAC,SAAD,EAAY,SAAZ,EAAuB,KAAvB,CAAnD;;AAF8J,+BAG7H,uBAAuB,CAAC,mBAAD,EAAsB,SAAtB,CAHsG;AAAA;AAAA,MAGvJ,YAHuJ;AAAA,MAGzI,QAHyI,8B;;;AAM9J,MAAI,IAAI,CAAC,SAAL,CAAe,QAAf,MAA6B,IAAI,CAAC,SAAL,CAAe,WAAf,CAAjC,EAA8D;AAC1D,UAAM,IAAI,UAAJ,4DAAmE,QAAnE,kBAAmF,WAAnF,EAAN;AACH;;AAED,EAAA,eAAe,CAAC,MAAD,EAAS,SAAT,EAAoB,SAApB,EAA+B,YAA/B,CAAf;AACH;;AAGD,SAAS,eAAT,CAAyB,MAAzB,EAAkD,SAAlD,EAAuF,KAAvF,EAAwG,SAAxG,EAA4I;AAExI,MAAM,YAAY,GAAG,SAAS,CAAC,CAAD,CAA9B;;AAEA,MAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,IAAA,uBAAuB,CAAC,MAAD,EAAS,SAAT,EAAoB,KAApB,EAA2B,SAAS,CAAC,GAAV,CAAc,UAAA,CAAC;AAAA,aAAI,OAAO,CAAP,KAAa,QAAb,GAAwB,CAAC,CAAD,EAAI,CAAC,GAAG,CAAR,EAAW,CAAX,EAAc,CAAd,CAAxB,GAA2C,CAA/C;AAAA,KAAf,CAA3B,CAAvB;;AACA;AACH,GAPuI,C;;;AAUxI,MAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AAClC,IAAA,eAAe,CAAE,MAA4B,CAAC,YAAD,CAA9B,EAA8C,SAA9C,EAAyD,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAzD,EAAyE,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAzE,CAAf;;AACA;AACH;;AAbuI,sCAelG,YAfkG;AAAA,MAejI,IAfiI;AAAA,MAe3H,GAf2H;AAAA,MAetH,IAfsH;AAAA,MAehH,UAfgH;;AAiBxI,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,QAAI,IAAI,KAAK,CAAb,EAAgB;AACX,MAAA,MAAqB,CAAC,GAAtB,CAA0B,SAA1B,EAAmD,IAAnD;AACJ,KAFD,MAEO;AACH,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,QAAA,MAAM,CAAC,IAAI,GAAG,CAAC,GAAG,IAAZ,CAAN,GAA2B,SAAD,CAAY,CAAZ,CAA1B;AACH;AACJ;;AACD;AACH;;AAED,OAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,UAApB,EAAgC,GAAC,EAAjC,EAAqC;AACjC,IAAA,eAAe,CAAE,MAA4B,CAAC,IAAI,GAAG,GAAC,GAAG,IAAZ,CAA9B,EAAkD,SAA+B,CAAC,GAAD,CAAjF,EAAsF,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAtF,EAAsG,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAtG,CAAf;AACH;AACJ;;AAED,SAAS,uBAAT,CAAiC,MAAjC,EAA0D,KAA1D,EAAyE,KAAzE,EAA0F,SAA1F,EAAmH;AAC/G,MAAM,YAAY,GAAG,SAAS,CAAC,CAAD,CAA9B;;AAD+G,sCAG1E,YAH0E;AAAA,MAGxG,IAHwG;AAAA,MAGlG,EAHkG;AAAA,MAG9F,IAH8F;AAAA,MAGxF,UAHwF;;AAK/G,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,QAAI,IAAI,KAAK,CAAb,EAAgB;AACX,MAAA,MAAqB,CAAC,IAAtB,CAA2B,KAA3B,EAAkC,IAAlC,EAAwC,EAAxC;AACJ,KAFD,MAEO;AACH,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,QAAA,MAAM,CAAC,IAAI,GAAG,CAAC,GAAG,IAAZ,CAAN,GAA0B,KAA1B;AACH;AACJ;;AACD;AACH;;AAED,OAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,UAApB,EAAgC,GAAC,EAAjC,EAAqC;AACjC,IAAA,uBAAuB,CAAE,MAA4B,CAAC,IAAI,GAAG,GAAC,GAAG,IAAZ,CAA9B,EAAiD,KAAjD,EAAwD,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAxD,EAAwE,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAxE,CAAvB;AACH;AACJ;;SAEe,kB,CAAmB,G,EAAsB,K,EAAiB,M,EAA0C;AAChH,MAAI,MAAM,KAAK,SAAf,EAA0B;AACtB,IAAA,MAAM,GAAG,yBAAyB,CAAC,GAAD,CAAlC;AACH;;AACD,MAAM,IAAI,GAAG,KAAK,CAAC,MAAN,CAAa,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,GAAG,CAAd;AAAA,GAAb,EAA8B,CAA9B,CAAb;AACA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,IAAX,CAAf;;AAEA,EAAA,mBAAmB,CAAC,GAAD,EAAM,KAAN,EAAa,MAAb,EAAqB,CAArB,CAAnB;;AAEA,SAAO,MAAP;AACH;;AAED,SAAS,mBAAT,CAA6B,GAA7B,EAAmD,KAAnD,EAAoE,MAApE,EAAwF,MAAxF,EAAsG;AAClG,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;;;AAGpB,IAAA,MAAM,CAAC,GAAP,CAAY,GAAZ,EAAgC,MAAhC;AACA;AACH;;AAED,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,CAAD,CAAzB,EAA8B,CAAC,EAA/B,EAAmC;AAC/B,MAAA,MAAM,CAAC,GAAP,CAAY,GAAoB,CAAC,CAAD,CAAhC,EAAqC,MAAM,GAAG,KAAK,CAAC,CAAD,CAAL,GAAW,CAAzD;AACH;;AACD,WAAO,GAAP;AACH;;AAED,MAAM,SAAS,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAlB,CAfkG,C;;AAiBlG,MAAM,IAAI,GAAG,SAAS,CAAC,MAAV,CAAiB,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,GAAG,CAAd;AAAA,GAAjB,EAAkC,CAAlC,CAAb;;AAEA,OAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,KAAK,CAAC,CAAD,CAAzB,EAA8B,GAAC,EAA/B,EAAmC;AAC/B,IAAA,mBAAmB,CAAE,GAAyB,CAAC,GAAD,CAA3B,EAAgC,SAAhC,EAA2C,MAA3C,EAAmD,MAAM,GAAG,IAAI,GAAG,GAAnE,CAAnB;AACH;;AACD,SAAO,GAAP;AACJ;;IChMa,W;AAOT,uBAAY,IAAZ,EAA8E,KAA9E,EAAyG,KAAzG,EAA4H;AAAA;;AACxH,QAAM,gBAAgB,GAAG,IAAI,KAAK,IAAT,IAAiB,CAAC,CAAE,IAAmB,CAAC,iBAAjE;;AAEA,QAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,UAAI,CAAC,gBAAL,EAAuB;AACnB,cAAM,IAAI,UAAJ,CAAe,4DAAf,CAAN;AACH;;AACD,MAAA,KAAK,GAAG,CAAE,IAAmB,CAAC,MAAtB,CAAR;AACH;;AAED,QAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,UAAI,CAAC,gBAAL,EAAuB;AACnB,cAAM,IAAI,UAAJ,CAAe,4DAAf,CAAN;AACH;;AACD,MAAA,KAAK,GAAG,wBAAwB,CAAC,IAAD,CAAhC;AACH;;AAED,IAAA,KAAK,GAAG,cAAc,CAAC,KAAD,CAAtB;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,KAAL,GAAa,KAAb;;AAEA,QAAI,gBAAgB,IAAI,KAAK,CAAC,MAAN,KAAiB,CAAzC,EAA4C;AACxC,MAAA,IAAI,GAAI,IAAmB,CAAC,MAA5B;AACH,KAvBuH,C;;;AA0BxH,QAAI,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA1B,EAA6B;AACzB,WAAK,IAAL,GAAY,KAAK,gBAAgB,CAAC,KAAD,CAArB,EAA8B,CAA9B,CAAZ;AACH,KAFD,MAGK,K;AAEA,IAAA,OAAO,IAAI,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAZ,IACG,IAAI,YAAY,WADnB,IAEG,IAAI,KAAK,IAFZ,IAGG,IAAI,CAAC,QAAL,GAAgB,UAAhB,CAA2B,sBAA3B,CALF,CAKoD;AALpD,MAMH;;AAEE,UAAM,gBAAgB,GAAG,KAAK,CAAC,MAAN,CAAa,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,CAAC,GAAG,CAAd;AAAA,OAAb,EAA8B,CAA9B,CAAzB;;AAEA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACf,QAAA,IAAI,GAAG,IAAI,WAAJ,CAAgB,gBAAgB,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAN,EAA0B,EAA1B,CAA3C,CAAP;AACH;;AAED,UAAM,eAAe,GAAI,IAAoB,CAAC,UAArB,GAAkC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAN,EAA0B,EAA1B,CAAnE;;AACA,UAAI,gBAAgB,KAAK,eAAzB,EAA0C;AACtC,cAAM,IAAI,KAAJ,sBAAwB,eAAxB,uBAAoD,KAApD,2CAA0F,KAA1F,oBAAyG,gBAAzG,OAAN;AACH;;AACD,UAAM,eAAe,GAAsC,gBAAgB,CAAC,KAAD,CAA3E;AACA,WAAK,IAAL,GAAY,iBAAiB,CAAE,IAAF,EAAwB,eAAxB,EAAyC,KAAzC,CAA7B;AACH,KApBI,MAoBE;AACH,WAAK,IAAL,GAAY,IAAZ;AACH;AACJ;;;;wBAIU,S,EAAyB;AAAA,+BACA,gBAAgB,CAAC,KAAK,IAAN,EAAY,KAAK,KAAjB,EAAwB,SAAxB,CADhB;AAAA;AAAA,UACzB,WADyB;AAAA,UACZ,QADY;;AAEhC,UAAI,QAAQ,CAAC,MAAT,KAAoB,CAAxB,EAA2B;AACvB,eAAO,WAAP;AACH,OAFD,MAEO;AACH,eAAO,IAAI,WAAJ,CAAgB,WAAhB,EAAgD,QAAhD,EAA0D,KAAK,KAA/D,CAAP;AACH;AACJ;;;0BAE0E;AAAA,UAAhE,SAAgE,uEAApC,IAAoC;AAAA,UAA9B,KAA8B;;AACvE,UAAI,SAAS,KAAK,IAAlB,EAAwB;AACpB,QAAA,SAAS,GAAG,CAAC,KAAK,CAAC,IAAD,CAAN,CAAZ;AACH;;AACD,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,YAAI,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA1B,EAA6B;;AAEzB,eAAK,IAAL,CAAU,CAAV,IAAe,KAAf;AACH,SAHD,MAGO;AACH,UAAA,sBAAsB,CAAC,KAAK,IAAN,EAAY,KAAZ,EAAmB,KAAK,KAAxB,EAA+B,SAA/B,CAAtB;AACH;AACJ,OAPD,MAOO;AACH,QAAA,cAAc,CAAC,KAAK,IAAN,EAAY,KAAK,CAAC,IAAlB,EAAwB,KAAK,KAA7B,EAAoC,KAAK,CAAC,KAA1C,EAAiD,SAAjD,CAAd;AACH;AACJ;;;8BAEa;AACV,UAAI,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA1B,EAA6B;AACzB,eAAO,KAAK,IAAZ;AACH;;AACD,aAAO,kBAAkB,CAAC,KAAK,IAAN,EAAY,KAAK,KAAjB,EAAwB,gBAAgB,CAAC,KAAK,KAAN,CAAxC,CAAzB;AACH;;;;;;;2BAKoB,I,EAAwC;AAAA,UAA1B,KAA0B,uEAAL,KAAK;AACzD,UAAM,MAAM,GAAG,gBAAgB,CAAC,KAAD,CAA/B;AACA,UAAM,IAAI,GAAG,eAAe,CAAC,CAAC,IAAD,CAAD,EAAS,MAAT,CAA5B;AACA,aAAO,IAAI,WAAJ,CAAgB,IAAhB,EAAsB,CAAC,IAAD,CAAtB,EAA8B,KAA9B,CAAP;AACH;;;;;AAKL;;;;;SAGgB,e,CAAsC,K,EAAiB,W,EAAqC;AACxG,MAAM,IAAI,GAAG,KAAK,CAAC,MAAN,CAAa,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,GAAG,CAAd;AAAA,GAAb,EAA8B,CAA9B,CAAb;AACA,MAAM,IAAI,GAAG,IAAI,WAAJ,CAAgB,IAAhB,CAAb;AACA,EAAA,IAAI,CAAC,GAAL,oBAAa,KAAK,CAAC,IAAD,CAAL,CAAY,IAAZ,EAAb,GAHwG,CAGtE;;AAClC,SAAO,IAAP;AACH;AAED;;;;;;;;;;;SASgB,iB,CAAwC,I,EAA4B,C,EAA6B,K,EAA2B;AAAA,MAAV,MAAU,uEAAD,CAAC;;AACxI,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;;;AAGpB,WAAO,IAAI,CAAJ,CAAM,IAAI,CAAC,KAAL,CAAW,MAAX,EAAmB,MAAM,GAAG,KAAK,CAAC,CAAD,CAAL,GAAW,CAAC,CAAC,iBAAzC,CAAN,CAAP;AACH;;AAED,MAAM,GAAG,GAAG,IAAI,KAAJ,CAAe,KAAK,CAAC,CAAD,CAApB,CAAZ;;AACA,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,CAAD,CAAzB,EAA8B,CAAC,EAA/B,EAAmC;AAC/B,MAAA,GAAG,CAAC,CAAD,CAAH,GAAS,IAAI,CAAJ,CAAM,IAAI,CAAC,KAAL,CAAW,MAAM,GAAG,KAAK,CAAC,CAAD,CAAL,GAAW,CAAX,GAAe,CAAC,CAAC,iBAArC,EAAwD,MAAM,GAAG,KAAK,CAAC,CAAD,CAAL,IAAY,CAAC,GAAG,CAAhB,IAAqB,CAAC,CAAC,iBAAxF,CAAN,CAAT;AACH;;AACD,WAAO,GAAP;AACH;;AAED,MAAM,SAAS,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAlB,CAfwI,C;;AAiBxI,MAAM,IAAI,GAAG,SAAS,CAAC,MAAV,CAAiB,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,GAAG,CAAd;AAAA,GAAjB,EAAkC,CAAlC,CAAb;;AAEA,OAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,KAAK,CAAC,CAAD,CAAzB,EAA8B,GAAC,EAA/B,EAAmC;AAC/B,IAAA,GAAG,CAAC,GAAD,CAAH,GAAS,iBAAiB,CAAC,IAAD,EAAO,CAAP,EAAU,SAAV,EAAqB,MAAM,GAAG,IAAI,GAAG,GAAP,GAAW,CAAC,CAAC,iBAA3C,CAA1B;AACH;;AACD,SAAO,GAAP;AACJ;;SCxJgB,mB,CAAoB,M,EAAoB,U,EAAsB,Q,EAAoB,Y,EAAuC,K,EAAa;;AAElJ,MAAM,mBAAmB,GAAG,uBAAuB,CAAC,YAAD,EAAe,QAAf,EAAyB,IAAzB,CAAnD;;AAFkJ,+BAG3H,uBAAuB,CAAC,mBAAD,EAAsB,QAAtB,CAHoG;AAAA;AAAA,MAG3I,YAH2I,8B;;;AAKlJ,EAAA,oBAAoB,CAAC,KAAD,EAAQ,MAAR,EAAgB,UAAhB,EAA4B,YAA5B,CAApB;AACH;;SAEe,W,CAAY,M,EAAoB,U,EAAsB,Q,EAAoB,Y,EAAuC,S,EAAuB,a,EAAyB,W,EAAqB;;AAElM,MAAM,sBAAsB,GAAG,uBAAuB,CAAC,YAAD,EAAe,QAAf,EAAyB,KAAzB,CAAtD;;AAFkM,+BAG9J,uBAAuB,CAAC,sBAAD,EAAyB,QAAzB,CAHuI;AAAA;AAAA,MAG3L,eAH2L;AAAA,MAG1K,QAH0K,+B;;;AAMlM,MAAI,IAAI,CAAC,SAAL,CAAe,QAAf,MAA6B,IAAI,CAAC,SAAL,CAAe,WAAf,CAAjC,EAA8D;AAC1D,UAAM,IAAI,UAAJ,yDAAgE,QAAhE,kBAAgF,WAAhF,EAAN;AACH;;AAED,EAAA,YAAY,CAAC,MAAD,EAAS,UAAT,EAAqB,eAArB,EAAsC,SAAtC,EAAiD,aAAjD,CAAZ;AACH;;SAEe,wB,CAAyB,M,EAAoB,U,EAAsB,Q,EAAoB,Y,EAAuC,S,EAAuB,a,EAAyB,W,EAAuB,e,EAAwC;;AAEzP,MAAM,sBAAsB,GAAG,uBAAuB,CAAC,YAAD,EAAe,QAAf,EAAyB,IAAzB,CAAtD,CAFyP,C;;AAAA,gCAI/N,uBAAuB,CAAC,sBAAD,EAAyB,QAAzB,CAJwM;AAAA;AAAA,MAIlP,eAJkP;;AAMzP,MAAM,yBAAyB,GAAG,uBAAuB,CAAC,eAAD,EAAkB,WAAlB,EAA+B,KAA/B,CAAzD;;AANyP,gCAO3N,uBAAuB,CAAC,yBAAD,EAA4B,WAA5B,CAPoM;AAAA;AAAA,MAOlP,mBAPkP,+B;;;;AAYzP,EAAA,yBAAyB,CAAC,MAAD,EAAS,UAAT,EAAqB,eAArB,EAAwD,SAAxD,EAAmE,aAAnE,EAAkF,mBAAlF,CAAzB;AACH;;AAED,SAAS,oBAAT,CAA8B,KAA9B,EAA6C,MAA7C,EAAiE,UAAjE,EAAuF,eAAvF,EAAsH;AAAA,kCAChE,eADgE;AAAA,MAC3G,eAD2G;AAAA,MACvF,mBADuF;;AAAA,6BAEpE,UAFoE;AAAA,MAE3G,gBAF2G;AAAA,MAEtF,cAFsF;;AAAA,wCAI5E,eAJ4E;AAAA,MAI3G,IAJ2G;AAAA,MAIrG,GAJqG;AAAA,MAIhG,IAJgG;AAAA,MAI1F,UAJ0F;;AAMlH,MAAI,UAAU,CAAC,MAAX,KAAsB,CAA1B,EAA6B;AACzB,QAAI,IAAI,KAAK,CAAT,IAAc,gBAAgB,KAAK,CAAvC,EAA0C;AACtC,MAAA,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,IAAnB,EAAyB,IAAI,GAAG,UAAhC;AACH,KAFD,MAEO;AACH,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,QAAA,MAAM,CAAC,gBAAgB,IAAI,IAAI,GAAI,IAAI,GAAG,CAAnB,CAAjB,CAAN,GAAiD,KAAjD;AACH;AACJ;;AACD;AACH;;AAED,OAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,UAApB,EAAgC,GAAC,EAAjC,EAAqC;AACjC,IAAA,oBAAoB,CAChB,KADgB,EAEhB,MAAM,CAAC,QAAP,CAAgB,gBAAgB,IAAI,IAAI,GAAI,IAAI,GAAG,GAAnB,CAAhC,CAFgB,EAGhB,cAHgB,EAIhB,mBAJgB,CAApB;AAMH;AACJ;;AAED,SAAS,YAAT,CAAsB,MAAtB,EAA0C,UAA1C,EAAgE,eAAhE,EAA4G,SAA5G,EAAmI,aAAnI,EAA0J;AACtJ,MAAI,eAAe,CAAC,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B,IAAA,MAAM,CAAC,GAAP,CAAW,SAAX;AACA;AACH;;AAJqJ,mCAMpG,eANoG;AAAA,MAM/I,eAN+I;AAAA,MAM3H,mBAN2H;;AAAA,8BAOxG,UAPwG;AAAA,MAO/I,gBAP+I;AAAA,MAO1H,cAP0H,0B;;;AAUtJ,MAAI,OAAO,eAAP,KAA2B,QAA/B,EAAyC;AACrC,IAAA,YAAY,CACR,MAAM,CAAC,QAAP,CAAgB,eAAe,GAAG,gBAAlC,CADQ,EAER,cAFQ,EAGR,mBAHQ,EAIR,SAJQ,EAKR,aALQ,CAAZ;;AAOA;AACH;;AAnBqJ,gCAqBlG,aArBkG;AAAA,MAqB/I,mBArB+I;AAAA,MAqBvH,iBArBuH;;AAAA,yCAsBhH,eAtBgH;AAAA,MAsB/I,IAtB+I;AAAA,MAsBzI,GAtByI;AAAA,MAsBpI,IAtBoI;AAAA,MAsB9H,UAtB8H;;AAwBtJ,MAAI,UAAU,CAAC,MAAX,KAAsB,CAA1B,EAA6B;AACzB,QAAI,IAAI,KAAK,CAAT,IAAc,gBAAgB,KAAK,CAAnC,IAAwC,mBAAmB,KAAK,CAApE,EAAuE;AACnE,MAAA,MAAM,CAAC,GAAP,CAAW,SAAS,CAAC,QAAV,CAAmB,CAAnB,EAAsB,UAAtB,CAAX,EAA8C,IAA9C;AACH,KAFD,MAEO;AACH,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,QAAA,MAAM,CAAC,gBAAgB,IAAI,IAAI,GAAI,IAAI,GAAG,CAAnB,CAAjB,CAAN,GAAiD,SAAS,CAAC,mBAAmB,GAAG,CAAvB,CAA1D;AACH;AACJ;;AACD;AACH;;AAED,OAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,UAApB,EAAgC,GAAC,EAAjC,EAAqC;;AAEjC,IAAA,YAAY,CACR,MAAM,CAAC,QAAP,CAAgB,gBAAgB,IAAI,IAAI,GAAI,GAAC,GAAG,IAAhB,CAAhC,CADQ,EAER,cAFQ,EAGR,mBAHQ,EAIR,SAAS,CAAC,QAAV,CAAmB,mBAAmB,GAAG,GAAzC,CAJQ,EAKR,iBALQ,CAAZ;AAOH;AACJ;;AAED,SAAS,yBAAT,CAAmC,MAAnC,EAAuD,UAAvD,EAA6E,eAA7E,EAA8G,SAA9G,EAAqI,aAArI,EAA8J,kBAA9J,EAA2M;AACvM,MAAI,kBAAkB,CAAC,MAAnB,KAA8B,CAAlC,EAAqC;;AAEjC,IAAA,MAAM,CAAC,GAAP,CAAW,SAAS,CAAC,QAAV,CAAmB,CAAnB,EAAsB,MAAM,CAAC,MAA7B,CAAX;AACA;AACH,GALsM,C;;;AAAA,mCAQrJ,eARqJ;AAAA,MAQhM,eARgM;AAAA,MAQ5K,mBAR4K;;AAAA,qCAS/I,kBAT+I;AAAA,MAShM,kBATgM;AAAA,MASzK,sBATyK;;AAAA,8BAWzJ,UAXyJ;AAAA,MAWhM,gBAXgM;AAAA,MAW3K,cAX2K;;AAAA,iCAYnJ,aAZmJ;AAAA,MAYhM,mBAZgM;AAAA,MAYxK,iBAZwK,6B;;;AAevM,MAAI,OAAO,kBAAP,KAA8B,QAAlC,EAA4C;;;;;;;AAUxC,IAAA,yBAAyB,E;AAErB,IAAA,MAFqB,EAEb,UAFa,EAED,eAFC,EAGrB,SAAS,CAAC,QAAV,CAAmB,mBAAmB,GAAG,kBAAzC,CAHqB,EAIrB,iBAJqB,EAKrB,sBALqB,CAAzB;;AAOA;AACH;;AAjCsM,yCAmCjK,eAnCiK;AAAA,MAmChM,IAnCgM;AAAA,MAmC1L,GAnC0L;AAAA,MAmCrL,IAnCqL;AAAA,MAmC/K,UAnC+K,yBAmCjJ;;;AAnCiJ,2CAoC5J,kBApC4J;AAAA,MAoChM,KApCgM;AAAA,MAoCzL,IApCyL;AAAA,MAoCnL,KApCmL;AAAA,MAoC5K,YApC4K,2BAoCzI;;;AAE9D,MAAI,UAAU,CAAC,MAAX,KAAsB,CAAtB,IAA2B,aAAa,CAAC,MAAd,KAAyB,CAAxD,EAA2D;AACvD,QAAI,IAAI,KAAK,CAAT,IAAc,gBAAgB,KAAK,CAAnC,IAAwC,KAAK,KAAK,CAAlD,IAAuD,mBAAmB,KAAK,CAAnF,EAAsF;AAClF,MAAA,MAAM,CAAC,GAAP,CAAW,SAAS,CAAC,QAAV,CAAmB,KAAnB,EAA0B,KAAK,GAAG,UAAlC,CAAX,EAA0D,IAA1D;AACH,KAFD,MAEO;AACH,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,QAAA,MAAM,CAAC,gBAAgB,IAAI,IAAI,GAAI,IAAI,GAAG,CAAnB,CAAjB,CAAN,GAAiD,SAAS,CAAC,mBAAmB,IAAI,KAAK,GAAI,KAAK,GAAG,CAArB,CAApB,CAA1D;AACH;AACJ;;AACD;AACH;;AAED,OAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,UAApB,EAAgC,GAAC,EAAjC,EAAqC;;AAEjC,IAAA,yBAAyB,CACrB,MAAM,CAAC,QAAP,CAAgB,gBAAgB,IAAI,IAAI,GAAI,GAAC,GAAG,IAAhB,CAAhC,CADqB,EAErB,cAFqB,EAGrB,mBAHqB,EAIrB,SAAS,CAAC,QAAV,CAAmB,mBAAmB,IAAI,KAAK,GAAI,GAAC,GAAG,KAAjB,CAAtC,CAJqB,EAKrB,iBALqB,EAMrB,sBANqB,CAAzB;AAQH;AACL;;ICvKa,Q;AAQT,oBAAY,IAAZ,EAA4D,KAA5D,EAAuF,KAAvF,EAA4G,OAA5G,EAA8H;AAAA;;AAC1H,QAAM,gBAAgB,GAAG,IAAI,KAAK,IAAT,IAAiB,CAAC,CAAE,IAAmB,CAAC,iBAAjE;;AAEA,QAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,UAAI,CAAC,gBAAL,EAAuB;AACnB,cAAM,IAAI,UAAJ,CAAe,4DAAf,CAAN;AACH;;AACD,MAAA,KAAK,GAAG,CAAE,IAAmB,CAAC,MAAtB,CAAR;AACH;;AACD,IAAA,KAAK,GAAG,cAAc,CAAC,KAAD,CAAtB;;AAEA,QAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,UAAI,CAAC,gBAAL,EAAuB;AACnB,cAAM,IAAI,UAAJ,CAAe,4DAAf,CAAN;AACH;;AACD,MAAA,KAAK,GAAG,wBAAwB,CAAC,IAAD,CAAhC;AACH;;AAED,QAAI,OAAO,KAAK,SAAhB,EAA2B;AACvB,MAAA,OAAO,GAAG,UAAU,CAAC,KAAD,CAApB;AACH;;AAED,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,OAAL,GAAe,OAAf;;AAEA,QAAI,gBAAgB,IAAI,KAAK,CAAC,MAAN,KAAiB,CAAzC,EAA4C;AACxC,MAAA,IAAI,GAAI,IAAmB,CAAC,MAA5B;AACH,KA5ByH,C;;;AA+B1H,QAAI,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA1B,EAA6B;AACzB,WAAK,IAAL,GAAY,KAAK,gBAAgB,CAAC,KAAD,CAArB,EAA8B,CAA9B,CAAZ;AACH,KAFD,MAEO,K;AAEF,IAAA,OAAO,IAAI,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAZ,IACG,IAAI,YAAY,WADnB,IAEG,IAAI,KAAK,IAFZ,IAGG,IAAI,CAAC,QAAL,GAAgB,UAAhB,CAA2B,sBAA3B,CALA,CAKkD;AALlD,MAML;;AAEE,UAAM,gBAAgB,GAAG,KAAK,CAAC,MAAN,CAAa,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,CAAC,GAAG,CAAd;AAAA,OAAb,EAA8B,CAA9B,CAAzB;;AAEA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACf,QAAA,IAAI,GAAG,IAAI,WAAJ,CAAgB,gBAAgB,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAN,EAA0B,EAA1B,CAA3C,CAAP;AACH;;AAED,UAAM,eAAe,GAAI,IAAoB,CAAC,UAArB,GAAkC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAN,EAA0B,EAA1B,CAAnE;;AACA,UAAI,gBAAgB,KAAK,eAAzB,EAA0C;AACtC,cAAM,IAAI,KAAJ,sBAAwB,eAAxB,uBAAoD,KAApD,2CAA0F,KAA1F,oBAAyG,gBAAzG,OAAN;AACH;;AACD,UAAM,eAAe,GAAsC,gBAAgB,CAAC,KAAD,CAA3E;AACA,WAAK,IAAL,GAAY,IAAI,eAAJ,CAAoB,IAApB,CAAZ;AACH,KApBM,MAoBA;AACH,WAAK,IAAL,GAAY,IAAZ;AACH;AACJ;;;;0BAIqG;AAAA,UAA3F,SAA2F,uEAA/D,IAA+D;AAAA,UAAzD,KAAyD;AAAA,UAA/B,cAA+B;;AAClG,UAAI,SAAS,KAAK,IAAlB,EAAwB;AACpB,QAAA,SAAS,GAAG,CAAC,KAAK,CAAC,IAAD,CAAN,CAAZ;AACH;;AACD,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,YAAI,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA1B,EAA6B;;AAEzB,eAAK,IAAL,CAAU,CAAV,IAAe,KAAf;AACH,SAHD,MAGO;AACH,UAAA,mBAAmB,CAAC,KAAK,IAAN,EAAY,KAAK,OAAjB,EAA0B,KAAK,KAA/B,EAAsC,SAAtC,EAAiD,KAAjD,CAAnB;AACH;AACJ,OAPD,MAOO,IAAI,KAAK,YAAY,QAAjB,IAA6B,cAAjC,EAAiD;;AAEpD,QAAA,wBAAwB,CAAC,KAAK,IAAN,EAAY,KAAK,OAAjB,EAA0B,KAAK,KAA/B,EAAsC,SAAtC,EAAiD,KAAK,CAAC,IAAvD,EAA6D,KAAK,CAAC,OAAnE,EAA4E,KAAK,CAAC,KAAlF,EAAyF,cAAzF,CAAxB;AACH,OAHM,MAGA;AACH,QAAA,WAAW,CAAC,KAAK,IAAN,EAAY,KAAK,OAAjB,EAA0B,KAAK,KAA/B,EAAsC,SAAtC,EAAiD,KAAK,CAAC,IAAvD,EAA6D,KAAK,CAAC,OAAnE,EAA4E,KAAK,CAAC,KAAlF,CAAX;AACH;AACJ;;;;;;;;;;;;;;AC3FL,MAAI,GAAG,GAAG,MAAM,CAAC,SAAP,CAAiB,cAA3B;AAAA,MACI,MAAM,GAAG,GADb;AAGA;;;;;;;;AAOA,WAAS,MAAT,GAAkB,CAAE,C,CAEpB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAI,MAAM,CAAC,MAAX,EAAmB;AACjB,IAAA,MAAM,CAAC,SAAP,GAAmB,MAAM,CAAC,MAAP,CAAc,IAAd,CAAnB,CADiB,CAGnB;AACA;AACA;AACA;;AACE,QAAI,CAAC,IAAI,MAAJ,GAAa,SAAlB,EAA6B,MAAM,GAAG,KAAT;AAC9B;AAED;;;;;;;;;;;AASA,WAAS,EAAT,CAAY,EAAZ,EAAgB,OAAhB,EAAyB,IAAzB,EAA+B;AAC7B,SAAK,EAAL,GAAU,EAAV;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,IAAL,GAAY,IAAI,IAAI,KAApB;AACD;AAED;;;;;;;;;;;;;AAWA,WAAS,WAAT,CAAqB,OAArB,EAA8B,KAA9B,EAAqC,EAArC,EAAyC,OAAzC,EAAkD,IAAlD,EAAwD;AACtD,QAAI,OAAO,EAAP,KAAc,UAAlB,EAA8B;AAC5B,YAAM,IAAI,SAAJ,CAAc,iCAAd,CAAN;AACD;;AAED,QAAI,QAAQ,GAAG,IAAI,EAAJ,CAAO,EAAP,EAAW,OAAO,IAAI,OAAtB,EAA+B,IAA/B,CAAf;AAAA,QACI,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,KAAZ,GAAoB,KADpC;AAGA,QAAI,CAAC,OAAO,CAAC,OAAR,CAAgB,GAAhB,CAAL,EAA2B,OAAO,CAAC,OAAR,CAAgB,GAAhB,IAAuB,QAAvB,EAAiC,OAAO,CAAC,YAAR,EAAjC,CAA3B,KACK,IAAI,CAAC,OAAO,CAAC,OAAR,CAAgB,GAAhB,EAAqB,EAA1B,EAA8B,OAAO,CAAC,OAAR,CAAgB,GAAhB,EAAqB,IAArB,CAA0B,QAA1B,EAA9B,KACA,OAAO,CAAC,OAAR,CAAgB,GAAhB,IAAuB,CAAC,OAAO,CAAC,OAAR,CAAgB,GAAhB,CAAD,EAAuB,QAAvB,CAAvB;AAEL,WAAO,OAAP;AACD;AAED;;;;;;;;;AAOA,WAAS,UAAT,CAAoB,OAApB,EAA6B,GAA7B,EAAkC;AAChC,QAAI,EAAE,OAAO,CAAC,YAAV,KAA2B,CAA/B,EAAkC,OAAO,CAAC,OAAR,GAAkB,IAAI,MAAJ,EAAlB,CAAlC,KACK,OAAO,OAAO,CAAC,OAAR,CAAgB,GAAhB,CAAP;AACN;AAED;;;;;;;;;AAOA,WAAS,YAAT,GAAwB;AACtB,SAAK,OAAL,GAAe,IAAI,MAAJ,EAAf;AACA,SAAK,YAAL,GAAoB,CAApB;AACD;AAED;;;;;;;;;AAOA,EAAA,YAAY,CAAC,SAAb,CAAuB,UAAvB,GAAoC,SAAS,UAAT,GAAsB;AACxD,QAAI,KAAK,GAAG,EAAZ;AAAA,QACI,MADJ;AAAA,QAEI,IAFJ;AAIA,QAAI,KAAK,YAAL,KAAsB,CAA1B,EAA6B,OAAO,KAAP;;AAE7B,SAAK,IAAL,IAAc,MAAM,GAAG,KAAK,OAA5B,EAAsC;AACpC,UAAI,GAAG,CAAC,IAAJ,CAAS,MAAT,EAAiB,IAAjB,CAAJ,EAA4B,KAAK,CAAC,IAAN,CAAW,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,CAAH,GAAmB,IAApC;AAC7B;;AAED,QAAI,MAAM,CAAC,qBAAX,EAAkC;AAChC,aAAO,KAAK,CAAC,MAAN,CAAa,MAAM,CAAC,qBAAP,CAA6B,MAA7B,CAAb,CAAP;AACD;;AAED,WAAO,KAAP;AACD,GAhBD;AAkBA;;;;;;;;;AAOA,EAAA,YAAY,CAAC,SAAb,CAAuB,SAAvB,GAAmC,SAAS,SAAT,CAAmB,KAAnB,EAA0B;AAC3D,QAAI,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,KAAZ,GAAoB,KAApC;AAAA,QACI,QAAQ,GAAG,KAAK,OAAL,CAAa,GAAb,CADf;AAGA,QAAI,CAAC,QAAL,EAAe,OAAO,EAAP;AACf,QAAI,QAAQ,CAAC,EAAb,EAAiB,OAAO,CAAC,QAAQ,CAAC,EAAV,CAAP;;AAEjB,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,QAAQ,CAAC,MAAxB,EAAgC,EAAE,GAAG,IAAI,KAAJ,CAAU,CAAV,CAA1C,EAAwD,CAAC,GAAG,CAA5D,EAA+D,CAAC,EAAhE,EAAoE;AAClE,MAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,QAAQ,CAAC,CAAD,CAAR,CAAY,EAApB;AACD;;AAED,WAAO,EAAP;AACD,GAZD;AAcA;;;;;;;;;AAOA,EAAA,YAAY,CAAC,SAAb,CAAuB,aAAvB,GAAuC,SAAS,aAAT,CAAuB,KAAvB,EAA8B;AACnE,QAAI,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,KAAZ,GAAoB,KAApC;AAAA,QACI,SAAS,GAAG,KAAK,OAAL,CAAa,GAAb,CADhB;AAGA,QAAI,CAAC,SAAL,EAAgB,OAAO,CAAP;AAChB,QAAI,SAAS,CAAC,EAAd,EAAkB,OAAO,CAAP;AAClB,WAAO,SAAS,CAAC,MAAjB;AACD,GAPD;AASA;;;;;;;;;AAOA,EAAA,YAAY,CAAC,SAAb,CAAuB,IAAvB,GAA8B,SAAS,IAAT,CAAc,KAAd,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC,EAAqC,EAArC,EAAyC;AACrE,QAAI,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,KAAZ,GAAoB,KAApC;AAEA,QAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAL,EAAwB,OAAO,KAAP;AAExB,QAAI,SAAS,GAAG,KAAK,OAAL,CAAa,GAAb,CAAhB;AAAA,QACI,GAAG,GAAG,SAAS,CAAC,MADpB;AAAA,QAEI,IAFJ;AAAA,QAGI,CAHJ;;AAKA,QAAI,SAAS,CAAC,EAAd,EAAkB;AAChB,UAAI,SAAS,CAAC,IAAd,EAAoB,KAAK,cAAL,CAAoB,KAApB,EAA2B,SAAS,CAAC,EAArC,EAAyC,SAAzC,EAAoD,IAApD;;AAEpB,cAAQ,GAAR;AACE,aAAK,CAAL;AAAQ,iBAAO,SAAS,CAAC,EAAV,CAAa,IAAb,CAAkB,SAAS,CAAC,OAA5B,GAAsC,IAA7C;;AACR,aAAK,CAAL;AAAQ,iBAAO,SAAS,CAAC,EAAV,CAAa,IAAb,CAAkB,SAAS,CAAC,OAA5B,EAAqC,EAArC,GAA0C,IAAjD;;AACR,aAAK,CAAL;AAAQ,iBAAO,SAAS,CAAC,EAAV,CAAa,IAAb,CAAkB,SAAS,CAAC,OAA5B,EAAqC,EAArC,EAAyC,EAAzC,GAA8C,IAArD;;AACR,aAAK,CAAL;AAAQ,iBAAO,SAAS,CAAC,EAAV,CAAa,IAAb,CAAkB,SAAS,CAAC,OAA5B,EAAqC,EAArC,EAAyC,EAAzC,EAA6C,EAA7C,GAAkD,IAAzD;;AACR,aAAK,CAAL;AAAQ,iBAAO,SAAS,CAAC,EAAV,CAAa,IAAb,CAAkB,SAAS,CAAC,OAA5B,EAAqC,EAArC,EAAyC,EAAzC,EAA6C,EAA7C,EAAiD,EAAjD,GAAsD,IAA7D;;AACR,aAAK,CAAL;AAAQ,iBAAO,SAAS,CAAC,EAAV,CAAa,IAAb,CAAkB,SAAS,CAAC,OAA5B,EAAqC,EAArC,EAAyC,EAAzC,EAA6C,EAA7C,EAAiD,EAAjD,EAAqD,EAArD,GAA0D,IAAjE;AANV;;AASA,WAAK,CAAC,GAAG,CAAJ,EAAO,IAAI,GAAG,IAAI,KAAJ,CAAU,GAAG,GAAE,CAAf,CAAnB,EAAsC,CAAC,GAAG,GAA1C,EAA+C,CAAC,EAAhD,EAAoD;AAClD,QAAA,IAAI,CAAC,CAAC,GAAG,CAAL,CAAJ,GAAc,SAAS,CAAC,CAAD,CAAvB;AACD;;AAED,MAAA,SAAS,CAAC,EAAV,CAAa,KAAb,CAAmB,SAAS,CAAC,OAA7B,EAAsC,IAAtC;AACD,KAjBD,MAiBO;AACL,UAAI,MAAM,GAAG,SAAS,CAAC,MAAvB;AAAA,UACI,CADJ;;AAGA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,MAAhB,EAAwB,CAAC,EAAzB,EAA6B;AAC3B,YAAI,SAAS,CAAC,CAAD,CAAT,CAAa,IAAjB,EAAuB,KAAK,cAAL,CAAoB,KAApB,EAA2B,SAAS,CAAC,CAAD,CAAT,CAAa,EAAxC,EAA4C,SAA5C,EAAuD,IAAvD;;AAEvB,gBAAQ,GAAR;AACE,eAAK,CAAL;AAAQ,YAAA,SAAS,CAAC,CAAD,CAAT,CAAa,EAAb,CAAgB,IAAhB,CAAqB,SAAS,CAAC,CAAD,CAAT,CAAa,OAAlC;AAA4C;;AACpD,eAAK,CAAL;AAAQ,YAAA,SAAS,CAAC,CAAD,CAAT,CAAa,EAAb,CAAgB,IAAhB,CAAqB,SAAS,CAAC,CAAD,CAAT,CAAa,OAAlC,EAA2C,EAA3C;AAAgD;;AACxD,eAAK,CAAL;AAAQ,YAAA,SAAS,CAAC,CAAD,CAAT,CAAa,EAAb,CAAgB,IAAhB,CAAqB,SAAS,CAAC,CAAD,CAAT,CAAa,OAAlC,EAA2C,EAA3C,EAA+C,EAA/C;AAAoD;;AAC5D,eAAK,CAAL;AAAQ,YAAA,SAAS,CAAC,CAAD,CAAT,CAAa,EAAb,CAAgB,IAAhB,CAAqB,SAAS,CAAC,CAAD,CAAT,CAAa,OAAlC,EAA2C,EAA3C,EAA+C,EAA/C,EAAmD,EAAnD;AAAwD;;AAChE;AACE,gBAAI,CAAC,IAAL,EAAW,KAAK,CAAC,GAAG,CAAJ,EAAO,IAAI,GAAG,IAAI,KAAJ,CAAU,GAAG,GAAE,CAAf,CAAnB,EAAsC,CAAC,GAAG,GAA1C,EAA+C,CAAC,EAAhD,EAAoD;AAC7D,cAAA,IAAI,CAAC,CAAC,GAAG,CAAL,CAAJ,GAAc,SAAS,CAAC,CAAD,CAAvB;AACD;AAED,YAAA,SAAS,CAAC,CAAD,CAAT,CAAa,EAAb,CAAgB,KAAhB,CAAsB,SAAS,CAAC,CAAD,CAAT,CAAa,OAAnC,EAA4C,IAA5C;AAVJ;AAYD;AACF;;AAED,WAAO,IAAP;AACD,GAlDD;AAoDA;;;;;;;;;;;AASA,EAAA,YAAY,CAAC,SAAb,CAAuB,EAAvB,GAA4B,SAAS,EAAT,CAAY,KAAZ,EAAmB,EAAnB,EAAuB,OAAvB,EAAgC;AAC1D,WAAO,WAAW,CAAC,IAAD,EAAO,KAAP,EAAc,EAAd,EAAkB,OAAlB,EAA2B,KAA3B,CAAlB;AACD,GAFD;AAIA;;;;;;;;;;;AASA,EAAA,YAAY,CAAC,SAAb,CAAuB,IAAvB,GAA8B,SAAS,IAAT,CAAc,KAAd,EAAqB,EAArB,EAAyB,OAAzB,EAAkC;AAC9D,WAAO,WAAW,CAAC,IAAD,EAAO,KAAP,EAAc,EAAd,EAAkB,OAAlB,EAA2B,IAA3B,CAAlB;AACD,GAFD;AAIA;;;;;;;;;;;;AAUA,EAAA,YAAY,CAAC,SAAb,CAAuB,cAAvB,GAAwC,SAAS,cAAT,CAAwB,KAAxB,EAA+B,EAA/B,EAAmC,OAAnC,EAA4C,IAA5C,EAAkD;AACxF,QAAI,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,KAAZ,GAAoB,KAApC;AAEA,QAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAL,EAAwB,OAAO,IAAP;;AACxB,QAAI,CAAC,EAAL,EAAS;AACP,MAAA,UAAU,CAAC,IAAD,EAAO,GAAP,CAAV;AACA,aAAO,IAAP;AACD;;AAED,QAAI,SAAS,GAAG,KAAK,OAAL,CAAa,GAAb,CAAhB;;AAEA,QAAI,SAAS,CAAC,EAAd,EAAkB;AAChB,UACE,SAAS,CAAC,EAAV,KAAiB,EAAjB,KACC,CAAC,IAAD,IAAS,SAAS,CAAC,IADpB,MAEC,CAAC,OAAD,IAAY,SAAS,CAAC,OAAV,KAAsB,OAFnC,CADF,EAIE;AACA,QAAA,UAAU,CAAC,IAAD,EAAO,GAAP,CAAV;AACD;AACF,KARD,MAQO;AACL,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,MAAM,GAAG,EAApB,EAAwB,MAAM,GAAG,SAAS,CAAC,MAAhD,EAAwD,CAAC,GAAG,MAA5D,EAAoE,CAAC,EAArE,EAAyE;AACvE,YACE,SAAS,CAAC,CAAD,CAAT,CAAa,EAAb,KAAoB,EAApB,IACC,IAAI,IAAI,CAAC,SAAS,CAAC,CAAD,CAAT,CAAa,IADvB,IAEC,OAAO,IAAI,SAAS,CAAC,CAAD,CAAT,CAAa,OAAb,KAAyB,OAHvC,EAIE;AACA,UAAA,MAAM,CAAC,IAAP,CAAY,SAAS,CAAC,CAAD,CAArB;AACD;AACF,OATI,CAWT;AACA;AACA;;;AACI,UAAI,MAAM,CAAC,MAAX,EAAmB,KAAK,OAAL,CAAa,GAAb,IAAoB,MAAM,CAAC,MAAP,KAAkB,CAAlB,GAAsB,MAAM,CAAC,CAAD,CAA5B,GAAkC,MAAtD,CAAnB,KACK,UAAU,CAAC,IAAD,EAAO,GAAP,CAAV;AACN;;AAED,WAAO,IAAP;AACD,GAtCD;AAwCA;;;;;;;;;AAOA,EAAA,YAAY,CAAC,SAAb,CAAuB,kBAAvB,GAA4C,SAAS,kBAAT,CAA4B,KAA5B,EAAmC;AAC7E,QAAI,GAAJ;;AAEA,QAAI,KAAJ,EAAW;AACT,MAAA,GAAG,GAAG,MAAM,GAAG,MAAM,GAAG,KAAZ,GAAoB,KAAhC;AACA,UAAI,KAAK,OAAL,CAAa,GAAb,CAAJ,EAAuB,UAAU,CAAC,IAAD,EAAO,GAAP,CAAV;AACxB,KAHD,MAGO;AACL,WAAK,OAAL,GAAe,IAAI,MAAJ,EAAf;AACA,WAAK,YAAL,GAAoB,CAApB;AACD;;AAED,WAAO,IAAP;AACD,GAZD,C,CAcA;AACA;AACA;;;AACA,EAAA,YAAY,CAAC,SAAb,CAAuB,GAAvB,GAA6B,YAAY,CAAC,SAAb,CAAuB,cAApD;AACA,EAAA,YAAY,CAAC,SAAb,CAAuB,WAAvB,GAAqC,YAAY,CAAC,SAAb,CAAuB,EAA5D,C,CAEA;AACA;AACA;;AACA,EAAA,YAAY,CAAC,QAAb,GAAwB,MAAxB,C,CAEA;AACA;AACA;;AACA,EAAA,YAAY,CAAC,YAAb,GAA4B,YAA5B,C,CAEA;AACA;AACA;;AACmC;AACjC,IAAA,MAAA,CAAA,OAAA,GAAiB,YAAjB;AACF;;;AC9UA,IAAA,QAAc,GAAG,SAAjB,QAAiB,CAAC,OAAD,EAAU,SAAV,EAAwB;AACxC,EAAA,SAAS,GAAG,SAAS,IAAK,YAAM,CAAE,CAAlC;;AAEA,SAAO,OAAO,CAAC,IAAR,CACN,UAAA,GAAG;AAAA,WAAI,IAAI,OAAJ,CAAY,UAAA,OAAO,EAAI;AAC7B,MAAA,OAAO,CAAC,SAAS,EAAV,CAAP;AACA,KAFM,EAEJ,IAFI,CAEC;AAAA,aAAM,GAAN;AAAA,KAFD,CAAJ;AAAA,GADG,EAIN,UAAA,GAAG;AAAA,WAAI,IAAI,OAAJ,CAAY,UAAA,OAAO,EAAI;AAC7B,MAAA,OAAO,CAAC,SAAS,EAAV,CAAP;AACA,KAFM,EAEJ,IAFI,CAEC,YAAM;AACb,YAAM,GAAN;AACA,KAJM,CAAJ;AAAA,GAJG,CAAP;AAUA,CAbD;;ICGM,Y;;;;;AACL,wBAAY,OAAZ,EAAqB;AAAA;;AAAA;;AACpB,kCAAM,OAAN;AACA,YAAK,IAAL,GAAY,cAAZ;AAFoB;AAGpB;;;iCAJyB,K;;AAO3B,IAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,OAAD,EAAU,YAAV,EAAwB,QAAxB;AAAA,SAAqC,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtF,QAAI,OAAO,YAAP,KAAwB,QAAxB,IAAoC,YAAY,GAAG,CAAvD,EAA0D;AACzD,YAAM,IAAI,SAAJ,CAAc,iDAAd,CAAN;AACA;;AAED,QAAI,YAAY,KAAK,QAArB,EAA+B;AAC9B,MAAA,OAAO,CAAC,OAAD,CAAP;AACA;AACA;;AAED,QAAM,KAAK,GAAG,UAAU,CAAC,YAAM;AAC9B,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AACnC,YAAI;AACH,UAAA,OAAO,CAAC,QAAQ,EAAT,CAAP;AACA,SAFD,CAEE,OAAO,KAAP,EAAc;AACf,UAAA,MAAM,CAAC,KAAD,CAAN;AACA;;AAED;AACA;;AAED,UAAM,OAAO,GAAG,OAAO,QAAP,KAAoB,QAApB,GAA+B,QAA/B,qCAAqE,YAArE,kBAAhB;AACA,UAAM,YAAY,GAAG,QAAQ,YAAY,KAApB,GAA4B,QAA5B,GAAuC,IAAI,YAAJ,CAAiB,OAAjB,CAA5D;;AAEA,UAAI,OAAO,OAAO,CAAC,MAAf,KAA0B,UAA9B,EAA0C;AACzC,QAAA,OAAO,CAAC,MAAR;AACA;;AAED,MAAA,MAAM,CAAC,YAAD,CAAN;AACA,KAnBuB,EAmBrB,YAnBqB,CAAxB,CAVsF,CA+BvF;;AACC,IAAA,QAAQ,EACT;AACE,IAAA,OAAO,CAAC,IAAR,CAAa,OAAb,EAAsB,MAAtB,CAFO,EAGP,YAAM;AACL,MAAA,YAAY,CAAC,KAAD,CAAZ;AACA,KALM,CAAR;AAOA,GAvCqD,CAArC;AAAA,CAAjB;;AAyCA,IAAA,UAAc,GAAG,QAAjB,C,CACA;;AACA,IAAA,UAAsB,GAAG,QAAzB;AAEA,IAAA,cAA2B,GAAG,YAA9B;;0CCtDA;AACA;;AACA,SAAS,UAAT,CAAoB,KAApB,EAA2B,KAA3B,EAAkC,UAAlC,EAA8C;AAC1C,MAAI,KAAK,GAAG,CAAZ;AACA,MAAI,KAAK,GAAG,KAAK,CAAC,MAAlB;;AACA,SAAO,KAAK,GAAG,CAAf,EAAkB;AACd,QAAM,IAAI,GAAI,KAAK,GAAG,CAAT,GAAc,CAA3B;AACA,QAAI,EAAE,GAAG,KAAK,GAAG,IAAjB;;AACA,QAAI,UAAU,CAAC,KAAK,CAAC,EAAD,CAAN,EAAY,KAAZ,CAAV,IAAgC,CAApC,EAAuC;AACnC,MAAA,KAAK,GAAG,EAAE,EAAV;AACA,MAAA,KAAK,IAAI,IAAI,GAAG,CAAhB;AACH,KAHD,MAIK;AACD,MAAA,KAAK,GAAG,IAAR;AACH;AACJ;;AACD,SAAO,KAAP;AACH;;AACD,IAAA,UAAe,GAAG,UAAlB;;;;;;;ICjBM,a;AACF,2BAAc;AAAA;;AACV,SAAK,MAAL,GAAc,EAAd;AACH;;;;4BACO,G,EAAK,O,EAAS;AAClB,MAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc;AAAE,QAAA,QAAQ,EAAE;AAAZ,OAAd,EAA+B,OAA/B,CAAV;AACA,UAAM,OAAO,GAAG;AACZ,QAAA,QAAQ,EAAE,OAAO,CAAC,QADN;AAEZ,QAAA,GAAG,EAAH;AAFY,OAAhB;;AAIA,UAAI,KAAK,IAAL,IAAa,KAAK,MAAL,CAAY,KAAK,IAAL,GAAY,CAAxB,EAA2B,QAA3B,IAAuC,OAAO,CAAC,QAAhE,EAA0E;AACtE,aAAK,MAAL,CAAY,IAAZ,CAAiB,OAAjB;;AACA;AACH;;AACD,UAAM,KAAK,GAAGA,YAAa,CAAC,OAAdA,CAAsB,KAAK,MAA3BA,EAAmC,OAAnCA,EAA4C,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,QAAzB;AAAA,OAA5CA,CAAd;;AACA,WAAK,MAAL,CAAY,MAAZ,CAAmB,KAAnB,EAA0B,CAA1B,EAA6B,OAA7B;AACH;;;8BACS;AACN,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAb;;AACA,aAAO,IAAI,IAAI,IAAI,CAAC,GAApB;AACH;;;wBACU;AACP,aAAO,KAAK,MAAL,CAAY,MAAnB;AACH;;;;;;AAEL,IAAA,UAAe,GAAG,aAAlB;;;;;;;ACvBA,IAAMC,OAAK,GAAG,SAARA,OAAQ,GAAM,CAAG,CAAvB;;AACA,IAAM,YAAY,GAAG,IAAIC,UAAW,CAAC,OAAZA,CAAoB,YAAxB,EAArB;AACA;;;;IAGM,M;;;;;AACF,kBAAY,OAAZ,EAAqB;AAAA;;AAAA;;AACjB;AACA,YAAK,cAAL,GAAsB,CAAtB;AACA,YAAK,YAAL,GAAoB,CAApB;AACA,YAAK,aAAL,GAAqB,CAArB;AACA,YAAK,aAAL,GAAqBD,OAArB;AACA,YAAK,YAAL,GAAoBA,OAApB,CANiB,CAOzB;;AACQ,IAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc;AAAE,MAAA,yBAAyB,EAAE,KAA7B;AAAoC,MAAA,WAAW,EAAE,QAAjD;AAA2D,MAAA,QAAQ,EAAE,CAArE;AAAwE,MAAA,WAAW,EAAE,QAArF;AAA+F,MAAA,SAAS,EAAE,IAA1G;AAAgH,MAAA,UAAU,EAAEG,aAAgB,CAAC;AAA7I,KAAd,EAAsK,OAAtK,CAClB;AADkB,KAAV;;AAGA,QAAI,EAAE,OAAO,OAAO,CAAC,WAAf,KAA+B,QAA/B,IAA2C,OAAO,CAAC,WAAR,IAAuB,CAApE,CAAJ,EAA4E;AACxE,YAAM,IAAI,SAAJ,qEAA8E,OAAO,CAAC,WAAtF,gBAAwG,OAAO,OAAO,CAAC,WAAvH,OAAN;AACH;;AACD,QAAI,OAAO,CAAC,QAAR,KAAqB,SAArB,IAAkC,EAAE,MAAM,CAAC,QAAP,CAAgB,OAAO,CAAC,QAAxB,KAAqC,OAAO,CAAC,QAAR,IAAoB,CAA3D,CAAtC,EAAqG;AACjG,YAAM,IAAI,SAAJ,gEAAyE,OAAO,CAAC,QAAjF,gBAAgG,OAAO,OAAO,CAAC,QAA/G,OAAN;AACH;;AACD,YAAK,0BAAL,GAAkC,OAAO,CAAC,yBAA1C;AACA,YAAK,kBAAL,GAA0B,OAAO,CAAC,WAAR,KAAwB,QAAxB,IAAoC,OAAO,CAAC,QAAR,KAAqB,CAAnF;AACA,YAAK,YAAL,GAAoB,OAAO,CAAC,WAA5B;AACA,YAAK,SAAL,GAAiB,OAAO,CAAC,QAAzB;AACA,YAAK,MAAL,GAAc,IAAI,OAAO,CAAC,UAAZ,EAAd;AACA,YAAK,WAAL,GAAmB,OAAO,CAAC,UAA3B;AACA,YAAK,WAAL,GAAmB,OAAO,CAAC,WAA3B;AACA,YAAK,QAAL,GAAgB,OAAO,CAAC,OAAxB;AACA,YAAK,eAAL,GAAuB,OAAO,CAAC,cAAR,KAA2B,IAAlD;AACA,YAAK,SAAL,GAAiB,OAAO,CAAC,SAAR,KAAsB,KAAvC;AA1BiB;AA2BpB;;;;4BAOO;AACJ,WAAK,aAAL;;AACA,WAAK,kBAAL;AACH;;;uCACkB;AACf,WAAK,aAAL;;AACA,WAAK,aAAL,GAAqBH,OAArB;;AACA,UAAI,KAAK,aAAL,KAAuB,CAA3B,EAA8B;AAC1B,aAAK,YAAL;;AACA,aAAK,YAAL,GAAoBA,OAApB;AACH;AACJ;;;wCACmB;AAChB,WAAK,WAAL;;AACA,WAAK,2BAAL;;AACA,WAAK,UAAL,GAAkB,SAAlB;AACH;;;wCACmB;AAAA;;AAChB,UAAM,GAAG,GAAG,IAAI,CAAC,GAAL,EAAZ;;AACA,UAAI,KAAK,WAAL,KAAqB,SAAzB,EAAoC;AAChC,YAAM,KAAK,GAAG,KAAK,YAAL,GAAoB,GAAlC;;AACA,YAAI,KAAK,GAAG,CAAZ,EAAe;AAC3B;AACA;AACgB,eAAK,cAAL,GAAuB,KAAK,0BAAN,GAAoC,KAAK,aAAzC,GAAyD,CAA/E;AACH,SAJD,MAKK;AACjB;AACgB,cAAI,KAAK,UAAL,KAAoB,SAAxB,EAAmC;AAC/B,iBAAK,UAAL,GAAkB,UAAU,CAAC,YAAM;AAC/B,cAAA,OAAI,CAAC,iBAAL;AACH,aAF2B,EAEzB,KAFyB,CAA5B;AAGH;;AACD,iBAAO,IAAP;AACH;AACJ;;AACD,aAAO,KAAP;AACH;;;yCACoB;AACjB,UAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,CAAzB,EAA4B;AACpC;AACA;AACY,YAAI,KAAK,WAAT,EAAsB;AAClB,UAAA,aAAa,CAAC,KAAK,WAAN,CAAb;AACH;;AACD,aAAK,WAAL,GAAmB,SAAnB;;AACA,aAAK,gBAAL;;AACA,eAAO,KAAP;AACH;;AACD,UAAI,CAAC,KAAK,SAAV,EAAqB;AACjB,YAAM,qBAAqB,GAAG,CAAC,KAAK,iBAAL,EAA/B;;AACA,YAAI,KAAK,yBAAL,IAAkC,KAAK,2BAA3C,EAAwE;AACpE,eAAK,IAAL,CAAU,QAAV;;AACA,eAAK,MAAL,CAAY,OAAZ;;AACA,cAAI,qBAAJ,EAA2B;AACvB,iBAAK,2BAAL;AACH;;AACD,iBAAO,IAAP;AACH;AACJ;;AACD,aAAO,KAAP;AACH;;;kDAC6B;AAAA;;AAC1B,UAAI,KAAK,kBAAL,IAA2B,KAAK,WAAL,KAAqB,SAApD,EAA+D;AAC3D;AACH;;AACD,WAAK,WAAL,GAAmB,WAAW,CAAC,YAAM;AACjC,QAAA,OAAI,CAAC,WAAL;AACH,OAF6B,EAE3B,KAAK,SAFsB,CAA9B;AAGA,WAAK,YAAL,GAAoB,IAAI,CAAC,GAAL,KAAa,KAAK,SAAtC;AACH;;;kCACa;AACV,UAAI,KAAK,cAAL,KAAwB,CAAxB,IAA6B,KAAK,aAAL,KAAuB,CAApD,IAAyD,KAAK,WAAlE,EAA+E;AAC3E,QAAA,aAAa,CAAC,KAAK,WAAN,CAAb;AACA,aAAK,WAAL,GAAmB,SAAnB;AACH;;AACD,WAAK,cAAL,GAAsB,KAAK,0BAAL,GAAkC,KAAK,aAAvC,GAAuD,CAA7E;;AACA,WAAK,aAAL;AACH;AACL;;;;;;oCAGoB;AACpB;AACQ,aAAO,KAAK,kBAAL,EAAP,EAAkC,CAAG;AACxC;;;;AAWL;;;;6FAGc,E;;;;;;;;;AAAI,gBAAA,O,iEAAU,E;mDACb,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACpC,sBAAM,GAAG;AAAA,yFAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACR,8BAAA,OAAI,CAAC,aAAL;AACA,8BAAA,OAAI,CAAC,cAAL;AAFQ;AAIE,8BAAA,SAJF,GAIe,OAAI,CAAC,QAAL,KAAkB,SAAlB,IAA+B,OAAO,CAAC,OAAR,KAAoB,SAApD,GAAiE,EAAE,EAAnE,GAAwEC,UAAW,CAAC,OAAZA,CAAoB,OAAO,CAAC,OAAR,CAAgB,EAAE,EAAlB,CAApBA,EAA4C,OAAO,CAAC,OAAR,KAAoB,SAApB,GAAgC,OAAI,CAAC,QAArC,GAAgD,OAAO,CAAC,OAApGA,EAA8G,YAAM;AAC1M,oCAAI,OAAO,CAAC,cAAR,KAA2B,SAA3B,GAAuC,OAAI,CAAC,eAA5C,GAA8D,OAAO,CAAC,cAA1E,EAA0F;AACtF,kCAAA,MAAM,CAAC,YAAD,CAAN;AACH;;AACD,uCAAO,SAAP;AACH,+BALyFA,CAJtF;AAAA,8CAUJ,OAVI;AAAA;AAAA,qCAUU,SAVV;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAaJ,8BAAA,MAAM,eAAN;;AAbI;AAeR,8BAAA,OAAI,CAAC,KAAL;;AAfQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAH;;AAAA,oCAAH,GAAG;AAAA;AAAA;AAAA,qBAAT;;AAiBA,kBAAA,OAAI,CAAC,MAAL,CAAY,OAAZ,CAAoB,GAApB,EAAyB,OAAzB;;AACA,kBAAA,OAAI,CAAC,kBAAL;AACH,iBApBM,C;;;;;;;;;;;;;;;;AAsBf;;;;;;;;gGAKiB,S,EAAW,O;;;;;;;mDACb,OAAO,CAAC,GAAR,CAAY,SAAS,CAAC,GAAV;AAAA,uFAAc,mBAAO,SAAP;AAAA;AAAA;AAAA;AAAA;AAAA,+DAAqB,OAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,OAApB,CAArB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAd;;AAAA;AAAA;AAAA;AAAA,oBAAZ,C;;;;;;;;;;;;;;;;AAEf;;;;;;4BAGY;AACJ,UAAI,CAAC,KAAK,SAAV,EAAqB;AACjB,eAAO,IAAP;AACH;;AACD,WAAK,SAAL,GAAiB,KAAjB;;AACA,WAAK,aAAL;;AACA,aAAO,IAAP;AACH;AACL;;;;;;4BAGY;AACJ,WAAK,SAAL,GAAiB,IAAjB;AACH;AACL;;;;;;4BAGY;AACJ,WAAK,MAAL,GAAc,IAAI,KAAK,WAAT,EAAd;AACH;AACL;;;;;;;;;;;;;;;sBAOY,KAAK,MAAL,CAAY,IAAZ,KAAqB,C;;;;;;;;mDAGlB,IAAI,OAAJ,CAAY,UAAA,OAAO,EAAI;AAC1B,sBAAM,eAAe,GAAG,OAAI,CAAC,aAA7B;;AACA,kBAAA,OAAI,CAAC,aAAL,GAAqB,YAAM;AACvB,oBAAA,eAAe;AACf,oBAAA,OAAO;AACV,mBAHD;AAIH,iBANM,C;;;;;;;;;;;;;;;;AAQf;;;;;;;;;;;;;;;sBAOY,KAAK,aAAL,KAAuB,CAAvB,IAA4B,KAAK,MAAL,CAAY,IAAZ,KAAqB,C;;;;;;;;mDAG9C,IAAI,OAAJ,CAAY,UAAA,OAAO,EAAI;AAC1B,sBAAM,eAAe,GAAG,OAAI,CAAC,YAA7B;;AACA,kBAAA,OAAI,CAAC,YAAL,GAAoB,YAAM;AACtB,oBAAA,eAAe;AACf,oBAAA,OAAO;AACV,mBAHD;AAIH,iBANM,C;;;;;;;;;;;;;;;;AAQf;;;;;;wBAnMoC;AAC5B,aAAO,KAAK,kBAAL,IAA2B,KAAK,cAAL,GAAsB,KAAK,YAA7D;AACH;;;wBACiC;AAC9B,aAAO,KAAK,aAAL,GAAqB,KAAK,YAAjC;AACH;;;wBAuFiB;AACd,aAAO,KAAK,YAAZ;AACH,K;sBACe,c,EAAgB;AAC5B,UAAI,EAAE,OAAO,cAAP,KAA0B,QAA1B,IAAsC,cAAc,IAAI,CAA1D,CAAJ,EAAkE;AAC9D,cAAM,IAAI,SAAJ,qEAA8E,cAA9E,gBAAmG,OAAO,cAA1G,OAAN;AACH;;AACD,WAAK,YAAL,GAAoB,cAApB;;AACA,WAAK,aAAL;AACH;;;wBAiGU;AACP,aAAO,KAAK,MAAL,CAAY,IAAnB;AACH;AACL;;;;;;wBAGkB;AACV,aAAO,KAAK,aAAZ;AACH;AACL;;;;;;wBAGmB;AACX,aAAO,KAAK,SAAZ;AACH;AACL;;;;;;sBAGgB,Y,EAAc;AACtB,WAAK,QAAL,GAAgB,YAAhB;AACH,K;wBACa;AACV,aAAO,KAAK,QAAZ;AACH;;;;EA1PgBC,a;;AA4PrB,IAAA,QAAe,GAAG,MAAlB;;IC9Na,S;;;;;;;;;;;;;AA0LX,qBAAoB,KAApB,EAAqL;AAAA,QAAnJ,IAAmJ,uEAA7H,IAA6H;AAAA,QAAvH,QAAuH;AAAA,QAA1F,QAA0F,uEAA/E,KAA+E;AAAA,QAAxE,UAAwE,uEAA7C,IAA6C;AAAA,QAAvC,aAAuC,uEAAvB,IAAuB;AAAA,QAAjB,UAAiB,uEAAJ,IAAI;;AAAA;;;;AAInL,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,WAAL,GAAmB,UAAnB;AACA,SAAK,IAAL,GAAY,oBAAoB,CAAC,IAAD,CAAhC;AACA,SAAK,SAAL,GAAiB,YAAY,CAAC,KAAK,IAAN,CAA7B;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,UAAL,GAAkB,UAAlB;AACA,SAAK,IAAL,GAAY,QAAZ;;AACA,QAAI,KAAK,IAAL,CAAU,UAAV,KAAyB,IAA7B,EAAmC;AACjC,WAAK,UAAL,GAAkB,QAAQ,CAAC,KAAK,IAAL,CAAU,UAAX,CAA1B;AACD,KAFD,MAEO;AACL,WAAK,UAAL,GAAkB,IAAlB;AACD;;AAGD,QAAM,OAAO,GAAG,KAAK,SAAL,GAAiB,cAAjC;AACA,SAAK,KAAL,GAAa,IAAI,UAAJ,CAA+B,KAAK,KAApC,EAA2C,OAA3C,EAAoD,KAAK,QAAzD,EAAmE,UAAnE,CAAb;AACD;;;;;;;;;;;;;;;;;;;AAMO,gBAAA,O,GAAU,KAAK,SAAL,GAAiB,c;AAC3B,gBAAA,c,GAAiB,KAAK,KAAL,CAAW,OAAX,CAAmB,OAAnB,C;gCACX,a;;uBAAoB,c;;;;AAAhC,qBAAK,I;mDACE,KAAK,I;;;;;;;;;;;;;;;;;;;;;;;;oBAIP,KAAK,a;;;;;;uBACF,KAAK,cAAL,E;;;;;;;;;;;;;;;;;;0BAMwD;AAAA,UAAvD,SAAuD,uEAA3B,IAA2B;AAAA,UAArB,IAAqB,uEAAF,EAAE;AAChE,aAAO,KAAK,iBAAL,CAAuB,SAAvB,EAAkC,KAAlC,EAAyC,IAAzC,CAAP;AACD;;;6BAIoE;AAAA,UAAvD,SAAuD,uEAA3B,IAA2B;AAAA,UAArB,IAAqB,uEAAF,EAAE;AACnE,aAAO,KAAK,iBAAL,CAAuB,SAAvB,EAAkC,IAAlC,EAAwC,IAAxC,CAAP;AACD;;;;2GAS8B,S;;;;;;;;;;;;AAA2B,gBAAA,K,iEAAQ,K;sFAAiE,E,gCAAxD,gB,EAAA,gB,sCAAmB,E,0BAAI,gB,SAAA,gB;;oBAE3F,KAAK,a;;;;;;uBACF,KAAK,cAAL,E;;;sBAIJ,KAAK,KAAL,KAAe,E;;;;;sBACX,IAAI,KAAJ,CAAU,wCAAV,C;;;mDAEC,KAAK,mBAAL,CAAyB,SAAzB,EAAoC,KAApC,EAA2C,gBAA3C,EAA6D,gBAA7D,C;;;;;;;;;;;;;;;;;;wCAIiB,S,EAA2B,K,EAAgB,gB,EAA0B,gB,EAAoF;AACnL,UAAM,OAAO,GAAG,IAAI,YAAJ,CAAiB,SAAjB,EAA4B,IAA5B,CAAhB;AACA,aAAO,KAAK,YAAL,CAAkB,OAAlB,EAA2B,KAA3B,EAAkC,gBAAlC,EAAoD,gBAApD,CAAP;AACD;;;;sGAE0B,O,EAAuB,K,EAAgB,gB,EAA0B,gB;;;;;;;;;;;;;;;AAUpF,gBAAA,Q,GAAW,KAAK,K;AAChB,gBAAA,Q,GAAW,OAAO,CAAC,K;AACnB,gBAAA,O,GAAU,OAAO,CAAC,KAAR,CAAc,MAAd,CAAqB,UAAC,CAAD,EAAI,CAAJ;AAAA,yBAAU,CAAC,GAAG,CAAd;AAAA,iBAArB,EAAsC,CAAtC,C;;sBAEZ,KAAK,IAAK,OAAO,KAAK,KAAK,S;;;;;;;AAGvB,gBAAA,G,GAAM,OAAO,CAAC,IAAR,E;AACN,gBAAA,I,GAAO,GAAG,CAAC,IAAJ,E,EAAW;;sBACpB,IAAI,CAAC,IAAL,KAAc,KAAd,IAAuB,GAAG,CAAC,IAAJ,GAAW,IAAX,KAAoB,I;;;;;AACvC,gBAAA,e,GAAkB,IAAI,CAAC,K;;uBACX,KAAK,sBAAL,CAA4B,eAA5B,EAA6C,QAA7C,EAAuD,OAAvD,C;;;AAAZ,gBAAA,I;mDACC,I;;;AAIL,gBAAA,G,GAAM,KAAK,GACb,IAAI,QAAJ,CAAa,IAAb,EAAmB,QAAnB,EAA6B,QAA7B,CADa,GAEb,IAAI,WAAJ,CAAgB,IAAhB,EAAsB,QAAtB,EAAgC,QAAhC,C;;sBAEA,OAAO,KAAK,C;;;;;mDACP,G;;;;AAIH,gBAAA,K,GAAQ,IAAIE,QAAJ,CAAW;AAAE,kBAAA,WAAW,EAAE;AAAf,iBAAX,C;;AAEd,oBAAI,gBAAJ,EAAsB;AAAA;AAEpB,wBAAI,QAAQ,GAAG,CAAf;AACA,wBAAI,SAAS,GAAG,CAAhB;;AAHoB,gEAIJ,OAAO,CAAC,IAAR,EAJI;AAAA;;AAAA;AAIpB;AAAA,4BAAW,CAAX;AAAgC,wBAAA,SAAS,IAAI,CAAb;AAAhC;AAJoB;AAAA;AAAA;AAAA;AAAA;;AAKpB,oBAAA,gBAAgB,CAAC;AAAE,sBAAA,QAAQ,EAAE,CAAZ;AAAe,sBAAA,SAAS,EAAE;AAA1B,qBAAD,CAAhB;;AALoB,gEAMD,OAAO,CAAC,IAAR,EANC;AAAA;;AAAA;AAAA;AAAA,4BAMT,IANS;;AAOlB,iFAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yCACO,KAAK,CAAC,GAAN,CAAU;AAAA,2CAAM,OAAI,CAAC,YAAL,CAAkB,IAAI,CAAC,WAAvB,EAAoC,IAAI,CAAC,cAAzC,EAAyD,GAAzD,EAA8D,IAAI,CAAC,YAAnE,EAAiF,OAAO,CAAC,QAAzF,CAAN;AAAA,mCAAV,CADP;;AAAA;AAEC,kCAAA,QAAQ,IAAI,CAAZ;AACA,kCAAA,gBAAgB,CAAC;AAAE,oCAAA,QAAQ,EAAE,QAAZ;AAAsB,oCAAA,SAAS,EAAE;AAAjC,mCAAD,CAAhB;;AAHD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAAD;AAPkB;;AAMpB,6EAAmC;AAAA;AAMlC;AAZmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAcrB,iBAdD,MAcO;AAAA,0DACc,OAAO,CAAC,IAAR,EADd;;AAAA;AAAA;AAAA,0BACM,IADN;AAEH,sBAAA,KAAK,CAAC,GAAN,CAAU;AAAA,+BAAM,OAAI,CAAC,YAAL,CAAkB,IAAI,CAAC,WAAvB,EAAoC,IAAI,CAAC,cAAzC,EAAyD,GAAzD,EAA8D,IAAI,CAAC,YAAnE,EAAiF,OAAO,CAAC,QAAzF,CAAN;AAAA,uBAAV;AAFG;;AACL,2EAAmC;AAAA;AAElC;AAHI;AAAA;AAAA;AAAA;AAAA;AAIN,iB;;;;uBAGK,KAAK,CAAC,MAAN,E;;;sBAGF,GAAG,CAAC,KAAJ,CAAU,MAAV,KAAqB,C;;;;;mDAChB,GAAG,CAAC,IAAJ,CAAS,CAAT,C;;;mDAGF,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;sGAWwC,W,EAAuB,c,EAAsC,G,EAAgC,Y,EAAoC,Q;;;;;;sBAC5K,WAAW,CAAC,MAAZ,KAAuB,KAAK,eAAL,CAAqB,M;;;;;sBACxC,IAAI,UAAJ,mDAA0D,WAAW,CAAC,MAAtE,iCAAmG,KAAK,cAAL,CAAoB,MAAvH,E;;;AAGF,gBAAA,I,GAAO,KAAK,QAAL,CAAc,WAAd,C;;;uBAES,KAAK,UAAL,CAAgB,OAAhB,CAAwB,IAAxB,C;;;AAAd,gBAAA,K;;uBACqB,KAAK,WAAL,CAAiB,KAAjB,C;;;AAArB,gBAAA,Y;;sBAEF,GAAG,YAAY,W;;;;;sBAEb,qBAAqB,CAAC,YAAD,CAArB,IAAuC,YAAY,CAAC,cAAD,EAAiB,KAAK,MAAtB,CAAnD,IAAoF,CAAC,KAAK,IAAL,CAAU,O;;;;;;;;;;AAOjG,gBAAA,GAAG,CAAC,GAAJ,CAAQ,YAAR,EAAsB,KAAK,aAAL,CAAsB,YAAtB,CAAtB;;;;;AAKI,gBAAA,K,GAAQ,KAAK,aAAL,CAAmB,YAAnB,C;AACR,gBAAA,G,GAAM,KAAK,CAAC,GAAN,CAAU,cAAV,C;;sBAER,QAAQ,KAAK,I;;;;;sBACT,IAAI,KAAJ,CAAU,gCAAV,C;;;AAGR,gBAAA,GAAG,CAAC,GAAJ,CAAQ,YAAR,EAAsB,GAAtB;;;;;;;;;AAOA,gBAAA,GAAG,CAAC,GAAJ,CAAQ,YAAR,EAAsB,KAAK,qBAAL,CAA2B,YAA3B,CAAtB,EAAgE,cAAhE;;;;;;;;;;qBAIE,UAAU,e;;;;;;AAEZ,oBAAI,KAAK,SAAL,KAAmB,IAAvB,EAA6B;AAC3B,kBAAA,GAAG,CAAC,GAAJ,CAAQ,YAAR,EAAsB,KAAK,SAA3B;AACD;;;;;;;;;;;;;;;;;;;;;;;;;qGAQqB,W,EAAuB,I;;;;;;sBAC7C,WAAW,CAAC,MAAZ,KAAuB,KAAK,KAAL,CAAW,M;;;;;sBAC9B,IAAI,KAAJ,6BAA+B,WAAW,CAAC,IAAZ,CAAiB,GAAjB,CAA/B,yCAAmF,KAAK,KAAxF,O;;;;;AAGN,qBAAS,CAAT,GAAa,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AACrC,kBAAA,SADqC,GACzB,IAAI,CAAC,IAAL,CAAU,KAAK,KAAL,CAAW,CAAX,IAAgB,KAAK,MAAL,CAAY,CAAZ,CAA1B,CADyB;AAE3C,kBAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,yBAAyB,CAAC,WAAW,CAAC,CAAD,CAAZ,EAAiB,SAAjB,CAA1C;AACD;;;;;;;;;sBAEG,yBAAiB,gB;;;;;sBACb,IAAI,gBAAJ,iBAA8B,WAAW,CAAC,IAAZ,CAAiB,GAAjB,CAA9B,0CAAmF,KAAK,KAAxF,yBAA4G,KAAK,MAAjH,E;;;;;;AAKJ,gBAAA,I,GAAO,KAAK,QAAL,CAAc,WAAd,C;AACP,gBAAA,K,GAAQ,KAAK,UAAL,CAAgB,OAAhB,CAAwB,IAAxB,EAA8B,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,YAApC,C;gCACO,I;;uBAAuB,K;;;;;qCAAlB,W;;;AAApB,gBAAA,M;AACA,gBAAA,Q,GAAW,KAAK,MAAL,CAAY,MAAZ,CAAmB,UAAA,CAAC;AAAA,yBAAI,CAAC,KAAK,CAAV;AAAA,iBAApB,C,EAAiC;;mDAC3C,IAAI,QAAJ,CAAa,MAAb,EAAqB,QAArB,EAA+B,KAAK,KAApC,C;;;;;;;;;;;;;;;;;;6BAGQ,W,EAAqB;;;AACpC,UAAM,GAAG,GAAG,CAAA,EAAA,GAAA,KAAK,IAAL,CAAU,mBAAV,MAA6B,IAA7B,IAA6B,EAAA,KAAA,KAAA,CAA7B,GAA6B,EAA7B,GAAiC,GAA7C;AACA,aAAO,KAAK,SAAL,GAAiB,WAAW,CAAC,IAAZ,CAAiB,GAAjB,CAAxB;AACD;;;oCAEuB,S,EAAyB;AAC/C,UAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACjC,eAAO,IAAI,UAAJ,CAAe,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,MAAtC,CAAP;AACD;;AACD,aAAO,IAAI,UAAJ,CAAe,SAAf,CAAP;AACD;;;iCAEoB,M,EAA4B;AAC/C,aAAO,KAAK,gBAAgB,CAAC,KAAK,KAAN,CAArB,EAAmC,MAAnC,CAAP;AACD;;;kCAE2C,I,EAAoB;AAC9D,UAAM,MAAM,GAAG,KAAK,eAAL,CAAqB,IAArB,EAA2B,MAA1C;AAEA,aAAO,IAAI,WAAJ,CAAmB,MAAnB,EAA2B,KAAK,MAAhC,EAAwC,KAAK,KAA7C,CAAP;AACD;;;;qGAEyB,S;;;;;;AACpB,gBAAA,K,GAAQ,KAAK,eAAL,CAAqB,SAArB,C;;sBAER,KAAK,UAAL,KAAoB,I;;;;;;uBACD,KAAK,U;;;;uCAAY,M,CAAO,K;;;AAA7C,gBAAA,K;;;AAGF,oBAAI,KAAK,KAAL,CAAW,QAAX,CAAoB,GAApB,CAAJ,EAA8B;;;AAG5B,kBAAA,eAAe,CAAC,KAAK,YAAL,CAAkB,KAAK,CAAC,MAAxB,CAAD,CAAf;AACD,iB;;;mDAGM,KAAK,CAAC,M;;;;;;;;;;;;;;;;;;0CAGe,M,EAA4B;AACxD,aAAO,IAAI,QAAJ,CAAa,MAAb,EAAqB,KAAK,MAA1B,EAAkC,KAAK,KAAvC,CAAP;AACD;;;;uHAEsE,Q,EAAoB,O;;;;;;AAApD,gBAAA,W,SAAA,W;AAC/B,gBAAA,I,GAAO,KAAK,QAAL,CAAc,WAAd,C;;;uBAES,KAAK,UAAL,CAAgB,OAAhB,CAAwB,IAAxB,C;;;AAAd,gBAAA,K;gCACK,Q;;uBAAe,KAAK,WAAL,CAAiB,KAAjB,C;;;;gCAAyB,Q;gCAAU,KAAK,K;;;;;;;qBAE9D,UAAU,e;;;;;;AAEN,gBAAA,I,GAAO,KAAK,gBAAgB,CAAC,KAAK,KAAN,CAArB,EAAmC,OAAnC,C;mDACN,IAAI,QAAJ,CAAa,IAAI,CAAC,IAAL,CAAU,KAAK,SAAf,CAAb,EAAkD,QAAlD,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQI,gBAAA,S,iEAA4B,I;AAAM,gBAAA,K;AAAY,gBAAA,I,iEAAmB,E;;uBAC1E,KAAK,iBAAL,CAAuB,SAAvB,EAAkC,KAAlC,EAAyC,IAAzC,C;;;;;;;;;;;;;;;;;;;2GAGuB,S,EAA2B,K;;;;;;;;;;;sFAAsE,E,gCAAxD,gB,EAAA,gB,sCAAmB,E,0BAAI,gB,SAAA,gB;;qBACzF,KAAK,Q;;;;;sBACD,IAAI,eAAJ,CAAoB,qBAApB,C;;;oBAGH,KAAK,a;;;;;;uBACF,KAAK,cAAL,E;;;sBAGJ,KAAK,KAAL,KAAe,E;;;;;sBACX,IAAI,KAAJ,CAAU,wCAAV,C;;;;uBAEA,KAAK,mBAAL,CAAyB,SAAzB,EAAoC,KAApC,EAA2C,gBAA3C,EAA6D,gBAA7D,C;;;;;;;;;;;;;;;;;;;6GAIwB,S,EAA2B,K,EAAY,gB,EAA0B,gB;;;;;;AAC3F,gBAAA,O,GAAU,IAAI,YAAJ,CAAiB,SAAjB,EAA4B,IAA5B,C;;uBACV,KAAK,YAAL,CAAkB,OAAlB,EAA2B,KAA3B,EAAkC,gBAAlC,EAAoD,gBAApD,C;;;;;;;;;;;;;;;;;;kCAGc,I,EAAuB,O,EAAkB,K,EAAyC,c,EAAwB;AAC9H,UAAI,UAAJ;;AACA,UAAI,cAAc,KAAK,EAAvB,EAA2B;AACzB,QAAA,UAAU,GAAG,KAAb;AACD,OAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AACpC,QAAA,UAAU,GAAG,KAAb;AACD,OAFM,MAEA;AACL,QAAA,UAAU,GAAG,KAAK,CAAC,GAAN,CAAU,IAAI,CAAC,YAAf,CAAb,CADK,C;;AAGL,YAAI,OAAO,CAAC,QAAR,KAAqB,IAAzB,EAA+B;AAC7B,gBAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AACD;AACF;;AACD,aAAO,UAAP;AACD;;;;sGAE0B,O,EAAkB,K,EAAyC,gB,EAA0B,gB;;;;;;;;;;;;;;;;AAWxG,gBAAA,c,GAAiB,OAAO,CAAC,K;;sBAG3B,cAAc,KAAK,E;;;;;AAAI;;;;;sBAEhB,OAAO,KAAP,KAAiB,Q;;;;;AAAU;;;;;sBAE3B,KAAK,YAAY,W;;;;;oBAErB,aAAa,CAAC,KAAK,CAAC,KAAP,EAAc,cAAd,C;;;;;sBACV,IAAI,UAAJ,mEAA0E,KAAK,CAAC,KAAhF,kBAA6F,cAA7F,E;;;;;;;sBAIF,IAAI,KAAJ,CAAU,kCAAV,C;;;AAGF,gBAAA,K,GAAQ,IAAIA,QAAJ,CAAW;AAAE,kBAAA,WAAW,EAAE;AAAf,iBAAX,C;;AAEd,oBAAI,gBAAJ,EAAsB;AAAA;AAEpB,wBAAI,SAAS,GAAG,CAAhB;;AAFoB,gEAGJ,OAAO,CAAC,IAAR,EAHI;AAAA;;AAAA;AAGpB;AAAA,4BAAW,CAAX;AAAgC,wBAAA,SAAS,IAAI,CAAb;AAAhC;AAHoB;AAAA;AAAA;AAAA;AAAA;;AAKpB,wBAAI,QAAQ,GAAG,CAAf;AACA,oBAAA,gBAAgB,CAAC;AAAE,sBAAA,QAAQ,EAAE,CAAZ;AAAe,sBAAA,SAAS,EAAE;AAA1B,qBAAD,CAAhB;;AANoB,iEAOD,OAAO,CAAC,IAAR,EAPC;AAAA;;AAAA;AAAA;AAAA,4BAOT,IAPS;;AAQlB,4BAAM,UAAU,GAAG,OAAI,CAAC,aAAL,CAAmB,IAAnB,EAAyB,OAAzB,EAAkC,KAAlC,EAAyC,cAAzC,CAAnB;;AACA,iFAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yCACO,KAAK,CAAC,GAAN,CAAU;AAAA,2CAAM,OAAI,CAAC,YAAL,CAAkB,IAAI,CAAC,WAAvB,EAAoC,IAAI,CAAC,cAAzC,EAAyD,UAAzD,CAAN;AAAA,mCAAV,CADP;;AAAA;AAEC,kCAAA,QAAQ,IAAI,CAAZ;AACA,kCAAA,gBAAgB,CAAC;AAAE,oCAAA,QAAQ,EAAE,QAAZ;AAAsB,oCAAA,SAAS,EAAE;AAAjC,mCAAD,CAAhB;;AAHD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAAD;AATkB;;AAOpB,gFAAmC;AAAA;AAOlC;AAdmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBrB,iBAhBD,MAgBO;AAAA,2DAEc,OAAO,CAAC,IAAR,EAFd;;AAAA;AAAA;AAAA,0BAEM,IAFN;;AAGH,0BAAM,UAAU,GAAG,OAAI,CAAC,aAAL,CAAmB,IAAnB,EAAyB,OAAzB,EAAkC,KAAlC,EAAyC,cAAzC,CAAnB;;AACA,sBAAA,KAAK,CAAC,GAAN,CAAU;AAAA,+BAAM,OAAI,CAAC,YAAL,CAAkB,IAAI,CAAC,WAAvB,EAAoC,IAAI,CAAC,cAAzC,EAAyD,UAAzD,CAAN;AAAA,uBAAV;AAJG;;AAEL,8EAAmC;AAAA;AAGlC;AALI;AAAA;AAAA;AAAA;AAAA;AAON,iB;;;;uBAGK,KAAK,CAAC,MAAN,E;;;;;;;;;;;;;;;;;;;sGAGmB,W,EAAuB,c,EAAsC,K;;;;;;;;AAEhF,gBAAA,Q,GAAW,KAAK,QAAL,CAAc,WAAd,C;AAEb,gBAAA,K,GAA2B,I;AAEzB,gBAAA,W,GAAc,gBAAgB,CAAC,KAAK,KAAN,C;AAC9B,gBAAA,S,GAAY,KAAK,S;;qBAEnB,YAAY,CAAC,cAAD,EAAiB,KAAK,MAAtB,C;;;;;;;;AAMd,oBAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;;AAE7B,kBAAA,KAAK,GAAG,IAAI,WAAJ,CAAgB,SAAhB,CAAR;AACA,kBAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AACD,iBAJD,MAIO;AACL,kBAAA,KAAK,GAAG,KAAK,CAAC,OAAN,EAAR;AACD;;;;;;;;uBAU8B,KAAK,UAAL,CAAgB,OAAhB,CAAwB,QAAxB,C;;;AAAvB,gBAAA,c;;uBACe,KAAK,WAAL,CAAiB,cAAjB,C;;;AAAf,gBAAA,M;AACN,gBAAA,UAAS,GAAG,KAAK,YAAL,CAAkB,MAAlB,CAAZ;;;;;;;;qBAEI,UAAU,e;;;;;;AAEZ,gBAAA,UAAS,GAAG,IAAI,WAAJ,CAAgB,SAAhB,CAAZ;;AACA,oBAAI,KAAK,SAAL,KAAmB,IAAvB,EAA6B;AAC3B,kBAAA,UAAS,CAAC,IAAV,CAAe,KAAK,SAApB;AACD;;;;;;;;;AAOC,gBAAA,gB,GAAmB,IAAI,WAAJ,CACvB,UADuB,EAEvB,KAAK,MAFkB,EAGvB,KAAK,KAHkB,C;AAKzB,gBAAA,gBAAgB,CAAC,GAAjB,CAAqB,cAArB,EAAqC,KAArC;AACA,gBAAA,KAAK,GAAG,gBAAgB,CAAC,OAAjB,EAAR;;;;uBAEsB,KAAK,WAAL,CAAiB,KAAjB,C;;;AAAlB,gBAAA,S;AACN,qBAAK,UAAL,CAAgB,OAAhB,CAAwB,QAAxB,EAAkC,SAAlC;;;;;;;;;;;;;;;;;;;qGAGwB,K;;;;;;AACxB,oBAAI,KAAK,KAAL,CAAW,QAAX,CAAoB,GAApB,CAAJ,EAA8B;;;;;;;AAO5B,kBAAA,KAAK,GAAG,QAAQ,CAAC,KAAD,CAAhB;AACD;;sBAEG,KAAK,UAAL,KAAoB,I;;;;;AAChB,gBAAA,K,GAAQ,IAAI,UAAJ,CAAe,KAAK,CAAC,MAArB,C;;uBACc,KAAK,U;;;;uCAAY,M,CAAO,K;;;AAA9C,gBAAA,M;mDACC,MAAM,CAAC,M;;;mDAIT,KAAK,CAAC,M;;;;;;;;;;;;;;;;;;wBApoBM;AACnB,UAAI,KAAK,WAAT,EAAsB;AACpB,eAAO,KAAK,WAAZ;AACD;;AACD,aAAO,KAAK,KAAZ;AACD;;;;;;;wBAYc;AACb,UAAI,KAAK,IAAL,CAAU,MAAV,GAAmB,CAAvB,EAA0B;AACxB,YAAI,KAAK,IAAL,CAAU,CAAV,MAAiB,GAArB,EAA0B;AACxB,iBAAO,MAAM,KAAK,IAAlB;AACD;;AACD,eAAO,KAAK,IAAZ;AACD;;AACD,aAAO,IAAP;AACD;;;;;;;wBAKkB;AACjB,UAAM,IAAI,GAAG,KAAK,IAAlB;;AACA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAO,IAAP;AACD;;AACD,UAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAd;AACA,aAAO,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAZ;AACD;;;;;;;wBAKe;;AAEd,aAAO,KAAK,IAAL,CAAU,KAAjB;AACD;;;;;;;wBAKgB;AACf,aAAO,KAAK,IAAL,CAAU,MAAjB;AACD;;;;;;;wBAKoB;AACnB,aAAO,KAAK,MAAL,CAAY,MAAZ,CAAmB,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,CAAC,GAAG,CAAd;AAAA,OAAnB,EAAoC,CAApC,CAAP;AACD;;;;;;;wBAKe;AACd,aAAO,KAAK,IAAL,CAAU,KAAjB;AACD;;;;;;;wBAKmB;AAElB,UAAM,aAAa,GAAG,KAAK,IAAL,CAAU,UAAhC,CAFkB,C;;AAKlB,UAAI,aAAa,KAAK,KAAtB,EAA6B;AAC3B,eAAO,GAAP;AACD,OAFD,MAEO,IAAI,aAAa,KAAK,UAAtB,EAAkC;AACvC,eAAO,QAAP;AACD,OAFM,MAEA,IAAI,aAAa,KAAK,WAAtB,EAAmC;AACxC,eAAO,CAAC,QAAR;AACD;;AAED,aAAO,KAAK,IAAL,CAAU,UAAjB;AACD;;;;;;;wBAKe;AACd,aAAO,KAAK,IAAL,CAAU,KAAV,CAAgB,MAAvB;AACD;;;;;;;wBAKc;;AAEb,aAAO,KAAK,IAAL,CAAU,KAAV,CAAgB,MAAhB,CAAuB,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,CAAC,GAAG,CAAd;AAAA,OAAvB,EAAwC,CAAxC,CAAP;AACD;;;wBAEgB;AACf,aAAO,KAAK,KAAL,CAAW,CAAX,CAAP;AACD;;;wBAG0B;AACzB,UAAI,KAAK,KAAL,KAAe,EAAnB,EAAuB;AACrB,eAAO,CAAC,CAAD,CAAP;AACD,OAFD,MAEO;AACL,YAAM,CAAC,GAAG,EAAV;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,KAAL,CAAW,MAA/B,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,UAAA,CAAC,CAAC,CAAD,CAAD,GAAO,IAAI,CAAC,IAAL,CAAU,KAAK,KAAL,CAAW,CAAX,IAAgB,KAAK,MAAL,CAAY,CAAZ,CAA1B,CAAP;AACD;;AACD,eAAO,CAAP;AACD;AACF;;;;;;;;wBAKwB;;AAEvB,aAAO,KAAK,eAAZ;AACD;;;;;;;wBAKmB;;AAElB,aAAO,KAAK,cAAL,CAAoB,MAApB,CAA2B,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,CAAC,GAAG,CAAd;AAAA,OAA3B,EAA4C,CAA5C,CAAP;AACD;;;;;;;;;;;;;;;;gGAa0B,K;;;;;;;;;;;;AAAc,gBAAA,I,iEAAsB,I;AAAM,gBAAA,Q,iEAAW,K;AAAO,gBAAA,U,iEAA2B,I;AAAM,gBAAA,a,iEAAgB,I;AAAM,gBAAA,U,iEAAa,I;;uBAClI,KAAK,0BAAL,CAAgC,KAAhC,EAAuC,IAAvC,C;;;AAAjB,gBAAA,Q;mDACC,IAAI,SAAJ,CAAc,KAAd,EAAqB,IAArB,EAA2B,QAA3B,EAA0D,QAA1D,EAAoE,UAApE,EAAgF,aAAhF,EAA+F,UAA/F,C;;;;;;;;;;;;;;;;;;;oHAGuC,K,EAAc,I;;;;;;;AAE1D,gBAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;AACM,gBAAA,S,GAAY,YAAY,CAAC,IAAD,C;;uBACD,KAAK,CAAC,OAAN,CAAc,SAAS,GAAG,cAA1B,C;;;AAAvB,gBAAA,c;mDACC,aAAa,CAAC,cAAD,C;;;;;;uBAEV,aAAa,CAAC,KAAD,EAAQ,IAAR,C;;;;;;;;sBACf,IAAI,kBAAJ,CAAuB,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAA,IAAA,GAAQ,EAA/B,C;;;sBAEF,IAAI,KAAJ,CAAU,2CAA2C,cAAM,QAAN,EAArD,C;;;;;;;;;;;;;;;;;;;;;IC9MC,W;AAQT,yBAAqB;AAAA,QAAT,IAAS,uEAAF,EAAE;;AAAA;;AACjB,SAAK,IAAL,GAAY,IAAZ;AACH;;;;4BAEW;AACR,aAAO,WAAW,CAAC,IAAD,CAAlB;AACH;;;8BAEiB,I,EAAY;AAC1B,UAAI,MAAM,GAAG,KAAK,IAAlB;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAjB,CAF0B,C;;AAAA,mDAIV,QAAQ,CAAC,KAAT,CAAe,CAAf,EAAkB,QAAQ,CAAC,MAAT,GAAkB,CAApC,CAJU;AAAA;;AAAA;AAI1B,kEAAwD;AAAA,cAA7C,CAA6C;AACpD,UAAA,MAAM,GAAG,MAAM,CAAC,CAAD,CAAf;;AACA,cAAI,CAAC,MAAL,EAAa;AACT,kBAAM,KAAK,CAAC,IAAD,CAAX;AACH,WAJmD,C;;;AAOvD;AAXyB;AAAA;AAAA;AAAA;AAAA;;AAY1B,aAAO,CAAC,MAAD,EAAS,QAAQ,CAAC,QAAQ,CAAC,MAAT,GAAkB,CAAnB,CAAjB,CAAP;AACH;;;kCAEqB,I,EAAY;AAC9B,UAAI,MAAM,GAAG,KAAK,IAAlB;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAjB,CAF8B,C;;AAAA,mDAKd,QAAQ,CAAC,KAAT,CAAe,CAAf,EAAkB,QAAQ,CAAC,MAAT,GAAkB,CAApC,CALc;AAAA;;AAAA;AAK9B,kEAAwD;AAAA,cAA7C,CAA6C;;;AAEpD,cAAI,MAAM,CAAC,CAAD,CAAN,KAAc,SAAlB,EAA6B;AACzB,YAAA,MAAM,CAAC,CAAD,CAAN,GAAY,EAAZ;AACH;;AACD,UAAA,MAAM,GAAG,MAAM,CAAC,CAAD,CAAf;AACH;AAX6B;AAAA;AAAA;AAAA;AAAA;;AAa9B,aAAO,CAAC,MAAD,EAAS,QAAQ,CAAC,QAAQ,CAAC,MAAT,GAAkB,CAAnB,CAAjB,CAAP;AACH;;;4BAEO,I,EAAY;AAAA,4BACM,KAAK,SAAL,CAAe,IAAf,CADN;AAAA;AAAA,UACT,MADS;AAAA,UACD,GADC;;AAEhB,UAAM,KAAK,GAAG,MAAM,CAAC,GAAD,CAApB;;AACA,UAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,cAAM,IAAI,QAAJ,CAAa,IAAb,CAAN;AACH;;AACD,aAAO,KAAP;AACH;;;4BAEO,I,EAAc,K,EAAU;AAAA,gCACN,KAAK,aAAL,CAAmB,IAAnB,CADM;AAAA;AAAA,UACrB,MADqB;AAAA,UACb,GADa;;AAE5B,MAAA,MAAM,CAAC,GAAD,CAAN,GAAc,KAAd;AACA,aAAO,IAAP;AACH;;;+BAEU,I,EAAY;AAAA,6BACG,KAAK,SAAL,CAAe,IAAf,CADH;AAAA;AAAA,UACZ,MADY;AAAA,UACJ,GADI;;AAEnB,aAAO,OAAO,MAAM,CAAC,GAAD,CAApB;AACH;;;iCAEY,I,EAAY;;AAErB,UAAI;AACA,eAAO,KAAK,OAAL,CAAa,IAAb,MAAuB,SAA9B;AACH,OAFD,CAEE,OAAO,CAAP,EAAU;AACR,eAAO,KAAP;AACH;AACJ;;;2BAEG;AACA,YAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACH;;;;;;AC9EL,IAAK,UAAL;;AAAA,CAAA,UAAK,UAAL,EAAe;AACb,EAAA,UAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AACA,EAAA,UAAA,CAAA,KAAA,CAAA,GAAA,KAAA;AACA,EAAA,UAAA,CAAA,KAAA,CAAA,GAAA,KAAA;AACD,CAJD,EAAK,UAAU,KAAV,UAAU,GAAA,EAAA,CAAf;;AAMA,IAAM,eAAe,GAAG,CAAC,UAAU,CAAC,IAAZ,EAAkB,UAAU,CAAC,GAA7B,EAAkC,UAAU,CAAC,GAA7C,CAAxB;;IAOa,S;AAUT,qBAAY,GAAZ,EAAuD;AAAA,QAA9B,OAA8B,uEAAF,EAAE;;AAAA;;AACnD,SAAK,GAAL,GAAW,GAAX;AADmD,gCAEe,OAFf,CAE3C,YAF2C;AAAA,QAE3C,YAF2C,sCAE5B,EAF4B;AAAA,gCAEe,OAFf,CAExB,gBAFwB;AAAA,QAExB,gBAFwB,sCAEL,eAFK;AAGnD,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,gBAAL,GAAwB,IAAI,GAAJ,CAAQ,gBAAR,CAAxB;AACH;;;;2BAEG;AACA,YAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACH;;;;kGAEa,I,EAAc,I;;;;;;AAClB,gBAAA,G,GAAM,YAAY,CAAC,KAAK,GAAN,EAAW,IAAX,C;;uBACJ,KAAK,CAAC,GAAD,oBAAW,KAAK,YAAhB,MAAiC,IAAjC,E;;;AAAnB,gBAAA,K;;sBAEF,KAAK,CAAC,MAAN,KAAiB,G;;;;;sBAEX,IAAI,QAAJ,CAAa,IAAb,C;;;sBACC,KAAK,CAAC,MAAN,KAAiB,G;;;;;sBAClB,IAAI,SAAJ,CAAc,MAAM,CAAC,KAAK,CAAC,MAAP,CAApB,C;;;qBAIN,O;;;;;gCACO,M;;uBAAkB,KAAK,CAAC,WAAN,E;;;;iEAAX,I;;;mDAEP,KAAK,CAAC,WAAN,E;;;;;;;;;;;;;;;;;;;kGAID,I,EAAc,K;;;;;;oBACnB,KAAK,gBAAL,CAAsB,GAAtB,CAA0B,UAAU,CAAC,GAArC,C;;;;;sBACG,IAAI,KAAJ,CAAU,2CAAV,C;;;AAEF,gBAAA,G,GAAM,YAAY,CAAC,KAAK,GAAN,EAAW,IAAX,C;;AACxB,oBAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,kBAAA,KAAK,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,KAAzB,EAAgC,MAAxC;AACH;;;uBACiB,KAAK,CAAC,GAAD,oBAAW,KAAK,YAAhB;AAA8B,kBAAA,MAAM,EAAE,UAAU,CAAC,GAAjD;AAAsD,kBAAA,IAAI,EAAE;AAA5D,mB;;;AAAjB,gBAAA,G;mDACC,GAAG,CAAC,MAAJ,CAAW,QAAX,GAAsB,CAAtB,MAA6B,G;;;;;;;;;;;;;;;;;;+BAG7B,K,EAAa;AACpB,YAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACH;;;;uGAEkB,I;;;;;;AACT,gBAAA,G,GAAM,YAAY,CAAC,KAAK,GAAN,EAAW,IAAX,C;;AAElB,gBAAA,M,GAAS,KAAK,gBAAL,CAAsB,GAAtB,CAA0B,UAAU,CAAC,IAArC,IAA6C,UAAU,CAAC,IAAxD,GAA+D,UAAU,CAAC,G;;uBACrE,KAAK,CAAC,GAAD,oBAAW,KAAK,YAAhB;AAA8B,kBAAA,MAAM,EAAN;AAA9B,mB;;;AAAnB,gBAAA,K;mDACC,KAAK,CAAC,MAAN,KAAiB,G;;;;;;;;;;;;;;;;;;;;ACjDhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA0BsB,M;;;AAatB;;;;;;sEAbO;AAAA;;AAAA;AAAA;AAAA;AAAA;AACD,YAAA,KADC,SACD,KADC,uBACM,MADN,EACM,MADN,6BACe,IADf,qCACqB,KADrB,EACqB,KADrB,4BAC6B,KAD7B,yCACoC,UADpC,EACoC,UADpC,iCACiD,IADjD,6CACuD,SADvD,EACuD,SADvD,gCACmE,IADnE,wCACyE,KADzE,EACyE,KADzE,4BACiF,GADjF,gBACsF,KADtF,SACsF,KADtF,0BAC6F,SAD7F,EAC6F,SAD7F,gCACyG,KADzG,oBACgH,IADhH,SACgH,IADhH,EACsH,UADtH,SACsH,UADtH,EACkI,OADlI,SACkI,OADlI,8BAC2I,aAD3I,EAC2I,aAD3I,oCAC2J,IAD3J,iDACiK,UADjK,EACiK,UADjK,iCAC8K,IAD9K,4CACoL,QADpL,EACoL,QADpL,+BAC+L,KAD/L,mBACsM,kBADtM,SACsM,kBADtM;AAIH,YAAA,KAAK,GAAG,sBAAsB,CAAC,KAAD,CAA9B;AAJG;AAAA,mBAMG,SAAS,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B,IAA9B,EAAoC,UAApC,EAAgD,SAAhD,EAA2D,KAA3D,EAAkE,SAAlE,EAA6E,UAA7E,EAAyF,OAAzF,EAAkG,kBAAlG,CANZ;;AAAA;AAAA;AAAA,mBAOa,SAAS,CAAC,MAAV,CAAiB,KAAjB,EAAwB,IAAxB,EAA8B,QAA9B,EAAwC,UAAxC,EAAoD,aAApD,EAAmE,UAAnE,CAPb;;AAAA;AAOG,YAAA,CAPH;AAAA,+CASI,CATJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAgBe,O;;;AAKtB;;;;;;;oEALO,mBAAqB,KAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C,YAAA,IAA/C,iEAAyF,EAAzF;AACH,YAAA,IAAI,CAAC,SAAL,GAAiB,IAAjB;AADG,+CAEI,MAAM;AAAG,cAAA,KAAK,EAAL;AAAH,eAAa,IAAb,EAFV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SASe,O;;;AAKtB;;;;;;;oEALO,mBAAqB,KAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C,YAAA,IAA/C,iEAAyF,EAAzF;AACH,YAAA,IAAI,CAAC,SAAL,GAAiB,CAAjB;AADG,+CAEI,MAAM;AAAG,cAAA,KAAK,EAAL;AAAH,eAAa,IAAb,EAFV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SASe,M;;;AAKtB;;;;;;;mEALO,mBAAoB,KAApB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C,YAAA,IAA9C,iEAAwF,EAAxF;AACH,YAAA,IAAI,CAAC,SAAL,GAAiB,CAAjB;AADG,+CAEI,MAAM;AAAG,cAAA,KAAK,EAAL;AAAH,eAAa,IAAb,EAFV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SASe,M;;;;;mEAAf,mBAAoB,KAApB,EAA8C,SAA9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmE,YAAA,IAAnE,iEAA6G,EAA7G;AACH,YAAA,IAAI,CAAC,SAAL,GAAiB,SAAjB;AADG,+CAEI,MAAM;AAAG,cAAA,KAAK,EAAL;AAAH,eAAa,IAAb,EAFV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAKe,O;;;;;oEAAf,mBAAqB,IAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2E,YAAA,IAA3E,iEAAqH,EAArH;;AAGC,YAAA,KAHD,GAGS,IAHT;;AAIH,gBAAI,IAAI,YAAY,WAApB,EAAiC;AAC7B,cAAA,KAAK,GAAG,IAAI,CAAC,KAAb;AACA,cAAA,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,KAAL,KAAe,SAAf,GAA2B,IAAI,CAAC,KAAhC,GAAwC,IAAI,CAAC,KAA1D;AACH,aAHD,MAGO;AACH,cAAA,KAAK,GAAG,IAAI,CAAC,UAAb,CADG,C;AAGN,aAVE,C;;;AAaG,YAAA,WAbH,GAaiB,IAAI,CAAC,QAAL,KAAkB,SAAlB,GAA8B,KAA9B,GAAsC,IAAI,CAAC,QAb5D;AAcH,YAAA,IAAI,CAAC,QAAL,GAAgB,KAAhB;AAdG;AAAA,mBAgBa,MAAM;AAAG,cAAA,KAAK,EAAL;AAAH,eAAa,IAAb,EAhBnB;;AAAA;AAgBG,YAAA,CAhBH;AAAA;AAAA,mBAiBG,CAAC,CAAC,GAAF,CAAM,IAAN,EAAY,IAAZ,CAjBH;;AAAA;AAkBH,YAAA,CAAC,CAAC,QAAF,GAAa,WAAb;AAlBG,+CAoBI,CApBJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAyBe,S;;;;;wEAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,mFACgP,EADhP,EACD,KADC,UACD,KADC,uBACM,IADN,EACM,IADN,4BACa,GADb,uCACkB,MADlB,EACkB,MADlB,8BAC2B,IAD3B,wCACiC,KADjC,EACiC,KADjC,6BACyC,KADzC,4CACgD,UADhD,EACgD,UADhD,kCAC6D,IAD7D,gDACmE,SADnE,EACmE,SADnE,iCAC+E,IAD/E,2CACqF,KADrF,EACqF,KADrF,6BAC6F,GAD7F,iBACkG,KADlG,UACkG,KADlG,4BACyG,SADzG,EACyG,SADzG,iCACqH,KADrH,0CAC4H,IAD5H,EAC4H,IAD5H,4BACmI,IADnI,gBACyI,UADzI,UACyI,UADzI,EACqJ,OADrJ,UACqJ,OADrJ,gCAC8J,aAD9J,EAC8J,aAD9J,qCAC8K,IAD9K,oDACoL,UADpL,EACoL,UADpL,kCACiM,IADjM,sBACuM,kBADvM,UACuM,kBADvM;AAGH,YAAA,KAAK,GAAG,sBAAsB,CAAC,KAAD,CAA9B;;AACA,gBAAI,UAAU,KAAK,SAAnB,EAA8B;AAC1B,cAAA,UAAU,GAAG,sBAAsB,CAAC,KAAD,CAAnC;AACH;;AACD,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;;AAPG,kBASC,IAAI,KAAK,GAAT,IAAgB,IAAI,KAAK,IAT1B;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAUY,aAAa,CAAC,KAAD,EAAQ,IAAR,CAVzB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAWe,aAAa,CAAC,KAAD,EAAQ,IAAR,CAX5B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAYe,IAAI,kBAAJ,CAAuB,IAAvB,CAZf;;AAAA;AAAA,kBAcW,IAAI,kBAAJ,CAAuB,IAAvB,CAdX;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAgBQ,IAAI,KAAK,GAhBjB;AAAA;AAAA;AAAA;;AAAA,kBAkBK,KAAK,KAAK,SAlBf;AAAA;AAAA;AAAA;;AAAA,kBAmBW,IAAI,UAAJ,CAAe,sDAAf,CAnBX;;AAAA;AAAA;AAAA,mBAqBO,SAAS,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B,IAA9B,EAAoC,UAApC,EAAgD,SAAhD,EAA2D,KAA3D,EAAkE,SAAlE,EAA6E,UAA7E,EAAyF,OAAzF,EAAkG,kBAAlG,CArBhB;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAuBQ,IAAI,KAAK,GAvBjB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAwBY,aAAa,CAAC,KAAD,EAAQ,IAAR,CAxBzB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAyBe,aAAa,CAAC,KAAD,EAAQ,IAAR,CAzB5B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBA0Be,IAAI,kBAAJ,CAAuB,IAAvB,CA1Bf;;AAAA;AAAA,kBA4BS,KAAK,KAAK,SA5BnB;AAAA;AAAA;AAAA;;AAAA,kBA6Be,IAAI,UAAJ,CAAe,sDAAf,CA7Bf;;AAAA;AAAA;AAAA,mBA+BW,SAAS,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B,IAA9B,EAAoC,UAApC,EAAgD,SAAhD,EAA2D,KAA3D,EAAkE,SAAlE,EAA6E,UAA7E,EAAyF,OAAzF,EAAkG,kBAAlG,CA/BpB;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAiCQ,IAAI,KAAK,IAAT,IAAkB,IAAY,KAAK,GAjC3C;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAkCW,aAAa,CAAC,KAAD,EAAQ,IAAR,CAlCxB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAmCW,IAAI,kBAAJ,CAAuB,IAAvB,CAnCX;;AAAA;AAAA;AAAA,mBAoCkB,aAAa,CAAC,KAAD,EAAQ,IAAR,CApC/B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAqCW,IAAI,kBAAJ,CAAuB,IAAvB,CArCX;;AAAA;AAAA,kBAuCS,KAAK,KAAK,SAvCnB;AAAA;AAAA;AAAA;;AAAA,kBAwCe,IAAI,UAAJ,CAAe,sDAAf,CAxCf;;AAAA;AAAA;AAAA,mBA0CW,SAAS,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B,IAA9B,EAAoC,UAApC,EAAgD,SAAhD,EAA2D,KAA3D,EAAkE,SAAlE,EAA6E,UAA7E,EAAyF,OAAzF,EAAkG,kBAAlG,CA1CpB;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBA6CO,IAAI,UAAJ,kCAAyC,IAAzC,EA7CP;;AAAA;AAgDG,YAAA,QAhDH,GAgDc,IAAI,KAAK,GAhDvB;AAAA,+CAiDI,SAAS,CAAC,MAAV,CAAiB,KAAjB,EAAwB,IAAxB,EAA8B,QAA9B,EAAwC,UAAxC,EAAoD,aAApD,EAAmE,UAAnE,CAjDJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAqDS,sB,CAAuB,K,EAAsB;AACzD,MAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,WAAO,IAAI,WAAJ,EAAP;AACH,GAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAClC,WAAO,IAAI,SAAJ,CAAc,KAAd,CAAP;AACH;;AACD,SAAO,KAAP;AACJ;;IC7Ka,K;AAyET,iBAAoB,KAApB,EAA+J;AAAA,QAA7H,IAA6H,uEAAvG,IAAuG;AAAA,QAAjG,QAAiG;AAAA,QAApE,QAAoE,uEAAzD,KAAyD;AAAA,QAAlD,UAAkD,uEAAvB,IAAuB;AAAA,QAAjB,UAAiB,uEAAJ,IAAI;;AAAA;;AAC3J,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,WAAL,GAAmB,UAAnB;AACA,SAAK,IAAL,GAAY,oBAAoB,CAAC,IAAD,CAAhC;AACA,SAAK,SAAL,GAAiB,YAAY,CAAC,KAAK,IAAN,CAA7B;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,IAAL,GAAY,QAAZ,CAN2J,C;;AAS3J,QAAM,OAAO,GAAG,KAAK,SAAL,GAAiB,cAAjC;AACA,SAAK,KAAL,GAAa,IAAI,UAAJ,CAA+B,KAAK,KAApC,EAA2C,OAA3C,EAAoD,KAAK,QAAzD,EAAmE,UAAnE,CAAb;AACH;;;;;;;;6BAEgB,I,EAAmB;AAChC,UAAM,QAAQ,GAAG,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,CAAC,MAAL,GAAc,CAA1C,IAA+C,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA5E;AACA,UAAM,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAAjC,CAFgC,C;;AAIhC,UAAI,CAAC,QAAD,IAAa,KAAK,IAAL,CAAU,MAAV,GAAmB,CAApC,EAAuC;AACnC,eAAO,KAAK,SAAL,GAAiB,IAAxB;AACH;;AACD,aAAO,IAAP;AACH;;;;;;;;qGAKwB,I;;;;;;;;AAAc,gBAAA,S,iEAAY,K;;qBAC3C,KAAK,Q;;;;;sBACC,IAAI,eAAJ,CAAoB,oBAApB,C;;;AAEJ,gBAAA,I,GAAO,KAAK,QAAL,CAAc,IAAd,C;;uBACP,SAAS,CAAC,KAAK,KAAN,EAAa,IAAb,EAAmB,KAAK,WAAxB,EAAqC,SAArC,C;;;mDACR,KAAK,CAAC,MAAN,CAAa,KAAK,KAAlB,EAAyB,IAAzB,EAA+B,KAAK,QAApC,EAA8C,KAAK,WAAnD,EAAgE,KAAK,KAAL,CAAW,KAA3E,C;;;;;;;;;;;;;;;;;;;;;;;sGAMe,I;;;;;;;;AAAc,gBAAA,S,iEAAY,K;;qBAC5C,KAAK,Q;;;;;sBACC,IAAI,eAAJ,CAAoB,oBAApB,C;;;AAEJ,gBAAA,I,GAAO,KAAK,QAAL,CAAc,IAAd,C;;uBACF,aAAa,CAAC,KAAK,KAAN,EAAa,IAAb,C;;;;;;;;;uBACd,SAAS,CAAC,KAAK,KAAN,EAAa,IAAb,EAAmB,KAAK,WAAxB,EAAqC,SAArC,C;;;mDAEZ,KAAK,CAAC,MAAN,CAAa,KAAK,KAAlB,EAAyB,IAAzB,EAA+B,KAAK,QAApC,EAA8C,KAAK,WAAnD,EAAgE,KAAK,KAAL,CAAW,KAA3E,C;;;;;;;;;;;;;;;;;;4CAGqB,I,EAA0D;AAAA,UAA5C,IAA4C,uEAAF,EAAE;AACtF,UAAM,IAAI,GAAG,KAAK,QAAL,CAAc,IAAd,CAAb;AACA,MAAA,IAAI,CAAC,IAAL,GAAY,IAAZ;;AAEA,UAAI,IAAI,CAAC,UAAL,KAAoB,SAAxB,EAAmC;AAC/B,QAAA,IAAI,CAAC,UAAL,GAAkB,KAAK,KAAL,CAAW,KAA7B;AACH;;AACD,MAAA,IAAI,CAAC,KAAL,GAAa,KAAK,KAAlB;AACA,MAAA,IAAI,CAAC,UAAL,GAAkB,KAAK,UAAvB;AACA,aAAO,IAAP;AACH;;;;;;;0BAKY,I,EAAc,I,EAAsD,I,EAA0C,S,EAAmB;AAC1I,UAAI,KAAK,QAAT,EAAmB;AACf,cAAM,IAAI,eAAJ,CAAoB,oBAApB,CAAN;AACH;;AACD,MAAA,IAAI,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,IAAnC,CAAP;AACA,MAAA,IAAI,CAAC,SAAL,GAAiB,SAAS,KAAK,SAAd,GAA0B,IAAI,CAAC,SAA/B,GAA2C,SAA5D;AAEA,aAAO,OAAK,CAAC,IAAD,EAAO,IAAP,CAAZ;AACH;;;0BAEY,I,EAAc,K,EAAqE;AAAA,UAA3C,IAA2C,uEAAF,EAAE;;AAC5F,UAAI,KAAK,QAAT,EAAmB;AACf,cAAM,IAAI,eAAJ,CAAoB,oBAApB,CAAN;AACH;;AACD,MAAA,IAAI,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,IAAnC,CAAP;AAEA,aAAO,OAAK,CAAC,KAAD,EAAQ,IAAR,CAAZ;AACH;;;0BAEY,I,EAAc,K,EAAqE;AAAA,UAA3C,IAA2C,uEAAF,EAAE;;AAC5F,UAAI,KAAK,QAAT,EAAmB;AACf,cAAM,IAAI,eAAJ,CAAoB,oBAApB,CAAN;AACH;;AACD,MAAA,IAAI,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,IAAnC,CAAP;AAEA,aAAO,OAAK,CAAC,KAAD,EAAQ,IAAR,CAAZ;AACH;;;yBAEW,I,EAAc,K,EAAqE;AAAA,UAA3C,IAA2C,uEAAF,EAAE;;AAC3F,UAAI,KAAK,QAAT,EAAmB;AACf,cAAM,IAAI,eAAJ,CAAoB,oBAApB,CAAN;AACH;;AACD,MAAA,IAAI,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,IAAnC,CAAP;AAEA,aAAO,MAAI,CAAC,KAAD,EAAQ,IAAR,CAAX;AACH;;;yBAEW,I,EAAc,K,EAA0B,S,EAAsE;AAAA,UAA5C,IAA4C,uEAAF,EAAE;;AACtH,UAAI,KAAK,QAAT,EAAmB;AACf,cAAM,IAAI,eAAJ,CAAoB,oBAApB,CAAN;AACH;;AACD,MAAA,IAAI,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,IAAnC,CAAP;AAEA,aAAO,MAAI,CAAC,KAAD,EAAQ,SAAR,EAAmB,IAAnB,CAAX;AACH;;;kCAEoB,I,EAAc,K,EAA2B,I,EAAuD,I,EAAwC;AACzJ,UAAI,KAAK,QAAT,EAAmB;AACf,cAAM,IAAI,eAAJ,CAAoB,oBAApB,CAAN;AACH;;AACD,MAAA,IAAI,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,IAAnC,CAAP;AAEA,UAAI,CAAJ;;AACA,UAAI,IAAI,KAAK,SAAb,EAAwB;AACpB,YAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,gBAAM,IAAI,UAAJ,CAAe,yDAAf,CAAN;AACH;;AACD,QAAA,CAAC,GAAG,MAAM;AAAG,UAAA,KAAK,EAAL;AAAH,WAAa,IAAb,EAAV;AACH,OALD,MAKO;AACH,QAAA,CAAC,GAAG,OAAK,CAAC,IAAD,EAAO,IAAP,CAAT;AACH;;AACD,aAAO,CAAP;AACH;;;;kGAEa,I;;;;;;AACJ,gBAAA,I,GAAO,KAAK,QAAL,CAAc,IAAd,C;;uBACH,aAAa,CAAC,KAAK,KAAN,EAAa,IAAb,C;;;;;;;;mDACZ,SAAS,CAAC,MAAV,CAAiB,KAAK,KAAtB,EAA6B,IAA7B,EAAmC,KAAK,QAAxC,EAAkD,KAAK,UAAvD,EAAmE,SAAnE,EAA8E,KAAK,KAAL,CAAW,KAAzF,C;;;;uBACM,aAAa,CAAC,KAAK,KAAN,EAAa,IAAb,C;;;;;;;;mDACnB,KAAK,CAAC,MAAN,CAAa,KAAK,KAAlB,EAAyB,IAAzB,EAA+B,KAAK,QAApC,EAA8C,KAAK,WAAnD,EAAgE,KAAK,KAAL,CAAW,KAA3E,C;;;sBAEL,IAAI,QAAJ,CAAa,IAAb,C;;;;;;;;;;;;;;;;;;;kGAGI,I,EAAc,K;;;;;;uBAClB,KAAK,KAAL,CAAW,IAAX,EAAiB,KAAjB,EAAwB,EAAxB,EAA4B,IAA5B,C;;;mDACC,I;;;;;;;;;;;;;;;;;;;;qGAIM,K;;;;;qBACT,KAAK,Q;;;;;sBACC,IAAI,eAAJ,CAAoB,oBAApB,C;;;sBAEJ,IAAI,KAAJ,CAAU,yBAAV,C;;;;;;;;;;;;;;;;;;;uGAGS,I;;;;;;AACT,gBAAA,I,GAAO,KAAK,QAAL,CAAc,IAAd,C;;uBACA,aAAa,CAAC,KAAK,KAAN,EAAa,IAAb,C;;;;;;;;;;gCAAsB,aAAa,CAAC,KAAK,KAAN,EAAa,IAAb,C;;;;;;;;;;;;;;;;;;;;;4BAG5D;AACD,aAAO,WAAW,CAAC,IAAD,CAAlB;AACH;;;wBAzNc;AACX,UAAI,KAAK,IAAL,CAAU,MAAV,GAAmB,CAAvB,EAA0B;AACtB,YAAI,KAAK,IAAL,CAAU,CAAV,MAAiB,GAArB,EAA0B;AACtB,iBAAO,MAAM,KAAK,IAAlB;AACH;;AACD,eAAO,KAAK,IAAZ;AACH;;AACD,aAAO,GAAP;AACH;;;;;;;wBAKkB;AACf,UAAM,KAAK,GAAG,KAAK,IAAL,CAAU,KAAV,CAAgB,GAAhB,CAAd;AACA,aAAO,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAZ;AACH;;;;;;;wBAaoB;AACjB,UAAI,KAAK,WAAT,EAAsB;AAClB,eAAO,KAAK,WAAZ;AACH;;AACD,aAAO,KAAK,KAAZ;AACH;;;;iGAM0B,K;;;;;;;;;;;AAAc,gBAAA,I,iEAAsB,I;AAAM,gBAAA,Q,iEAAW,K;AAAO,gBAAA,U,iEAA2B,I;AAAM,gBAAA,U,iEAAa,I;;uBAC1G,KAAK,0BAAL,CAAgC,KAAhC,EAAuC,IAAvC,C;;;AAAjB,gBAAA,Q;mDACC,IAAI,KAAJ,CAAU,KAAV,EAAiB,IAAjB,EAAuB,QAAvB,EAAsD,QAAtD,EAAgE,UAAhE,EAA4E,UAA5E,C;;;;;;;;;;;;;;;;;;;qHAGqC,K,EAAc,I;;;;;;AAC1D,gBAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;AACM,gBAAA,S,GAAY,YAAY,CAAC,IAAD,C;;;uBAEG,KAAK,CAAC,OAAN,CAAc,SAAS,GAAG,cAA1B,C;;;AAAvB,gBAAA,c;mDACC,aAAa,CAAC,cAAD,C;;;;;;uBAEV,aAAa,CAAC,KAAD,EAAQ,IAAR,C;;;;;;;;sBACb,IAAI,kBAAJ,CAAuB,IAAvB,C;;;sBAEJ,IAAI,kBAAJ,CAAuB,IAAvB,C;;;;;;;;;;;;;;;;;;;;AAqKlB;;;;;;;;;;;SASsB,K;;;AAWtB;;;;;;;;;;;;;oEAXO,mBAAqB,KAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C,YAAA,IAA7C,iEAAmE,IAAnE;AAAyE,YAAA,UAAzE;AAA6F,YAAA,SAA7F,iEAAyG,KAAzG;AAAgH,YAAA,UAAhH,iEAA6H,IAA7H;AACH,YAAA,KAAK,GAAG,sBAAsB,CAAC,KAAD,CAA9B;AACA,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;AAFG,4BAIC,SAJD;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAIoB,aAAa,CAAC,KAAD,CAJjC;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAKO,SAAS,CAAC,KAAD,EAAQ,IAAR,EAAc,UAAd,EAA0B,SAA1B,CALhB;;AAAA;AAAA,+CAQI,KAAK,CAAC,MAAN,CAAa,KAAb,EAAoB,IAApB,EAA0B,KAA1B,EAAiC,UAAjC,EAA6C,UAA7C,CARJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAqBe,S;;;;;wEAAf,mBAAyB,KAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiD,YAAA,IAAjD,iEAAuE,IAAvE;AAA6E,YAAA,IAA7E,iEAAqG,GAArG;AAA0G,YAAA,UAA1G;AAA8H,YAAA,UAA9H,iEAA2I,IAA3I;AACH,YAAA,KAAK,GAAG,sBAAsB,CAAC,KAAD,CAA9B;;AACA,gBAAI,UAAU,KAAK,SAAnB,EAA8B;AAC1B,cAAA,UAAU,GAAG,sBAAsB,CAAC,KAAD,CAAnC;AACH;;AACD,YAAA,IAAI,GAAG,oBAAoB,CAAC,IAAD,CAA3B;;AALG,kBAOC,IAAI,KAAK,GAAT,IAAgB,IAAI,KAAK,IAP1B;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAQY,aAAa,CAAC,KAAD,EAAQ,IAAR,CARzB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBASe,aAAa,CAAC,KAAD,EAAQ,IAAR,CAT5B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAUe,IAAI,kBAAJ,CAAuB,IAAvB,CAVf;;AAAA;AAAA,kBAYW,IAAI,kBAAJ,CAAuB,IAAvB,CAZX;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAcQ,IAAI,KAAK,GAdjB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAeO,SAAS,CAAC,KAAD,EAAQ,IAAR,EAAc,UAAd,EAA0B,IAA1B,CAfhB;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAgBQ,IAAI,KAAK,GAhBjB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAiBY,aAAa,CAAC,KAAD,EAAQ,IAAR,CAjBzB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAkBe,aAAa,CAAC,KAAD,EAAQ,IAAR,CAlB5B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAmBe,IAAI,kBAAJ,CAAuB,IAAvB,CAnBf;;AAAA;AAAA;AAAA,mBAqBW,SAAS,CAAC,KAAD,EAAQ,IAAR,EAAc,UAAd,CArBpB;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAuBQ,IAAI,KAAK,IAAT,IAAkB,IAAY,KAAK,GAvB3C;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAwBW,aAAa,CAAC,KAAD,EAAQ,IAAR,CAxBxB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBAyBW,IAAI,kBAAJ,CAAuB,IAAvB,CAzBX;;AAAA;AAAA;AAAA,mBA0BkB,aAAa,CAAC,KAAD,EAAQ,IAAR,CA1B/B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,kBA2BW,IAAI,kBAAJ,CAAuB,IAAvB,CA3BX;;AAAA;AAAA;AAAA,mBA6BW,SAAS,CAAC,KAAD,EAAQ,IAAR,EAAc,UAAd,CA7BpB;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAgCO,IAAI,UAAJ,kCAAyC,IAAzC,EAhCP;;AAAA;AAmCG,YAAA,QAnCH,GAmCc,IAAI,KAAK,GAnCvB;AAAA,+CAoCI,KAAK,CAAC,MAAN,CAAa,KAAb,EAAoB,IAApB,EAA0B,QAA1B,EAAoC,UAApC,EAAgD,UAAhD,CApCJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;ICnRM,W;AAUT,yBAAA;AAAA;;AACI,SAAK,MAAL,GAAc,EAAd;AACH;;;;4BAEO,I,EAAY;AAChB,UAAI,CAAC,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,KAAK,MAA1C,EAAkD,IAAlD,CAAL,EAA8D;AAC1D,cAAM,IAAI,QAAJ,CAAa,IAAb,CAAN;AACH;;AACD,aAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;AACH;;;4BACO,I,EAAc,K,EAAQ;AAC1B,WAAK,MAAL,CAAY,IAAZ,IAAoB,KAApB;AACA,aAAO,IAAP;AACH;;;+BACU,I,EAAY;AACnB,aAAO,OAAO,KAAK,MAAL,CAAY,IAAZ,CAAd;AACH;;;iCACY,I,EAAY;AACrB,aAAO,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,KAAK,MAA1C,EAAkD,IAAlD,CAAP;AACH;;;4BACI;AACD,aAAO,WAAW,CAAC,IAAD,CAAlB;AACH;;;2BACG;AACA,aAAO,MAAM,CAAC,mBAAP,CAA2B,KAAK,MAAhC,CAAP;AACH","sourcesContent":["import type { Codec, CodecConstructor } from 'numcodecs';\n\ntype Config = Record<string, unknown>;\ntype CodecImporter = () => CodecConstructor<Config> | Promise<CodecConstructor<Config>>;\n\nconst registry: Map<string, CodecImporter> = new Map();\n\nexport function addCodec(id: string, importFn: CodecImporter) {\n  registry.set(id, importFn);\n}\n\nexport async function getCodec(config: Config & { id: string }): Promise<Codec> {\n  if (!registry.has(config.id)) {\n    throw new Error(`Compression codec ${config.id} is not supported by Zarr.js yet.`);\n  }\n  const codec = await registry.get(config.id)!();\n  return codec.fromConfig(config);\n}\n","/**\n * Closely resembles the functions on the MutableMapping type in Python.\n */\nexport interface MutableMapping<T, O=any> {\n    getItem(item: string, opts?: O): T;\n    setItem(item: string, value: T): boolean;\n    deleteItem(item: string): boolean;\n    containsItem(item: string): boolean;\n\n    proxy(): MutableMappingProxy<T>;\n\n    // length(): number;\n}\n\n/**\n * Closely resembles the functions on the MutableMapping type in Python.\n */\nexport interface AsyncMutableMapping<T, O=any> {\n    getItem(item: string, opts?: O): Promise<T>;\n    setItem(item: string, value: T): Promise<boolean>;\n    deleteItem(item: string): Promise<boolean>;\n    containsItem(item: string): Promise<boolean>;\n    // length(): number;\n}\n\nexport interface MutableMappingProxy<T> {\n    [key: string]: T;\n}\n\nexport interface AsyncMutableMappingProxy<T> {\n    [key: string]: T | Promise<T>;\n}\n\n\n/**\n * A proxy allows for accessing, setting and deleting the keys in the mutable mapping using\n * m[\"a\"] or even m.a notation.\n */\nexport function createProxy<S, T>(mapping: S & MutableMapping<T>): (S & MutableMappingProxy<T>);\nexport function createProxy<S, T>(mapping: S & AsyncMutableMapping<T>): (S & AsyncMutableMappingProxy<T>);\nexport function createProxy<S, T>(mapping: (S & MutableMapping<T>) | (S & AsyncMutableMapping<T>)): (S & MutableMappingProxy<T>) | (S & AsyncMutableMappingProxy<T>) {\n    return new Proxy(mapping as any, {\n        set(target, key, value, _receiver) {\n            return target.setItem(key as string, value);\n        },\n        get(target, key, _receiver) {\n            return target.getItem(key as string);\n        },\n        deleteProperty(target, key) {\n            return target.deleteItem(key as string);\n        },\n        has(target, key) {\n            return target.containsItem(key as string);\n        }\n    });\n}","export interface ZarrError {\n    __zarr__: string;\n}\n\nfunction isZarrError(err: unknown): err is ZarrError {\n    return typeof err === 'object' && err !== null && '__zarr__' in err;\n}\n\nexport function isKeyError(o: unknown) {\n    return isZarrError(o) && o.__zarr__ === 'KeyError';\n}\n\n// Custom error messages, note we have to patch the prototype of the\n// errors to fix `instanceof` calls, see:\n// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\nexport class ContainsArrayError extends Error implements ZarrError {\n    __zarr__ = 'ContainsArrayError';\n    constructor(path: string) {\n        super(`path ${path} contains an array`);\n        Object.setPrototypeOf(this, ContainsArrayError.prototype);\n    }\n}\n\nexport class ContainsGroupError extends Error implements ZarrError {\n    __zarr__ = 'ContainsGroupError';\n    constructor(path: string) {\n        super(`path ${path} contains a group`);\n        Object.setPrototypeOf(this, ContainsGroupError.prototype);\n    }\n}\n\nexport class ArrayNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'ArrayNotFoundError';\n    constructor(path: string) {\n        super(`array not found at path ${path}`);\n        Object.setPrototypeOf(this, ArrayNotFoundError.prototype);\n    }\n}\n\nexport class GroupNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'GroupNotFoundError';\n    constructor(path: string) {\n        super(`ground not found at path ${path}`);\n        Object.setPrototypeOf(this, GroupNotFoundError.prototype);\n    }\n}\n\nexport class PathNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'PathNotFoundError';\n    constructor(path: string) {\n        super(`nothing not found at path ${path}`);\n        Object.setPrototypeOf(this, PathNotFoundError.prototype);\n    }\n}\n\nexport class PermissionError extends Error implements ZarrError {\n    __zarr__ = 'PermissionError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, PermissionError.prototype);\n    }\n}\n\nexport class KeyError extends Error implements ZarrError {\n    __zarr__ = 'KeyError';\n    constructor(key: string) {\n        super(`key ${key} not present`);\n        Object.setPrototypeOf(this, KeyError.prototype);\n    }\n}\n\nexport class TooManyIndicesError extends RangeError implements ZarrError {\n    __zarr__ = 'TooManyIndicesError';\n    constructor(selection: any[], shape: number[]) {\n        super(`too many indices for array; expected ${shape.length}, got ${selection.length}`);\n        Object.setPrototypeOf(this, TooManyIndicesError.prototype);\n    }\n}\n\nexport class BoundsCheckError extends RangeError implements ZarrError {\n    __zarr__ = 'BoundsCheckError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, BoundsCheckError.prototype);\n    }\n}\n\nexport class InvalidSliceError extends RangeError implements ZarrError {\n    __zarr__ = 'InvalidSliceError';\n    constructor(from: any, to: any, stepSize: any, reason: any) {\n        super(`slice arguments slice(${from}, ${to}, ${stepSize}) invalid: ${reason}`);\n        Object.setPrototypeOf(this, InvalidSliceError.prototype);\n    }\n}\n\nexport class NegativeStepError extends Error implements ZarrError {\n    __zarr__ = 'NegativeStepError';\n    constructor() {\n        super(`Negative step size is not supported when indexing.`);\n        Object.setPrototypeOf(this, NegativeStepError.prototype);\n    }\n}\n\nexport class ValueError extends Error implements ZarrError {\n    __zarr__ = 'ValueError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, ValueError.prototype);\n    }\n}\n\nexport class HTTPError extends Error implements ZarrError {\n    __zarr__ = 'HTTPError';\n    constructor(code: string) {\n        super(code);\n        Object.setPrototypeOf(this, HTTPError.prototype);\n    }\n}\n","\nimport { InvalidSliceError } from '../errors';\nimport { Slice, SliceArgument, SliceIndices } from \"./types\";\n\nexport function slice(start: SliceArgument, stop: SliceArgument | undefined = undefined, step: number | null = null): Slice {\n    // tslint:disable-next-line: strict-type-predicates\n    if (start === undefined) { // Not possible in typescript\n        throw new InvalidSliceError(start, stop, step, \"The first argument must not be undefined\");\n    }\n\n    if ((typeof start === \"string\" && start !== \":\") || (typeof stop === \"string\" && stop !== \":\")) { // Note in typescript this will never happen with type checking.\n        throw new InvalidSliceError(start, stop, step, \"Arguments can only be integers, \\\":\\\" or null\");\n    }\n\n    // slice(5) === slice(null, 5)\n    if (stop === undefined) {\n        stop = start;\n        start = null;\n    }\n\n    // if (start !== null && stop !== null && start > stop) {\n    //     throw new InvalidSliceError(start, stop, step, \"to is higher than from\");\n    // }\n\n    return {\n        start: start === \":\" ? null : start,\n        stop: stop === \":\" ? null : stop,\n        step,\n        _slice: true,\n    };\n}\n\n\n/**\n * Port of adjustIndices\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L243\n */\nfunction adjustIndices(start: number, stop: number, step: number, length: number) {\n    if (start < 0) {\n        start += length;\n        if (start < 0) {\n            start = (step < 0) ? -1 : 0;\n        }\n    } else if (start >= length) {\n        start = (step < 0) ? length - 1 : length;\n    }\n\n    if (stop < 0) {\n        stop += length;\n        if (stop < 0) {\n            stop = (step < 0) ? -1 : 0;\n        }\n    } else if (stop >= length) {\n        stop = (step < 0) ? length - 1 : length;\n    }\n\n    if (step < 0) {\n        if (stop < start) {\n            const length = Math.floor((start - stop - 1) / (-step) + 1);\n            return [start, stop, step, length];\n        }\n    } else {\n        if (start < stop) {\n            const length = Math.floor((stop - start - 1) / step + 1);\n            return [start, stop, step, length];\n        }\n    }\n    return [start, stop, step, 0];\n}\n\n/**\n * Port of slice.indices(n) and PySlice_Unpack\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L166\n *  https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L198 \n * \n * Behaviour might be slightly different as it's a weird hybrid implementation.\n */\nexport function sliceIndices(slice: Slice, length: number): SliceIndices {\n    let start: number;\n    let stop: number;\n    let step: number;\n\n    if (slice.step === null) {\n        step = 1;\n    } else {\n        step = slice.step;\n    }\n\n    if (slice.start === null) {\n        start = step < 0 ? Number.MAX_SAFE_INTEGER : 0;\n    } else {\n        start = slice.start;\n        if (start < 0) {\n            start += length;\n        }\n    }\n\n    if (slice.stop === null) {\n        stop = step < 0 ? -Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;\n    } else {\n        stop = slice.stop;\n        if (stop < 0) {\n            stop += length;\n        }\n    }\n\n    // This clips out of bounds slices\n    const s = adjustIndices(start, stop, step, length);\n    start = s[0];\n    stop = s[1];\n    step = s[2];\n    // The output length\n    length = s[3];\n\n\n    // With out of bounds slicing these two assertions are not useful.\n    // if (stop > length) throw new Error(\"Stop greater than length\");\n    // if (start >= length) throw new Error(\"Start greater than or equal to length\");\n\n    if (step === 0) throw new Error(\"Step size 0 is invalid\");\n\n    return [start, stop, step, length];\n}","import { TooManyIndicesError, BoundsCheckError, NegativeStepError } from '../errors';\nimport { ZarrArray } from './index';\nimport { Slice, ArraySelection, ChunkDimProjection, Indexer, DimIndexer, ChunkProjection, NormalizedArraySelection, SliceIndices, DimensionArraySelection } from './types';\nimport { sliceIndices, slice } from \"./slice\";\n\nfunction ensureArray(selection: ArraySelection): DimensionArraySelection[] {\n    if (!Array.isArray(selection)) {\n        return [selection];\n    }\n    return selection;\n}\n\nfunction checkSelectionLength(selection: DimensionArraySelection[], shape: number[]) {\n    if (selection.length > shape.length) {\n        throw new TooManyIndicesError(selection, shape);\n    }\n}\n\n/**\n * Returns both the sliceIndices per dimension and the output shape after slicing.\n */\nexport function selectionToSliceIndices(selection: NormalizedArraySelection, shape: number[]): [(number | SliceIndices)[], number[]] {\n    const sliceIndicesResult = [];\n    const outShape = [];\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (typeof s === \"number\") {\n            sliceIndicesResult.push(s);\n        } else {\n            const x = sliceIndices(s, shape[i]);\n            const dimLength = x[3];\n\n            outShape.push(dimLength);\n            sliceIndicesResult.push(x);\n        }\n    }\n\n    return [sliceIndicesResult, outShape];\n}\n\n/**\n * This translates \"...\", \":\", null into a list of slices or non-negative integer selections of length shape\n */\nexport function normalizeArraySelection(selection: ArraySelection | number, shape: number[], convertIntegerSelectionToSlices = false): NormalizedArraySelection {\n    selection = replaceEllipsis(selection, shape);\n\n    for (let i = 0; i < selection.length; i++) {\n        const dimSelection = selection[i];\n\n        if (typeof dimSelection === \"number\") {\n            if (convertIntegerSelectionToSlices) {\n                selection[i] = slice(dimSelection, dimSelection + 1, 1);\n            } else {\n                selection[i] = normalizeIntegerSelection(dimSelection, shape[i]);\n            }\n        } else if (isIntegerArray(dimSelection)) {\n            throw new TypeError(\"Integer array selections are not supported (yet)\");\n        } else if (dimSelection === \":\" || dimSelection === null) {\n            selection[i] = slice(null, null, 1);\n        }\n    }\n\n    return selection as NormalizedArraySelection;\n}\n\nexport function replaceEllipsis(selection: ArraySelection | number, shape: number[]) {\n    selection = ensureArray(selection);\n\n    let ellipsisIndex = -1;\n    let numEllipsis = 0;\n    for (let i = 0; i < selection.length; i++) {\n        if (selection[i] === \"...\") {\n            ellipsisIndex = i;\n            numEllipsis += 1;\n        }\n    }\n\n    if (numEllipsis > 1) {\n        throw new RangeError(\"an index can only have a single ellipsis ('...')\");\n    }\n    if (numEllipsis === 1) {\n        // count how many items to left and right of ellipsis\n        const numItemsLeft = ellipsisIndex;\n        const numItemsRight = selection.length - (numItemsLeft + 1);\n        const numItems = selection.length - 1; // All non-ellipsis items\n        if (numItems >= shape.length) {\n            // Ellipsis does nothing, just remove it\n            selection = selection.filter((x) => x !== \"...\");\n        } else {\n            // Replace ellipsis with as many slices are needed for number of dims\n            const numNewItems = shape.length - numItems;\n            let newItem = selection.slice(0, numItemsLeft).concat(new Array(numNewItems).fill(null));\n            if (numItemsRight > 0) {\n                newItem = newItem.concat(selection.slice(selection.length - numItemsRight));\n            }\n            selection = newItem;\n        }\n    }\n    // Fill out selection if not completely specified\n    if (selection.length < shape.length) {\n        const numMissing = shape.length - selection.length;\n        selection = selection.concat(new Array(numMissing).fill(null));\n    }\n\n    checkSelectionLength(selection, shape);\n    return selection;\n}\n\nexport function normalizeIntegerSelection(dimSelection: number, dimLength: number): number {\n    // Note: Maybe we should convert to integer or warn if dimSelection is not an integer\n\n    // handle wraparound\n    if (dimSelection < 0) {\n        dimSelection = dimLength + dimSelection;\n    }\n\n    // handle out of bounds\n    if (dimSelection >= dimLength || dimSelection < 0) {\n        throw new BoundsCheckError(`index out of bounds for dimension with length ${dimLength}`);\n    }\n\n    return dimSelection;\n}\n\nfunction isInteger(s: any) {\n    return typeof s === \"number\";\n}\n\nexport function isIntegerArray(s: any) {\n    if (!Array.isArray(s)) {\n        return false;\n    }\n    for (const e of s) {\n        if (typeof e !== \"number\") {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function isSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    if (s !== null && (s as any)[\"_slice\"] === true) {\n        return true;\n    }\n    return false;\n}\n\nfunction isContiguousSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    return isSlice(s) && ((s as Slice).step === null || (s as Slice).step === 1);\n}\n\nfunction isPositiveSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    return isSlice(s) && ((s as Slice).step === null || ((s as Slice).step as number) >= 1);\n}\n\nexport function isContiguousSelection(selection: ArraySelection) {\n    selection = ensureArray(selection);\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (!(isIntegerArray(s) || isContiguousSlice(s) || s === \"...\")) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction isBasicSelection(selection: ArraySelection): boolean {\n    selection = ensureArray(selection);\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (!(isInteger(s) || isPositiveSlice(s))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction* product<T>(...iterables: (() => IterableIterator<T>)[]): IterableIterator<T[]> {\n    if (iterables.length === 0) { return; }\n    // make a list of iterators from the iterables\n    const iterators = iterables.map(it => it());\n    const results = iterators.map(it => it.next());\n\n    // Disabled to allow empty inputs\n    // if (results.some(r => r.done)) {\n    //     throw new Error(\"Input contains an empty iterator.\");\n    // }\n\n    for (let i = 0; ;) {\n        if (results[i].done) {\n            // reset the current iterator\n            iterators[i] = iterables[i]();\n            results[i] = iterators[i].next();\n            // advance, and exit if we've reached the end\n            if (++i >= iterators.length) { return; }\n        } else {\n            yield results.map(({ value }) => value);\n            i = 0;\n        }\n        results[i] = iterators[i].next();\n    }\n}\n\nexport class BasicIndexer implements Indexer {\n    dimIndexers: DimIndexer[];\n    shape: number[];\n    dropAxes: null;\n\n    constructor(selection: ArraySelection, array: ZarrArray) {\n        selection = normalizeArraySelection(selection, array.shape);\n\n        // Setup per-dimension indexers\n        this.dimIndexers = [];\n        const arrayShape = array.shape;\n        for (let i = 0; i < arrayShape.length; i++) {\n            let dimSelection = selection[i];\n            const dimLength = arrayShape[i];\n            const dimChunkLength = array.chunks[i];\n\n            if (dimSelection === null) {\n                dimSelection = slice(null);\n            }\n\n\n            if (isInteger(dimSelection)) {\n                this.dimIndexers.push(new IntDimIndexer(dimSelection as number, dimLength, dimChunkLength));\n            } else if (isSlice(dimSelection)) {\n                this.dimIndexers.push(new SliceDimIndexer(dimSelection as Slice, dimLength, dimChunkLength));\n            } else {\n                throw new RangeError(`Unspported selection item for basic indexing; expected integer or slice, got ${dimSelection}`);\n            }\n        }\n\n        this.shape = [];\n        for (const d of this.dimIndexers) {\n            if (d instanceof SliceDimIndexer) {\n                this.shape.push(d.numItems);\n            }\n        }\n        this.dropAxes = null;\n    }\n\n    * iter() {\n        const dimIndexerIterables = this.dimIndexers.map(x => (() => x.iter()));\n        const dimIndexerProduct = product(...dimIndexerIterables);\n\n        for (const dimProjections of dimIndexerProduct) {\n            // TODO fix this, I think the product outputs too many combinations\n            const chunkCoords = [];\n            const chunkSelection = [];\n            const outSelection = [];\n\n            for (const p of dimProjections) {\n                chunkCoords.push((p).dimChunkIndex);\n                chunkSelection.push((p).dimChunkSelection);\n                if ((p).dimOutSelection !== null) {\n                    outSelection.push((p).dimOutSelection);\n                }\n            }\n\n            yield ({\n                chunkCoords,\n                chunkSelection,\n                outSelection,\n            } as ChunkProjection);\n        }\n\n    }\n}\n\nclass IntDimIndexer implements DimIndexer {\n    dimSelection: number;\n    dimLength: number;\n    dimChunkLength: number;\n    numItems: number;\n\n    constructor(dimSelection: number, dimLength: number, dimChunkLength: number) {\n        dimSelection = normalizeIntegerSelection(dimSelection, dimLength);\n        this.dimSelection = dimSelection;\n        this.dimLength = dimLength;\n        this.dimChunkLength = dimChunkLength;\n        this.numItems = 1;\n    }\n\n    * iter() {\n        const dimChunkIndex = Math.floor(this.dimSelection / this.dimChunkLength);\n        const dimOffset = dimChunkIndex * this.dimChunkLength;\n        const dimChunkSelection = this.dimSelection - dimOffset;\n        const dimOutSelection = null;\n        yield {\n            dimChunkIndex,\n            dimChunkSelection,\n            dimOutSelection,\n        } as ChunkDimProjection;\n    }\n}\n\nclass SliceDimIndexer implements DimIndexer {\n    dimLength: number;\n    dimChunkLength: number;\n    numItems: number;\n    numChunks: number;\n\n    start: number;\n    stop: number;\n    step: number;\n\n    constructor(dimSelection: Slice, dimLength: number, dimChunkLength: number) {\n        // Normalize\n        const [start, stop, step] = sliceIndices(dimSelection, dimLength);\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n        if (this.step < 1) {\n            throw new NegativeStepError();\n        }\n\n        this.dimLength = dimLength;\n        this.dimChunkLength = dimChunkLength;\n        this.numItems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n        this.numChunks = Math.ceil(this.dimLength / this.dimChunkLength);\n    }\n\n    *iter() {\n        const dimChunkIndexFrom = Math.floor(this.start / this.dimChunkLength);\n        const dimChunkIndexTo = Math.ceil(this.stop / this.dimChunkLength);\n\n        // Iterate over chunks in range\n        for (let dimChunkIndex = dimChunkIndexFrom; dimChunkIndex < dimChunkIndexTo; dimChunkIndex++) {\n\n            // Compute offsets for chunk within overall array\n            const dimOffset = dimChunkIndex * this.dimChunkLength;\n            const dimLimit = Math.min(this.dimLength, (dimChunkIndex + 1) * this.dimChunkLength);\n\n            // Determine chunk length, accounting for trailing chunk\n            const dimChunkLength = dimLimit - dimOffset;\n\n            let dimChunkSelStart: number;\n            let dimChunkSelStop: number;\n            let dimOutOffset: number;\n\n            if (this.start < dimOffset) {\n                // Selection starts before current chunk\n\n                dimChunkSelStart = 0;\n                const remainder = (dimOffset - this.start) % this.step;\n                if (remainder > 0) {\n                    dimChunkSelStart += this.step - remainder;\n                }\n                // Compute number of previous items, provides offset into output array\n                dimOutOffset = Math.ceil((dimOffset - this.start) / this.step);\n            } else {\n                // Selection starts within current chunk\n                dimChunkSelStart = this.start - dimOffset;\n                dimOutOffset = 0;\n            }\n\n            if (this.stop > dimLimit) {\n                // Selection ends after current chunk\n                dimChunkSelStop = dimChunkLength;\n            } else {\n                // Selection ends within current chunk\n                dimChunkSelStop = this.stop - dimOffset;\n            }\n\n            const dimChunkSelection = slice(dimChunkSelStart, dimChunkSelStop, this.step);\n            const dimChunkNumItems = Math.ceil((dimChunkSelStop - dimChunkSelStart) / this.step);\n            const dimOutSelection = slice(dimOutOffset, dimOutOffset + dimChunkNumItems);\n            yield {\n                dimChunkIndex,\n                dimChunkSelection,\n                dimOutSelection,\n            } as ChunkDimProjection;\n        }\n\n    }\n\n}\n","import { Order, FillType, ChunksArgument, DtypeString } from \"./types\";\n\nimport { DimensionSelection, Slice } from \"./core/types\";\nimport { isSlice } from \"./core/indexing\";\nimport { TypedArray } from \"./nestedArray/types\";\n\n/**\n * This should be true only if this javascript is getting executed in Node.\n */\nexport const IS_NODE = typeof process !== \"undefined\" && process.versions && process.versions.node;\n\nexport function humanReadableSize(size: number) {\n    if (size < 2 ** 10) {\n        return `${size}`;\n    }\n    else if (size < 2 ** 20) {\n        return `${(size / (2 ** 10)).toFixed(1)}K`;\n    }\n    else if (size < 2 ** 30) {\n        return `${(size / (2 ** 20)).toFixed(1)}M`;\n    }\n    else if (size < 2 ** 40) {\n        return `${(size / (2 ** 30)).toFixed(1)}G`;\n    }\n    else if (size < 2 ** 50) {\n        return `${(size / (2 ** 40)).toFixed(1)}T`;\n    }\n    return `${(size / (2 ** 50)).toFixed(1)}P`;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function normalizeStoragePath(path: string | String | null): string {\n    if (path === null) {\n        return \"\";\n    }\n\n    if (path instanceof String) {\n        path = path.valueOf();\n    }\n\n    // convert backslash to forward slash\n    path = path.replace(/\\\\/g, \"/\");\n    // ensure no leading slash\n    while (path.length > 0 && path[0] === '/') {\n        path = path.slice(1);\n    }\n\n    // ensure no trailing slash\n    while (path.length > 0 && path[path.length - 1] === '/') {\n        path = path.slice(0, path.length - 1);\n    }\n\n\n    // collapse any repeated slashes\n    path = path.replace(/\\/\\/+/g, \"/\");\n\n    // don't allow path segments with just '.' or '..'\n    const segments = path.split('/');\n\n    for (const s of segments) {\n        if (s === \".\" || s === \"..\") {\n            throw Error(\"path containing '.' or '..' segment not allowed\");\n        }\n    }\n    return path as string;\n}\n\nexport function normalizeShape(shape: number | number[]): number[] {\n    if (typeof shape === \"number\") {\n        shape = [shape];\n    }\n    return shape.map(x => Math.floor(x));\n}\n\nexport function normalizeChunks(chunks: ChunksArgument, shape: number[]): number[] {\n    // Assume shape is already normalized\n\n    if (chunks === null || chunks === true) {\n        throw new Error(\"Chunk guessing is not supported yet\");\n    }\n\n    if (chunks === false) {\n        return shape;\n    }\n\n    if (typeof chunks === \"number\") {\n        chunks = [chunks];\n    }\n\n    // handle underspecified chunks\n    if (chunks.length < shape.length) {\n        // assume chunks across remaining dimensions\n        chunks = chunks.concat(shape.slice(chunks.length));\n    }\n\n    return chunks.map((x, idx) => {\n        // handle null or -1 in chunks\n        if (x === -1 || x === null) {\n            return shape[idx];\n        } else {\n            return Math.floor(x);\n        }\n    });\n}\n\nexport function normalizeOrder(order: string): Order {\n    order = order.toUpperCase();\n    return order as Order;\n}\n\nexport function normalizeDtype(dtype: DtypeString): DtypeString {\n    return dtype;\n}\n\nexport function normalizeFillValue(fillValue: FillType): FillType {\n    return fillValue;\n}\n\n/**\n * Determine whether `item` specifies a complete slice of array with the\n *  given `shape`. Used to optimize __setitem__ operations on chunks\n * @param item\n * @param shape\n */\nexport function isTotalSlice(item: DimensionSelection | DimensionSelection[], shape: number[]): boolean {\n    if (item === null) {\n        return true;\n    }\n    if (!Array.isArray(item)) {\n        item = [item];\n    }\n\n    for (let i = 0; i < Math.min(item.length, shape.length); i++) {\n        const it = item[i];\n        if (it === null) continue;\n\n        if (isSlice(it)) {\n            const s = it as Slice;\n            const isStepOne = s.step === 1 || s.step === null;\n\n            if (s.start === null && s.stop === null && isStepOne) {\n                continue;\n            }\n            if (((s.stop as number) - (s.start as number)) === shape[i] && isStepOne) {\n                continue;\n            }\n            return false;\n        }\n        return false;\n\n\n        // } else {\n        //     console.error(`isTotalSlice unexpected non-slice, got ${it}`);\n        //     return false;\n        // }\n    }\n    return true;\n}\n\n/**\n * Checks for === equality of all elements.\n */\nexport function arrayEquals1D(a: ArrayLike<any>, b: ArrayLike<any>) {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/*\n * Determines \"C\" order strides for a given shape array.\n * Strides provide integer steps in each dimention to traverse an ndarray.\n *\n * NOTE: - These strides here are distinct from numpy.ndarray.strides, which describe actual byte steps.\n *       - Strides are assumed to be contiguous, so initial step is 1. Thus, output will always be [XX, XX, 1].\n */\nexport function getStrides(shape: number[]): number[] {\n    // adapted from https://github.com/scijs/ndarray/blob/master/ndarray.js#L326-L330\n    const ndim = shape.length;\n    const strides = Array(ndim);\n    let step = 1; // init step\n    for (let i = ndim - 1; i >= 0; i--) {\n        strides[i] = step;\n        step *= shape[i];\n    }\n    return strides;\n}\n\n/**\n * Preserves (double) slashes earlier in the path, so this works better\n * for URLs. From https://stackoverflow.com/a/46427607/4178400\n * @param args parts of a path or URL to join.\n */\nexport function joinUrlParts(...args: string[]) {\n    return args.map((part, i) => {\n        if (i === 0) {\n          return part.trim().replace(/[\\/]*$/g, '');\n        } else {\n          return part.trim().replace(/(^[\\/]*|[\\/]*$)/g, '');\n        }\n      }).filter(x=>x.length).join('/');\n}\n\n\n/**\n * Swaps byte order in-place for a given TypedArray.\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\n * @param src TypedArray\n */\nexport function byteSwapInplace(src: TypedArray): void {\n  const b = src.BYTES_PER_ELEMENT;\n  if (b === 1) return; // no swapping needed\n  if (IS_NODE) {\n    // Use builtin methods for swapping if in Node environment\n    const bytes = Buffer.from(src.buffer, src.byteOffset, src.length * b);\n    if (b === 2) bytes.swap16();\n    if (b === 4) bytes.swap32();\n    if (b === 8) bytes.swap64();\n    return;\n  }\n  // In browser, need to flip manually\n  // Adapted from https://github.com/zbjornson/node-bswap/blob/master/bswap.js\n  const flipper = new Uint8Array(src.buffer, src.byteOffset, src.length * b);\n  const numFlips = b / 2;\n  const endByteIndex = b - 1;\n  let t: number;\n  for (let i = 0; i < flipper.length; i += b) {\n    for (let j = 0; j < numFlips; j++) {\n      t = flipper[i + j];\n      flipper[i + j] = flipper[i + endByteIndex - j];\n      flipper[i + endByteIndex - j] = t;\n    }\n  }\n}\n\n/**\n * Creates a copy of a TypedArray and swaps bytes.\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\n * @param src TypedArray\n */\nexport function byteSwap(src: TypedArray): TypedArray {\n    const copy = src.slice();\n    byteSwapInplace(copy);\n    return copy;\n}\n","export const ARRAY_META_KEY = \".zarray\";\nexport const GROUP_META_KEY = \".zgroup\";\nexport const ATTRS_META_KEY = \".zattrs\";\n","import { normalizeStoragePath, normalizeChunks, normalizeDtype, normalizeShape, normalizeOrder, normalizeFillValue } from '../util';\nimport { Store } from './types';\nimport { ARRAY_META_KEY, GROUP_META_KEY } from '../names';\nimport { FillType, Order, Filter, CompressorConfig, ZarrGroupMetadata, ChunksArgument, DtypeString, ZarrArrayMetadata, FillTypeSerialized } from '../types';\nimport { ContainsArrayError, ContainsGroupError } from '../errors';\n\n\n/**\n * Return true if the store contains an array at the given logical path.\n */\nexport async function containsArray(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    const prefix = pathToPrefix(path);\n    const key = prefix + ARRAY_META_KEY;\n    return store.containsItem(key);\n}\n\n/**\n * Return true if the store contains a group at the given logical path.\n */\nexport async function containsGroup(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    const prefix = pathToPrefix(path);\n    const key = prefix + GROUP_META_KEY;\n    return store.containsItem(key);\n}\n\n\nexport function pathToPrefix(path: string): string {\n    // assume path already normalized\n    if (path.length > 0) {\n        return path + '/';\n    }\n    return '';\n}\n\nasync function listDirFromKeys(store: Store, path: string) {\n    // assume path already normalized\n    const prefix = pathToPrefix(path);\n    const children = new Set<string>();\n\n    for (const key in await store.keys()) {\n        if (key.startsWith(prefix) && key.length > prefix.length) {\n            const suffix = key.slice(prefix.length);\n            const child = suffix.split('/')[0];\n            children.add(child);\n        }\n    }\n    return Array.from(children).sort();\n}\n\nasync function requireParentGroup(store: Store, path: string, chunkStore: Store | null, overwrite: boolean) {\n    // Assume path is normalized\n    if (path.length === 0) {\n        return;\n    }\n\n    const segments = path.split(\"/\");\n    let p = \"\";\n    for (const s of segments.slice(0, segments.length - 1)) {\n        p += s;\n        if (await containsArray(store, p)) {\n            await initGroupMetadata(store, p, overwrite);\n        } else if (!await containsGroup(store, p)) {\n            await initGroupMetadata(store, p);\n        }\n        p += \"/\";\n    }\n}\n\n/**\n * Obtain a directory listing for the given path. If `store` provides a `listDir`\n *  method, this will be called, otherwise will fall back to implementation via the\n *  `MutableMapping` interface.\n * @param store \n */\nexport async function listDir(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    if (store.listDir) {\n        return store.listDir(path);\n    } else {\n        return listDirFromKeys(store, path);\n    }\n}\n\nasync function initGroupMetadata(store: Store, path: string | null = null, overwrite = false) {\n    path = normalizeStoragePath(path);\n\n    // Guard conditions\n    if (overwrite) {\n        throw Error(\"Group overwriting not implemented yet :(\");\n    } else if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n    }\n\n    const metadata: ZarrGroupMetadata = { zarr_format: 2 };\n    const key = pathToPrefix(path) + GROUP_META_KEY;\n    await store.setItem(key, JSON.stringify(metadata));\n}\n/**\n *  Initialize a group store. Note that this is a low-level function and there should be no\n *  need to call this directly from user code.\n */\nexport async function initGroup(store: Store, path: string | null = null, chunkStore: null | Store = null, overwrite = false) {\n    path = normalizeStoragePath(path);\n    await requireParentGroup(store, path, chunkStore, overwrite);\n    await initGroupMetadata(store, path, overwrite);\n}\n\nasync function initArrayMetadata(\n    store: Store,\n    shape: number | number[],\n    chunks: ChunksArgument,\n    dtype: DtypeString,\n    path: string,\n    compressor: null | CompressorConfig,\n    fillValue: FillType,\n    order: Order,\n    overwrite: boolean,\n    chunkStore: null | Store,\n    filters: null | Filter[],\n    dimensionSeparator?: '.' | '/',\n) {\n    // Guard conditions\n    if (overwrite) {\n        throw Error(\"Array overwriting not implemented yet :(\");\n    } else if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n    }\n\n    // Normalize metadata,  does type checking too.\n    dtype = normalizeDtype(dtype);\n    shape = normalizeShape(shape);\n    chunks = normalizeChunks(chunks, shape);\n    order = normalizeOrder(order);\n    fillValue = normalizeFillValue(fillValue);\n\n    if (filters !== null && filters.length > 0) {\n        throw Error(\"Filters are not supported yet\");\n    }\n\n    let serializedFillValue: FillTypeSerialized = fillValue;\n\n    if (typeof fillValue === \"number\") {\n        if (Number.isNaN(fillValue)) serializedFillValue = \"NaN\";\n        if (Number.POSITIVE_INFINITY === fillValue) serializedFillValue = \"Infinity\";\n        if (Number.NEGATIVE_INFINITY === fillValue) serializedFillValue = \"-Infinity\";\n    }\n\n    filters = null;\n\n    const metadata: ZarrArrayMetadata = {\n        zarr_format: 2,\n        shape: shape,\n        chunks: chunks as number[],\n        dtype: dtype,\n        fill_value: serializedFillValue,\n        order: order,\n        compressor: compressor,\n        filters: filters,\n    };\n    if (dimensionSeparator) {\n        metadata.dimension_separator = dimensionSeparator;\n    }\n    const metaKey = pathToPrefix(path) + ARRAY_META_KEY;\n    await store.setItem(metaKey, JSON.stringify(metadata));\n}\n\n/**\n * \n * Initialize an array store with the given configuration. Note that this is a low-level\n * function and there should be no need to call this directly from user code\n */\nexport async function initArray(\n    store: Store,\n    shape: number | number[],\n    chunks: ChunksArgument,\n    dtype: DtypeString,\n    path: string | null = null,\n    compressor: null | CompressorConfig = null,\n    fillValue: FillType = null,\n    order: Order = \"C\",\n    overwrite = false,\n    chunkStore: null | Store = null,\n    filters: null | Filter[] = null,\n    dimensionSeparator?: '.' | '/',\n) {\n\n    path = normalizeStoragePath(path);\n    await requireParentGroup(store, path, chunkStore, overwrite);\n    await initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n}\n","import { ZarrMetadataType, UserAttributes } from './types';\nimport { ValidStoreType } from './storage/types';\nimport { IS_NODE } from './util';\n\nexport function parseMetadata(\n    s: ValidStoreType | ZarrMetadataType\n): ZarrMetadataType | UserAttributes {\n    // Here we allow that a store may return an already-parsed metadata object,\n    // or a string of JSON that we will parse here. We allow for an already-parsed\n    // object to accommodate a consolidated metadata store, where all the metadata for\n    // all groups and arrays will already have been parsed from JSON.\n    if (typeof s !== 'string') {\n        // tslint:disable-next-line: strict-type-predicates\n        if (IS_NODE && Buffer.isBuffer(s)) {\n            return JSON.parse(s.toString());\n        } else if (s instanceof ArrayBuffer) {\n            const utf8Decoder = new TextDecoder();\n            const bytes = new Uint8Array(s);\n            return JSON.parse(utf8Decoder.decode(bytes));\n        } else {\n            return s;\n        }\n    }\n    return JSON.parse(s);\n}\n","import { createProxy, AsyncMutableMapping, AsyncMutableMappingProxy } from './mutableMapping';\nimport { Store } from './storage/types';\nimport { parseMetadata } from './metadata';\nimport { UserAttributes } from './types';\nimport { PermissionError } from './errors';\n\n/**\n * Class providing access to user attributes on an array or group. Should not be\n * instantiated directly, will be available via the `.attrs` property of an array or\n * group.\n */\nexport class Attributes<M extends UserAttributes> implements AsyncMutableMapping<any> {\n    store: Store;\n    key: string;\n    readOnly: boolean;\n    cache: boolean;\n    private cachedValue: M | null;\n\n    constructor(store: Store, key: string, readOnly: boolean, cache = true) {\n        this.store = store;\n        this.key = key;\n        this.readOnly = readOnly;\n        this.cache = cache;\n        this.cachedValue = null;\n    }\n\n    /**\n     * Retrieve all attributes as a JSON object.\n     */\n    public async asObject() {\n        if (this.cache && this.cachedValue !== null) {\n            return this.cachedValue;\n        }\n        const o = await this.getNoSync();\n        if (this.cache) {\n            this.cachedValue = o;\n        }\n        return o;\n    }\n\n    private async getNoSync(): Promise<M> {\n        try {\n            const data = await this.store.getItem(this.key);\n            // TODO fix typing?\n            return parseMetadata(data) as M;\n        } catch (error) {\n            return {} as M;\n        }\n    }\n\n    private async setNoSync(key: string, value: any) {\n        const d = await this.getNoSync();\n        (d as any)[key] = value;\n        await this.putNoSync(d);\n        return true;\n    }\n\n    private async putNoSync(m: M) {\n        await this.store.setItem(this.key, JSON.stringify(m));\n        if (this.cache) {\n            this.cachedValue = m;\n        }\n    }\n\n    private async delNoSync(key: string): Promise<boolean> {\n        const d = await this.getNoSync();\n        delete (d as any)[key];\n        await this.putNoSync(d);\n        return true;\n    }\n\n    /**\n     * Overwrite all attributes with the provided object in a single operation\n     */\n    async put(d: M) {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.putNoSync(d);\n    }\n\n    async setItem(key: string, value: any): Promise<boolean> {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.setNoSync(key, value);\n    }\n\n    async getItem(key: string) {\n        return ((await this.asObject()) as any)[key];\n    }\n\n    async deleteItem(key: string) {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.delNoSync(key);\n    }\n\n    async containsItem(key: string) {\n        return ((await this.asObject()) as any)[key] !== undefined;\n    }\n\n    proxy(): AsyncMutableMappingProxy<any> {\n        return createProxy(this);\n    }\n}","import { DtypeString } from '../types';\nimport { ValueError } from '../errors';\n\nexport type NestedArrayData = TypedArray | NDNestedArrayData;\nexport type NDNestedArrayData =\n  | TypedArray[]\n  | TypedArray[][]\n  | TypedArray[][][]\n  | TypedArray[][][][]\n  | TypedArray[][][][][]\n  | TypedArray[][][][][][];\n\nexport type TypedArray =\n  | Uint8Array\n  | Int8Array\n  | Uint16Array\n  | Int16Array\n  | Uint32Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\nexport type TypedArrayConstructor<T extends TypedArray> = {\n  new(): T;\n  // tslint:disable-next-line: unified-signatures\n  new(size: number): T;\n  // tslint:disable-next-line: unified-signatures\n  new(buffer: ArrayBuffer): T;\n  BYTES_PER_ELEMENT: number;\n};\n\nconst DTYPE_TYPEDARRAY_MAPPING: { [A in DtypeString]: TypedArrayConstructor<TypedArray> } = {\n  '|b': Int8Array,\n  '|B': Uint8Array,\n  '|u1': Uint8Array,\n  '|i1': Int8Array,\n  '<b': Int8Array,\n  '<B': Uint8Array,\n  '<u1': Uint8Array,\n  '<i1': Int8Array,\n  '<u2': Uint16Array,\n  '<i2': Int16Array,\n  '<u4': Uint32Array,\n  '<i4': Int32Array,\n  '<f4': Float32Array,\n  '<f8': Float64Array,\n  '>b': Int8Array,\n  '>B': Uint8Array,\n  '>u1': Uint8Array,\n  '>i1': Int8Array,\n  '>u2': Uint16Array,\n  '>i2': Int16Array,\n  '>u4': Uint32Array,\n  '>i4': Int32Array,\n  '>f4': Float32Array,\n  '>f8': Float64Array\n};\n\n\nexport function getTypedArrayCtr(dtype: DtypeString) {\n  const ctr = DTYPE_TYPEDARRAY_MAPPING[dtype];\n  if (!ctr) {\n    throw Error(`Dtype not recognized or not supported in zarr.js, got ${dtype}.`);\n  }\n  return ctr;\n}\n\n/*\n * Called by NestedArray and RawArray constructors only.\n * We byte-swap the buffer of a store after decoding\n * since TypedArray views are little endian only.\n *\n * This means NestedArrays and RawArrays will always be little endian,\n * unless a numpy-like library comes around and can handle endianess\n * for buffer views.\n */\nexport function getTypedArrayDtypeString(t: TypedArray): DtypeString {\n  // Favour the types below instead of small and big B\n  if (t instanceof Uint8Array) return '|u1';\n  if (t instanceof Int8Array) return '|i1';\n  if (t instanceof Uint16Array) return '<u2';\n  if (t instanceof Int16Array) return '<i2';\n  if (t instanceof Uint32Array) return '<u4';\n  if (t instanceof Int32Array) return '<i4';\n  if (t instanceof Float32Array) return '<f4';\n  if (t instanceof Float64Array) return '<f8';\n  throw new ValueError('Mapping for TypedArray to Dtypestring not known');\n}\n","import { ArraySelection, SliceIndices } from '../core/types';\nimport { ValueError } from '../errors';\nimport { TypedArray, TypedArrayConstructor, NestedArrayData, NDNestedArrayData } from './types';\nimport { normalizeArraySelection, selectionToSliceIndices } from '../core/indexing';\n\n/**\n * Digs down into the dimensions of given array to find the TypedArray and returns its constructor.\n * Better to use sparingly.\n */\nexport function getNestedArrayConstructor<T extends TypedArray>(arr: any): TypedArrayConstructor<T> {\n    // TODO fix typing\n    // tslint:disable-next-line: strict-type-predicates\n    if ((arr as TypedArray).byteLength !== undefined) {\n        return (arr).constructor;\n    }\n    return getNestedArrayConstructor(arr[0]);\n}\n\n/**\n * Returns both the slice result and new output shape\n * @param arr NestedArray to slice\n * @param shape The shape of the NestedArray\n * @param selection\n */\nexport function sliceNestedArray(arr: NestedArrayData, shape: number[], selection: number | ArraySelection): [NestedArrayData | number, number[]] {\n    // This translates \"...\", \":\", null into a list of slices or integer selections\n    const normalizedSelection = normalizeArraySelection(selection, shape);\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, shape);\n    const outArray = _sliceNestedArray(arr, shape, sliceIndices);\n    return [outArray, outShape];\n}\n\nfunction _sliceNestedArray<T extends TypedArray>(arr: NestedArrayData, shape: number[], selection: (SliceIndices | number)[]): NestedArrayData | number {\n    const currentSlice = selection[0];\n\n    // Is this necessary?\n    // // This is possible when a slice list is passed shorter than the amount of dimensions\n    // // tslint:disable-next-line: strict-type-predicates\n    // if (currentSlice === undefined) {\n    //     return arr.slice();\n    // }\n\n    // When a number is passed that dimension is squeezed\n    if (typeof currentSlice === \"number\") {\n        // Assume already normalized integer selection here.\n        if (shape.length === 1) {\n            return arr[currentSlice];\n        } else {\n            return _sliceNestedArray(arr[currentSlice] as NestedArrayData, shape.slice(1), selection.slice(1));\n        }\n    }\n    const [from, to, step, outputSize] = currentSlice;\n\n    if (outputSize === 0) {\n        return new (getNestedArrayConstructor(arr))(0);\n    }\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            return (arr as TypedArray).slice(from, to);\n        }\n\n        const newArrData = new (arr.constructor as TypedArrayConstructor<T>)(outputSize);\n        for (let i = 0; i < outputSize; i++) {\n            newArrData[i] = (arr as TypedArray)[from + i * step];\n        }\n        return newArrData;\n    }\n\n    let newArr = new Array(outputSize);\n\n    for (let i = 0; i < outputSize; i++) {\n        newArr[i] = _sliceNestedArray(arr[from + i * step] as NestedArrayData, shape.slice(1), selection.slice(1));\n    }\n\n    // This is necessary to ensure that the return value is a NestedArray if the last dimension is squeezed\n    // e.g. shape [2,1] with slice [:, 0] would otherwise result in a list of numbers instead of a valid NestedArray\n    if (outputSize > 0 && typeof newArr[0] === \"number\") {\n        const typedArrayConstructor = (arr[0] as TypedArray).constructor;\n        newArr = (typedArrayConstructor as any).from(newArr);\n    }\n\n    return newArr;\n}\n\n\n\n\nexport function setNestedArrayToScalar(dstArr: NestedArrayData, value: number, destShape: number[], selection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(selection, destShape, true);\n\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n    const [sliceIndices, _outShape] = selectionToSliceIndices(normalizedSelection, destShape) as [SliceIndices[], number[]];\n    _setNestedArrayToScalar(dstArr, value, destShape, sliceIndices);\n}\n\nexport function setNestedArray(dstArr: NestedArrayData, sourceArr: NestedArrayData, destShape: number[], sourceShape: number[], selection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(selection, destShape, false);\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, destShape);\n\n    // TODO: replace with non stringify equality check\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n        throw new ValueError(`Shape mismatch in target and source NestedArray: ${outShape} and ${sourceShape}`);\n    }\n\n    _setNestedArray(dstArr, sourceArr, destShape, sliceIndices);\n}\n\n\nfunction _setNestedArray(dstArr: NestedArrayData, sourceArr: NestedArrayData | number, shape: number[], selection: (SliceIndices | number)[]) {\n\n    const currentSlice = selection[0];\n\n    if (typeof sourceArr === \"number\") {\n        _setNestedArrayToScalar(dstArr, sourceArr, shape, selection.map(x => typeof x === \"number\" ? [x, x + 1, 1, 1] : x));\n        return;\n    }\n\n    // This dimension is squeezed.\n    if (typeof currentSlice === \"number\") {\n        _setNestedArray((dstArr as NDNestedArrayData)[currentSlice], sourceArr, shape.slice(1), selection.slice(1));\n        return;\n    }\n\n    const [from, _to, step, outputSize] = currentSlice;\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            (dstArr as TypedArray).set(sourceArr as TypedArray, from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[from + i * step] = (sourceArr)[i];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setNestedArray((dstArr as NDNestedArrayData)[from + i * step], (sourceArr as NDNestedArrayData)[i], shape.slice(1), selection.slice(1));\n    }\n}\n\nfunction _setNestedArrayToScalar(dstArr: NestedArrayData, value: number, shape: number[], selection: SliceIndices[]) {\n    const currentSlice = selection[0];\n\n    const [from, to, step, outputSize] = currentSlice;\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            (dstArr as TypedArray).fill(value, from, to);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[from + i * step] = value;\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setNestedArrayToScalar((dstArr as NDNestedArrayData)[from + i * step], value, shape.slice(1), selection.slice(1));\n    }\n}\n\nexport function flattenNestedArray(arr: NestedArrayData, shape: number[], constr?: TypedArrayConstructor<TypedArray>): TypedArray {\n    if (constr === undefined) {\n        constr = getNestedArrayConstructor(arr);\n    }\n    const size = shape.reduce((x, y) => x * y, 1);\n    const outArr = new constr(size);\n\n    _flattenNestedArray(arr, shape, outArr, 0);\n\n    return outArr;\n}\n\nfunction _flattenNestedArray(arr: NestedArrayData, shape: number[], outArr: TypedArray, offset: number) {\n    if (shape.length === 1) {\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\n        // We just slice set the array directly from one level above to save some function calls.\n        outArr.set((arr as TypedArray), offset);\n        return;\n    }\n\n    if (shape.length === 2) {\n        for (let i = 0; i < shape[0]; i++) {\n            outArr.set((arr as TypedArray[])[i], offset + shape[1] * i);\n        }\n        return arr;\n    }\n\n    const nextShape = shape.slice(1);\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n    const mult = nextShape.reduce((x, y) => x * y, 1);\n\n    for (let i = 0; i < shape[0]; i++) {\n        _flattenNestedArray((arr as NDNestedArrayData)[i], nextShape, outArr, offset + mult * i);\n    }\n    return arr;\n}\n","import { DtypeString } from '../types';\nimport { NestedArrayData, TypedArray, TypedArrayConstructor, getTypedArrayCtr, getTypedArrayDtypeString } from './types';\nimport { ArraySelection, Slice } from '../core/types';\nimport { slice } from '../core/slice';\nimport { ValueError } from '../errors';\nimport { normalizeShape, IS_NODE } from '../util';\nimport { setNestedArray, setNestedArrayToScalar, flattenNestedArray, sliceNestedArray } from './ops';\n\nexport class NestedArray<T extends TypedArray> {\n    dtype: DtypeString;\n    shape: number[];\n    data: NestedArrayData;\n\n    constructor(data: TypedArray, shape?: number | number[], dtype?: DtypeString)\n    constructor(data: Buffer | ArrayBuffer | NestedArrayData | null, shape: number | number[], dtype: DtypeString)\n    constructor(data: Buffer | ArrayBuffer | NestedArrayData | TypedArray | null, shape?: number | number[], dtype?: DtypeString) {\n        const dataIsTypedArray = data !== null && !!(data as TypedArray).BYTES_PER_ELEMENT;\n\n        if (shape === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n            }\n            shape = [(data as TypedArray).length];\n        }\n\n        if (dtype === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n            }\n            dtype = getTypedArrayDtypeString(data as TypedArray);\n        }\n\n        shape = normalizeShape(shape);\n        this.shape = shape;\n        this.dtype = dtype;\n\n        if (dataIsTypedArray && shape.length !== 1) {\n            data = (data as TypedArray).buffer;\n        }\n\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n        if (this.shape.length === 0) {\n            this.data = new (getTypedArrayCtr(dtype))(1);\n        }\n        else if (\n            // tslint:disable-next-line: strict-type-predicates\n            (IS_NODE && Buffer.isBuffer(data))\n            || data instanceof ArrayBuffer\n            || data === null\n            || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n        ) {\n            // Create from ArrayBuffer or Buffer\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n            if (data === null) {\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n            }\n\n            const numDataElements = (data as ArrayBuffer).byteLength / parseInt(dtype[dtype.length - 1], 10);\n            if (numShapeElements !== numDataElements) {\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n            }\n            const typeConstructor: TypedArrayConstructor<TypedArray> = getTypedArrayCtr(dtype);\n            this.data = createNestedArray((data as ArrayBuffer), typeConstructor, shape);\n        } else {\n            this.data = data;\n        }\n    }\n\n    public get(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[]): NestedArray<T>;\n    public get(selection: ArraySelection): NestedArray<T> | number;\n    public get(selection: ArraySelection): NestedArray<T> | number {\n        const [sliceResult, outShape] = sliceNestedArray(this.data, this.shape, selection);\n        if (outShape.length === 0) {\n            return sliceResult as number;\n        } else {\n            return new NestedArray(sliceResult as NestedArrayData, outShape, this.dtype);\n        }\n    }\n\n    public set(selection: ArraySelection = null, value: NestedArray<T> | number) {\n        if (selection === null) {\n            selection = [slice(null)];\n        }\n        if (typeof value === \"number\") {\n            if (this.shape.length === 0) {\n                // Zero dimension array..\n                this.data[0] = value;\n            } else {\n                setNestedArrayToScalar(this.data, value, this.shape, selection);\n            }\n        } else {\n            setNestedArray(this.data, value.data, this.shape, value.shape, selection);\n        }\n    }\n\n    public flatten(): T {\n        if (this.shape.length === 1) {\n            return this.data as T;\n        }\n        return flattenNestedArray(this.data, this.shape, getTypedArrayCtr(this.dtype)) as T;\n    }\n\n    /**\n     * Currently only supports a single integer as the size, TODO: support start, stop, step.\n     */\n    public static arange(size: number, dtype: DtypeString = \"<i4\"): NestedArray<TypedArray> {\n        const constr = getTypedArrayCtr(dtype);\n        const data = rangeTypedArray([size], constr);\n        return new NestedArray(data, [size], dtype);\n    }\n}\n\n\n\n/**\n * Creates a TypedArray with values 0 through N where N is the product of the shape.\n */\nexport function rangeTypedArray<T extends TypedArray>(shape: number[], tContructor: TypedArrayConstructor<T>) {\n    const size = shape.reduce((x, y) => x * y, 1);\n    const data = new tContructor(size);\n    data.set([...Array(size).keys()]); // Sets range 0,1,2,3,4,5\n    return data;\n}\n\n/**\n * Creates multi-dimensional (rank > 1) array given input data and shape recursively.\n * What it does is create a Array<Array<...<Array<Uint8Array>>> or some other typed array.\n * This is for internal use, there should be no need to call this from user code.\n * @param data a buffer containing the data for this array.\n * @param t constructor for the datatype of choice\n * @param shape list of numbers describing the size in each dimension\n * @param offset in bytes for this dimension\n */\nexport function createNestedArray<T extends TypedArray>(data: Buffer | ArrayBuffer, t: TypedArrayConstructor<T>, shape: number[], offset = 0): NestedArrayData {\n    if (shape.length === 1) {\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\n        // We just slice set the array directly from one level above to save some function calls.\n        return new t(data.slice(offset, offset + shape[0] * t.BYTES_PER_ELEMENT));\n    }\n\n    const arr = new Array<any>(shape[0]);\n    if (shape.length === 2) {\n        for (let i = 0; i < shape[0]; i++) {\n            arr[i] = new t(data.slice(offset + shape[1] * i * t.BYTES_PER_ELEMENT, offset + shape[1] * (i + 1) * t.BYTES_PER_ELEMENT));\n        }\n        return arr;\n    }\n\n    const nextShape = shape.slice(1);\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n    const mult = nextShape.reduce((x, y) => x * y, 1);\n\n    for (let i = 0; i < shape[0]; i++) {\n        arr[i] = createNestedArray(data, t, nextShape, offset + mult * i * t.BYTES_PER_ELEMENT);\n    }\n    return arr;\n}\n","import { ArraySelection, SliceIndices } from '../core/types';\nimport { normalizeArraySelection, selectionToSliceIndices } from '../core/indexing';\nimport { ValueError } from '../errors';\nimport { TypedArray } from '../nestedArray/types';\n\nexport function setRawArrayToScalar(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, value: number) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(dstSelection, dstShape, true);\n    const [sliceIndices] = selectionToSliceIndices(normalizedSelection, dstShape);\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n    _setRawArrayToScalar(value, dstArr, dstStrides, sliceIndices as SliceIndices[]);\n}\n\nexport function setRawArray(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, sourceArr: TypedArray, sourceStrides: number[], sourceShape: number[]): void {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, false);\n    const [dstSliceIndices, outShape] = selectionToSliceIndices(normalizedDstSelection, dstShape);\n\n    // TODO: replace with non stringify equality check\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n        throw new ValueError(`Shape mismatch in target and source RawArray: ${outShape} and ${sourceShape}`);\n    }\n\n    _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides);\n}\n\nexport function setRawArrayFromChunkItem(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, sourceArr: TypedArray, sourceStrides: number[], sourceShape: number[], sourceSelection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, true);\n    // Above we force the results to be dstSliceIndices only, without integer selections making this cast is safe.\n    const [dstSliceIndices] = selectionToSliceIndices(normalizedDstSelection, dstShape);\n\n    const normalizedSourceSelection = normalizeArraySelection(sourceSelection, sourceShape, false);\n    const [sourceSliceIndicies] = selectionToSliceIndices(normalizedSourceSelection, sourceShape);\n\n    // TODO check to ensure chunk and dest selection are same shape?\n    // As is, this only gets called in ZarrArray.getRaw where this condition should be ensured, and check might hinder performance.\n\n    _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices as SliceIndices[], sourceArr, sourceStrides, sourceSliceIndicies);\n}\n\nfunction _setRawArrayToScalar(value: number, dstArr: TypedArray, dstStrides: number[], dstSliceIndices: SliceIndices[]) {\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n\n    const [from, _to, step, outputSize] = currentDstSlice;\n\n    if (dstStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1) {\n            dstArr.fill(value, from, from + outputSize);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = value;\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setRawArrayToScalar(\n            value,\n            dstArr.subarray(currentDstStride * (from + (step * i))),\n            nextDstStrides,\n            nextDstSliceIndices,\n        );\n    }\n}\n\nfunction _setRawArray(dstArr: TypedArray, dstStrides: number[], dstSliceIndices: (number | SliceIndices)[], sourceArr: TypedArray, sourceStrides: number[]) {\n    if (dstSliceIndices.length === 0) {\n        dstArr.set(sourceArr);\n        return;\n    }\n\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n\n    // This dimension is squeezed.\n    if (typeof currentDstSlice === \"number\") {\n        _setRawArray(\n            dstArr.subarray(currentDstSlice * currentDstStride),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr,\n            sourceStrides\n        );\n        return;\n    }\n\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\n    const [from, _to, step, outputSize] = currentDstSlice;\n\n    if (dstStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1 && currentSourceStride === 1) {\n            dstArr.set(sourceArr.subarray(0, outputSize), from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * i];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        // Apply strides as above, using both destination and source-specific strides.\n        _setRawArray(\n            dstArr.subarray(currentDstStride * (from + (i * step))),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr.subarray(currentSourceStride * i),\n            nextSourceStrides\n        );\n    }\n}\n\nfunction _setRawArrayFromChunkItem(dstArr: TypedArray, dstStrides: number[], dstSliceIndices: SliceIndices[], sourceArr: TypedArray, sourceStrides: number[], sourceSliceIndices: (SliceIndices | number)[]) {\n    if (sourceSliceIndices.length === 0) {\n        // Case when last source dimension is squeezed\n        dstArr.set(sourceArr.subarray(0, dstArr.length));\n        return;\n    }\n\n    // Get current indicies and strides for both destination and source arrays\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentSourceSlice, ...nextSourceSliceIndices] = sourceSliceIndices;\n\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\n\n    // This source dimension is squeezed\n    if (typeof currentSourceSlice === \"number\") {\n        /*\n        Sets dimension offset for squeezed dimension.\n\n        Ex. if 0th dimension is squeezed to 2nd index (numpy : arr[2,i])\n\n            sourceArr[stride[0]* 2 + i] --> sourceArr.subarray(stride[0] * 2)[i] (sourceArr[i] in next call)\n\n        Thus, subsequent squeezed dims are appended to the source offset.\n        */\n        _setRawArrayFromChunkItem(\n            // Don't update destination offset/slices, just source\n            dstArr, dstStrides, dstSliceIndices,\n            sourceArr.subarray(currentSourceStride * currentSourceSlice),\n            nextSourceStrides,\n            nextSourceSliceIndices,\n        );\n        return;\n    }\n\n    const [from, _to, step, outputSize] = currentDstSlice; // just need start and size\n    const [sfrom, _sto, sstep, _soutputSize] = currentSourceSlice; // Will always be subset of dst, so don't need output size just start\n\n    if (dstStrides.length === 1 && sourceStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1 && sstep === 1 && currentSourceStride === 1) {\n            dstArr.set(sourceArr.subarray(sfrom, sfrom + outputSize), from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * (sfrom + (sstep * i))];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        // Apply strides as above, using both destination and source-specific strides.\n        _setRawArrayFromChunkItem(\n            dstArr.subarray(currentDstStride * (from + (i * step))),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr.subarray(currentSourceStride * (sfrom + (i * sstep))),\n            nextSourceStrides,\n            nextSourceSliceIndices,\n        );\n    }\n}\n","import { DtypeString } from '../types';\nimport { ArraySelection } from '../core/types';\nimport { slice } from '../core/slice';\nimport { ValueError } from '../errors';\nimport { normalizeShape, IS_NODE, getStrides } from '../util';\nimport { TypedArray, getTypedArrayCtr, getTypedArrayDtypeString, TypedArrayConstructor } from '../nestedArray/types';\nimport { setRawArrayFromChunkItem, setRawArrayToScalar, setRawArray } from './ops';\n\nexport class RawArray {\n    dtype: DtypeString;\n    shape: number[];\n    strides: number[];\n    data: TypedArray;\n\n    constructor(data: TypedArray, shape?: number | number[], dtype?: DtypeString, strides?: number[])\n    constructor(data: Buffer | ArrayBuffer | null, shape?: number | number[], dtype?: DtypeString, strides?: number[])\n    constructor(data: Buffer | ArrayBuffer | TypedArray | null, shape?: number | number[], dtype?: DtypeString, strides?: number[]) {\n        const dataIsTypedArray = data !== null && !!(data as TypedArray).BYTES_PER_ELEMENT;\n\n        if (shape === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n            }\n            shape = [(data as TypedArray).length];\n        }\n        shape = normalizeShape(shape);\n\n        if (dtype === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n            }\n            dtype = getTypedArrayDtypeString(data as TypedArray);\n        }\n\n        if (strides === undefined) {\n            strides = getStrides(shape);\n        }\n\n        this.shape = shape;\n        this.dtype = dtype;\n        this.strides = strides;\n\n        if (dataIsTypedArray && shape.length !== 1) {\n            data = (data as TypedArray).buffer;\n        }\n\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n        if (this.shape.length === 0) {\n            this.data = new (getTypedArrayCtr(dtype))(1);\n        } else if (\n            // tslint:disable-next-line: strict-type-predicates\n            (IS_NODE && Buffer.isBuffer(data))\n            || data instanceof ArrayBuffer\n            || data === null\n            || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n        ) {\n            // Create from ArrayBuffer or Buffer\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n            if (data === null) {\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n            }\n\n            const numDataElements = (data as ArrayBuffer).byteLength / parseInt(dtype[dtype.length - 1], 10);\n            if (numShapeElements !== numDataElements) {\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n            }\n            const typeConstructor: TypedArrayConstructor<TypedArray> = getTypedArrayCtr(dtype);\n            this.data = new typeConstructor(data as ArrayBuffer);\n        } else {\n            this.data = data;\n        }\n    }\n\n    public set(selection: ArraySelection, value: RawArray | number): void;\n    public set(selection: ArraySelection, chunk: RawArray, chunkSelection: ArraySelection): void;\n    public set(selection: ArraySelection = null, value: RawArray | number, chunkSelection?: ArraySelection) {\n        if (selection === null) {\n            selection = [slice(null)];\n        }\n        if (typeof value === \"number\") {\n            if (this.shape.length === 0) {\n                // Zero dimension array..\n                this.data[0] = value;\n            } else {\n                setRawArrayToScalar(this.data, this.strides, this.shape, selection, value);\n            }\n        } else if (value instanceof RawArray && chunkSelection) {\n            // Copy directly from decoded chunk to destination array\n            setRawArrayFromChunkItem(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape, chunkSelection);\n        } else {\n            setRawArray(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape);\n        }\n    }\n}\n\n\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","'use strict';\nmodule.exports = (promise, onFinally) => {\n\tonFinally = onFinally || (() => {});\n\n\treturn promise.then(\n\t\tval => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => val),\n\t\terr => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => {\n\t\t\tthrow err;\n\t\t})\n\t);\n};\n","'use strict';\n\nconst pFinally = require('p-finally');\n\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t}\n\n\tif (milliseconds === Infinity) {\n\t\tresolve(promise);\n\t\treturn;\n\t}\n\n\tconst timer = setTimeout(() => {\n\t\tif (typeof fallback === 'function') {\n\t\t\ttry {\n\t\t\t\tresolve(fallback());\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\tif (typeof promise.cancel === 'function') {\n\t\t\tpromise.cancel();\n\t\t}\n\n\t\treject(timeoutError);\n\t}, milliseconds);\n\n\t// TODO: Use native `finally` keyword when targeting Node.js 10\n\tpFinally(\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tpromise.then(resolve, reject),\n\t\t() => {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t);\n});\n\nmodule.exports = pTimeout;\n// TODO: Remove this for the next major release\nmodule.exports.default = pTimeout;\n\nmodule.exports.TimeoutError = TimeoutError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = (count / 2) | 0;\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\nexports.default = lowerBound;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lower_bound_1 = require(\"./lower-bound\");\nclass PriorityQueue {\n    constructor() {\n        this._queue = [];\n    }\n    enqueue(run, options) {\n        options = Object.assign({ priority: 0 }, options);\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item && item.run;\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\nexports.default = PriorityQueue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.default.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options\n        // TODO: Remove this `as`.\n        );\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                this.emit('active');\n                this._queue.dequeue()();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n}\nexports.default = PQueue;\n","import { Store, ValidStoreType } from \"../storage/types\";\n\nimport { containsGroup, pathToPrefix } from '../storage/index';\nimport { normalizeStoragePath, isTotalSlice, arrayEquals1D, byteSwap, byteSwapInplace } from '../util';\nimport { ZarrArrayMetadata, UserAttributes, FillType } from '../types';\nimport { ARRAY_META_KEY, ATTRS_META_KEY } from '../names';\nimport { Attributes } from \"../attributes\";\nimport { parseMetadata } from \"../metadata\";\nimport { ArraySelection, DimensionSelection, Indexer, Slice, ChunkProjection } from \"./types\";\nimport { BasicIndexer, isContiguousSelection, normalizeIntegerSelection } from './indexing';\nimport { NestedArray } from \"../nestedArray\";\nimport { RawArray } from \"../rawArray\";\nimport { TypedArray, getTypedArrayCtr } from '../nestedArray/types';\nimport { ValueError, PermissionError, BoundsCheckError, ContainsGroupError, isKeyError } from '../errors';\nimport { getCodec } from \"../compression/registry\";\n\n\nimport type { Codec } from 'numcodecs';\nimport PQueue from 'p-queue';\n\nexport interface GetOptions {\n  concurrencyLimit?: number;\n  progressCallback?: (progressUpdate: {\n    progress: number;\n    queueSize: number;\n  }) => void;\n}\n\nexport interface SetOptions {\n  concurrencyLimit?: number;\n  progressCallback?: (progressUpdate: {\n    progress: number;\n    queueSize: number;\n  }) => void;\n}\n\nexport interface GetRawChunkOptions<O> {\n  storeOptions: O;\n}\n\nexport class ZarrArray {\n\n  public store: Store;\n  private compressor: Promise<Codec> | null;\n\n  private _chunkStore: Store | null;\n  /**\n   * A `Store` providing the underlying storage for array chunks.\n   */\n  public get chunkStore(): Store {\n    if (this._chunkStore) {\n      return this._chunkStore;\n    }\n    return this.store;\n  }\n  public path: string;\n  public keyPrefix: string;\n  public readOnly: boolean;\n  public cacheMetadata: boolean;\n  public cacheAttrs: boolean;\n  public meta: ZarrArrayMetadata;\n  public attrs: Attributes<UserAttributes>;\n\n  /**\n   * Array name following h5py convention.\n   */\n  public get name(): string | null {\n    if (this.path.length > 0) {\n      if (this.path[0] !== \"/\") {\n        return \"/\" + this.path;\n      }\n      return this.path;\n    }\n    return null;\n  }\n\n  /**\n   * Final component of name.\n   */\n  public get basename(): string | null {\n    const name = this.name;\n    if (name === null) {\n      return null;\n    }\n    const parts = name.split(\"/\");\n    return parts[parts.length - 1];\n  }\n\n  /**\n   * \"A list of integers describing the length of each dimension of the array.\n   */\n  public get shape(): number[] {\n    // this.refreshMetadata();\n    return this.meta.shape;\n  }\n\n  /**\n   * A list of integers describing the length of each dimension of a chunk of the array.\n   */\n  public get chunks(): number[] {\n    return this.meta.chunks;\n  }\n\n  /**\n   * Integer describing how many element a chunk contains\n   */\n  private get chunkSize(): number {\n    return this.chunks.reduce((x, y) => x * y, 1);\n  }\n\n  /**\n   *  The NumPy data type.\n   */\n  public get dtype() {\n    return this.meta.dtype;\n  }\n\n  /**\n   *  A value used for uninitialized portions of the array.\n   */\n  public get fillValue(): FillType {\n\n    const fillTypeValue = this.meta.fill_value;\n\n    // TODO extract into function\n    if (fillTypeValue === \"NaN\") {\n      return NaN;\n    } else if (fillTypeValue === \"Infinity\") {\n      return Infinity;\n    } else if (fillTypeValue === \"-Infinity\") {\n      return -Infinity;\n    }\n\n    return this.meta.fill_value as FillType;\n  }\n\n  /**\n   *  Number of dimensions.\n   */\n  public get nDims() {\n    return this.meta.shape.length;\n  }\n\n  /**\n   *  The total number of elements in the array.\n   */\n  public get size() {\n    // this.refreshMetadata()\n    return this.meta.shape.reduce((x, y) => x * y, 1);\n  }\n\n  public get length() {\n    return this.shape[0];\n  }\n\n\n  private get _chunkDataShape() {\n    if (this.shape === []) {\n      return [1];\n    } else {\n      const s = [];\n      for (let i = 0; i < this.shape.length; i++) {\n        s[i] = Math.ceil(this.shape[i] / this.chunks[i]);\n      }\n      return s;\n    }\n  }\n  /**\n   * A tuple of integers describing the number of chunks along each\n   * dimension of the array.\n   */\n  public get chunkDataShape() {\n    // this.refreshMetadata();\n    return this._chunkDataShape;\n  }\n\n  /**\n   * Total number of chunks.\n   */\n  public get numChunks() {\n    // this.refreshMetadata();\n    return this.chunkDataShape.reduce((x, y) => x * y, 1);\n  }\n\n  /**\n   * Instantiate an array from an initialized store.\n   * @param store Array store, already initialized.\n   * @param path Storage path.\n   * @param readOnly True if array should be protected against modification.\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\n   */\n  public static async create(store: Store, path: null | string = null, readOnly = false, chunkStore: Store | null = null, cacheMetadata = true, cacheAttrs = true) {\n    const metadata = await this.loadMetadataForConstructor(store, path);\n    return new ZarrArray(store, path, metadata as ZarrArrayMetadata, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n  }\n\n  private static async loadMetadataForConstructor(store: Store, path: null | string) {\n    try {\n      path = normalizeStoragePath(path);\n      const keyPrefix = pathToPrefix(path);\n      const metaStoreValue = await store.getItem(keyPrefix + ARRAY_META_KEY);\n      return parseMetadata(metaStoreValue);\n    } catch (error) {\n      if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path ?? '');\n      }\n      throw new Error(\"Failed to load metadata for ZarrArray:\" + error.toString());\n    }\n  }\n\n  /**\n   * Instantiate an array from an initialized store.\n   * @param store Array store, already initialized.\n   * @param path Storage path.\n   * @param metadata The initial value for the metadata\n   * @param readOnly True if array should be protected against modification.\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\n   */\n  private constructor(store: Store, path: null | string = null, metadata: ZarrArrayMetadata, readOnly = false, chunkStore: Store | null = null, cacheMetadata = true, cacheAttrs = true) {\n    // N.B., expect at this point store is fully initialized with all\n    // configuration metadata fully specified and normalized\n\n    this.store = store;\n    this._chunkStore = chunkStore;\n    this.path = normalizeStoragePath(path);\n    this.keyPrefix = pathToPrefix(this.path);\n    this.readOnly = readOnly;\n    this.cacheMetadata = cacheMetadata;\n    this.cacheAttrs = cacheAttrs;\n    this.meta = metadata;\n    if (this.meta.compressor !== null) {\n      this.compressor = getCodec(this.meta.compressor);\n    } else {\n      this.compressor = null;\n    }\n\n\n    const attrKey = this.keyPrefix + ATTRS_META_KEY;\n    this.attrs = new Attributes<UserAttributes>(this.store, attrKey, this.readOnly, cacheAttrs);\n  }\n\n  /**\n   * (Re)load metadata from store\n   */\n  public async reloadMetadata() {\n    const metaKey = this.keyPrefix + ARRAY_META_KEY;\n    const metaStoreValue = this.store.getItem(metaKey);\n    this.meta = parseMetadata(await metaStoreValue) as ZarrArrayMetadata;\n    return this.meta;\n  }\n\n  private async refreshMetadata() {\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n  }\n\n  public get(selection?: undefined | Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public get(selection?: ArraySelection, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public get(selection: ArraySelection = null, opts: GetOptions = {}): Promise<NestedArray<TypedArray> | number> {\n    return this.getBasicSelection(selection, false, opts);\n  }\n\n  public getRaw(selection?: undefined | Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], opts?: GetOptions): Promise<RawArray | number>;\n  public getRaw(selection?: ArraySelection, opts?: GetOptions): Promise<RawArray | number>;\n  public getRaw(selection: ArraySelection = null, opts: GetOptions = {}): Promise<RawArray | number> {\n    return this.getBasicSelection(selection, true, opts);\n  }\n\n  // asRaw = false\n  public async getBasicSelection(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], asRaw?: false, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public async getBasicSelection(selection: ArraySelection, asRaw?: false, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  // asRaw = true\n  public async getBasicSelection(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], asRaw?: true, opts?: GetOptions): Promise<RawArray | number>;\n  public async getBasicSelection(selection: ArraySelection, asRaw?: true, opts?: GetOptions): Promise<RawArray | number>;\n\n  public async getBasicSelection(selection: ArraySelection, asRaw = false, { concurrencyLimit = 10, progressCallback }: GetOptions = {}): Promise<NestedArray<TypedArray> | RawArray | number> {\n    // Refresh metadata\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n\n    // Check fields (TODO?)\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      return this.getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback);\n    }\n  }\n\n  private getBasicSelectionND(selection: ArraySelection, asRaw: boolean, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void): Promise<number | NestedArray<TypedArray> | RawArray> {\n    const indexer = new BasicIndexer(selection, this);\n    return this.getSelection(indexer, asRaw, concurrencyLimit, progressCallback);\n  }\n\n  private async getSelection(indexer: BasicIndexer, asRaw: boolean, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void): Promise<number | NestedArray<TypedArray> | RawArray> {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be extracted. Each chunk is processed in turn, extracting the\n    // necessary data and storing into the correct location in the output array.\n\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n\n    // check fields are sensible (TODO?)\n\n    const outDtype = this.dtype;\n    const outShape = indexer.shape;\n    const outSize = indexer.shape.reduce((x, y) => x * y, 1);\n\n    if (asRaw && (outSize === this.chunkSize)) {\n      // Optimization: if output strided array _is_ chunk exactly,\n      // decode directly as new TypedArray and return\n      const itr = indexer.iter();\n      const proj = itr.next(); // ensure there is only one projection\n      if (proj.done === false && itr.next().done === true) {\n        const chunkProjection = proj.value as ChunkProjection;\n        const out = await this.decodeDirectToRawArray(chunkProjection, outShape, outSize);\n        return out;\n      }\n    }\n\n    const out = asRaw\n      ? new RawArray(null, outShape, outDtype)\n      : new NestedArray(null, outShape, outDtype);\n\n    if (outSize === 0) {\n      return out;\n    }\n\n    // create promise queue with concurrency control\n    const queue = new PQueue({ concurrency: concurrencyLimit });\n\n    if (progressCallback) {\n\n      let progress = 0;\n      let queueSize = 0;\n      for (const _ of indexer.iter()) queueSize += 1;\n      progressCallback({ progress: 0, queueSize: queueSize });\n      for (const proj of indexer.iter()) {\n        (async () => {\n          await queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n          progress += 1;\n          progressCallback({ progress: progress, queueSize: queueSize });\n        })();\n      }\n\n    } else {\n      for (const proj of indexer.iter()) {\n        queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n      }\n    }\n\n    // guarantees that all work on queue has finished\n    await queue.onIdle();\n\n    // Return scalar instead of zero-dimensional array.\n    if (out.shape.length === 0) {\n      return out.data[0] as number;\n    }\n\n    return out;\n  }\n\n  /**\n   * Obtain part or whole of a chunk.\n   * @param chunkCoords Indices of the chunk.\n   * @param chunkSelection Location of region within the chunk to extract.\n   * @param out Array to store result in.\n   * @param outSelection Location of region within output array to store results in.\n   * @param dropAxes Axes to squeeze out of the chunk.\n   */\n  private async chunkGetItem<T extends TypedArray>(chunkCoords: number[], chunkSelection: DimensionSelection[], out: NestedArray<T> | RawArray, outSelection: DimensionSelection[], dropAxes: null | number[]) {\n    if (chunkCoords.length !== this._chunkDataShape.length) {\n      throw new ValueError(`Inconsistent shapes: chunkCoordsLength: ${chunkCoords.length}, cDataShapeLength: ${this.chunkDataShape.length}`);\n    }\n\n    const cKey = this.chunkKey(chunkCoords);\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      const decodedChunk = await this.decodeChunk(cdata);\n\n      if (out instanceof NestedArray) {\n\n        if (isContiguousSelection(outSelection) && isTotalSlice(chunkSelection, this.chunks) && !this.meta.filters) {\n          // Optimization: we want the whole chunk, and the destination is\n          // contiguous, so we can decompress directly from the chunk\n          // into the destination array\n\n          // TODO check order\n          // TODO filters..\n          out.set(outSelection, this.toNestedArray<T>(decodedChunk));\n          return;\n        }\n\n        // Decode chunk\n        const chunk = this.toNestedArray(decodedChunk);\n        const tmp = chunk.get(chunkSelection);\n\n        if (dropAxes !== null) {\n          throw new Error(\"Drop axes is not supported yet\");\n        }\n\n        out.set(outSelection, tmp as NestedArray<T>);\n\n      } else {\n        /* RawArray\n        Copies chunk by index directly into output. Doesn't matter if selection is contiguous\n        since store/output are different shapes/strides.\n        */\n        out.set(outSelection, this.chunkBufferToRawArray(decodedChunk), chunkSelection);\n      }\n\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if cKey doesn't exist in store\n        if (this.fillValue !== null) {\n          out.set(outSelection, this.fillValue);\n        }\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  public async getRawChunk<O>(chunkCoords: number[], opts?: GetRawChunkOptions<O>): Promise<RawArray> {\n    if (chunkCoords.length !== this.shape.length) {\n      throw new Error(`Chunk coordinates ${chunkCoords.join(\".\")} do not correspond to shape ${this.shape}.`);\n    }\n    try {\n      for (let i = 0; i < chunkCoords.length; i++) {\n        const dimLength = Math.ceil(this.shape[i] / this.chunks[i]);\n        chunkCoords[i] = normalizeIntegerSelection(chunkCoords[i], dimLength);\n      }\n    } catch (error) {\n      if (error instanceof BoundsCheckError) {\n        throw new BoundsCheckError(`index ${chunkCoords.join(\".\")} is out of bounds for shape: ${this.shape} and chunks ${this.chunks}`);\n      } else {\n        throw error;\n      }\n    }\n    const cKey = this.chunkKey(chunkCoords);\n    const cdata = this.chunkStore.getItem(cKey, opts?.storeOptions);\n    const buffer = await this.decodeChunk(await cdata);\n    const outShape = this.chunks.filter(d => d !== 1); // squeeze chunk dim if 1\n    return new RawArray(buffer, outShape, this.dtype);\n  }\n\n  private chunkKey(chunkCoords: number[]) {\n    const sep = this.meta.dimension_separator ?? \".\";\n    return this.keyPrefix + chunkCoords.join(sep);\n  }\n\n  private ensureByteArray(chunkData: ValidStoreType): Uint8Array {\n    if (typeof chunkData === \"string\") {\n      return new Uint8Array(Buffer.from(chunkData).buffer);\n    }\n    return new Uint8Array(chunkData);\n  }\n\n  private toTypedArray(buffer: Buffer | ArrayBuffer) {\n    return new (getTypedArrayCtr(this.dtype))(buffer);\n  }\n\n  private toNestedArray<T extends TypedArray>(data: ValidStoreType) {\n    const buffer = this.ensureByteArray(data).buffer;\n\n    return new NestedArray<T>(buffer, this.chunks, this.dtype);\n  }\n\n  private async decodeChunk(chunkData: ValidStoreType) {\n    let bytes = this.ensureByteArray(chunkData);\n\n    if (this.compressor !== null) {\n      bytes = await (await this.compressor).decode(bytes);\n    }\n\n    if (this.dtype.includes('>')) {\n      // Need to flip bytes for Javascript TypedArrays\n      // We flip bytes in-place to avoid creating an extra copy of the decoded buffer.\n      byteSwapInplace(this.toTypedArray(bytes.buffer));\n    }\n\n    // TODO filtering etc\n    return bytes.buffer;\n  }\n\n  private chunkBufferToRawArray(buffer: Buffer | ArrayBuffer) {\n    return new RawArray(buffer, this.chunks, this.dtype);\n  }\n\n  private async decodeDirectToRawArray({ chunkCoords }: ChunkProjection, outShape: number[], outSize: number): Promise<RawArray> {\n    const cKey = this.chunkKey(chunkCoords);\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      return new RawArray(await this.decodeChunk(cdata), outShape, this.dtype);\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if item doesn't exist\n        const data = new (getTypedArrayCtr(this.dtype))(outSize);\n        return new RawArray(data.fill(this.fillValue as number), outShape);\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  public async set(selection: ArraySelection = null, value: any, opts: SetOptions = {}) {\n    await this.setBasicSelection(selection, value, opts);\n  }\n\n  public async setBasicSelection(selection: ArraySelection, value: any, { concurrencyLimit = 10, progressCallback }: SetOptions = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"Object is read only\");\n    }\n\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      await this.setBasicSelectionND(selection, value, concurrencyLimit, progressCallback);\n    }\n  }\n\n  private async setBasicSelectionND(selection: ArraySelection, value: any, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void) {\n    const indexer = new BasicIndexer(selection, this);\n    await this.setSelection(indexer, value, concurrencyLimit, progressCallback);\n  }\n\n  private getChunkValue(proj: ChunkProjection, indexer: Indexer, value: number | NestedArray<TypedArray>, selectionShape: number[]): number | NestedArray<TypedArray> {\n    let chunkValue: number | NestedArray<TypedArray>;\n    if (selectionShape === []) {\n      chunkValue = value;\n    } else if (typeof value === \"number\") {\n      chunkValue = value;\n    } else {\n      chunkValue = value.get(proj.outSelection);\n      // tslint:disable-next-line: strict-type-predicates\n      if (indexer.dropAxes !== null) {\n        throw new Error(\"Handling drop axes not supported yet\");\n      }\n    }\n    return chunkValue;\n  }\n\n  private async setSelection(indexer: Indexer, value: number | NestedArray<TypedArray>, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void) {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be replaced. Each chunk is processed in turn, extracting the\n    // necessary data from the value array and storing into the chunk array.\n\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n\n    // TODO? check fields are sensible\n\n    // Determine indices of chunks overlapping the selection\n    const selectionShape = indexer.shape;\n\n    // Check value shape\n    if (selectionShape === []) {\n      // Setting a single value\n    } else if (typeof value === \"number\") {\n      // Setting a scalar value\n    } else if (value instanceof NestedArray) {\n      // TODO: non stringify equality check\n      if (!arrayEquals1D(value.shape, selectionShape)) {\n        throw new ValueError(`Shape mismatch in source NestedArray and set selection: ${value.shape} and ${selectionShape}`);\n      }\n    } else {\n      // TODO support TypedArrays, buffers, etc\n      throw new Error(\"Unknown data type for setting :(\");\n    }\n\n    const queue = new PQueue({ concurrency: concurrencyLimit });\n\n    if (progressCallback) {\n\n      let queueSize = 0;\n      for (const _ of indexer.iter()) queueSize += 1;\n\n      let progress = 0;\n      progressCallback({ progress: 0, queueSize: queueSize });\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n        (async () => {\n          await queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n          progress += 1;\n          progressCallback({ progress: progress, queueSize: queueSize });\n        })();\n      }\n\n    } else {\n\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n        queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n      }\n\n    }\n\n    // guarantees that all work on queue has finished\n    await queue.onIdle();\n  }\n\n  private async chunkSetItem(chunkCoords: number[], chunkSelection: DimensionSelection[], value: number | NestedArray<TypedArray>) {\n    // Obtain key for chunk storage\n    const chunkKey = this.chunkKey(chunkCoords);\n\n    let chunk: null | TypedArray = null;\n\n    const dtypeConstr = getTypedArrayCtr(this.dtype);\n    const chunkSize = this.chunkSize;\n\n    if (isTotalSlice(chunkSelection, this.chunks)) {\n      // Totally replace chunk\n\n      // Optimization: we are completely replacing the chunk, so no need\n      // to access the existing chunk data\n\n      if (typeof value === \"number\") {\n        // TODO get the right type here\n        chunk = new dtypeConstr(chunkSize);\n        chunk.fill(value);\n      } else {\n        chunk = value.flatten();\n      }\n    } else {\n\n      // partially replace the contents of this chunk\n\n      // Existing chunk data\n      let chunkData: TypedArray;\n\n      try {\n        // Chunk is initialized if this does not error\n        const chunkStoreData = await this.chunkStore.getItem(chunkKey);\n        const dBytes = await this.decodeChunk(chunkStoreData);\n        chunkData = this.toTypedArray(dBytes);\n      } catch (error) {\n        if (isKeyError(error)) {\n          // Chunk is not initialized\n          chunkData = new dtypeConstr(chunkSize);\n          if (this.fillValue !== null) {\n            chunkData.fill(this.fillValue);\n          }\n        } else {\n          // Different type of error - rethrow\n          throw error;\n        }\n      }\n\n      const chunkNestedArray = new NestedArray(\n        chunkData,\n        this.chunks,\n        this.dtype,\n      );\n      chunkNestedArray.set(chunkSelection, value);\n      chunk = chunkNestedArray.flatten();\n    }\n    const chunkData = await this.encodeChunk(chunk);\n    this.chunkStore.setItem(chunkKey, chunkData);\n  }\n\n  private async encodeChunk(chunk: TypedArray) {\n    if (this.dtype.includes('>')) {\n      /*\n       * If big endian, flip bytes before applying compression and setting store.\n       *\n       * Here we create a copy (not in-place byteswapping) to avoid flipping the\n       * bytes in the buffers of user-created Raw- and NestedArrays.\n      */\n      chunk = byteSwap(chunk);\n    }\n\n    if (this.compressor !== null) {\n      const bytes = new Uint8Array(chunk.buffer);\n      const cbytes = await (await this.compressor).encode(bytes);\n      return cbytes.buffer;\n    }\n\n    // TODO: filters, etc\n    return chunk.buffer;\n  }\n}","import { SyncStore, ValidStoreType } from \"./types\";\nimport { createProxy, MutableMappingProxy } from \"../mutableMapping\";\nimport { KeyError } from \"../errors\";\n\nexport class MemoryStore<T extends ValidStoreType> implements SyncStore<T> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    root: { [key: string]: any };\n\n    constructor(root = {}) {\n        this.root = root;\n    }\n\n    public proxy(): MutableMappingProxy<T> {\n        return createProxy(this);\n    }\n\n    private getParent(item: string): [any, string] {\n        let parent = this.root;\n        const segments = item.split('/');\n        // find the parent container\n        for (const k of segments.slice(0, segments.length - 1)) {\n            parent = parent[k];\n            if (!parent) {\n                throw Error(item);\n            }\n            // if not isinstance(parent, self.cls):\n            //     raise KeyError(item)\n        }\n        return [parent, segments[segments.length - 1]];\n    }\n\n    private requireParent(item: string): [any, string] {\n        let parent = this.root;\n        const segments = item.split('/');\n\n        // require the parent container\n        for (const k of segments.slice(0, segments.length - 1)) {\n            // TODO: verify correct implementation\n            if (parent[k] === undefined) {\n                parent[k] = {};\n            }\n            parent = parent[k];\n        }\n\n        return [parent, segments[segments.length - 1]];\n    }\n\n    getItem(item: string) {\n        const [parent, key] = this.getParent(item);\n        const value = parent[key];\n        if (value === undefined) {\n            throw new KeyError(item);\n        }\n        return value;\n    }\n\n    setItem(item: string, value: any): boolean {\n        const [parent, key] = this.requireParent(item);\n        parent[key] = value;\n        return true;\n    }\n\n    deleteItem(item: string): boolean {\n        const [parent, key] = this.getParent(item);\n        return delete parent[key];\n    }\n\n    containsItem(item: string): boolean {\n        // TODO: more sane implementation\n        try {\n            return this.getItem(item) !== undefined;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    keys(): string[] {\n        throw new Error(\"Method not implemented.\");\n    }\n\n\n}","import { ValidStoreType, AsyncStore } from './types';\nimport { IS_NODE, joinUrlParts } from '../util';\nimport { KeyError, HTTPError } from '../errors';\n\nenum HTTPMethod {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  PUT = 'PUT',\n}\n\nconst DEFAULT_METHODS = [HTTPMethod.HEAD, HTTPMethod.GET, HTTPMethod.PUT];\n\ninterface HTTPStoreOptions {\n    fetchOptions?: RequestInit;\n    supportedMethods?: HTTPMethod[];\n}\n\nexport class HTTPStore implements AsyncStore<ArrayBuffer> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    public url: string;\n    public fetchOptions: RequestInit;\n    private supportedMethods: Set<HTTPMethod>;\n\n    constructor(url: string, options: HTTPStoreOptions = {}) {\n        this.url = url;\n        const { fetchOptions = {}, supportedMethods = DEFAULT_METHODS } = options;\n        this.fetchOptions = fetchOptions;\n        this.supportedMethods = new Set(supportedMethods);\n    }\n\n    keys(): Promise<string[]> {\n        throw new Error('Method not implemented.');\n    }\n\n    async getItem(item: string, opts?: RequestInit) {\n        const url = joinUrlParts(this.url, item);\n        const value = await fetch(url, { ...this.fetchOptions, ...opts });\n\n        if (value.status === 404) {\n            // Item is not found\n            throw new KeyError(item);\n        } else if (value.status !== 200) {\n            throw new HTTPError(String(value.status));\n        }\n\n        // only decode if 200\n        if (IS_NODE) {\n            return Buffer.from(await value.arrayBuffer());\n        } else {\n            return value.arrayBuffer(); // Browser\n        }\n    }\n\n    async setItem(item: string, value: ValidStoreType): Promise<boolean> {\n        if (!this.supportedMethods.has(HTTPMethod.PUT)) {\n          throw new Error('HTTP PUT no a supported method for store.');\n        }\n        const url = joinUrlParts(this.url, item);\n        if (typeof value === 'string') {\n            value = new TextEncoder().encode(value).buffer;\n        }\n        const set = await fetch(url, { ...this.fetchOptions, method: HTTPMethod.PUT, body: value });\n        return set.status.toString()[0] === '2';\n    }\n\n    deleteItem(_item: string): Promise<boolean> {\n        throw new Error('Method not implemented.');\n    }\n\n    async containsItem(item: string): Promise<boolean> {\n        const url = joinUrlParts(this.url, item);\n        // Just check headers if HEAD method supported\n        const method = this.supportedMethods.has(HTTPMethod.HEAD) ? HTTPMethod.HEAD : HTTPMethod.GET;\n        const value = await fetch(url, { ...this.fetchOptions, method });\n        return value.status === 200;\n    }\n}\n","import { ChunksArgument, DtypeString, CompressorConfig, Order, Filter, FillType, PersistenceMode } from './types';\nimport { Store } from './storage/types';\nimport { ZarrArray } from './core/index';\nimport { MemoryStore } from './storage/memoryStore';\nimport { initArray, containsArray, containsGroup } from './storage/index';\nimport { TypedArray } from './nestedArray/types';\nimport { NestedArray } from './nestedArray/index';\nimport { normalizeStoragePath } from './util';\nimport { ContainsArrayError, ValueError, ArrayNotFoundError, ContainsGroupError } from './errors';\nimport { HTTPStore } from './storage/httpStore';\n\nexport type CreateArrayOptions = {\n    shape: number | number[];\n    chunks?: ChunksArgument;\n    dtype?: DtypeString;\n    compressor?: CompressorConfig | null;\n    fillValue?: FillType;\n    order?: Order;\n    store?: Store;\n    overwrite?: boolean;\n    path?: string | null;\n    chunkStore?: Store;\n    filters?: Filter[];\n    cacheMetadata?: boolean;\n    cacheAttrs?: boolean;\n    readOnly?: boolean;\n    dimensionSeparator?: '.' | '/';\n};\n\n/**\n * \n * @param shape Array shape.\n * @param chunks  Chunk shape. If `true`, will be guessed from `shape` and `dtype`. If\n *      `false`, will be set to `shape`, i.e., single chunk for the whole array.\n *      If an int, the chunk size in each dimension will be given by the value\n *      of `chunks`. Default is `true`.\n * @param dtype NumPy dtype.\n * @param compressor Primary compressor.\n * @param fillValue Default value to use for uninitialized portions of the array.\n * @param order Memory layout to be used within each chunk.\n * @param store Store or path to directory in file system or name of zip file.\n * @param overwrite  If True, delete all pre-existing data in `store` at `path` before creating the array.\n * @param path Path under which array is stored.\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n * @param filters Sequence of filters to use to encode chunk data prior to compression.\n * @param cacheMetadata If `true` (default), array configuration metadata will be cached for the\n *      lifetime of the object. If `false`, array metadata will be reloaded\n *      prior to all data access and modification operations (may incur\n *      overhead depending on storage and data access pattern).\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read\n *      operations. If `false`, user attributes are reloaded from the store prior\n *      to all attribute read operations.\n * @param readOnly `true` if array should be protected against modification, defaults to `false`.\n * @param dimensionSeparator if specified, defines an alternate string separator placed between the dimension chunks.\n */\nexport async function create(\n    { shape, chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path, chunkStore, filters, cacheMetadata = true, cacheAttrs = true, readOnly = false, dimensionSeparator }: CreateArrayOptions,\n): Promise<ZarrArray> {\n\n    store = normalizeStoreArgument(store);\n\n    await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n    const z = await ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n\n    return z;\n}\n\n\n/**\n * Create an empty array.\n */\nexport async function empty(shape: number | number[], opts: Omit<CreateArrayOptions, 'shape'> = {}) {\n    opts.fillValue = null;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with zero being used as the default value for\n * uninitialized portions of the array.\n */\nexport async function zeros(shape: number | number[], opts: Omit<CreateArrayOptions, 'shape'> = {}) {\n    opts.fillValue = 0;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with one being used as the default value for\n * uninitialized portions of the array.\n */\nexport async function ones(shape: number | number[], opts: Omit<CreateArrayOptions, 'shape'> = {}) {\n    opts.fillValue = 1;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with `fill_value` being used as the default value for\n * uninitialized portions of the array\n */\nexport async function full(shape: number | number[], fillValue: FillType, opts: Omit<CreateArrayOptions, 'shape'> = {}) {\n    opts.fillValue = fillValue;\n    return create({ shape, ...opts });\n}\n\nexport async function array(data: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts: Omit<CreateArrayOptions, 'shape'> = {}) {\n    // TODO: infer chunks?\n\n    let shape = null;\n    if (data instanceof NestedArray) {\n        shape = data.shape;\n        opts.dtype = opts.dtype === undefined ? data.dtype : opts.dtype;\n    } else {\n        shape = data.byteLength;\n        // TODO: infer datatype\n    }\n    // TODO: support TypedArray\n\n    const wasReadOnly = opts.readOnly === undefined ? false : opts.readOnly;\n    opts.readOnly = false;\n\n    const z = await create({ shape, ...opts });\n    await z.set(null, data);\n    z.readOnly = wasReadOnly;\n\n    return z;\n}\n\ntype OpenArrayOptions = Partial<CreateArrayOptions & { mode: PersistenceMode }>;\n\nexport async function openArray(\n    { shape, mode = \"a\", chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path = null, chunkStore, filters, cacheMetadata = true, cacheAttrs = true, dimensionSeparator }: OpenArrayOptions = {},\n) {\n    store = normalizeStoreArgument(store);\n    if (chunkStore === undefined) {\n        chunkStore = normalizeStoreArgument(store);\n    }\n    path = normalizeStoragePath(path);\n\n    if (mode === \"r\" || mode === \"r+\") {\n        if (!await containsArray(store, path)) {\n            if (await containsGroup(store, path)) {\n                throw new ContainsGroupError(path);\n            }\n            throw new ArrayNotFoundError(path);\n        }\n    } else if (mode === \"w\") {\n\n        if (shape === undefined) {\n            throw new ValueError(\"Shape can not be undefined when creating a new array\");\n        }\n        await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n\n    } else if (mode === \"a\") {\n        if (!await containsArray(store, path)) {\n            if (await containsGroup(store, path)) {\n                throw new ContainsGroupError(path);\n            }\n            if (shape === undefined) {\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\n            }\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n        }\n    } else if (mode === \"w-\" || (mode as any) === \"x\") {\n        if (await containsArray(store, path)) {\n            throw new ContainsArrayError(path);\n        } else if (await containsGroup(store, path)) {\n            throw new ContainsGroupError(path);\n        } else {\n            if (shape === undefined) {\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\n            }\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\n        }\n    } else {\n        throw new ValueError(`Invalid mode argument: ${mode}`);\n    }\n\n    const readOnly = mode === \"r\";\n    return ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n}\n\n\nexport function normalizeStoreArgument(store?: Store | string): Store {\n    if (store === undefined) {\n        return new MemoryStore();\n    } else if (typeof store === \"string\") {\n        return new HTTPStore(store);\n    }\n    return store;\n}","import { createProxy, AsyncMutableMapping, AsyncMutableMappingProxy } from './mutableMapping';\nimport { Store, } from './storage/types';\nimport { normalizeStoragePath } from './util';\nimport { containsArray, pathToPrefix, containsGroup, initGroup } from './storage/index';\nimport { ContainsArrayError, GroupNotFoundError, PermissionError, KeyError, ValueError, ContainsGroupError } from './errors';\nimport { ZarrGroupMetadata, UserAttributes, PersistenceMode } from './types';\nimport { GROUP_META_KEY, ATTRS_META_KEY } from './names';\nimport { parseMetadata } from './metadata';\nimport { Attributes } from './attributes';\nimport { array, empty, zeros, ones, full, create, normalizeStoreArgument, CreateArrayOptions } from './creation';\nimport { NestedArray } from './nestedArray';\nimport { TypedArray } from './nestedArray/types';\nimport { ZarrArray } from './core';\n\n\nexport class Group implements AsyncMutableMapping<Group | ZarrArray> {\n    /**\n     * A `Store` providing the underlying storage for the group.\n     */\n    public store: Store;\n\n    /**\n     * Storage path.\n     */\n    public path: string;\n\n    /**\n     * Group name following h5py convention.\n     */\n    public get name(): string {\n        if (this.path.length > 0) {\n            if (this.path[0] !== \"/\") {\n                return \"/\" + this.path;\n            }\n            return this.path;\n        }\n        return \"/\";\n    }\n\n    /**\n     * Final component of name.\n     */\n    public get basename(): string {\n        const parts = this.name.split(\"/\");\n        return parts[parts.length - 1];\n    }\n\n    /**\n     * An object containing user-defined attributes. Note that\n     * attribute values are stored as a JSON string in a store.\n     */\n    public attrs: Attributes<UserAttributes>;\n\n\n    private _chunkStore: Store | null;\n    /**\n     * A `Store` providing the underlying storage for array chunks.\n     */\n    public get chunkStore(): Store {\n        if (this._chunkStore) {\n            return this._chunkStore;\n        }\n        return this.store;\n    }\n\n    private keyPrefix: string;\n    public readOnly: boolean;\n    private meta: ZarrGroupMetadata;\n\n    public static async create(store: Store, path: string | null = null, readOnly = false, chunkStore: Store | null = null, cacheAttrs = true) {\n        const metadata = await this.loadMetadataForConstructor(store, path);\n        return new Group(store, path, metadata as ZarrGroupMetadata, readOnly, chunkStore, cacheAttrs);\n    }\n\n    private static async loadMetadataForConstructor(store: Store, path: null | string) {\n        path = normalizeStoragePath(path);\n        const keyPrefix = pathToPrefix(path);\n        try {\n            const metaStoreValue = await store.getItem(keyPrefix + GROUP_META_KEY);\n            return parseMetadata(metaStoreValue);\n        } catch (error) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            throw new GroupNotFoundError(path);\n        }\n    }\n\n    private constructor(store: Store, path: string | null = null, metadata: ZarrGroupMetadata, readOnly = false, chunkStore: Store | null = null, cacheAttrs = true) {\n        this.store = store;\n        this._chunkStore = chunkStore;\n        this.path = normalizeStoragePath(path);\n        this.keyPrefix = pathToPrefix(this.path);\n        this.readOnly = readOnly;\n        this.meta = metadata;\n\n        // Initialize attributes\n        const attrKey = this.keyPrefix + ATTRS_META_KEY;\n        this.attrs = new Attributes<UserAttributes>(this.store, attrKey, this.readOnly, cacheAttrs);\n    }\n\n    private itemPath(item: string | null) {\n        const absolute = typeof item === \"string\" && item.length > 0 && item[0] === '/';\n        const path = normalizeStoragePath(item);\n        // Absolute path\n        if (!absolute && this.path.length > 0) {\n            return this.keyPrefix + path;\n        }\n        return path;\n    }\n\n    /**\n     * Create a sub-group.\n     */\n    public async createGroup(name: string, overwrite = false) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        const path = this.itemPath(name);\n        await initGroup(this.store, path, this._chunkStore, overwrite);\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n    }\n\n    /**\n     * Obtain a sub-group, creating one if it doesn't exist.\n     */\n    public async requireGroup(name: string, overwrite = false) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        const path = this.itemPath(name);\n        if (!await containsGroup(this.store, path)) {\n            await initGroup(this.store, path, this._chunkStore, overwrite);\n        }\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n    }\n\n    private getOptsForArrayCreation(name: string, opts: Omit<CreateArrayOptions, 'shape'> = {}) {\n        const path = this.itemPath(name);\n        opts.path = path;\n\n        if (opts.cacheAttrs === undefined) {\n            opts.cacheAttrs = this.attrs.cache;\n        }\n        opts.store = this.store;\n        opts.chunkStore = this.chunkStore;\n        return opts;\n    }\n\n    /**\n     * Creates an array\n     */\n    public array(name: string, data: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts?: Omit<CreateArrayOptions, 'shape'>, overwrite?: boolean) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n        opts.overwrite = overwrite === undefined ? opts.overwrite : overwrite;\n\n        return array(data, opts);\n    }\n\n    public empty(name: string, shape: number | number[], opts: Omit<CreateArrayOptions, 'shape'>= {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return empty(shape, opts);\n    }\n\n    public zeros(name: string, shape: number | number[], opts: Omit<CreateArrayOptions, 'shape'>= {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return zeros(shape, opts);\n    }\n\n    public ones(name: string, shape: number | number[], opts: Omit<CreateArrayOptions, 'shape'>= {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return ones(shape, opts);\n    }\n\n    public full(name: string, shape: number | number[], fillValue: number | null, opts: Omit<CreateArrayOptions, 'shape'> = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return full(shape, fillValue, opts);\n    }\n\n    public createDataset(name: string, shape?: number | number[], data?: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts?: Omit<CreateArrayOptions, 'shape'>) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        let z: Promise<ZarrArray>;\n        if (data === undefined) {\n            if (shape === undefined) {\n                throw new ValueError(\"Shape must be set if no data is passed to CreateDataset\");\n            }\n            z = create({ shape, ...opts });\n        } else {\n            z = array(data, opts);\n        }\n        return z;\n    }\n\n    async getItem(item: string) {\n        const path = this.itemPath(item);\n        if (await containsArray(this.store, path)) {\n            return ZarrArray.create(this.store, path, this.readOnly, this.chunkStore, undefined, this.attrs.cache);\n        } else if (await containsGroup(this.store, path)) {\n            return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n        }\n        throw new KeyError(item);\n    }\n\n    async setItem(item: string, value: any) {\n        await this.array(item, value, {}, true);\n        return true;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async deleteItem(_item: string): Promise<boolean> {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        throw new Error(\"Method not implemented.\");\n    }\n\n    async containsItem(item: string) {\n        const path = this.itemPath(item);\n        return await containsArray(this.store, path) || containsGroup(this.store, path);\n    }\n\n    proxy(): AsyncMutableMappingProxy<Group> {\n        return createProxy(this);\n    }\n}\n\n/**\n * Create a group.\n * @param store Store or path to directory in file system.\n * @param path Group path within store.\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n * @param overwrite If `true`, delete any pre-existing data in `store` at `path` before creating the group.\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations.\n *   If `false`, user attributes are reloaded from the store prior to all attribute read operations.\n */\nexport async function group(store?: Store | string, path: string | null = null, chunkStore?: Store, overwrite = false, cacheAttrs = true) {\n    store = normalizeStoreArgument(store);\n    path = normalizeStoragePath(path);\n\n    if (overwrite || await containsGroup(store)) {\n        await initGroup(store, path, chunkStore, overwrite);\n    }\n\n    return Group.create(store, path, false, chunkStore, cacheAttrs);\n}\n\n/**\n * Open a group using file-mode-like semantics.\n * @param store Store or path to directory in file system or name of zip file.\n * @param path Group path within store.\n * @param mode Persistence mode, see `PersistenceMode` type.\n * @param chunkStore Store or path to directory in file system or name of zip file.\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations\n *   If False, user attributes are reloaded from the store prior to all attribute read operations.\n *\n */\nexport async function openGroup(store?: Store | string, path: string | null = null, mode: PersistenceMode = \"a\", chunkStore?: Store, cacheAttrs = true) {\n    store = normalizeStoreArgument(store);\n    if (chunkStore !== undefined) {\n        chunkStore = normalizeStoreArgument(store);\n    }\n    path = normalizeStoragePath(path);\n\n    if (mode === \"r\" || mode === \"r+\") {\n        if (!await containsGroup(store, path)) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            throw new GroupNotFoundError(path);\n        }\n    } else if (mode === \"w\") {\n        await initGroup(store, path, chunkStore, true);\n    } else if (mode === \"a\") {\n        if (!await containsGroup(store, path)) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            await initGroup(store, path, chunkStore);\n        }\n    } else if (mode === \"w-\" || (mode as any) === \"x\") {\n        if (await containsArray(store, path)) {\n            throw new ContainsArrayError(path);\n        } else if (await containsGroup(store, path)) {\n            throw new ContainsGroupError(path);\n        } else {\n            await initGroup(store, path, chunkStore);\n        }\n    } else {\n        throw new ValueError(`Invalid mode argument: ${mode}`);\n    }\n\n    const readOnly = mode === \"r\";\n    return Group.create(store, path, readOnly, chunkStore, cacheAttrs);\n}\n","import { SyncStore, ValidStoreType } from \"./types\";\nimport { createProxy, MutableMappingProxy } from \"../mutableMapping\";\nimport { KeyError } from \"../errors\";\n\nexport class ObjectStore<T extends ValidStoreType> implements SyncStore<T> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    public object: {\n        [key: string]: T;\n    };\n\n    constructor() {\n        this.object = {};\n    }\n\n    getItem(item: string): T {\n        if (!Object.prototype.hasOwnProperty.call(this.object, item)) {\n            throw new KeyError(item);\n        }\n        return this.object[item];\n    }\n    setItem(item: string, value: T): boolean {\n        this.object[item] = value;\n        return true;\n    }\n    deleteItem(item: string): boolean {\n        return delete this.object[item];\n    }\n    containsItem(item: string): boolean {\n        return Object.prototype.hasOwnProperty.call(this.object, item);\n    }\n    proxy(): MutableMappingProxy<T> {\n        return createProxy(this);\n    }\n    keys(): string[] {\n        return Object.getOwnPropertyNames(this.object);\n    }\n}"]},"metadata":{},"sourceType":"module"}