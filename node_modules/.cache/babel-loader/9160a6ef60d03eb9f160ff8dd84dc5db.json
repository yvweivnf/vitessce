{"ast":null,"code":"import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nvar array8 = function array8(n) {\n  return new Uint8Array(n);\n};\n\nvar array16 = function array16(n) {\n  return new Uint16Array(n);\n};\n\nvar array32 = function array32(n) {\n  return new Uint32Array(n);\n};\n/**\n * Maintains CrossFilter state.\n */\n\n\nfunction Bitmaps() {\n  var width = 8,\n      _data = [],\n      _seen = array32(0),\n      _curr = array(0, width),\n      _prev = array(0, width);\n\n  return {\n    data: function data() {\n      return _data;\n    },\n    seen: function seen() {\n      return _seen = lengthen(_seen, _data.length);\n    },\n    add: function add(array) {\n      for (var i = 0, j = _data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n\n        _data.push(t);\n      }\n    },\n    remove: function remove(num, map) {\n      // map: index -> boolean (true => remove)\n      var n = _data.length,\n          copy = Array(n - num),\n          reindex = _data; // reuse old data array for index map\n\n      var t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = _data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n\n      for (j = i; i < n; ++i) {\n        t = _data[i];\n\n        if (!map[i]) {\n          reindex[i] = j;\n          _curr[j] = _curr[i];\n          _prev[j] = _prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n\n        _curr[i] = 0; // clear unused bits\n      }\n\n      _data = copy;\n      return reindex;\n    },\n    size: function size() {\n      return _data.length;\n    },\n    curr: function curr() {\n      return _curr;\n    },\n    prev: function prev() {\n      return _prev;\n    },\n    reset: function reset(k) {\n      return _prev[k] = _curr[k];\n    },\n    all: function all() {\n      return width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff;\n    },\n    set: function set(k, one) {\n      _curr[k] |= one;\n    },\n    clear: function clear(k, one) {\n      _curr[k] &= ~one;\n    },\n    resize: function resize(n, m) {\n      var k = _curr.length;\n\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        _curr = array(n, width, _curr);\n        _prev = array(n, width);\n      }\n    }\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  var copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension(index, i, query) {\n  var bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n    onAdd: function onAdd(added, curr) {\n      var dim = this,\n          range = dim.bisect(dim.range, added.value),\n          idx = added.index,\n          lo = range[0],\n          hi = range[1],\n          n1 = idx.length;\n      var i;\n\n      for (i = 0; i < lo; ++i) {\n        curr[idx[i]] |= bit;\n      }\n\n      for (i = hi; i < n1; ++i) {\n        curr[idx[i]] |= bit;\n      }\n\n      return dim;\n    }\n  };\n}\n/**\n * Maintains a list of values, sorted by key.\n */\n\n\nfunction SortedIndex() {\n  var _index = array32(0),\n      value = [],\n      _size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    var n0 = _size,\n        n1 = data.length,\n        addi = array32(n1);\n    var addv = Array(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = _index;\n      value = Array(n0 + n1);\n      _index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, _index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      _index = addi;\n    }\n\n    _size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    var n = _size;\n    var idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[_index[i]] && i < n; ++i) {\n      ;\n    } // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = _index[i]]) {\n        _index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    _size = n - num;\n  }\n\n  function reindex(map) {\n    for (var i = 0, n = _size; i < n; ++i) {\n      _index[i] = map[_index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    var n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = _size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: function index() {\n      return _index;\n    },\n    size: function size() {\n      return _size;\n    }\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, function (a, b) {\n    var x = values[a],\n        y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  var i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform: function transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(function (f) {\n        return pulse.modified(f.fields);\n      });\n\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n  init: function init(_, pulse) {\n    var fields = _.fields,\n        query = _.query,\n        indices = this._indices = {},\n        dims = this._dims = [],\n        m = query.length;\n    var i = 0,\n        key,\n        index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n  reinit: function reinit(_, pulse) {\n    var output = pulse.materialize().fork(),\n        fields = _.fields,\n        query = _.query,\n        indices = this._indices,\n        dims = this._dims,\n        bits = this.value,\n        curr = bits.curr(),\n        prev = bits.prev(),\n        all = bits.all(),\n        out = output.rem = output.add,\n        mod = output.mod,\n        m = query.length,\n        adds = {};\n    var add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n\n    if (pulse.mod.length) {\n      modMap = {};\n\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n  eval: function _eval(_, pulse) {\n    var output = pulse.materialize().fork(),\n        m = this._dims.length;\n    var mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n  insert: function insert(_, pulse, output) {\n    var tuples = pulse.add,\n        bits = this.value,\n        dims = this._dims,\n        indices = this._indices,\n        fields = _.fields,\n        adds = {},\n        out = output.add,\n        n = bits.size() + tuples.length,\n        m = dims.length;\n    var k = bits.size(),\n        j,\n        key,\n        add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    var curr = bits.curr(),\n        prev = bits.prev(),\n        all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  modify: function modify(pulse, output) {\n    var out = output.mod,\n        bits = this.value,\n        curr = bits.curr(),\n        all = bits.all(),\n        tuples = pulse.mod;\n    var i, n, k;\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  remove: function remove(_, pulse, output) {\n    var indices = this._indices,\n        bits = this.value,\n        curr = bits.curr(),\n        prev = bits.prev(),\n        all = bits.all(),\n        map = {},\n        out = output.rem,\n        tuples = pulse.rem;\n    var i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n  // reindex filters and indices after propagation completes\n  reindex: function reindex(pulse, num, map) {\n    var indices = this._indices,\n        bits = this.value;\n    pulse.runAfter(function () {\n      var indexMap = bits.remove(num, map);\n\n      for (var key in indices) {\n        indices[key].reindex(indexMap);\n      }\n    });\n  },\n  update: function update(_, pulse, output) {\n    var dims = this._dims,\n        query = _.query,\n        stamp = pulse.stamp,\n        m = dims.length;\n    var mask = 0,\n        i,\n        q; // survey how many queries have changed\n\n    output.filters = 0;\n\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n  incrementAll: function incrementAll(dim, query, stamp, out) {\n    var bits = this.value,\n        seen = bits.seen(),\n        curr = bits.curr(),\n        prev = bits.prev(),\n        index = dim.index(),\n        old = dim.bisect(dim.range),\n        range = dim.bisect(query),\n        lo1 = range[0],\n        hi1 = range[1],\n        lo0 = old[0],\n        hi0 = old[1],\n        one = dim.one;\n    var i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n  incrementOne: function incrementOne(dim, query, add, rem) {\n    var bits = this.value,\n        curr = bits.curr(),\n        index = dim.index(),\n        old = dim.bisect(dim.range),\n        range = dim.bisect(query),\n        lo1 = range[0],\n        hi1 = range[1],\n        lo0 = old[0],\n        hi0 = old[1],\n        one = dim.one;\n    var i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n});\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform: function transform(_, pulse) {\n    var ignore = ~(_.ignore || 0),\n        // bit mask where zeros -> dims to ignore\n    bitmap = _.filter,\n        mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    var output = pulse.fork(pulse.ALL),\n        data = bitmap.data(),\n        curr = bitmap.curr(),\n        prev = bitmap.prev(),\n        pass = function pass(k) {\n      return !(curr[k] & ignore) ? data[k] : null;\n    }; // propagate all mod tuples that pass the filter\n\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, function (k) {\n        return (curr[k] & ignore) === mask ? data[k] : null;\n      });\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, function (k) {\n        var c = curr[k] & ignore,\n            f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, function (k) {\n        var c = curr[k] & ignore,\n            f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n\n    return output.filter(output.SOURCE, function (t) {\n      return pass(t._index);\n    });\n  }\n});\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-crossfilter/build/vega-crossfilter.module.js"],"names":["permute","bisectLeft","bisectRight","Transform","inherits","array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","Bitmaps","width","data","seen","curr","array","prev","lengthen","length","add","i","j","t","_index","push","remove","num","map","copy","Array","reindex","size","reset","k","all","set","one","clear","resize","m","Math","max","constructor","Dimension","index","query","bit","zero","range","slice","bisect","onAdd","added","dim","value","idx","lo","hi","n1","SortedIndex","insert","key","base","n0","addi","addv","oldv","oldi","sort","merge","values","call","a","b","x","y","value0","index0","value1","index1","i0","i1","CrossFilter","params","_indices","_dims","Definition","transform","_","pulse","init","modified","fields","some","f","reinit","eval","indices","dims","fname","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","source","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","ResolveFilter","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","REM","c","SOURCE","crossfilter","resolvefilter"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,UAAlB,EAA8BC,WAA9B,QAAiD,UAAjD;AACA,SAASC,SAAT,QAA0B,eAA1B;AACA,SAASC,QAAT,QAAyB,WAAzB;;AAEA,IAAMC,MAAM,GAAG,SAATA,MAAS,CAAAC,CAAC;AAAA,SAAI,IAAIC,UAAJ,CAAeD,CAAf,CAAJ;AAAA,CAAhB;;AACA,IAAME,OAAO,GAAG,SAAVA,OAAU,CAAAF,CAAC;AAAA,SAAI,IAAIG,WAAJ,CAAgBH,CAAhB,CAAJ;AAAA,CAAjB;;AACA,IAAMI,OAAO,GAAG,SAAVA,OAAU,CAAAJ,CAAC;AAAA,SAAI,IAAIK,WAAJ,CAAgBL,CAAhB,CAAJ;AAAA,CAAjB;AAEA;;;;;AAIA,SAASM,OAAT,GAAmB;AACjB,MAAIC,KAAK,GAAG,CAAZ;AAAA,MACIC,KAAI,GAAG,EADX;AAAA,MAEIC,KAAI,GAAGL,OAAO,CAAC,CAAD,CAFlB;AAAA,MAGIM,KAAI,GAAGC,KAAK,CAAC,CAAD,EAAIJ,KAAJ,CAHhB;AAAA,MAIIK,KAAI,GAAGD,KAAK,CAAC,CAAD,EAAIJ,KAAJ,CAJhB;;AAKA,SAAO;AACLC,IAAAA,IAAI,EAAE;AAAA,aAAMA,KAAN;AAAA,KADD;AAELC,IAAAA,IAAI,EAAE;AAAA,aAAMA,KAAI,GAAGI,QAAQ,CAACJ,KAAD,EAAOD,KAAI,CAACM,MAAZ,CAArB;AAAA,KAFD;AAILC,IAAAA,GAJK,eAIDJ,KAJC,EAIM;AACT,WAAK,IAAIK,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGT,KAAI,CAACM,MAApB,EAA4Bd,CAAC,GAAGW,KAAK,CAACG,MAAtC,EAA8CI,CAAnD,EAAsDF,CAAC,GAAGhB,CAA1D,EAA6D,EAAEgB,CAA/D,EAAkE;AAChEE,QAAAA,CAAC,GAAGP,KAAK,CAACK,CAAD,CAAT;AACAE,QAAAA,CAAC,CAACC,MAAF,GAAWF,CAAC,EAAZ;;AACAT,QAAAA,KAAI,CAACY,IAAL,CAAUF,CAAV;AACD;AACF,KAVI;AAYLG,IAAAA,MAZK,kBAYEC,GAZF,EAYOC,GAZP,EAYY;AACf;AACA,UAAMvB,CAAC,GAAGQ,KAAI,CAACM,MAAf;AAAA,UACMU,IAAI,GAAGC,KAAK,CAACzB,CAAC,GAAGsB,GAAL,CADlB;AAAA,UAEMI,OAAO,GAAGlB,KAFhB,CAFe,CAIO;;AAEtB,UAAIU,CAAJ,EAAOF,CAAP,EAAUC,CAAV,CANe,CAMF;;AAEb,WAAKD,CAAC,GAAG,CAAT,EAAY,CAACO,GAAG,CAACP,CAAD,CAAJ,IAAWA,CAAC,GAAGhB,CAA3B,EAA8B,EAAEgB,CAAhC,EAAmC;AACjCQ,QAAAA,IAAI,CAACR,CAAD,CAAJ,GAAUR,KAAI,CAACQ,CAAD,CAAd;AACAU,QAAAA,OAAO,CAACV,CAAD,CAAP,GAAaA,CAAb;AACD,OAXc,CAWb;;;AAGF,WAAKC,CAAC,GAAGD,CAAT,EAAYA,CAAC,GAAGhB,CAAhB,EAAmB,EAAEgB,CAArB,EAAwB;AACtBE,QAAAA,CAAC,GAAGV,KAAI,CAACQ,CAAD,CAAR;;AAEA,YAAI,CAACO,GAAG,CAACP,CAAD,CAAR,EAAa;AACXU,UAAAA,OAAO,CAACV,CAAD,CAAP,GAAaC,CAAb;AACAP,UAAAA,KAAI,CAACO,CAAD,CAAJ,GAAUP,KAAI,CAACM,CAAD,CAAd;AACAJ,UAAAA,KAAI,CAACK,CAAD,CAAJ,GAAUL,KAAI,CAACI,CAAD,CAAd;AACAQ,UAAAA,IAAI,CAACP,CAAD,CAAJ,GAAUC,CAAV;AACAA,UAAAA,CAAC,CAACC,MAAF,GAAWF,CAAC,EAAZ;AACD,SAND,MAMO;AACLS,UAAAA,OAAO,CAACV,CAAD,CAAP,GAAa,CAAC,CAAd;AACD;;AAEDN,QAAAA,KAAI,CAACM,CAAD,CAAJ,GAAU,CAAV,CAbsB,CAaT;AACd;;AAEDR,MAAAA,KAAI,GAAGgB,IAAP;AACA,aAAOE,OAAP;AACD,KA5CI;AA8CLC,IAAAA,IAAI,EAAE;AAAA,aAAMnB,KAAI,CAACM,MAAX;AAAA,KA9CD;AA+CLJ,IAAAA,IAAI,EAAE;AAAA,aAAMA,KAAN;AAAA,KA/CD;AAgDLE,IAAAA,IAAI,EAAE;AAAA,aAAMA,KAAN;AAAA,KAhDD;AAiDLgB,IAAAA,KAAK,EAAE,eAAAC,CAAC;AAAA,aAAIjB,KAAI,CAACiB,CAAD,CAAJ,GAAUnB,KAAI,CAACmB,CAAD,CAAlB;AAAA,KAjDH;AAkDLC,IAAAA,GAAG,EAAE;AAAA,aAAMvB,KAAK,GAAG,KAAR,GAAgB,IAAhB,GAAuBA,KAAK,GAAG,OAAR,GAAkB,MAAlB,GAA2B,UAAxD;AAAA,KAlDA;AAoDLwB,IAAAA,GApDK,eAoDDF,CApDC,EAoDEG,GApDF,EAoDO;AACVtB,MAAAA,KAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACD,KAtDI;AAwDLC,IAAAA,KAxDK,iBAwDCJ,CAxDD,EAwDIG,GAxDJ,EAwDS;AACZtB,MAAAA,KAAI,CAACmB,CAAD,CAAJ,IAAW,CAACG,GAAZ;AACD,KA1DI;AA4DLE,IAAAA,MA5DK,kBA4DElC,CA5DF,EA4DKmC,CA5DL,EA4DQ;AACX,UAAMN,CAAC,GAAGnB,KAAI,CAACI,MAAf;;AAEA,UAAId,CAAC,GAAG6B,CAAJ,IAASM,CAAC,GAAG5B,KAAjB,EAAwB;AACtBA,QAAAA,KAAK,GAAG6B,IAAI,CAACC,GAAL,CAASF,CAAT,EAAY5B,KAAZ,CAAR;AACAG,QAAAA,KAAI,GAAGC,KAAK,CAACX,CAAD,EAAIO,KAAJ,EAAWG,KAAX,CAAZ;AACAE,QAAAA,KAAI,GAAGD,KAAK,CAACX,CAAD,EAAIO,KAAJ,CAAZ;AACD;AACF;AApEI,GAAP;AAuED;;AAED,SAASM,QAAT,CAAkBF,KAAlB,EAAyBG,MAAzB,EAAiCU,IAAjC,EAAuC;AACrC,MAAIb,KAAK,CAACG,MAAN,IAAgBA,MAApB,EAA4B,OAAOH,KAAP;AAC5Ba,EAAAA,IAAI,GAAGA,IAAI,IAAI,IAAIb,KAAK,CAAC2B,WAAV,CAAsBxB,MAAtB,CAAf;AACAU,EAAAA,IAAI,CAACO,GAAL,CAASpB,KAAT;AACA,SAAOa,IAAP;AACD;;AAED,SAASb,KAAT,CAAeX,CAAf,EAAkBmC,CAAlB,EAAqBxB,KAArB,EAA4B;AAC1B,MAAMa,IAAI,GAAG,CAACW,CAAC,GAAG,KAAJ,GAAYpC,MAAZ,GAAqBoC,CAAC,GAAG,OAAJ,GAAcjC,OAAd,GAAwBE,OAA9C,EAAuDJ,CAAvD,CAAb;AACA,MAAIW,KAAJ,EAAWa,IAAI,CAACO,GAAL,CAASpB,KAAT;AACX,SAAOa,IAAP;AACD;;AAED,SAASe,SAAT,CAAoBC,KAApB,EAA2BxB,CAA3B,EAA8ByB,KAA9B,EAAqC;AACnC,MAAMC,GAAG,GAAG,KAAK1B,CAAjB;AACA,SAAO;AACLgB,IAAAA,GAAG,EAAEU,GADA;AAELC,IAAAA,IAAI,EAAE,CAACD,GAFF;AAGLE,IAAAA,KAAK,EAAEH,KAAK,CAACI,KAAN,EAHF;AAILC,IAAAA,MAAM,EAAEN,KAAK,CAACM,MAJT;AAKLN,IAAAA,KAAK,EAAEA,KAAK,CAACA,KALR;AAMLb,IAAAA,IAAI,EAAEa,KAAK,CAACb,IANP;AAQLoB,IAAAA,KARK,iBAQCC,KARD,EAQQtC,IARR,EAQc;AACjB,UAAMuC,GAAG,GAAG,IAAZ;AAAA,UACML,KAAK,GAAGK,GAAG,CAACH,MAAJ,CAAWG,GAAG,CAACL,KAAf,EAAsBI,KAAK,CAACE,KAA5B,CADd;AAAA,UAEMC,GAAG,GAAGH,KAAK,CAACR,KAFlB;AAAA,UAGMY,EAAE,GAAGR,KAAK,CAAC,CAAD,CAHhB;AAAA,UAIMS,EAAE,GAAGT,KAAK,CAAC,CAAD,CAJhB;AAAA,UAKMU,EAAE,GAAGH,GAAG,CAACrC,MALf;AAMA,UAAIE,CAAJ;;AAEA,WAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGoC,EAAhB,EAAoB,EAAEpC,CAAtB;AAAyBN,QAAAA,IAAI,CAACyC,GAAG,CAACnC,CAAD,CAAJ,CAAJ,IAAgB0B,GAAhB;AAAzB;;AAEA,WAAK1B,CAAC,GAAGqC,EAAT,EAAarC,CAAC,GAAGsC,EAAjB,EAAqB,EAAEtC,CAAvB;AAA0BN,QAAAA,IAAI,CAACyC,GAAG,CAACnC,CAAD,CAAJ,CAAJ,IAAgB0B,GAAhB;AAA1B;;AAEA,aAAOO,GAAP;AACD;AAtBI,GAAP;AAyBD;AAED;;;;;AAIA,SAASM,WAAT,GAAuB;AACrB,MAAIf,MAAK,GAAGpC,OAAO,CAAC,CAAD,CAAnB;AAAA,MACI8C,KAAK,GAAG,EADZ;AAAA,MAEIvB,KAAI,GAAG,CAFX;;AAIA,WAAS6B,MAAT,CAAgBC,GAAhB,EAAqBjD,IAArB,EAA2BkD,IAA3B,EAAiC;AAC/B,QAAI,CAAClD,IAAI,CAACM,MAAV,EAAkB,OAAO,EAAP;AAClB,QAAM6C,EAAE,GAAGhC,KAAX;AAAA,QACM2B,EAAE,GAAG9C,IAAI,CAACM,MADhB;AAAA,QAEM8C,IAAI,GAAGxD,OAAO,CAACkD,EAAD,CAFpB;AAGA,QAAIO,IAAI,GAAGpC,KAAK,CAAC6B,EAAD,CAAhB;AAAA,QACIQ,IADJ;AAAA,QAEIC,IAFJ;AAAA,QAGI/C,CAHJ;;AAKA,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsC,EAAhB,EAAoB,EAAEtC,CAAtB,EAAyB;AACvB6C,MAAAA,IAAI,CAAC7C,CAAD,CAAJ,GAAUyC,GAAG,CAACjD,IAAI,CAACQ,CAAD,CAAL,CAAb;AACA4C,MAAAA,IAAI,CAAC5C,CAAD,CAAJ,GAAUA,CAAV;AACD;;AAED6C,IAAAA,IAAI,GAAGG,IAAI,CAACH,IAAD,EAAOD,IAAP,CAAX;;AAEA,QAAID,EAAJ,EAAQ;AACNG,MAAAA,IAAI,GAAGZ,KAAP;AACAa,MAAAA,IAAI,GAAGvB,MAAP;AACAU,MAAAA,KAAK,GAAGzB,KAAK,CAACkC,EAAE,GAAGL,EAAN,CAAb;AACAd,MAAAA,MAAK,GAAGpC,OAAO,CAACuD,EAAE,GAAGL,EAAN,CAAf;AACAW,MAAAA,KAAK,CAACP,IAAD,EAAOI,IAAP,EAAaC,IAAb,EAAmBJ,EAAnB,EAAuBE,IAAvB,EAA6BD,IAA7B,EAAmCN,EAAnC,EAAuCJ,KAAvC,EAA8CV,MAA9C,CAAL;AACD,KAND,MAMO;AACL,UAAIkB,IAAI,GAAG,CAAX,EAAc,KAAK1C,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsC,EAAhB,EAAoB,EAAEtC,CAAtB,EAAyB;AACrC4C,QAAAA,IAAI,CAAC5C,CAAD,CAAJ,IAAW0C,IAAX;AACD;AACDR,MAAAA,KAAK,GAAGW,IAAR;AACArB,MAAAA,MAAK,GAAGoB,IAAR;AACD;;AAEDjC,IAAAA,KAAI,GAAGgC,EAAE,GAAGL,EAAZ;AACA,WAAO;AACLd,MAAAA,KAAK,EAAEoB,IADF;AAELV,MAAAA,KAAK,EAAEW;AAFF,KAAP;AAID;;AAED,WAASxC,MAAT,CAAgBC,GAAhB,EAAqBC,GAArB,EAA0B;AACxB;AACA,QAAMvB,CAAC,GAAG2B,KAAV;AACA,QAAIwB,GAAJ,EAASnC,CAAT,EAAYC,CAAZ,CAHwB,CAGT;;AAEf,SAAKD,CAAC,GAAG,CAAT,EAAY,CAACO,GAAG,CAACiB,MAAK,CAACxB,CAAD,CAAN,CAAJ,IAAkBA,CAAC,GAAGhB,CAAlC,EAAqC,EAAEgB,CAAvC;AAAyC;AAAzC,KALwB,CAKmB;;;AAG3C,SAAKC,CAAC,GAAGD,CAAT,EAAYA,CAAC,GAAGhB,CAAhB,EAAmB,EAAEgB,CAArB,EAAwB;AACtB,UAAI,CAACO,GAAG,CAAC4B,GAAG,GAAGX,MAAK,CAACxB,CAAD,CAAZ,CAAR,EAA0B;AACxBwB,QAAAA,MAAK,CAACvB,CAAD,CAAL,GAAWkC,GAAX;AACAD,QAAAA,KAAK,CAACjC,CAAD,CAAL,GAAWiC,KAAK,CAAClC,CAAD,CAAhB;AACA,UAAEC,CAAF;AACD;AACF;;AAEDU,IAAAA,KAAI,GAAG3B,CAAC,GAAGsB,GAAX;AACD;;AAED,WAASI,OAAT,CAAiBH,GAAjB,EAAsB;AACpB,SAAK,IAAIP,CAAC,GAAG,CAAR,EAAWhB,CAAC,GAAG2B,KAApB,EAA0BX,CAAC,GAAGhB,CAA9B,EAAiC,EAAEgB,CAAnC,EAAsC;AACpCwB,MAAAA,MAAK,CAACxB,CAAD,CAAL,GAAWO,GAAG,CAACiB,MAAK,CAACxB,CAAD,CAAN,CAAd;AACD;AACF;;AAED,WAAS8B,MAAT,CAAgBF,KAAhB,EAAuBjC,KAAvB,EAA8B;AAC5B,QAAIX,CAAJ;;AAEA,QAAIW,KAAJ,EAAW;AACTX,MAAAA,CAAC,GAAGW,KAAK,CAACG,MAAV;AACD,KAFD,MAEO;AACLH,MAAAA,KAAK,GAAGuC,KAAR;AACAlD,MAAAA,CAAC,GAAG2B,KAAJ;AACD;;AAED,WAAO,CAAChC,UAAU,CAACgB,KAAD,EAAQiC,KAAK,CAAC,CAAD,CAAb,EAAkB,CAAlB,EAAqB5C,CAArB,CAAX,EAAoCJ,WAAW,CAACe,KAAD,EAAQiC,KAAK,CAAC,CAAD,CAAb,EAAkB,CAAlB,EAAqB5C,CAArB,CAA/C,CAAP;AACD;;AAED,SAAO;AACLwD,IAAAA,MAAM,EAAEA,MADH;AAELnC,IAAAA,MAAM,EAAEA,MAFH;AAGLyB,IAAAA,MAAM,EAAEA,MAHH;AAILpB,IAAAA,OAAO,EAAEA,OAJJ;AAKLc,IAAAA,KAAK,EAAE;AAAA,aAAMA,MAAN;AAAA,KALF;AAMLb,IAAAA,IAAI,EAAE;AAAA,aAAMA,KAAN;AAAA;AAND,GAAP;AAQD;;AAED,SAASqC,IAAT,CAAcE,MAAd,EAAsB1B,KAAtB,EAA6B;AAC3B0B,EAAAA,MAAM,CAACF,IAAP,CAAYG,IAAZ,CAAiB3B,KAAjB,EAAwB,UAAC4B,CAAD,EAAIC,CAAJ,EAAU;AAChC,QAAMC,CAAC,GAAGJ,MAAM,CAACE,CAAD,CAAhB;AAAA,QACMG,CAAC,GAAGL,MAAM,CAACG,CAAD,CADhB;AAEA,WAAOC,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAaD,CAAC,GAAGC,CAAJ,GAAQ,CAAR,GAAY,CAAhC;AACD,GAJD;AAKA,SAAO7E,OAAO,CAACwE,MAAD,EAAS1B,KAAT,CAAd;AACD;;AAED,SAASyB,KAAT,CAAeP,IAAf,EAAqBc,MAArB,EAA6BC,MAA7B,EAAqCd,EAArC,EAAyCe,MAAzC,EAAiDC,MAAjD,EAAyDrB,EAAzD,EAA6DJ,KAA7D,EAAoEV,KAApE,EAA2E;AACzE,MAAIoC,EAAE,GAAG,CAAT;AAAA,MACIC,EAAE,GAAG,CADT;AAAA,MAEI7D,CAFJ;;AAIA,OAAKA,CAAC,GAAG,CAAT,EAAY4D,EAAE,GAAGjB,EAAL,IAAWkB,EAAE,GAAGvB,EAA5B,EAAgC,EAAEtC,CAAlC,EAAqC;AACnC,QAAIwD,MAAM,CAACI,EAAD,CAAN,GAAaF,MAAM,CAACG,EAAD,CAAvB,EAA6B;AAC3B3B,MAAAA,KAAK,CAAClC,CAAD,CAAL,GAAWwD,MAAM,CAACI,EAAD,CAAjB;AACApC,MAAAA,KAAK,CAACxB,CAAD,CAAL,GAAWyD,MAAM,CAACG,EAAE,EAAH,CAAjB;AACD,KAHD,MAGO;AACL1B,MAAAA,KAAK,CAAClC,CAAD,CAAL,GAAW0D,MAAM,CAACG,EAAD,CAAjB;AACArC,MAAAA,KAAK,CAACxB,CAAD,CAAL,GAAW2D,MAAM,CAACE,EAAE,EAAH,CAAN,GAAenB,IAA1B;AACD;AACF;;AAED,SAAOkB,EAAE,GAAGjB,EAAZ,EAAgB,EAAEiB,EAAF,EAAM,EAAE5D,CAAxB,EAA2B;AACzBkC,IAAAA,KAAK,CAAClC,CAAD,CAAL,GAAWwD,MAAM,CAACI,EAAD,CAAjB;AACApC,IAAAA,KAAK,CAACxB,CAAD,CAAL,GAAWyD,MAAM,CAACG,EAAD,CAAjB;AACD;;AAED,SAAOC,EAAE,GAAGvB,EAAZ,EAAgB,EAAEuB,EAAF,EAAM,EAAE7D,CAAxB,EAA2B;AACzBkC,IAAAA,KAAK,CAAClC,CAAD,CAAL,GAAW0D,MAAM,CAACG,EAAD,CAAjB;AACArC,IAAAA,KAAK,CAACxB,CAAD,CAAL,GAAW2D,MAAM,CAACE,EAAD,CAAN,GAAanB,IAAxB;AACD;AACF;AAED;;;;;;;;;AAQA,SAASoB,WAAT,CAAqBC,MAArB,EAA6B;AAC3BlF,EAAAA,SAAS,CAACsE,IAAV,CAAe,IAAf,EAAqB7D,OAAO,EAA5B,EAAgCyE,MAAhC;AACA,OAAKC,QAAL,GAAgB,IAAhB;AACA,OAAKC,KAAL,GAAa,IAAb;AACD;;AACDH,WAAW,CAACI,UAAZ,GAAyB;AACvB,UAAQ,aADe;AAEvB,cAAY,EAFW;AAGvB,YAAU,CAAC;AACT,YAAQ,QADC;AAET,YAAQ,OAFC;AAGT,aAAS,IAHA;AAIT,gBAAY;AAJH,GAAD,EAKP;AACD,YAAQ,OADP;AAED,YAAQ,OAFP;AAGD,aAAS,IAHR;AAID,gBAAY,IAJX;AAKD,eAAW;AACT,cAAQ,QADC;AAET,eAAS,IAFA;AAGT,gBAAU;AAHD;AALV,GALO;AAHa,CAAzB;AAoBApF,QAAQ,CAACgF,WAAD,EAAcjF,SAAd,EAAyB;AAC/BsF,EAAAA,SAD+B,qBACrBC,CADqB,EAClBC,KADkB,EACX;AAClB,QAAI,CAAC,KAAKJ,KAAV,EAAiB;AACf,aAAO,KAAKK,IAAL,CAAUF,CAAV,EAAaC,KAAb,CAAP;AACD,KAFD,MAEO;AACL,UAAIC,IAAI,GAAGF,CAAC,CAACG,QAAF,CAAW,QAAX,KAAwBH,CAAC,CAACI,MAAF,CAASC,IAAT,CAAc,UAAAC,CAAC;AAAA,eAAIL,KAAK,CAACE,QAAN,CAAeG,CAAC,CAACF,MAAjB,CAAJ;AAAA,OAAf,CAAnC;;AAEA,aAAOF,IAAI,GAAG,KAAKK,MAAL,CAAYP,CAAZ,EAAeC,KAAf,CAAH,GAA2B,KAAKO,IAAL,CAAUR,CAAV,EAAaC,KAAb,CAAtC;AACD;AACF,GAT8B;AAW/BC,EAAAA,IAX+B,gBAW1BF,CAX0B,EAWvBC,KAXuB,EAWhB;AACb,QAAMG,MAAM,GAAGJ,CAAC,CAACI,MAAjB;AAAA,QACM/C,KAAK,GAAG2C,CAAC,CAAC3C,KADhB;AAAA,QAEMoD,OAAO,GAAG,KAAKb,QAAL,GAAgB,EAFhC;AAAA,QAGMc,IAAI,GAAG,KAAKb,KAAL,GAAa,EAH1B;AAAA,QAIM9C,CAAC,GAAGM,KAAK,CAAC3B,MAJhB;AAKA,QAAIE,CAAC,GAAG,CAAR;AAAA,QACIyC,GADJ;AAAA,QAEIjB,KAFJ,CANa,CAQF;;AAEX,WAAOxB,CAAC,GAAGmB,CAAX,EAAc,EAAEnB,CAAhB,EAAmB;AACjByC,MAAAA,GAAG,GAAG+B,MAAM,CAACxE,CAAD,CAAN,CAAU+E,KAAhB;AACAvD,MAAAA,KAAK,GAAGqD,OAAO,CAACpC,GAAD,CAAP,KAAiBoC,OAAO,CAACpC,GAAD,CAAP,GAAeF,WAAW,EAA3C,CAAR;AACAuC,MAAAA,IAAI,CAAC1E,IAAL,CAAUmB,SAAS,CAACC,KAAD,EAAQxB,CAAR,EAAWyB,KAAK,CAACzB,CAAD,CAAhB,CAAnB;AACD;;AAED,WAAO,KAAK4E,IAAL,CAAUR,CAAV,EAAaC,KAAb,CAAP;AACD,GA5B8B;AA8B/BM,EAAAA,MA9B+B,kBA8BxBP,CA9BwB,EA8BrBC,KA9BqB,EA8Bd;AACf,QAAMW,MAAM,GAAGX,KAAK,CAACY,WAAN,GAAoBC,IAApB,EAAf;AAAA,QACMV,MAAM,GAAGJ,CAAC,CAACI,MADjB;AAAA,QAEM/C,KAAK,GAAG2C,CAAC,CAAC3C,KAFhB;AAAA,QAGMoD,OAAO,GAAG,KAAKb,QAHrB;AAAA,QAIMc,IAAI,GAAG,KAAKb,KAJlB;AAAA,QAKMkB,IAAI,GAAG,KAAKjD,KALlB;AAAA,QAMMxC,IAAI,GAAGyF,IAAI,CAACzF,IAAL,EANb;AAAA,QAOME,IAAI,GAAGuF,IAAI,CAACvF,IAAL,EAPb;AAAA,QAQMkB,GAAG,GAAGqE,IAAI,CAACrE,GAAL,EARZ;AAAA,QASMsE,GAAG,GAAGJ,MAAM,CAACK,GAAP,GAAaL,MAAM,CAACjF,GAThC;AAAA,QAUMuF,GAAG,GAAGN,MAAM,CAACM,GAVnB;AAAA,QAWMnE,CAAC,GAAGM,KAAK,CAAC3B,MAXhB;AAAA,QAYMyF,IAAI,GAAG,EAZb;AAaA,QAAIxF,GAAJ,EAASyB,KAAT,EAAgBiB,GAAhB,EAAqB+C,IAArB,EAA2BC,MAA3B,EAAmCC,MAAnC,EAA2C1F,CAA3C,EAA8ChB,CAA9C,EAAiD0F,CAAjD,CAde,CAcqC;;AAEpD9E,IAAAA,IAAI,CAACmB,GAAL,CAASrB,IAAT,EAhBe,CAgBC;;AAEhB,QAAI2E,KAAK,CAACgB,GAAN,CAAUvF,MAAd,EAAsB;AACpB2F,MAAAA,MAAM,GAAG,KAAKpF,MAAL,CAAY+D,CAAZ,EAAeC,KAAf,EAAsBW,MAAtB,CAAT;AACD,KApBc,CAoBb;;;AAGF,QAAIX,KAAK,CAACtE,GAAN,CAAUD,MAAd,EAAsB;AACpBqF,MAAAA,IAAI,CAACpF,GAAL,CAASsE,KAAK,CAACtE,GAAf;AACD,KAzBc,CAyBb;;;AAGF,QAAIsE,KAAK,CAACiB,GAAN,CAAUxF,MAAd,EAAsB;AACpB4F,MAAAA,MAAM,GAAG,EAAT;;AAEA,WAAKF,IAAI,GAAGnB,KAAK,CAACiB,GAAb,EAAkBtF,CAAC,GAAG,CAAtB,EAAyBhB,CAAC,GAAGwG,IAAI,CAAC1F,MAAvC,EAA+CE,CAAC,GAAGhB,CAAnD,EAAsD,EAAEgB,CAAxD,EAA2D;AACzD0F,QAAAA,MAAM,CAACF,IAAI,CAACxF,CAAD,CAAJ,CAAQG,MAAT,CAAN,GAAyB,CAAzB;AACD;AACF,KAlCc,CAkCb;;;AAGF,SAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGmB,CAAhB,EAAmB,EAAEnB,CAArB,EAAwB;AACtB0E,MAAAA,CAAC,GAAGF,MAAM,CAACxE,CAAD,CAAV;;AAEA,UAAI,CAAC8E,IAAI,CAAC9E,CAAD,CAAL,IAAYoE,CAAC,CAACG,QAAF,CAAW,QAAX,EAAqBvE,CAArB,CAAZ,IAAuCqE,KAAK,CAACE,QAAN,CAAeG,CAAC,CAACF,MAAjB,CAA3C,EAAqE;AACnE/B,QAAAA,GAAG,GAAGiC,CAAC,CAACK,KAAR;;AAEA,YAAI,EAAEhF,GAAG,GAAGwF,IAAI,CAAC9C,GAAD,CAAZ,CAAJ,EAAwB;AACtBoC,UAAAA,OAAO,CAACpC,GAAD,CAAP,GAAejB,KAAK,GAAGe,WAAW,EAAlC;AACAgD,UAAAA,IAAI,CAAC9C,GAAD,CAAJ,GAAY1C,GAAG,GAAGyB,KAAK,CAACgB,MAAN,CAAakC,CAAb,EAAgBL,KAAK,CAACsB,MAAtB,EAA8B,CAA9B,CAAlB;AACD;;AAEDb,QAAAA,IAAI,CAAC9E,CAAD,CAAJ,GAAUuB,SAAS,CAACC,KAAD,EAAQxB,CAAR,EAAWyB,KAAK,CAACzB,CAAD,CAAhB,CAAT,CAA8B+B,KAA9B,CAAoChC,GAApC,EAAyCL,IAAzC,CAAV;AACD;AACF,KAlDc,CAkDb;AACF;AACA;;;AAGA,SAAKM,CAAC,GAAG,CAAJ,EAAOhB,CAAC,GAAGmG,IAAI,CAAC3F,IAAL,GAAYM,MAA5B,EAAoCE,CAAC,GAAGhB,CAAxC,EAA2C,EAAEgB,CAA7C,EAAgD;AAC9C,UAAIyF,MAAM,CAACzF,CAAD,CAAV,EAAe;AACb;AACA;AACD,OAHD,MAGO,IAAIJ,IAAI,CAACI,CAAD,CAAJ,KAAYN,IAAI,CAACM,CAAD,CAApB,EAAyB;AAC9B;AACAoF,QAAAA,GAAG,CAAChF,IAAJ,CAASJ,CAAT;AACD,OAHM,MAGA,IAAI0F,MAAM,CAAC1F,CAAD,CAAN,IAAaN,IAAI,CAACM,CAAD,CAAJ,KAAYc,GAA7B,EAAkC;AACvC;AACAwE,QAAAA,GAAG,CAAClF,IAAJ,CAASJ,CAAT;AACD;AACF;;AAEDmF,IAAAA,IAAI,CAACS,IAAL,GAAY,CAAC,KAAKzE,CAAN,IAAW,CAAvB;AACA,WAAO6D,MAAP;AACD,GApG8B;AAsG/BJ,EAAAA,IAtG+B,iBAsG1BR,CAtG0B,EAsGvBC,KAtGuB,EAsGhB;AACb,QAAMW,MAAM,GAAGX,KAAK,CAACY,WAAN,GAAoBC,IAApB,EAAf;AAAA,QACM/D,CAAC,GAAG,KAAK8C,KAAL,CAAWnE,MADrB;AAEA,QAAI8F,IAAI,GAAG,CAAX;;AAEA,QAAIvB,KAAK,CAACgB,GAAN,CAAUvF,MAAd,EAAsB;AACpB,WAAKO,MAAL,CAAY+D,CAAZ,EAAeC,KAAf,EAAsBW,MAAtB;AACAY,MAAAA,IAAI,IAAI,CAAC,KAAKzE,CAAN,IAAW,CAAnB;AACD;;AAED,QAAIiD,CAAC,CAACG,QAAF,CAAW,OAAX,KAAuB,CAACH,CAAC,CAACG,QAAF,CAAW,QAAX,CAA5B,EAAkD;AAChDqB,MAAAA,IAAI,IAAI,KAAKC,MAAL,CAAYzB,CAAZ,EAAeC,KAAf,EAAsBW,MAAtB,CAAR;AACD;;AAED,QAAIX,KAAK,CAACtE,GAAN,CAAUD,MAAd,EAAsB;AACpB,WAAK0C,MAAL,CAAY4B,CAAZ,EAAeC,KAAf,EAAsBW,MAAtB;AACAY,MAAAA,IAAI,IAAI,CAAC,KAAKzE,CAAN,IAAW,CAAnB;AACD;;AAED,QAAIkD,KAAK,CAACiB,GAAN,CAAUxF,MAAd,EAAsB;AACpB,WAAKgG,MAAL,CAAYzB,KAAZ,EAAmBW,MAAnB;AACAY,MAAAA,IAAI,IAAI,CAAC,KAAKzE,CAAN,IAAW,CAAnB;AACD;;AAED,SAAKe,KAAL,CAAW0D,IAAX,GAAkBA,IAAlB;AACA,WAAOZ,MAAP;AACD,GAhI8B;AAkI/BxC,EAAAA,MAlI+B,kBAkIxB4B,CAlIwB,EAkIrBC,KAlIqB,EAkIdW,MAlIc,EAkIN;AACvB,QAAMe,MAAM,GAAG1B,KAAK,CAACtE,GAArB;AAAA,QACMoF,IAAI,GAAG,KAAKjD,KADlB;AAAA,QAEM4C,IAAI,GAAG,KAAKb,KAFlB;AAAA,QAGMY,OAAO,GAAG,KAAKb,QAHrB;AAAA,QAIMQ,MAAM,GAAGJ,CAAC,CAACI,MAJjB;AAAA,QAKMe,IAAI,GAAG,EALb;AAAA,QAMMH,GAAG,GAAGJ,MAAM,CAACjF,GANnB;AAAA,QAOMf,CAAC,GAAGmG,IAAI,CAACxE,IAAL,KAAcoF,MAAM,CAACjG,MAP/B;AAAA,QAQMqB,CAAC,GAAG2D,IAAI,CAAChF,MARf;AASA,QAAIe,CAAC,GAAGsE,IAAI,CAACxE,IAAL,EAAR;AAAA,QACIV,CADJ;AAAA,QAEIwC,GAFJ;AAAA,QAGI1C,GAHJ,CAVuB,CAad;;AAEToF,IAAAA,IAAI,CAACjE,MAAL,CAAYlC,CAAZ,EAAemC,CAAf;AACAgE,IAAAA,IAAI,CAACpF,GAAL,CAASgG,MAAT;AACA,QAAMrG,IAAI,GAAGyF,IAAI,CAACzF,IAAL,EAAb;AAAA,QACME,IAAI,GAAGuF,IAAI,CAACvF,IAAL,EADb;AAAA,QAEMkB,GAAG,GAAGqE,IAAI,CAACrE,GAAL,EAFZ,CAjBuB,CAmBC;;AAExB,SAAKb,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGkB,CAAhB,EAAmB,EAAElB,CAArB,EAAwB;AACtBwC,MAAAA,GAAG,GAAG+B,MAAM,CAACvE,CAAD,CAAN,CAAU8E,KAAhB;AACAhF,MAAAA,GAAG,GAAGwF,IAAI,CAAC9C,GAAD,CAAJ,KAAc8C,IAAI,CAAC9C,GAAD,CAAJ,GAAYoC,OAAO,CAACpC,GAAD,CAAP,CAAaD,MAAb,CAAoBgC,MAAM,CAACvE,CAAD,CAA1B,EAA+B8F,MAA/B,EAAuClF,CAAvC,CAA1B,CAAN;AACAiE,MAAAA,IAAI,CAAC7E,CAAD,CAAJ,CAAQ8B,KAAR,CAAchC,GAAd,EAAmBL,IAAnB;AACD,KAzBsB,CAyBrB;;;AAGF,WAAOmB,CAAC,GAAG7B,CAAX,EAAc,EAAE6B,CAAhB,EAAmB;AACjBjB,MAAAA,IAAI,CAACiB,CAAD,CAAJ,GAAUC,GAAV;AACA,UAAIpB,IAAI,CAACmB,CAAD,CAAJ,KAAYC,GAAhB,EAAqBsE,GAAG,CAAChF,IAAJ,CAASS,CAAT;AACtB;AACF,GAlK8B;AAoK/BiF,EAAAA,MApK+B,kBAoKxBzB,KApKwB,EAoKjBW,MApKiB,EAoKT;AACpB,QAAMI,GAAG,GAAGJ,MAAM,CAACM,GAAnB;AAAA,QACMH,IAAI,GAAG,KAAKjD,KADlB;AAAA,QAEMxC,IAAI,GAAGyF,IAAI,CAACzF,IAAL,EAFb;AAAA,QAGMoB,GAAG,GAAGqE,IAAI,CAACrE,GAAL,EAHZ;AAAA,QAIMiF,MAAM,GAAG1B,KAAK,CAACiB,GAJrB;AAKA,QAAItF,CAAJ,EAAOhB,CAAP,EAAU6B,CAAV;;AAEA,SAAKb,CAAC,GAAG,CAAJ,EAAOhB,CAAC,GAAG+G,MAAM,CAACjG,MAAvB,EAA+BE,CAAC,GAAGhB,CAAnC,EAAsC,EAAEgB,CAAxC,EAA2C;AACzCa,MAAAA,CAAC,GAAGkF,MAAM,CAAC/F,CAAD,CAAN,CAAUG,MAAd;AACA,UAAIT,IAAI,CAACmB,CAAD,CAAJ,KAAYC,GAAhB,EAAqBsE,GAAG,CAAChF,IAAJ,CAASS,CAAT;AACtB;AACF,GAhL8B;AAkL/BR,EAAAA,MAlL+B,kBAkLxB+D,CAlLwB,EAkLrBC,KAlLqB,EAkLdW,MAlLc,EAkLN;AACvB,QAAMH,OAAO,GAAG,KAAKb,QAArB;AAAA,QACMmB,IAAI,GAAG,KAAKjD,KADlB;AAAA,QAEMxC,IAAI,GAAGyF,IAAI,CAACzF,IAAL,EAFb;AAAA,QAGME,IAAI,GAAGuF,IAAI,CAACvF,IAAL,EAHb;AAAA,QAIMkB,GAAG,GAAGqE,IAAI,CAACrE,GAAL,EAJZ;AAAA,QAKMP,GAAG,GAAG,EALZ;AAAA,QAMM6E,GAAG,GAAGJ,MAAM,CAACK,GANnB;AAAA,QAOMU,MAAM,GAAG1B,KAAK,CAACgB,GAPrB;AAQA,QAAIrF,CAAJ,EAAOhB,CAAP,EAAU6B,CAAV,EAAa6D,CAAb,CATuB,CASP;;AAEhB,SAAK1E,CAAC,GAAG,CAAJ,EAAOhB,CAAC,GAAG+G,MAAM,CAACjG,MAAvB,EAA+BE,CAAC,GAAGhB,CAAnC,EAAsC,EAAEgB,CAAxC,EAA2C;AACzCa,MAAAA,CAAC,GAAGkF,MAAM,CAAC/F,CAAD,CAAN,CAAUG,MAAd;AACAI,MAAAA,GAAG,CAACM,CAAD,CAAH,GAAS,CAAT,CAFyC,CAE7B;;AAEZjB,MAAAA,IAAI,CAACiB,CAAD,CAAJ,GAAU6D,CAAC,GAAGhF,IAAI,CAACmB,CAAD,CAAlB;AACAnB,MAAAA,IAAI,CAACmB,CAAD,CAAJ,GAAUC,GAAV;AACA,UAAI4D,CAAC,KAAK5D,GAAV,EAAesE,GAAG,CAAChF,IAAJ,CAASS,CAAT;AAChB,KAlBsB,CAkBrB;;;AAGF,SAAKA,CAAL,IAAUgE,OAAV,EAAmB;AACjBA,MAAAA,OAAO,CAAChE,CAAD,CAAP,CAAWR,MAAX,CAAkBrB,CAAlB,EAAqBuB,GAArB;AACD;;AAED,SAAKG,OAAL,CAAa2D,KAAb,EAAoBrF,CAApB,EAAuBuB,GAAvB;AACA,WAAOA,GAAP;AACD,GA7M8B;AA+M/B;AACAG,EAAAA,OAhN+B,mBAgNvB2D,KAhNuB,EAgNhB/D,GAhNgB,EAgNXC,GAhNW,EAgNN;AACvB,QAAMsE,OAAO,GAAG,KAAKb,QAArB;AAAA,QACMmB,IAAI,GAAG,KAAKjD,KADlB;AAEAmC,IAAAA,KAAK,CAAC2B,QAAN,CAAe,YAAM;AACnB,UAAMC,QAAQ,GAAGd,IAAI,CAAC9E,MAAL,CAAYC,GAAZ,EAAiBC,GAAjB,CAAjB;;AAEA,WAAK,IAAMkC,GAAX,IAAkBoC,OAAlB;AAA2BA,QAAAA,OAAO,CAACpC,GAAD,CAAP,CAAa/B,OAAb,CAAqBuF,QAArB;AAA3B;AACD,KAJD;AAKD,GAxN8B;AA0N/BJ,EAAAA,MA1N+B,kBA0NxBzB,CA1NwB,EA0NrBC,KA1NqB,EA0NdW,MA1Nc,EA0NN;AACvB,QAAMF,IAAI,GAAG,KAAKb,KAAlB;AAAA,QACMxC,KAAK,GAAG2C,CAAC,CAAC3C,KADhB;AAAA,QAEMyE,KAAK,GAAG7B,KAAK,CAAC6B,KAFpB;AAAA,QAGM/E,CAAC,GAAG2D,IAAI,CAAChF,MAHf;AAIA,QAAI8F,IAAI,GAAG,CAAX;AAAA,QACI5F,CADJ;AAAA,QAEImG,CAFJ,CALuB,CAOhB;;AAEPnB,IAAAA,MAAM,CAACoB,OAAP,GAAiB,CAAjB;;AAEA,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGhF,CAAhB,EAAmB,EAAEgF,CAArB,EAAwB;AACtB,UAAI/B,CAAC,CAACG,QAAF,CAAW,OAAX,EAAoB4B,CAApB,CAAJ,EAA4B;AAC1BnG,QAAAA,CAAC,GAAGmG,CAAJ;AACA,UAAEP,IAAF;AACD;AACF;;AAED,QAAIA,IAAI,KAAK,CAAb,EAAgB;AACd;AACAA,MAAAA,IAAI,GAAGd,IAAI,CAAC9E,CAAD,CAAJ,CAAQgB,GAAf;AACA,WAAKqF,YAAL,CAAkBvB,IAAI,CAAC9E,CAAD,CAAtB,EAA2ByB,KAAK,CAACzB,CAAD,CAAhC,EAAqCgF,MAAM,CAACjF,GAA5C,EAAiDiF,MAAM,CAACK,GAAxD;AACD,KAJD,MAIO;AACL;AACA,WAAKc,CAAC,GAAG,CAAJ,EAAOP,IAAI,GAAG,CAAnB,EAAsBO,CAAC,GAAGhF,CAA1B,EAA6B,EAAEgF,CAA/B,EAAkC;AAChC,YAAI,CAAC/B,CAAC,CAACG,QAAF,CAAW,OAAX,EAAoB4B,CAApB,CAAL,EAA6B;AAC7BP,QAAAA,IAAI,IAAId,IAAI,CAACqB,CAAD,CAAJ,CAAQnF,GAAhB;AACA,aAAKsF,YAAL,CAAkBxB,IAAI,CAACqB,CAAD,CAAtB,EAA2B1E,KAAK,CAAC0E,CAAD,CAAhC,EAAqCD,KAArC,EAA4ClB,MAAM,CAACjF,GAAnD;AACAiF,QAAAA,MAAM,CAACK,GAAP,GAAaL,MAAM,CAACjF,GAApB,CAJgC,CAIP;AAC1B;AACF;;AAED,WAAO6F,IAAP;AACD,GA3P8B;AA6P/BU,EAAAA,YA7P+B,wBA6PlBrE,GA7PkB,EA6PbR,KA7Pa,EA6PNyE,KA7PM,EA6PCd,GA7PD,EA6PM;AACnC,QAAMD,IAAI,GAAG,KAAKjD,KAAlB;AAAA,QACMzC,IAAI,GAAG0F,IAAI,CAAC1F,IAAL,EADb;AAAA,QAEMC,IAAI,GAAGyF,IAAI,CAACzF,IAAL,EAFb;AAAA,QAGME,IAAI,GAAGuF,IAAI,CAACvF,IAAL,EAHb;AAAA,QAIM4B,KAAK,GAAGS,GAAG,CAACT,KAAJ,EAJd;AAAA,QAKM+E,GAAG,GAAGtE,GAAG,CAACH,MAAJ,CAAWG,GAAG,CAACL,KAAf,CALZ;AAAA,QAMMA,KAAK,GAAGK,GAAG,CAACH,MAAJ,CAAWL,KAAX,CANd;AAAA,QAOM+E,GAAG,GAAG5E,KAAK,CAAC,CAAD,CAPjB;AAAA,QAQM6E,GAAG,GAAG7E,KAAK,CAAC,CAAD,CARjB;AAAA,QASM8E,GAAG,GAAGH,GAAG,CAAC,CAAD,CATf;AAAA,QAUMI,GAAG,GAAGJ,GAAG,CAAC,CAAD,CAVf;AAAA,QAWMvF,GAAG,GAAGiB,GAAG,CAACjB,GAXhB;AAYA,QAAIhB,CAAJ,EAAOC,CAAP,EAAUY,CAAV,CAbmC,CAatB;;AAEb,QAAI2F,GAAG,GAAGE,GAAV,EAAe;AACb,WAAK1G,CAAC,GAAGwG,GAAJ,EAASvG,CAAC,GAAGmB,IAAI,CAACwF,GAAL,CAASF,GAAT,EAAcD,GAAd,CAAlB,EAAsCzG,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;;AAEA,YAAIP,IAAI,CAACoB,CAAD,CAAJ,KAAYqF,KAAhB,EAAuB;AACrBtG,UAAAA,IAAI,CAACiB,CAAD,CAAJ,GAAUnB,IAAI,CAACmB,CAAD,CAAd;AACApB,UAAAA,IAAI,CAACoB,CAAD,CAAJ,GAAUqF,KAAV;AACAd,UAAAA,GAAG,CAAChF,IAAJ,CAASS,CAAT;AACD;;AAEDnB,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACD;AACF,KAZD,MAYO,IAAIwF,GAAG,GAAGE,GAAV,EAAe;AACpB,WAAK1G,CAAC,GAAG0G,GAAJ,EAASzG,CAAC,GAAGmB,IAAI,CAACwF,GAAL,CAASJ,GAAT,EAAcG,GAAd,CAAlB,EAAsC3G,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;;AAEA,YAAIP,IAAI,CAACoB,CAAD,CAAJ,KAAYqF,KAAhB,EAAuB;AACrBtG,UAAAA,IAAI,CAACiB,CAAD,CAAJ,GAAUnB,IAAI,CAACmB,CAAD,CAAd;AACApB,UAAAA,IAAI,CAACoB,CAAD,CAAJ,GAAUqF,KAAV;AACAd,UAAAA,GAAG,CAAChF,IAAJ,CAASS,CAAT;AACD;;AAEDnB,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACD;AACF,KAvCkC,CAuCjC;;;AAGF,QAAIyF,GAAG,GAAGE,GAAV,EAAe;AACb,WAAK3G,CAAC,GAAGoB,IAAI,CAACC,GAAL,CAASmF,GAAT,EAAcG,GAAd,CAAJ,EAAwB1G,CAAC,GAAGwG,GAAjC,EAAsCzG,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;;AAEA,YAAIP,IAAI,CAACoB,CAAD,CAAJ,KAAYqF,KAAhB,EAAuB;AACrBtG,UAAAA,IAAI,CAACiB,CAAD,CAAJ,GAAUnB,IAAI,CAACmB,CAAD,CAAd;AACApB,UAAAA,IAAI,CAACoB,CAAD,CAAJ,GAAUqF,KAAV;AACAd,UAAAA,GAAG,CAAChF,IAAJ,CAASS,CAAT;AACD;;AAEDnB,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACD;AACF,KAZD,MAYO,IAAIyF,GAAG,GAAGE,GAAV,EAAe;AACpB,WAAK3G,CAAC,GAAGoB,IAAI,CAACC,GAAL,CAASqF,GAAT,EAAcD,GAAd,CAAJ,EAAwBxG,CAAC,GAAG0G,GAAjC,EAAsC3G,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;;AAEA,YAAIP,IAAI,CAACoB,CAAD,CAAJ,KAAYqF,KAAhB,EAAuB;AACrBtG,UAAAA,IAAI,CAACiB,CAAD,CAAJ,GAAUnB,IAAI,CAACmB,CAAD,CAAd;AACApB,UAAAA,IAAI,CAACoB,CAAD,CAAJ,GAAUqF,KAAV;AACAd,UAAAA,GAAG,CAAChF,IAAJ,CAASS,CAAT;AACD;;AAEDnB,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACD;AACF;;AAEDiB,IAAAA,GAAG,CAACL,KAAJ,GAAYH,KAAK,CAACI,KAAN,EAAZ;AACD,GAlU8B;AAoU/BwE,EAAAA,YApU+B,wBAoUlBpE,GApUkB,EAoUbR,KApUa,EAoUN1B,GApUM,EAoUDsF,GApUC,EAoUI;AACjC,QAAMF,IAAI,GAAG,KAAKjD,KAAlB;AAAA,QACMxC,IAAI,GAAGyF,IAAI,CAACzF,IAAL,EADb;AAAA,QAEM8B,KAAK,GAAGS,GAAG,CAACT,KAAJ,EAFd;AAAA,QAGM+E,GAAG,GAAGtE,GAAG,CAACH,MAAJ,CAAWG,GAAG,CAACL,KAAf,CAHZ;AAAA,QAIMA,KAAK,GAAGK,GAAG,CAACH,MAAJ,CAAWL,KAAX,CAJd;AAAA,QAKM+E,GAAG,GAAG5E,KAAK,CAAC,CAAD,CALjB;AAAA,QAMM6E,GAAG,GAAG7E,KAAK,CAAC,CAAD,CANjB;AAAA,QAOM8E,GAAG,GAAGH,GAAG,CAAC,CAAD,CAPf;AAAA,QAQMI,GAAG,GAAGJ,GAAG,CAAC,CAAD,CARf;AAAA,QASMvF,GAAG,GAAGiB,GAAG,CAACjB,GAThB;AAUA,QAAIhB,CAAJ,EAAOC,CAAP,EAAUY,CAAV,CAXiC,CAWpB;;AAEb,QAAI2F,GAAG,GAAGE,GAAV,EAAe;AACb,WAAK1G,CAAC,GAAGwG,GAAJ,EAASvG,CAAC,GAAGmB,IAAI,CAACwF,GAAL,CAASF,GAAT,EAAcD,GAAd,CAAlB,EAAsCzG,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;AACAN,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACAjB,QAAAA,GAAG,CAACK,IAAJ,CAASS,CAAT;AACD;AACF,KAND,MAMO,IAAI2F,GAAG,GAAGE,GAAV,EAAe;AACpB,WAAK1G,CAAC,GAAG0G,GAAJ,EAASzG,CAAC,GAAGmB,IAAI,CAACwF,GAAL,CAASJ,GAAT,EAAcG,GAAd,CAAlB,EAAsC3G,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;AACAN,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACAqE,QAAAA,GAAG,CAACjF,IAAJ,CAASS,CAAT;AACD;AACF,KAzBgC,CAyB/B;;;AAGF,QAAI4F,GAAG,GAAGE,GAAV,EAAe;AACb,WAAK3G,CAAC,GAAGoB,IAAI,CAACC,GAAL,CAASmF,GAAT,EAAcG,GAAd,CAAJ,EAAwB1G,CAAC,GAAGwG,GAAjC,EAAsCzG,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;AACAN,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACAjB,QAAAA,GAAG,CAACK,IAAJ,CAASS,CAAT;AACD;AACF,KAND,MAMO,IAAI4F,GAAG,GAAGE,GAAV,EAAe;AACpB,WAAK3G,CAAC,GAAGoB,IAAI,CAACC,GAAL,CAASqF,GAAT,EAAcD,GAAd,CAAJ,EAAwBxG,CAAC,GAAG0G,GAAjC,EAAsC3G,CAAC,GAAGC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChDa,QAAAA,CAAC,GAAGW,KAAK,CAACxB,CAAD,CAAT;AACAN,QAAAA,IAAI,CAACmB,CAAD,CAAJ,IAAWG,GAAX;AACAqE,QAAAA,GAAG,CAACjF,IAAJ,CAASS,CAAT;AACD;AACF;;AAEDoB,IAAAA,GAAG,CAACL,KAAJ,GAAYH,KAAK,CAACI,KAAN,EAAZ;AACD;AA/W8B,CAAzB,CAAR;AAmXA;;;;;;;;;;AAUA,SAASgF,aAAT,CAAuB9C,MAAvB,EAA+B;AAC7BlF,EAAAA,SAAS,CAACsE,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BY,MAA3B;AACD;;AACD8C,aAAa,CAAC3C,UAAd,GAA2B;AACzB,UAAQ,eADiB;AAEzB,cAAY,EAFa;AAGzB,YAAU,CAAC;AACT,YAAQ,QADC;AAET,YAAQ,QAFC;AAGT,gBAAY,IAHH;AAIT,mBAAe;AAJN,GAAD,EAKP;AACD,YAAQ,QADP;AAED,YAAQ,QAFP;AAGD,gBAAY,IAHX;AAID,mBAAe;AAJd,GALO;AAHe,CAA3B;AAeApF,QAAQ,CAAC+H,aAAD,EAAgBhI,SAAhB,EAA2B;AACjCsF,EAAAA,SADiC,qBACvBC,CADuB,EACpBC,KADoB,EACb;AAClB,QAAMyC,MAAM,GAAG,EAAE1C,CAAC,CAAC0C,MAAF,IAAY,CAAd,CAAf;AAAA,QACM;AACNC,IAAAA,MAAM,GAAG3C,CAAC,CAAC4C,MAFX;AAAA,QAGMpB,IAAI,GAAGmB,MAAM,CAACnB,IAHpB,CADkB,CAIQ;;AAE1B,QAAI,CAACA,IAAI,GAAGkB,MAAR,MAAoB,CAAxB,EAA2B,OAAOzC,KAAK,CAAC4C,eAAb;;AAE3B,QAAMjC,MAAM,GAAGX,KAAK,CAACa,IAAN,CAAWb,KAAK,CAAC6C,GAAjB,CAAf;AAAA,QACM1H,IAAI,GAAGuH,MAAM,CAACvH,IAAP,EADb;AAAA,QAEME,IAAI,GAAGqH,MAAM,CAACrH,IAAP,EAFb;AAAA,QAGME,IAAI,GAAGmH,MAAM,CAACnH,IAAP,EAHb;AAAA,QAIMuH,IAAI,GAAG,SAAPA,IAAO,CAAAtG,CAAC;AAAA,aAAI,EAAEnB,IAAI,CAACmB,CAAD,CAAJ,GAAUiG,MAAZ,IAAsBtH,IAAI,CAACqB,CAAD,CAA1B,GAAgC,IAApC;AAAA,KAJd,CARkB,CAYsC;;;AAGxDmE,IAAAA,MAAM,CAACgC,MAAP,CAAchC,MAAM,CAACoC,GAArB,EAA0BD,IAA1B,EAfkB,CAee;AACjC;AACA;;AAEA,QAAI,EAAEvB,IAAI,GAAGA,IAAI,GAAG,CAAhB,CAAJ,EAAwB;AACtB;AACAZ,MAAAA,MAAM,CAACgC,MAAP,CAAchC,MAAM,CAACqC,GAArB,EAA0BF,IAA1B;AACAnC,MAAAA,MAAM,CAACgC,MAAP,CAAchC,MAAM,CAACsC,GAArB,EAA0B,UAAAzG,CAAC;AAAA,eAAI,CAACnB,IAAI,CAACmB,CAAD,CAAJ,GAAUiG,MAAX,MAAuBlB,IAAvB,GAA8BpG,IAAI,CAACqB,CAAD,CAAlC,GAAwC,IAA5C;AAAA,OAA3B;AACD,KAJD,MAIO;AACL;AACAmE,MAAAA,MAAM,CAACgC,MAAP,CAAchC,MAAM,CAACqC,GAArB,EAA0B,UAAAxG,CAAC,EAAI;AAC7B,YAAM0G,CAAC,GAAG7H,IAAI,CAACmB,CAAD,CAAJ,GAAUiG,MAApB;AAAA,YACMpC,CAAC,GAAG,CAAC6C,CAAD,IAAMA,CAAC,GAAG3H,IAAI,CAACiB,CAAD,CAAJ,GAAUiG,MAD9B;AAEA,eAAOpC,CAAC,GAAGlF,IAAI,CAACqB,CAAD,CAAP,GAAa,IAArB;AACD,OAJD;AAKAmE,MAAAA,MAAM,CAACgC,MAAP,CAAchC,MAAM,CAACsC,GAArB,EAA0B,UAAAzG,CAAC,EAAI;AAC7B,YAAM0G,CAAC,GAAG7H,IAAI,CAACmB,CAAD,CAAJ,GAAUiG,MAApB;AAAA,YACMpC,CAAC,GAAG6C,CAAC,IAAI,EAAEA,CAAC,IAAIA,CAAC,GAAG3H,IAAI,CAACiB,CAAD,CAAJ,GAAUiG,MAAlB,CAAH,CADf;AAEA,eAAOpC,CAAC,GAAGlF,IAAI,CAACqB,CAAD,CAAP,GAAa,IAArB;AACD,OAJD;AAKD,KAnCiB,CAmChB;;;AAGF,WAAOmE,MAAM,CAACgC,MAAP,CAAchC,MAAM,CAACwC,MAArB,EAA6B,UAAAtH,CAAC;AAAA,aAAIiH,IAAI,CAACjH,CAAC,CAACC,MAAH,CAAR;AAAA,KAA9B,CAAP;AACD;AAxCgC,CAA3B,CAAR;AA4CA,SAAS2D,WAAW,IAAI2D,WAAxB,EAAqCZ,aAAa,IAAIa,aAAtD","sourcesContent":["import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nconst array8 = n => new Uint8Array(n);\nconst array16 = n => new Uint16Array(n);\nconst array32 = n => new Uint32Array(n);\n\n/**\n * Maintains CrossFilter state.\n */\n\nfunction Bitmaps() {\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n\n      let t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n\n      for (j = i; i < n; ++i) {\n        t = data[i];\n\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) {\n      curr[k] |= one;\n    },\n\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n\n    resize(n, m) {\n      const k = curr.length;\n\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension (index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n\n      return dim;\n    }\n\n  };\n}\n\n/**\n * Maintains a list of values, sorted by key.\n */\n\nfunction SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n          n1 = data.length,\n          addi = array32(n1);\n    let addv = Array(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0,\n        key,\n        index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = output.rem = output.add,\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n\n    if (pulse.mod.length) {\n      modMap = {};\n\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(),\n        j,\n        key,\n        add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0,\n        i,\n        q; // survey how many queries have changed\n\n    output.filters = 0;\n\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n\n});\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n          // bit mask where zeros -> dims to ignore\n    bitmap = _.filter,\n          mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter\n\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n\n});\n\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };\n"]},"metadata":{},"sourceType":"module"}