{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar helpers_1 = require(\"@turf/helpers\");\n\nvar invariant_1 = require(\"@turf/invariant\"); // http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\n\n\nfunction bearing(start, end, options) {\n  if (options === void 0) {\n    options = {};\n  } // Reverse calculation\n\n\n  if (options.final === true) {\n    return calculateFinalBearing(start, end);\n  }\n\n  var coordinates1 = invariant_1.getCoord(start);\n  var coordinates2 = invariant_1.getCoord(end);\n  var lon1 = helpers_1.degreesToRadians(coordinates1[0]);\n  var lon2 = helpers_1.degreesToRadians(coordinates2[0]);\n  var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n  var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return helpers_1.radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\n\n\nfunction calculateFinalBearing(start, end) {\n  // Swap start & end\n  var bear = bearing(end, start);\n  bear = (bear + 180) % 360;\n  return bear;\n}\n\nexports.default = bearing;","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/@turf/bearing/index.js"],"names":["Object","defineProperty","exports","value","helpers_1","require","invariant_1","bearing","start","end","options","final","calculateFinalBearing","coordinates1","getCoord","coordinates2","lon1","degreesToRadians","lon2","lat1","lat2","a","Math","sin","cos","b","radiansToDegrees","atan2","bear","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,SAAS,GAAGC,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,iBAAD,CAAzB,C,CACA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAsBA,SAASE,OAAT,CAAiBC,KAAjB,EAAwBC,GAAxB,EAA6BC,OAA7B,EAAsC;AAClC,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe,GADP,CAElC;;;AACA,MAAIA,OAAO,CAACC,KAAR,KAAkB,IAAtB,EAA4B;AACxB,WAAOC,qBAAqB,CAACJ,KAAD,EAAQC,GAAR,CAA5B;AACH;;AACD,MAAII,YAAY,GAAGP,WAAW,CAACQ,QAAZ,CAAqBN,KAArB,CAAnB;AACA,MAAIO,YAAY,GAAGT,WAAW,CAACQ,QAAZ,CAAqBL,GAArB,CAAnB;AACA,MAAIO,IAAI,GAAGZ,SAAS,CAACa,gBAAV,CAA2BJ,YAAY,CAAC,CAAD,CAAvC,CAAX;AACA,MAAIK,IAAI,GAAGd,SAAS,CAACa,gBAAV,CAA2BF,YAAY,CAAC,CAAD,CAAvC,CAAX;AACA,MAAII,IAAI,GAAGf,SAAS,CAACa,gBAAV,CAA2BJ,YAAY,CAAC,CAAD,CAAvC,CAAX;AACA,MAAIO,IAAI,GAAGhB,SAAS,CAACa,gBAAV,CAA2BF,YAAY,CAAC,CAAD,CAAvC,CAAX;AACA,MAAIM,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASL,IAAI,GAAGF,IAAhB,IAAwBM,IAAI,CAACE,GAAL,CAASJ,IAAT,CAAhC;AACA,MAAIK,CAAC,GAAGH,IAAI,CAACE,GAAL,CAASL,IAAT,IAAiBG,IAAI,CAACC,GAAL,CAASH,IAAT,CAAjB,GACJE,IAAI,CAACC,GAAL,CAASJ,IAAT,IAAiBG,IAAI,CAACE,GAAL,CAASJ,IAAT,CAAjB,GAAkCE,IAAI,CAACE,GAAL,CAASN,IAAI,GAAGF,IAAhB,CADtC;AAEA,SAAOZ,SAAS,CAACsB,gBAAV,CAA2BJ,IAAI,CAACK,KAAL,CAAWN,CAAX,EAAcI,CAAd,CAA3B,CAAP;AACH;AACD;;;;;;;;;;AAQA,SAASb,qBAAT,CAA+BJ,KAA/B,EAAsCC,GAAtC,EAA2C;AACvC;AACA,MAAImB,IAAI,GAAGrB,OAAO,CAACE,GAAD,EAAMD,KAAN,CAAlB;AACAoB,EAAAA,IAAI,GAAG,CAACA,IAAI,GAAG,GAAR,IAAe,GAAtB;AACA,SAAOA,IAAP;AACH;;AACD1B,OAAO,CAAC2B,OAAR,GAAkBtB,OAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = invariant_1.getCoord(start);\n    var coordinates2 = invariant_1.getCoord(end);\n    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return helpers_1.radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\nexports.default = bearing;\n"]},"metadata":{},"sourceType":"script"}