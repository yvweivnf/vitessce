{"ast":null,"code":"import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import _defineProperty from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";import _objectSpread from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";import _toConsumableArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";/* eslint-disable no-plusplus */ /* eslint-disable camelcase */import difference from'lodash/difference';import cloneDeep from'lodash/cloneDeep';import packageJson from'../../package.json';import{getNextScope}from'../utils';import{AUTO_INDEPENDENT_COORDINATION_TYPES}from'./state/coordination';import{getViewTypes}from'./component-registry';import{getComponentCoordinationTypes,getDefaultCoordinationValues,getCoordinationTypes,getFileTypes,getConvenienceFileTypes}from'./plugins';import{SCHEMA_HANDLERS}from'./view-config-versions';/**\n * Get a list of all unique scope names for a\n * particular coordination type, which exist in\n * a particular view config.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @returns {string[]} Array of existing coordination scope names.\n */export function getExistingScopesForCoordinationType(config,coordinationType){var _config$coordinationS;var spaceScopes=Object.keys((config===null||config===void 0?void 0:(_config$coordinationS=config.coordinationSpace)===null||_config$coordinationS===void 0?void 0:_config$coordinationS[coordinationType])||{});var componentScopes=config.layout.map(function(c){var _c$coordinationScopes;return(_c$coordinationScopes=c.coordinationScopes)===null||_c$coordinationScopes===void 0?void 0:_c$coordinationScopes[coordinationType];});return Array.from(new Set([].concat(_toConsumableArray(spaceScopes),_toConsumableArray(componentScopes))));}/**\n * Give each component the same scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */function coordinateComponentsTogether(config,coordinationType,scopeValue){var _config$coordinationS2;var componentCoordinationTypes=getComponentCoordinationTypes();var scopeName=getNextScope(getExistingScopesForCoordinationType(config,coordinationType));var newConfig=_objectSpread({},config,{coordinationSpace:_objectSpread({},config.coordinationSpace,_defineProperty({},coordinationType,_objectSpread({},config===null||config===void 0?void 0:(_config$coordinationS2=config.coordinationSpace)===null||_config$coordinationS2===void 0?void 0:_config$coordinationS2[coordinationType],_defineProperty({},scopeName,scopeValue)))),layout:config.layout.map(function(component){var _component$coordinati;return _objectSpread({},component,{coordinationScopes:_objectSpread({},component.coordinationScopes,{},componentCoordinationTypes[component.component].includes(coordinationType)&&!((_component$coordinati=component.coordinationScopes)===null||_component$coordinati===void 0?void 0:_component$coordinati[coordinationType])?_defineProperty({},coordinationType,scopeName):{})});})});return newConfig;}/**\n * Give each component a different scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */function coordinateComponentsIndependent(config,coordinationType,scopeValue){var componentCoordinationTypes=getComponentCoordinationTypes();var newConfig=_objectSpread({},config,{layout:_toConsumableArray(config.layout)});var newScopes={};newConfig.layout.forEach(function(component,i){var _component$coordinati2;// Only set the coordination scope if this component uses this coordination type,\n// and the component is missing a coordination scope for this coordination type.\nif(componentCoordinationTypes[component.component].includes(coordinationType)&&!((_component$coordinati2=component.coordinationScopes)===null||_component$coordinati2===void 0?void 0:_component$coordinati2[coordinationType])){var scopeName=getNextScope([].concat(_toConsumableArray(getExistingScopesForCoordinationType(config,coordinationType)),_toConsumableArray(Object.keys(newScopes))));newScopes[scopeName]=scopeValue;newConfig.layout[i]=_objectSpread({},component,{coordinationScopes:_objectSpread({},component.coordinationScopes,_defineProperty({},coordinationType,scopeName))});}});newConfig.coordinationSpace=_objectSpread({},newConfig.coordinationSpace,_defineProperty({},coordinationType,_objectSpread({},newConfig.coordinationSpace[coordinationType],{},newScopes)));return newConfig;}function initializeAuto(config){var newConfig=config;var _newConfig=newConfig,layout=_newConfig.layout,datasets=_newConfig.datasets;var componentCoordinationTypes=getComponentCoordinationTypes();var defaultCoordinationValues=getDefaultCoordinationValues();var coordinationTypes=getCoordinationTypes();// For each coordination type, check whether it requires initialization.\ncoordinationTypes.forEach(function(coordinationType){// A coordination type requires coordination if at least one component is missing\n// a (coordination type, coordination scope) tuple.\n// Components may only use a subset of all coordination types.\nvar requiresCoordination=!layout.every(function(c){var _c$coordinationScopes2;return!componentCoordinationTypes[c.component].includes(coordinationType)||((_c$coordinationScopes2=c.coordinationScopes)===null||_c$coordinationScopes2===void 0?void 0:_c$coordinationScopes2[coordinationType]);});if(requiresCoordination){// Note that the default value may be undefined.\nvar defaultValue=defaultCoordinationValues[coordinationType];// Check whether this is the special 'dataset' coordination type.\nif(coordinationType==='dataset'&&datasets.length>=1){// Use the first dataset ID as the default\n// if there is at least one dataset.\ndefaultValue=datasets[0].uid;}// Use the list of \"independent\" coordination types\n// to determine whether a particular coordination type\n// should be initialized to\n// a unique scope for every component (\"independent\")\n// vs. the same scope for every component (\"together\").\nif(AUTO_INDEPENDENT_COORDINATION_TYPES.includes(coordinationType)){newConfig=coordinateComponentsIndependent(newConfig,coordinationType,defaultValue);}else{newConfig=coordinateComponentsTogether(newConfig,coordinationType,defaultValue);}}});return newConfig;}export function checkTypes(config){// Add a log message when there are additionalProperties in the coordination space that\n// do not appear in the view config JSON schema,\n// with a note that this indicates either a mistake or custom coordination type usage.\nvar coordinationTypesInConfig=Object.keys(config.coordinationSpace||{});var allCoordinationTypes=getCoordinationTypes();var unknownCoordinationTypes=difference(coordinationTypesInConfig,allCoordinationTypes);if(unknownCoordinationTypes.length>0){return[false,\"The following coordination types are not recognized: [\".concat(unknownCoordinationTypes,\"].\\nIf these are plugin coordination types, ensure that they have been properly registered.\")];}// Add a log message when there are views in the layout that are neither\n// core views nor registered plugin views.\nvar viewTypesInConfig=config.layout.map(function(c){return c.component;});var allViewTypes=getViewTypes();var unknownViewTypes=difference(viewTypesInConfig,allViewTypes);if(unknownViewTypes.length>0){return[false,\"The following view types are not recognized: [\".concat(unknownViewTypes,\"].\\nIf these are plugin view types, ensure that they have been properly registered.\")];}// Add a log message when there are file definitions with neither\n// core nor registered plugin file types.\nvar fileTypesInConfig=config.datasets.flatMap(function(d){return d.files.map(function(f){return f.fileType;});});var allFileTypes=getFileTypes();var unknownFileTypes=difference(fileTypesInConfig,allFileTypes);if(unknownFileTypes.length>0){return[false,\"The following file types are not recognized: [\".concat(unknownFileTypes,\"].\\nIf these are plugin file types, ensure that they have been properly registered.\")];}return[true,'All view types, coordination types, and file types that appear in the view config are recognized.'];}/**\n * Assign unique ids for view definitions where\n * they are missing a value for the uid property\n * in layout[].uid.\n * @param {object} config The view config\n * @returns The updated view config.\n */function assignViewUids(config){var layout=config.layout;var usedIds=layout.map(function(view){return view.uid;});layout.forEach(function(view,i){// Assign uids for views where they are not present.\nif(!view.uid){var nextUid=getNextScope(usedIds);layout[i].uid=nextUid;usedIds.push(nextUid);}});return _objectSpread({},config,{layout:layout});}/**\n * Expand convenience file definitions. Each convenience file\n * definition expansion function takes in one file definition and\n * returns an array of file definitions. Not performed recursively.\n * @param {object} config The view config containing collapsed\n * convenience file types.\n * @returns The view config containing expanded minimal file types.\n */function expandConvenienceFileDefs(config){var convenienceFileTypes=getConvenienceFileTypes();var currDatasets=config.datasets;var datasets=cloneDeep(currDatasets);currDatasets.forEach(function(dataset,i){var _dataset$files=dataset.files,files=_dataset$files===void 0?[]:_dataset$files;var newFiles=[];files.forEach(function(fileDef){var fileType=fileDef.fileType;var expansionFunc=convenienceFileTypes[fileType];if(expansionFunc&&typeof expansionFunc==='function'){// This was a convenience file type, so expand it.\nvar expandedFileDefs=expansionFunc(fileDef);newFiles=newFiles.concat(expandedFileDefs);}else{// This was not a convenience file type,\n// so keep it in the files array as-is.\nnewFiles.push(fileDef);}});datasets[i].files=newFiles;});return _objectSpread({},config,{datasets:datasets});}/**\n * Initialize the view config:\n * - Fill in missing coordination objects with default values.\n * - Fill in missing component coordination scope mappings.\n *   based on the `initStrategy` specified in the view config.\n * - Fill in missing view uid values.\n * - Expand convenience file types.\n * Should be \"stable\": if run on the same view config twice, the return value the second\n * time should be identical to the return value the first time.\n * @param {object} config The view config prop.\n * @returns The initialized view config.\n */export function initialize(config){var newConfig=cloneDeep(config);if(newConfig.initStrategy==='auto'){newConfig=initializeAuto(config);}newConfig=expandConvenienceFileDefs(newConfig);return assignViewUids(newConfig);}export function upgradeAndValidate(oldConfig){// oldConfig object must have a `version` property.\nvar nextConfig=oldConfig;var fromVersion;var upgradeFunction;var validateFunction;do{fromVersion=nextConfig.version;if(!Object.keys(SCHEMA_HANDLERS).includes(fromVersion)){return[{title:'Config validation failed',preformatted:'Unknown config version.'},false];}var _SCHEMA_HANDLERS$from=_slicedToArray(SCHEMA_HANDLERS[fromVersion],2);validateFunction=_SCHEMA_HANDLERS$from[0];upgradeFunction=_SCHEMA_HANDLERS$from[1];// Validate under the legacy schema before upgrading.\nvar validLegacy=validateFunction(nextConfig);if(!validLegacy){var failureReason=JSON.stringify(validateFunction.errors,null,2);return[{title:'Config validation failed',preformatted:failureReason},false];}if(upgradeFunction){nextConfig=upgradeFunction(nextConfig);}}while(upgradeFunction);// NOTE: Remove when a view config viewer/editor is available in UI.\nconsole.groupCollapsed(\"\\uD83D\\uDE84 Vitessce (\".concat(packageJson.version,\") view configuration\"));console.info(\"data:,\".concat(JSON.stringify(nextConfig)));console.info(JSON.stringify(nextConfig,null,2));console.groupEnd();return[nextConfig,true];}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/app/view-config-utils.js"],"names":["difference","cloneDeep","packageJson","getNextScope","AUTO_INDEPENDENT_COORDINATION_TYPES","getViewTypes","getComponentCoordinationTypes","getDefaultCoordinationValues","getCoordinationTypes","getFileTypes","getConvenienceFileTypes","SCHEMA_HANDLERS","getExistingScopesForCoordinationType","config","coordinationType","spaceScopes","Object","keys","coordinationSpace","componentScopes","layout","map","c","coordinationScopes","Array","from","Set","coordinateComponentsTogether","scopeValue","componentCoordinationTypes","scopeName","newConfig","component","includes","coordinateComponentsIndependent","newScopes","forEach","i","initializeAuto","datasets","defaultCoordinationValues","coordinationTypes","requiresCoordination","every","defaultValue","length","uid","checkTypes","coordinationTypesInConfig","allCoordinationTypes","unknownCoordinationTypes","viewTypesInConfig","allViewTypes","unknownViewTypes","fileTypesInConfig","flatMap","d","files","f","fileType","allFileTypes","unknownFileTypes","assignViewUids","usedIds","view","nextUid","push","expandConvenienceFileDefs","convenienceFileTypes","currDatasets","dataset","newFiles","fileDef","expansionFunc","expandedFileDefs","concat","initialize","initStrategy","upgradeAndValidate","oldConfig","nextConfig","fromVersion","upgradeFunction","validateFunction","version","title","preformatted","validLegacy","failureReason","JSON","stringify","errors","console","groupCollapsed","info","groupEnd"],"mappings":"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","sourcesContent":["/* eslint-disable no-plusplus */\n/* eslint-disable camelcase */\nimport difference from 'lodash/difference';\nimport cloneDeep from 'lodash/cloneDeep';\nimport packageJson from '../../package.json';\nimport { getNextScope } from '../utils';\nimport {\n  AUTO_INDEPENDENT_COORDINATION_TYPES,\n} from './state/coordination';\nimport { getViewTypes } from './component-registry';\nimport {\n  getComponentCoordinationTypes,\n  getDefaultCoordinationValues,\n  getCoordinationTypes,\n  getFileTypes,\n  getConvenienceFileTypes,\n} from './plugins';\nimport { SCHEMA_HANDLERS } from './view-config-versions';\n\n/**\n * Get a list of all unique scope names for a\n * particular coordination type, which exist in\n * a particular view config.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @returns {string[]} Array of existing coordination scope names.\n */\nexport function getExistingScopesForCoordinationType(config, coordinationType) {\n  const spaceScopes = Object.keys(config?.coordinationSpace?.[coordinationType] || {});\n  const componentScopes = config.layout.map(c => c.coordinationScopes?.[coordinationType]);\n  return Array.from(new Set([...spaceScopes, ...componentScopes]));\n}\n\n/**\n * Give each component the same scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */\nfunction coordinateComponentsTogether(config, coordinationType, scopeValue) {\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const scopeName = getNextScope(getExistingScopesForCoordinationType(config, coordinationType));\n  const newConfig = {\n    ...config,\n    coordinationSpace: {\n      ...config.coordinationSpace,\n      [coordinationType]: {\n        ...config?.coordinationSpace?.[coordinationType],\n        // Add the new scope name and value to the coordination space.\n        [scopeName]: scopeValue,\n      },\n    },\n    layout: config.layout.map(component => ({\n      ...component,\n      coordinationScopes: {\n        ...component.coordinationScopes,\n        // Only set the coordination scope if this component uses this coordination type,\n        // and the component is missing a coordination scope for this coordination type.\n        ...((\n          componentCoordinationTypes[component.component].includes(coordinationType)\n          && !component.coordinationScopes?.[coordinationType]\n        ) ? {\n          // Only set the new scope name if the scope name\n          // for this component and coordination type is currently undefined.\n            [coordinationType]: scopeName,\n          } : {}),\n      },\n    })),\n  };\n  return newConfig;\n}\n\n/**\n * Give each component a different scope name for this coordination type.\n * @param {object} config A view config object.\n * @param {string} coordinationType A coordination type,\n * for example 'spatialZoom' or 'dataset'.\n * @param {*} scopeValue The initial value for the coordination scope,\n * to set in the coordination space.\n * @returns {object} The new view config.\n */\nfunction coordinateComponentsIndependent(config, coordinationType, scopeValue) {\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const newConfig = {\n    ...config,\n    layout: [...config.layout],\n  };\n  const newScopes = {};\n  newConfig.layout.forEach((component, i) => {\n    // Only set the coordination scope if this component uses this coordination type,\n    // and the component is missing a coordination scope for this coordination type.\n    if (componentCoordinationTypes[component.component].includes(coordinationType)\n      && !component.coordinationScopes?.[coordinationType]\n    ) {\n      const scopeName = getNextScope([\n        ...getExistingScopesForCoordinationType(config, coordinationType),\n        ...Object.keys(newScopes),\n      ]);\n      newScopes[scopeName] = scopeValue;\n      newConfig.layout[i] = {\n        ...component,\n        coordinationScopes: {\n          ...component.coordinationScopes,\n          [coordinationType]: scopeName,\n        },\n      };\n    }\n  });\n  newConfig.coordinationSpace = {\n    ...newConfig.coordinationSpace,\n    [coordinationType]: {\n      ...newConfig.coordinationSpace[coordinationType],\n      // Add the new scope name and value to the coordination space.\n      ...newScopes,\n    },\n  };\n  return newConfig;\n}\n\nfunction initializeAuto(config) {\n  let newConfig = config;\n  const { layout, datasets } = newConfig;\n\n  const componentCoordinationTypes = getComponentCoordinationTypes();\n  const defaultCoordinationValues = getDefaultCoordinationValues();\n  const coordinationTypes = getCoordinationTypes();\n\n  // For each coordination type, check whether it requires initialization.\n  coordinationTypes.forEach((coordinationType) => {\n    // A coordination type requires coordination if at least one component is missing\n    // a (coordination type, coordination scope) tuple.\n    // Components may only use a subset of all coordination types.\n    const requiresCoordination = !layout\n      .every(c => (\n        (!componentCoordinationTypes[c.component].includes(coordinationType))\n                || c.coordinationScopes?.[coordinationType]\n      ));\n    if (requiresCoordination) {\n      // Note that the default value may be undefined.\n      let defaultValue = defaultCoordinationValues[coordinationType];\n      // Check whether this is the special 'dataset' coordination type.\n      if (coordinationType === 'dataset' && datasets.length >= 1) {\n        // Use the first dataset ID as the default\n        // if there is at least one dataset.\n        defaultValue = datasets[0].uid;\n      }\n      // Use the list of \"independent\" coordination types\n      // to determine whether a particular coordination type\n      // should be initialized to\n      // a unique scope for every component (\"independent\")\n      // vs. the same scope for every component (\"together\").\n      if (AUTO_INDEPENDENT_COORDINATION_TYPES.includes(coordinationType)) {\n        newConfig = coordinateComponentsIndependent(newConfig, coordinationType, defaultValue);\n      } else {\n        newConfig = coordinateComponentsTogether(newConfig, coordinationType, defaultValue);\n      }\n    }\n  });\n\n  return newConfig;\n}\n\nexport function checkTypes(config) {\n  // Add a log message when there are additionalProperties in the coordination space that\n  // do not appear in the view config JSON schema,\n  // with a note that this indicates either a mistake or custom coordination type usage.\n  const coordinationTypesInConfig = Object.keys(config.coordinationSpace || {});\n  const allCoordinationTypes = getCoordinationTypes();\n  const unknownCoordinationTypes = difference(coordinationTypesInConfig, allCoordinationTypes);\n  if (unknownCoordinationTypes.length > 0) {\n    return [false, `The following coordination types are not recognized: [${unknownCoordinationTypes}].\\nIf these are plugin coordination types, ensure that they have been properly registered.`];\n  }\n  // Add a log message when there are views in the layout that are neither\n  // core views nor registered plugin views.\n  const viewTypesInConfig = config.layout.map(c => c.component);\n  const allViewTypes = getViewTypes();\n  const unknownViewTypes = difference(viewTypesInConfig, allViewTypes);\n  if (unknownViewTypes.length > 0) {\n    return [false, `The following view types are not recognized: [${unknownViewTypes}].\\nIf these are plugin view types, ensure that they have been properly registered.`];\n  }\n  // Add a log message when there are file definitions with neither\n  // core nor registered plugin file types.\n  const fileTypesInConfig = config.datasets.flatMap(d => d.files.map(f => f.fileType));\n  const allFileTypes = getFileTypes();\n  const unknownFileTypes = difference(fileTypesInConfig, allFileTypes);\n  if (unknownFileTypes.length > 0) {\n    return [false, `The following file types are not recognized: [${unknownFileTypes}].\\nIf these are plugin file types, ensure that they have been properly registered.`];\n  }\n  return [true, 'All view types, coordination types, and file types that appear in the view config are recognized.'];\n}\n\n/**\n * Assign unique ids for view definitions where\n * they are missing a value for the uid property\n * in layout[].uid.\n * @param {object} config The view config\n * @returns The updated view config.\n */\nfunction assignViewUids(config) {\n  const { layout } = config;\n  const usedIds = layout.map(view => view.uid);\n  layout.forEach((view, i) => {\n    // Assign uids for views where they are not present.\n    if (!view.uid) {\n      const nextUid = getNextScope(usedIds);\n      layout[i].uid = nextUid;\n      usedIds.push(nextUid);\n    }\n  });\n  return {\n    ...config,\n    layout,\n  };\n}\n\n/**\n * Expand convenience file definitions. Each convenience file\n * definition expansion function takes in one file definition and\n * returns an array of file definitions. Not performed recursively.\n * @param {object} config The view config containing collapsed\n * convenience file types.\n * @returns The view config containing expanded minimal file types.\n */\nfunction expandConvenienceFileDefs(config) {\n  const convenienceFileTypes = getConvenienceFileTypes();\n  const { datasets: currDatasets } = config;\n  const datasets = cloneDeep(currDatasets);\n  currDatasets.forEach((dataset, i) => {\n    const { files = [] } = dataset;\n    let newFiles = [];\n    files.forEach((fileDef) => {\n      const { fileType } = fileDef;\n      const expansionFunc = convenienceFileTypes[fileType];\n      if (expansionFunc && typeof expansionFunc === 'function') {\n        // This was a convenience file type, so expand it.\n        const expandedFileDefs = expansionFunc(fileDef);\n        newFiles = newFiles.concat(expandedFileDefs);\n      } else {\n        // This was not a convenience file type,\n        // so keep it in the files array as-is.\n        newFiles.push(fileDef);\n      }\n    });\n    datasets[i].files = newFiles;\n  });\n  return {\n    ...config,\n    datasets,\n  };\n}\n\n/**\n * Initialize the view config:\n * - Fill in missing coordination objects with default values.\n * - Fill in missing component coordination scope mappings.\n *   based on the `initStrategy` specified in the view config.\n * - Fill in missing view uid values.\n * - Expand convenience file types.\n * Should be \"stable\": if run on the same view config twice, the return value the second\n * time should be identical to the return value the first time.\n * @param {object} config The view config prop.\n * @returns The initialized view config.\n */\nexport function initialize(config) {\n  let newConfig = cloneDeep(config);\n  if (newConfig.initStrategy === 'auto') {\n    newConfig = initializeAuto(config);\n  }\n  newConfig = expandConvenienceFileDefs(newConfig);\n  return assignViewUids(newConfig);\n}\n\nexport function upgradeAndValidate(oldConfig) {\n  // oldConfig object must have a `version` property.\n  let nextConfig = oldConfig;\n  let fromVersion;\n  let upgradeFunction; let\n    validateFunction;\n\n  do {\n    fromVersion = nextConfig.version;\n\n    if (!Object.keys(SCHEMA_HANDLERS).includes(fromVersion)) {\n      return [{\n        title: 'Config validation failed',\n        preformatted: 'Unknown config version.',\n      }, false];\n    }\n\n    [validateFunction, upgradeFunction] = SCHEMA_HANDLERS[fromVersion];\n\n    // Validate under the legacy schema before upgrading.\n    const validLegacy = validateFunction(nextConfig);\n    if (!validLegacy) {\n      const failureReason = JSON.stringify(validateFunction.errors, null, 2);\n      return [{\n        title: 'Config validation failed',\n        preformatted: failureReason,\n      }, false];\n    }\n\n    if (upgradeFunction) {\n      nextConfig = upgradeFunction(nextConfig);\n    }\n  } while (upgradeFunction);\n\n  // NOTE: Remove when a view config viewer/editor is available in UI.\n  console.groupCollapsed(`🚄 Vitessce (${packageJson.version}) view configuration`);\n  console.info(`data:,${JSON.stringify(nextConfig)}`);\n  console.info(JSON.stringify(nextConfig, null, 2));\n  console.groupEnd();\n\n  return [nextConfig, true];\n}\n"]},"metadata":{},"sourceType":"module"}