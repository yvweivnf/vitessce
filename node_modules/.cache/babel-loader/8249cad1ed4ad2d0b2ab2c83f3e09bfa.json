{"ast":null,"code":"import { isXorY } from '../channel';\nimport * as log from '../log';\nimport { isConcatModel, isFacetModel, isLayerModel } from './model';\nexport function defaultScaleResolve(channel, model) {\n  if (isFacetModel(model)) {\n    return channel === 'theta' ? 'independent' : 'shared';\n  } else if (isLayerModel(model)) {\n    return 'shared';\n  } else if (isConcatModel(model)) {\n    return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n  }\n  /* istanbul ignore next: should never reach here. */\n\n\n  throw new Error('invalid model type for resolve');\n}\nexport function parseGuideResolve(resolve, channel) {\n  var channelScaleResolve = resolve.scale[channel];\n  var guide = isXorY(channel) ? 'axis' : 'legend';\n\n  if (channelScaleResolve === 'independent') {\n    if (resolve[guide][channel] === 'shared') {\n      log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n    }\n\n    return 'independent';\n  }\n\n  return resolve[guide][channel] || 'shared';\n}","map":{"version":3,"sources":["../../../src/compile/resolve.ts"],"names":[],"mappings":"AAAA,SAAQ,MAAR,QAAmC,YAAnC;AACA,OAAO,KAAK,GAAZ,MAAqB,QAArB;AAEA,SAAQ,aAAR,EAAuB,YAAvB,EAAqC,YAArC,QAA+D,SAA/D;AAEA,OAAM,SAAU,mBAAV,CAA8B,OAA9B,EAAqD,KAArD,EAAiE;AACrE,MAAI,YAAY,CAAC,KAAD,CAAhB,EAAyB;AACvB,WAAO,OAAO,KAAK,OAAZ,GAAsB,aAAtB,GAAsC,QAA7C;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,KAAD,CAAhB,EAAyB;AAC9B,WAAO,QAAP;AACD,GAFM,MAEA,IAAI,aAAa,CAAC,KAAD,CAAjB,EAA0B;AAC/B,WAAO,MAAM,CAAC,OAAD,CAAN,IAAmB,OAAO,KAAK,OAA/B,IAA0C,OAAO,KAAK,QAAtD,GAAiE,aAAjE,GAAiF,QAAxF;AACD;AACD;;;AACA,QAAM,IAAI,KAAJ,CAAU,gCAAV,CAAN;AACD;AAED,OAAM,SAAU,iBAAV,CAA4B,OAA5B,EAA8C,OAA9C,EAAmE;AACvE,MAAM,mBAAmB,GAAG,OAAO,CAAC,KAAR,CAAc,OAAd,CAA5B;AACA,MAAM,KAAK,GAAG,MAAM,CAAC,OAAD,CAAN,GAAkB,MAAlB,GAA2B,QAAzC;;AAEA,MAAI,mBAAmB,KAAK,aAA5B,EAA2C;AACzC,QAAI,OAAO,CAAC,KAAD,CAAP,CAAe,OAAf,MAA4B,QAAhC,EAA0C;AACxC,MAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,qCAAZ,CAAkD,OAAlD,CAAT;AACD;;AACD,WAAO,aAAP;AACD;;AAED,SAAO,OAAO,CAAC,KAAD,CAAP,CAAe,OAAf,KAA2B,QAAlC;AACD","sourceRoot":"","sourcesContent":["import { isXorY } from '../channel';\nimport * as log from '../log';\nimport { isConcatModel, isFacetModel, isLayerModel } from './model';\nexport function defaultScaleResolve(channel, model) {\n    if (isFacetModel(model)) {\n        return channel === 'theta' ? 'independent' : 'shared';\n    }\n    else if (isLayerModel(model)) {\n        return 'shared';\n    }\n    else if (isConcatModel(model)) {\n        return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n    }\n    /* istanbul ignore next: should never reach here. */\n    throw new Error('invalid model type for resolve');\n}\nexport function parseGuideResolve(resolve, channel) {\n    const channelScaleResolve = resolve.scale[channel];\n    const guide = isXorY(channel) ? 'axis' : 'legend';\n    if (channelScaleResolve === 'independent') {\n        if (resolve[guide][channel] === 'shared') {\n            log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n        }\n        return 'independent';\n    }\n    return resolve[guide][channel] || 'shared';\n}\n//# sourceMappingURL=resolve.js.map"]},"metadata":{},"sourceType":"module"}