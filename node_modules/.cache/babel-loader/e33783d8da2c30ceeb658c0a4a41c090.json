{"ast":null,"code":"/* eslint-disable no-plusplus */ /* eslint-disable no-param-reassign */import{quadtree}from'd3-quadtree';/**\n * Returns a closure that returns a constant value.\n */function constant(v){return function(){return v;};}/**\n * Adds a tiny bit of randomness to a number.\n */function jiggle(v){return v+(Math.random()-0.5)*1e-6;}/**\n * A force function to be used with d3.forceSimulation.\n * This has been adapted for use here, with comments explaining each part.\n * Reference: https://bl.ocks.org/cmgiven/547658968d365bcc324f3e62e175709b\n */export function forceCollideRects(){// D3 implements things with function prototypes rather than classes.\n// Pretend these variables are the \"instance members\" of a class.\n// Note that this function actually returns the internal force() function,\n// but that the force() function is a closure with access to these instance members.\nvar nodes;var masses;var strength=1;var iterations=1;var sizes;var size=constant([0,0]);// Given a node, return the center point along the x-axis.\nfunction xCenter(d){return d.x+d.vx+sizes[d.index][0]/2;}// Given a node, return the center point along the y-axis.\nfunction yCenter(d){return d.y+d.vy+sizes[d.index][1]/2;}// Given a quadtree node, initialize its .size property.\nfunction prepare(quad){if(quad.data){// This is a leaf node, so we set quad.size to the node's size.\n// (No need to compute the max of internal nodes,\n// since leaf nodes do not have any internal nodes).\nquad.size=sizes[quad.data.index];}else{quad.size=[0,0];// Internal nodes of the quadtree are represented\n// as four-element arrays in left-to-right, top-to-bottom order.\n// Here, we are setting quad.size to [maxWidth, maxHeight]\n// among the internal nodes of this current `quad` node.\nfor(var i=0;i<4;i++){if(quad[i]&&quad[i].size){quad.size[0]=Math.max(quad.size[0],quad[i].size[0]);quad.size[1]=Math.max(quad.size[1],quad[i].size[1]);}}}}function force(){var node;var nodeSize;var nodeMass;var xi;var yi;// Create a quadtree based on node center points.\n// Initialize each quadtree node's .size property by calling\n// the prepare() function on each quadtree node.\nvar tree=quadtree(nodes,xCenter,yCenter).visitAfter(prepare);// Update the .vx and .vy properties of both `node` and `data`\n// (the current node pair).\nfunction apply(quad,x0,y0,x1,y1){// `quad` is a quadtree node.\nvar data=quad.data;var xSize=(nodeSize[0]+quad.size[0])/2;var ySize=(nodeSize[1]+quad.size[1])/2;if(data&&data.index>node.index){// This is a leaf node because `data` is defined.\n// `x` is the difference in x centers between `node` and `data`.\n// `y` is the difference in y centers between `node` and `data`.\nvar x=jiggle(xi-xCenter(data));var y=jiggle(yi-yCenter(data));var xd=Math.abs(x)-xSize;var yd=Math.abs(y)-ySize;// If `xd` and `yd` is less than zero,\n// then there is an overlap between the two nodes.\nif(xd<0&&yd<0){var l=Math.sqrt(x*x+y*y);var m=masses[data.index]/(nodeMass+masses[data.index]);// We move the nodes either in the x or y direction.\n// Nodes are moved proportionally to:\n// their distance apart (`l`), their amount of overlap (`xd` or `yd`), their masses (`m`),\n// and the strength parameter (`strength`).\nif(Math.abs(xd)<Math.abs(yd)){node.vx-=(x*=xd/l*strength)*m;data.vx+=x*(1-m);}else{node.vy-=(y*=yd/l*strength)*m;data.vy+=y*(1-m);}}// When the quadtree.visit callback returns _true_ for a node,\n// then the node's children will _not_ be visited.\nreturn x0>xi+xSize||x1<xi-xSize||y0>yi+ySize||y1<yi-ySize;}return false;}function iterate(){// On every iteration, use the `apply` function to visit every node\n// which has an index greater than the current node's index,\n// (visiting every node pair).\nfor(var j=0;j<nodes.length;j++){node=nodes[j];nodeSize=sizes[j];nodeMass=masses[j];xi=xCenter(node);yi=yCenter(node);tree.visit(apply);}}// Do the specified number of iterations.\nfor(var i=0;i<iterations;i++){iterate();}}// The \"constructor\".\n// Takes a list of nodes as input.\nforce.initialize=function(v){nodes=v;// Get the size [w, h] of each node using the size getter function.\nsizes=nodes.map(size);// Get the mass of each node,\n// which is the sum of its horizontal and vertical edge lengths.\nmasses=sizes.map(function(d){return d[0]+d[1];});};// Set the number of iterations.\n// If no value is provided as a parameter, this acts as a getter function.\nforce.iterations=function(){if(arguments.length){iterations=+(arguments.length<=0?undefined:arguments[0]);return force;}return iterations;};// Set the strength value.\n// If no value is provided as a parameter, this acts as a getter function.\nforce.strength=function(){if(arguments.length){strength=+(arguments.length<=0?undefined:arguments[0]);return force;}return strength;};// Set the size function.\n// The size function takes a node as a parameter and returns its size.\n// If no size function is provided as a parameter, this acts as a getter function.\nforce.size=function(){if(arguments.length){size=typeof(arguments.length<=0?undefined:arguments[0])==='function'?arguments.length<=0?undefined:arguments[0]:constant(arguments.length<=0?undefined:arguments[0]);return force;}return size;};// Returns the force closure.\nreturn force;}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/components/shared-spatial-scatterplot/force-collide-rects.js"],"names":["quadtree","constant","v","jiggle","Math","random","forceCollideRects","nodes","masses","strength","iterations","sizes","size","xCenter","d","x","vx","index","yCenter","y","vy","prepare","quad","data","i","max","force","node","nodeSize","nodeMass","xi","yi","tree","visitAfter","apply","x0","y0","x1","y1","xSize","ySize","xd","abs","yd","l","sqrt","m","iterate","j","length","visit","initialize","map"],"mappings":"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","sourcesContent":["/* eslint-disable no-plusplus */\n/* eslint-disable no-param-reassign */\nimport { quadtree } from 'd3-quadtree';\n\n/**\n * Returns a closure that returns a constant value.\n */\nfunction constant(v) {\n  return (() => v);\n}\n\n/**\n * Adds a tiny bit of randomness to a number.\n */\nfunction jiggle(v) {\n  return v + (Math.random() - 0.5) * 1e-6;\n}\n\n/**\n * A force function to be used with d3.forceSimulation.\n * This has been adapted for use here, with comments explaining each part.\n * Reference: https://bl.ocks.org/cmgiven/547658968d365bcc324f3e62e175709b\n */\nexport function forceCollideRects() {\n  // D3 implements things with function prototypes rather than classes.\n  // Pretend these variables are the \"instance members\" of a class.\n  // Note that this function actually returns the internal force() function,\n  // but that the force() function is a closure with access to these instance members.\n\n  let nodes;\n  let masses;\n  let strength = 1;\n  let iterations = 1;\n\n  let sizes;\n  let size = constant([0, 0]);\n\n  // Given a node, return the center point along the x-axis.\n  function xCenter(d) {\n    return d.x + d.vx + sizes[d.index][0] / 2;\n  }\n\n  // Given a node, return the center point along the y-axis.\n  function yCenter(d) {\n    return d.y + d.vy + sizes[d.index][1] / 2;\n  }\n\n  // Given a quadtree node, initialize its .size property.\n  function prepare(quad) {\n    if (quad.data) {\n      // This is a leaf node, so we set quad.size to the node's size.\n      // (No need to compute the max of internal nodes,\n      // since leaf nodes do not have any internal nodes).\n      quad.size = sizes[quad.data.index];\n    } else {\n      quad.size = [0, 0];\n      // Internal nodes of the quadtree are represented\n      // as four-element arrays in left-to-right, top-to-bottom order.\n      // Here, we are setting quad.size to [maxWidth, maxHeight]\n      // among the internal nodes of this current `quad` node.\n      for (let i = 0; i < 4; i++) {\n        if (quad[i] && quad[i].size) {\n          quad.size[0] = Math.max(quad.size[0], quad[i].size[0]);\n          quad.size[1] = Math.max(quad.size[1], quad[i].size[1]);\n        }\n      }\n    }\n  }\n\n  function force() {\n    let node;\n    let nodeSize;\n    let nodeMass;\n    let xi;\n    let yi;\n\n    // Create a quadtree based on node center points.\n    // Initialize each quadtree node's .size property by calling\n    // the prepare() function on each quadtree node.\n    const tree = quadtree(nodes, xCenter, yCenter).visitAfter(prepare);\n\n    // Update the .vx and .vy properties of both `node` and `data`\n    // (the current node pair).\n    function apply(quad, x0, y0, x1, y1) {\n      // `quad` is a quadtree node.\n      const { data } = quad;\n      const xSize = (nodeSize[0] + quad.size[0]) / 2;\n      const ySize = (nodeSize[1] + quad.size[1]) / 2;\n\n      if (data && data.index > node.index) {\n        // This is a leaf node because `data` is defined.\n        // `x` is the difference in x centers between `node` and `data`.\n        // `y` is the difference in y centers between `node` and `data`.\n        let x = jiggle(xi - xCenter(data));\n        let y = jiggle(yi - yCenter(data));\n        const xd = Math.abs(x) - xSize;\n        const yd = Math.abs(y) - ySize;\n\n        // If `xd` and `yd` is less than zero,\n        // then there is an overlap between the two nodes.\n        if (xd < 0 && yd < 0) {\n          const l = Math.sqrt(x * x + y * y);\n          const m = masses[data.index] / (nodeMass + masses[data.index]);\n\n          // We move the nodes either in the x or y direction.\n          // Nodes are moved proportionally to:\n          // their distance apart (`l`), their amount of overlap (`xd` or `yd`), their masses (`m`),\n          // and the strength parameter (`strength`).\n          if (Math.abs(xd) < Math.abs(yd)) {\n            node.vx -= (x *= xd / l * strength) * m;\n            data.vx += x * (1 - m);\n          } else {\n            node.vy -= (y *= yd / l * strength) * m;\n            data.vy += y * (1 - m);\n          }\n        }\n        // When the quadtree.visit callback returns _true_ for a node,\n        // then the node's children will _not_ be visited.\n        return x0 > xi + xSize || x1 < xi - xSize || y0 > yi + ySize || y1 < yi - ySize;\n      }\n      return false;\n    }\n\n    function iterate() {\n      // On every iteration, use the `apply` function to visit every node\n      // which has an index greater than the current node's index,\n      // (visiting every node pair).\n      for (let j = 0; j < nodes.length; j++) {\n        node = nodes[j];\n        nodeSize = sizes[j];\n        nodeMass = masses[j];\n        xi = xCenter(node);\n        yi = yCenter(node);\n\n        tree.visit(apply);\n      }\n    }\n\n    // Do the specified number of iterations.\n    for (let i = 0; i < iterations; i++) {\n      iterate();\n    }\n  }\n\n  // The \"constructor\".\n  // Takes a list of nodes as input.\n  force.initialize = (v) => {\n    nodes = v;\n    // Get the size [w, h] of each node using the size getter function.\n    sizes = nodes.map(size);\n    // Get the mass of each node,\n    // which is the sum of its horizontal and vertical edge lengths.\n    masses = sizes.map(d => d[0] + d[1]);\n  };\n\n  // Set the number of iterations.\n  // If no value is provided as a parameter, this acts as a getter function.\n  force.iterations = (...v) => {\n    if (v.length) {\n      iterations = +v[0];\n      return force;\n    }\n    return iterations;\n  };\n\n  // Set the strength value.\n  // If no value is provided as a parameter, this acts as a getter function.\n  force.strength = (...v) => {\n    if (v.length) {\n      strength = +v[0];\n      return force;\n    }\n    return strength;\n  };\n\n  // Set the size function.\n  // The size function takes a node as a parameter and returns its size.\n  // If no size function is provided as a parameter, this acts as a getter function.\n  force.size = (...v) => {\n    if (v.length) {\n      size = (typeof v[0] === 'function' ? v[0] : constant(v[0]));\n      return force;\n    }\n    return size;\n  };\n\n  // Returns the force closure.\n  return force;\n}\n"]},"metadata":{},"sourceType":"module"}