{"ast":null,"code":"import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\n\nfunction customFormatExpr(formatType, field, format) {\n  return \"\".concat(formatType, \"(\").concat(field).concat(format ? \", \".concat(stringify(format)) : '', \")\");\n}\n\nexport var BIN_RANGE_DELIMITER = \" \\u2013 \";\nexport function formatSignalRef(_ref) {\n  var fieldOrDatumDef = _ref.fieldOrDatumDef,\n      format = _ref.format,\n      formatType = _ref.formatType,\n      expr = _ref.expr,\n      normalizeStack = _ref.normalizeStack,\n      config = _ref.config;\n\n  var _a, _b;\n\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef: fieldOrDatumDef,\n      format: format,\n      formatType: formatType,\n      expr: expr,\n      config: config\n    });\n  }\n\n  var field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    var signal = timeFormatExpression(field, isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined, format, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);\n    return signal ? {\n      signal: signal\n    } : undefined;\n  }\n\n  format = numberFormat(channelDefType(fieldOrDatumDef), format, config);\n\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    var endField = vgField(fieldOrDatumDef, {\n      expr: expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: \"\".concat(formatExpr(field, format))\n    };\n  } else {\n    return {\n      signal: \"isValid(\".concat(field, \") ? \").concat(field, \" : \\\"\\\"+\").concat(field)\n    };\n  }\n}\n\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return \"\".concat(vgField(fieldOrDatumDef, {\n        expr: expr,\n        suffix: 'end'\n      }), \"-\").concat(vgField(fieldOrDatumDef, {\n        expr: expr,\n        suffix: 'start'\n      }));\n    } else {\n      return vgField(fieldOrDatumDef, {\n        expr: expr\n      });\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\n\nexport function formatCustomType(_ref2) {\n  var fieldOrDatumDef = _ref2.fieldOrDatumDef,\n      format = _ref2.format,\n      formatType = _ref2.formatType,\n      expr = _ref2.expr,\n      normalizeStack = _ref2.normalizeStack,\n      config = _ref2.config,\n      field = _ref2.field;\n  field !== null && field !== void 0 ? field : field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    var endField = vgField(fieldOrDatumDef, {\n      expr: expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n\n  return {\n    signal: customFormatExpr(formatType, field, format)\n  };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n  var _a;\n\n  if (isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    var timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n    return timeFormat(format, timeUnit, config, omitTimeFormatConfig);\n  }\n\n  return numberFormat(type, format, config);\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return 'time';\n  }\n\n  return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\n\nexport function numberFormat(type, specifiedFormat, config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n\n  return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\n\nexport function timeFormat(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\n\nfunction formatExpr(field, format) {\n  return \"format(\".concat(field, \", \\\"\").concat(format || '', \"\\\")\");\n}\n\nfunction binNumberFormatExpr(field, format, formatType, config) {\n  var _a;\n\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n\n  return formatExpr(field, (_a = isString(format) ? format : undefined) !== null && _a !== void 0 ? _a : config.numberFormat);\n}\n\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n  var start = binNumberFormatExpr(startField, format, formatType, config);\n  var end = binNumberFormatExpr(endField, format, formatType, config);\n  return \"\".concat(fieldValidPredicate(startField, false), \" ? \\\"null\\\" : \").concat(start, \" + \\\"\").concat(BIN_RANGE_DELIMITER, \"\\\" + \").concat(end);\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\n\nexport function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale) {\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    return \"\".concat(isUTCScale ? 'utc' : 'time', \"Format(\").concat(field, \", '\").concat(format, \"')\");\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}","map":{"version":3,"sources":["../../../src/compile/format.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n    return formatType && formatType !== 'number' && formatType !== 'time';\n}\nfunction customFormatExpr(formatType, field, format) {\n    return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function formatSignalRef({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config }) {\n    var _a, _b;\n    if (isCustomFormatType(formatType)) {\n        return formatCustomType({\n            fieldOrDatumDef,\n            format,\n            formatType,\n            expr,\n            config\n        });\n    }\n    const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n        const signal = timeFormatExpression(field, isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined, format, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);\n        return signal ? { signal } : undefined;\n    }\n    format = numberFormat(channelDefType(fieldOrDatumDef), format, config);\n    if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n        const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });\n        return {\n            signal: binFormatExpression(field, endField, format, formatType, config)\n        };\n    }\n    else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n        return {\n            signal: `${formatExpr(field, format)}`\n        };\n    }\n    else {\n        return { signal: `isValid(${field}) ? ${field} : \"\"+${field}` };\n    }\n}\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n    if (isFieldDef(fieldOrDatumDef)) {\n        if (normalizeStack) {\n            return `${vgField(fieldOrDatumDef, { expr, suffix: 'end' })}-${vgField(fieldOrDatumDef, {\n                expr,\n                suffix: 'start'\n            })}`;\n        }\n        else {\n            return vgField(fieldOrDatumDef, { expr });\n        }\n    }\n    else {\n        return datumDefToExpr(fieldOrDatumDef);\n    }\n}\nexport function formatCustomType({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config, field }) {\n    field !== null && field !== void 0 ? field : (field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack));\n    if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n        const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });\n        return {\n            signal: binFormatExpression(field, endField, format, formatType, config)\n        };\n    }\n    return { signal: customFormatExpr(formatType, field, format) };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n    var _a;\n    if (isCustomFormatType(formatType)) {\n        return undefined; // handled in encode block\n    }\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n        const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n        return timeFormat(format, timeUnit, config, omitTimeFormatConfig);\n    }\n    return numberFormat(type, format, config);\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n    if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n        return formatType;\n    }\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n        return 'time';\n    }\n    return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat(type, specifiedFormat, config) {\n    // Specified format in axis/legend has higher precedence than fieldDef.format\n    if (isString(specifiedFormat)) {\n        return specifiedFormat;\n    }\n    if (type === QUANTITATIVE) {\n        // we only apply the default if the field is quantitative\n        return config.numberFormat;\n    }\n    return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {\n    if (specifiedFormat) {\n        return specifiedFormat;\n    }\n    if (timeUnit) {\n        return {\n            signal: timeUnitSpecifierExpression(timeUnit)\n        };\n    }\n    return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\nfunction formatExpr(field, format) {\n    return `format(${field}, \"${format || ''}\")`;\n}\nfunction binNumberFormatExpr(field, format, formatType, config) {\n    var _a;\n    if (isCustomFormatType(formatType)) {\n        return customFormatExpr(formatType, field, format);\n    }\n    return formatExpr(field, (_a = (isString(format) ? format : undefined)) !== null && _a !== void 0 ? _a : config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n    const start = binNumberFormatExpr(startField, format, formatType, config);\n    const end = binNumberFormatExpr(endField, format, formatType, config);\n    return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale) {\n    if (!timeUnit || format) {\n        // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n        format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n        return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    }\n    else {\n        return formatExpression(timeUnit, field, isUTCScale);\n    }\n}\n//# sourceMappingURL=format.js.map"]},"metadata":{},"sourceType":"module"}