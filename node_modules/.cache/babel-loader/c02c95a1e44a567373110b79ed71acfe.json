{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleInit(init) {\n  var isExpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n\n  if (isArray(init)) {\n    var assembled = init.map(function (v) {\n      return assembleInit(v, isExpr, wrap);\n    });\n    return isExpr ? \"[\".concat(assembled.join(', '), \"]\") : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n\n  return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  var _a;\n\n  var _iterator = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var selCmpt = _step.value;\n      var name = selCmpt.name;\n      var modifyExpr = \"\".concat(name).concat(TUPLE, \", \").concat(selCmpt.resolve === 'global' ? 'true' : \"{unit: \".concat(unitName(model), \"}\"));\n\n      var _iterator2 = _createForOfIteratorHelper(selectionCompilers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var c = _step2.value;\n          if (!c.defined(selCmpt)) continue;\n          if (c.signals) signals = c.signals(model, selCmpt, signals);\n          if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      signals.push({\n        name: name + MODIFY,\n        on: [{\n          events: {\n            signal: selCmpt.name + TUPLE\n          },\n          update: \"modify(\".concat(stringValue(selCmpt.name + STORE), \", \").concat(modifyExpr, \")\")\n        }]\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    var name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: \"isTuple(facet) ? facet : group(\".concat(name, \").datum\")\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  var _a;\n\n  var hasSelections = false;\n\n  var _iterator3 = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n      _step3;\n\n  try {\n    var _loop = function _loop() {\n      var selCmpt = _step3.value;\n      var name = selCmpt.name;\n      var store = stringValue(name + STORE);\n      var hasSg = signals.filter(function (s) {\n        return s.name === name;\n      });\n\n      if (hasSg.length === 0) {\n        var resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n        var isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n        signals.push({\n          name: selCmpt.name,\n          update: \"\".concat(VL_SELECTION_RESOLVE, \"(\").concat(store, \", \").concat(stringValue(resolve)).concat(isPoint)\n        });\n      }\n\n      hasSelections = true;\n\n      var _iterator4 = _createForOfIteratorHelper(selectionCompilers),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var c = _step4.value;\n\n          if (c.defined(selCmpt) && c.topLevelSignals) {\n            signals = c.topLevelSignals(model, selCmpt, signals);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    };\n\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (hasSelections) {\n    var hasUnit = signals.filter(function (s) {\n      return s.name === 'unit';\n    });\n\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  var _a;\n\n  var dataCopy = _toConsumableArray(data);\n\n  var _iterator5 = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n      _step5;\n\n  try {\n    var _loop2 = function _loop2() {\n      var selCmpt = _step5.value;\n      var init = {\n        name: selCmpt.name + STORE\n      };\n\n      if (selCmpt.init) {\n        var fields = selCmpt.project.items.map(function (proj) {\n          var signals = proj.signals,\n              rest = __rest(proj, [\"signals\"]);\n\n          return rest;\n        });\n        init.values = selCmpt.init.map(function (i) {\n          return {\n            unit: unitName(model, {\n              escape: false\n            }),\n            fields: fields,\n            values: assembleInit(i, false)\n          };\n        });\n      }\n\n      var contains = dataCopy.filter(function (d) {\n        return d.name === selCmpt.name + STORE;\n      });\n\n      if (!contains.length) {\n        dataCopy.push(init);\n      }\n    };\n\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      _loop2();\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  var _a;\n\n  var _iterator6 = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var selCmpt = _step6.value;\n\n      var _iterator7 = _createForOfIteratorHelper(selectionCompilers),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var c = _step7.value;\n\n          if (c.defined(selCmpt) && c.marks) {\n            marks = c.marks(model, selCmpt, marks);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  var _iterator8 = _createForOfIteratorHelper(model.children),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var child = _step8.value;\n\n      if (isUnitModel(child)) {\n        marks = assembleUnitSelectionMarks(child, marks);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n  var parsedExtent = parseSelectionExtent(model, extent.param, extent);\n  return {\n    signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1] ? \"isValid(\".concat(parsedExtent, \") && reverse(\").concat(parsedExtent, \")\") : parsedExtent\n  };\n}\n\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(function (s) {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n    if (isArray(init)) {\n        const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n        return isExpr ? `[${assembled.join(', ')}]` : assembled;\n    }\n    else if (isDateTime(init)) {\n        if (isExpr) {\n            return wrap(dateTimeToExpr(init));\n        }\n        else {\n            return wrap(dateTimeToTimestamp(init));\n        }\n    }\n    return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n    var _a;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const name = selCmpt.name;\n        let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n        for (const c of selectionCompilers) {\n            if (!c.defined(selCmpt))\n                continue;\n            if (c.signals)\n                signals = c.signals(model, selCmpt, signals);\n            if (c.modifyExpr)\n                modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n        }\n        signals.push({\n            name: name + MODIFY,\n            on: [\n                {\n                    events: { signal: selCmpt.name + TUPLE },\n                    update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n                }\n            ]\n        });\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n    if (model.component.selection && keys(model.component.selection).length) {\n        const name = stringValue(model.getName('cell'));\n        signals.unshift({\n            name: 'facet',\n            value: {},\n            on: [\n                {\n                    events: parseSelector('mousemove', 'scope'),\n                    update: `isTuple(facet) ? facet : group(${name}).datum`\n                }\n            ]\n        });\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n    var _a;\n    let hasSelections = false;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const name = selCmpt.name;\n        const store = stringValue(name + STORE);\n        const hasSg = signals.filter(s => s.name === name);\n        if (hasSg.length === 0) {\n            const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n            const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n            signals.push({\n                name: selCmpt.name,\n                update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n            });\n        }\n        hasSelections = true;\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.topLevelSignals) {\n                signals = c.topLevelSignals(model, selCmpt, signals);\n            }\n        }\n    }\n    if (hasSelections) {\n        const hasUnit = signals.filter(s => s.name === 'unit');\n        if (hasUnit.length === 0) {\n            signals.unshift({\n                name: 'unit',\n                value: {},\n                on: [{ events: 'mousemove', update: 'isTuple(group()) ? group() : unit' }]\n            });\n        }\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n    var _a;\n    const dataCopy = [...data];\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const init = { name: selCmpt.name + STORE };\n        if (selCmpt.init) {\n            const fields = selCmpt.project.items.map(proj => {\n                const { signals } = proj, rest = __rest(proj, [\"signals\"]);\n                return rest;\n            });\n            init.values = selCmpt.init.map(i => ({\n                unit: unitName(model, { escape: false }),\n                fields,\n                values: assembleInit(i, false)\n            }));\n        }\n        const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n        if (!contains.length) {\n            dataCopy.push(init);\n        }\n    }\n    return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n    var _a;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.marks) {\n                marks = c.marks(model, selCmpt, marks);\n            }\n        }\n    }\n    return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n    for (const child of model.children) {\n        if (isUnitModel(child)) {\n            marks = assembleUnitSelectionMarks(child, marks);\n        }\n    }\n    return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n    const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n    return {\n        signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1]\n            ? `isValid(${parsedExtent}) && reverse(${parsedExtent})`\n            : parsedExtent\n    };\n}\nfunction cleanupEmptyOnArray(signals) {\n    return signals.map(s => {\n        if (s.on && !s.on.length)\n            delete s.on;\n        return s;\n    });\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}