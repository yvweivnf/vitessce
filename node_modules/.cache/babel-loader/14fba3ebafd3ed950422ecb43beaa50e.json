{"ast":null,"code":"import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\n\nfunction customFormatExpr(formatType, field, format) {\n  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function formatSignalRef({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config\n}) {\n  var _a, _b;\n\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef,\n      format,\n      formatType,\n      expr,\n      config\n    });\n  }\n\n  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const signal = timeFormatExpression(field, isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined, format, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);\n    return signal ? {\n      signal\n    } : undefined;\n  }\n\n  format = numberFormat(channelDefType(fieldOrDatumDef), format, config);\n\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: `${formatExpr(field, format)}`\n    };\n  } else {\n    return {\n      signal: `isValid(${field}) ? ${field} : \"\"+${field}`\n    };\n  }\n}\n\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return `${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'end'\n      })}-${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'start'\n      })}`;\n    } else {\n      return vgField(fieldOrDatumDef, {\n        expr\n      });\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\n\nexport function formatCustomType({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config,\n  field\n}) {\n  field !== null && field !== void 0 ? field : field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n\n  return {\n    signal: customFormatExpr(formatType, field, format)\n  };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n  var _a;\n\n  if (isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n    return timeFormat(format, timeUnit, config, omitTimeFormatConfig);\n  }\n\n  return numberFormat(type, format, config);\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return 'time';\n  }\n\n  return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\n\nexport function numberFormat(type, specifiedFormat, config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n\n  return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\n\nexport function timeFormat(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\n\nfunction formatExpr(field, format) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nfunction binNumberFormatExpr(field, format, formatType, config) {\n  var _a;\n\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n\n  return formatExpr(field, (_a = isString(format) ? format : undefined) !== null && _a !== void 0 ? _a : config.numberFormat);\n}\n\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n  const start = binNumberFormatExpr(startField, format, formatType, config);\n  const end = binNumberFormatExpr(endField, format, formatType, config);\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\n\nexport function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale) {\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}","map":{"version":3,"sources":["../../../src/compile/format.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n    return formatType && formatType !== 'number' && formatType !== 'time';\n}\nfunction customFormatExpr(formatType, field, format) {\n    return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function formatSignalRef({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config }) {\n    var _a, _b;\n    if (isCustomFormatType(formatType)) {\n        return formatCustomType({\n            fieldOrDatumDef,\n            format,\n            formatType,\n            expr,\n            config\n        });\n    }\n    const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n        const signal = timeFormatExpression(field, isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined, format, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);\n        return signal ? { signal } : undefined;\n    }\n    format = numberFormat(channelDefType(fieldOrDatumDef), format, config);\n    if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n        const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });\n        return {\n            signal: binFormatExpression(field, endField, format, formatType, config)\n        };\n    }\n    else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n        return {\n            signal: `${formatExpr(field, format)}`\n        };\n    }\n    else {\n        return { signal: `isValid(${field}) ? ${field} : \"\"+${field}` };\n    }\n}\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n    if (isFieldDef(fieldOrDatumDef)) {\n        if (normalizeStack) {\n            return `${vgField(fieldOrDatumDef, { expr, suffix: 'end' })}-${vgField(fieldOrDatumDef, {\n                expr,\n                suffix: 'start'\n            })}`;\n        }\n        else {\n            return vgField(fieldOrDatumDef, { expr });\n        }\n    }\n    else {\n        return datumDefToExpr(fieldOrDatumDef);\n    }\n}\nexport function formatCustomType({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config, field }) {\n    field !== null && field !== void 0 ? field : (field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack));\n    if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n        const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });\n        return {\n            signal: binFormatExpression(field, endField, format, formatType, config)\n        };\n    }\n    return { signal: customFormatExpr(formatType, field, format) };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n    var _a;\n    if (isCustomFormatType(formatType)) {\n        return undefined; // handled in encode block\n    }\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n        const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n        return timeFormat(format, timeUnit, config, omitTimeFormatConfig);\n    }\n    return numberFormat(type, format, config);\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n    if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n        return formatType;\n    }\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n        return 'time';\n    }\n    return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat(type, specifiedFormat, config) {\n    // Specified format in axis/legend has higher precedence than fieldDef.format\n    if (isString(specifiedFormat)) {\n        return specifiedFormat;\n    }\n    if (type === QUANTITATIVE) {\n        // we only apply the default if the field is quantitative\n        return config.numberFormat;\n    }\n    return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {\n    if (specifiedFormat) {\n        return specifiedFormat;\n    }\n    if (timeUnit) {\n        return {\n            signal: timeUnitSpecifierExpression(timeUnit)\n        };\n    }\n    return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\nfunction formatExpr(field, format) {\n    return `format(${field}, \"${format || ''}\")`;\n}\nfunction binNumberFormatExpr(field, format, formatType, config) {\n    var _a;\n    if (isCustomFormatType(formatType)) {\n        return customFormatExpr(formatType, field, format);\n    }\n    return formatExpr(field, (_a = (isString(format) ? format : undefined)) !== null && _a !== void 0 ? _a : config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n    const start = binNumberFormatExpr(startField, format, formatType, config);\n    const end = binNumberFormatExpr(endField, format, formatType, config);\n    return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale) {\n    if (!timeUnit || format) {\n        // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n        format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n        return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    }\n    else {\n        return formatExpression(timeUnit, field, isUTCScale);\n    }\n}\n//# sourceMappingURL=format.js.map"]},"metadata":{},"sourceType":"module"}