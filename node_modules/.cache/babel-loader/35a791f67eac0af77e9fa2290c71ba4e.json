{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n  var legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n  model.component.legends = legendComponent;\n  return legendComponent;\n}\n\nfunction parseUnitLegend(model) {\n  var encoding = model.encoding;\n  var legendComponent = {};\n\n  for (var _i = 0, _arr = [COLOR].concat(_toConsumableArray(LEGEND_SCALE_CHANNELS)); _i < _arr.length; _i++) {\n    var channel = _arr[_i];\n    var def = getFieldOrDatumDef(encoding[channel]);\n\n    if (!def || !model.getScaleComponent(channel)) {\n      continue;\n    }\n\n    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n      continue;\n    }\n\n    legendComponent[channel] = parseLegendForChannel(model, channel);\n  }\n\n  return legendComponent;\n}\n\nfunction getLegendDefWithScale(model, channel) {\n  var scale = model.scaleName(channel);\n\n  if (model.mark === 'trail') {\n    if (channel === 'color') {\n      // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n      return {\n        stroke: scale\n      };\n    } else if (channel === 'size') {\n      return {\n        strokeWidth: scale\n      };\n    }\n  }\n\n  if (channel === 'color') {\n    return model.markDef.filled ? {\n      fill: scale\n    } : {\n      stroke: scale\n    };\n  }\n\n  return _defineProperty({}, channel, scale);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nfunction isExplicit(value, property, legend, fieldDef) {\n  switch (property) {\n    case 'disable':\n      return legend !== undefined;\n    // if axis is specified or null/false, then its enable/disable state is explicit\n\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!(legend === null || legend === void 0 ? void 0 : legend.values);\n\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {\n        return true;\n      }\n\n  } // Otherwise, things are explicit if the returned value matches the specified property\n\n\n  return value === (legend || {})[property];\n}\n\nexport function parseLegendForChannel(model, channel) {\n  var _a, _b, _c;\n\n  var legend = model.legend(channel);\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config;\n  var legendConfig = config.legend;\n  var legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n  var disable = legend !== undefined ? !legend : legendConfig.disable;\n  legendCmpt.set('disable', disable, legend !== undefined);\n\n  if (disable) {\n    return legendCmpt;\n  }\n\n  legend = legend || {};\n  var scaleType = model.getScaleComponent(channel).get('type');\n  var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  var timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n  var orient = legend.orient || config.legend.orient || 'right';\n  var legendType = getLegendType({\n    legend: legend,\n    channel: channel,\n    timeUnit: timeUnit,\n    scaleType: scaleType\n  });\n  var direction = getDirection({\n    legend: legend,\n    legendType: legendType,\n    orient: orient,\n    legendConfig: legendConfig\n  });\n  var ruleParams = {\n    legend: legend,\n    channel: channel,\n    model: model,\n    markDef: markDef,\n    encoding: encoding,\n    fieldOrDatumDef: fieldOrDatumDef,\n    legendConfig: legendConfig,\n    config: config,\n    scaleType: scaleType,\n    orient: orient,\n    legendType: legendType,\n    direction: direction\n  };\n\n  var _iterator = _createForOfIteratorHelper(LEGEND_COMPONENT_PROPERTIES),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var property = _step.value;\n\n      if (legendType === 'gradient' && property.startsWith('symbol') || legendType === 'symbol' && property.startsWith('gradient')) {\n        continue;\n      }\n\n      var _value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n\n      if (_value !== undefined) {\n        var explicit = isExplicit(_value, property, legend, model.fieldDef(channel));\n\n        if (explicit || config.legend[property] === undefined) {\n          legendCmpt.set(property, _value, explicit);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};\n  var selections = legendCmpt.get('selections');\n  var legendEncode = {};\n  var legendEncodeParams = {\n    fieldOrDatumDef: fieldOrDatumDef,\n    model: model,\n    channel: channel,\n    legendCmpt: legendCmpt,\n    legendType: legendType\n  };\n\n  for (var _i2 = 0, _arr2 = ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']; _i2 < _arr2.length; _i2++) {\n    var part = _arr2[_i2];\n    var legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);\n    var value = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n    : legendEncodingPart; // no rule -- just default values\n\n    if (value !== undefined && !isEmpty(value)) {\n      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? {\n        name: \"\".concat(varName(fieldOrDatumDef.field), \"_legend_\").concat(part)\n      } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? {\n        interactive: !!selections\n      } : {}), {\n        update: value\n      });\n    }\n  }\n\n  if (!isEmpty(legendEncode)) {\n    legendCmpt.set('encode', legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));\n  }\n\n  return legendCmpt;\n}\n\nfunction parseNonUnitLegend(model) {\n  var _model$component = model.component,\n      legends = _model$component.legends,\n      resolve = _model$component.resolve;\n\n  var _iterator2 = _createForOfIteratorHelper(model.children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      parseLegend(child);\n\n      var _iterator4 = _createForOfIteratorHelper(keys(child.component.legends)),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var channel = _step4.value;\n          resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n          if (resolve.legend[channel] === 'shared') {\n            // If the resolve says shared (and has not been overridden)\n            // We will try to merge and see if there is a conflict\n            legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n            if (!legends[channel]) {\n              // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n              // Thus, mark legend as independent and remove the legend component.\n              resolve.legend[channel] = 'independent';\n              delete legends[channel];\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(keys(legends)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _channel = _step3.value;\n\n      var _iterator5 = _createForOfIteratorHelper(model.children),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _child = _step5.value;\n\n          if (!_child.component.legends[_channel]) {\n            // skip if the child does not have a particular legend\n            continue;\n          }\n\n          if (resolve.legend[_channel] === 'shared') {\n            // After merging shared legend, make sure to remove legend from child\n            delete _child.component.legends[_channel];\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n  var _a, _b, _c, _d;\n\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n\n  var mergedOrient = mergedLegend.getWithExplicit('orient');\n  var childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  var typeMerged = false; // Otherwise, let's merge\n\n  var _iterator6 = _createForOfIteratorHelper(LEGEND_COMPONENT_PROPERTIES),\n      _step6;\n\n  try {\n    var _loop = function _loop() {\n      var prop = _step6.value;\n      var mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', // Tie breaker function\n      function (v1, v2) {\n        switch (prop) {\n          case 'symbolType':\n            return mergeSymbolType(v1, v2);\n\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n\n        return defaultTieBreaker(v1, v2, prop, 'legend');\n      });\n      mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n    };\n\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  if (typeMerged) {\n    if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n\n    if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1, st2) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n\n  return st1;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n    const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n    model.component.legends = legendComponent;\n    return legendComponent;\n}\nfunction parseUnitLegend(model) {\n    const { encoding } = model;\n    const legendComponent = {};\n    for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n        const def = getFieldOrDatumDef(encoding[channel]);\n        if (!def || !model.getScaleComponent(channel)) {\n            continue;\n        }\n        if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n            continue;\n        }\n        legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n    return legendComponent;\n}\nfunction getLegendDefWithScale(model, channel) {\n    const scale = model.scaleName(channel);\n    if (model.mark === 'trail') {\n        if (channel === 'color') {\n            // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n            return { stroke: scale };\n        }\n        else if (channel === 'size') {\n            return { strokeWidth: scale };\n        }\n    }\n    if (channel === 'color') {\n        return model.markDef.filled ? { fill: scale } : { stroke: scale };\n    }\n    return { [channel]: scale };\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isExplicit(value, property, legend, fieldDef) {\n    switch (property) {\n        case 'disable':\n            return legend !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n        case 'values':\n            // specified legend.values is already respected, but may get transformed.\n            return !!(legend === null || legend === void 0 ? void 0 : legend.values);\n        case 'title':\n            // title can be explicit if fieldDef.title is set\n            if (property === 'title' && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {\n                return true;\n            }\n    }\n    // Otherwise, things are explicit if the returned value matches the specified property\n    return value === (legend || {})[property];\n}\nexport function parseLegendForChannel(model, channel) {\n    var _a, _b, _c;\n    let legend = model.legend(channel);\n    const { markDef, encoding, config } = model;\n    const legendConfig = config.legend;\n    const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n    parseInteractiveLegend(model, channel, legendCmpt);\n    const disable = legend !== undefined ? !legend : legendConfig.disable;\n    legendCmpt.set('disable', disable, legend !== undefined);\n    if (disable) {\n        return legendCmpt;\n    }\n    legend = legend || {};\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n    const orient = legend.orient || config.legend.orient || 'right';\n    const legendType = getLegendType({ legend, channel, timeUnit, scaleType });\n    const direction = getDirection({ legend, legendType, orient, legendConfig });\n    const ruleParams = {\n        legend,\n        channel,\n        model,\n        markDef,\n        encoding,\n        fieldOrDatumDef,\n        legendConfig,\n        config,\n        scaleType,\n        orient,\n        legendType,\n        direction\n    };\n    for (const property of LEGEND_COMPONENT_PROPERTIES) {\n        if ((legendType === 'gradient' && property.startsWith('symbol')) ||\n            (legendType === 'symbol' && property.startsWith('gradient'))) {\n            continue;\n        }\n        const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n        if (value !== undefined) {\n            const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n            if (explicit || config.legend[property] === undefined) {\n                legendCmpt.set(property, value, explicit);\n            }\n        }\n    }\n    const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};\n    const selections = legendCmpt.get('selections');\n    const legendEncode = {};\n    const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType };\n    for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {\n        const legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);\n        const value = part in legendEncodeRules\n            ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n            : legendEncodingPart; // no rule -- just default values\n        if (value !== undefined && !isEmpty(value)) {\n            legendEncode[part] = Object.assign(Object.assign(Object.assign({}, ((selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef)\n                ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` }\n                : {})), ((selections === null || selections === void 0 ? void 0 : selections.length) ? { interactive: !!selections } : {})), { update: value });\n        }\n    }\n    if (!isEmpty(legendEncode)) {\n        legendCmpt.set('encode', legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));\n    }\n    return legendCmpt;\n}\nfunction parseNonUnitLegend(model) {\n    const { legends, resolve } = model.component;\n    for (const child of model.children) {\n        parseLegend(child);\n        for (const channel of keys(child.component.legends)) {\n            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n            if (resolve.legend[channel] === 'shared') {\n                // If the resolve says shared (and has not been overridden)\n                // We will try to merge and see if there is a conflict\n                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n                if (!legends[channel]) {\n                    // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n                    // Thus, mark legend as independent and remove the legend component.\n                    resolve.legend[channel] = 'independent';\n                    delete legends[channel];\n                }\n            }\n        }\n    }\n    for (const channel of keys(legends)) {\n        for (const child of model.children) {\n            if (!child.component.legends[channel]) {\n                // skip if the child does not have a particular legend\n                continue;\n            }\n            if (resolve.legend[channel] === 'shared') {\n                // After merging shared legend, make sure to remove legend from child\n                delete child.component.legends[channel];\n            }\n        }\n    }\n    return legends;\n}\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n    var _a, _b, _c, _d;\n    if (!mergedLegend) {\n        return childLegend.clone();\n    }\n    const mergedOrient = mergedLegend.getWithExplicit('orient');\n    const childOrient = childLegend.getWithExplicit('orient');\n    if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n        // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n        // Cannot merge due to inconsistent orient\n        return undefined;\n    }\n    let typeMerged = false;\n    // Otherwise, let's merge\n    for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n        const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', \n        // Tie breaker function\n        (v1, v2) => {\n            switch (prop) {\n                case 'symbolType':\n                    return mergeSymbolType(v1, v2);\n                case 'title':\n                    return mergeTitleComponent(v1, v2);\n                case 'type':\n                    // There are only two types. If we have different types, then prefer symbol over gradient.\n                    typeMerged = true;\n                    return makeImplicit('symbol');\n            }\n            return defaultTieBreaker(v1, v2, prop, 'legend');\n        });\n        mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n    }\n    if (typeMerged) {\n        if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {\n            deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n        }\n        if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {\n            deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n        }\n    }\n    return mergedLegend;\n}\nfunction mergeSymbolType(st1, st2) {\n    if (st2.value === 'circle') {\n        // prefer \"circle\" over \"stroke\"\n        return st2;\n    }\n    return st1;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}