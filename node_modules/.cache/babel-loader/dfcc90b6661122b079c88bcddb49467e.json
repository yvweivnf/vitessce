{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { getOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\n\nexport function pointPosition(channel, model, {\n  defaultPos,\n  vgChannel\n}) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const offset = getOffset(channel, markDef); // Get default position or position from mark def\n\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  });\n  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef\n  });\n  return valueRef ? {\n    [vgChannel || channel]: valueRef\n  } : undefined;\n} // TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\n\nexport function positionRef(params) {\n  const {\n    channel,\n    channelDef,\n    scaleName,\n    stack,\n    offset,\n    markDef\n  } = params; // This isn't a part of midPoint because we use midPoint for non-position too\n\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      let bandPosition = channelDef.bandPosition;\n\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName,\n          fieldOrDatumDef: channelDef,\n          startSuffix: 'start',\n          bandPosition,\n          offset\n        });\n      }\n    } // x or y use stack_end so that stacked line's point mark use stack_end too.\n\n\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef({\n  model,\n  defaultPos,\n  channel,\n  scaleName,\n  scale\n}) {\n  const {\n    markDef,\n    config\n  } = model;\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel\n    });\n\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n\n    switch (defaultPos) {\n      case 'zeroOrMin':\n      case 'zeroOrMax':\n        if (scaleName) {\n          const scaleType = scale.get('type');\n\n          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {// Log scales cannot have zero.\n            // Zero in time scale is arbitrary, and does not affect ratio.\n            // (Time is an interval level of measurement, not ratio).\n            // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          } else {\n            if (scale.domainDefinitelyIncludesZero()) {\n              return {\n                scale: scaleName,\n                value: 0\n              };\n            }\n          }\n        }\n\n        if (defaultPos === 'zeroOrMin') {\n          return mainChannel === 'y' ? {\n            field: {\n              group: 'height'\n            }\n          } : {\n            value: 0\n          };\n        } else {\n          // zeroOrMax\n          switch (mainChannel) {\n            case 'radius':\n              // max of radius is min(width, height) / 2\n              return {\n                signal: `min(${model.width.signal},${model.height.signal})/2`\n              };\n\n            case 'theta':\n              return {\n                signal: '2*PI'\n              };\n\n            case 'x':\n              return {\n                field: {\n                  group: 'width'\n                }\n              };\n\n            case 'y':\n              return {\n                value: 0\n              };\n          }\n        }\n\n        break;\n\n      case 'mid':\n        {\n          const sizeRef = model[getSizeChannel(channel)];\n          return Object.assign(Object.assign({}, sizeRef), {\n            mult: 0.5\n          });\n        }\n    } // defaultPos === null\n\n\n    return undefined;\n  };\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-point.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { getOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(channel, model, { defaultPos, vgChannel }) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding[channel];\n    const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const offset = getOffset(channel, markDef);\n    // Get default position or position from mark def\n    const defaultRef = pointPositionDefaultRef({\n        model,\n        defaultPos,\n        channel,\n        scaleName,\n        scale\n    });\n    const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude)\n        ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n            { field: model.getName(channel) }\n        : positionRef({\n            channel,\n            channelDef,\n            channel2Def,\n            markDef,\n            config,\n            scaleName,\n            scale,\n            stack,\n            offset,\n            defaultRef\n        });\n    return valueRef ? { [vgChannel || channel]: valueRef } : undefined;\n}\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(params) {\n    const { channel, channelDef, scaleName, stack, offset, markDef } = params;\n    // This isn't a part of midPoint because we use midPoint for non-position too\n    if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n        if (isFieldDef(channelDef)) {\n            let bandPosition = channelDef.bandPosition;\n            if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n                // theta and radius of text mark should use bandPosition = 0.5 by default\n                // so that labels for arc marks are centered automatically\n                bandPosition = 0.5;\n            }\n            if (bandPosition !== undefined) {\n                return ref.interpolatedSignalRef({\n                    scaleName,\n                    fieldOrDatumDef: channelDef,\n                    startSuffix: 'start',\n                    bandPosition,\n                    offset\n                });\n            }\n        }\n        // x or y use stack_end so that stacked line's point mark use stack_end too.\n        return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: 'end' }, { offset });\n    }\n    return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale }) {\n    const { markDef, config } = model;\n    return () => {\n        const mainChannel = getMainRangeChannel(channel);\n        const vgChannel = getVgPositionChannel(channel);\n        const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });\n        if (definedValueOrConfig !== undefined) {\n            return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n        }\n        switch (defaultPos) {\n            case 'zeroOrMin':\n            case 'zeroOrMax':\n                if (scaleName) {\n                    const scaleType = scale.get('type');\n                    if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n                        // Log scales cannot have zero.\n                        // Zero in time scale is arbitrary, and does not affect ratio.\n                        // (Time is an interval level of measurement, not ratio).\n                        // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n                    }\n                    else {\n                        if (scale.domainDefinitelyIncludesZero()) {\n                            return {\n                                scale: scaleName,\n                                value: 0\n                            };\n                        }\n                    }\n                }\n                if (defaultPos === 'zeroOrMin') {\n                    return mainChannel === 'y' ? { field: { group: 'height' } } : { value: 0 };\n                }\n                else {\n                    // zeroOrMax\n                    switch (mainChannel) {\n                        case 'radius':\n                            // max of radius is min(width, height) / 2\n                            return {\n                                signal: `min(${model.width.signal},${model.height.signal})/2`\n                            };\n                        case 'theta':\n                            return { signal: '2*PI' };\n                        case 'x':\n                            return { field: { group: 'width' } };\n                        case 'y':\n                            return { value: 0 };\n                    }\n                }\n                break;\n            case 'mid': {\n                const sizeRef = model[getSizeChannel(channel)];\n                return Object.assign(Object.assign({}, sizeRef), { mult: 0.5 });\n            }\n        }\n        // defaultPos === null\n        return undefined;\n    };\n}\n//# sourceMappingURL=position-point.js.map"]},"metadata":{},"sourceType":"module"}