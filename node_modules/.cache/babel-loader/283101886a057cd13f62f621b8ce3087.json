{"ast":null,"code":"import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize(spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\n\nfunction parsePadding(spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\n\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\n\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n\n  return encode;\n}\n\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults(encode, type, role, style, config) {\n  const defaults = {},\n        enter = {};\n  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\n\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;\n\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_)); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction rule(enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry$1(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n\nfunction parseEncode(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\n\nfunction parse$1(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nfunction parseSignal(signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nfunction operator(value, params) {\n  return entry('operator', value, params);\n} // -----\n\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\n\nconst keyFieldRef = fieldRef$1('key');\n\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\n\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\n\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\n\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\n\nconst Scope$1 = 'scope';\nconst View = 'view';\n\nfunction isSignal(_) {\n  return _ && _.signal;\n}\n\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\n\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\n\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({\n    merge: list\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\n\nfunction parseUpdate(spec, scope, target) {\n  const encode = spec.encode,\n        entry = {\n    target: target\n  };\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);\n\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\n\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\n\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v; // get value counts for each domain field\n\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection(proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  } // apply projection defaults from config\n\n\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter$1(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n  return _;\n}\n\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\n\nfunction anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\n\nconst alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\n\nfunction tickBand(_) {\n  const v = _('tickBand');\n\n  let offset = _('tickOffset'),\n      band,\n      extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n    };\n    extra = {\n      signal: `(${v.signal}) === 'extent'`\n    };\n\n    if (!isObject(offset)) {\n      offset = {\n        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {\n    extra,\n    band,\n    offset\n  };\n}\n\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n\n  return mark;\n}\n\nfunction legendGradient(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u,\n      v,\n      uu,\n      vv,\n      adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n\nfunction legendGradientLabels(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter,\n      update,\n      u,\n      v,\n      adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction legendSymbolGroups(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {\n    data: 'value'\n  },\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {\n    field: Size\n  },\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\n\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr$1}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n\nfunction legendTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip(clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr ? scope.signalRef(expr) : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole(spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition(spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n/**\n * Parse a data transform specification.\n */\n\n\nfunction parseTransform(spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\n\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef; // loop over defs to find matching key\n\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nconst outerExpr = _ => _ && _.expr;\n\nconst outerField = _ => _ && _.field;\n\nconst isData = _ => _ === 'data';\n\nconst isExpr = _ => _ === 'expr';\n\nconst isField = _ => _ === 'field';\n\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData$1(from, group, scope) {\n  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n        values = entries[n - 1],\n        output = entries[n - 2];\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n  let k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n\n};\n\nfunction parseFacet(spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow(spec, scope, input) {\n  const op = scope.add(PreFacet({\n    pulse: input.pulse\n  })),\n        subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger(spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark(spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops,\n      op,\n      store,\n      enc,\n      name,\n      layoutRef,\n      boundRef;\n  const nested = role === MarkRole || layout || facet; // resolve input data\n\n  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  const render = scope.add(Render({\n    pulse: boundRef\n  })),\n        sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend(spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0,\n      entryLayout,\n      params,\n      children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  } // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  } // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  } // generate legend marks\n\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n\nfunction parseTitle(spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = []; // single-element data source for group title\n\n\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\n\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.text,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.subtitle,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\n\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\n\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\n\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\n\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: `${test} ? (${a}) : (${b})`\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n});\n\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: `(${sign.signal}) * ${value}`\n} : {\n  value: sign * value\n};\n\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key in obj) map[key] = 1;\n  }\n\n  return Object.keys(map);\n}\n\nfunction axisConfig(spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy,\n      or,\n      key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n\n    or = {};\n\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ;else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: `(${sign.signal}) * (${offset || 0})`\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: `(${entry.mult}) * (${sign.signal})`\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n\n    entry.mult = sign;\n  }\n  return offset;\n}\n\nfunction axisTicks(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nfunction axisLabels(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n\n  const bound = _('labelBound');\n\n  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis(spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_); // single-element data source for axis group\n\n\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  const children = [];\n  let size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: `abs(span(range(\"${spec.scale}\")))`\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n  scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n  array(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions\n\n  scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n  array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n  array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n  array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\n\nfunction parseView(spec, scope) {\n  const config = scope.config; // add scenegraph root\n\n  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  const input = scope.add(Collect()); // encode root group item\n\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\n\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {}; // add spec signal array\n\n\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n\n    function annotate(op, name, type) {\n      let data, list;\n\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n\n    this._parent.push(parent);\n\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n\n    this._parent.pop();\n\n    this._lookup.pop();\n\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n\n  // ----\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    const a = aggrField(sort.op, sort.field),\n          o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n\n  // ----\n  event(source, type) {\n    const key = source + ':' + type;\n\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n\n    return this.events[key];\n  },\n\n  // ----\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n\n  // ----\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.data[name] = dataScope;\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\n\n\nfunction defaults() {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-parser/build/vega-parser.module.js"],"names":["isObject","isArray","extend","hasOwnProperty","array","stringValue","peek","isString","error","splitAccessPath","mergeConfig","parseExpression","parseSelector","isValidScaleType","isDiscrete","isQuantile","isDiscretizing","isContinuous","definition","definition$1","parseAutosize","spec","type","number","_","paddingObject","top","bottom","left","right","parsePadding","signal","encoder","value","addEncode","object","name","set","isEncoder","length","update","addEncoders","enter","extendEncode","encode","extra","skip","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendBandRole","LegendEntryRole","LegendGradientRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleRole","TitleTextRole","TitleSubtitleRole","applyDefaults","role","style","config","defaults","props","applyDefault","String","startsWith","group","mark","forEach","scaleRef","scale","field","entry$1","enc","gradient","color","undefined","exponent","property","mult","offset","round","_color","x","y","z","map","join","c","h","l","s","a","b","r","g","args","start","stop","count","pop","unshift","ref","resolveField","datum","level","parent","Math","max","range","band","rule","code","test","parseEncode","scope","params","encoders","$encode","parseBlock","block","marktype","channels","fields","parse$1","expr","$expr","$fields","Object","keys","$output","$params","OUTER","OUTER_INVALID","outerError","prefix","parseSignal","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","id","entry","operator","$ref","refs","fieldRef$1","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","keyRef","flat","$key","$flat","Ascending","Descending","sortKey","sort","order","aggrField","Scope$1","View","isSignal","isExpr$1","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","method","merge","mergeStream","nestedStream","eventStream","eventSource","source","list","streamParameters","addStream","event","throttle","between","filter","param","concat","markname","markrole","filterMark","debounce","consume","item","OP_VALUE_EXPR","ast","parseUpdate","target","events","sources","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","parseSignalUpdates","getSignal","init","initonly","on","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","initScale","addScale","domain","parseScale","getScale","parseScaleDomain","parseScaleRange","interpolate","parseScaleInterpolate","nice","parseScaleNice","bins","parseScaleBins","parseLiteral","parseArray","dataLookupError","domainMin","domainMax","explicitDomain","multipleDomain","singularDomain","data","getData","valuesRef","parseSort","domainRef","extentRef","reduce","dom","d","fieldRef","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","coll","$ingest","input","addDataPipeline","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","objectProperty","interval","step","gamma","interpolateGamma","scheme","extent","schemeExtent","schemeCount","rangeStep","parseProjection","proj","projection","parseParameter$1","addProjection","Top","Left","Right","Bottom","Center","Vertical","Start","Middle","End","Index","Label","Offset","Perc","Perc2","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","Shape","Fill","Stroke","StrokeWidth","StrokeDash","Opacity","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","SymbolMark","TextMark","guideGroup","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","getStyle","anchorExpr","e","m","alignExpr$1","tickBand","extendOffset","assign","guideMark","extras","legendGradient","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","legendGradientDiscrete","dataRef","u","uu","vv","adjust","from","alignExpr","baselineExpr","legendGradientLabels","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","legendSymbolGroups","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","facet","marks","legendSymbolLayout","center","padding","isL","isR","isLR","isVG","alignFlip","exprAlign","exprAnchor","exprAngle","exprBaseline","legendTitle","orient","_anchor","anchor","angle","title","lineHeight","path","sphere","getRole","indexOf","zindex","aria","description","parseTransform","def","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","parseParameter","parseIndexParameter","required","parseSubParameters","projectionRef","parameterValue","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","lookupRef","parseSubParameter","k","parseData$1","getDataRef","aggregate","output","DataScope","aggr","fromEntries","fieldKey","addSortField","cache","ds","optype","prototype","agg","tuplesRef","indataRef","parseFacet","subscope","fork","addData","subflow","$subflow","parse","toRuntime","parseSubflow","parseTrigger","remove","insert","toggle","modify","trigger","parseMark","layout","store","layoutRef","boundRef","nested","clean","joinRef","markdef","context","$context","groups","markpath","markRef","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","popState","parseOverlap","render","sieve","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","parseLegend","legend","legendEncode","scales","entryLayout","children","legendType","scaleType","vgrad","entryEncode","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","sizeExpression","buildLegendEncode","scaleCount","titlePadding","cornerRadius","getChannel","getFontSize","angleExpr","parseTitle","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","dx","dy","parseData","transforms","analyze","generate","upstream","load","collect","$format","url","$request","modifies","derive","splice","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","ifRight","ifRightExpr","$orient","ifEnc","ifExpr","isSimple","toExpr","ifOrient","sign","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","axis","axisBand","xy","or","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","result","axisDomain","strokeCap","strokeOpacity","pos0","position","pos1","x2","y2","pos","axisGrid","vscale","gridScale","offsetValue","tickPos","sz","gridStart","gridEnd","axisTicks","tickSize","flushExpr","threshold","axisLabels","flush","flushOffset","labelAlign","labelBaseline","flushOn","offsetExpr","axisTitle","titlePos","autoLayout","auto","dim","autoY","autoX","parseAxis","axisEncode","ticks","grid","ticksRef","tickCount","buildAxisEncode","minExtent","maxExtent","translate","parseScope","preprocessed","projections","axes","parseLambdas","rootEncode","parseView","root","collectSignals","eventConfig","locale","autosize","signalObject","pre","Scope","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","finish","vref","annotate","cmp","check","sig","o","hasOwnSignal","propertyLambda","addScaleProj","projectionType","dataScope","arrayLambda","objectLambda","defaultFont","defaultSymbolSize","defaultStrokeWidth","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","signalUpdates"],"mappings":"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","sourcesContent":["import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize (spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\n\nfunction parsePadding (spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n\n  return encode;\n}\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults (encode, type, role, style, config) {\n  const defaults = {},\n        enter = {};\n  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\n\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;\n\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_)); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction rule (enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry$1(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n\nfunction parseEncode (encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\n\nfunction parse$1(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nfunction parseSignal (signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\nfunction operator(value, params) {\n  return entry('operator', value, params);\n} // -----\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\nconst keyFieldRef = fieldRef$1('key');\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\nconst Scope$1 = 'scope';\nconst View = 'view';\nfunction isSignal(_) {\n  return _ && _.signal;\n}\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({\n    merge: list\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\nfunction parseUpdate (spec, scope, target) {\n  const encode = spec.encode,\n        entry = {\n    target: target\n  };\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates (signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);\n\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\n\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v; // get value counts for each domain field\n\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection (proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  } // apply projection defaults from config\n\n\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter$1(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\n\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup (mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n  return _;\n}\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\nfunction anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\nconst alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\nfunction tickBand(_) {\n  const v = _('tickBand');\n\n  let offset = _('tickOffset'),\n      band,\n      extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n    };\n    extra = {\n      signal: `(${v.signal}) === 'extent'`\n    };\n\n    if (!isObject(offset)) {\n      offset = {\n        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {\n    extra,\n    band,\n    offset\n  };\n}\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark (mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n\n  return mark;\n}\n\nfunction legendGradient (spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u,\n      v,\n      uu,\n      vv,\n      adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\nfunction legendGradientLabels (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter,\n      update,\n      u,\n      v,\n      adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction legendSymbolGroups (spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {\n    data: 'value'\n  },\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {\n    field: Size\n  },\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr$1}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\nfunction legendTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip (clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr ? scope.signalRef(expr) : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole (spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition (spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive (spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n\n/**\n * Parse a data transform specification.\n */\n\nfunction parseTransform (spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef; // loop over defs to find matching key\n\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nconst outerExpr = _ => _ && _.expr;\nconst outerField = _ => _ && _.field;\nconst isData = _ => _ === 'data';\nconst isExpr = _ => _ === 'expr';\nconst isField = _ => _ === 'field';\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData$1 (from, group, scope) {\n  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n        values = entries[n - 1],\n        output = entries[n - 2];\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n  let k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n\n};\n\nfunction parseFacet (spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow (spec, scope, input) {\n  const op = scope.add(PreFacet({\n    pulse: input.pulse\n  })),\n        subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger (spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark (spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops,\n      op,\n      store,\n      enc,\n      name,\n      layoutRef,\n      boundRef;\n  const nested = role === MarkRole || layout || facet; // resolve input data\n\n  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  const render = scope.add(Render({\n    pulse: boundRef\n  })),\n        sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend (spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0,\n      entryLayout,\n      params,\n      children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  } // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  } // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  } // generate legend marks\n\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\nfunction parseTitle (spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = []; // single-element data source for group title\n\n\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.text,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.subtitle,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: `${test} ? (${a}) : (${b})`\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n});\n\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: `(${sign.signal}) * ${value}`\n} : {\n  value: sign * value\n};\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key in obj) map[key] = 1;\n  }\n\n  return Object.keys(map);\n}\n\nfunction axisConfig (spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy,\n      or,\n      key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n\n    or = {};\n\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid (spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ; else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: `(${sign.signal}) * (${offset || 0})`\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: `(${entry.mult}) * (${sign.signal})`\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n\nfunction axisTicks (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nfunction axisLabels (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n\n  const bound = _('labelBound');\n\n  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis (spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_); // single-element data source for axis group\n\n\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  const children = [];\n  let size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: `abs(span(range(\"${spec.scale}\")))`\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope (spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n  scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n  array(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions\n\n  scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n  array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n  array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n  array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\n\nfunction parseView(spec, scope) {\n  const config = scope.config; // add scenegraph root\n\n  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  const input = scope.add(Collect()); // encode root group item\n\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\n\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {}; // add spec signal array\n\n\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n\n    function annotate(op, name, type) {\n      let data, list;\n\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n\n    this._parent.push(parent);\n\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n\n    this._parent.pop();\n\n    this._lookup.pop();\n\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n\n  // ----\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    const a = aggrField(sort.op, sort.field),\n          o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n\n  // ----\n  event(source, type) {\n    const key = source + ':' + type;\n\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n\n    return this.events[key];\n  },\n\n  // ----\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n\n  // ----\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.data[name] = dataScope;\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults () {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse (spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };\n"]},"metadata":{},"sourceType":"module"}