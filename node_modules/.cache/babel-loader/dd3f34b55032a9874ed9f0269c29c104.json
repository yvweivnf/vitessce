{"ast":null,"code":"import { createIterable } from '@deck.gl/core';\nimport { getGridOffset } from '../utils/grid-aggregation-utils';\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {\n    data = [],\n    cellSize\n  } = props;\n  const {\n    attributes,\n    viewport,\n    projectPoints,\n    numInstances\n  } = aggregationParams;\n  const positions = attributes.positions.value;\n  const {\n    size\n  } = attributes.positions.getAccessor();\n  const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset\n    };\n  }\n\n  const {\n    width,\n    height\n  } = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  const gridHash = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n  const position = new Array(3);\n\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n\n      if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {\n        const key = \"\".concat(yIndex, \"-\").concat(xIndex);\n        gridHash[key] = gridHash[key] || {\n          count: 0,\n          points: [],\n          lonIdx: xIndex,\n          latIdx: yIndex\n        };\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n\n  return {\n    gridHash,\n    gridOffset,\n    offsets: [offsets[0] * -1, offsets[1] * -1]\n  };\n}\n\nfunction getGridLayerDataFromGridHash(_ref) {\n  let {\n    gridHash,\n    gridOffset,\n    offsets\n  } = _ref;\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n    data[index] = {\n      index,\n      position: [offsets[0] + gridOffset.xOffset * lonIdx, offsets[1] + gridOffset.yOffset * latIdx],\n      ...gridHash[key]\n    };\n  }\n\n  return data;\n}\n\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  const positions = positionAttribute.value;\n  const {\n    size\n  } = positionAttribute.getAccessor();\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  };\n}","map":{"version":3,"sources":["../../../src/cpu-grid-layer/grid-aggregator.js"],"names":["hashInfo","pointsToGridHashing","result","getGridLayerDataFromGridHash","gridHash","gridOffset","data","cellSize","numInstances","positions","attributes","size","boundingBox","aggregationParams","getPositionBoundingBox","offsets","getGridOffset","height","numCol","Math","width","numRow","objectInfo","createIterable","position","projectPoints","viewport","Number","yIndex","y","xIndex","x","key","count","points","lonIdx","latIdx","source","index","Object","i","idxs","parseInt","positionAttribute","yMin","yMax","xMin","xMax"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {createIterable} from '@deck.gl/core';\nimport {getGridOffset} from '../utils/grid-aggregation-utils';\n\n/**\n * Calculate density grid from an array of points\n * @param {Object} props - object containing :\n * @param {Iterable} [props.data] - data objects to be aggregated\n * @param {Integer} [props.cellSize] - size of the grid cell\n *\n * @param {Object} aggregationParams - object containing :\n * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters\n * @param {Integer} width - width of the grid\n * @param {Integer} height - height of the grid\n * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise\n * @param {Array} attributes - attributes array containing position values\n * @param {Viewport} viewport - viewport to be used for projection\n * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index\n * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data\n *\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable max-statements, complexity */\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {data = [], cellSize} = props;\n  const {attributes, viewport, projectPoints, numInstances} = aggregationParams;\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n  const boundingBox =\n    aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  const {width, height} = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n\n  // calculate count per cell\n  const gridHash = {};\n\n  const {iterable, objectInfo} = createIterable(data);\n  const position = new Array(3);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n      if (\n        !projectPoints ||\n        // when doing screen space agggregation (projectPoints = true), filter points outside of the viewport range.\n        (xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow)\n      ) {\n        const key = `${yIndex}-${xIndex}`;\n\n        gridHash[key] = gridHash[key] || {count: 0, points: [], lonIdx: xIndex, latIdx: yIndex};\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n\n  return {gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1]};\n}\n/* eslint-enable max-statements, complexity */\n\nfunction getGridLayerDataFromGridHash({gridHash, gridOffset, offsets}) {\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n\n    data[index] = {\n      index,\n      position: [\n        offsets[0] + gridOffset.xOffset * lonIdx,\n        offsets[1] + gridOffset.yOffset * latIdx\n      ],\n      ...gridHash[key]\n    };\n  }\n  return data;\n}\n\n// Calculate bounding box of position attribute\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = positionAttribute.value;\n  const {size} = positionAttribute.getAccessor();\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {xMin, xMax, yMin, yMax};\n}\n"]},"metadata":{},"sourceType":"module"}