{"ast":null,"code":"import { deduceMeshField } from '@loaders.gl/schema';\nimport { Schema } from '@loaders.gl/schema';\nexport function getDracoSchema(attributes, loaderData, indices) {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);\n    fields.push(field);\n  }\n\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData) {\n  const result = {};\n\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(attributeName, attribute, loaderData) {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata) {\n  const metadataMap = new Map();\n\n  for (const key in metadata) {\n    metadataMap.set(\"\".concat(key, \".string\"), JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}","map":{"version":3,"sources":["../../../../src/lib/utils/get-draco-schema.ts"],"names":["metadataMap","makeMetadata","loaderData","fields","namedLoaderDataAttributes","transformAttributesLoaderData","attribute","attributes","field","getArrowFieldFromAttribute","indicesField","result","dracoAttribute","deduceMeshField","JSON","metadata"],"mappings":"AAAA,SAAA,eAAA,QAAA,oBAAA;AACA,SAAA,MAAA,QAAA,oBAAA;AAIA,OAAO,SAAA,cAAA,CAAA,UAAA,EAAA,UAAA,EAAA,OAAA,EAIG;AACR,QAAMA,WAAW,GAAGC,YAAY,CAACC,UAAU,CAA3C,QAAgC,CAAhC;AACA,QAAMC,MAAe,GAArB,EAAA;AACA,QAAMC,yBAAyB,GAAGC,6BAA6B,CAACH,UAAU,CAA1E,UAA+D,CAA/D;;AACA,OAAK,MAAL,aAAA,IAAA,UAAA,EAAwC;AACtC,UAAMI,SAAS,GAAGC,UAAU,CAA5B,aAA4B,CAA5B;AACA,UAAMC,KAAK,GAAGC,0BAA0B,CAAA,aAAA,EAAA,SAAA,EAGtCL,yBAAyB,CAH3B,aAG2B,CAHa,CAAxC;AAKAD,IAAAA,MAAM,CAANA,IAAAA,CAAAA,KAAAA;AACD;;AACD,MAAA,OAAA,EAAa;AACX,UAAMO,YAAY,GAAGD,0BAA0B,CAAA,SAAA,EAA/C,OAA+C,CAA/C;AACAN,IAAAA,MAAM,CAANA,IAAAA,CAAAA,YAAAA;AACD;;AACD,SAAO,IAAA,MAAA,CAAA,MAAA,EAAP,WAAO,CAAP;AACD;;AAED,SAAA,6BAAA,CAAA,UAAA,EAEE;AACA,QAAMQ,MAAiD,GAAvD,EAAA;;AACA,OAAK,MAAL,GAAA,IAAA,UAAA,EAA8B;AAC5B,UAAMC,cAAc,GAAGV,UAAU,CAAjC,GAAiC,CAAjC;AACAS,IAAAA,MAAM,CAACC,cAAc,CAAdA,IAAAA,IAAPD,WAAM,CAANA,GAAAA,cAAAA;AACD;;AACD,SAAA,MAAA;AACD;;AAED,SAAA,0BAAA,CAAA,aAAA,EAAA,SAAA,EAAA,UAAA,EAIS;AACP,QAAMX,WAAW,GAAGE,UAAU,GAAGD,YAAY,CAACC,UAAU,CAA1B,QAAe,CAAf,GAA9B,SAAA;AACA,QAAMM,KAAK,GAAGK,eAAe,CAAA,aAAA,EAAA,SAAA,EAA7B,WAA6B,CAA7B;AACA,SAAA,KAAA;AACD;;AAED,SAAA,YAAA,CAAA,QAAA,EAA0F;AACxF,QAAMb,WAAW,GAAG,IAApB,GAAoB,EAApB;;AACA,OAAK,MAAL,GAAA,IAAA,QAAA,EAA4B;AAC1BA,IAAAA,WAAW,CAAXA,GAAAA,CAAAA,GAAAA,MAAAA,CAAAA,GAAAA,EAAAA,SAAAA,CAAAA,EAAiCc,IAAI,CAAJA,SAAAA,CAAeC,QAAQ,CAAxDf,GAAwD,CAAvBc,CAAjCd;AACD;;AACD,SAAA,WAAA;AACD","sourcesContent":["import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n  return metadataMap;\n}\n"]},"metadata":{},"sourceType":"module"}