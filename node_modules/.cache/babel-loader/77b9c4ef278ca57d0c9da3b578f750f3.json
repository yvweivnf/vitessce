{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc, wrapGetValueFunc } from './aggregation-operation-utils';\n\nfunction nop() {}\n\nvar dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nvar _defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\n\nvar defaultGetCellSize = function defaultGetCellSize(props) {\n  return props.cellSize;\n};\n\nvar CPUAggregator = /*#__PURE__*/function () {\n  function CPUAggregator(opts) {\n    _classCallCheck(this, CPUAggregator);\n\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n\n    this._addDimension(opts.dimensions || _defaultDimensions);\n  }\n\n  _createClass(CPUAggregator, [{\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n          props = opts.props,\n          changeFlags = opts.changeFlags;\n      this.updateGetValueFuncs(oldProps, props, changeFlags);\n      var reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n      var aggregationDirty = false;\n\n      if (changeFlags.dataChanged || reprojectNeeded) {\n        this.getAggregatedData(props, aggregationParams);\n        aggregationDirty = true;\n      } else {\n        var dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n        aggregationDirty = true;\n      }\n\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n      return this.state;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = _objectSpread({}, this.state, {}, updateObject);\n    }\n  }, {\n    key: \"setDimensionState\",\n    value: function setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: _objectSpread({}, this.state.dimensions, _defineProperty({}, key, _objectSpread({}, this.state.dimensions[key], {}, updateObject)))\n      });\n    }\n  }, {\n    key: \"normalizeResult\",\n    value: function normalizeResult() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (result.hexagons) {\n        return _objectSpread({\n          data: result.hexagons\n        }, result);\n      } else if (result.layerData) {\n        return _objectSpread({\n          data: result.layerData\n        }, result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getAggregatedData\",\n    value: function getAggregatedData(props, aggregationParams) {\n      var aggregator = this._getAggregator(props);\n\n      var result = aggregator(props, aggregationParams);\n      this.setState({\n        layerData: this.normalizeResult(result)\n      });\n      this.changeFlags = {\n        layerData: true\n      };\n      this.getSortedBins(props);\n    }\n  }, {\n    key: \"updateGetValueFuncs\",\n    value: function updateGetValueFuncs(oldProps, props, changeFlags) {\n      for (var key in this.dimensionUpdaters) {\n        var _this$dimensionUpdate = this.dimensionUpdaters[key].getBins.triggers,\n            value = _this$dimensionUpdate.value,\n            weight = _this$dimensionUpdate.weight,\n            aggregation = _this$dimensionUpdate.aggregation;\n        var getValue = props[value.prop];\n        var getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n\n        if (getValueChanged) {\n          if (getValue) {\n            getValue = wrapGetValueFunc(getValue, {\n              data: props.data\n            });\n          } else {\n            getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {\n              data: props.data\n            });\n          }\n        }\n\n        if (getValue) {\n          this.setDimensionState(key, {\n            getValue: getValue\n          });\n        }\n      }\n    }\n  }, {\n    key: \"needsReProjectPoints\",\n    value: function needsReProjectPoints(oldProps, props, changeFlags) {\n      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n    }\n  }, {\n    key: \"addDimension\",\n    value: function addDimension(dimensions) {\n      this._addDimension(dimensions);\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = _this.getDimensionUpdaters(dimension);\n        _this.state.dimensions[key] = {\n          getValue: null,\n          domain: null,\n          sortedBins: null,\n          scaleFunc: nop\n        };\n      });\n    }\n  }, {\n    key: \"getDimensionUpdaters\",\n    value: function getDimensionUpdaters(_ref) {\n      var key = _ref.key,\n          accessor = _ref.accessor,\n          pickingInfo = _ref.pickingInfo,\n          getBins = _ref.getBins,\n          getDomain = _ref.getDomain,\n          getScaleFunc = _ref.getScaleFunc,\n          nullValue = _ref.nullValue;\n      return {\n        key: key,\n        accessor: accessor,\n        pickingInfo: pickingInfo,\n        getBins: _objectSpread({\n          updater: this.getDimensionSortedBins\n        }, getBins),\n        getDomain: _objectSpread({\n          updater: this.getDimensionValueDomain\n        }, getDomain),\n        getScaleFunc: _objectSpread({\n          updater: this.getDimensionScale\n        }, getScaleFunc),\n        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n      };\n    }\n  }, {\n    key: \"needUpdateDimensionStep\",\n    value: function needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        }\n\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"getDimensionChanges\",\n    value: function getDimensionChanges(oldProps, props, changeFlags) {\n      var _this2 = this;\n\n      var updaters = [];\n\n      var _loop = function _loop(key) {\n        var needUpdate = dimensionSteps.find(function (step) {\n          return _this2.needUpdateDimensionStep(_this2.dimensionUpdaters[key][step], oldProps, props, changeFlags);\n        });\n\n        if (needUpdate) {\n          updaters.push(_this2.dimensionUpdaters[key][needUpdate].updater.bind(_this2, props, _this2.dimensionUpdaters[key]));\n        }\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop(key);\n      }\n\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n\n      var _updateTriggers = props.updateTriggers || {};\n\n      var updateTriggers = {};\n\n      var _loop2 = function _loop2(key) {\n        var accessor = _this3.dimensionUpdaters[key].accessor;\n        updateTriggers[accessor] = {};\n        dimensionSteps.forEach(function (step) {\n          Object.values(_this3.dimensionUpdaters[key][step].triggers).forEach(function (_ref2) {\n            var prop = _ref2.prop,\n                updateTrigger = _ref2.updateTrigger;\n\n            if (updateTrigger) {\n              var fromProp = _updateTriggers[updateTrigger];\n\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop2(key);\n      }\n\n      return updateTriggers;\n    }\n  }, {\n    key: \"getSortedBins\",\n    value: function getSortedBins(props) {\n      for (var key in this.dimensionUpdaters) {\n        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n      }\n    }\n  }, {\n    key: \"getDimensionSortedBins\",\n    value: function getDimensionSortedBins(props, dimensionUpdater) {\n      var key = dimensionUpdater.key;\n      var getValue = this.state.dimensions[key].getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue,\n        filterData: props._filterData\n      });\n      this.setDimensionState(key, {\n        sortedBins: sortedBins\n      });\n      this.getDimensionValueDomain(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionValueDomain\",\n    value: function getDimensionValueDomain(props, dimensionUpdater) {\n      var getDomain = dimensionUpdater.getDomain,\n          key = dimensionUpdater.key;\n      var _getDomain$triggers = getDomain.triggers,\n          lowerPercentile = _getDomain$triggers.lowerPercentile,\n          upperPercentile = _getDomain$triggers.upperPercentile,\n          scaleType = _getDomain$triggers.scaleType;\n      var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n      this.setDimensionState(key, {\n        valueDomain: valueDomain\n      });\n      this.getDimensionScale(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionScale\",\n    value: function getDimensionScale(props, dimensionUpdater) {\n      var key = dimensionUpdater.key,\n          getScaleFunc = dimensionUpdater.getScaleFunc,\n          getDomain = dimensionUpdater.getDomain;\n      var _getScaleFunc$trigger = getScaleFunc.triggers,\n          domain = _getScaleFunc$trigger.domain,\n          range = _getScaleFunc$trigger.range;\n      var scaleType = getDomain.triggers.scaleType;\n      var onSet = getScaleFunc.onSet;\n      var dimensionRange = props[range.prop];\n      var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n      var getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n      var scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n      if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n        props[onSet.props](scaleFunc.domain());\n      }\n\n      this.setDimensionState(key, {\n        scaleFunc: scaleFunc\n      });\n    }\n  }, {\n    key: \"getSubLayerDimensionAttribute\",\n    value: function getSubLayerDimensionAttribute(key, nullValue) {\n      var _this4 = this;\n\n      return function (cell) {\n        var _this4$state$dimensio = _this4.state.dimensions[key],\n            sortedBins = _this4$state$dimensio.sortedBins,\n            scaleFunc = _this4$state$dimensio.scaleFunc;\n        var bin = sortedBins.binMap[cell.index];\n\n        if (bin && bin.counts === 0) {\n          return nullValue;\n        }\n\n        var cv = bin && bin.value;\n        var domain = scaleFunc.domain();\n        var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n        return isValueInDomain ? scaleFunc(cv) : nullValue;\n      };\n    }\n  }, {\n    key: \"getSubLayerAccessors\",\n    value: function getSubLayerAccessors(props) {\n      var accessors = {};\n\n      for (var key in this.dimensionUpdaters) {\n        var accessor = this.dimensionUpdaters[key].accessor;\n        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n      }\n\n      return accessors;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n\n      if (isPicked) {\n        var cell = this.state.layerData.data[info.index];\n        var binInfo = {};\n\n        for (var key in this.dimensionUpdaters) {\n          var pickingInfo = this.dimensionUpdaters[key].pickingInfo;\n          var sortedBins = this.state.dimensions[key].sortedBins;\n          var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n          binInfo[pickingInfo] = value;\n        }\n\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      }\n\n      info.picked = Boolean(object);\n      info.object = object;\n      return info;\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n\n      return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n\n  return CPUAggregator;\n}();\n\nexport { CPUAggregator as default };","map":{"version":3,"sources":["../../../src/utils/cpu-aggregator.js"],"names":["dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","constructor","layerData","dimensions","opts","changeFlags","reprojectNeeded","aggregationDirty","dimensionChanges","f","updateObject","result","data","aggregator","getValue","getValueChanged","wrapGetValueFunc","getValueFunc","dimension","sortedBins","scaleFunc","nop","updater","attributeAccessor","dimensionStep","item","oldProps","updaters","needUpdate","step","_updateTriggers","updateTriggers","Object","fromProp","Array","_filterData","valueDomain","dimensionRange","dimensionDomain","getScaleFunction","getScaleFunctionByScaleType","cell","bin","cv","isValueInDomain","accessors","info","isPicked","object","binInfo","points","Boolean"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}