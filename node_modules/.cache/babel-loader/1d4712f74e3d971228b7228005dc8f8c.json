{"ast":null,"code":"import { AXIS_PARTS, isAxisProperty, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getFirstDefined, isEmpty, keys, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, mergeValuesWithExplicit } from '../split';\nimport { AxisComponent, AXIS_COMPONENT_PROPERTIES } from './component';\nimport { getAxisConfig, getAxisConfigs } from './config';\nimport * as encode from './encode';\nimport { axisRules, defaultOrient, getFieldDefTitle, getLabelAngle } from './properties';\nexport function parseUnitAxes(model) {\n  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {\n    if (model.component.scales[channel]) {\n      axis[channel] = [parseAxis(channel, model)];\n    }\n\n    return axis;\n  }, {});\n}\nconst OPPOSITE_ORIENT = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'right',\n  right: 'left'\n};\nexport function parseLayerAxes(model) {\n  var _a;\n\n  const {\n    axes,\n    resolve\n  } = model.component;\n  const axisCount = {\n    top: 0,\n    bottom: 0,\n    right: 0,\n    left: 0\n  };\n\n  for (const child of model.children) {\n    child.parseAxesAndHeaders();\n\n    for (const channel of keys(child.component.axes)) {\n      resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.axis[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n\n        if (!axes[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n          // Thus, mark axis as independent and remove the axis component.\n          resolve.axis[channel] = 'independent';\n          delete axes[channel];\n        }\n      }\n    }\n  } // Move axes to layer's axis component and merge shared axes\n\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    for (const child of model.children) {\n      if (!child.component.axes[channel]) {\n        // skip if the child does not have a particular axis\n        continue;\n      }\n\n      if (resolve.axis[channel] === 'independent') {\n        // If axes are independent, concat the axisComponent array.\n        axes[channel] = ((_a = axes[channel]) !== null && _a !== void 0 ? _a : []).concat(child.component.axes[channel]); // Automatically adjust orient\n\n        for (const axisComponent of child.component.axes[channel]) {\n          const {\n            value: orient,\n            explicit\n          } = axisComponent.getWithExplicit('orient');\n\n          if (isSignalRef(orient)) {\n            continue;\n          }\n\n          if (axisCount[orient] > 0 && !explicit) {\n            // Change axis orient if the number do not match\n            const oppositeOrient = OPPOSITE_ORIENT[orient];\n\n            if (axisCount[orient] > axisCount[oppositeOrient]) {\n              axisComponent.set('orient', oppositeOrient, false);\n            }\n          }\n\n          axisCount[orient]++; // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n        }\n      } // After merging, make sure to remove axes from child\n\n\n      delete child.component.axes[channel];\n    } // Suppress grid lines for dual axis charts (https://github.com/vega/vega-lite/issues/4676)\n\n\n    if (resolve.axis[channel] === 'independent' && axes[channel] && axes[channel].length > 1) {\n      for (const axisCmpt of axes[channel]) {\n        if (!!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n          axisCmpt.implicit.grid = false;\n        }\n      }\n    }\n  }\n}\n\nfunction mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {\n  if (mergedAxisCmpts) {\n    // FIXME: this is a bit wrong once we support multiple axes\n    if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n      return undefined; // Cannot merge axis component with different number of axes.\n    }\n\n    const length = mergedAxisCmpts.length;\n\n    for (let i = 0; i < length; i++) {\n      const merged = mergedAxisCmpts[i];\n      const child = childAxisCmpts[i];\n\n      if (!!merged !== !!child) {\n        return undefined;\n      } else if (merged && child) {\n        const mergedOrient = merged.getWithExplicit('orient');\n        const childOrient = child.getWithExplicit('orient');\n\n        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n          // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n          // Cannot merge due to inconsistent orient\n          return undefined;\n        } else {\n          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n        }\n      }\n    }\n  } else {\n    // For first one, return a copy of the child\n    return childAxisCmpts.map(axisComponent => axisComponent.clone());\n  }\n\n  return mergedAxisCmpts;\n}\n\nfunction mergeAxisComponent(merged, child) {\n  for (const prop of AXIS_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, 'axis', // Tie breaker function\n    (v1, v2) => {\n      switch (prop) {\n        case 'title':\n          return mergeTitleComponent(v1, v2);\n\n        case 'gridScale':\n          return {\n            explicit: v1.explicit,\n            value: getFirstDefined(v1.value, v2.value)\n          };\n      }\n\n      return defaultTieBreaker(v1, v2, prop, 'axis');\n    });\n    merged.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n\n  return merged;\n}\n\nfunction isExplicit(value, property, axis, model, channel) {\n  if (property === 'disable') {\n    return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n  }\n\n  axis = axis || {};\n\n  switch (property) {\n    case 'titleAngle':\n    case 'labelAngle':\n      return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n\n    case 'values':\n      return !!axis.values;\n    // specified axis.values is already respected, but may get transformed.\n\n    case 'encode':\n      // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n      return !!axis.encoding || !!axis.labelAngle;\n\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (value === getFieldDefTitle(model, channel)) {\n        return true;\n      }\n\n  } // Otherwise, things are explicit if the returned value matches the specified property\n\n\n  return value === axis[property];\n}\n/**\n * Properties to always include values from config\n */\n\n\nconst propsToAlwaysIncludeConfig = new Set(['grid', 'translate', // the rest are not axis configs in Vega, but are in VL, so we need to set too.\n'format', 'formatType', 'orient', 'labelExpr', 'tickCount', 'position', 'tickMinStep']);\n\nfunction parseAxis(channel, model) {\n  var _a, _b, _c;\n\n  let axis = model.axis(channel);\n  const axisComponent = new AxisComponent();\n  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);\n  const {\n    mark,\n    config\n  } = model;\n  const orient = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a = config[channel === 'x' ? 'axisX' : 'axisY']) === null || _a === void 0 ? void 0 : _a.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n  const disable = axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;\n  axisComponent.set('disable', disable, axis !== undefined);\n\n  if (disable) {\n    return axisComponent;\n  }\n\n  axis = axis || {};\n  const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n  const ruleParams = {\n    fieldOrDatumDef,\n    axis,\n    channel,\n    model,\n    scaleType,\n    orient,\n    labelAngle,\n    mark,\n    config\n  }; // 1.2. Add properties\n\n  for (const property of AXIS_COMPONENT_PROPERTIES) {\n    const value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n    const hasValue = value !== undefined;\n    const explicit = isExplicit(value, property, axis, model, channel);\n\n    if (hasValue && explicit) {\n      axisComponent.set(property, value, explicit);\n    } else {\n      const {\n        configValue = undefined,\n        configFrom = undefined\n      } = isAxisProperty(property) && property !== 'values' ? getAxisConfig(property, config.style, axis.style, axisConfigs) : {};\n      const hasConfigValue = configValue !== undefined;\n\n      if (hasValue && !hasConfigValue) {\n        // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n        axisComponent.set(property, value, explicit);\n      } else if ( // Cases need implicit values\n      // 1. Axis config that aren't available in Vega\n      !(configFrom === 'vgAxisConfig') || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n      propsToAlwaysIncludeConfig.has(property) && hasConfigValue || // 3. Conditional axis values and signals\n      isConditionalAxisValue(configValue) || isSignalRef(configValue)) {\n        // If a config is specified and is conditional, copy conditional value from axis config\n        axisComponent.set(property, configValue, false);\n      }\n    }\n  } // 2) Add guide encode definition groups\n\n\n  const axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};\n  const axisEncode = AXIS_PARTS.reduce((e, part) => {\n    var _a;\n\n    if (!axisComponent.hasAxisPart(part)) {\n      // No need to create encode for a disabled part.\n      return e;\n    }\n\n    const axisEncodingPart = guideEncodeEntry((_a = axisEncoding[part]) !== null && _a !== void 0 ? _a : {}, model);\n    const value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n\n    if (value !== undefined && !isEmpty(value)) {\n      e[part] = {\n        update: value\n      };\n    }\n\n    return e;\n  }, {}); // FIXME: By having encode as one property, we won't have fine grained encode merging.\n\n  if (!isEmpty(axisEncode)) {\n    axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n  }\n\n  return axisComponent;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AXIS_PARTS, isAxisProperty, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getFirstDefined, isEmpty, keys, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, mergeValuesWithExplicit } from '../split';\nimport { AxisComponent, AXIS_COMPONENT_PROPERTIES } from './component';\nimport { getAxisConfig, getAxisConfigs } from './config';\nimport * as encode from './encode';\nimport { axisRules, defaultOrient, getFieldDefTitle, getLabelAngle } from './properties';\nexport function parseUnitAxes(model) {\n    return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {\n        if (model.component.scales[channel]) {\n            axis[channel] = [parseAxis(channel, model)];\n        }\n        return axis;\n    }, {});\n}\nconst OPPOSITE_ORIENT = {\n    bottom: 'top',\n    top: 'bottom',\n    left: 'right',\n    right: 'left'\n};\nexport function parseLayerAxes(model) {\n    var _a;\n    const { axes, resolve } = model.component;\n    const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };\n    for (const child of model.children) {\n        child.parseAxesAndHeaders();\n        for (const channel of keys(child.component.axes)) {\n            resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n            if (resolve.axis[channel] === 'shared') {\n                // If the resolve says shared (and has not been overridden)\n                // We will try to merge and see if there is a conflict\n                axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n                if (!axes[channel]) {\n                    // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n                    // Thus, mark axis as independent and remove the axis component.\n                    resolve.axis[channel] = 'independent';\n                    delete axes[channel];\n                }\n            }\n        }\n    }\n    // Move axes to layer's axis component and merge shared axes\n    for (const channel of POSITION_SCALE_CHANNELS) {\n        for (const child of model.children) {\n            if (!child.component.axes[channel]) {\n                // skip if the child does not have a particular axis\n                continue;\n            }\n            if (resolve.axis[channel] === 'independent') {\n                // If axes are independent, concat the axisComponent array.\n                axes[channel] = ((_a = axes[channel]) !== null && _a !== void 0 ? _a : []).concat(child.component.axes[channel]);\n                // Automatically adjust orient\n                for (const axisComponent of child.component.axes[channel]) {\n                    const { value: orient, explicit } = axisComponent.getWithExplicit('orient');\n                    if (isSignalRef(orient)) {\n                        continue;\n                    }\n                    if (axisCount[orient] > 0 && !explicit) {\n                        // Change axis orient if the number do not match\n                        const oppositeOrient = OPPOSITE_ORIENT[orient];\n                        if (axisCount[orient] > axisCount[oppositeOrient]) {\n                            axisComponent.set('orient', oppositeOrient, false);\n                        }\n                    }\n                    axisCount[orient]++;\n                    // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n                }\n            }\n            // After merging, make sure to remove axes from child\n            delete child.component.axes[channel];\n        }\n        // Suppress grid lines for dual axis charts (https://github.com/vega/vega-lite/issues/4676)\n        if (resolve.axis[channel] === 'independent' && axes[channel] && axes[channel].length > 1) {\n            for (const axisCmpt of axes[channel]) {\n                if (!!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n                    axisCmpt.implicit.grid = false;\n                }\n            }\n        }\n    }\n}\nfunction mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {\n    if (mergedAxisCmpts) {\n        // FIXME: this is a bit wrong once we support multiple axes\n        if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n            return undefined; // Cannot merge axis component with different number of axes.\n        }\n        const length = mergedAxisCmpts.length;\n        for (let i = 0; i < length; i++) {\n            const merged = mergedAxisCmpts[i];\n            const child = childAxisCmpts[i];\n            if (!!merged !== !!child) {\n                return undefined;\n            }\n            else if (merged && child) {\n                const mergedOrient = merged.getWithExplicit('orient');\n                const childOrient = child.getWithExplicit('orient');\n                if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n                    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n                    // Cannot merge due to inconsistent orient\n                    return undefined;\n                }\n                else {\n                    mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n                }\n            }\n        }\n    }\n    else {\n        // For first one, return a copy of the child\n        return childAxisCmpts.map(axisComponent => axisComponent.clone());\n    }\n    return mergedAxisCmpts;\n}\nfunction mergeAxisComponent(merged, child) {\n    for (const prop of AXIS_COMPONENT_PROPERTIES) {\n        const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, 'axis', \n        // Tie breaker function\n        (v1, v2) => {\n            switch (prop) {\n                case 'title':\n                    return mergeTitleComponent(v1, v2);\n                case 'gridScale':\n                    return {\n                        explicit: v1.explicit,\n                        value: getFirstDefined(v1.value, v2.value)\n                    };\n            }\n            return defaultTieBreaker(v1, v2, prop, 'axis');\n        });\n        merged.setWithExplicit(prop, mergedValueWithExplicit);\n    }\n    return merged;\n}\nfunction isExplicit(value, property, axis, model, channel) {\n    if (property === 'disable') {\n        return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n    }\n    axis = axis || {};\n    switch (property) {\n        case 'titleAngle':\n        case 'labelAngle':\n            return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n        case 'values':\n            return !!axis.values;\n        // specified axis.values is already respected, but may get transformed.\n        case 'encode':\n            // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n            return !!axis.encoding || !!axis.labelAngle;\n        case 'title':\n            // title can be explicit if fieldDef.title is set\n            if (value === getFieldDefTitle(model, channel)) {\n                return true;\n            }\n    }\n    // Otherwise, things are explicit if the returned value matches the specified property\n    return value === axis[property];\n}\n/**\n * Properties to always include values from config\n */\nconst propsToAlwaysIncludeConfig = new Set([\n    'grid',\n    'translate',\n    // the rest are not axis configs in Vega, but are in VL, so we need to set too.\n    'format',\n    'formatType',\n    'orient',\n    'labelExpr',\n    'tickCount',\n    'position',\n    'tickMinStep'\n]);\nfunction parseAxis(channel, model) {\n    var _a, _b, _c;\n    let axis = model.axis(channel);\n    const axisComponent = new AxisComponent();\n    const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);\n    const { mark, config } = model;\n    const orient = (axis === null || axis === void 0 ? void 0 : axis.orient) ||\n        ((_a = config[channel === 'x' ? 'axisX' : 'axisY']) === null || _a === void 0 ? void 0 : _a.orient) ||\n        ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) ||\n        defaultOrient(channel);\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n    const disable = axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;\n    axisComponent.set('disable', disable, axis !== undefined);\n    if (disable) {\n        return axisComponent;\n    }\n    axis = axis || {};\n    const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n    const ruleParams = {\n        fieldOrDatumDef,\n        axis,\n        channel,\n        model,\n        scaleType,\n        orient,\n        labelAngle,\n        mark,\n        config\n    };\n    // 1.2. Add properties\n    for (const property of AXIS_COMPONENT_PROPERTIES) {\n        const value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n        const hasValue = value !== undefined;\n        const explicit = isExplicit(value, property, axis, model, channel);\n        if (hasValue && explicit) {\n            axisComponent.set(property, value, explicit);\n        }\n        else {\n            const { configValue = undefined, configFrom = undefined } = isAxisProperty(property) && property !== 'values'\n                ? getAxisConfig(property, config.style, axis.style, axisConfigs)\n                : {};\n            const hasConfigValue = configValue !== undefined;\n            if (hasValue && !hasConfigValue) {\n                // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n                axisComponent.set(property, value, explicit);\n            }\n            else if (\n            // Cases need implicit values\n            // 1. Axis config that aren't available in Vega\n            !(configFrom === 'vgAxisConfig') ||\n                // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n                (propsToAlwaysIncludeConfig.has(property) && hasConfigValue) ||\n                // 3. Conditional axis values and signals\n                isConditionalAxisValue(configValue) ||\n                isSignalRef(configValue)) {\n                // If a config is specified and is conditional, copy conditional value from axis config\n                axisComponent.set(property, configValue, false);\n            }\n        }\n    }\n    // 2) Add guide encode definition groups\n    const axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};\n    const axisEncode = AXIS_PARTS.reduce((e, part) => {\n        var _a;\n        if (!axisComponent.hasAxisPart(part)) {\n            // No need to create encode for a disabled part.\n            return e;\n        }\n        const axisEncodingPart = guideEncodeEntry((_a = axisEncoding[part]) !== null && _a !== void 0 ? _a : {}, model);\n        const value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n        if (value !== undefined && !isEmpty(value)) {\n            e[part] = { update: value };\n        }\n        return e;\n    }, {});\n    // FIXME: By having encode as one property, we won't have fine grained encode merging.\n    if (!isEmpty(axisEncode)) {\n        axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n    }\n    return axisComponent;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}