{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport { addSkirt } from './helpers/skirt';\n\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n  var rScaler = elevationDecoder.rScaler,\n      bScaler = elevationDecoder.bScaler,\n      gScaler = elevationDecoder.gScaler,\n      offset = elevationDecoder.offset;\n  var terrain = new Float32Array((width + 1) * (height + 1));\n\n  for (var i = 0, y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++, i++) {\n      var k = i * 4;\n      var r = imageData[k + 0];\n      var g = imageData[k + 1];\n      var b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    for (var _i = (width + 1) * width, _x = 0; _x < width; _x++, _i++) {\n      terrain[_i] = terrain[_i - width - 1];\n    }\n\n    for (var _i2 = height, _y = 0; _y < height + 1; _y++, _i2 += height + 1) {\n      terrain[_i2] = terrain[_i2 - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n  var gridSize = width + 1;\n  var numOfVerticies = vertices.length / 2;\n  var positions = new Float32Array(numOfVerticies * 3);\n  var texCoords = new Float32Array(numOfVerticies * 2);\n\n  var _ref = bounds || [0, 0, width, height],\n      _ref2 = _slicedToArray(_ref, 4),\n      minX = _ref2[0],\n      minY = _ref2[1],\n      maxX = _ref2[2],\n      maxY = _ref2[3];\n\n  var xScale = (maxX - minX) / width;\n  var yScale = (maxY - minY) / height;\n\n  for (var i = 0; i < numOfVerticies; i++) {\n    var x = vertices[i * 2];\n    var y = vertices[i * 2 + 1];\n    var pixelIdx = y * gridSize + x;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\n\nfunction getMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n\n  var meshMaxError = terrainOptions.meshMaxError,\n      bounds = terrainOptions.bounds,\n      elevationDecoder = terrainOptions.elevationDecoder;\n  var data = terrainImage.data,\n      width = terrainImage.width,\n      height = terrainImage.height;\n  var terrain;\n  var mesh;\n\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n\n    default:\n      if (width === height && !(height & width - 1)) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n\n      break;\n  }\n\n  var _mesh = mesh,\n      vertices = _mesh.vertices;\n  var _mesh2 = mesh,\n      triangles = _mesh2.triangles;\n  var attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n  var boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    var _addSkirt = addSkirt(attributes, triangles, terrainOptions.skirtHeight),\n        newAttributes = _addSkirt.attributes,\n        newTriangles = _addSkirt.triangles;\n\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: boundingBox\n    },\n    mode: 4,\n    indices: {\n      value: Uint32Array.from(triangles),\n      size: 1\n    },\n    attributes: attributes\n  };\n}\n\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  var gridSize = width + 1;\n  var martini = new Martini(gridSize);\n  var tile = martini.createTile(terrain);\n\n  var _tile$getMesh = tile.getMesh(meshMaxError),\n      vertices = _tile$getMesh.vertices,\n      triangles = _tile$getMesh.triangles;\n\n  return {\n    vertices: vertices,\n    triangles: triangles\n  };\n}\n\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  var tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  var coords = tin.coords,\n      triangles = tin.triangles;\n  var vertices = coords;\n  return {\n    vertices: vertices,\n    triangles: triangles\n  };\n}\n\nexport default function loadTerrain(_x2, _x3, _x4) {\n  return _loadTerrain.apply(this, arguments);\n}\n\nfunction _loadTerrain() {\n  _loadTerrain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(arrayBuffer, options, context) {\n    var loadImageOptions, image;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            loadImageOptions = _objectSpread({}, options, {\n              mimeType: 'application/x.image',\n              image: _objectSpread({}, options.image, {\n                type: 'data'\n              })\n            });\n            _context.next = 3;\n            return context.parse(arrayBuffer, loadImageOptions);\n\n          case 3:\n            image = _context.sent;\n            return _context.abrupt(\"return\", getMesh(image, options.terrain));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadTerrain.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/lib/parse-terrain.ts"],"names":["offset","terrain","width","height","i","y","x","k","r","imageData","g","b","tesselator","gridSize","numOfVerticies","vertices","positions","texCoords","bounds","xScale","maxX","yScale","maxY","pixelIdx","POSITION","value","size","TEXCOORD_0","terrainImage","elevationDecoder","terrainOptions","getTerrain","mesh","getMartiniTileMesh","getDelatinTileMesh","triangles","attributes","getMeshAttributes","boundingBox","getMeshBoundingBox","newTriangles","addSkirt","loaderData","header","vertexCount","mode","indices","Uint32Array","martini","tile","tin","loadImageOptions","mimeType","image","options","type","context","getMesh"],"mappings":"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","sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport {addSkirt} from './helpers/skirt';\n\ntype TerrainOptions = {\n  meshMaxError: number;\n  bounds: number[];\n  elevationDecoder: ElevationDecoder;\n  tesselator: 'martini' | 'delatin';\n  skirtHeight?: number;\n};\n\ntype TerrainImage = {\n  data: Uint8Array;\n  width: number;\n  height: number;\n};\n\ntype ElevationDecoder = {\n  rScaler: any;\n  bScaler: any;\n  gScaler: any;\n  offset: number;\n};\n\nfunction getTerrain(\n  imageData: Uint8Array,\n  width: number,\n  height: number,\n  elevationDecoder: ElevationDecoder,\n  tesselator: 'martini' | 'delatin'\n) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array((width + 1) * (height + 1));\n  // decode terrain values\n  for (let i = 0, y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    // backfill bottom border\n    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n      terrain[i] = terrain[i - width - 1];\n    }\n    // backfill right border\n    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n      terrain[i] = terrain[i - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(\n  vertices,\n  terrain: Uint8Array,\n  width: number,\n  height: number,\n  bounds: number[]\n) {\n  const gridSize = width + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n  const xScale = (maxX - minX) / width;\n  const yScale = (maxY - minY) / height;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\n/**\n * Returns generated mesh object from image data\n *\n * @param {object} terrainImage terrain image data\n * @param {object} terrainOptions terrain options\n * @returns mesh object\n */\nfunction getMesh(terrainImage: TerrainImage, terrainOptions: TerrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const {data, width, height} = terrainImage;\n\n  let terrain;\n  let mesh;\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n    // auto\n    default:\n      if (width === height && !(height & (width - 1))) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n      break;\n  }\n\n  const {vertices} = mesh;\n  let {triangles} = mesh;\n  let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangles,\n      terrainOptions.skirtHeight\n    );\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: Uint32Array.from(triangles), size: 1},\n    attributes\n  };\n}\n\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  const gridSize = width + 1;\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  return {vertices, triangles};\n}\n\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  const tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  // @ts-expect-error\n  const {coords, triangles} = tin;\n  const vertices = coords;\n  return {vertices, triangles};\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  const loadImageOptions = {\n    ...options,\n    mimeType: 'application/x.image',\n    image: {...options.image, type: 'data'}\n  };\n  const image = await context.parse(arrayBuffer, loadImageOptions);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMesh(image, options.terrain);\n}\n"]},"metadata":{},"sourceType":"module"}