{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nvar KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport var name = KHR_TECHNIQUES_WEBGL;\nexport function decode(_x) {\n  return _decode.apply(this, arguments);\n}\n\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltfData) {\n    var gltfScenegraph, json, extension, techniques, _iterator, _step, material, materialExtension;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            gltfScenegraph = new GLTFScenegraph(gltfData);\n            json = gltfScenegraph.json;\n            extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n\n            if (extension) {\n              techniques = resolveTechniques(extension, gltfScenegraph);\n              _iterator = _createForOfIteratorHelper(json.materials || []);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  material = _step.value;\n                  materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n\n                  if (materialExtension) {\n                    material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);\n                    material.technique.values = resolveValues(material.technique, gltfScenegraph);\n                  }\n\n                  gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n            }\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\n\nexport function encode(_x2, _x3) {\n  return _encode.apply(this, arguments);\n}\n\nfunction _encode() {\n  _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(gltfData, options) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _encode.apply(this, arguments);\n}\n\nfunction resolveTechniques(techniquesExtension, gltfScenegraph) {\n  var _techniquesExtension$ = techniquesExtension.programs,\n      programs = _techniquesExtension$ === void 0 ? [] : _techniquesExtension$,\n      _techniquesExtension$2 = techniquesExtension.shaders,\n      shaders = _techniquesExtension$2 === void 0 ? [] : _techniquesExtension$2,\n      _techniquesExtension$3 = techniquesExtension.techniques,\n      techniques = _techniquesExtension$3 === void 0 ? [] : _techniquesExtension$3;\n  var textDecoder = new TextDecoder();\n  shaders.forEach(function (shader) {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(function (program) {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(function (technique) {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  var values = Object.assign({}, technique.values);\n  Object.keys(technique.uniforms || {}).forEach(function (uniform) {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  Object.keys(values).forEach(function (uniform) {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}","map":{"version":3,"sources":["../../../../../src/lib/extensions/deprecated/KHR_techniques_webgl.ts"],"names":["KHR_TECHNIQUES_WEBGL","name","gltfScenegraph","json","extension","techniques","resolveTechniques","materialExtension","material","Object","resolveValues","programs","shaders","textDecoder","shader","Number","program","technique","values","uniform"],"mappings":"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","sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n"]},"metadata":{},"sourceType":"module"}