{"ast":null,"code":"import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport class Split {\n  constructor(explicit = {}, implicit = {}) {\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n\n  clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  combine() {\n    return Object.assign(Object.assign({}, this.explicit), this.implicit);\n  }\n\n  get(key) {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  getWithExplicit(key) {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {\n        explicit: true,\n        value: this.explicit[key]\n      };\n    } else if (this.implicit[key] !== undefined) {\n      return {\n        explicit: false,\n        value: this.implicit[key]\n      };\n    }\n\n    return {\n      explicit: false,\n      value: undefined\n    };\n  }\n\n  setWithExplicit(key, {\n    value,\n    explicit\n  }) {\n    if (value !== undefined) {\n      this.set(key, value, explicit);\n    }\n  }\n\n  set(key, value, explicit) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  copyKeyFromSplit(key, {\n    explicit,\n    implicit\n  }) {\n    // Explicit has higher precedence\n    if (explicit[key] !== undefined) {\n      this.set(key, explicit[key], true);\n    } else if (implicit[key] !== undefined) {\n      this.set(key, implicit[key], false);\n    }\n  }\n\n  copyKeyFromObject(key, s) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n\n\n  copyAll(other) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n\n}\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return (v1, v2, property, propertyOf) => {\n    const diff = compare(v1.value, v2.value);\n\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, prefer v1.\n\n\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":{"version":3,"sources":["../../../src/compile/split.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,GAAZ,MAAqB,QAArB;AACA,SAAQ,SAAR,EAAmB,SAAnB,EAA8B,eAA9B,EAA+C,IAA/C,QAA0D,SAA1D;AAEA;;;;;;AAMA;;AACA,OAAM,MAAO,KAAP,CAAY;AAChB,EAAA,WAAA,CAA4B,QAAA,GAAuB,EAAnD,EAAuE,QAAA,GAAuB,EAA9F,EAAgG;AAApE,SAAA,QAAA,GAAA,QAAA;AAA2C,SAAA,QAAA,GAAA,QAAA;AAA6B;;AAE7F,EAAA,KAAK,GAAA;AACV,WAAO,IAAI,KAAJ,CAAU,SAAS,CAAC,KAAK,QAAN,CAAnB,EAAoC,SAAS,CAAC,KAAK,QAAN,CAA7C,CAAP;AACD;;AAEM,EAAA,OAAO,GAAA;AACZ,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,KAAK,QADV,CAAA,EAEK,KAAK,QAFV,CAAA;AAID;;AAEM,EAAA,GAAG,CAAoB,GAApB,EAA0B;AAClC;AACA,WAAO,eAAe,CAAC,KAAK,QAAL,CAAc,GAAd,CAAD,EAAqB,KAAK,QAAL,CAAc,GAAd,CAArB,CAAtB;AACD;;AAEM,EAAA,eAAe,CAAoB,GAApB,EAA0B;AAC9C;AACA,QAAI,KAAK,QAAL,CAAc,GAAd,MAAuB,SAA3B,EAAsC;AACpC,aAAO;AAAC,QAAA,QAAQ,EAAE,IAAX;AAAiB,QAAA,KAAK,EAAE,KAAK,QAAL,CAAc,GAAd;AAAxB,OAAP;AACD,KAFD,MAEO,IAAI,KAAK,QAAL,CAAc,GAAd,MAAuB,SAA3B,EAAsC;AAC3C,aAAO;AAAC,QAAA,QAAQ,EAAE,KAAX;AAAkB,QAAA,KAAK,EAAE,KAAK,QAAL,CAAc,GAAd;AAAzB,OAAP;AACD;;AACD,WAAO;AAAC,MAAA,QAAQ,EAAE,KAAX;AAAkB,MAAA,KAAK,EAAE;AAAzB,KAAP;AACD;;AAEM,EAAA,eAAe,CAAoB,GAApB,EAA4B;AAAC,IAAA,KAAD;AAAQ,IAAA;AAAR,GAA5B,EAA6D;AACjF,QAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,WAAK,GAAL,CAAS,GAAT,EAAc,KAAd,EAAqB,QAArB;AACD;AACF;;AAEM,EAAA,GAAG,CAAoB,GAApB,EAA4B,KAA5B,EAAyC,QAAzC,EAA0D;AAClE,WAAO,KAAK,QAAQ,GAAG,UAAH,GAAgB,UAA7B,EAAyC,GAAzC,CAAP;AACA,SAAK,QAAQ,GAAG,UAAH,GAAgB,UAA7B,EAAyC,GAAzC,IAAgD,KAAhD;AACA,WAAO,IAAP;AACD;;AAEM,EAAA,gBAAgB,CAAc,GAAd,EAA4B;AAAC,IAAA,QAAD;AAAW,IAAA;AAAX,GAA5B,EAA0D;AAC/E;AACA,QAAI,QAAQ,CAAC,GAAD,CAAR,KAAkB,SAAtB,EAAiC;AAC/B,WAAK,GAAL,CAAS,GAAT,EAAc,QAAQ,CAAC,GAAD,CAAtB,EAA6B,IAA7B;AACD,KAFD,MAEO,IAAI,QAAQ,CAAC,GAAD,CAAR,KAAkB,SAAtB,EAAiC;AACtC,WAAK,GAAL,CAAS,GAAT,EAAc,QAAQ,CAAC,GAAD,CAAtB,EAA6B,KAA7B;AACD;AACF;;AACM,EAAA,iBAAiB,CAAc,GAAd,EAA4B,CAA5B,EAAyC;AAC/D;AACA,QAAI,CAAC,CAAC,GAAD,CAAD,KAAW,SAAf,EAA0B;AACxB,WAAK,GAAL,CAAS,GAAT,EAAc,CAAC,CAAC,GAAD,CAAf,EAAsB,IAAtB;AACD;AACF;AAED;;;;;;AAIO,EAAA,OAAO,CAAC,KAAD,EAAgB;AAC5B,SAAK,MAAM,GAAX,IAAkB,IAAI,CAAC,KAAK,CAAC,OAAN,EAAD,CAAtB,EAAyC;AACvC,YAAM,GAAG,GAAG,KAAK,CAAC,eAAN,CAAsB,GAAtB,CAAZ;AACA,WAAK,eAAL,CAAqB,GAArB,EAA0B,GAA1B;AACD;AACF;;AAjEe;AAyElB,OAAM,SAAU,YAAV,CAA0B,KAA1B,EAAkC;AACtC,SAAO;AACL,IAAA,QAAQ,EAAE,IADL;AAEL,IAAA;AAFK,GAAP;AAID;AAED,OAAM,SAAU,YAAV,CAA0B,KAA1B,EAAkC;AACtC,SAAO;AACL,IAAA,QAAQ,EAAE,KADL;AAEL,IAAA;AAFK,GAAP;AAID;AAID,OAAM,SAAU,mBAAV,CAAoC,OAApC,EAAqE;AACzE,SAAO,CACL,EADK,EAEL,EAFK,EAGL,QAHK,EAIL,UAJK,KAKU;AACf,UAAM,IAAI,GAAG,OAAO,CAAC,EAAE,CAAC,KAAJ,EAAW,EAAE,CAAC,KAAd,CAApB;;AACA,QAAI,IAAI,GAAG,CAAX,EAAc;AACZ,aAAO,EAAP;AACD,KAFD,MAEO,IAAI,IAAI,GAAG,CAAX,EAAc;AACnB,aAAO,EAAP;AACD;;AACD,WAAO,iBAAiB,CAAO,EAAP,EAAW,EAAX,EAAe,QAAf,EAAyB,UAAzB,CAAxB;AACD,GAbD;AAcD;AAED,OAAM,SAAU,iBAAV,CACJ,EADI,EAEJ,EAFI,EAGJ,QAHI,EAIJ,UAJI,EAI2B;AAE/B,MAAI,EAAE,CAAC,QAAH,IAAe,EAAE,CAAC,QAAtB,EAAgC;AAC9B,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,wBAAZ,CAAqC,QAArC,EAA+C,UAA/C,EAA2D,EAAE,CAAC,KAA9D,EAAqE,EAAE,CAAC,KAAxE,CAAT;AACD,GAJ8B,CAK/B;;;AACA,SAAO,EAAP;AACD;AAED,OAAM,SAAU,uBAAV,CACJ,EADI,EAEJ,EAFI,EAGJ,QAHI,EAIJ,UAJI,EAKJ,UAAA,GAKmB,iBAVf,EAUgC;AAEpC,MAAI,EAAE,KAAK,SAAP,IAAoB,EAAE,CAAC,KAAH,KAAa,SAArC,EAAgD;AAC9C;AACA,WAAO,EAAP;AACD;;AAED,MAAI,EAAE,CAAC,QAAH,IAAe,CAAC,EAAE,CAAC,QAAvB,EAAiC;AAC/B,WAAO,EAAP;AACD,GAFD,MAEO,IAAI,EAAE,CAAC,QAAH,IAAe,CAAC,EAAE,CAAC,QAAvB,EAAiC;AACtC,WAAO,EAAP;AACD,GAFM,MAEA,IAAI,SAAS,CAAC,EAAE,CAAC,KAAJ,EAAW,EAAE,CAAC,KAAd,CAAb,EAAmC;AACxC,WAAO,EAAP;AACD,GAFM,MAEA;AACL,WAAO,UAAU,CAAC,EAAD,EAAK,EAAL,EAAS,QAAT,EAAmB,UAAnB,CAAjB;AACD;AACF","sourceRoot":"","sourcesContent":["import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split {\n    constructor(explicit = {}, implicit = {}) {\n        this.explicit = explicit;\n        this.implicit = implicit;\n    }\n    clone() {\n        return new Split(duplicate(this.explicit), duplicate(this.implicit));\n    }\n    combine() {\n        return Object.assign(Object.assign({}, this.explicit), this.implicit);\n    }\n    get(key) {\n        // Explicit has higher precedence\n        return getFirstDefined(this.explicit[key], this.implicit[key]);\n    }\n    getWithExplicit(key) {\n        // Explicit has higher precedence\n        if (this.explicit[key] !== undefined) {\n            return { explicit: true, value: this.explicit[key] };\n        }\n        else if (this.implicit[key] !== undefined) {\n            return { explicit: false, value: this.implicit[key] };\n        }\n        return { explicit: false, value: undefined };\n    }\n    setWithExplicit(key, { value, explicit }) {\n        if (value !== undefined) {\n            this.set(key, value, explicit);\n        }\n    }\n    set(key, value, explicit) {\n        delete this[explicit ? 'implicit' : 'explicit'][key];\n        this[explicit ? 'explicit' : 'implicit'][key] = value;\n        return this;\n    }\n    copyKeyFromSplit(key, { explicit, implicit }) {\n        // Explicit has higher precedence\n        if (explicit[key] !== undefined) {\n            this.set(key, explicit[key], true);\n        }\n        else if (implicit[key] !== undefined) {\n            this.set(key, implicit[key], false);\n        }\n    }\n    copyKeyFromObject(key, s) {\n        // Explicit has higher precedence\n        if (s[key] !== undefined) {\n            this.set(key, s[key], true);\n        }\n    }\n    /**\n     * Merge split object into this split object. Properties from the other split\n     * overwrite properties from this split.\n     */\n    copyAll(other) {\n        for (const key of keys(other.combine())) {\n            const val = other.getWithExplicit(key);\n            this.setWithExplicit(key, val);\n        }\n    }\n}\nexport function makeExplicit(value) {\n    return {\n        explicit: true,\n        value\n    };\n}\nexport function makeImplicit(value) {\n    return {\n        explicit: false,\n        value\n    };\n}\nexport function tieBreakByComparing(compare) {\n    return (v1, v2, property, propertyOf) => {\n        const diff = compare(v1.value, v2.value);\n        if (diff > 0) {\n            return v1;\n        }\n        else if (diff < 0) {\n            return v2;\n        }\n        return defaultTieBreaker(v1, v2, property, propertyOf);\n    };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n    if (v1.explicit && v2.explicit) {\n        log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n    }\n    // If equal score, prefer v1.\n    return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {\n    if (v1 === undefined || v1.value === undefined) {\n        // For first run\n        return v2;\n    }\n    if (v1.explicit && !v2.explicit) {\n        return v1;\n    }\n    else if (v2.explicit && !v1.explicit) {\n        return v2;\n    }\n    else if (deepEqual(v1.value, v2.value)) {\n        return v1;\n    }\n    else {\n        return tieBreaker(v1, v2, property, propertyOf);\n    }\n}\n//# sourceMappingURL=split.js.map"]},"metadata":{},"sourceType":"module"}