{"ast":null,"code":"import { ZarrPixelSource, loadOmeTiff } from '@hms-dbmi/viv';\nimport { openArray } from 'zarr';\nimport rasterSchema from '../schemas/raster.schema.json';\nimport JsonLoader from './JsonLoader';\nimport { AbstractLoaderError } from './errors';\nimport LoaderResult from './LoaderResult';\nimport { initializeRasterLayersAndChannels } from '../components/spatial/utils';\n\nasync function initLoader(imageData) {\n  const {\n    type,\n    url,\n    metadata,\n    requestInit\n  } = imageData;\n\n  switch (type) {\n    case 'zarr':\n      {\n        const {\n          dimensions,\n          isPyramid,\n          transform\n        } = metadata || {};\n        const labels = dimensions.map(d => d.field);\n        let source;\n\n        if (isPyramid) {\n          const metadataUrl = `${url}${url.slice(-1) === '/' ? '' : '/'}.zmetadata`;\n          const response = await fetch(metadataUrl);\n          const {\n            metadata: zarrMetadata\n          } = await response.json();\n          const paths = Object.keys(zarrMetadata).filter(metaKey => metaKey.includes('.zarray')).map(arrMetaKeys => arrMetaKeys.slice(0, -7));\n          const data = await Promise.all(paths.map(path => openArray({\n            store: url,\n            path\n          })));\n          const [yChunk, xChunk] = data[0].chunks.slice(-2);\n          const size = Math.min(yChunk, xChunk); // deck.gl requirement for power-of-two tile size.\n\n          const tileSize = 2 ** Math.floor(Math.log2(size));\n          source = data.map(d => new ZarrPixelSource(d, labels, tileSize));\n        } else {\n          const data = await openArray({\n            store: url\n          });\n          source = new ZarrPixelSource(data, labels);\n        }\n\n        return {\n          data: source,\n          metadata: {\n            dimensions,\n            transform\n          },\n          channels: (dimensions.find(d => d.field === 'channel') || dimensions[0]).values\n        };\n      }\n\n    case 'ome-tiff':\n      {\n        let loader; // Fetch offsets for ome-tiff if needed.\n\n        if (metadata && 'omeTiffOffsetsUrl' in metadata) {\n          const {\n            omeTiffOffsetsUrl\n          } = metadata;\n          const res = await fetch(omeTiffOffsetsUrl, requestInit || {});\n\n          if (res.ok) {\n            const offsets = await res.json();\n            loader = await loadOmeTiff(url, {\n              offsets,\n              headers: requestInit === null || requestInit === void 0 ? void 0 : requestInit.headers\n            });\n          } else {\n            throw new Error(`Offsets not found but provided: ${res.status} from ${res.url}`);\n          }\n        } else {\n          loader = await loadOmeTiff(url, {\n            headers: requestInit === null || requestInit === void 0 ? void 0 : requestInit.headers\n          });\n        }\n\n        const {\n          Pixels: {\n            Channels\n          }\n        } = loader.metadata;\n        const channels = Array.isArray(Channels) ? Channels.map((channel, i) => channel.Name || `Channel ${i}`) : [Channels.Name || `Channel ${0}`];\n        return { ...loader,\n          channels\n        };\n      }\n\n    default:\n      {\n        throw Error(`Image type (${type}) is not supported`);\n      }\n  }\n}\n\nexport default class RasterLoader extends JsonLoader {\n  constructor(dataSource, params) {\n    const {\n      url,\n      options\n    } = params;\n\n    if (!url && options) {\n      // eslint-disable-next-line no-param-reassign\n      dataSource.url = URL.createObjectURL(new Blob([JSON.stringify(options)]));\n    }\n\n    super(dataSource, params);\n    this.schema = rasterSchema;\n  }\n\n  async load() {\n    const payload = await super.load().catch(reason => Promise.resolve(reason));\n\n    if (payload instanceof AbstractLoaderError) {\n      return Promise.reject(payload);\n    }\n\n    const {\n      data: raster\n    } = payload;\n    const {\n      images,\n      renderLayers,\n      usePhysicalSizeScaling = false\n    } = raster; // Get image name and URL tuples.\n\n    const urls = images.filter(image => !image.url.includes('zarr')).map(image => [image.url, image.name]); // Add a loaderCreator function for each image layer.\n\n    const imagesWithLoaderCreators = images.map(image => ({ ...image,\n      loaderCreator: async () => initLoader(image)\n    })); // TODO: use options for initial selection of channels\n    // which omit domain/slider ranges.\n\n    if (!this.autoImageCache) {\n      this.autoImageCache = initializeRasterLayersAndChannels(imagesWithLoaderCreators, renderLayers, usePhysicalSizeScaling);\n    }\n\n    return this.autoImageCache.then(autoImages => {\n      const [autoImageLayers, imageLayerLoaders, imageLayerMeta] = autoImages;\n      const coordinationValues = {\n        spatialImageLayer: autoImageLayers\n      };\n      return new LoaderResult({\n        loaders: imageLayerLoaders,\n        meta: imageLayerMeta\n      }, urls, coordinationValues);\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/RasterJsonLoader.js"],"names":["ZarrPixelSource","loadOmeTiff","openArray","rasterSchema","JsonLoader","AbstractLoaderError","LoaderResult","initializeRasterLayersAndChannels","initLoader","imageData","type","url","metadata","requestInit","dimensions","isPyramid","transform","labels","map","d","field","source","metadataUrl","slice","response","fetch","zarrMetadata","json","paths","Object","keys","filter","metaKey","includes","arrMetaKeys","data","Promise","all","path","store","yChunk","xChunk","chunks","size","Math","min","tileSize","floor","log2","channels","find","values","loader","omeTiffOffsetsUrl","res","ok","offsets","headers","Error","status","Pixels","Channels","Array","isArray","channel","i","Name","RasterLoader","constructor","dataSource","params","options","URL","createObjectURL","Blob","JSON","stringify","schema","load","payload","catch","reason","resolve","reject","raster","images","renderLayers","usePhysicalSizeScaling","urls","image","name","imagesWithLoaderCreators","loaderCreator","autoImageCache","then","autoImages","autoImageLayers","imageLayerLoaders","imageLayerMeta","coordinationValues","spatialImageLayer","loaders","meta"],"mappings":"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","sourcesContent":["import { ZarrPixelSource, loadOmeTiff } from '@hms-dbmi/viv';\nimport { openArray } from 'zarr';\nimport rasterSchema from '../schemas/raster.schema.json';\nimport JsonLoader from './JsonLoader';\nimport { AbstractLoaderError } from './errors';\nimport LoaderResult from './LoaderResult';\n\nimport { initializeRasterLayersAndChannels } from '../components/spatial/utils';\n\nasync function initLoader(imageData) {\n  const {\n    type, url, metadata, requestInit,\n  } = imageData;\n  switch (type) {\n    case ('zarr'): {\n      const {\n        dimensions, isPyramid, transform,\n      } = metadata || {};\n      const labels = dimensions.map(d => d.field);\n      let source;\n      if (isPyramid) {\n        const metadataUrl = `${url}${\n          url.slice(-1) === '/' ? '' : '/'\n        }.zmetadata`;\n        const response = await fetch(metadataUrl);\n        const { metadata: zarrMetadata } = await response.json();\n        const paths = Object.keys(zarrMetadata)\n          .filter(metaKey => metaKey.includes('.zarray'))\n          .map(arrMetaKeys => arrMetaKeys.slice(0, -7));\n        const data = await Promise.all(\n          paths.map(path => openArray({ store: url, path })),\n        );\n        const [yChunk, xChunk] = data[0].chunks.slice(-2);\n        const size = Math.min(yChunk, xChunk);\n        // deck.gl requirement for power-of-two tile size.\n        const tileSize = 2 ** Math.floor(Math.log2(size));\n        source = data.map(d => new ZarrPixelSource(d, labels, tileSize));\n      } else {\n        const data = await openArray({ store: url });\n        source = new ZarrPixelSource(data, labels);\n      }\n      return { data: source, metadata: { dimensions, transform }, channels: (dimensions.find(d => d.field === 'channel') || dimensions[0]).values };\n    }\n    case ('ome-tiff'): {\n      let loader;\n      // Fetch offsets for ome-tiff if needed.\n      if (metadata && 'omeTiffOffsetsUrl' in metadata) {\n        const { omeTiffOffsetsUrl } = metadata;\n        const res = await fetch(omeTiffOffsetsUrl, (requestInit || {}));\n        if (res.ok) {\n          const offsets = await res.json();\n          loader = await loadOmeTiff(\n            url,\n            {\n              offsets,\n              headers: requestInit?.headers,\n            },\n          );\n        } else {\n          throw new Error(`Offsets not found but provided: ${res.status} from ${res.url}`);\n        }\n      } else {\n        loader = await loadOmeTiff(url, { headers: requestInit?.headers });\n      }\n      const { Pixels: { Channels } } = loader.metadata;\n      const channels = Array.isArray(Channels)\n        ? Channels.map((channel, i) => channel.Name || `Channel ${i}`)\n        : [Channels.Name || `Channel ${0}`];\n      return { ...loader, channels };\n    }\n    default: {\n      throw Error(`Image type (${type}) is not supported`);\n    }\n  }\n}\n\nexport default class RasterLoader extends JsonLoader {\n  constructor(dataSource, params) {\n    const { url, options } = params;\n    if (!url && options) {\n      // eslint-disable-next-line no-param-reassign\n      dataSource.url = URL.createObjectURL(new Blob([JSON.stringify(options)]));\n    }\n    super(dataSource, params);\n    this.schema = rasterSchema;\n  }\n\n  async load() {\n    const payload = await super.load().catch(reason => Promise.resolve(reason));\n    if (payload instanceof AbstractLoaderError) {\n      return Promise.reject(payload);\n    }\n    const { data: raster } = payload;\n    const { images, renderLayers, usePhysicalSizeScaling = false } = raster;\n\n    // Get image name and URL tuples.\n    const urls = images\n      .filter(image => !image.url.includes('zarr'))\n      .map(image => ([image.url, image.name]));\n\n    // Add a loaderCreator function for each image layer.\n    const imagesWithLoaderCreators = images.map(image => ({\n      ...image,\n      loaderCreator: async () => initLoader(image),\n    }));\n\n    // TODO: use options for initial selection of channels\n    // which omit domain/slider ranges.\n    if (!this.autoImageCache) {\n      this.autoImageCache = initializeRasterLayersAndChannels(\n        imagesWithLoaderCreators,\n        renderLayers,\n        usePhysicalSizeScaling,\n      );\n    }\n\n    return this.autoImageCache.then((autoImages) => {\n      const [autoImageLayers, imageLayerLoaders, imageLayerMeta] = autoImages;\n\n      const coordinationValues = {\n        spatialImageLayer: autoImageLayers,\n      };\n      return new LoaderResult(\n        { loaders: imageLayerLoaders, meta: imageLayerMeta },\n        urls,\n        coordinationValues,\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}