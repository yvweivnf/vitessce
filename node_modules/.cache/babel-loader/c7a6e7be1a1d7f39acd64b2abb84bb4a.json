{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray } from 'vega';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport var SelectionCompatibilityNormalizer = /*#__PURE__*/function (_SpecMapper) {\n  _inherits(SelectionCompatibilityNormalizer, _SpecMapper);\n\n  var _super = _createSuper(SelectionCompatibilityNormalizer);\n\n  function SelectionCompatibilityNormalizer() {\n    _classCallCheck(this, SelectionCompatibilityNormalizer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SelectionCompatibilityNormalizer, [{\n    key: \"map\",\n    value: function map(spec, normParams) {\n      var _a, _b;\n\n      (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : normParams.emptySelections = {};\n      (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : normParams.selectionPredicates = {};\n      spec = normalizeTransforms(spec, normParams);\n      return _get(_getPrototypeOf(SelectionCompatibilityNormalizer.prototype), \"map\", this).call(this, spec, normParams);\n    }\n  }, {\n    key: \"mapLayerOrUnit\",\n    value: function mapLayerOrUnit(spec, normParams) {\n      spec = normalizeTransforms(spec, normParams);\n\n      if (spec.encoding) {\n        var encoding = {};\n\n        var _iterator = _createForOfIteratorHelper(entries(spec.encoding)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                channel = _step$value[0],\n                enc = _step$value[1];\n\n            encoding[channel] = normalizeChannelDef(enc, normParams);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        spec = Object.assign(Object.assign({}, spec), {\n          encoding: encoding\n        });\n      }\n\n      return _get(_getPrototypeOf(SelectionCompatibilityNormalizer.prototype), \"mapLayerOrUnit\", this).call(this, spec, normParams);\n    }\n  }, {\n    key: \"mapUnit\",\n    value: function mapUnit(spec, normParams) {\n      var _a = spec,\n          selection = _a.selection,\n          rest = __rest(_a, [\"selection\"]);\n\n      if (selection) {\n        return Object.assign(Object.assign({}, rest), {\n          params: entries(selection).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                name = _ref2[0],\n                selDef = _ref2[1];\n\n            var _a;\n\n            var _b = selDef,\n                value = _b.init,\n                bind = _b.bind,\n                empty = _b.empty,\n                select = __rest(_b, [\"init\", \"bind\", \"empty\"]);\n\n            if (select.type === 'single') {\n              select.type = 'point';\n              select.toggle = false;\n            } else if (select.type === 'multi') {\n              select.type = 'point';\n            } // Propagate emptiness forwards and backwards\n\n\n            normParams.emptySelections[name] = empty !== 'none';\n\n            var _iterator2 = _createForOfIteratorHelper(vals((_a = normParams.selectionPredicates[name]) !== null && _a !== void 0 ? _a : {})),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var pred = _step2.value;\n                pred.empty = empty !== 'none';\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            return {\n              name: name,\n              value: value,\n              select: select,\n              bind: bind\n            };\n          })\n        });\n      }\n\n      return spec;\n    }\n  }]);\n\n  return SelectionCompatibilityNormalizer;\n}(SpecMapper);\n\nfunction normalizeTransforms(spec, normParams) {\n  var tx = spec.transform,\n      rest = __rest(spec, [\"transform\"]);\n\n  if (tx) {\n    var transform = tx.map(function (t) {\n      if (isFilter(t)) {\n        return {\n          filter: normalizePredicate(t, normParams)\n        };\n      } else if (isBin(t) && isBinParams(t.bin)) {\n        return Object.assign(Object.assign({}, t), {\n          bin: normalizeBinExtent(t.bin)\n        });\n      } else if (isLookup(t)) {\n        var _a = t.from,\n            param = _a.selection,\n            from = __rest(_a, [\"selection\"]);\n\n        return param ? Object.assign(Object.assign({}, t), {\n          from: Object.assign({\n            param: param\n          }, from)\n        }) : t;\n      }\n\n      return t;\n    });\n    return Object.assign(Object.assign({}, rest), {\n      transform: transform\n    });\n  }\n\n  return spec;\n}\n\nfunction normalizeChannelDef(obj, normParams) {\n  var _a, _b;\n\n  var enc = duplicate(obj);\n\n  if (isFieldDef(enc) && isBinParams(enc.bin)) {\n    enc.bin = normalizeBinExtent(enc.bin);\n  }\n\n  if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {\n    var _c = enc.scale.domain,\n        param = _c.selection,\n        domain = __rest(_c, [\"selection\"]);\n\n    enc.scale.domain = Object.assign(Object.assign({}, domain), param ? {\n      param: param\n    } : {});\n  }\n\n  if (isConditionalDef(enc)) {\n    if (isArray(enc.condition)) {\n      enc.condition = enc.condition.map(function (c) {\n        var selection = c.selection,\n            param = c.param,\n            test = c.test,\n            cond = __rest(c, [\"selection\", \"param\", \"test\"]);\n\n        return param ? c : Object.assign(Object.assign({}, cond), {\n          test: normalizePredicate(c, normParams)\n        });\n      });\n    } else {\n      var _d = normalizeChannelDef(enc.condition, normParams),\n          selection = _d.selection,\n          _param = _d.param,\n          test = _d.test,\n          cond = __rest(_d, [\"selection\", \"param\", \"test\"]);\n\n      enc.condition = _param ? enc.condition : Object.assign(Object.assign({}, cond), {\n        test: normalizePredicate(enc.condition, normParams)\n      });\n    }\n  }\n\n  return enc;\n}\n\nfunction normalizeBinExtent(bin) {\n  var ext = bin.extent;\n\n  if (ext === null || ext === void 0 ? void 0 : ext.selection) {\n    var param = ext.selection,\n        rest = __rest(ext, [\"selection\"]);\n\n    return Object.assign(Object.assign({}, bin), {\n      extent: Object.assign(Object.assign({}, rest), {\n        param: param\n      })\n    });\n  }\n\n  return bin;\n}\n\nfunction normalizePredicate(op, normParams) {\n  // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n  var normalizeSelectionComposition = function normalizeSelectionComposition(o) {\n    return normalizeLogicalComposition(o, function (param) {\n      var _a, _b;\n\n      var _c;\n\n      var empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;\n      var pred = {\n        param: param,\n        empty: empty\n      };\n      (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : _c[param] = [];\n      normParams.selectionPredicates[param].push(pred);\n      return pred;\n    });\n  };\n\n  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, function (o) {\n    return o.selection ? normalizeSelectionComposition(o.selection) : o;\n  });\n}","map":{"version":3,"sources":["../../../src/normalize/selectioncompat.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray } from 'vega';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport class SelectionCompatibilityNormalizer extends SpecMapper {\n    map(spec, normParams) {\n        var _a, _b;\n        (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : (normParams.emptySelections = {});\n        (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : (normParams.selectionPredicates = {});\n        spec = normalizeTransforms(spec, normParams);\n        return super.map(spec, normParams);\n    }\n    mapLayerOrUnit(spec, normParams) {\n        spec = normalizeTransforms(spec, normParams);\n        if (spec.encoding) {\n            const encoding = {};\n            for (const [channel, enc] of entries(spec.encoding)) {\n                encoding[channel] = normalizeChannelDef(enc, normParams);\n            }\n            spec = Object.assign(Object.assign({}, spec), { encoding });\n        }\n        return super.mapLayerOrUnit(spec, normParams);\n    }\n    mapUnit(spec, normParams) {\n        const _a = spec, { selection } = _a, rest = __rest(_a, [\"selection\"]);\n        if (selection) {\n            return Object.assign(Object.assign({}, rest), { params: entries(selection).map(([name, selDef]) => {\n                    var _a;\n                    const _b = selDef, { init: value, bind, empty } = _b, select = __rest(_b, [\"init\", \"bind\", \"empty\"]);\n                    if (select.type === 'single') {\n                        select.type = 'point';\n                        select.toggle = false;\n                    }\n                    else if (select.type === 'multi') {\n                        select.type = 'point';\n                    }\n                    // Propagate emptiness forwards and backwards\n                    normParams.emptySelections[name] = empty !== 'none';\n                    for (const pred of vals((_a = normParams.selectionPredicates[name]) !== null && _a !== void 0 ? _a : {})) {\n                        pred.empty = empty !== 'none';\n                    }\n                    return { name, value, select, bind };\n                }) });\n        }\n        return spec;\n    }\n}\nfunction normalizeTransforms(spec, normParams) {\n    const { transform: tx } = spec, rest = __rest(spec, [\"transform\"]);\n    if (tx) {\n        const transform = tx.map((t) => {\n            if (isFilter(t)) {\n                return { filter: normalizePredicate(t, normParams) };\n            }\n            else if (isBin(t) && isBinParams(t.bin)) {\n                return Object.assign(Object.assign({}, t), { bin: normalizeBinExtent(t.bin) });\n            }\n            else if (isLookup(t)) {\n                const _a = t.from, { selection: param } = _a, from = __rest(_a, [\"selection\"]);\n                return param\n                    ? Object.assign(Object.assign({}, t), { from: Object.assign({ param }, from) }) : t;\n            }\n            return t;\n        });\n        return Object.assign(Object.assign({}, rest), { transform });\n    }\n    return spec;\n}\nfunction normalizeChannelDef(obj, normParams) {\n    var _a, _b;\n    const enc = duplicate(obj);\n    if (isFieldDef(enc) && isBinParams(enc.bin)) {\n        enc.bin = normalizeBinExtent(enc.bin);\n    }\n    if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {\n        const _c = enc.scale.domain, { selection: param } = _c, domain = __rest(_c, [\"selection\"]);\n        enc.scale.domain = Object.assign(Object.assign({}, domain), (param ? { param } : {}));\n    }\n    if (isConditionalDef(enc)) {\n        if (isArray(enc.condition)) {\n            enc.condition = enc.condition.map((c) => {\n                const { selection, param, test } = c, cond = __rest(c, [\"selection\", \"param\", \"test\"]);\n                return param ? c : Object.assign(Object.assign({}, cond), { test: normalizePredicate(c, normParams) });\n            });\n        }\n        else {\n            const _d = normalizeChannelDef(enc.condition, normParams), { selection, param, test } = _d, cond = __rest(_d, [\"selection\", \"param\", \"test\"]);\n            enc.condition = param\n                ? enc.condition\n                : Object.assign(Object.assign({}, cond), { test: normalizePredicate(enc.condition, normParams) });\n        }\n    }\n    return enc;\n}\nfunction normalizeBinExtent(bin) {\n    const ext = bin.extent;\n    if (ext === null || ext === void 0 ? void 0 : ext.selection) {\n        const { selection: param } = ext, rest = __rest(ext, [\"selection\"]);\n        return Object.assign(Object.assign({}, bin), { extent: Object.assign(Object.assign({}, rest), { param }) });\n    }\n    return bin;\n}\nfunction normalizePredicate(op, normParams) {\n    // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n    const normalizeSelectionComposition = (o) => {\n        return normalizeLogicalComposition(o, param => {\n            var _a, _b;\n            var _c;\n            const empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;\n            const pred = { param, empty };\n            (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : (_c[param] = []);\n            normParams.selectionPredicates[param].push(pred);\n            return pred;\n        });\n    };\n    return op.selection\n        ? normalizeSelectionComposition(op.selection)\n        : normalizeLogicalComposition(op.test || op.filter, o => o.selection ? normalizeSelectionComposition(o.selection) : o);\n}\n//# sourceMappingURL=selectioncompat.js.map"]},"metadata":{},"sourceType":"module"}