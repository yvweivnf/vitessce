{"ast":null,"code":"import _defineProperty from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";/* eslint-disable no-plusplus */ // Adapted from https://github.com/feross/fromentries/blob/29b52a850bb3a47c390937631c2638edf3443942/index.js\nexport function fromEntries(iterable){return _toConsumableArray(iterable).reduce(function(obj,_ref){var key=_ref[0],val=_ref[1];return Object.assign(obj,_defineProperty({},key,val));},{});}/**\n * Select between a singular and plural version of a word,\n * based on an item count.\n * @param {string} singular The singular version of the word.\n * @param {string} plural The plural version of the word.\n * @param {number} count The number of items.\n * @returns {string} Singular if count is one, else plural.\n */export function pluralize(singular,plural,count){return count===1?singular:plural;}/**\n * Capitalize a the first letter of a string.\n * @param {string} word A string to capitalize.\n * @returns {string} The word parameter with the first letter capitalized.\n */export function capitalize(word){return word.charAt(0).toUpperCase()+word.slice(1);}/**\n * Get the longest string in the array of strings.\n * @param {string[]} strings The array of strings.\n * @returns The longest string.\n */export function getLongestString(strings){return strings.reduce(function(prevLongest,currentValue){return prevLongest.length>currentValue.length?prevLongest:currentValue;});}/**\n * Generate a new scope name which does not\n * conflict / overlap with a previous scope name.\n * Really these just need to be unique within the coordination object.\n * So in theory they could be String(Math.random()) or uuidv4() or something.\n * However it may be good to make them more human-readable and memorable\n * since eventually we will want to expose a UI to update the coordination.\n * @param {string[]} prevScopes Previous scope names.\n * @returns {string} The new scope name.\n */export function getNextScope(prevScopes){// Keep an ordered list of valid characters.\nvar chars='ABCDEFGHIJKLMNOPQRSTUVWXYZ';// Store the value of the next character for each position\n// in the new string.\n// For example, [0] -> \"A\", [1] -> \"B\", [0, 1] -> \"AB\"\nvar nextCharIndices=[0];// Generate a new scope name,\n// potentially conflicting with an existing name.\n// Reference: https://stackoverflow.com/a/12504061\nfunction next(){var r=[];nextCharIndices.forEach(function(charIndex){r.unshift(chars[charIndex]);});var increment=true;for(var i=0;i<nextCharIndices.length;i++){var val=++nextCharIndices[i];if(val>=chars.length){nextCharIndices[i]=0;}else{increment=false;break;}}if(increment){nextCharIndices.push(0);}return r.join('');}var nextScope;do{nextScope=next();}while(prevScopes.includes(nextScope));return nextScope;}/**\n * Get a representative PixelSource from a loader object returned from\n * the Vitessce imaging loaders\n * @param {object} loader { data: (PixelSource[]|PixelSource), metadata, channels } object\n * @param {number=} level Level of the multiscale loader from which to get a PixelSource\n * @returns {object} PixelSource object\n */export function getSourceFromLoader(loader,level){var data=loader.data;var source=Array.isArray(data)?data[level||data.length-1]:data;return source;}/*\n * Helper method to determine whether pixel data is interleaved and rgb or not.\n * @param {object} loader\n */export function isRgb(loader){var source=getSourceFromLoader(loader);var shape=source.shape,dtype=source.dtype,labels=source.labels;var channelSize=shape[labels.indexOf('c')];return channelSize===3&&dtype==='Uint8';}","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/utils.js"],"names":["fromEntries","iterable","reduce","obj","key","val","Object","assign","pluralize","singular","plural","count","capitalize","word","charAt","toUpperCase","slice","getLongestString","strings","prevLongest","currentValue","length","getNextScope","prevScopes","chars","nextCharIndices","next","r","forEach","charIndex","unshift","increment","i","push","join","nextScope","includes","getSourceFromLoader","loader","level","data","source","Array","isArray","isRgb","shape","dtype","labels","channelSize","indexOf"],"mappings":"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","sourcesContent":["/* eslint-disable no-plusplus */\n\n// Adapted from https://github.com/feross/fromentries/blob/29b52a850bb3a47c390937631c2638edf3443942/index.js\nexport function fromEntries(iterable) {\n  return [...iterable]\n    .reduce((obj, { 0: key, 1: val }) => Object.assign(obj, { [key]: val }), {});\n}\n\n/**\n * Select between a singular and plural version of a word,\n * based on an item count.\n * @param {string} singular The singular version of the word.\n * @param {string} plural The plural version of the word.\n * @param {number} count The number of items.\n * @returns {string} Singular if count is one, else plural.\n */\nexport function pluralize(singular, plural, count) {\n  return (count === 1 ? singular : plural);\n}\n\n/**\n * Capitalize a the first letter of a string.\n * @param {string} word A string to capitalize.\n * @returns {string} The word parameter with the first letter capitalized.\n */\nexport function capitalize(word) {\n  return word.charAt(0).toUpperCase() + word.slice(1);\n}\n\n/**\n * Get the longest string in the array of strings.\n * @param {string[]} strings The array of strings.\n * @returns The longest string.\n */\nexport function getLongestString(strings) {\n  return strings.reduce(\n    (prevLongest, currentValue) => (\n      prevLongest.length > currentValue.length ? prevLongest : currentValue\n    ),\n  );\n}\n\n/**\n * Generate a new scope name which does not\n * conflict / overlap with a previous scope name.\n * Really these just need to be unique within the coordination object.\n * So in theory they could be String(Math.random()) or uuidv4() or something.\n * However it may be good to make them more human-readable and memorable\n * since eventually we will want to expose a UI to update the coordination.\n * @param {string[]} prevScopes Previous scope names.\n * @returns {string} The new scope name.\n */\nexport function getNextScope(prevScopes) {\n  // Keep an ordered list of valid characters.\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  // Store the value of the next character for each position\n  // in the new string.\n  // For example, [0] -> \"A\", [1] -> \"B\", [0, 1] -> \"AB\"\n  const nextCharIndices = [0];\n\n  // Generate a new scope name,\n  // potentially conflicting with an existing name.\n  // Reference: https://stackoverflow.com/a/12504061\n  function next() {\n    const r = [];\n    nextCharIndices.forEach((charIndex) => {\n      r.unshift(chars[charIndex]);\n    });\n    let increment = true;\n    for (let i = 0; i < nextCharIndices.length; i++) {\n      const val = ++nextCharIndices[i];\n      if (val >= chars.length) {\n        nextCharIndices[i] = 0;\n      } else {\n        increment = false;\n        break;\n      }\n    }\n    if (increment) {\n      nextCharIndices.push(0);\n    }\n    return r.join('');\n  }\n\n  let nextScope;\n  do {\n    nextScope = next();\n  } while (prevScopes.includes(nextScope));\n  return nextScope;\n}\n\n/**\n * Get a representative PixelSource from a loader object returned from\n * the Vitessce imaging loaders\n * @param {object} loader { data: (PixelSource[]|PixelSource), metadata, channels } object\n * @param {number=} level Level of the multiscale loader from which to get a PixelSource\n * @returns {object} PixelSource object\n */\nexport function getSourceFromLoader(loader, level) {\n  const { data } = loader;\n  const source = Array.isArray(data) ? data[(level || data.length - 1)] : data;\n  return source;\n}\n\n/*\n * Helper method to determine whether pixel data is interleaved and rgb or not.\n * @param {object} loader\n */\nexport function isRgb(loader) {\n  const source = getSourceFromLoader(loader);\n  const { shape, dtype, labels } = source;\n  const channelSize = shape[labels.indexOf('c')];\n  return (channelSize === 3) && dtype === 'Uint8';\n}\n"]},"metadata":{},"sourceType":"module"}