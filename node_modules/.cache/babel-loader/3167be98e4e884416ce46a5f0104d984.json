{"ast":null,"code":"import _regeneratorRuntime from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";import _asyncToGenerator from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _createClass from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";// https://developer.mozilla.org/en-US/docs/Web/API/NavigatorConcurrentHardware/hardwareConcurrency\n// We need to give a different way of getting this for safari, so 4 is probably a safe bet\n// for parallel processing in the meantime.  More can't really hurt since they'll just block\n// each other and not the UI thread, which is the real benefit.\nvar defaultPoolSize=typeof navigator!=='undefined'?navigator.hardwareConcurrency||4:null;/**\n * Pool for workers to decode chunks of the images.\n * This is a line-for-line copy of GeoTIFFs old implementation: https://github.com/geotiffjs/geotiff.js/blob/v1.0.0-beta.6/src/pool.js\n */var Pool=/*#__PURE__*/function(){/**\n   * @constructor\n   * @param {object} Worker The worker class to be used for processing.\n   */function Pool(Worker){_classCallCheck(this,Pool);this.workers=[];this.idleWorkers=[];this.waitQueue=[];this.decoder=null;// eslint-disable-next-line no-plusplus\nfor(var i=0;i<defaultPoolSize;++i){var w=new Worker();this.workers.push(w);this.idleWorkers.push(w);}}// eslint-disable-next-line class-methods-use-this\n_createClass(Pool,[{key:\"process\",value:function(){var _process=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:throw new Error('Pool needs to implement \"process\" method');case 1:case\"end\":return _context.stop();}}},_callee);}));function process(){return _process.apply(this,arguments);}return process;}()},{key:\"waitForWorker\",value:function(){var _waitForWorker=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var idleWorker,waiter,promise;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:idleWorker=this.idleWorkers.pop();if(!idleWorker){_context2.next=3;break;}return _context2.abrupt(\"return\",idleWorker);case 3:waiter={};promise=new Promise(function(resolve){waiter.resolve=resolve;});this.waitQueue.push(waiter);return _context2.abrupt(\"return\",promise);case 7:case\"end\":return _context2.stop();}}},_callee2,this);}));function waitForWorker(){return _waitForWorker.apply(this,arguments);}return waitForWorker;}()},{key:\"finishTask\",value:function(){var _finishTask=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(currentWorker){var waiter;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:waiter=this.waitQueue.pop();if(waiter){waiter.resolve(currentWorker);}else{this.idleWorkers.push(currentWorker);}case 2:case\"end\":return _context3.stop();}}},_callee3,this);}));function finishTask(_x){return _finishTask.apply(this,arguments);}return finishTask;}()},{key:\"destroy\",value:function destroy(){// eslint-disable-next-line no-plusplus\nfor(var i=0;i<this.workers.length;++i){this.workers[i].terminate();}}}]);return Pool;}();export{Pool as default};","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/Pool.js"],"names":["defaultPoolSize","navigator","hardwareConcurrency","Pool","Worker","workers","idleWorkers","waitQueue","decoder","i","w","push","Error","idleWorker","pop","waiter","promise","Promise","resolve","currentWorker","length","terminate"],"mappings":"2tBAAA;AACA;AACA;AACA;AACA,GAAMA,CAAAA,eAAe,CAAG,MAAOC,CAAAA,SAAP,GAAqB,WAArB,CAAmCA,SAAS,CAACC,mBAAV,EAAiC,CAApE,CAAwE,IAAhG,CAEA;;;MAIqBC,CAAAA,I,yBACnB;;;KAIA,cAAYC,MAAZ,CAAoB,4BAClB,KAAKC,OAAL,CAAe,EAAf,CACA,KAAKC,WAAL,CAAmB,EAAnB,CACA,KAAKC,SAAL,CAAiB,EAAjB,CACA,KAAKC,OAAL,CAAe,IAAf,CAEA;AACA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGT,eAApB,CAAqC,EAAES,CAAvC,CAA0C,CACxC,GAAMC,CAAAA,CAAC,CAAG,GAAIN,CAAAA,MAAJ,EAAV,CACA,KAAKC,OAAL,CAAaM,IAAb,CAAkBD,CAAlB,EACA,KAAKJ,WAAL,CAAiBK,IAAjB,CAAsBD,CAAtB,EACD,CACF,CAED;gQAEQ,IAAIE,CAAAA,KAAJ,CAAU,0CAAV,C,+ZAIAC,U,CAAa,KAAKP,WAAL,CAAiBQ,GAAjB,E,KACfD,U,2DACKA,U,SAEHE,M,CAAS,E,CACTC,O,CAAU,GAAIC,CAAAA,OAAJ,CAAY,SAACC,OAAD,CAAa,CACvCH,MAAM,CAACG,OAAP,CAAiBA,OAAjB,CACD,CAFe,C,CAIhB,KAAKX,SAAL,CAAeI,IAAf,CAAoBI,MAApB,E,iCACOC,O,+RAGQG,a,iIACTJ,M,CAAS,KAAKR,SAAL,CAAeO,GAAf,E,CACf,GAAIC,MAAJ,CAAY,CACVA,MAAM,CAACG,OAAP,CAAeC,aAAf,EACD,CAFD,IAEO,CACL,KAAKb,WAAL,CAAiBK,IAAjB,CAAsBQ,aAAtB,EACD,C,gMAGO,CACR;AACA,IAAK,GAAIV,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAG,KAAKJ,OAAL,CAAae,MAAjC,CAAyC,EAAEX,CAA3C,CAA8C,CAC5C,KAAKJ,OAAL,CAAaI,CAAb,EAAgBY,SAAhB,GACD,CACF,C,2BApDkBlB,I","sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/API/NavigatorConcurrentHardware/hardwareConcurrency\n// We need to give a different way of getting this for safari, so 4 is probably a safe bet\n// for parallel processing in the meantime.  More can't really hurt since they'll just block\n// each other and not the UI thread, which is the real benefit.\nconst defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 4 : null;\n\n/**\n * Pool for workers to decode chunks of the images.\n * This is a line-for-line copy of GeoTIFFs old implementation: https://github.com/geotiffjs/geotiff.js/blob/v1.0.0-beta.6/src/pool.js\n */\nexport default class Pool {\n  /**\n   * @constructor\n   * @param {object} Worker The worker class to be used for processing.\n   */\n  constructor(Worker) {\n    this.workers = [];\n    this.idleWorkers = [];\n    this.waitQueue = [];\n    this.decoder = null;\n\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < defaultPoolSize; ++i) {\n      const w = new Worker();\n      this.workers.push(w);\n      this.idleWorkers.push(w);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async process() {\n    throw new Error('Pool needs to implement \"process\" method');\n  }\n\n  async waitForWorker() {\n    const idleWorker = this.idleWorkers.pop();\n    if (idleWorker) {\n      return idleWorker;\n    }\n    const waiter = {};\n    const promise = new Promise((resolve) => {\n      waiter.resolve = resolve;\n    });\n\n    this.waitQueue.push(waiter);\n    return promise;\n  }\n\n  async finishTask(currentWorker) {\n    const waiter = this.waitQueue.pop();\n    if (waiter) {\n      waiter.resolve(currentWorker);\n    } else {\n      this.idleWorkers.push(currentWorker);\n    }\n  }\n\n  destroy() {\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < this.workers.length; ++i) {\n      this.workers[i].terminate();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}