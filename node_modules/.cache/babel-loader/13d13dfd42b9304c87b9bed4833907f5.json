{"ast":null,"code":"import _slicedToArray from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";import _asyncToGenerator from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _createClass from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";import _inherits from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";import _createSuper from\"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";import LoaderResult from'../LoaderResult';import AbstractTwoStepLoader from'../AbstractTwoStepLoader';/**\n * Loader for converting zarr into the cell json schema.\n */var CellsZarrLoader=/*#__PURE__*/function(_AbstractTwoStepLoade){_inherits(CellsZarrLoader,_AbstractTwoStepLoade);var _super=_createSuper(CellsZarrLoader);function CellsZarrLoader(){_classCallCheck(this,CellsZarrLoader);return _super.apply(this,arguments);}_createClass(CellsZarrLoader,[{key:\"loadXy\",/**\n   * Class method for loading spatial cell centroids.\n   * @returns {Promise} A promise for an array of tuples/triples for cell centroids.\n   */value:function loadXy(){var _ref=this.options||{},xy=_ref.xy;if(this.xy){return this.xy;}if(!this.xy&&xy){this.xy=this.dataSource.loadNumeric(xy);return this.xy;}this.xy=Promise.resolve(null);return this.xy;}/**\n   * Class method for loading spatial cell polygons.\n   * @returns {Promise} A promise for an array of arrays for cell polygons.\n   */},{key:\"loadPoly\",value:function loadPoly(){var _ref2=this.options||{},poly=_ref2.poly;if(this.poly){return this.poly;}if(!this.poly&&poly){this.poly=this.dataSource.loadNumeric(poly);return this.poly;}this.poly=Promise.resolve(null);return this.poly;}/**\n   * Class method for loading various mappings, like UMAP or tSNE cooridnates.\n   * @returns {Promise} A promise for an array of tuples of coordinates.\n   */},{key:\"loadMappings\",value:function loadMappings(){var _this=this;var _ref3=this.options||{},mappings=_ref3.mappings;if(this.mappings){return this.mappings;}if(!this.mappings&&mappings){this.mappings=Promise.all(Object.keys(mappings).map(/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(coordinationName){var key;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:key=mappings[coordinationName].key;_context.t0=coordinationName;_context.next=4;return _this.dataSource.loadNumeric(key);case 4:_context.t1=_context.sent;return _context.abrupt(\"return\",{coordinationName:_context.t0,arr:_context.t1});case 6:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref4.apply(this,arguments);};}()));return this.mappings;}this.mappings=Promise.resolve(null);return this.mappings;}/**\n   * Class method for loading factors, which are cell set ids.\n   * @returns {Promise} A promise for an array of an array of strings of ids,\n   * where subarray is a clustering/factor.\n   */},{key:\"loadFactors\",value:function loadFactors(){var _ref5=this.options||{},factors=_ref5.factors;if(factors){return this.dataSource.loadObsColumns(factors);}return Promise.resolve(null);}},{key:\"load\",value:function(){var _load=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var _this2=this;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!this.cells){this.cells=Promise.all([this.loadMappings(),this.loadXy(),this.loadPoly(),this.dataSource.loadObsIndex(),this.loadFactors()]).then(function(_ref6){var _ref7=_slicedToArray(_ref6,5),mappings=_ref7[0],xy=_ref7[1],poly=_ref7[2],cellNames=_ref7[3],factors=_ref7[4];var cells={};cellNames.forEach(function(name,i){cells[name]={};if(mappings){mappings.forEach(function(_ref8){var coordinationName=_ref8.coordinationName,arr=_ref8.arr;if(!cells[name].mappings){cells[name].mappings={};}var dims=_this2.options.mappings[coordinationName].dims;cells[name].mappings[coordinationName]=dims.map(function(dim){return arr.data[i][dim];});});}if(xy){cells[name].xy=xy.data[i];}if(poly){cells[name].poly=poly.data[i];}if(factors){var factorsObj={};factors.forEach(// eslint-disable-next-line no-return-assign\nfunction(factor,j){return factorsObj[_this2.options.factors[j].split('/').slice(-1)]=factor[i];});cells[name].factors=factorsObj;}});return cells;});}_context2.t0=Promise;_context2.t1=LoaderResult;_context2.next=5;return this.cells;case 5:_context2.t2=_context2.sent;_context2.t3=new _context2.t1(_context2.t2,null);return _context2.abrupt(\"return\",_context2.t0.resolve.call(_context2.t0,_context2.t3));case 8:case\"end\":return _context2.stop();}}},_callee2,this);}));function load(){return _load.apply(this,arguments);}return load;}()}]);return CellsZarrLoader;}(AbstractTwoStepLoader);export{CellsZarrLoader as default};","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/src/loaders/anndata-loaders/CellsZarrLoader.js"],"names":["LoaderResult","AbstractTwoStepLoader","CellsZarrLoader","options","xy","dataSource","loadNumeric","Promise","resolve","poly","mappings","all","Object","keys","map","coordinationName","key","arr","factors","loadObsColumns","cells","loadMappings","loadXy","loadPoly","loadObsIndex","loadFactors","then","cellNames","forEach","name","i","dims","dim","data","factorsObj","factor","j","split","slice"],"mappings":"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","sourcesContent":["import LoaderResult from '../LoaderResult';\nimport AbstractTwoStepLoader from '../AbstractTwoStepLoader';\n\n/**\n * Loader for converting zarr into the cell json schema.\n */\nexport default class CellsZarrLoader extends AbstractTwoStepLoader {\n  /**\n   * Class method for loading spatial cell centroids.\n   * @returns {Promise} A promise for an array of tuples/triples for cell centroids.\n   */\n  loadXy() {\n    const { xy } = (this.options || {});\n    if (this.xy) {\n      return this.xy;\n    }\n    if (!this.xy && xy) {\n      this.xy = this.dataSource.loadNumeric(xy);\n      return this.xy;\n    }\n    this.xy = Promise.resolve(null);\n    return this.xy;\n  }\n\n  /**\n   * Class method for loading spatial cell polygons.\n   * @returns {Promise} A promise for an array of arrays for cell polygons.\n   */\n  loadPoly() {\n    const { poly } = (this.options || {});\n    if (this.poly) {\n      return this.poly;\n    }\n    if (!this.poly && poly) {\n      this.poly = this.dataSource.loadNumeric(poly);\n      return this.poly;\n    }\n    this.poly = Promise.resolve(null);\n    return this.poly;\n  }\n\n  /**\n   * Class method for loading various mappings, like UMAP or tSNE cooridnates.\n   * @returns {Promise} A promise for an array of tuples of coordinates.\n   */\n  loadMappings() {\n    const { mappings } = (this.options || {});\n    if (this.mappings) {\n      return this.mappings;\n    }\n    if (!this.mappings && mappings) {\n      this.mappings = Promise.all(\n        Object.keys(mappings).map(async (coordinationName) => {\n          const { key } = mappings[coordinationName];\n          return { coordinationName, arr: await this.dataSource.loadNumeric(key) };\n        }),\n      );\n      return this.mappings;\n    }\n    this.mappings = Promise.resolve(null);\n    return this.mappings;\n  }\n\n  /**\n   * Class method for loading factors, which are cell set ids.\n   * @returns {Promise} A promise for an array of an array of strings of ids,\n   * where subarray is a clustering/factor.\n   */\n  loadFactors() {\n    const { factors } = (this.options || {});\n    if (factors) {\n      return this.dataSource.loadObsColumns(factors);\n    }\n    return Promise.resolve(null);\n  }\n\n  async load() {\n    if (!this.cells) {\n      this.cells = Promise.all([\n        this.loadMappings(),\n        this.loadXy(),\n        this.loadPoly(),\n        this.dataSource.loadObsIndex(),\n        this.loadFactors(),\n      ]).then(([mappings, xy, poly, cellNames, factors]) => {\n        const cells = {};\n        cellNames.forEach((name, i) => {\n          cells[name] = {};\n          if (mappings) {\n            mappings.forEach(({ coordinationName, arr }) => {\n              if (!cells[name].mappings) {\n                cells[name].mappings = {};\n              }\n              const { dims } = this.options.mappings[coordinationName];\n              cells[name].mappings[coordinationName] = dims.map(\n                dim => arr.data[i][dim],\n              );\n            });\n          }\n          if (xy) {\n            cells[name].xy = xy.data[i];\n          }\n          if (poly) {\n            cells[name].poly = poly.data[i];\n          }\n          if (factors) {\n            const factorsObj = {};\n            factors.forEach(\n              // eslint-disable-next-line no-return-assign\n              (factor, j) => (factorsObj[this.options.factors[j].split('/').slice(-1)] = factor[i]),\n            );\n            cells[name].factors = factorsObj;\n          }\n        });\n        return cells;\n      });\n    }\n    return Promise.resolve(new LoaderResult(await this.cells, null));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}