{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nvar scaleBindings = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: function parse(model, selCmpt) {\n    var bound = selCmpt.scales = [];\n\n    var _iterator = _createForOfIteratorHelper(selCmpt.project.items),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var proj = _step.value;\n        var channel = proj.channel;\n\n        if (!isScaleChannel(channel)) {\n          continue;\n        }\n\n        var scale = model.getScaleComponent(channel);\n        var scaleType = scale ? scale.get('type') : undefined;\n\n        if (!scale || !hasContinuousDomain(scaleType)) {\n          log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n          continue;\n        }\n\n        scale.set('selectionExtent', {\n          param: selCmpt.name,\n          field: proj.field\n        }, true);\n        bound.push(proj);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    var bound = selCmpt.scales.filter(function (proj) {\n      return signals.filter(function (s) {\n        return s.name === proj.signals.data;\n      }).length === 0;\n    }); // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    } // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n\n\n    var namedSg = signals.filter(function (s) {\n      return s.name === selCmpt.name;\n    })[0];\n    var update = namedSg.update;\n\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = \"{\".concat(bound.map(function (proj) {\n        return \"\".concat(stringValue(replacePathInField(proj.field)), \": \").concat(proj.signals.data);\n      }).join(', '), \"}\");\n    } else {\n      var _iterator2 = _createForOfIteratorHelper(bound),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var proj = _step2.value;\n          var mapping = \"\".concat(stringValue(replacePathInField(proj.field)), \": \").concat(proj.signals.data);\n\n          if (!update.includes(mapping)) {\n            update = \"\".concat(update.substring(0, update.length - 1), \", \").concat(mapping, \"}\");\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(function (proj) {\n      return {\n        name: proj.signals.data\n      };\n    }));\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      var _iterator3 = _createForOfIteratorHelper(selCmpt.scales),\n          _step3;\n\n      try {\n        var _loop = function _loop() {\n          var proj = _step3.value;\n\n          var signal = _signals.filter(function (s) {\n            return s.name === proj.signals.data;\n          })[0];\n\n          signal.push = 'outer';\n          delete signal.value;\n          delete signal.update;\n        };\n\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    return _signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  var scale = stringValue(model.scaleName(channel));\n  return \"domain(\".concat(scale, \")\");\n}\n\nfunction isTopLevelLayer(model) {\n  var _a;\n\n  return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}","map":{"version":3,"sources":["../../../../src/compile/selection/scales.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nconst scaleBindings = {\n    defined: selCmpt => {\n        return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n    },\n    parse: (model, selCmpt) => {\n        const bound = (selCmpt.scales = []);\n        for (const proj of selCmpt.project.items) {\n            const channel = proj.channel;\n            if (!isScaleChannel(channel)) {\n                continue;\n            }\n            const scale = model.getScaleComponent(channel);\n            const scaleType = scale ? scale.get('type') : undefined;\n            if (!scale || !hasContinuousDomain(scaleType)) {\n                log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n                continue;\n            }\n            scale.set('selectionExtent', { param: selCmpt.name, field: proj.field }, true);\n            bound.push(proj);\n        }\n    },\n    topLevelSignals: (model, selCmpt, signals) => {\n        const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);\n        // Top-level signals are only needed for multiview displays and if this\n        // view's top-level signals haven't already been generated.\n        if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n            return signals;\n        }\n        // vlSelectionResolve does not account for the behavior of bound scales in\n        // multiview displays. Each unit view adds a tuple to the store, but the\n        // state of the selection is the unit selection most recently updated. This\n        // state is captured by the top-level signals that we insert and \"push\n        // outer\" to from within the units. We need to reassemble this state into\n        // the top-level named signal, except no single selCmpt has a global view.\n        const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n        let update = namedSg.update;\n        if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n            namedSg.update = `{${bound\n                .map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`)\n                .join(', ')}}`;\n        }\n        else {\n            for (const proj of bound) {\n                const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n                if (!update.includes(mapping)) {\n                    update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n                }\n            }\n            namedSg.update = update;\n        }\n        return signals.concat(bound.map(proj => ({ name: proj.signals.data })));\n    },\n    signals: (model, selCmpt, signals) => {\n        // Nested signals need only push to top-level signals with multiview displays.\n        if (model.parent && !isTopLevelLayer(model)) {\n            for (const proj of selCmpt.scales) {\n                const signal = signals.filter(s => s.name === proj.signals.data)[0];\n                signal.push = 'outer';\n                delete signal.value;\n                delete signal.update;\n            }\n        }\n        return signals;\n    }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n    const scale = stringValue(model.scaleName(channel));\n    return `domain(${scale})`;\n}\nfunction isTopLevelLayer(model) {\n    var _a;\n    return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}\n//# sourceMappingURL=scales.js.map"]},"metadata":{},"sourceType":"module"}