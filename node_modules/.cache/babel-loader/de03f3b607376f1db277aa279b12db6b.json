{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { valueExpr, vgField } from './channeldef';\nimport { fieldExpr as timeUnitFieldExpr, normalizeTimeUnit } from './timeunit';\nimport { stringify } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isSelectionPredicate(predicate) {\n  return predicate === null || predicate === void 0 ? void 0 : predicate['param'];\n}\nexport function isFieldEqualPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\nexport function isFieldLTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\nexport function isFieldLTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\nexport function isFieldGTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\nexport function isFieldGTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\nexport function isFieldRangePredicate(predicate) {\n  if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    } else if (isSignalRef(predicate.range)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function isFieldOneOfPredicate(predicate) {\n  return predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  ;\n}\nexport function isFieldValidPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\nexport function isFieldPredicate(predicate) {\n  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);\n}\n\nfunction predicateValueExpr(v, timeUnit) {\n  return valueExpr(v, {\n    timeUnit: timeUnit,\n    wrapTime: true\n  });\n}\n\nfunction predicateValuesExpr(vals, timeUnit) {\n  return vals.map(function (v) {\n    return predicateValueExpr(v, timeUnit);\n  });\n} // This method is used by Voyager. Do not change its behavior without changing Voyager.\n\n\nexport function fieldFilterExpression(predicate) {\n  var useInRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  var _a;\n\n  var field = predicate.field;\n  var timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n  var fieldExpr = timeUnit ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n  // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n  // TODO: support utc\n  \"time(\".concat(timeUnitFieldExpr(timeUnit, field), \")\") : vgField(predicate, {\n    expr: 'datum'\n  });\n\n  if (isFieldEqualPredicate(predicate)) {\n    return \"\".concat(fieldExpr, \"===\").concat(predicateValueExpr(predicate.equal, timeUnit));\n  } else if (isFieldLTPredicate(predicate)) {\n    var upper = predicate.lt;\n    return \"\".concat(fieldExpr, \"<\").concat(predicateValueExpr(upper, timeUnit));\n  } else if (isFieldGTPredicate(predicate)) {\n    var lower = predicate.gt;\n    return \"\".concat(fieldExpr, \">\").concat(predicateValueExpr(lower, timeUnit));\n  } else if (isFieldLTEPredicate(predicate)) {\n    var _upper = predicate.lte;\n    return \"\".concat(fieldExpr, \"<=\").concat(predicateValueExpr(_upper, timeUnit));\n  } else if (isFieldGTEPredicate(predicate)) {\n    var _lower = predicate.gte;\n    return \"\".concat(fieldExpr, \">=\").concat(predicateValueExpr(_lower, timeUnit));\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return \"indexof([\".concat(predicateValuesExpr(predicate.oneOf, timeUnit).join(','), \"], \").concat(fieldExpr, \") !== -1\");\n  } else if (isFieldValidPredicate(predicate)) {\n    return fieldValidPredicate(fieldExpr, predicate.valid);\n  } else if (isFieldRangePredicate(predicate)) {\n    var range = predicate.range;\n\n    var _lower2 = isSignalRef(range) ? {\n      signal: \"\".concat(range.signal, \"[0]\")\n    } : range[0];\n\n    var _upper2 = isSignalRef(range) ? {\n      signal: \"\".concat(range.signal, \"[1]\")\n    } : range[1];\n\n    if (_lower2 !== null && _upper2 !== null && useInRange) {\n      return 'inrange(' + fieldExpr + ', [' + predicateValueExpr(_lower2, timeUnit) + ', ' + predicateValueExpr(_upper2, timeUnit) + '])';\n    }\n\n    var exprs = [];\n\n    if (_lower2 !== null) {\n      exprs.push(\"\".concat(fieldExpr, \" >= \").concat(predicateValueExpr(_lower2, timeUnit)));\n    }\n\n    if (_upper2 !== null) {\n      exprs.push(\"\".concat(fieldExpr, \" <= \").concat(predicateValueExpr(_upper2, timeUnit)));\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n  /* istanbul ignore next: it should never reach here */\n\n\n  throw new Error(\"Invalid field predicate: \".concat(stringify(predicate)));\n}\nexport function fieldValidPredicate(fieldExpr) {\n  var valid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (valid) {\n    return \"isValid(\".concat(fieldExpr, \") && isFinite(+\").concat(fieldExpr, \")\");\n  } else {\n    return \"!isValid(\".concat(fieldExpr, \") || !isFinite(+\").concat(fieldExpr, \")\");\n  }\n}\nexport function normalizePredicate(f) {\n  var _a;\n\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return Object.assign(Object.assign({}, f), {\n      timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit\n    });\n  }\n\n  return f;\n}","map":{"version":3,"sources":["../../src/predicate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { valueExpr, vgField } from './channeldef';\nimport { fieldExpr as timeUnitFieldExpr, normalizeTimeUnit } from './timeunit';\nimport { stringify } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isSelectionPredicate(predicate) {\n    return predicate === null || predicate === void 0 ? void 0 : predicate['param'];\n}\nexport function isFieldEqualPredicate(predicate) {\n    return predicate && !!predicate.field && predicate.equal !== undefined;\n}\nexport function isFieldLTPredicate(predicate) {\n    return predicate && !!predicate.field && predicate.lt !== undefined;\n}\nexport function isFieldLTEPredicate(predicate) {\n    return predicate && !!predicate.field && predicate.lte !== undefined;\n}\nexport function isFieldGTPredicate(predicate) {\n    return predicate && !!predicate.field && predicate.gt !== undefined;\n}\nexport function isFieldGTEPredicate(predicate) {\n    return predicate && !!predicate.field && predicate.gte !== undefined;\n}\nexport function isFieldRangePredicate(predicate) {\n    if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {\n        if (isArray(predicate.range) && predicate.range.length === 2) {\n            return true;\n        }\n        else if (isSignalRef(predicate.range)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function isFieldOneOfPredicate(predicate) {\n    return (predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n    );\n}\nexport function isFieldValidPredicate(predicate) {\n    return predicate && !!predicate.field && predicate.valid !== undefined;\n}\nexport function isFieldPredicate(predicate) {\n    return (isFieldOneOfPredicate(predicate) ||\n        isFieldEqualPredicate(predicate) ||\n        isFieldRangePredicate(predicate) ||\n        isFieldLTPredicate(predicate) ||\n        isFieldGTPredicate(predicate) ||\n        isFieldLTEPredicate(predicate) ||\n        isFieldGTEPredicate(predicate));\n}\nfunction predicateValueExpr(v, timeUnit) {\n    return valueExpr(v, { timeUnit, wrapTime: true });\n}\nfunction predicateValuesExpr(vals, timeUnit) {\n    return vals.map(v => predicateValueExpr(v, timeUnit));\n}\n// This method is used by Voyager. Do not change its behavior without changing Voyager.\nexport function fieldFilterExpression(predicate, useInRange = true) {\n    var _a;\n    const { field } = predicate;\n    const timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n    const fieldExpr = timeUnit\n        ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n            // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n            // TODO: support utc\n            `time(${timeUnitFieldExpr(timeUnit, field)})`\n        : vgField(predicate, { expr: 'datum' });\n    if (isFieldEqualPredicate(predicate)) {\n        return `${fieldExpr}===${predicateValueExpr(predicate.equal, timeUnit)}`;\n    }\n    else if (isFieldLTPredicate(predicate)) {\n        const upper = predicate.lt;\n        return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n    }\n    else if (isFieldGTPredicate(predicate)) {\n        const lower = predicate.gt;\n        return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n    }\n    else if (isFieldLTEPredicate(predicate)) {\n        const upper = predicate.lte;\n        return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n    }\n    else if (isFieldGTEPredicate(predicate)) {\n        const lower = predicate.gte;\n        return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n    }\n    else if (isFieldOneOfPredicate(predicate)) {\n        return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n    }\n    else if (isFieldValidPredicate(predicate)) {\n        return fieldValidPredicate(fieldExpr, predicate.valid);\n    }\n    else if (isFieldRangePredicate(predicate)) {\n        const { range } = predicate;\n        const lower = isSignalRef(range) ? { signal: `${range.signal}[0]` } : range[0];\n        const upper = isSignalRef(range) ? { signal: `${range.signal}[1]` } : range[1];\n        if (lower !== null && upper !== null && useInRange) {\n            return ('inrange(' +\n                fieldExpr +\n                ', [' +\n                predicateValueExpr(lower, timeUnit) +\n                ', ' +\n                predicateValueExpr(upper, timeUnit) +\n                '])');\n        }\n        const exprs = [];\n        if (lower !== null) {\n            exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n        }\n        if (upper !== null) {\n            exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n        }\n        return exprs.length > 0 ? exprs.join(' && ') : 'true';\n    }\n    /* istanbul ignore next: it should never reach here */\n    throw new Error(`Invalid field predicate: ${stringify(predicate)}`);\n}\nexport function fieldValidPredicate(fieldExpr, valid = true) {\n    if (valid) {\n        return `isValid(${fieldExpr}) && isFinite(+${fieldExpr})`;\n    }\n    else {\n        return `!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`;\n    }\n}\nexport function normalizePredicate(f) {\n    var _a;\n    if (isFieldPredicate(f) && f.timeUnit) {\n        return Object.assign(Object.assign({}, f), { timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit });\n    }\n    return f;\n}\n//# sourceMappingURL=predicate.js.map"]},"metadata":{},"sourceType":"module"}