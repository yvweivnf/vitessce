{"ast":null,"code":"import { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\n\nfunction getStackByFields(model) {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n\n    const _field = vgField(fieldDef);\n\n    if (_field) {\n      fields.push(_field);\n    }\n\n    return fields;\n  }, []);\n}\n\nfunction isValidAsArray(as) {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends DataFlowNode {\n  constructor(parent, stack) {\n    super(parent);\n    this._stack = stack;\n  }\n\n  clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  static makeFromTransform(parent, stackTransform) {\n    const {\n      stack,\n      groupby,\n      as,\n      offset = 'zero'\n    } = stackTransform;\n    const sortFields = [];\n    const sortOrder = [];\n\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n\n    const sort = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs;\n\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, `${as}_end`];\n    } else {\n      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n    }\n\n    return new StackNode(parent, {\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  static makeFromEncoding(parent, model) {\n    const stackProperties = model.stack;\n    const {\n      encoding\n    } = model;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    const {\n      groupbyChannel,\n      fieldChannel,\n      offset,\n      impute\n    } = stackProperties;\n    let dimensionFieldDef;\n\n    if (groupbyChannel) {\n      const cDef = encoding[groupbyChannel];\n      dimensionFieldDef = getFieldDef(cDef); // Fair to cast as groupByChannel is always either x or y\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n    let sort;\n\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        s.field.push(field);\n        s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n        return s;\n      }, {\n        field: [],\n        order: []\n      });\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDef,\n      stackField: model.vgField(fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset,\n      impute,\n      as: [model.vgField(fieldChannel, {\n        suffix: 'start',\n        forAs: true\n      }), model.vgField(fieldChannel, {\n        suffix: 'end',\n        forAs: true\n      })]\n    });\n  }\n\n  get stack() {\n    return this._stack;\n  }\n\n  addDimensions(fields) {\n    this._stack.facetby.push(...fields);\n  }\n\n  dependentFields() {\n    const out = new Set();\n    out.add(this._stack.stackField);\n    this.getGroupbyFields().forEach(out.add, out);\n\n    this._stack.facetby.forEach(out.add, out);\n\n    this._stack.sort.field.forEach(out.add, out);\n\n    return out;\n  }\n\n  producedFields() {\n    return new Set(this._stack.as);\n  }\n\n  hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n\n  getGroupbyFields() {\n    const {\n      dimensionFieldDef,\n      impute,\n      groupby\n    } = this._stack;\n\n    if (dimensionFieldDef) {\n      if (dimensionFieldDef.bin) {\n        if (impute) {\n          // For binned group by field with impute, we calculate bin_mid\n          // as we cannot impute two fields simultaneously\n          return [vgField(dimensionFieldDef, {\n            binSuffix: 'mid'\n          })];\n        }\n\n        return [// For binned group by field without impute, we need both bin (start) and bin_end\n        vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {\n          binSuffix: 'end'\n        })];\n      }\n\n      return [vgField(dimensionFieldDef)];\n    }\n\n    return groupby !== null && groupby !== void 0 ? groupby : [];\n  }\n\n  assemble() {\n    const transform = [];\n    const {\n      facetby,\n      dimensionFieldDef,\n      stackField: field,\n      stackby,\n      sort,\n      offset,\n      impute,\n      as\n    } = this._stack; // Impute\n\n    if (impute && dimensionFieldDef) {\n      const {\n        bandPosition = 0.5,\n        bin\n      } = dimensionFieldDef;\n\n      if (bin) {\n        // As we can only impute one field at a time, we need to calculate\n        // mid point for a binned field\n        transform.push({\n          type: 'formula',\n          expr: `${bandPosition}*` + vgField(dimensionFieldDef, {\n            expr: 'datum'\n          }) + `+${1 - bandPosition}*` + vgField(dimensionFieldDef, {\n            expr: 'datum',\n            binSuffix: 'end'\n          }),\n          as: vgField(dimensionFieldDef, {\n            binSuffix: 'mid',\n            forAs: true\n          })\n        });\n      }\n\n      transform.push({\n        type: 'impute',\n        field,\n        groupby: [...stackby, ...facetby],\n        key: vgField(dimensionFieldDef, {\n          binSuffix: 'mid'\n        }),\n        method: 'value',\n        value: 0\n      });\n    } // Stack\n\n\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n    return transform;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/stack.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\nfunction getStackByFields(model) {\n    return model.stack.stackBy.reduce((fields, by) => {\n        const fieldDef = by.fieldDef;\n        const _field = vgField(fieldDef);\n        if (_field) {\n            fields.push(_field);\n        }\n        return fields;\n    }, []);\n}\nfunction isValidAsArray(as) {\n    return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\nexport class StackNode extends DataFlowNode {\n    constructor(parent, stack) {\n        super(parent);\n        this._stack = stack;\n    }\n    clone() {\n        return new StackNode(null, duplicate(this._stack));\n    }\n    static makeFromTransform(parent, stackTransform) {\n        const { stack, groupby, as, offset = 'zero' } = stackTransform;\n        const sortFields = [];\n        const sortOrder = [];\n        if (stackTransform.sort !== undefined) {\n            for (const sortField of stackTransform.sort) {\n                sortFields.push(sortField.field);\n                sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n            }\n        }\n        const sort = {\n            field: sortFields,\n            order: sortOrder\n        };\n        let normalizedAs;\n        if (isValidAsArray(as)) {\n            normalizedAs = as;\n        }\n        else if (isString(as)) {\n            normalizedAs = [as, `${as}_end`];\n        }\n        else {\n            normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n        }\n        return new StackNode(parent, {\n            stackField: stack,\n            groupby,\n            offset,\n            sort,\n            facetby: [],\n            as: normalizedAs\n        });\n    }\n    static makeFromEncoding(parent, model) {\n        const stackProperties = model.stack;\n        const { encoding } = model;\n        if (!stackProperties) {\n            return null;\n        }\n        const { groupbyChannel, fieldChannel, offset, impute } = stackProperties;\n        let dimensionFieldDef;\n        if (groupbyChannel) {\n            const cDef = encoding[groupbyChannel];\n            dimensionFieldDef = getFieldDef(cDef); // Fair to cast as groupByChannel is always either x or y\n        }\n        const stackby = getStackByFields(model);\n        const orderDef = model.encoding.order;\n        let sort;\n        if (isArray(orderDef) || isFieldDef(orderDef)) {\n            sort = sortParams(orderDef);\n        }\n        else {\n            // default = descending by stackFields\n            // FIXME is the default here correct for binned fields?\n            sort = stackby.reduce((s, field) => {\n                s.field.push(field);\n                s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n                return s;\n            }, { field: [], order: [] });\n        }\n        return new StackNode(parent, {\n            dimensionFieldDef,\n            stackField: model.vgField(fieldChannel),\n            facetby: [],\n            stackby,\n            sort,\n            offset,\n            impute,\n            as: [\n                model.vgField(fieldChannel, { suffix: 'start', forAs: true }),\n                model.vgField(fieldChannel, { suffix: 'end', forAs: true })\n            ]\n        });\n    }\n    get stack() {\n        return this._stack;\n    }\n    addDimensions(fields) {\n        this._stack.facetby.push(...fields);\n    }\n    dependentFields() {\n        const out = new Set();\n        out.add(this._stack.stackField);\n        this.getGroupbyFields().forEach(out.add, out);\n        this._stack.facetby.forEach(out.add, out);\n        this._stack.sort.field.forEach(out.add, out);\n        return out;\n    }\n    producedFields() {\n        return new Set(this._stack.as);\n    }\n    hash() {\n        return `Stack ${hash(this._stack)}`;\n    }\n    getGroupbyFields() {\n        const { dimensionFieldDef, impute, groupby } = this._stack;\n        if (dimensionFieldDef) {\n            if (dimensionFieldDef.bin) {\n                if (impute) {\n                    // For binned group by field with impute, we calculate bin_mid\n                    // as we cannot impute two fields simultaneously\n                    return [vgField(dimensionFieldDef, { binSuffix: 'mid' })];\n                }\n                return [\n                    // For binned group by field without impute, we need both bin (start) and bin_end\n                    vgField(dimensionFieldDef, {}),\n                    vgField(dimensionFieldDef, { binSuffix: 'end' })\n                ];\n            }\n            return [vgField(dimensionFieldDef)];\n        }\n        return groupby !== null && groupby !== void 0 ? groupby : [];\n    }\n    assemble() {\n        const transform = [];\n        const { facetby, dimensionFieldDef, stackField: field, stackby, sort, offset, impute, as } = this._stack;\n        // Impute\n        if (impute && dimensionFieldDef) {\n            const { bandPosition = 0.5, bin } = dimensionFieldDef;\n            if (bin) {\n                // As we can only impute one field at a time, we need to calculate\n                // mid point for a binned field\n                transform.push({\n                    type: 'formula',\n                    expr: `${bandPosition}*` +\n                        vgField(dimensionFieldDef, { expr: 'datum' }) +\n                        `+${1 - bandPosition}*` +\n                        vgField(dimensionFieldDef, { expr: 'datum', binSuffix: 'end' }),\n                    as: vgField(dimensionFieldDef, { binSuffix: 'mid', forAs: true })\n                });\n            }\n            transform.push({\n                type: 'impute',\n                field,\n                groupby: [...stackby, ...facetby],\n                key: vgField(dimensionFieldDef, { binSuffix: 'mid' }),\n                method: 'value',\n                value: 0\n            });\n        }\n        // Stack\n        transform.push({\n            type: 'stack',\n            groupby: [...this.getGroupbyFields(), ...facetby],\n            field,\n            sort,\n            as,\n            offset\n        });\n        return transform;\n    }\n}\n//# sourceMappingURL=stack.js.map"]},"metadata":{},"sourceType":"module"}