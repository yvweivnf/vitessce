{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(makeArrayBufferIterator);\n\nvar DEFAULT_CHUNK_SIZE = 256 * 1024;\nexport function makeArrayBufferIterator(arrayBuffer) {\n  var options,\n      _options$chunkSize,\n      chunkSize,\n      byteOffset,\n      chunkByteLength,\n      chunk,\n      sourceArray,\n      chunkArray,\n      _args = arguments;\n\n  return _regeneratorRuntime.wrap(function makeArrayBufferIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? DEFAULT_CHUNK_SIZE : _options$chunkSize;\n          byteOffset = 0;\n\n        case 3:\n          if (!(byteOffset < arrayBuffer.byteLength)) {\n            _context.next = 14;\n            break;\n          }\n\n          chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n          chunk = new ArrayBuffer(chunkByteLength);\n          sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n          chunkArray = new Uint8Array(chunk);\n          chunkArray.set(sourceArray);\n          byteOffset += chunkByteLength;\n          _context.next = 12;\n          return chunk;\n\n        case 12:\n          _context.next = 3;\n          break;\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}","map":{"version":3,"sources":["../../../../src/iterators/make-iterator/make-array-buffer-iterator.ts"],"names":["DEFAULT_CHUNK_SIZE","options","chunkSize","byteOffset","arrayBuffer","chunkByteLength","Math","chunk","sourceArray","chunkArray"],"mappings":";;oDAUO,uB;;AARP,IAAMA,kBAAkB,GAAG,MAA3B,IAAA;AAQA,OAAO,SAAA,uBAAA,CAAA,WAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAELC,UAAAA,OAFK,2DAAA,EAAA;AAAA,+BAIL,OAJK,CAIEC,SAJF,EAIEA,SAJF,mCAIcF,kBAJd;AAMDG,UAAAA,UANC,GAML,CANK;;AAAA;AAAA,gBAQEA,UAAU,GAAGC,WAAW,CAA/B,UARK;AAAA;AAAA;AAAA;;AAUGC,UAAAA,eAVH,GAUqBC,IAAI,CAAJA,GAAAA,CAASF,WAAW,CAAXA,UAAAA,GAATE,UAAAA,EAAxB,SAAwBA,CAVrB;AAWGC,UAAAA,KAXH,GAWW,IAAA,WAAA,CAAd,eAAc,CAXX;AAcGC,UAAAA,WAdH,GAciB,IAAA,UAAA,CAAA,WAAA,EAAA,UAAA,EAApB,eAAoB,CAdjB;AAeGC,UAAAA,UAfH,GAegB,IAAA,UAAA,CAAnB,KAAmB,CAfhB;AAgBHA,UAAAA,UAAU,CAAVA,GAAAA,CAAAA,WAAAA;AAGAN,UAAAA,UAAU,IAAVA,eAAAA;AAnBG;AAoBH,iBAAA,KAAA;;AApBG;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import type {IteratorOptions} from './make-iterator';\n\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n\n/**\n * Returns an iterator that breaks a big ArrayBuffer into chunks and yields them one-by-one\n * @param blob ArrayBuffer to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeArrayBufferIterator(\n  arrayBuffer: ArrayBuffer,\n  options: IteratorOptions = {}\n): Iterable<ArrayBuffer> {\n  const {chunkSize = DEFAULT_CHUNK_SIZE} = options;\n\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    // Create a chunk of the right size\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    // Copy data from the big chunk\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    // yield the chunk\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}