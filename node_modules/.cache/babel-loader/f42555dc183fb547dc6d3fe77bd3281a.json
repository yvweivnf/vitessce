{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\wkuo\\\\Documents\\\\vitessce-forked-v1.2.2\\\\vitessce\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { log } from '@deck.gl/core';\nimport { Geometry, uid } from '@luma.gl/core';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\n\nvar ColumnGeometry = /*#__PURE__*/function (_Geometry) {\n  _inherits(ColumnGeometry, _Geometry);\n\n  var _super = _createSuper(ColumnGeometry);\n\n  function ColumnGeometry() {\n    _classCallCheck(this, ColumnGeometry);\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('column-geometry') : _props$id;\n\n    var _tesselateColumn = tesselateColumn(props),\n        indices = _tesselateColumn.indices,\n        attributes = _tesselateColumn.attributes;\n\n    return _super.call(this, _objectSpread({}, props, {\n      id: id,\n      indices: indices,\n      attributes: attributes\n    }));\n  }\n\n  return ColumnGeometry;\n}(Geometry);\n\nexport { ColumnGeometry as default };\n\nfunction tesselateColumn(props) {\n  var radius = props.radius,\n      _props$height = props.height,\n      height = _props$height === void 0 ? 1 : _props$height,\n      _props$nradial = props.nradial,\n      nradial = _props$nradial === void 0 ? 10 : _props$nradial;\n  var vertices = props.vertices;\n\n  if (vertices) {\n    log.assert(vertices.length >= nradial);\n    vertices = vertices.flatMap(function (v) {\n      return [v[0], v[1]];\n    });\n    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);\n  }\n\n  var isExtruded = height > 0;\n  var vertsAroundEdge = nradial + 1;\n  var numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;\n  var stepAngle = Math.PI * 2 / nradial;\n  var indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);\n  var positions = new Float32Array(numVertices * 3);\n  var normals = new Float32Array(numVertices * 3);\n  var i = 0;\n\n  if (isExtruded) {\n    for (var j = 0; j < vertsAroundEdge; j++) {\n      var a = j * stepAngle;\n      var vertexIndex = j % nradial;\n      var sin = Math.sin(a);\n      var cos = Math.cos(a);\n\n      for (var k = 0; k < 2; k++) {\n        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n        positions[i + 2] = (1 / 2 - k) * height;\n        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;\n        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;\n        i += 3;\n      }\n    }\n\n    positions[i + 0] = positions[i - 3];\n    positions[i + 1] = positions[i - 2];\n    positions[i + 2] = positions[i - 1];\n    i += 3;\n  }\n\n  for (var _j = isExtruded ? 0 : 1; _j < vertsAroundEdge; _j++) {\n    var v = Math.floor(_j / 2) * Math.sign(0.5 - _j % 2);\n\n    var _a = v * stepAngle;\n\n    var _vertexIndex = (v + nradial) % nradial;\n\n    var _sin = Math.sin(_a);\n\n    var _cos = Math.cos(_a);\n\n    positions[i + 0] = vertices ? vertices[_vertexIndex * 2] : _cos * radius;\n    positions[i + 1] = vertices ? vertices[_vertexIndex * 2 + 1] : _sin * radius;\n    positions[i + 2] = height / 2;\n    normals[i + 2] = 1;\n    i += 3;\n  }\n\n  if (isExtruded) {\n    var index = 0;\n\n    for (var _j2 = 0; _j2 < nradial; _j2++) {\n      indices[index++] = _j2 * 2 + 0;\n      indices[index++] = _j2 * 2 + 2;\n      indices[index++] = _j2 * 2 + 0;\n      indices[index++] = _j2 * 2 + 1;\n      indices[index++] = _j2 * 2 + 1;\n      indices[index++] = _j2 * 2 + 3;\n    }\n  }\n\n  return {\n    indices: indices,\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      }\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/column-layer/column-geometry.js"],"names":["constructor","props","id","uid","attributes","tesselateColumn","indices","height","nradial","vertices","log","v","modifyPolygonWindingDirection","WINDING","isExtruded","vertsAroundEdge","numVertices","stepAngle","Math","positions","normals","i","j","a","vertexIndex","sin","cos","k","index","POSITION","size","value","NORMAL"],"mappings":"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","sourcesContent":["import {log} from '@deck.gl/core';\nimport {Geometry, uid} from '@luma.gl/core';\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\nexport default class ColumnGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('column-geometry')} = props;\n    const {indices, attributes} = tesselateColumn(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateColumn(props) {\n  const {radius, height = 1, nradial = 10} = props;\n  let {vertices} = props;\n\n  if (vertices) {\n    log.assert(vertices.length >= nradial); // `vertices` must contain at least `diskResolution` points\n    vertices = vertices.flatMap(v => [v[0], v[1]]);\n    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);\n  }\n\n  const isExtruded = height > 0;\n  const vertsAroundEdge = nradial + 1; // loop\n  const numVertices = isExtruded\n    ? vertsAroundEdge * 3 + 1 // top, side top edge, side bottom edge, one additional degenerage vertex\n    : nradial; // top\n\n  const stepAngle = (Math.PI * 2) / nradial;\n\n  // Used for wireframe\n  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0); // top loop, side vertical, bottom loop\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n\n  let i = 0;\n\n  // side tesselation: 0, 1, 2, 3, 4, 5, ...\n  //\n  // 0 - 2 - 4  ... top\n  // | / | / |\n  // 1 - 3 - 5  ... bottom\n  //\n  if (isExtruded) {\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const a = j * stepAngle;\n      const vertexIndex = j % nradial;\n      const sin = Math.sin(a);\n      const cos = Math.cos(a);\n\n      for (let k = 0; k < 2; k++) {\n        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n        positions[i + 2] = (1 / 2 - k) * height;\n\n        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;\n        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;\n\n        i += 3;\n      }\n    }\n\n    // duplicate the last vertex to create proper degenerate triangle.\n    positions[i + 0] = positions[i - 3];\n    positions[i + 1] = positions[i - 2];\n    positions[i + 2] = positions[i - 1];\n    i += 3;\n  }\n\n  // The column geometry is rendered as a triangle strip, so\n  // in order to render sides and top in one go we need to use degenerate triangles.\n  // Duplicate last vertex of side trinagles and first vertex of the top cap to preserve winding order.\n\n  // top tesselation: 0, -1, 1, -2, 2, -3, 3, ...\n  //\n  //    0 -- 1\n  //   /      \\\n  // -1        2\n  //  |        |\n  // -2        3\n  //   \\      /\n  //   -3 -- 4\n  //\n  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign(0.5 - (j % 2));\n    const a = v * stepAngle;\n    const vertexIndex = (v + nradial) % nradial;\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n    positions[i + 2] = height / 2;\n\n    normals[i + 2] = 1;\n\n    i += 3;\n  }\n\n  if (isExtruded) {\n    let index = 0;\n    for (let j = 0; j < nradial; j++) {\n      // top loop\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 2;\n      // side vertical\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 1;\n      // bottom loop\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 3;\n    }\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals}\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}