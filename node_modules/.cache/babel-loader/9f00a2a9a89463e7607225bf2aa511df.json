{"ast":null,"code":"import { Transform, isTuple, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { inherits, error, array, one, truthy, hasOwnProperty } from 'vega-util';\nimport { hierarchy, pack, partition, stratify, tree, cluster, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from 'd3-hierarchy'; // Build lookup table mapping tuple keys to tree node instances\n\nfunction lookup(tree, key, filter) {\n  var map = {};\n  tree.each(function (node) {\n    var t = node.data;\n    if (filter(t)) map[key(t)] = node;\n  });\n  tree.lookup = map;\n  return tree;\n}\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\n\nfunction Nest(params) {\n  Transform.call(this, null, params);\n}\n\nNest.Definition = {\n  'type': 'Nest',\n  'metadata': {\n    'treesource': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'keys',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'generate',\n    'type': 'boolean'\n  }]\n};\n\nvar children = function children(n) {\n  return n.values;\n};\n\ninherits(Nest, Transform, {\n  transform: function transform(_, pulse) {\n    if (!pulse.source) {\n      error('Nest transform requires an upstream data source.');\n    }\n\n    var gen = _.generate,\n        mod = _.modified(),\n        out = pulse.clone(),\n        tree = this.value;\n\n    if (!tree || mod || pulse.changed()) {\n      // collect nodes to remove\n      if (tree) {\n        tree.each(function (node) {\n          if (node.children && isTuple(node.data)) {\n            out.rem.push(node.data);\n          }\n        });\n      } // generate new tree structure\n\n\n      this.value = tree = hierarchy({\n        values: array(_.keys).reduce(function (n, k) {\n          n.key(k);\n          return n;\n        }, nest()).entries(out.source)\n      }, children); // collect nodes to add\n\n      if (gen) {\n        tree.each(function (node) {\n          if (node.children) {\n            node = ingest(node.data);\n            out.add.push(node);\n            out.source.push(node);\n          }\n        });\n      } // build lookup table\n\n\n      lookup(tree, tupleid, tupleid);\n    }\n\n    out.source.root = tree;\n    return out;\n  }\n});\n\nfunction nest() {\n  var keys = [],\n      nest = {\n    entries: function entries(array) {\n      return _entries(apply(array, 0), 0);\n    },\n    key: function key(d) {\n      return keys.push(d), nest;\n    }\n  };\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    var n = array.length,\n        key = keys[depth++],\n        valuesByKey = {},\n        result = {};\n    var i = -1,\n        keyValue,\n        value,\n        values;\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function _entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array = [];\n\n    for (var key in map) {\n      array.push({\n        key: key,\n        values: _entries(map[key], depth)\n      });\n    }\n\n    return array;\n  }\n\n  return nest;\n}\n/**\n * Abstract class for tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction HierarchyLayout(params) {\n  Transform.call(this, null, params);\n}\n\nvar defaultSeparation = function defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n};\n\ninherits(HierarchyLayout, Transform, {\n  transform: function transform(_, pulse) {\n    if (!pulse.source || !pulse.source.root) {\n      error(this.constructor.name + ' transform requires a backing tree data source.');\n    }\n\n    var layout = this.layout(_.method),\n        fields = this.fields,\n        root = pulse.source.root,\n        as = _.as || fields;\n    if (_.field) root.sum(_.field);else root.count();\n    if (_.sort) root.sort(stableCompare(_.sort, function (d) {\n      return d.data;\n    }));\n    setParams(layout, this.params, _);\n\n    if (layout.separation) {\n      layout.separation(_.separation !== false ? defaultSeparation : one);\n    }\n\n    try {\n      this.value = layout(root);\n    } catch (err) {\n      error(err);\n    }\n\n    root.each(function (node) {\n      return setFields(node, fields, as);\n    });\n    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n  }\n});\n\nfunction setParams(layout, params, _) {\n  for (var p, i = 0, n = params.length; i < n; ++i) {\n    p = params[i];\n    if (p in _) layout[p](_[p]);\n  }\n}\n\nfunction setFields(node, fields, as) {\n  var t = node.data,\n      n = fields.length - 1;\n\n  for (var i = 0; i < n; ++i) {\n    t[as[i]] = node[fields[i]];\n  }\n\n  t[as[n]] = node.children ? node.children.length : 0;\n}\n\nvar Output = ['x', 'y', 'r', 'depth', 'children'];\n/**\n * Packed circle tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Pack(params) {\n  HierarchyLayout.call(this, params);\n}\n\nPack.Definition = {\n  'type': 'Pack',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'radius',\n    'type': 'field',\n    'default': null\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output.length,\n    'default': Output\n  }]\n};\ninherits(Pack, HierarchyLayout, {\n  layout: pack,\n  params: ['radius', 'size', 'padding'],\n  fields: Output\n});\nvar Output$1 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Partition tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Partition(params) {\n  HierarchyLayout.call(this, params);\n}\n\nPartition.Definition = {\n  'type': 'Partition',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$1.length,\n    'default': Output$1\n  }]\n};\ninherits(Partition, HierarchyLayout, {\n  layout: partition,\n  params: ['size', 'round', 'padding'],\n  fields: Output$1\n});\n/**\n * Stratify a collection of tuples into a tree structure based on\n * id and parent id fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.key - Unique key field for each tuple.\n * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n */\n\nfunction Stratify(params) {\n  Transform.call(this, null, params);\n}\n\nStratify.Definition = {\n  'type': 'Stratify',\n  'metadata': {\n    'treesource': true\n  },\n  'params': [{\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'parentKey',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Stratify, Transform, {\n  transform: function transform(_, pulse) {\n    if (!pulse.source) {\n      error('Stratify transform requires an upstream data source.');\n    }\n\n    var tree = this.value;\n\n    var mod = _.modified(),\n        out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n        run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution\n\n\n    out.source = out.source.slice();\n\n    if (run) {\n      tree = out.source.length ? lookup(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup(stratify()([{}]), _.key, _.key);\n    }\n\n    out.source.root = this.value = tree;\n    return out;\n  }\n});\nvar Layouts = {\n  tidy: tree,\n  cluster: cluster\n};\nvar Output$2 = ['x', 'y', 'depth', 'children'];\n/**\n * Tree layout. Depending on the method parameter, performs either\n * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Tree(params) {\n  HierarchyLayout.call(this, params);\n}\n\nTree.Definition = {\n  'type': 'Tree',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'tidy',\n    'values': ['tidy', 'cluster']\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'nodeSize',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'separation',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$2.length,\n    'default': Output$2\n  }]\n};\ninherits(Tree, HierarchyLayout, {\n  /**\n   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n   */\n  layout: function layout(method) {\n    var m = method || 'tidy';\n    if (hasOwnProperty(Layouts, m)) return Layouts[m]();else error('Unrecognized Tree layout method: ' + m);\n  },\n  params: ['size', 'nodeSize'],\n  fields: Output$2\n});\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction TreeLinks(params) {\n  Transform.call(this, [], params);\n}\n\nTreeLinks.Definition = {\n  'type': 'TreeLinks',\n  'metadata': {\n    'tree': true,\n    'generates': true,\n    'changes': true\n  },\n  'params': []\n};\ninherits(TreeLinks, Transform, {\n  transform: function transform(_, pulse) {\n    var links = this.value,\n        tree = pulse.source && pulse.source.root,\n        out = pulse.fork(pulse.NO_SOURCE),\n        lut = {};\n    if (!tree) error('TreeLinks transform requires a tree data source.');\n\n    if (pulse.changed(pulse.ADD_REM)) {\n      // remove previous links\n      out.rem = links; // build lookup table of valid tuples\n\n      pulse.visit(pulse.SOURCE, function (t) {\n        return lut[tupleid(t)] = 1;\n      }); // generate links for all edges incident on valid tuples\n\n      tree.each(function (node) {\n        var t = node.data,\n            p = node.parent && node.parent.data;\n\n        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n          out.add.push(ingest({\n            source: p,\n            target: t\n          }));\n        }\n      });\n      this.value = out.add;\n    } else if (pulse.changed(pulse.MOD)) {\n      // build lookup table of modified tuples\n      pulse.visit(pulse.MOD, function (t) {\n        return lut[tupleid(t)] = 1;\n      }); // gather links incident on modified tuples\n\n      links.forEach(function (link) {\n        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n          out.mod.push(link);\n        }\n      });\n    }\n\n    return out;\n  }\n});\nvar Tiles = {\n  binary: treemapBinary,\n  dice: treemapDice,\n  slice: treemapSlice,\n  slicedice: treemapSliceDice,\n  squarify: treemapSquarify,\n  resquarify: treemapResquarify\n};\nvar Output$3 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Treemap layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Treemap(params) {\n  HierarchyLayout.call(this, params);\n}\n\nTreemap.Definition = {\n  'type': 'Treemap',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'squarify',\n    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingInner',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingOuter',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingTop',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingRight',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingBottom',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingLeft',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'ratio',\n    'type': 'number',\n    'default': 1.618033988749895\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$3.length,\n    'default': Output$3\n  }]\n};\ninherits(Treemap, HierarchyLayout, {\n  /**\n   * Treemap layout generator. Adds 'method' and 'ratio' parameters\n   * to configure the underlying tile method.\n   */\n  layout: function layout() {\n    var x = treemap();\n\n    x.ratio = function (_) {\n      var t = x.tile();\n      if (t.ratio) x.tile(t.ratio(_));\n    };\n\n    x.method = function (_) {\n      if (hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);else error('Unrecognized Treemap layout method: ' + _);\n    };\n\n    return x;\n  },\n  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],\n  fields: Output$3\n});\nexport { Nest as nest, Pack as pack, Partition as partition, Stratify as stratify, Tree as tree, TreeLinks as treelinks, Treemap as treemap };","map":{"version":3,"sources":["C:/Users/wkuo/Documents/vitessce-forked-v1.2.2/vitessce/node_modules/vega-hierarchy/build/vega-hierarchy.module.js"],"names":["Transform","isTuple","ingest","tupleid","stableCompare","inherits","error","array","one","truthy","hasOwnProperty","hierarchy","pack","partition","stratify","tree","cluster","treemap","treemapBinary","treemapDice","treemapSlice","treemapSliceDice","treemapSquarify","treemapResquarify","lookup","key","filter","map","each","node","t","data","Nest","params","call","Definition","children","n","values","transform","_","pulse","source","gen","generate","mod","modified","out","clone","value","changed","rem","push","keys","reduce","k","nest","entries","add","root","apply","d","depth","length","valuesByKey","result","i","keyValue","HierarchyLayout","defaultSeparation","a","b","parent","constructor","name","layout","method","fields","as","field","sum","count","sort","setParams","separation","err","setFields","reflow","modifies","p","Output","Pack","Output$1","Partition","Stratify","fork","ALL","materialize","SOURCE","run","ADD_REM","parentKey","slice","id","parentId","Layouts","tidy","Output$2","Tree","m","TreeLinks","links","NO_SOURCE","lut","visit","target","MOD","forEach","link","Tiles","binary","dice","slicedice","squarify","resquarify","Output$3","Treemap","x","ratio","tile","treelinks"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,OAApB,EAA6BC,MAA7B,EAAqCC,OAArC,EAA8CC,aAA9C,QAAmE,eAAnE;AACA,SAASC,QAAT,EAAmBC,KAAnB,EAA0BC,KAA1B,EAAiCC,GAAjC,EAAsCC,MAAtC,EAA8CC,cAA9C,QAAoE,WAApE;AACA,SAASC,SAAT,EAAoBC,IAApB,EAA0BC,SAA1B,EAAqCC,QAArC,EAA+CC,IAA/C,EAAqDC,OAArD,EAA8DC,OAA9D,EAAuEC,aAAvE,EAAsFC,WAAtF,EAAmGC,YAAnG,EAAiHC,gBAAjH,EAAmIC,eAAnI,EAAoJC,iBAApJ,QAA6K,cAA7K,C,CAEA;;AACA,SAASC,MAAT,CAAiBT,IAAjB,EAAuBU,GAAvB,EAA4BC,MAA5B,EAAoC;AAClC,MAAMC,GAAG,GAAG,EAAZ;AACAZ,EAAAA,IAAI,CAACa,IAAL,CAAU,UAAAC,IAAI,EAAI;AAChB,QAAMC,CAAC,GAAGD,IAAI,CAACE,IAAf;AACA,QAAIL,MAAM,CAACI,CAAD,CAAV,EAAeH,GAAG,CAACF,GAAG,CAACK,CAAD,CAAJ,CAAH,GAAcD,IAAd;AAChB,GAHD;AAIAd,EAAAA,IAAI,CAACS,MAAL,GAAcG,GAAd;AACA,SAAOZ,IAAP;AACD;AAED;;;;;;;;;;;;AAWA,SAASiB,IAAT,CAAcC,MAAd,EAAsB;AACpBjC,EAAAA,SAAS,CAACkC,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDD,IAAI,CAACG,UAAL,GAAkB;AAChB,UAAQ,MADQ;AAEhB,cAAY;AACV,kBAAc,IADJ;AAEV,eAAW;AAFD,GAFI;AAMhB,YAAU,CAAC;AACT,YAAQ,MADC;AAET,YAAQ,OAFC;AAGT,aAAS;AAHA,GAAD,EAIP;AACD,YAAQ,UADP;AAED,YAAQ;AAFP,GAJO;AANM,CAAlB;;AAgBA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAC,CAAC;AAAA,SAAIA,CAAC,CAACC,MAAN;AAAA,CAAlB;;AAEAjC,QAAQ,CAAC2B,IAAD,EAAOhC,SAAP,EAAkB;AACxBuC,EAAAA,SADwB,qBACdC,CADc,EACXC,KADW,EACJ;AAClB,QAAI,CAACA,KAAK,CAACC,MAAX,EAAmB;AACjBpC,MAAAA,KAAK,CAAC,kDAAD,CAAL;AACD;;AAED,QAAIqC,GAAG,GAAGH,CAAC,CAACI,QAAZ;AAAA,QACIC,GAAG,GAAGL,CAAC,CAACM,QAAF,EADV;AAAA,QAEIC,GAAG,GAAGN,KAAK,CAACO,KAAN,EAFV;AAAA,QAGIjC,IAAI,GAAG,KAAKkC,KAHhB;;AAKA,QAAI,CAAClC,IAAD,IAAS8B,GAAT,IAAgBJ,KAAK,CAACS,OAAN,EAApB,EAAqC;AACnC;AACA,UAAInC,IAAJ,EAAU;AACRA,QAAAA,IAAI,CAACa,IAAL,CAAU,UAAAC,IAAI,EAAI;AAChB,cAAIA,IAAI,CAACO,QAAL,IAAiBnC,OAAO,CAAC4B,IAAI,CAACE,IAAN,CAA5B,EAAyC;AACvCgB,YAAAA,GAAG,CAACI,GAAJ,CAAQC,IAAR,CAAavB,IAAI,CAACE,IAAlB;AACD;AACF,SAJD;AAKD,OARkC,CAQjC;;;AAGF,WAAKkB,KAAL,GAAalC,IAAI,GAAGJ,SAAS,CAAC;AAC5B2B,QAAAA,MAAM,EAAE/B,KAAK,CAACiC,CAAC,CAACa,IAAH,CAAL,CAAcC,MAAd,CAAqB,UAACjB,CAAD,EAAIkB,CAAJ,EAAU;AACrClB,UAAAA,CAAC,CAACZ,GAAF,CAAM8B,CAAN;AACA,iBAAOlB,CAAP;AACD,SAHO,EAGLmB,IAAI,EAHC,EAGGC,OAHH,CAGWV,GAAG,CAACL,MAHf;AADoB,OAAD,EAK1BN,QAL0B,CAA7B,CAXmC,CAgBrB;;AAEd,UAAIO,GAAJ,EAAS;AACP5B,QAAAA,IAAI,CAACa,IAAL,CAAU,UAAAC,IAAI,EAAI;AAChB,cAAIA,IAAI,CAACO,QAAT,EAAmB;AACjBP,YAAAA,IAAI,GAAG3B,MAAM,CAAC2B,IAAI,CAACE,IAAN,CAAb;AACAgB,YAAAA,GAAG,CAACW,GAAJ,CAAQN,IAAR,CAAavB,IAAb;AACAkB,YAAAA,GAAG,CAACL,MAAJ,CAAWU,IAAX,CAAgBvB,IAAhB;AACD;AACF,SAND;AAOD,OA1BkC,CA0BjC;;;AAGFL,MAAAA,MAAM,CAACT,IAAD,EAAOZ,OAAP,EAAgBA,OAAhB,CAAN;AACD;;AAED4C,IAAAA,GAAG,CAACL,MAAJ,CAAWiB,IAAX,GAAkB5C,IAAlB;AACA,WAAOgC,GAAP;AACD;AA7CuB,CAAlB,CAAR;;AAiDA,SAASS,IAAT,GAAgB;AACd,MAAMH,IAAI,GAAG,EAAb;AAAA,MACMG,IAAI,GAAG;AACXC,IAAAA,OAAO,EAAE,iBAAAlD,KAAK;AAAA,aAAIkD,QAAO,CAACG,KAAK,CAACrD,KAAD,EAAQ,CAAR,CAAN,EAAkB,CAAlB,CAAX;AAAA,KADH;AAEXkB,IAAAA,GAAG,EAAE,aAAAoC,CAAC;AAAA,aAAKR,IAAI,CAACD,IAAL,CAAUS,CAAV,GAAcL,IAAnB;AAAA;AAFK,GADb;;AAMA,WAASI,KAAT,CAAerD,KAAf,EAAsBuD,KAAtB,EAA6B;AAC3B,QAAIA,KAAK,IAAIT,IAAI,CAACU,MAAlB,EAA0B;AACxB,aAAOxD,KAAP;AACD;;AAED,QAAM8B,CAAC,GAAG9B,KAAK,CAACwD,MAAhB;AAAA,QACMtC,GAAG,GAAG4B,IAAI,CAACS,KAAK,EAAN,CADhB;AAAA,QAEME,WAAW,GAAG,EAFpB;AAAA,QAGMC,MAAM,GAAG,EAHf;AAIA,QAAIC,CAAC,GAAG,CAAC,CAAT;AAAA,QACIC,QADJ;AAAA,QAEIlB,KAFJ;AAAA,QAGIX,MAHJ;;AAKA,WAAO,EAAE4B,CAAF,GAAM7B,CAAb,EAAgB;AACd8B,MAAAA,QAAQ,GAAG1C,GAAG,CAACwB,KAAK,GAAG1C,KAAK,CAAC2D,CAAD,CAAd,CAAH,GAAwB,EAAnC;;AAEA,UAAI5B,MAAM,GAAG0B,WAAW,CAACG,QAAD,CAAxB,EAAoC;AAClC7B,QAAAA,MAAM,CAACc,IAAP,CAAYH,KAAZ;AACD,OAFD,MAEO;AACLe,QAAAA,WAAW,CAACG,QAAD,CAAX,GAAwB,CAAClB,KAAD,CAAxB;AACD;AACF;;AAED,SAAKkB,QAAL,IAAiBH,WAAjB,EAA8B;AAC5BC,MAAAA,MAAM,CAACE,QAAD,CAAN,GAAmBP,KAAK,CAACI,WAAW,CAACG,QAAD,CAAZ,EAAwBL,KAAxB,CAAxB;AACD;;AAED,WAAOG,MAAP;AACD;;AAED,WAASR,QAAT,CAAiB9B,GAAjB,EAAsBmC,KAAtB,EAA6B;AAC3B,QAAI,EAAEA,KAAF,GAAUT,IAAI,CAACU,MAAnB,EAA2B,OAAOpC,GAAP;AAC3B,QAAMpB,KAAK,GAAG,EAAd;;AAEA,SAAK,IAAMkB,GAAX,IAAkBE,GAAlB,EAAuB;AACrBpB,MAAAA,KAAK,CAAC6C,IAAN,CAAW;AACT3B,QAAAA,GAAG,EAAHA,GADS;AAETa,QAAAA,MAAM,EAAEmB,QAAO,CAAC9B,GAAG,CAACF,GAAD,CAAJ,EAAWqC,KAAX;AAFN,OAAX;AAID;;AAED,WAAOvD,KAAP;AACD;;AAED,SAAOiD,IAAP;AACD;AAED;;;;;;;AAMA,SAASY,eAAT,CAAyBnC,MAAzB,EAAiC;AAC/BjC,EAAAA,SAAS,CAACkC,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AAED,IAAMoC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,CAAD,EAAIC,CAAJ;AAAA,SAAUD,CAAC,CAACE,MAAF,KAAaD,CAAC,CAACC,MAAf,GAAwB,CAAxB,GAA4B,CAAtC;AAAA,CAA1B;;AAEAnE,QAAQ,CAAC+D,eAAD,EAAkBpE,SAAlB,EAA6B;AACnCuC,EAAAA,SADmC,qBACzBC,CADyB,EACtBC,KADsB,EACf;AAClB,QAAI,CAACA,KAAK,CAACC,MAAP,IAAiB,CAACD,KAAK,CAACC,MAAN,CAAaiB,IAAnC,EAAyC;AACvCrD,MAAAA,KAAK,CAAC,KAAKmE,WAAL,CAAiBC,IAAjB,GAAwB,iDAAzB,CAAL;AACD;;AAED,QAAMC,MAAM,GAAG,KAAKA,MAAL,CAAYnC,CAAC,CAACoC,MAAd,CAAf;AAAA,QACMC,MAAM,GAAG,KAAKA,MADpB;AAAA,QAEMlB,IAAI,GAAGlB,KAAK,CAACC,MAAN,CAAaiB,IAF1B;AAAA,QAGMmB,EAAE,GAAGtC,CAAC,CAACsC,EAAF,IAAQD,MAHnB;AAIA,QAAIrC,CAAC,CAACuC,KAAN,EAAapB,IAAI,CAACqB,GAAL,CAASxC,CAAC,CAACuC,KAAX,EAAb,KAAoCpB,IAAI,CAACsB,KAAL;AACpC,QAAIzC,CAAC,CAAC0C,IAAN,EAAYvB,IAAI,CAACuB,IAAL,CAAU9E,aAAa,CAACoC,CAAC,CAAC0C,IAAH,EAAS,UAAArB,CAAC;AAAA,aAAIA,CAAC,CAAC9B,IAAN;AAAA,KAAV,CAAvB;AACZoD,IAAAA,SAAS,CAACR,MAAD,EAAS,KAAK1C,MAAd,EAAsBO,CAAtB,CAAT;;AAEA,QAAImC,MAAM,CAACS,UAAX,EAAuB;AACrBT,MAAAA,MAAM,CAACS,UAAP,CAAkB5C,CAAC,CAAC4C,UAAF,KAAiB,KAAjB,GAAyBf,iBAAzB,GAA6C7D,GAA/D;AACD;;AAED,QAAI;AACF,WAAKyC,KAAL,GAAa0B,MAAM,CAAChB,IAAD,CAAnB;AACD,KAFD,CAEE,OAAO0B,GAAP,EAAY;AACZ/E,MAAAA,KAAK,CAAC+E,GAAD,CAAL;AACD;;AAED1B,IAAAA,IAAI,CAAC/B,IAAL,CAAU,UAAAC,IAAI;AAAA,aAAIyD,SAAS,CAACzD,IAAD,EAAOgD,MAAP,EAAeC,EAAf,CAAb;AAAA,KAAd;AACA,WAAOrC,KAAK,CAAC8C,MAAN,CAAa/C,CAAC,CAACM,QAAF,EAAb,EAA2B0C,QAA3B,CAAoCV,EAApC,EAAwCU,QAAxC,CAAiD,MAAjD,CAAP;AACD;AA1BkC,CAA7B,CAAR;;AA8BA,SAASL,SAAT,CAAmBR,MAAnB,EAA2B1C,MAA3B,EAAmCO,CAAnC,EAAsC;AACpC,OAAK,IAAIiD,CAAJ,EAAOvB,CAAC,GAAG,CAAX,EAAc7B,CAAC,GAAGJ,MAAM,CAAC8B,MAA9B,EAAsCG,CAAC,GAAG7B,CAA1C,EAA6C,EAAE6B,CAA/C,EAAkD;AAChDuB,IAAAA,CAAC,GAAGxD,MAAM,CAACiC,CAAD,CAAV;AACA,QAAIuB,CAAC,IAAIjD,CAAT,EAAYmC,MAAM,CAACc,CAAD,CAAN,CAAUjD,CAAC,CAACiD,CAAD,CAAX;AACb;AACF;;AAED,SAASH,SAAT,CAAmBzD,IAAnB,EAAyBgD,MAAzB,EAAiCC,EAAjC,EAAqC;AACnC,MAAMhD,CAAC,GAAGD,IAAI,CAACE,IAAf;AAAA,MACMM,CAAC,GAAGwC,MAAM,CAACd,MAAP,GAAgB,CAD1B;;AAGA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7B,CAApB,EAAuB,EAAE6B,CAAzB,EAA4B;AAC1BpC,IAAAA,CAAC,CAACgD,EAAE,CAACZ,CAAD,CAAH,CAAD,GAAWrC,IAAI,CAACgD,MAAM,CAACX,CAAD,CAAP,CAAf;AACD;;AAEDpC,EAAAA,CAAC,CAACgD,EAAE,CAACzC,CAAD,CAAH,CAAD,GAAWR,IAAI,CAACO,QAAL,GAAgBP,IAAI,CAACO,QAAL,CAAc2B,MAA9B,GAAuC,CAAlD;AACD;;AAED,IAAM2B,MAAM,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,OAAhB,EAAyB,UAAzB,CAAf;AACA;;;;;;;AAOA,SAASC,IAAT,CAAc1D,MAAd,EAAsB;AACpBmC,EAAAA,eAAe,CAAClC,IAAhB,CAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD0D,IAAI,CAACxD,UAAL,GAAkB;AAChB,UAAQ,MADQ;AAEhB,cAAY;AACV,YAAQ,IADE;AAEV,gBAAY;AAFF,GAFI;AAMhB,YAAU,CAAC;AACT,YAAQ,OADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,MADP;AAED,YAAQ;AAFP,GAHO,EAMP;AACD,YAAQ,SADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GANO,EAUP;AACD,YAAQ,QADP;AAED,YAAQ,OAFP;AAGD,eAAW;AAHV,GAVO,EAcP;AACD,YAAQ,MADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU;AAJT,GAdO,EAmBP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAUuD,MAAM,CAAC3B,MAJhB;AAKD,eAAW2B;AALV,GAnBO;AANM,CAAlB;AAiCArF,QAAQ,CAACsF,IAAD,EAAOvB,eAAP,EAAwB;AAC9BO,EAAAA,MAAM,EAAE/D,IADsB;AAE9BqB,EAAAA,MAAM,EAAE,CAAC,QAAD,EAAW,MAAX,EAAmB,SAAnB,CAFsB;AAG9B4C,EAAAA,MAAM,EAAEa;AAHsB,CAAxB,CAAR;AAMA,IAAME,QAAQ,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,OAAzB,EAAkC,UAAlC,CAAjB;AACA;;;;;;;AAOA,SAASC,SAAT,CAAmB5D,MAAnB,EAA2B;AACzBmC,EAAAA,eAAe,CAAClC,IAAhB,CAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD4D,SAAS,CAAC1D,UAAV,GAAuB;AACrB,UAAQ,WADa;AAErB,cAAY;AACV,YAAQ,IADE;AAEV,gBAAY;AAFF,GAFS;AAMrB,YAAU,CAAC;AACT,YAAQ,OADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,MADP;AAED,YAAQ;AAFP,GAHO,EAMP;AACD,YAAQ,SADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GANO,EAUP;AACD,YAAQ,OADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GAVO,EAcP;AACD,YAAQ,MADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU;AAJT,GAdO,EAmBP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAUyD,QAAQ,CAAC7B,MAJlB;AAKD,eAAW6B;AALV,GAnBO;AANW,CAAvB;AAiCAvF,QAAQ,CAACwF,SAAD,EAAYzB,eAAZ,EAA6B;AACnCO,EAAAA,MAAM,EAAE9D,SAD2B;AAEnCoB,EAAAA,MAAM,EAAE,CAAC,MAAD,EAAS,OAAT,EAAkB,SAAlB,CAF2B;AAGnC4C,EAAAA,MAAM,EAAEe;AAH2B,CAA7B,CAAR;AAMA;;;;;;;;;AASA,SAASE,QAAT,CAAkB7D,MAAlB,EAA0B;AACxBjC,EAAAA,SAAS,CAACkC,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD6D,QAAQ,CAAC3D,UAAT,GAAsB;AACpB,UAAQ,UADY;AAEpB,cAAY;AACV,kBAAc;AADJ,GAFQ;AAKpB,YAAU,CAAC;AACT,YAAQ,KADC;AAET,YAAQ,OAFC;AAGT,gBAAY;AAHH,GAAD,EAIP;AACD,YAAQ,WADP;AAED,YAAQ,OAFP;AAGD,gBAAY;AAHX,GAJO;AALU,CAAtB;AAeA9B,QAAQ,CAACyF,QAAD,EAAW9F,SAAX,EAAsB;AAC5BuC,EAAAA,SAD4B,qBAClBC,CADkB,EACfC,KADe,EACR;AAClB,QAAI,CAACA,KAAK,CAACC,MAAX,EAAmB;AACjBpC,MAAAA,KAAK,CAAC,sDAAD,CAAL;AACD;;AAED,QAAIS,IAAI,GAAG,KAAKkC,KAAhB;;AAEA,QAAMJ,GAAG,GAAGL,CAAC,CAACM,QAAF,EAAZ;AAAA,QACMC,GAAG,GAAGN,KAAK,CAACsD,IAAN,CAAWtD,KAAK,CAACuD,GAAjB,EAAsBC,WAAtB,CAAkCxD,KAAK,CAACyD,MAAxC,CADZ;AAAA,QAEMC,GAAG,GAAG,CAACpF,IAAD,IAAS8B,GAAT,IAAgBJ,KAAK,CAACS,OAAN,CAAcT,KAAK,CAAC2D,OAApB,CAAhB,IAAgD3D,KAAK,CAACK,QAAN,CAAeN,CAAC,CAACf,GAAF,CAAMoD,MAArB,CAAhD,IAAgFpC,KAAK,CAACK,QAAN,CAAeN,CAAC,CAAC6D,SAAF,CAAYxB,MAA3B,CAF5F,CAPkB,CAS8G;;;AAGhI9B,IAAAA,GAAG,CAACL,MAAJ,GAAaK,GAAG,CAACL,MAAJ,CAAW4D,KAAX,EAAb;;AAEA,QAAIH,GAAJ,EAAS;AACPpF,MAAAA,IAAI,GAAGgC,GAAG,CAACL,MAAJ,CAAWqB,MAAX,GAAoBvC,MAAM,CAACV,QAAQ,GAAGyF,EAAX,CAAc/D,CAAC,CAACf,GAAhB,EAAqB+E,QAArB,CAA8BhE,CAAC,CAAC6D,SAAhC,EAA2CtD,GAAG,CAACL,MAA/C,CAAD,EAAyDF,CAAC,CAACf,GAA3D,EAAgEhB,MAAhE,CAA1B,GAAoGe,MAAM,CAACV,QAAQ,GAAG,CAAC,EAAD,CAAH,CAAT,EAAmB0B,CAAC,CAACf,GAArB,EAA0Be,CAAC,CAACf,GAA5B,CAAjH;AACD;;AAEDsB,IAAAA,GAAG,CAACL,MAAJ,CAAWiB,IAAX,GAAkB,KAAKV,KAAL,GAAalC,IAA/B;AACA,WAAOgC,GAAP;AACD;AArB2B,CAAtB,CAAR;AAyBA,IAAM0D,OAAO,GAAG;AACdC,EAAAA,IAAI,EAAE3F,IADQ;AAEdC,EAAAA,OAAO,EAAEA;AAFK,CAAhB;AAIA,IAAM2F,QAAQ,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,OAAX,EAAoB,UAApB,CAAjB;AACA;;;;;;;AAOA,SAASC,IAAT,CAAc3E,MAAd,EAAsB;AACpBmC,EAAAA,eAAe,CAAClC,IAAhB,CAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD2E,IAAI,CAACzE,UAAL,GAAkB;AAChB,UAAQ,MADQ;AAEhB,cAAY;AACV,YAAQ,IADE;AAEV,gBAAY;AAFF,GAFI;AAMhB,YAAU,CAAC;AACT,YAAQ,OADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,MADP;AAED,YAAQ;AAFP,GAHO,EAMP;AACD,YAAQ,QADP;AAED,YAAQ,MAFP;AAGD,eAAW,MAHV;AAID,cAAU,CAAC,MAAD,EAAS,SAAT;AAJT,GANO,EAWP;AACD,YAAQ,MADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU;AAJT,GAXO,EAgBP;AACD,YAAQ,UADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU;AAJT,GAhBO,EAqBP;AACD,YAAQ,YADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GArBO,EAyBP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAUwE,QAAQ,CAAC5C,MAJlB;AAKD,eAAW4C;AALV,GAzBO;AANM,CAAlB;AAuCAtG,QAAQ,CAACuG,IAAD,EAAOxC,eAAP,EAAwB;AAC9B;;;AAGAO,EAAAA,MAJ8B,kBAIvBC,MAJuB,EAIf;AACb,QAAMiC,CAAC,GAAGjC,MAAM,IAAI,MAApB;AACA,QAAIlE,cAAc,CAAC+F,OAAD,EAAUI,CAAV,CAAlB,EAAgC,OAAOJ,OAAO,CAACI,CAAD,CAAP,EAAP,CAAhC,KAAyDvG,KAAK,CAAC,sCAAsCuG,CAAvC,CAAL;AAC1D,GAP6B;AAS9B5E,EAAAA,MAAM,EAAE,CAAC,MAAD,EAAS,UAAT,CATsB;AAU9B4C,EAAAA,MAAM,EAAE8B;AAVsB,CAAxB,CAAR;AAaA;;;;;;;;AAQA,SAASG,SAAT,CAAmB7E,MAAnB,EAA2B;AACzBjC,EAAAA,SAAS,CAACkC,IAAV,CAAe,IAAf,EAAqB,EAArB,EAAyBD,MAAzB;AACD;;AACD6E,SAAS,CAAC3E,UAAV,GAAuB;AACrB,UAAQ,WADa;AAErB,cAAY;AACV,YAAQ,IADE;AAEV,iBAAa,IAFH;AAGV,eAAW;AAHD,GAFS;AAOrB,YAAU;AAPW,CAAvB;AASA9B,QAAQ,CAACyG,SAAD,EAAY9G,SAAZ,EAAuB;AAC7BuC,EAAAA,SAD6B,qBACnBC,CADmB,EAChBC,KADgB,EACT;AAClB,QAAMsE,KAAK,GAAG,KAAK9D,KAAnB;AAAA,QACMlC,IAAI,GAAG0B,KAAK,CAACC,MAAN,IAAgBD,KAAK,CAACC,MAAN,CAAaiB,IAD1C;AAAA,QAEMZ,GAAG,GAAGN,KAAK,CAACsD,IAAN,CAAWtD,KAAK,CAACuE,SAAjB,CAFZ;AAAA,QAGMC,GAAG,GAAG,EAHZ;AAIA,QAAI,CAAClG,IAAL,EAAWT,KAAK,CAAC,kDAAD,CAAL;;AAEX,QAAImC,KAAK,CAACS,OAAN,CAAcT,KAAK,CAAC2D,OAApB,CAAJ,EAAkC;AAChC;AACArD,MAAAA,GAAG,CAACI,GAAJ,GAAU4D,KAAV,CAFgC,CAEf;;AAEjBtE,MAAAA,KAAK,CAACyE,KAAN,CAAYzE,KAAK,CAACyD,MAAlB,EAA0B,UAAApE,CAAC;AAAA,eAAImF,GAAG,CAAC9G,OAAO,CAAC2B,CAAD,CAAR,CAAH,GAAkB,CAAtB;AAAA,OAA3B,EAJgC,CAIqB;;AAErDf,MAAAA,IAAI,CAACa,IAAL,CAAU,UAAAC,IAAI,EAAI;AAChB,YAAMC,CAAC,GAAGD,IAAI,CAACE,IAAf;AAAA,YACM0D,CAAC,GAAG5D,IAAI,CAAC2C,MAAL,IAAe3C,IAAI,CAAC2C,MAAL,CAAYzC,IADrC;;AAGA,YAAI0D,CAAC,IAAIwB,GAAG,CAAC9G,OAAO,CAAC2B,CAAD,CAAR,CAAR,IAAwBmF,GAAG,CAAC9G,OAAO,CAACsF,CAAD,CAAR,CAA/B,EAA6C;AAC3C1C,UAAAA,GAAG,CAACW,GAAJ,CAAQN,IAAR,CAAalD,MAAM,CAAC;AAClBwC,YAAAA,MAAM,EAAE+C,CADU;AAElB0B,YAAAA,MAAM,EAAErF;AAFU,WAAD,CAAnB;AAID;AACF,OAVD;AAWA,WAAKmB,KAAL,GAAaF,GAAG,CAACW,GAAjB;AACD,KAlBD,MAkBO,IAAIjB,KAAK,CAACS,OAAN,CAAcT,KAAK,CAAC2E,GAApB,CAAJ,EAA8B;AACnC;AACA3E,MAAAA,KAAK,CAACyE,KAAN,CAAYzE,KAAK,CAAC2E,GAAlB,EAAuB,UAAAtF,CAAC;AAAA,eAAImF,GAAG,CAAC9G,OAAO,CAAC2B,CAAD,CAAR,CAAH,GAAkB,CAAtB;AAAA,OAAxB,EAFmC,CAEe;;AAElDiF,MAAAA,KAAK,CAACM,OAAN,CAAc,UAAAC,IAAI,EAAI;AACpB,YAAIL,GAAG,CAAC9G,OAAO,CAACmH,IAAI,CAAC5E,MAAN,CAAR,CAAH,IAA6BuE,GAAG,CAAC9G,OAAO,CAACmH,IAAI,CAACH,MAAN,CAAR,CAApC,EAA4D;AAC1DpE,UAAAA,GAAG,CAACF,GAAJ,CAAQO,IAAR,CAAakE,IAAb;AACD;AACF,OAJD;AAKD;;AAED,WAAOvE,GAAP;AACD;AAtC4B,CAAvB,CAAR;AA0CA,IAAMwE,KAAK,GAAG;AACZC,EAAAA,MAAM,EAAEtG,aADI;AAEZuG,EAAAA,IAAI,EAAEtG,WAFM;AAGZmF,EAAAA,KAAK,EAAElF,YAHK;AAIZsG,EAAAA,SAAS,EAAErG,gBAJC;AAKZsG,EAAAA,QAAQ,EAAErG,eALE;AAMZsG,EAAAA,UAAU,EAAErG;AANA,CAAd;AAQA,IAAMsG,QAAQ,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,OAAzB,EAAkC,UAAlC,CAAjB;AACA;;;;;;;AAOA,SAASC,OAAT,CAAiB7F,MAAjB,EAAyB;AACvBmC,EAAAA,eAAe,CAAClC,IAAhB,CAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD6F,OAAO,CAAC3F,UAAR,GAAqB;AACnB,UAAQ,SADW;AAEnB,cAAY;AACV,YAAQ,IADE;AAEV,gBAAY;AAFF,GAFO;AAMnB,YAAU,CAAC;AACT,YAAQ,OADC;AAET,YAAQ;AAFC,GAAD,EAGP;AACD,YAAQ,MADP;AAED,YAAQ;AAFP,GAHO,EAMP;AACD,YAAQ,QADP;AAED,YAAQ,MAFP;AAGD,eAAW,UAHV;AAID,cAAU,CAAC,UAAD,EAAa,YAAb,EAA2B,QAA3B,EAAqC,MAArC,EAA6C,OAA7C,EAAsD,WAAtD;AAJT,GANO,EAWP;AACD,YAAQ,SADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAXO,EAeP;AACD,YAAQ,cADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAfO,EAmBP;AACD,YAAQ,cADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAnBO,EAuBP;AACD,YAAQ,YADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAvBO,EA2BP;AACD,YAAQ,cADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GA3BO,EA+BP;AACD,YAAQ,eADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GA/BO,EAmCP;AACD,YAAQ,aADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAnCO,EAuCP;AACD,YAAQ,OADP;AAED,YAAQ,QAFP;AAGD,eAAW;AAHV,GAvCO,EA2CP;AACD,YAAQ,OADP;AAED,YAAQ,SAFP;AAGD,eAAW;AAHV,GA3CO,EA+CP;AACD,YAAQ,MADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU;AAJT,GA/CO,EAoDP;AACD,YAAQ,IADP;AAED,YAAQ,QAFP;AAGD,aAAS,IAHR;AAID,cAAU0F,QAAQ,CAAC9D,MAJlB;AAKD,eAAW8D;AALV,GApDO;AANS,CAArB;AAkEAxH,QAAQ,CAACyH,OAAD,EAAU1D,eAAV,EAA2B;AACjC;;;;AAIAO,EAAAA,MALiC,oBAKxB;AACP,QAAMoD,CAAC,GAAG9G,OAAO,EAAjB;;AAEA8G,IAAAA,CAAC,CAACC,KAAF,GAAU,UAAAxF,CAAC,EAAI;AACb,UAAMV,CAAC,GAAGiG,CAAC,CAACE,IAAF,EAAV;AACA,UAAInG,CAAC,CAACkG,KAAN,EAAaD,CAAC,CAACE,IAAF,CAAOnG,CAAC,CAACkG,KAAF,CAAQxF,CAAR,CAAP;AACd,KAHD;;AAKAuF,IAAAA,CAAC,CAACnD,MAAF,GAAW,UAAApC,CAAC,EAAI;AACd,UAAI9B,cAAc,CAAC6G,KAAD,EAAQ/E,CAAR,CAAlB,EAA8BuF,CAAC,CAACE,IAAF,CAAOV,KAAK,CAAC/E,CAAD,CAAZ,EAA9B,KAAoDlC,KAAK,CAAC,yCAAyCkC,CAA1C,CAAL;AACrD,KAFD;;AAIA,WAAOuF,CAAP;AACD,GAlBgC;AAoBjC9F,EAAAA,MAAM,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,MAApB,EAA4B,OAA5B,EAAqC,SAArC,EAAgD,cAAhD,EAAgE,cAAhE,EAAgF,YAAhF,EAA8F,cAA9F,EAA8G,eAA9G,EAA+H,aAA/H,CApByB;AAqBjC4C,EAAAA,MAAM,EAAEgD;AArByB,CAA3B,CAAR;AAwBA,SAAS7F,IAAI,IAAIwB,IAAjB,EAAuBmC,IAAI,IAAI/E,IAA/B,EAAqCiF,SAAS,IAAIhF,SAAlD,EAA6DiF,QAAQ,IAAIhF,QAAzE,EAAmF8F,IAAI,IAAI7F,IAA3F,EAAiG+F,SAAS,IAAIoB,SAA9G,EAAyHJ,OAAO,IAAI7G,OAApI","sourcesContent":["import { Transform, isTuple, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { inherits, error, array, one, truthy, hasOwnProperty } from 'vega-util';\nimport { hierarchy, pack, partition, stratify, tree, cluster, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from 'd3-hierarchy';\n\n// Build lookup table mapping tuple keys to tree node instances\nfunction lookup (tree, key, filter) {\n  const map = {};\n  tree.each(node => {\n    const t = node.data;\n    if (filter(t)) map[key(t)] = node;\n  });\n  tree.lookup = map;\n  return tree;\n}\n\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\nfunction Nest(params) {\n  Transform.call(this, null, params);\n}\nNest.Definition = {\n  'type': 'Nest',\n  'metadata': {\n    'treesource': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'keys',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'generate',\n    'type': 'boolean'\n  }]\n};\n\nconst children = n => n.values;\n\ninherits(Nest, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Nest transform requires an upstream data source.');\n    }\n\n    var gen = _.generate,\n        mod = _.modified(),\n        out = pulse.clone(),\n        tree = this.value;\n\n    if (!tree || mod || pulse.changed()) {\n      // collect nodes to remove\n      if (tree) {\n        tree.each(node => {\n          if (node.children && isTuple(node.data)) {\n            out.rem.push(node.data);\n          }\n        });\n      } // generate new tree structure\n\n\n      this.value = tree = hierarchy({\n        values: array(_.keys).reduce((n, k) => {\n          n.key(k);\n          return n;\n        }, nest()).entries(out.source)\n      }, children); // collect nodes to add\n\n      if (gen) {\n        tree.each(node => {\n          if (node.children) {\n            node = ingest(node.data);\n            out.add.push(node);\n            out.source.push(node);\n          }\n        });\n      } // build lookup table\n\n\n      lookup(tree, tupleid, tupleid);\n    }\n\n    out.source.root = tree;\n    return out;\n  }\n\n});\n\nfunction nest() {\n  const keys = [],\n        nest = {\n    entries: array => entries(apply(array, 0), 0),\n    key: d => (keys.push(d), nest)\n  };\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    const n = array.length,\n          key = keys[depth++],\n          valuesByKey = {},\n          result = {};\n    let i = -1,\n        keyValue,\n        value,\n        values;\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    const array = [];\n\n    for (const key in map) {\n      array.push({\n        key,\n        values: entries(map[key], depth)\n      });\n    }\n\n    return array;\n  }\n\n  return nest;\n}\n\n/**\n * Abstract class for tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction HierarchyLayout(params) {\n  Transform.call(this, null, params);\n}\n\nconst defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;\n\ninherits(HierarchyLayout, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source || !pulse.source.root) {\n      error(this.constructor.name + ' transform requires a backing tree data source.');\n    }\n\n    const layout = this.layout(_.method),\n          fields = this.fields,\n          root = pulse.source.root,\n          as = _.as || fields;\n    if (_.field) root.sum(_.field);else root.count();\n    if (_.sort) root.sort(stableCompare(_.sort, d => d.data));\n    setParams(layout, this.params, _);\n\n    if (layout.separation) {\n      layout.separation(_.separation !== false ? defaultSeparation : one);\n    }\n\n    try {\n      this.value = layout(root);\n    } catch (err) {\n      error(err);\n    }\n\n    root.each(node => setFields(node, fields, as));\n    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n  }\n\n});\n\nfunction setParams(layout, params, _) {\n  for (let p, i = 0, n = params.length; i < n; ++i) {\n    p = params[i];\n    if (p in _) layout[p](_[p]);\n  }\n}\n\nfunction setFields(node, fields, as) {\n  const t = node.data,\n        n = fields.length - 1;\n\n  for (let i = 0; i < n; ++i) {\n    t[as[i]] = node[fields[i]];\n  }\n\n  t[as[n]] = node.children ? node.children.length : 0;\n}\n\nconst Output = ['x', 'y', 'r', 'depth', 'children'];\n/**\n * Packed circle tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Pack(params) {\n  HierarchyLayout.call(this, params);\n}\nPack.Definition = {\n  'type': 'Pack',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'radius',\n    'type': 'field',\n    'default': null\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output.length,\n    'default': Output\n  }]\n};\ninherits(Pack, HierarchyLayout, {\n  layout: pack,\n  params: ['radius', 'size', 'padding'],\n  fields: Output\n});\n\nconst Output$1 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Partition tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Partition(params) {\n  HierarchyLayout.call(this, params);\n}\nPartition.Definition = {\n  'type': 'Partition',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$1.length,\n    'default': Output$1\n  }]\n};\ninherits(Partition, HierarchyLayout, {\n  layout: partition,\n  params: ['size', 'round', 'padding'],\n  fields: Output$1\n});\n\n/**\n * Stratify a collection of tuples into a tree structure based on\n * id and parent id fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.key - Unique key field for each tuple.\n * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n */\n\nfunction Stratify(params) {\n  Transform.call(this, null, params);\n}\nStratify.Definition = {\n  'type': 'Stratify',\n  'metadata': {\n    'treesource': true\n  },\n  'params': [{\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'parentKey',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Stratify, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Stratify transform requires an upstream data source.');\n    }\n\n    let tree = this.value;\n\n    const mod = _.modified(),\n          out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n          run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution\n\n\n    out.source = out.source.slice();\n\n    if (run) {\n      tree = out.source.length ? lookup(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup(stratify()([{}]), _.key, _.key);\n    }\n\n    out.source.root = this.value = tree;\n    return out;\n  }\n\n});\n\nconst Layouts = {\n  tidy: tree,\n  cluster: cluster\n};\nconst Output$2 = ['x', 'y', 'depth', 'children'];\n/**\n * Tree layout. Depending on the method parameter, performs either\n * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Tree(params) {\n  HierarchyLayout.call(this, params);\n}\nTree.Definition = {\n  'type': 'Tree',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'tidy',\n    'values': ['tidy', 'cluster']\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'nodeSize',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'separation',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$2.length,\n    'default': Output$2\n  }]\n};\ninherits(Tree, HierarchyLayout, {\n  /**\n   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n   */\n  layout(method) {\n    const m = method || 'tidy';\n    if (hasOwnProperty(Layouts, m)) return Layouts[m]();else error('Unrecognized Tree layout method: ' + m);\n  },\n\n  params: ['size', 'nodeSize'],\n  fields: Output$2\n});\n\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction TreeLinks(params) {\n  Transform.call(this, [], params);\n}\nTreeLinks.Definition = {\n  'type': 'TreeLinks',\n  'metadata': {\n    'tree': true,\n    'generates': true,\n    'changes': true\n  },\n  'params': []\n};\ninherits(TreeLinks, Transform, {\n  transform(_, pulse) {\n    const links = this.value,\n          tree = pulse.source && pulse.source.root,\n          out = pulse.fork(pulse.NO_SOURCE),\n          lut = {};\n    if (!tree) error('TreeLinks transform requires a tree data source.');\n\n    if (pulse.changed(pulse.ADD_REM)) {\n      // remove previous links\n      out.rem = links; // build lookup table of valid tuples\n\n      pulse.visit(pulse.SOURCE, t => lut[tupleid(t)] = 1); // generate links for all edges incident on valid tuples\n\n      tree.each(node => {\n        const t = node.data,\n              p = node.parent && node.parent.data;\n\n        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n          out.add.push(ingest({\n            source: p,\n            target: t\n          }));\n        }\n      });\n      this.value = out.add;\n    } else if (pulse.changed(pulse.MOD)) {\n      // build lookup table of modified tuples\n      pulse.visit(pulse.MOD, t => lut[tupleid(t)] = 1); // gather links incident on modified tuples\n\n      links.forEach(link => {\n        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n          out.mod.push(link);\n        }\n      });\n    }\n\n    return out;\n  }\n\n});\n\nconst Tiles = {\n  binary: treemapBinary,\n  dice: treemapDice,\n  slice: treemapSlice,\n  slicedice: treemapSliceDice,\n  squarify: treemapSquarify,\n  resquarify: treemapResquarify\n};\nconst Output$3 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Treemap layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Treemap(params) {\n  HierarchyLayout.call(this, params);\n}\nTreemap.Definition = {\n  'type': 'Treemap',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'squarify',\n    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingInner',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingOuter',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingTop',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingRight',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingBottom',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingLeft',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'ratio',\n    'type': 'number',\n    'default': 1.618033988749895\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$3.length,\n    'default': Output$3\n  }]\n};\ninherits(Treemap, HierarchyLayout, {\n  /**\n   * Treemap layout generator. Adds 'method' and 'ratio' parameters\n   * to configure the underlying tile method.\n   */\n  layout() {\n    const x = treemap();\n\n    x.ratio = _ => {\n      const t = x.tile();\n      if (t.ratio) x.tile(t.ratio(_));\n    };\n\n    x.method = _ => {\n      if (hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);else error('Unrecognized Treemap layout method: ' + _);\n    };\n\n    return x;\n  },\n\n  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],\n  fields: Output$3\n});\n\nexport { Nest as nest, Pack as pack, Partition as partition, Stratify as stratify, Tree as tree, TreeLinks as treelinks, Treemap as treemap };\n"]},"metadata":{},"sourceType":"module"}