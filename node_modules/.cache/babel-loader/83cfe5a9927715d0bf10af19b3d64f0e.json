{"ast":null,"code":"import { getSizeChannel } from '../channel';\nimport { stringify } from '../util';\nexport function invalidSpec(spec) {\n  return `Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".`;\n} // FIT\n\nexport const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\nexport function containerSizeNonSingle(name) {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  return `${uName} \"container\" only works for single views and layered views.`;\n}\nexport function containerSizeNotCompatibleWithAutosize(name) {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  const fitDirection = name == 'width' ? 'x' : 'y';\n  return `${uName} \"container\" only works well with autosize \"fit\" or \"fit-${fitDirection}\".`;\n}\nexport function droppingFit(channel) {\n  return channel ? `Dropping \"fit-${channel}\" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping \"fit\" because spec has discrete size.`;\n} // VIEW SIZE\n\nexport function unknownField(channel) {\n  return `Unknown field for ${channel}. Cannot calculate view size.`;\n} // SELECTION\n\nexport function cannotProjectOnChannelWithoutField(channel) {\n  return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n}\nexport function cannotProjectAggregate(channel, aggregate) {\n  return `Cannot project a selection on encoding channel \"${channel}\" as it uses an aggregate function (\"${aggregate}\").`;\n}\nexport function nearestNotSupportForContinuous(mark) {\n  return `The \"nearest\" transform is not supported for ${mark} marks.`;\n}\nexport function selectionNotSupported(mark) {\n  return `Selection not supported for ${mark} yet.`;\n}\nexport function selectionNotFound(name) {\n  return `Cannot find a selection named \"${name}\".`;\n}\nexport const SCALE_BINDINGS_CONTINUOUS = 'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\nexport const LEGEND_BINDINGS_MUST_HAVE_PROJECTION = 'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function cannotLookupVariableParameter(name) {\n  return `Lookups can only be performed on selection parameters. \"${name}\" is a variable parameter.`;\n}\nexport function noSameUnitLookup(name) {\n  return `Cannot define and lookup the \"${name}\" selection in the same view. ` + `Try moving the lookup into a second, layered view?`;\n}\nexport const NEEDS_SAME_SELECTION = 'The same selection must be used to override scale domains in a layered view.';\nexport const INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using \"x\" and/or \"y\" keys.'; // REPEAT\n\nexport function noSuchRepeatedValue(field) {\n  return `Unknown repeated value \"${field}\".`;\n}\nexport function columnsNotSupportByRowCol(type) {\n  return `The \"columns\" property cannot be used when \"${type}\" has nested row/column.`;\n} // CONCAT / REPEAT\n\nexport const CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).'; // DATA\n\nexport function unrecognizedParse(p) {\n  return `Unrecognized parse \"${p}\".`;\n}\nexport function differentParse(field, local, ancestor) {\n  return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n}\nexport const ADD_SAME_CHILD_TWICE = 'Attempt to add the same child twice.'; // TRANSFORMS\n\nexport function invalidTransformIgnored(transform) {\n  return `Ignoring an invalid transform: ${stringify(transform)}.`;\n}\nexport const NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.'; // ENCODING & FACET\n\nexport function customFormatTypeNotAllowed(channel) {\n  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;\n}\nexport function projectionOverridden(opt) {\n  const {\n    parentProjection,\n    projection\n  } = opt;\n  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`;\n}\nexport const REPLACE_ANGLE_WITH_THETA = 'Arc marks uses theta channel rather than angle, replacing angle with theta.';\nexport function primitiveChannelDef(channel, type, value) {\n  return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n}\nexport function invalidFieldType(type) {\n  return `Invalid field type \"${type}\".`;\n}\nexport function invalidFieldTypeForCountAggregate(type, aggregate) {\n  return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n}\nexport function invalidAggregate(aggregate) {\n  return `Invalid aggregation operator \"${aggregate}\".`;\n}\nexport function missingFieldType(channel, newType) {\n  return `Missing type for channel \"${channel}\", using \"${newType}\" instead.`;\n}\nexport function droppingColor(type, opt) {\n  const {\n    fill,\n    stroke\n  } = opt;\n  return `Dropping color ${type} as the plot also has ${fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke'}.`;\n}\nexport function relativeBandSizeNotSupported(sizeChannel) {\n  return `Position range does not support relative band size for ${sizeChannel}.`;\n}\nexport function emptyFieldDef(fieldDef, channel) {\n  return `Dropping ${stringify(fieldDef)} from channel \"${channel}\" since it does not contain any data field, datum, value, or signal.`;\n}\nexport const LINE_WITH_VARYING_SIZE = 'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\nexport function incompatibleChannel(channel, markOrFacet, when) {\n  return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n}\nexport function invalidEncodingChannel(channel) {\n  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n}\nexport function channelShouldBeDiscrete(channel) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n}\nexport function channelShouldBeDiscreteOrDiscretizing(channel) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;\n}\nexport function facetChannelDropped(channels) {\n  return `Facet encoding dropped as ${channels.join(' and ')} ${channels.length > 1 ? 'are' : 'is'} also specified.`;\n}\nexport function discreteChannelCannotEncode(channel, type) {\n  return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n} // MARK\n\nexport function rangeMarkAlignmentCannotBeExpression(align) {\n  return `The ${align} for range marks cannot be an expression`;\n}\nexport function lineWithRange(hasX2, hasY2) {\n  const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n}\nexport function orientOverridden(original, actual) {\n  return `Specified orient \"${original}\" overridden with \"${actual}\".`;\n} // SCALE\n\nexport const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'Custom domain scale cannot be unioned with default field-based domain.';\nexport function cannotUseScalePropertyWithNonColor(prop) {\n  return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n}\nexport function cannotUseRelativeBandSizeWithNonBandScale(scaleType) {\n  return `Cannot use the relative band size with ${scaleType} scale.`;\n}\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n}\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n  return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n}\nexport function unaggregatedDomainWithLogScale(fieldDef) {\n  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n}\nexport function cannotApplySizeToNonOrientedMark(mark) {\n  return `Cannot apply size to non-oriented mark \"${mark}\".`;\n}\nexport function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n  return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n  return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n  return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n}\nexport function scaleTypeNotWorkWithMark(mark, scaleType) {\n  return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n}\nexport function stepDropped(channel) {\n  return `The step for \"${channel}\" is dropped because the ${channel === 'width' ? 'x' : 'y'} is continuous.`;\n}\nexport function mergeConflictingProperty(property, propertyOf, v1, v2) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;\n}\nexport function mergeConflictingDomainProperty(property, propertyOf, v1, v2) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;\n}\nexport function independentScaleMeansIndependentGuide(channel) {\n  return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n}\nexport function domainSortDropped(sort) {\n  return `Dropping sort property ${stringify(sort)} as unioned domains only support boolean or op \"count\", \"min\", and \"max\".`;\n}\nexport const MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\nexport const FACETED_INDEPENDENT_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_SOURCE = 'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.'; // AXIS\n\nexport const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.'; // STACK\n\nexport function cannotStackRangedMark(channel) {\n  return `Cannot stack \"${channel}\" if there is already \"${channel}2\".`;\n}\nexport function cannotStackNonLinearScale(scaleType) {\n  return `Cannot stack non-linear scale (${scaleType}).`;\n}\nexport function stackNonSummativeAggregate(aggregate) {\n  return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\").`;\n} // TIMEUNIT\n\nexport function invalidTimeUnit(unitName, value) {\n  return `Invalid ${unitName}: ${stringify(value)}.`;\n}\nexport function droppedDay(d) {\n  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n}\nexport function errorBarCenterAndExtentAreNotNeeded(center, extent) {\n  return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${extent && center ? 'are ' : 'is '}not needed when data are aggregated.`;\n}\nexport function errorBarCenterIsUsedWithWrongExtent(center, extent, mark) {\n  return `${center} is not usually used with ${extent} for ${mark}.`;\n}\nexport function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {\n  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n}\nexport function errorBand1DNotSupport(property) {\n  return `1D error band does not support ${property}.`;\n} // CHANNEL\n\nexport function channelRequiredForBinned(channel) {\n  return `Channel ${channel} is required for \"binned\" bin.`;\n}\nexport function channelShouldNotBeUsedForBinned(channel) {\n  return `Channel ${channel} should not be used with \"binned\" bin.`;\n}\nexport function domainRequiredForThresholdScale(channel) {\n  return `Domain for ${channel} is required for threshold scale.`;\n}","map":{"version":3,"sources":["../../../src/log/message.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getSizeChannel } from '../channel';\nimport { stringify } from '../util';\nexport function invalidSpec(spec) {\n    return `Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".`;\n}\n// FIT\nexport const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\nexport function containerSizeNonSingle(name) {\n    const uName = name == 'width' ? 'Width' : 'Height';\n    return `${uName} \"container\" only works for single views and layered views.`;\n}\nexport function containerSizeNotCompatibleWithAutosize(name) {\n    const uName = name == 'width' ? 'Width' : 'Height';\n    const fitDirection = name == 'width' ? 'x' : 'y';\n    return `${uName} \"container\" only works well with autosize \"fit\" or \"fit-${fitDirection}\".`;\n}\nexport function droppingFit(channel) {\n    return channel\n        ? `Dropping \"fit-${channel}\" because spec has discrete ${getSizeChannel(channel)}.`\n        : `Dropping \"fit\" because spec has discrete size.`;\n}\n// VIEW SIZE\nexport function unknownField(channel) {\n    return `Unknown field for ${channel}. Cannot calculate view size.`;\n}\n// SELECTION\nexport function cannotProjectOnChannelWithoutField(channel) {\n    return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n}\nexport function cannotProjectAggregate(channel, aggregate) {\n    return `Cannot project a selection on encoding channel \"${channel}\" as it uses an aggregate function (\"${aggregate}\").`;\n}\nexport function nearestNotSupportForContinuous(mark) {\n    return `The \"nearest\" transform is not supported for ${mark} marks.`;\n}\nexport function selectionNotSupported(mark) {\n    return `Selection not supported for ${mark} yet.`;\n}\nexport function selectionNotFound(name) {\n    return `Cannot find a selection named \"${name}\".`;\n}\nexport const SCALE_BINDINGS_CONTINUOUS = 'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\nexport const LEGEND_BINDINGS_MUST_HAVE_PROJECTION = 'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function cannotLookupVariableParameter(name) {\n    return `Lookups can only be performed on selection parameters. \"${name}\" is a variable parameter.`;\n}\nexport function noSameUnitLookup(name) {\n    return (`Cannot define and lookup the \"${name}\" selection in the same view. ` +\n        `Try moving the lookup into a second, layered view?`);\n}\nexport const NEEDS_SAME_SELECTION = 'The same selection must be used to override scale domains in a layered view.';\nexport const INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using \"x\" and/or \"y\" keys.';\n// REPEAT\nexport function noSuchRepeatedValue(field) {\n    return `Unknown repeated value \"${field}\".`;\n}\nexport function columnsNotSupportByRowCol(type) {\n    return `The \"columns\" property cannot be used when \"${type}\" has nested row/column.`;\n}\n// CONCAT / REPEAT\nexport const CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).';\n// DATA\nexport function unrecognizedParse(p) {\n    return `Unrecognized parse \"${p}\".`;\n}\nexport function differentParse(field, local, ancestor) {\n    return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n}\nexport const ADD_SAME_CHILD_TWICE = 'Attempt to add the same child twice.';\n// TRANSFORMS\nexport function invalidTransformIgnored(transform) {\n    return `Ignoring an invalid transform: ${stringify(transform)}.`;\n}\nexport const NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.';\n// ENCODING & FACET\nexport function customFormatTypeNotAllowed(channel) {\n    return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;\n}\nexport function projectionOverridden(opt) {\n    const { parentProjection, projection } = opt;\n    return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`;\n}\nexport const REPLACE_ANGLE_WITH_THETA = 'Arc marks uses theta channel rather than angle, replacing angle with theta.';\nexport function primitiveChannelDef(channel, type, value) {\n    return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n}\nexport function invalidFieldType(type) {\n    return `Invalid field type \"${type}\".`;\n}\nexport function invalidFieldTypeForCountAggregate(type, aggregate) {\n    return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n}\nexport function invalidAggregate(aggregate) {\n    return `Invalid aggregation operator \"${aggregate}\".`;\n}\nexport function missingFieldType(channel, newType) {\n    return `Missing type for channel \"${channel}\", using \"${newType}\" instead.`;\n}\nexport function droppingColor(type, opt) {\n    const { fill, stroke } = opt;\n    return `Dropping color ${type} as the plot also has ${fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke'}.`;\n}\nexport function relativeBandSizeNotSupported(sizeChannel) {\n    return `Position range does not support relative band size for ${sizeChannel}.`;\n}\nexport function emptyFieldDef(fieldDef, channel) {\n    return `Dropping ${stringify(fieldDef)} from channel \"${channel}\" since it does not contain any data field, datum, value, or signal.`;\n}\nexport const LINE_WITH_VARYING_SIZE = 'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\nexport function incompatibleChannel(channel, markOrFacet, when) {\n    return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n}\nexport function invalidEncodingChannel(channel) {\n    return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n}\nexport function channelShouldBeDiscrete(channel) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n}\nexport function channelShouldBeDiscreteOrDiscretizing(channel) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;\n}\nexport function facetChannelDropped(channels) {\n    return `Facet encoding dropped as ${channels.join(' and ')} ${channels.length > 1 ? 'are' : 'is'} also specified.`;\n}\nexport function discreteChannelCannotEncode(channel, type) {\n    return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n}\n// MARK\nexport function rangeMarkAlignmentCannotBeExpression(align) {\n    return `The ${align} for range marks cannot be an expression`;\n}\nexport function lineWithRange(hasX2, hasY2) {\n    const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n    return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n}\nexport function orientOverridden(original, actual) {\n    return `Specified orient \"${original}\" overridden with \"${actual}\".`;\n}\n// SCALE\nexport const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'Custom domain scale cannot be unioned with default field-based domain.';\nexport function cannotUseScalePropertyWithNonColor(prop) {\n    return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n}\nexport function cannotUseRelativeBandSizeWithNonBandScale(scaleType) {\n    return `Cannot use the relative band size with ${scaleType} scale.`;\n}\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n    return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n}\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n    return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n}\nexport function unaggregatedDomainWithLogScale(fieldDef) {\n    return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n}\nexport function cannotApplySizeToNonOrientedMark(mark) {\n    return `Cannot apply size to non-oriented mark \"${mark}\".`;\n}\nexport function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n    return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n    return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n    return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n}\nexport function scaleTypeNotWorkWithMark(mark, scaleType) {\n    return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n}\nexport function stepDropped(channel) {\n    return `The step for \"${channel}\" is dropped because the ${channel === 'width' ? 'x' : 'y'} is continuous.`;\n}\nexport function mergeConflictingProperty(property, propertyOf, v1, v2) {\n    return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;\n}\nexport function mergeConflictingDomainProperty(property, propertyOf, v1, v2) {\n    return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;\n}\nexport function independentScaleMeansIndependentGuide(channel) {\n    return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n}\nexport function domainSortDropped(sort) {\n    return `Dropping sort property ${stringify(sort)} as unioned domains only support boolean or op \"count\", \"min\", and \"max\".`;\n}\nexport const MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\nexport const FACETED_INDEPENDENT_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_SOURCE = 'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.';\n// AXIS\nexport const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n// STACK\nexport function cannotStackRangedMark(channel) {\n    return `Cannot stack \"${channel}\" if there is already \"${channel}2\".`;\n}\nexport function cannotStackNonLinearScale(scaleType) {\n    return `Cannot stack non-linear scale (${scaleType}).`;\n}\nexport function stackNonSummativeAggregate(aggregate) {\n    return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\").`;\n}\n// TIMEUNIT\nexport function invalidTimeUnit(unitName, value) {\n    return `Invalid ${unitName}: ${stringify(value)}.`;\n}\nexport function droppedDay(d) {\n    return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n}\nexport function errorBarCenterAndExtentAreNotNeeded(center, extent) {\n    return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${extent && center ? 'are ' : 'is '}not needed when data are aggregated.`;\n}\nexport function errorBarCenterIsUsedWithWrongExtent(center, extent, mark) {\n    return `${center} is not usually used with ${extent} for ${mark}.`;\n}\nexport function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {\n    return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n}\nexport function errorBand1DNotSupport(property) {\n    return `1D error band does not support ${property}.`;\n}\n// CHANNEL\nexport function channelRequiredForBinned(channel) {\n    return `Channel ${channel} is required for \"binned\" bin.`;\n}\nexport function channelShouldNotBeUsedForBinned(channel) {\n    return `Channel ${channel} should not be used with \"binned\" bin.`;\n}\nexport function domainRequiredForThresholdScale(channel) {\n    return `Domain for ${channel} is required for threshold scale.`;\n}\n//# sourceMappingURL=message.js.map"]},"metadata":{},"sourceType":"module"}