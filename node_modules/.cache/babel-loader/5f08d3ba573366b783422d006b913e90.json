{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNEL_INDEX, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  const {\n    config,\n    encoding,\n    markDef,\n    specifiedScales\n  } = model;\n\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = fieldOrDatumDef['timeUnit'];\n        const type = fieldOrDatumDef.type;\n\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {\n                signal: valueExpr(specifiedScale[property], {\n                  type,\n                  timeUnit\n                })\n              }, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property], true);\n            }\n\n            break;\n\n          default:\n            localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n        }\n      } else {\n        const value = property in scaleRules ? scaleRules[property]({\n          model,\n          channel,\n          fieldOrDatumDef,\n          scaleType,\n          scalePadding,\n          scalePaddingInner,\n          domain: specifiedScale.domain,\n          markDef,\n          config\n        }) : config.scale[property];\n\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  }\n}\n\nexport const scaleRules = {\n  bins: ({\n    model,\n    fieldOrDatumDef\n  }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined,\n  interpolate: ({\n    channel,\n    fieldOrDatumDef\n  }) => interpolate(channel, fieldOrDatumDef.type),\n  nice: ({\n    scaleType,\n    channel,\n    domain,\n    fieldOrDatumDef\n  }) => nice(scaleType, channel, domain, fieldOrDatumDef),\n  padding: ({\n    channel,\n    scaleType,\n    fieldOrDatumDef,\n    markDef,\n    config\n  }) => padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n  paddingInner: ({\n    scalePadding,\n    channel,\n    markDef,\n    config\n  }) => paddingInner(scalePadding, channel, markDef.type, config.scale),\n  paddingOuter: ({\n    scalePadding,\n    channel,\n    scaleType,\n    markDef,\n    scalePaddingInner,\n    config\n  }) => paddingOuter(scalePadding, channel, scaleType, markDef.type, scalePaddingInner, config.scale),\n  reverse: ({\n    fieldOrDatumDef,\n    scaleType,\n    channel,\n    config\n  }) => {\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: ({\n    channel,\n    fieldOrDatumDef,\n    domain,\n    markDef,\n    scaleType\n  }) => zero(channel, fieldOrDatumDef, domain, markDef, scaleType)\n}; // This method is here rather than in range.ts to avoid circular dependency.\n\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n          switch (property) {\n            case 'range':\n              // For step, prefer larger step\n              if (v1.step && v2.step) {\n                return v1.step - v2.step;\n              }\n\n              return 0;\n            // TODO: precedence rule for other properties\n          }\n\n          return 0;\n        }));\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\nexport function bins(model, fieldDef) {\n  const bin = fieldDef.bin;\n\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n\n  return undefined;\n}\nexport function interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n\n  return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, fieldOrDatumDef) {\n  var _a;\n\n  if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) || isArray(specifiedDomain) || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n\n  return channel in POSITION_SCALE_CHANNEL_INDEX ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n  if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {\n        type,\n        orient\n      } = markDef;\n\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n\n  return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner\n    } = scaleConfig;\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  }\n\n  return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, mark, paddingInnerValue, scaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      const {\n        bandPaddingOuter\n      } = scaleConfig;\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      isSignalRef(paddingInnerValue) ? {\n        signal: `${paddingInnerValue.signal}/2`\n      } : paddingInnerValue / 2);\n    }\n  }\n\n  return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {\n          signal: `!${scaleConfig.xReverse.signal}`\n        };\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n\n    return scaleConfig.xReverse;\n  }\n\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n\n  return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n\n      return false;\n    }\n  } // If there is no custom domain, return true only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n\n\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  } // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n\n\n  if (!(isFieldDef(fieldDef) && fieldDef.bin) && util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n    const {\n      orient,\n      type\n    } = markDef;\n\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNEL_INDEX, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n    if (isUnitModel(model)) {\n        parseUnitScaleProperty(model, property);\n    }\n    else {\n        parseNonUnitScaleProperty(model, property);\n    }\n}\nfunction parseUnitScaleProperty(model, property) {\n    const localScaleComponents = model.component.scales;\n    const { config, encoding, markDef, specifiedScales } = model;\n    for (const channel of keys(localScaleComponents)) {\n        const specifiedScale = specifiedScales[channel];\n        const localScaleCmpt = localScaleComponents[channel];\n        const mergedScaleCmpt = model.getScaleComponent(channel);\n        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n        const specifiedValue = specifiedScale[property];\n        const scaleType = mergedScaleCmpt.get('type');\n        const scalePadding = mergedScaleCmpt.get('padding');\n        const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n        const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n        const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n        if (specifiedValue !== undefined) {\n            // If there is a specified value, check if it is compatible with scale type and channel\n            if (!supportedByScaleType) {\n                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n            }\n            else if (channelIncompatability) {\n                // channel\n                log.warn(channelIncompatability);\n            }\n        }\n        if (supportedByScaleType && channelIncompatability === undefined) {\n            if (specifiedValue !== undefined) {\n                const timeUnit = fieldOrDatumDef['timeUnit'];\n                const type = fieldOrDatumDef.type;\n                switch (property) {\n                    // domainMax/Min to signal if the value is a datetime object\n                    case 'domainMax':\n                    case 'domainMin':\n                        if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n                            localScaleCmpt.set(property, { signal: valueExpr(specifiedScale[property], { type, timeUnit }) }, true);\n                        }\n                        else {\n                            localScaleCmpt.set(property, specifiedScale[property], true);\n                        }\n                        break;\n                    default:\n                        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n                }\n            }\n            else {\n                const value = property in scaleRules\n                    ? scaleRules[property]({\n                        model,\n                        channel,\n                        fieldOrDatumDef,\n                        scaleType,\n                        scalePadding,\n                        scalePaddingInner,\n                        domain: specifiedScale.domain,\n                        markDef,\n                        config\n                    })\n                    : config.scale[property];\n                if (value !== undefined) {\n                    localScaleCmpt.set(property, value, false);\n                }\n            }\n        }\n    }\n}\nexport const scaleRules = {\n    bins: ({ model, fieldOrDatumDef }) => (isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined),\n    interpolate: ({ channel, fieldOrDatumDef }) => interpolate(channel, fieldOrDatumDef.type),\n    nice: ({ scaleType, channel, domain, fieldOrDatumDef }) => nice(scaleType, channel, domain, fieldOrDatumDef),\n    padding: ({ channel, scaleType, fieldOrDatumDef, markDef, config }) => padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n    paddingInner: ({ scalePadding, channel, markDef, config }) => paddingInner(scalePadding, channel, markDef.type, config.scale),\n    paddingOuter: ({ scalePadding, channel, scaleType, markDef, scalePaddingInner, config }) => paddingOuter(scalePadding, channel, scaleType, markDef.type, scalePaddingInner, config.scale),\n    reverse: ({ fieldOrDatumDef, scaleType, channel, config }) => {\n        const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n        return reverse(scaleType, sort, channel, config.scale);\n    },\n    zero: ({ channel, fieldOrDatumDef, domain, markDef, scaleType }) => zero(channel, fieldOrDatumDef, domain, markDef, scaleType)\n};\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model) {\n    if (isUnitModel(model)) {\n        parseUnitScaleRange(model);\n    }\n    else {\n        parseNonUnitScaleProperty(model, 'range');\n    }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n    const localScaleComponents = model.component.scales;\n    for (const child of model.children) {\n        if (property === 'range') {\n            parseScaleRange(child);\n        }\n        else {\n            parseScaleProperty(child, property);\n        }\n    }\n    for (const channel of keys(localScaleComponents)) {\n        let valueWithExplicit;\n        for (const child of model.children) {\n            const childComponent = child.component.scales[channel];\n            if (childComponent) {\n                const childValueWithExplicit = childComponent.getWithExplicit(property);\n                valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n                    switch (property) {\n                        case 'range':\n                            // For step, prefer larger step\n                            if (v1.step && v2.step) {\n                                return v1.step - v2.step;\n                            }\n                            return 0;\n                        // TODO: precedence rule for other properties\n                    }\n                    return 0;\n                }));\n            }\n        }\n        localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n    }\n}\nexport function bins(model, fieldDef) {\n    const bin = fieldDef.bin;\n    if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return new SignalRefWrapper(() => {\n            return model.getSignalName(binSignal);\n        });\n    }\n    else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n        // start and stop will be determined from the scale domain\n        return {\n            step: bin.step\n        };\n    }\n    return undefined;\n}\nexport function interpolate(channel, type) {\n    if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n        return 'hcl';\n    }\n    return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, fieldOrDatumDef) {\n    var _a;\n    if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) ||\n        isArray(specifiedDomain) ||\n        util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n        return undefined;\n    }\n    return channel in POSITION_SCALE_CHANNEL_INDEX ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n    if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n        if (isContinuousToContinuous(scaleType)) {\n            if (scaleConfig.continuousPadding !== undefined) {\n                return scaleConfig.continuousPadding;\n            }\n            const { type, orient } = markDef;\n            if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n                if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n                    return barConfig.continuousBandSize;\n                }\n            }\n        }\n        if (scaleType === ScaleType.POINT) {\n            return scaleConfig.pointPadding;\n        }\n    }\n    return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleConfig) {\n    if (paddingValue !== undefined) {\n        // If user has already manually specified \"padding\", no need to add default paddingInner.\n        return undefined;\n    }\n    if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n        // Padding is only set for X and Y by default.\n        // Basically it doesn't make sense to add padding for color and size.\n        // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n        const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner } = scaleConfig;\n        return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n    }\n    return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, mark, paddingInnerValue, scaleConfig) {\n    if (paddingValue !== undefined) {\n        // If user has already manually specified \"padding\", no need to add default paddingOuter.\n        return undefined;\n    }\n    if (channel in POSITION_SCALE_CHANNEL_INDEX) {\n        // Padding is only set for X and Y by default.\n        // Basically it doesn't make sense to add padding for color and size.\n        if (scaleType === ScaleType.BAND) {\n            const { bandPaddingOuter } = scaleConfig;\n            return getFirstDefined(bandPaddingOuter, \n            /* By default, paddingOuter is paddingInner / 2. The reason is that\n              size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n              and we want the width/height to be integer by default.\n              Note that step (by default) and cardinality are integers.) */\n            isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2);\n        }\n    }\n    return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n    if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n        if (hasContinuousDomain(scaleType) && sort === 'descending') {\n            if (isSignalRef(scaleConfig.xReverse)) {\n                return { signal: `!${scaleConfig.xReverse.signal}` };\n            }\n            else {\n                return !scaleConfig.xReverse;\n            }\n        }\n        return scaleConfig.xReverse;\n    }\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n        // For continuous domain scales, Vega does not support domain sort.\n        // Thus, we reverse range instead if sort is descending\n        return true;\n    }\n    return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType) {\n    // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n    const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n    if (hasCustomDomain) {\n        if (hasContinuousDomain(scaleType)) {\n            if (isArray(specifiedDomain)) {\n                const first = specifiedDomain[0];\n                const last = specifiedDomain[specifiedDomain.length - 1];\n                if (first <= 0 && last >= 0) {\n                    // if the domain includes zero, make zero remains true\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    // If there is no custom domain, return true only for the following cases:\n    // 1) using quantitative field with size\n    // While this can be either ratio or interval fields, our assumption is that\n    // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n    // false so that range doesn't start at zero\n    if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n        return true;\n    }\n    // 2) non-binned, quantitative x-scale or y-scale\n    // (For binning, we should not include zero by default because binning are calculated without zero.)\n    if (!(isFieldDef(fieldDef) && fieldDef.bin) &&\n        util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n        const { orient, type } = markDef;\n        if (contains(['bar', 'area', 'line', 'trail'], type)) {\n            if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}