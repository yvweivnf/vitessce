{"version":3,"sources":["../../../src/passes/pick-layers-pass.js"],"names":["PICKING_PARAMETERS","blendFunc","blendEquation","PickLayersPass","props","pickingFBO","_drawPickingBuffer","layers","layerFilter","views","viewports","onViewportActive","deviceRect","x","y","width","height","pass","redrawReason","pickZ","gl","encodedColors","byLayer","Map","byAlpha","_colors","renderStatus","scissorTest","scissor","clearColor","depthMask","depthTest","depthRange","colorMask","blend","target","decodePickingColor","decodeColor","bind","stats","layer","pickable","pickingActive","pickingAttribute","lightSources","layerIndex","viewport","pickParameters","parameters","Object","assign","blendColor","encodeColor","LayersPass","encoded","a","has","entry","get","push","size","set","log","warn","pickedColor","pickedLayer","pickedViewports","pickedObjectIndex"],"mappings":"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","sourcesContent":["import LayersPass from './layers-pass';\nimport {withParameters} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport log from '../utils/log';\n\nconst PICKING_PARAMETERS = {\n  blendFunc: [GL.ONE, GL.ZERO, GL.CONSTANT_ALPHA, GL.ZERO],\n  blendEquation: GL.FUNC_ADD\n};\n\nexport default class PickLayersPass extends LayersPass {\n  render(props) {\n    if (props.pickingFBO) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {x, y, width, height},\n    pass = 'picking',\n    redrawReason,\n    pickZ\n  }) {\n    const gl = this.gl;\n    this.pickZ = pickZ;\n\n    // Track encoded layer indices\n    const encodedColors = !pickZ && {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    this._colors = encodedColors;\n\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = withParameters(\n      gl,\n      {\n        scissorTest: true,\n        scissor: [x, y, width, height],\n        clearColor: [0, 0, 0, 0],\n        // When used as Mapbox custom layer, the context state may be dirty\n        // TODO - Remove when mapbox fixes this issue\n        // https://github.com/mapbox/mapbox-gl-js/issues/7801\n        depthMask: true,\n        depthTest: true,\n        depthRange: [0, 1],\n        colorMask: [true, true, true, true],\n        // Blending\n        ...PICKING_PARAMETERS,\n        blend: !pickZ\n      },\n      () =>\n        super.render({\n          target: pickingFBO,\n          layers,\n          layerFilter,\n          views,\n          viewports,\n          onViewportActive,\n          pass,\n          redrawReason\n        })\n    );\n\n    // Clear the temp field\n    this._colors = null;\n    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);\n    return {decodePickingColor, stats: renderStatus};\n  }\n\n  // PRIVATE\n  shouldDrawLayer(layer) {\n    return layer.props.pickable;\n  }\n\n  getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      // turn off lighting by adding empty light source object\n      // lights shader module relies on the `lightSources` to turn on/off lighting\n      lightSources: {}\n    };\n  }\n\n  getLayerParameters(layer, layerIndex, viewport) {\n    const pickParameters = {...layer.props.parameters};\n\n    if (this.pickZ) {\n      pickParameters.blend = false;\n    } else {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);\n    }\n\n    return pickParameters;\n  }\n}\n\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n  const {byLayer, byAlpha} = encoded;\n  let a;\n\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  if (byLayer.has(layer)) {\n    const entry = byLayer.get(layer);\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      const entry = {a, layer, viewports: [viewport]};\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return (\n    entry && {\n      pickedLayer: entry.layer,\n      pickedViewports: entry.viewports,\n      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    }\n  );\n}\n"],"file":"pick-layers-pass.js"}