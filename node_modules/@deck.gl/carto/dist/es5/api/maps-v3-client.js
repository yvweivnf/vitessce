"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchLayerData = fetchLayerData;
exports.getData = getData;
exports.mapInstantiation = mapInstantiation;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _config = require("../config");

var _mapsApiCommon = require("./maps-api-common");

var _core = require("@deck.gl/core");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var MAX_GET_LENGTH = 2048;

function request(_x) {
  return _request.apply(this, arguments);
}

function _request() {
  _request = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(_ref) {
    var method, url, format, accessToken, body, response, headers, json;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            method = _ref.method, url = _ref.url, format = _ref.format, accessToken = _ref.accessToken, body = _ref.body;
            headers = {
              Accept: 'application/json'
            };

            if (accessToken) {
              headers.Authorization = "Bearer ".concat(accessToken);
            }

            if (method === 'POST') {
              headers['Content-Type'] = 'application/json';
            }

            _context.prev = 4;
            _context.next = 7;
            return fetch(url, {
              method: method,
              headers: headers,
              body: body
            });

          case 7:
            response = _context.sent;
            _context.next = 13;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](4);
            throw new Error("Failed to connect to Maps API: ".concat(_context.t0));

          case 13:
            if (!(format === _mapsApiCommon.FORMATS.NDJSON)) {
              _context.next = 15;
              break;
            }

            return _context.abrupt("return", response);

          case 15:
            _context.next = 17;
            return response.json();

          case 17:
            json = _context.sent;

            if (!response.ok) {
              dealWithError({
                response: response,
                error: json.error
              });
            }

            return _context.abrupt("return", json.rows ? json.rows : json);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 10]]);
  }));
  return _request.apply(this, arguments);
}

function dealWithError(_ref2) {
  var response = _ref2.response,
      error = _ref2.error;

  switch (response.status) {
    case 400:
      throw new Error("Bad request. ".concat(error));

    case 401:
    case 403:
      throw new Error("Unauthorized access. ".concat(error));

    default:
      throw new Error(error);
  }
}

function getParameters(_ref3) {
  var type = _ref3.type,
      source = _ref3.source,
      geoColumn = _ref3.geoColumn,
      columns = _ref3.columns,
      schema = _ref3.schema;
  var parameters = [(0, _mapsApiCommon.encodeParameter)('client', 'deck-gl-carto')];

  if (schema) {
    parameters.push((0, _mapsApiCommon.encodeParameter)('schema', true));
  }

  var sourceName = type === _mapsApiCommon.MAP_TYPES.QUERY ? 'q' : 'name';
  parameters.push((0, _mapsApiCommon.encodeParameter)(sourceName, source));

  if (type === _mapsApiCommon.MAP_TYPES.TABLE) {
    if (geoColumn) {
      parameters.push((0, _mapsApiCommon.encodeParameter)('geo_column', geoColumn));
    }

    if (columns) {
      parameters.push((0, _mapsApiCommon.encodeParameter)('columns', columns.join(',')));
    }
  }

  return parameters.join('&');
}

function mapInstantiation(_x2) {
  return _mapInstantiation.apply(this, arguments);
}

function _mapInstantiation() {
  _mapInstantiation = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(_ref4) {
    var type, source, connection, credentials, geoColumn, columns, schema, baseUrl, url, accessToken, format, body;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            type = _ref4.type, source = _ref4.source, connection = _ref4.connection, credentials = _ref4.credentials, geoColumn = _ref4.geoColumn, columns = _ref4.columns, schema = _ref4.schema;
            baseUrl = "".concat(credentials.mapsUrl, "/").concat(connection, "/").concat(type);
            url = "".concat(baseUrl, "?").concat(getParameters({
              type: type,
              source: source,
              geoColumn: geoColumn,
              columns: columns,
              schema: schema
            }));
            accessToken = credentials.accessToken;
            format = 'json';

            if (!(url.length > MAX_GET_LENGTH && type === _mapsApiCommon.MAP_TYPES.QUERY)) {
              _context2.next = 10;
              break;
            }

            body = JSON.stringify({
              q: source,
              client: 'deck-gl-carto'
            });
            _context2.next = 9;
            return request({
              method: 'POST',
              url: baseUrl,
              format: format,
              accessToken: accessToken,
              body: body
            });

          case 9:
            return _context2.abrupt("return", _context2.sent);

          case 10:
            _context2.next = 12;
            return request({
              url: url,
              format: format,
              accessToken: accessToken
            });

          case 12:
            return _context2.abrupt("return", _context2.sent);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _mapInstantiation.apply(this, arguments);
}

function getUrlFromMetadata(metadata, format) {
  var m = metadata[format];

  if (m && !m.error && m.url) {
    return m.url[0];
  }

  return null;
}

function checkGetLayerDataParameters(_ref5) {
  var type = _ref5.type,
      source = _ref5.source,
      connection = _ref5.connection,
      localCreds = _ref5.localCreds;

  _core.log.assert(connection, 'Must define connection');

  _core.log.assert(type, 'Must define a type');

  _core.log.assert(source, 'Must define a source');

  _core.log.assert(localCreds.apiVersion === _mapsApiCommon.API_VERSIONS.V3, 'Method only available for v3');

  _core.log.assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');

  _core.log.assert(localCreds.accessToken, 'Must define an accessToken');
}

function fetchLayerData(_x3) {
  return _fetchLayerData.apply(this, arguments);
}

function _fetchLayerData() {
  _fetchLayerData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(_ref6) {
    var type, source, connection, credentials, geoColumn, columns, format, schema, defaultCredentials, localCreds, metadata, url, mapFormat, prioritizedFormats, _i, _prioritizedFormats, f, accessToken, data, result;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            type = _ref6.type, source = _ref6.source, connection = _ref6.connection, credentials = _ref6.credentials, geoColumn = _ref6.geoColumn, columns = _ref6.columns, format = _ref6.format, schema = _ref6.schema;
            defaultCredentials = (0, _config.getDefaultCredentials)();
            localCreds = _objectSpread(_objectSpread({}, defaultCredentials.apiVersion === _mapsApiCommon.API_VERSIONS.V3 && defaultCredentials), credentials);
            checkGetLayerDataParameters({
              type: type,
              source: source,
              connection: connection,
              localCreds: localCreds
            });

            if (!localCreds.mapsUrl) {
              localCreds.mapsUrl = (0, _config.buildMapsUrlFromBase)(localCreds.apiBaseUrl);
            }

            _context3.next = 7;
            return mapInstantiation({
              type: type,
              source: source,
              connection: connection,
              credentials: localCreds,
              geoColumn: geoColumn,
              columns: columns,
              schema: schema
            });

          case 7:
            metadata = _context3.sent;

            if (!format) {
              _context3.next = 14;
              break;
            }

            mapFormat = format;
            url = getUrlFromMetadata(metadata, format);

            _core.log.assert(url, "Format ".concat(format, " not available"));

            _context3.next = 25;
            break;

          case 14:
            prioritizedFormats = [_mapsApiCommon.FORMATS.GEOJSON, _mapsApiCommon.FORMATS.NDJSON, _mapsApiCommon.FORMATS.TILEJSON];
            _i = 0, _prioritizedFormats = prioritizedFormats;

          case 16:
            if (!(_i < _prioritizedFormats.length)) {
              _context3.next = 25;
              break;
            }

            f = _prioritizedFormats[_i];
            url = getUrlFromMetadata(metadata, f);

            if (!url) {
              _context3.next = 22;
              break;
            }

            mapFormat = f;
            return _context3.abrupt("break", 25);

          case 22:
            _i++;
            _context3.next = 16;
            break;

          case 25:
            accessToken = localCreds.accessToken;
            _context3.next = 28;
            return request({
              url: url,
              format: mapFormat,
              accessToken: accessToken
            });

          case 28:
            data = _context3.sent;
            result = {
              data: data,
              format: mapFormat
            };

            if (schema) {
              result.schema = metadata.schema;
            }

            return _context3.abrupt("return", result);

          case 32:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fetchLayerData.apply(this, arguments);
}

function getData(_x4) {
  return _getData.apply(this, arguments);
}

function _getData() {
  _getData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(_ref7) {
    var type, source, connection, credentials, geoColumn, columns, format, layerData;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            type = _ref7.type, source = _ref7.source, connection = _ref7.connection, credentials = _ref7.credentials, geoColumn = _ref7.geoColumn, columns = _ref7.columns, format = _ref7.format;
            _context4.next = 3;
            return fetchLayerData({
              type: type,
              source: source,
              connection: connection,
              credentials: credentials,
              geoColumn: geoColumn,
              columns: columns,
              format: format,
              schema: false
            });

          case 3:
            layerData = _context4.sent;
            return _context4.abrupt("return", layerData.data);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getData.apply(this, arguments);
}
//# sourceMappingURL=maps-v3-client.js.map