import type { DTYPE_VALUES, COLORMAPS } from './constants';
import type { Matrix4 } from 'math.gl';
export declare type SupportedDtype = keyof typeof DTYPE_VALUES;
export declare type SupportedTypedArray = InstanceType<typeof globalThis[`${SupportedDtype}Array`]>;
export interface PixelData {
    data: SupportedTypedArray;
    width: number;
    height: number;
}
export declare type PixelSourceSelection<S extends string[]> = {
    [K in S[number]]: number;
};
export interface RasterSelection<S extends string[]> {
    selection: PixelSourceSelection<S>;
    signal?: AbortSignal;
}
export interface TileSelection<S extends string[]> {
    x: number;
    y: number;
    selection: PixelSourceSelection<S>;
    signal?: AbortSignal;
}
interface PhysicalSize {
    size: number;
    unit: string;
}
export interface PixelSourceMeta {
    physicalSizes?: {
        [key: string]: PhysicalSize;
    };
    photometricInterpretation?: number;
}
export declare type Labels<S extends string[]> = [...S, 'y', 'x'] | [...S, 'y', 'x', '_c'];
export interface PixelSource<S extends string[]> {
    getRaster(sel: RasterSelection<S>): Promise<PixelData>;
    getTile(sel: TileSelection<S>): Promise<PixelData>;
    onTileError(err: Error): void;
    shape: number[];
    dtype: SupportedDtype;
    labels: Labels<S>;
    tileSize: number;
    meta?: PixelSourceMeta;
}
declare type Color = [r: number, g: number, b: number];
declare type ColorPaletteExtensionProps = {
    colors: Color[];
    opacity: number;
    transparentColor: Color;
    useTransparentColor: boolean;
};
declare type AdditiveColormapExtensionProps = {
    colormap: typeof COLORMAPS[number];
    opacity: number;
    useTransparentColor: boolean;
};
declare type LensExtensionProps = {
    lensEnabled: boolean;
    lensSelection: number;
    lensRadius: number;
    lensBorderRadius: number;
    colors: Color[];
    lensBorderColor: Color;
};
declare type PreciseLayerProps<S extends string[]> = {
    contrastLimits: [begin: number, end: number][];
    selections: PixelSourceSelection<S>[];
    dtype: keyof typeof DTYPE_VALUES;
    opacity?: number;
    modelMatrix?: Matrix4 | undefined;
};
declare type Override<What, With> = Omit<What, keyof With> & With;
declare type ExtractLoader<LayerProps, S extends string[]> = LayerProps extends {
    loader: object[];
} ? {
    loader: PixelSource<S>[];
} : LayerProps extends {
    loader: object;
} ? {
    loader: PixelSource<S>;
} : {};
declare type WithExtensionProps<LayerProps> = LayerProps extends {
    extensions: unknown;
} ? Partial<ColorPaletteExtensionProps & AdditiveColormapExtensionProps & LensExtensionProps> & {
    [extensionProp: string]: any;
} : {};
/**
 * DocumentationJS does not understand TS syntax in JSDoc annotations,
 * which means our generated types from `LayerProps` aren't very precise.
 *
 * This utility type overrides keys from `LayerProps` with
 * more precise types if they exist in `PreciseLayerProps`. We import this type in
 * each Layer constructor, ignored by DocumentationJS, meaning our documentation
 * stays the same (with less precise types) but code completion / type-checking
 * is much more strict and useful.
 */
export declare type Viv<LayerProps, S extends string[] = string[]> = Override<Omit<LayerProps, 'loader'>, PreciseLayerProps<S>> & ExtractLoader<LayerProps, S> & WithExtensionProps<LayerProps>;
export {};
