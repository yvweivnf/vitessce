"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toDeckColor = toDeckColor;
exports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;
exports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;
exports.distance2d = distance2d;
exports.mix = mix;
exports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;
exports.nearestPointOnLine = nearestPointOnLine;
exports.getPickedEditHandle = getPickedEditHandle;
exports.getPickedSnapSourceEditHandle = getPickedSnapSourceEditHandle;
exports.getNonGuidePicks = getNonGuidePicks;
exports.getPickedExistingEditHandle = getPickedExistingEditHandle;
exports.getPickedIntermediateEditHandle = getPickedIntermediateEditHandle;
exports.getPickedEditHandles = getPickedEditHandles;
exports.getEditHandlesForGeometry = getEditHandlesForGeometry;

var _destination = _interopRequireDefault(require("@turf/destination"));

var _bearing = _interopRequireDefault(require("@turf/bearing"));

var _pointToLineDistance = _interopRequireDefault(require("@turf/point-to-line-distance"));

var _meta = require("@turf/meta");

var _helpers = require("@turf/helpers");

var _invariant = require("@turf/invariant");

var _viewportMercatorProject = _interopRequireDefault(require("viewport-mercator-project"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function toDeckColor(color) {
  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];

  if (!Array.isArray(color)) {
    return defaultColor;
  }

  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];
} //
// a GeoJSON helper function that calls the provided function with
// an argument that is the most deeply-nested array having elements
// that are arrays of primitives as an argument, e.g.
//
// {
//   "type": "MultiPolygon",
//   "coordinates": [
//       [
//           [[30, 20], [45, 40], [10, 40], [30, 20]]
//       ],
//       [
//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]
//       ]
//   ]
// }
//
// the function would be called on:
//
// [[30, 20], [45, 40], [10, 40], [30, 20]]
//
// and
//
// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]
//


function recursivelyTraverseNestedArrays(array, prefix, fn) {
  if (!Array.isArray(array[0])) {
    return true;
  }

  for (var i = 0; i < array.length; i++) {
    if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {
      fn(array, prefix);
      break;
    }
  }

  return false;
}

function generatePointsParallelToLinePoints(p1, p2, mapCoords) {
  var lineString = {
    type: 'LineString',
    coordinates: [p1, p2]
  };
  var pt = (0, _helpers.point)(mapCoords);
  var ddistance = (0, _pointToLineDistance["default"])(pt, lineString);
  var lineBearing = (0, _bearing["default"])(p1, p2); // Check if current point is to the left or right of line
  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)
  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)

  var isPointToLeftOfLine = (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string

  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString
  // Add the distance as the current position moves away from the lineString

  var p3 = (0, _destination["default"])(p2, ddistance, orthogonalBearing);
  var p4 = (0, _destination["default"])(p1, ddistance, orthogonalBearing);
  return [p3.geometry.coordinates, p4.geometry.coordinates];
}

function distance2d(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

function mix(a, b, ratio) {
  return b * ratio + a * (1 - ratio);
}

function nearestPointOnProjectedLine(line, inPoint, viewport) {
  var wmViewport = new _viewportMercatorProject["default"](viewport); // Project the line to viewport, then find the nearest point

  var coordinates = line.geometry.coordinates;
  var projectedCoords = coordinates.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        x = _ref2[0],
        y = _ref2[1],
        _ref2$ = _ref2[2],
        z = _ref2$ === void 0 ? 0 : _ref2$;

    return wmViewport.project([x, y, z]);
  }); // @ts-ignore

  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),
      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),
      x = _wmViewport$project2[0],
      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));


  var minDistance = Infinity;
  var minPointInfo = {};
  projectedCoords.forEach(function (_ref3, index) {
    var _ref4 = _slicedToArray(_ref3, 2),
        x2 = _ref4[0],
        y2 = _ref4[1];

    if (index === 0) {
      return;
    }

    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),
        x1 = _projectedCoords[0],
        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]
    // convert to Ax + By + C = 0


    var A = y1 - y2;
    var B = x2 - x1;
    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

    var div = A * A + B * B;
    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds

    if (distance < minDistance) {
      minDistance = distance;
      minPointInfo = {
        index: index,
        x0: (B * (B * x - A * y) - A * C) / div,
        y0: (A * (-B * x + A * y) - B * C) / div
      };
    }
  }); // @ts-ignore

  var _minPointInfo = minPointInfo,
      index = _minPointInfo.index,
      x0 = _minPointInfo.x0,
      y0 = _minPointInfo.y0;

  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),
      x1 = _projectedCoords2[0],
      y1 = _projectedCoords2[1],
      _projectedCoords2$ = _projectedCoords2[2],
      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;

  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),
      x2 = _projectedCoords$inde[0],
      y2 = _projectedCoords$inde[1],
      _projectedCoords$inde2 = _projectedCoords$inde[2],
      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z


  var lineLength = distance2d(x1, y1, x2, y2);
  var startToPointLength = distance2d(x1, y1, x0, y0);
  var ratio = startToPointLength / lineLength;
  var z0 = mix(z1, z2, ratio);
  return {
    type: 'Feature',
    geometry: {
      type: 'Point',
      coordinates: wmViewport.unproject([x0, y0, z0])
    },
    properties: {
      // TODO: calculate the distance in proper units
      dist: minDistance,
      index: index - 1
    }
  };
}

function nearestPointOnLine(lines, inPoint, viewport) {
  var _lines$geometry, _lines$geometry2;

  var mercator;

  if (viewport) {
    mercator = new _viewportMercatorProject["default"](viewport);
  }

  var closestPoint = (0, _helpers.point)([Infinity, Infinity], {
    dist: Infinity
  });

  if (!((_lines$geometry = lines.geometry) === null || _lines$geometry === void 0 ? void 0 : _lines$geometry.coordinates.length) || ((_lines$geometry2 = lines.geometry) === null || _lines$geometry2 === void 0 ? void 0 : _lines$geometry2.coordinates.length) < 2) {
    return closestPoint;
  } // @ts-ignore


  (0, _meta.flattenEach)(lines, function (line) {
    var coords = (0, _invariant.getCoords)(line); // @ts-ignore

    var pointCoords = (0, _invariant.getCoords)(inPoint);
    var minDist;
    var to;
    var from;
    var x;
    var y;
    var segmentIdx;
    var dist;

    if (coords.length > 1 && pointCoords.length) {
      var lineCoordinates;
      var pointCoordinate; // If viewport is given, then translate these coordinates to pixels to increase precision

      if (mercator) {
        lineCoordinates = coords.map(function (lineCoordinate) {
          return mercator.project(lineCoordinate);
        });
        pointCoordinate = mercator.project(pointCoords);
      } else {
        lineCoordinates = coords;
        pointCoordinate = pointCoords;
      }

      for (var n = 1; n < lineCoordinates.length; n++) {
        if (lineCoordinates[n][0] !== lineCoordinates[n - 1][0]) {
          var slope = (lineCoordinates[n][1] - lineCoordinates[n - 1][1]) / (lineCoordinates[n][0] - lineCoordinates[n - 1][0]);
          var inverseSlope = lineCoordinates[n][1] - slope * lineCoordinates[n][0];
          dist = Math.abs(slope * pointCoordinate[0] + inverseSlope - pointCoordinate[1]) / Math.sqrt(slope * slope + 1);
        } else dist = Math.abs(pointCoordinate[0] - lineCoordinates[n][0]); // length^2 of line segment


        var rl2 = Math.pow(lineCoordinates[n][1] - lineCoordinates[n - 1][1], 2) + Math.pow(lineCoordinates[n][0] - lineCoordinates[n - 1][0], 2); // distance^2 of pt to end line segment

        var ln2 = Math.pow(lineCoordinates[n][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n][0] - pointCoordinate[0], 2); // distance^2 of pt to begin line segment

        var lnm12 = Math.pow(lineCoordinates[n - 1][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n - 1][0] - pointCoordinate[0], 2); // minimum distance^2 of pt to infinite line

        var dist2 = Math.pow(dist, 2); // calculated length^2 of line segment

        var calcrl2 = ln2 - dist2 + lnm12 - dist2; // redefine minimum distance to line segment (not infinite line) if necessary

        if (calcrl2 > rl2) {
          dist = Math.sqrt(Math.min(ln2, lnm12));
        }

        if (minDist === null || minDist === undefined || minDist > dist) {
          // eslint-disable-next-line max-depth
          if (calcrl2 > rl2) {
            // eslint-disable-next-line max-depth
            if (lnm12 < ln2) {
              to = 0; // nearer to previous point

              from = 1;
            } else {
              from = 0; // nearer to current point

              to = 1;
            }
          } else {
            // perpendicular from point intersects line segment
            to = Math.sqrt(lnm12 - dist2) / Math.sqrt(rl2);
            from = Math.sqrt(ln2 - dist2) / Math.sqrt(rl2);
          }

          minDist = dist;
          segmentIdx = n;
        }
      }

      var dx = lineCoordinates[segmentIdx - 1][0] - lineCoordinates[segmentIdx][0];
      var dy = lineCoordinates[segmentIdx - 1][1] - lineCoordinates[segmentIdx][1];
      x = lineCoordinates[segmentIdx - 1][0] - dx * to;
      y = lineCoordinates[segmentIdx - 1][1] - dy * to;
    } // index needs to be -1 because we have to account for the shift from initial backscan


    var snapPoint = {
      x: x,
      y: y,
      idx: segmentIdx - 1,
      to: to,
      from: from
    };

    if (mercator) {
      var pixelToLatLong = mercator.unproject([snapPoint.x, snapPoint.y]);
      snapPoint = {
        x: pixelToLatLong[0],
        y: pixelToLatLong[1],
        idx: segmentIdx - 1,
        to: to,
        from: from
      };
    }

    closestPoint = (0, _helpers.point)([snapPoint.x, snapPoint.y], {
      dist: Math.abs(snapPoint.from - snapPoint.to),
      index: snapPoint.idx
    });
  });
  return closestPoint;
}

function getPickedEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.length ? handles[0] : null;
}

function getPickedSnapSourceEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (handle) {
    return handle.properties.editHandleType === 'snap-source';
  });
}

function getNonGuidePicks(picks) {
  return picks && picks.filter(function (pick) {
    return !pick.isGuide;
  });
}

function getPickedExistingEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (_ref5) {
    var properties = _ref5.properties;
    return properties.featureIndex >= 0 && properties.editHandleType === 'existing';
  });
}

function getPickedIntermediateEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (_ref6) {
    var properties = _ref6.properties;
    return properties.featureIndex >= 0 && properties.editHandleType === 'intermediate';
  });
}

function getPickedEditHandles(picks) {
  var handles = picks && picks.filter(function (pick) {
    return pick.isGuide && pick.object.properties.guideType === 'editHandle';
  }).map(function (pick) {
    return pick.object;
  }) || [];
  return handles;
}

function getEditHandlesForGeometry(geometry, featureIndex) {
  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';
  var handles = [];

  switch (geometry.type) {
    case 'Point':
      // positions are not nested
      handles = [{
        type: 'Feature',
        properties: {
          guideType: 'editHandle',
          editHandleType: editHandleType,
          positionIndexes: [],
          featureIndex: featureIndex
        },
        geometry: {
          type: 'Point',
          coordinates: geometry.coordinates
        }
      }];
      break;

    case 'MultiPoint':
    case 'LineString':
      // positions are nested 1 level
      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));
      break;

    case 'Polygon':
    case 'MultiLineString':
      // positions are nested 2 levels
      for (var a = 0; a < geometry.coordinates.length; a++) {
        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));

        if (geometry.type === 'Polygon') {
          // Don't repeat the first/last handle for Polygons
          handles = handles.slice(0, -1);
        }
      }

      break;

    case 'MultiPolygon':
      // positions are nested 3 levels
      for (var _a = 0; _a < geometry.coordinates.length; _a++) {
        for (var b = 0; b < geometry.coordinates[_a].length; b++) {
          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons

          handles = handles.slice(0, -1);
        }
      }

      break;

    default:
      // @ts-ignore
      throw Error("Unhandled geometry type: ".concat(geometry.type));
  }

  return handles;
}

function getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {
  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';
  var editHandles = [];

  for (var i = 0; i < coordinates.length; i++) {
    var position = coordinates[i];
    editHandles.push({
      type: 'Feature',
      properties: {
        guideType: 'editHandle',
        positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [i]),
        featureIndex: featureIndex,
        editHandleType: editHandleType
      },
      geometry: {
        type: 'Point',
        coordinates: position
      }
    });
  }

  return editHandles;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy50cyJdLCJuYW1lcyI6WyJ0b0RlY2tDb2xvciIsImNvbG9yIiwiZGVmYXVsdENvbG9yIiwiQXJyYXkiLCJpc0FycmF5IiwicmVjdXJzaXZlbHlUcmF2ZXJzZU5lc3RlZEFycmF5cyIsImFycmF5IiwicHJlZml4IiwiZm4iLCJpIiwibGVuZ3RoIiwiZ2VuZXJhdGVQb2ludHNQYXJhbGxlbFRvTGluZVBvaW50cyIsInAxIiwicDIiLCJtYXBDb29yZHMiLCJsaW5lU3RyaW5nIiwidHlwZSIsImNvb3JkaW5hdGVzIiwicHQiLCJkZGlzdGFuY2UiLCJsaW5lQmVhcmluZyIsImlzUG9pbnRUb0xlZnRPZkxpbmUiLCJvcnRob2dvbmFsQmVhcmluZyIsInAzIiwicDQiLCJnZW9tZXRyeSIsImRpc3RhbmNlMmQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImR4IiwiZHkiLCJNYXRoIiwic3FydCIsIm1peCIsImEiLCJiIiwicmF0aW8iLCJuZWFyZXN0UG9pbnRPblByb2plY3RlZExpbmUiLCJsaW5lIiwiaW5Qb2ludCIsInZpZXdwb3J0Iiwid21WaWV3cG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJwcm9qZWN0ZWRDb29yZHMiLCJtYXAiLCJ4IiwieSIsInoiLCJwcm9qZWN0IiwibWluRGlzdGFuY2UiLCJJbmZpbml0eSIsIm1pblBvaW50SW5mbyIsImZvckVhY2giLCJpbmRleCIsIkEiLCJCIiwiQyIsImRpdiIsImRpc3RhbmNlIiwiYWJzIiwieDAiLCJ5MCIsInoxIiwiejIiLCJsaW5lTGVuZ3RoIiwic3RhcnRUb1BvaW50TGVuZ3RoIiwiejAiLCJ1bnByb2plY3QiLCJwcm9wZXJ0aWVzIiwiZGlzdCIsIm5lYXJlc3RQb2ludE9uTGluZSIsImxpbmVzIiwibWVyY2F0b3IiLCJjbG9zZXN0UG9pbnQiLCJjb29yZHMiLCJwb2ludENvb3JkcyIsIm1pbkRpc3QiLCJ0byIsImZyb20iLCJzZWdtZW50SWR4IiwibGluZUNvb3JkaW5hdGVzIiwicG9pbnRDb29yZGluYXRlIiwibGluZUNvb3JkaW5hdGUiLCJuIiwic2xvcGUiLCJpbnZlcnNlU2xvcGUiLCJybDIiLCJwb3ciLCJsbjIiLCJsbm0xMiIsImRpc3QyIiwiY2FsY3JsMiIsIm1pbiIsInVuZGVmaW5lZCIsInNuYXBQb2ludCIsImlkeCIsInBpeGVsVG9MYXRMb25nIiwiZ2V0UGlja2VkRWRpdEhhbmRsZSIsInBpY2tzIiwiaGFuZGxlcyIsImdldFBpY2tlZEVkaXRIYW5kbGVzIiwiZ2V0UGlja2VkU25hcFNvdXJjZUVkaXRIYW5kbGUiLCJmaW5kIiwiaGFuZGxlIiwiZWRpdEhhbmRsZVR5cGUiLCJnZXROb25HdWlkZVBpY2tzIiwiZmlsdGVyIiwicGljayIsImlzR3VpZGUiLCJnZXRQaWNrZWRFeGlzdGluZ0VkaXRIYW5kbGUiLCJmZWF0dXJlSW5kZXgiLCJnZXRQaWNrZWRJbnRlcm1lZGlhdGVFZGl0SGFuZGxlIiwib2JqZWN0IiwiZ3VpZGVUeXBlIiwiZ2V0RWRpdEhhbmRsZXNGb3JHZW9tZXRyeSIsInBvc2l0aW9uSW5kZXhlcyIsImNvbmNhdCIsImdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMiLCJzbGljZSIsIkVycm9yIiwicG9zaXRpb25JbmRleFByZWZpeCIsImVkaXRIYW5kbGVzIiwicG9zaXRpb24iLCJwdXNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhTyxTQUFTQSxXQUFULENBQ0xDLEtBREssRUFHNkI7QUFBQSxNQURsQ0MsWUFDa0MsdUVBRGUsQ0FBQyxHQUFELEVBQU0sQ0FBTixFQUFTLENBQVQsRUFBWSxHQUFaLENBQ2Y7O0FBQ2xDLE1BQUksQ0FBQ0MsS0FBSyxDQUFDQyxPQUFOLENBQWNILEtBQWQsQ0FBTCxFQUEyQjtBQUN6QixXQUFPQyxZQUFQO0FBQ0Q7O0FBQ0QsU0FBTyxDQUFDRCxLQUFLLENBQUMsQ0FBRCxDQUFMLEdB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QUEsV0FBVyxDQUFDRSxJQUFaLENBQWlCO0FBQ2Y3RyxNQUFBQSxJQUFJLEVBQUUsU0FEUztBQUVmc0QsTUFBQUEsVUFBVSxFQUFFO0FBQ1Y2QyxRQUFBQSxTQUFTLEVBQUUsWUFERDtBQUVWRSxRQUFBQSxlQUFlLCtCQUFNSyxtQkFBTixJQUEyQmpILENBQTNCLEVBRkw7QUFHVnVHLFFBQUFBLFlBQVksRUFBWkEsWUFIVTtBQUlWTixRQUFBQSxjQUFjLEVBQWRBO0FBSlUsT0FGRztBQVFmakYsTUFBQUEsUUFBUSxFQUFFO0FBQ1JULFFBQUFBLElBQUksRUFBRSxPQURFO0FBRVJDLFFBQUFBLFdBQVcsRUFBRTJHO0FBRkw7QUFSSyxLQUFqQjtBQWFEOztBQUNELFNBQU9ELFdBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZXN0aW5hdGlvbiBmcm9tICdAdHVyZi9kZXN0aW5hdGlvbic7XG5pbXBvcnQgYmVhcmluZyBmcm9tICdAdHVyZi9iZWFyaW5nJztcbmltcG9ydCBwb2ludFRvTGluZURpc3RhbmNlIGZyb20gJ0B0dXJmL3BvaW50LXRvLWxpbmUtZGlzdGFuY2UnO1xuaW1wb3J0IHsgZmxhdHRlbkVhY2ggfSBmcm9tICdAdHVyZi9tZXRhJztcbmltcG9ydCB7IHBvaW50LCBNdWx0aUxpbmVTdHJpbmcgfSBmcm9tICdAdHVyZi9oZWxwZXJzJztcbmltcG9ydCB7IGdldENvb3JkcyB9IGZyb20gJ0B0dXJmL2ludmFyaWFudCc7XG5pbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IFZpZXdwb3J0LCBQaWNrLCBFZGl0SGFuZGxlRmVhdHVyZSwgRWRpdEhhbmRsZVR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIEdlb21ldHJ5LFxuICBQb3NpdGlvbixcbiAgUG9pbnQsXG4gIExpbmVTdHJpbmcsXG4gIEZlYXR1cmVPZixcbiAgRmVhdHVyZVdpdGhQcm9wcyxcbn0gZnJvbSAnLi9nZW9qc29uLXR5cGVzJztcblxuZXhwb3J0IHR5cGUgTmVhcmVzdFBvaW50VHlwZSA9IEZlYXR1cmVXaXRoUHJvcHM8UG9pbnQsIHsgZGlzdDogbnVtYmVyOyBpbmRleDogbnVtYmVyIH0+O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9EZWNrQ29sb3IoXG4gIGNvbG9yPzogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBudW1iZXIsXG4gIGRlZmF1bHRDb2xvcjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbMjU1LCAwLCAwLCAyNTVdXG4pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICByZXR1cm4gZGVmYXVsdENvbG9yO1xuICB9XG4gIHJldHVybiBbY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSwgY29sb3JbM10gKiAyNTVdO1xufVxuXG4vL1xuLy8gYSBHZW9KU09OIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aXRoXG4vLyBhbiBhcmd1bWVudCB0aGF0IGlzIHRoZSBtb3N0IGRlZXBseS1uZXN0ZWQgYXJyYXkgaGF2aW5nIGVsZW1lbnRzXG4vLyB0aGF0IGFyZSBhcnJheXMgb2YgcHJpbWl0aXZlcyBhcyBhbiBhcmd1bWVudCwgZS5nLlxuLy9cbi8vIHtcbi8vICAgXCJ0eXBlXCI6IFwiTXVsdGlQb2x5Z29uXCIsXG4vLyAgIFwiY29vcmRpbmF0ZXNcIjogW1xuLy8gICAgICAgW1xuLy8gICAgICAgICAgIFtbMzAsIDIwXSwgWzQ1LCA0MF0sIFsxMCwgNDBdLCBbMzAsIDIwXV1cbi8vICAgICAgIF0sXG4vLyAgICAgICBbXG4vLyAgICAgICAgICAgW1sxNSwgNV0sIFs0MCwgMTBdLCBbMTAsIDIwXSwgWzUsIDEwXSwgWzE1LCA1XV1cbi8vICAgICAgIF1cbi8vICAgXVxuLy8gfVxuLy9cbi8vIHRoZSBmdW5jdGlvbiB3b3VsZCBiZSBjYWxsZWQgb246XG4vL1xuLy8gW1szMCwgMjBdLCBbNDUsIDQwXSwgWzEwLCA0MF0sIFszMCwgMjBdXVxuLy9cbi8vIGFuZFxuLy9cbi8vIFtbMTUsIDVdLCBbNDAsIDEwXSwgWzEwLCAyMF0sIFs1LCAxMF0sIFsxNSwgNV1dXG4vL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VOZXN0ZWRBcnJheXMoXG4gIGFycmF5OiBBcnJheTxhbnk+LFxuICBwcmVmaXg6IEFycmF5PG51bWJlcj4sXG4gIGZuOiBGdW5jdGlvblxuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheVswXSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZWx5VHJhdmVyc2VOZXN0ZWRBcnJheXMoYXJyYXlbaV0sIFsuLi5wcmVmaXgsIGldLCBmbikpIHtcbiAgICAgIGZuKGFycmF5LCBwcmVmaXgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUG9pbnRzUGFyYWxsZWxUb0xpbmVQb2ludHMoXG4gIHAxOiBQb3NpdGlvbixcbiAgcDI6IFBvc2l0aW9uLFxuICBtYXBDb29yZHM6IFBvc2l0aW9uXG4pOiBQb3NpdGlvbltdIHtcbiAgY29uc3QgbGluZVN0cmluZzogTGluZVN0cmluZyA9IHtcbiAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgY29vcmRpbmF0ZXM6IFtwMSwgcDJdLFxuICB9O1xuICBjb25zdCBwdCA9IHBvaW50KG1hcENvb3Jkcyk7XG4gIGNvbnN0IGRkaXN0YW5jZSA9IHBvaW50VG9MaW5lRGlzdGFuY2UocHQsIGxpbmVTdHJpbmcpO1xuICBjb25zdCBsaW5lQmVhcmluZyA9IGJlYXJpbmcocDEsIHAyKTtcblxuICAvLyBDaGVjayBpZiBjdXJyZW50IHBvaW50IGlzIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IG9mIGxpbmVcbiAgLy8gTGluZSBmcm9tIEE9KHgxLHkxKSB0byBCPSh4Mix5MikgYSBwb2ludCBQPSh4LHkpXG4gIC8vIHRoZW4gKHjiiJJ4MSkoeTLiiJJ5MSniiJIoeeKIknkxKSh4MuKIkngxKVxuICBjb25zdCBpc1BvaW50VG9MZWZ0T2ZMaW5lID1cbiAgICAobWFwQ29vcmRzWzBdIC0gcDFbMF0pICogKHAyWzFdIC0gcDFbMV0pIC0gKG1hcENvb3Jkc1sxXSAtIHAxWzFdKSAqIChwMlswXSAtIHAxWzBdKTtcblxuICAvLyBCZWFyaW5nIHRvIGRyYXcgcGVycGVuZGljdWxhciB0byB0aGUgbGluZSBzdHJpbmdcbiAgY29uc3Qgb3J0aG9nb25hbEJlYXJpbmcgPSBpc1BvaW50VG9MZWZ0T2ZMaW5lIDwgMCA/IGxpbmVCZWFyaW5nIC0gOTAgOiBsaW5lQmVhcmluZyAtIDI3MDtcblxuICAvLyBHZXQgY29vcmRpbmF0ZXMgZm9yIHRoZSBwb2ludCBwMyBhbmQgcDQgd2hpY2ggYXJlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGxpbmVTdHJpbmdcbiAgLy8gQWRkIHRoZSBkaXN0YW5jZSBhcyB0aGUgY3VycmVudCBwb3NpdGlvbiBtb3ZlcyBhd2F5IGZyb20gdGhlIGxpbmVTdHJpbmdcbiAgY29uc3QgcDMgPSBkZXN0aW5hdGlvbihwMiwgZGRpc3RhbmNlLCBvcnRob2dvbmFsQmVhcmluZyk7XG4gIGNvbnN0IHA0ID0gZGVzdGluYXRpb24ocDEsIGRkaXN0YW5jZSwgb3J0aG9nb25hbEJlYXJpbmcpO1xuXG4gIHJldHVybiBbcDMuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHA0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzXSBhcyBQb3NpdGlvbltdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UyZCh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgZHggPSB4MSAtIHgyO1xuICBjb25zdCBkeSA9IHkxIC0geTI7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWl4KGE6IG51bWJlciwgYjogbnVtYmVyLCByYXRpbzogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGIgKiByYXRpbyArIGEgKiAoMSAtIHJhdGlvKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lYXJlc3RQb2ludE9uUHJvamVjdGVkTGluZShcbiAgbGluZTogRmVhdHVyZU9mPExpbmVTdHJpbmc+LFxuICBpblBvaW50OiBGZWF0dXJlT2Y8UG9pbnQ+LFxuICB2aWV3cG9ydDogVmlld3BvcnRcbik6IE5lYXJlc3RQb2ludFR5cGUge1xuICBjb25zdCB3bVZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodmlld3BvcnQpO1xuICAvLyBQcm9qZWN0IHRoZSBsaW5lIHRvIHZpZXdwb3J0LCB0aGVuIGZpbmQgdGhlIG5lYXJlc3QgcG9pbnRcbiAgY29uc3QgY29vcmRpbmF0ZXM6IEFycmF5PEFycmF5PG51bWJlcj4+ID0gbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcyBhcyBhbnk7XG4gIGNvbnN0IHByb2plY3RlZENvb3JkcyA9IGNvb3JkaW5hdGVzLm1hcCgoW3gsIHksIHogPSAwXSkgPT4gd21WaWV3cG9ydC5wcm9qZWN0KFt4LCB5LCB6XSkpO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IFt4LCB5XSA9IHdtVmlld3BvcnQucHJvamVjdChpblBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgLy8gY29uc29sZS5sb2coJ3Byb2plY3RlZENvb3JkcycsIEpTT04uc3RyaW5naWZ5KHByb2plY3RlZENvb3JkcykpO1xuXG4gIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICBsZXQgbWluUG9pbnRJbmZvID0ge307XG5cbiAgcHJvamVjdGVkQ29vcmRzLmZvckVhY2goKFt4MiwgeTJdLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IFt4MSwgeTFdID0gcHJvamVjdGVkQ29vcmRzW2luZGV4IC0gMV07XG5cbiAgICAvLyBsaW5lIGZyb20gcHJvamVjdGVkQ29vcmRzW2luZGV4IC0gMV0gdG8gcHJvamVjdGVkQ29vcmRzW2luZGV4XVxuICAgIC8vIGNvbnZlcnQgdG8gQXggKyBCeSArIEMgPSAwXG4gICAgY29uc3QgQSA9IHkxIC0geTI7XG4gICAgY29uc3QgQiA9IHgyIC0geDE7XG4gICAgY29uc3QgQyA9IHgxICogeTIgLSB4MiAqIHkxO1xuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxuICAgIGNvbnN0IGRpdiA9IEEgKiBBICsgQiAqIEI7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyhBICogeCArIEIgKiB5ICsgQykgLyBNYXRoLnNxcnQoZGl2KTtcblxuICAgIC8vIFRPRE86IENoZWNrIGlmIGluc2lkZSBib3VuZHNcblxuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgbWluUG9pbnRJbmZvID0ge1xuICAgICAgICBpbmRleCxcbiAgICAgICAgeDA6IChCICogKEIgKiB4IC0gQSAqIHkpIC0gQSAqIEMpIC8gZGl2LFxuICAgICAgICB5MDogKEEgKiAoLUIgKiB4ICsgQSAqIHkpIC0gQiAqIEMpIC8gZGl2LFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHsgaW5kZXgsIHgwLCB5MCB9ID0gbWluUG9pbnRJbmZvO1xuICBjb25zdCBbeDEsIHkxLCB6MSA9IDBdID0gcHJvamVjdGVkQ29vcmRzW2luZGV4IC0gMV07XG4gIGNvbnN0IFt4MiwgeTIsIHoyID0gMF0gPSBwcm9qZWN0ZWRDb29yZHNbaW5kZXhdO1xuXG4gIC8vIGNhbGN1bGF0ZSB3aGF0IHJhdGlvIG9mIHRoZSBsaW5lIHdlIGFyZSBvbiB0byBmaW5kIHRoZSBwcm9wZXIgelxuICBjb25zdCBsaW5lTGVuZ3RoID0gZGlzdGFuY2UyZCh4MSwgeTEsIHgyLCB5Mik7XG4gIGNvbnN0IHN0YXJ0VG9Qb2ludExlbmd0aCA9IGRpc3RhbmNlMmQoeDEsIHkxLCB4MCwgeTApO1xuICBjb25zdCByYXRpbyA9IHN0YXJ0VG9Qb2ludExlbmd0aCAvIGxpbmVMZW5ndGg7XG4gIGNvbnN0IHowID0gbWl4KHoxLCB6MiwgcmF0aW8pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgY29vcmRpbmF0ZXM6IHdtVmlld3BvcnQudW5wcm9qZWN0KFt4MCwgeTAsIHowXSksXG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAvLyBUT0RPOiBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGluIHByb3BlciB1bml0c1xuICAgICAgZGlzdDogbWluRGlzdGFuY2UsXG4gICAgICBpbmRleDogaW5kZXggLSAxLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWFyZXN0UG9pbnRPbkxpbmU8RyBleHRlbmRzIExpbmVTdHJpbmcgfCBNdWx0aUxpbmVTdHJpbmc+KFxuICBsaW5lczogRmVhdHVyZU9mPExpbmVTdHJpbmc+LFxuICBpblBvaW50OiBGZWF0dXJlT2Y8UG9pbnQ+LFxuICB2aWV3cG9ydD86IFZpZXdwb3J0XG4pOiBOZWFyZXN0UG9pbnRUeXBlIHtcbiAgbGV0IG1lcmNhdG9yO1xuXG4gIGlmICh2aWV3cG9ydCkge1xuICAgIG1lcmNhdG9yID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodmlld3BvcnQpO1xuICB9XG4gIGxldCBjbG9zZXN0UG9pbnQ6IGFueSA9IHBvaW50KFtJbmZpbml0eSwgSW5maW5pdHldLCB7XG4gICAgZGlzdDogSW5maW5pdHksXG4gIH0pO1xuXG4gIGlmICghbGluZXMuZ2VvbWV0cnk/LmNvb3JkaW5hdGVzLmxlbmd0aCB8fCBsaW5lcy5nZW9tZXRyeT8uY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBjbG9zZXN0UG9pbnQ7XG4gIH1cblxuICAvLyBAdHMtaWdub3JlXG4gIGZsYXR0ZW5FYWNoKGxpbmVzLCAobGluZTogYW55KSA9PiB7XG4gICAgY29uc3QgY29vcmRzOiBhbnkgPSBnZXRDb29yZHMobGluZSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHBvaW50Q29vcmRzOiBhbnkgPSBnZXRDb29yZHMoaW5Qb2ludCk7XG5cbiAgICBsZXQgbWluRGlzdDtcbiAgICBsZXQgdG87XG4gICAgbGV0IGZyb207XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IHNlZ21lbnRJZHg7XG4gICAgbGV0IGRpc3Q7XG5cbiAgICBpZiAoY29vcmRzLmxlbmd0aCA+IDEgJiYgcG9pbnRDb29yZHMubGVuZ3RoKSB7XG4gICAgICBsZXQgbGluZUNvb3JkaW5hdGVzO1xuICAgICAgbGV0IHBvaW50Q29vcmRpbmF0ZTtcblxuICAgICAgLy8gSWYgdmlld3BvcnQgaXMgZ2l2ZW4sIHRoZW4gdHJhbnNsYXRlIHRoZXNlIGNvb3JkaW5hdGVzIHRvIHBpeGVscyB0byBpbmNyZWFzZSBwcmVjaXNpb25cbiAgICAgIGlmIChtZXJjYXRvcikge1xuICAgICAgICBsaW5lQ29vcmRpbmF0ZXMgPSBjb29yZHMubWFwKChsaW5lQ29vcmRpbmF0ZSkgPT4gbWVyY2F0b3IucHJvamVjdChsaW5lQ29vcmRpbmF0ZSkpO1xuICAgICAgICBwb2ludENvb3JkaW5hdGUgPSBtZXJjYXRvci5wcm9qZWN0KHBvaW50Q29vcmRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVDb29yZGluYXRlcyA9IGNvb3JkcztcbiAgICAgICAgcG9pbnRDb29yZGluYXRlID0gcG9pbnRDb29yZHM7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IG4gPSAxOyBuIDwgbGluZUNvb3JkaW5hdGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGlmIChsaW5lQ29vcmRpbmF0ZXNbbl1bMF0gIT09IGxpbmVDb29yZGluYXRlc1tuIC0gMV1bMF0pIHtcbiAgICAgICAgICBjb25zdCBzbG9wZSA9XG4gICAgICAgICAgICAobGluZUNvb3JkaW5hdGVzW25dWzFdIC0gbGluZUNvb3JkaW5hdGVzW24gLSAxXVsxXSkgL1xuICAgICAgICAgICAgKGxpbmVDb29yZGluYXRlc1tuXVswXSAtIGxpbmVDb29yZGluYXRlc1tuIC0gMV1bMF0pO1xuICAgICAgICAgIGNvbnN0IGludmVyc2VTbG9wZSA9IGxpbmVDb29yZGluYXRlc1tuXVsxXSAtIHNsb3BlICogbGluZUNvb3JkaW5hdGVzW25dWzBdO1xuXG4gICAgICAgICAgZGlzdCA9XG4gICAgICAgICAgICBNYXRoLmFicyhzbG9wZSAqIHBvaW50Q29vcmRpbmF0ZVswXSArIGludmVyc2VTbG9wZSAtIHBvaW50Q29vcmRpbmF0ZVsxXSkgL1xuICAgICAgICAgICAgTWF0aC5zcXJ0KHNsb3BlICogc2xvcGUgKyAxKTtcbiAgICAgICAgfSBlbHNlIGRpc3QgPSBNYXRoLmFicyhwb2ludENvb3JkaW5hdGVbMF0gLSBsaW5lQ29vcmRpbmF0ZXNbbl1bMF0pO1xuXG4gICAgICAgIC8vIGxlbmd0aF4yIG9mIGxpbmUgc2VnbWVudFxuICAgICAgICBjb25zdCBybDIgPVxuICAgICAgICAgIE1hdGgucG93KGxpbmVDb29yZGluYXRlc1tuXVsxXSAtIGxpbmVDb29yZGluYXRlc1tuIC0gMV1bMV0sIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhsaW5lQ29vcmRpbmF0ZXNbbl1bMF0gLSBsaW5lQ29vcmRpbmF0ZXNbbiAtIDFdWzBdLCAyKTtcblxuICAgICAgICAvLyBkaXN0YW5jZV4yIG9mIHB0IHRvIGVuZCBsaW5lIHNlZ21lbnRcbiAgICAgICAgY29uc3QgbG4yID1cbiAgICAgICAgICBNYXRoLnBvdyhsaW5lQ29vcmRpbmF0ZXNbbl1bMV0gLSBwb2ludENvb3JkaW5hdGVbMV0sIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhsaW5lQ29vcmRpbmF0ZXNbbl1bMF0gLSBwb2ludENvb3JkaW5hdGVbMF0sIDIpO1xuXG4gICAgICAgIC8vIGRpc3RhbmNlXjIgb2YgcHQgdG8gYmVnaW4gbGluZSBzZWdtZW50XG4gICAgICAgIGNvbnN0IGxubTEyID1cbiAgICAgICAgICBNYXRoLnBvdyhsaW5lQ29vcmRpbmF0ZXNbbiAtIDFdWzFdIC0gcG9pbnRDb29yZGluYXRlWzFdLCAyKSArXG4gICAgICAgICAgTWF0aC5wb3cobGluZUNvb3JkaW5hdGVzW24gLSAxXVswXSAtIHBvaW50Q29vcmRpbmF0ZVswXSwgMik7XG5cbiAgICAgICAgLy8gbWluaW11bSBkaXN0YW5jZV4yIG9mIHB0IHRvIGluZmluaXRlIGxpbmVcbiAgICAgICAgY29uc3QgZGlzdDIgPSBNYXRoLnBvdyhkaXN0LCAyKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGVkIGxlbmd0aF4yIG9mIGxpbmUgc2VnbWVudFxuICAgICAgICBjb25zdCBjYWxjcmwyID0gbG4yIC0gZGlzdDIgKyBsbm0xMiAtIGRpc3QyO1xuXG4gICAgICAgIC8vIHJlZGVmaW5lIG1pbmltdW0gZGlzdGFuY2UgdG8gbGluZSBzZWdtZW50IChub3QgaW5maW5pdGUgbGluZSkgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChjYWxjcmwyID4gcmwyKSB7XG4gICAgICAgICAgZGlzdCA9IE1hdGguc3FydChNYXRoLm1pbihsbjIsIGxubTEyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluRGlzdCA9PT0gbnVsbCB8fCBtaW5EaXN0ID09PSB1bmRlZmluZWQgfHwgbWluRGlzdCA+IGRpc3QpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgaWYgKGNhbGNybDIgPiBybDIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgIGlmIChsbm0xMiA8IGxuMikge1xuICAgICAgICAgICAgICB0byA9IDA7IC8vIG5lYXJlciB0byBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgICBmcm9tID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyBuZWFyZXIgdG8gY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICB0byA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBlcnBlbmRpY3VsYXIgZnJvbSBwb2ludCBpbnRlcnNlY3RzIGxpbmUgc2VnbWVudFxuICAgICAgICAgICAgdG8gPSBNYXRoLnNxcnQobG5tMTIgLSBkaXN0MikgLyBNYXRoLnNxcnQocmwyKTtcbiAgICAgICAgICAgIGZyb20gPSBNYXRoLnNxcnQobG4yIC0gZGlzdDIpIC8gTWF0aC5zcXJ0KHJsMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgIHNlZ21lbnRJZHggPSBuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGR4ID0gbGluZUNvb3JkaW5hdGVzW3NlZ21lbnRJZHggLSAxXVswXSAtIGxpbmVDb29yZGluYXRlc1tzZWdtZW50SWR4XVswXTtcbiAgICAgIGNvbnN0IGR5ID0gbGluZUNvb3JkaW5hdGVzW3NlZ21lbnRJZHggLSAxXVsxXSAtIGxpbmVDb29yZGluYXRlc1tzZWdtZW50SWR4XVsxXTtcblxuICAgICAgeCA9IGxpbmVDb29yZGluYXRlc1tzZWdtZW50SWR4IC0gMV1bMF0gLSBkeCAqIHRvO1xuICAgICAgeSA9IGxpbmVDb29yZGluYXRlc1tzZWdtZW50SWR4IC0gMV1bMV0gLSBkeSAqIHRvO1xuICAgIH1cblxuICAgIC8vIGluZGV4IG5lZWRzIHRvIGJlIC0xIGJlY2F1c2Ugd2UgaGF2ZSB0byBhY2NvdW50IGZvciB0aGUgc2hpZnQgZnJvbSBpbml0aWFsIGJhY2tzY2FuXG4gICAgbGV0IHNuYXBQb2ludCA9IHsgeCwgeSwgaWR4OiBzZWdtZW50SWR4IC0gMSwgdG8sIGZyb20gfTtcblxuICAgIGlmIChtZXJjYXRvcikge1xuICAgICAgY29uc3QgcGl4ZWxUb0xhdExvbmcgPSBtZXJjYXRvci51bnByb2plY3QoW3NuYXBQb2ludC54LCBzbmFwUG9pbnQueV0pO1xuICAgICAgc25hcFBvaW50ID0ge1xuICAgICAgICB4OiBwaXhlbFRvTGF0TG9uZ1swXSxcbiAgICAgICAgeTogcGl4ZWxUb0xhdExvbmdbMV0sXG4gICAgICAgIGlkeDogc2VnbWVudElkeCAtIDEsXG4gICAgICAgIHRvLFxuICAgICAgICBmcm9tLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjbG9zZXN0UG9pbnQgPSBwb2ludChbc25hcFBvaW50LngsIHNuYXBQb2ludC55XSwge1xuICAgICAgZGlzdDogTWF0aC5hYnMoc25hcFBvaW50LmZyb20gLSBzbmFwUG9pbnQudG8pLFxuICAgICAgaW5kZXg6IHNuYXBQb2ludC5pZHgsXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBjbG9zZXN0UG9pbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWNrZWRFZGl0SGFuZGxlKFxuICBwaWNrczogUGlja1tdIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogRWRpdEhhbmRsZUZlYXR1cmUgfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFBpY2tlZEVkaXRIYW5kbGVzKHBpY2tzKTtcbiAgcmV0dXJuIGhhbmRsZXMubGVuZ3RoID8gaGFuZGxlc1swXSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWNrZWRTbmFwU291cmNlRWRpdEhhbmRsZShcbiAgcGlja3M6IFBpY2tbXSB8IG51bGwgfCB1bmRlZmluZWRcbik6IEVkaXRIYW5kbGVGZWF0dXJlIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGhhbmRsZXMgPSBnZXRQaWNrZWRFZGl0SGFuZGxlcyhwaWNrcyk7XG4gIHJldHVybiBoYW5kbGVzLmZpbmQoKGhhbmRsZSkgPT4gaGFuZGxlLnByb3BlcnRpZXMuZWRpdEhhbmRsZVR5cGUgPT09ICdzbmFwLXNvdXJjZScpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9uR3VpZGVQaWNrcyhwaWNrczogUGlja1tdKTogUGlja1tdIHtcbiAgcmV0dXJuIHBpY2tzICYmIHBpY2tzLmZpbHRlcigocGljaykgPT4gIXBpY2suaXNHdWlkZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWNrZWRFeGlzdGluZ0VkaXRIYW5kbGUoXG4gIHBpY2tzOiBQaWNrW10gfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBFZGl0SGFuZGxlRmVhdHVyZSB8IG51bGwgfCB1bmRlZmluZWQge1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UGlja2VkRWRpdEhhbmRsZXMocGlja3MpO1xuICByZXR1cm4gaGFuZGxlcy5maW5kKFxuICAgICh7IHByb3BlcnRpZXMgfSkgPT4gcHJvcGVydGllcy5mZWF0dXJlSW5kZXggPj0gMCAmJiBwcm9wZXJ0aWVzLmVkaXRIYW5kbGVUeXBlID09PSAnZXhpc3RpbmcnXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWNrZWRJbnRlcm1lZGlhdGVFZGl0SGFuZGxlKFxuICBwaWNrczogUGlja1tdIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogRWRpdEhhbmRsZUZlYXR1cmUgfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFBpY2tlZEVkaXRIYW5kbGVzKHBpY2tzKTtcbiAgcmV0dXJuIGhhbmRsZXMuZmluZChcbiAgICAoeyBwcm9wZXJ0aWVzIH0pID0+IHByb3BlcnRpZXMuZmVhdHVyZUluZGV4ID49IDAgJiYgcHJvcGVydGllcy5lZGl0SGFuZGxlVHlwZSA9PT0gJ2ludGVybWVkaWF0ZSdcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpY2tlZEVkaXRIYW5kbGVzKHBpY2tzOiBQaWNrW10gfCBudWxsIHwgdW5kZWZpbmVkKTogRWRpdEhhbmRsZUZlYXR1cmVbXSB7XG4gIGNvbnN0IGhhbmRsZXMgPVxuICAgIChwaWNrcyAmJlxuICAgICAgcGlja3NcbiAgICAgICAgLmZpbHRlcigocGljaykgPT4gcGljay5pc0d1aWRlICYmIHBpY2sub2JqZWN0LnByb3BlcnRpZXMuZ3VpZGVUeXBlID09PSAnZWRpdEhhbmRsZScpXG4gICAgICAgIC5tYXAoKHBpY2spID0+IHBpY2sub2JqZWN0KSkgfHxcbiAgICBbXTtcblxuICByZXR1cm4gaGFuZGxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnkoXG4gIGdlb21ldHJ5OiBHZW9tZXRyeSxcbiAgZmVhdHVyZUluZGV4OiBudW1iZXIsXG4gIGVkaXRIYW5kbGVUeXBlOiBFZGl0SGFuZGxlVHlwZSA9ICdleGlzdGluZydcbik6IEVkaXRIYW5kbGVGZWF0dXJlW10ge1xuICBsZXQgaGFuZGxlczogRWRpdEhhbmRsZUZlYXR1cmVbXSA9IFtdO1xuXG4gIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbm90IG5lc3RlZFxuICAgICAgaGFuZGxlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBndWlkZVR5cGU6ICdlZGl0SGFuZGxlJyxcbiAgICAgICAgICAgIGVkaXRIYW5kbGVUeXBlLFxuICAgICAgICAgICAgcG9zaXRpb25JbmRleGVzOiBbXSxcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAvLyBwb3NpdGlvbnMgYXJlIG5lc3RlZCAxIGxldmVsXG4gICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoXG4gICAgICAgIGdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIFtdLCBmZWF0dXJlSW5kZXgsIGVkaXRIYW5kbGVUeXBlKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAvLyBwb3NpdGlvbnMgYXJlIG5lc3RlZCAyIGxldmVsc1xuICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGErKykge1xuICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoXG4gICAgICAgICAgZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyhnZW9tZXRyeS5jb29yZGluYXRlc1thXSwgW2FdLCBmZWF0dXJlSW5kZXgsIGVkaXRIYW5kbGVUeXBlKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgcmVwZWF0IHRoZSBmaXJzdC9sYXN0IGhhbmRsZSBmb3IgUG9seWdvbnNcbiAgICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDMgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbYV0ubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoXG4gICAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKFxuICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlc1thXVtiXSxcbiAgICAgICAgICAgICAgW2EsIGJdLFxuICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGVkaXRIYW5kbGVUeXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhyb3cgRXJyb3IoYFVuaGFuZGxlZCBnZW9tZXRyeSB0eXBlOiAke2dlb21ldHJ5LnR5cGV9YCk7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlcztcbn1cblxuZnVuY3Rpb24gZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyhcbiAgY29vcmRpbmF0ZXM6IGFueVtdLFxuICBwb3NpdGlvbkluZGV4UHJlZml4OiBudW1iZXJbXSxcbiAgZmVhdHVyZUluZGV4OiBudW1iZXIsXG4gIGVkaXRIYW5kbGVUeXBlOiBFZGl0SGFuZGxlVHlwZSA9ICdleGlzdGluZydcbik6IEVkaXRIYW5kbGVGZWF0dXJlW10ge1xuICBjb25zdCBlZGl0SGFuZGxlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjb29yZGluYXRlc1tpXTtcbiAgICBlZGl0SGFuZGxlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZ3VpZGVUeXBlOiAnZWRpdEhhbmRsZScsXG4gICAgICAgIHBvc2l0aW9uSW5kZXhlczogWy4uLnBvc2l0aW9uSW5kZXhQcmVmaXgsIGldLFxuICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgIGVkaXRIYW5kbGVUeXBlLFxuICAgICAgfSxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBwb3NpdGlvbixcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVkaXRIYW5kbGVzO1xufVxuIl19