{"version":3,"file":"core.min.mjs","sources":["../src/compression/registry.ts","../src/mutableMapping.ts","../src/errors.ts","../src/core/slice.ts","../src/core/indexing.ts","../src/util.ts","../src/names.ts","../src/storage/index.ts","../src/metadata.ts","../src/attributes.ts","../src/nestedArray/types.ts","../src/nestedArray/ops.ts","../src/nestedArray/index.ts","../src/rawArray/ops.ts","../src/rawArray/index.ts","../node_modules/eventemitter3/index.js","../node_modules/p-finally/index.js","../node_modules/p-timeout/index.js","../node_modules/p-queue/dist/lower-bound.js","../node_modules/p-queue/dist/priority-queue.js","../node_modules/p-queue/dist/index.js","../src/core/index.ts","../src/storage/memoryStore.ts","../src/storage/httpStore.ts","../src/creation.ts","../src/hierarchy.ts","../src/storage/objectStore.ts"],"sourcesContent":["import type { Codec, CompressorConfig } from 'numcodecs';\n\n// TODO: This interface is tied to compressors in numcodecs..\n// might be better to just use 'any' or have numcodecs export complete \n// (optional) config? \ninterface Options {\n  level?: number;\n  cname?: string;\n  blocksize?: number;\n  clevel?: number;\n  shuffle?: number;\n}\n\ntype CodecConstructor = { fromConfig(config: Options & CompressorConfig): Codec };\ntype CodecImporter = () => CodecConstructor | Promise<CodecConstructor>;\n\nconst registry: Map<string, CodecImporter> = new Map();\n\nexport function addCodec(id: string, importFn: CodecImporter) {\n  registry.set(id, importFn);\n}\n\nexport async function getCodec<T extends Codec>(config: Options & CompressorConfig): Promise<T> {\n  if (!registry.has(config.id)) {\n    throw new Error(`Compression codec ${config.id} is not supported by Zarr.js yet.`);\n  }\n  const codec = await (registry.get(config.id) as CodecImporter)();\n  return codec.fromConfig(config) as T;\n}\n","/**\n * Closely resembles the functions on the MutableMapping type in Python.\n */\nexport interface MutableMapping<T, O=any> {\n    getItem(item: string, opts?: O): T;\n    setItem(item: string, value: T): boolean;\n    deleteItem(item: string): boolean;\n    containsItem(item: string): boolean;\n\n    proxy(): MutableMappingProxy<T>;\n\n    // length(): number;\n}\n\n/**\n * Closely resembles the functions on the MutableMapping type in Python.\n */\nexport interface AsyncMutableMapping<T, O=any> {\n    getItem(item: string, opts?: O): Promise<T>;\n    setItem(item: string, value: T): Promise<boolean>;\n    deleteItem(item: string): Promise<boolean>;\n    containsItem(item: string): Promise<boolean>;\n    // length(): number;\n}\n\nexport interface MutableMappingProxy<T> {\n    [key: string]: T;\n}\n\nexport interface AsyncMutableMappingProxy<T> {\n    [key: string]: T | Promise<T>;\n}\n\n\n/**\n * A proxy allows for accessing, setting and deleting the keys in the mutable mapping using\n * m[\"a\"] or even m.a notation.\n */\nexport function createProxy<S, T>(mapping: S & MutableMapping<T>): (S & MutableMappingProxy<T>);\nexport function createProxy<S, T>(mapping: S & AsyncMutableMapping<T>): (S & AsyncMutableMappingProxy<T>);\nexport function createProxy<S, T>(mapping: (S & MutableMapping<T>) | (S & AsyncMutableMapping<T>)): (S & MutableMappingProxy<T>) | (S & AsyncMutableMappingProxy<T>) {\n    return new Proxy(mapping as any, {\n        set(target, key, value, _receiver) {\n            return target.setItem(key as string, value);\n        },\n        get(target, key, _receiver) {\n            return target.getItem(key as string);\n        },\n        deleteProperty(target, key) {\n            return target.deleteItem(key as string);\n        },\n        has(target, key) {\n            return target.containsItem(key as string);\n        }\n    });\n}","export interface ZarrError {\n    __zarr__: string;\n}\n\nfunction isZarrError(err: unknown): err is ZarrError {\n    return typeof err === 'object' && err !== null && '__zarr__' in err;\n}\n\nexport function isKeyError(o: unknown) {\n    return isZarrError(o) && o.__zarr__ === 'KeyError';\n}\n\n// Custom error messages, note we have to patch the prototype of the\n// errors to fix `instanceof` calls, see:\n// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\nexport class ContainsArrayError extends Error implements ZarrError {\n    __zarr__ = 'ContainsArrayError';\n    constructor(path: string) {\n        super(`path ${path} contains an array`);\n        Object.setPrototypeOf(this, ContainsArrayError.prototype);\n    }\n}\n\nexport class ContainsGroupError extends Error implements ZarrError {\n    __zarr__ = 'ContainsGroupError';\n    constructor(path: string) {\n        super(`path ${path} contains a group`);\n        Object.setPrototypeOf(this, ContainsGroupError.prototype);\n    }\n}\n\nexport class ArrayNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'ArrayNotFoundError';\n    constructor(path: string) {\n        super(`array not found at path ${path}`);\n        Object.setPrototypeOf(this, ArrayNotFoundError.prototype);\n    }\n}\n\nexport class GroupNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'GroupNotFoundError';\n    constructor(path: string) {\n        super(`ground not found at path ${path}`);\n        Object.setPrototypeOf(this, GroupNotFoundError.prototype);\n    }\n}\n\nexport class PathNotFoundError extends Error implements ZarrError {\n    __zarr__ = 'PathNotFoundError';\n    constructor(path: string) {\n        super(`nothing not found at path ${path}`);\n        Object.setPrototypeOf(this, PathNotFoundError.prototype);\n    }\n}\n\nexport class PermissionError extends Error implements ZarrError {\n    __zarr__ = 'PermissionError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, PermissionError.prototype);\n    }\n}\n\nexport class KeyError extends Error implements ZarrError {\n    __zarr__ = 'KeyError';\n    constructor(key: string) {\n        super(`key ${key} not present`);\n        Object.setPrototypeOf(this, KeyError.prototype);\n    }\n}\n\nexport class TooManyIndicesError extends RangeError implements ZarrError {\n    __zarr__ = 'TooManyIndicesError';\n    constructor(selection: any[], shape: number[]) {\n        super(`too many indices for array; expected ${shape.length}, got ${selection.length}`);\n        Object.setPrototypeOf(this, TooManyIndicesError.prototype);\n    }\n}\n\nexport class BoundsCheckError extends RangeError implements ZarrError {\n    __zarr__ = 'BoundsCheckError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, BoundsCheckError.prototype);\n    }\n}\n\nexport class InvalidSliceError extends RangeError implements ZarrError {\n    __zarr__ = 'InvalidSliceError';\n    constructor(from: any, to: any, stepSize: any, reason: any) {\n        super(`slice arguments slice(${from}, ${to}, ${stepSize}) invalid: ${reason}`);\n        Object.setPrototypeOf(this, InvalidSliceError.prototype);\n    }\n}\n\nexport class NegativeStepError extends Error implements ZarrError {\n    __zarr__ = 'NegativeStepError';\n    constructor() {\n        super(`Negative step size is not supported when indexing.`);\n        Object.setPrototypeOf(this, NegativeStepError.prototype);\n    }\n}\n\nexport class ValueError extends Error implements ZarrError {\n    __zarr__ = 'ValueError';\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, ValueError.prototype);\n    }\n}\n\nexport class HTTPError extends Error implements ZarrError {\n    __zarr__ = 'HTTPError';\n    constructor(code: string) {\n        super(code);\n        Object.setPrototypeOf(this, HTTPError.prototype);\n    }\n}\n","\nimport { InvalidSliceError } from '../errors';\nimport { Slice, SliceArgument, SliceIndices } from \"./types\";\n\nexport function slice(start: SliceArgument, stop: SliceArgument | undefined = undefined, step: number | null = null): Slice {\n    // tslint:disable-next-line: strict-type-predicates\n    if (start === undefined) { // Not possible in typescript\n        throw new InvalidSliceError(start, stop, step, \"The first argument must not be undefined\");\n    }\n\n    if ((typeof start === \"string\" && start !== \":\") || (typeof stop === \"string\" && stop !== \":\")) { // Note in typescript this will never happen with type checking.\n        throw new InvalidSliceError(start, stop, step, \"Arguments can only be integers, \\\":\\\" or null\");\n    }\n\n    // slice(5) === slice(null, 5)\n    if (stop === undefined) {\n        stop = start;\n        start = null;\n    }\n\n    // if (start !== null && stop !== null && start > stop) {\n    //     throw new InvalidSliceError(start, stop, step, \"to is higher than from\");\n    // }\n\n    return {\n        start: start === \":\" ? null : start,\n        stop: stop === \":\" ? null : stop,\n        step,\n        _slice: true,\n    };\n}\n\n\n/**\n * Port of adjustIndices\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L243\n */\nfunction adjustIndices(start: number, stop: number, step: number, length: number) {\n    if (start < 0) {\n        start += length;\n        if (start < 0) {\n            start = (step < 0) ? -1 : 0;\n        }\n    } else if (start >= length) {\n        start = (step < 0) ? length - 1 : length;\n    }\n\n    if (stop < 0) {\n        stop += length;\n        if (stop < 0) {\n            stop = (step < 0) ? -1 : 0;\n        }\n    } else if (stop >= length) {\n        stop = (step < 0) ? length - 1 : length;\n    }\n\n    if (step < 0) {\n        if (stop < start) {\n            const length = Math.floor((start - stop - 1) / (-step) + 1);\n            return [start, stop, step, length];\n        }\n    } else {\n        if (start < stop) {\n            const length = Math.floor((stop - start - 1) / step + 1);\n            return [start, stop, step, length];\n        }\n    }\n    return [start, stop, step, 0];\n}\n\n/**\n * Port of slice.indices(n) and PySlice_Unpack\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L166\n *  https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L198 \n * \n * Behaviour might be slightly different as it's a weird hybrid implementation.\n */\nexport function sliceIndices(slice: Slice, length: number): SliceIndices {\n    let start: number;\n    let stop: number;\n    let step: number;\n\n    if (slice.step === null) {\n        step = 1;\n    } else {\n        step = slice.step;\n    }\n\n    if (slice.start === null) {\n        start = step < 0 ? Number.MAX_SAFE_INTEGER : 0;\n    } else {\n        start = slice.start;\n        if (start < 0) {\n            start += length;\n        }\n    }\n\n    if (slice.stop === null) {\n        stop = step < 0 ? -Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;\n    } else {\n        stop = slice.stop;\n        if (stop < 0) {\n            stop += length;\n        }\n    }\n\n    // This clips out of bounds slices\n    const s = adjustIndices(start, stop, step, length);\n    start = s[0];\n    stop = s[1];\n    step = s[2];\n    // The output length\n    length = s[3];\n\n\n    // With out of bounds slicing these two assertions are not useful.\n    // if (stop > length) throw new Error(\"Stop greater than length\");\n    // if (start >= length) throw new Error(\"Start greater than or equal to length\");\n\n    if (step === 0) throw new Error(\"Step size 0 is invalid\");\n\n    return [start, stop, step, length];\n}","import { TooManyIndicesError, BoundsCheckError, NegativeStepError } from '../errors';\nimport { ZarrArray } from './index';\nimport { Slice, ArraySelection, ChunkDimProjection, Indexer, DimIndexer, ChunkProjection, NormalizedArraySelection, SliceIndices, DimensionArraySelection } from './types';\nimport { sliceIndices, slice } from \"./slice\";\n\nfunction ensureArray(selection: ArraySelection): DimensionArraySelection[] {\n    if (!Array.isArray(selection)) {\n        return [selection];\n    }\n    return selection;\n}\n\nfunction checkSelectionLength(selection: DimensionArraySelection[], shape: number[]) {\n    if (selection.length > shape.length) {\n        throw new TooManyIndicesError(selection, shape);\n    }\n}\n\n/**\n * Returns both the sliceIndices per dimension and the output shape after slicing.\n */\nexport function selectionToSliceIndices(selection: NormalizedArraySelection, shape: number[]): [(number | SliceIndices)[], number[]] {\n    const sliceIndicesResult = [];\n    const outShape = [];\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (typeof s === \"number\") {\n            sliceIndicesResult.push(s);\n        } else {\n            const x = sliceIndices(s, shape[i]);\n            const dimLength = x[3];\n\n            outShape.push(dimLength);\n            sliceIndicesResult.push(x);\n        }\n    }\n\n    return [sliceIndicesResult, outShape];\n}\n\n/**\n * This translates \"...\", \":\", null into a list of slices or non-negative integer selections of length shape\n */\nexport function normalizeArraySelection(selection: ArraySelection | number, shape: number[], convertIntegerSelectionToSlices = false): NormalizedArraySelection {\n    selection = replaceEllipsis(selection, shape);\n\n    for (let i = 0; i < selection.length; i++) {\n        const dimSelection = selection[i];\n\n        if (typeof dimSelection === \"number\") {\n            if (convertIntegerSelectionToSlices) {\n                selection[i] = slice(dimSelection, dimSelection + 1, 1);\n            } else {\n                selection[i] = normalizeIntegerSelection(dimSelection, shape[i]);\n            }\n        } else if (isIntegerArray(dimSelection)) {\n            throw new TypeError(\"Integer array selections are not supported (yet)\");\n        } else if (dimSelection === \":\" || dimSelection === null) {\n            selection[i] = slice(null, null, 1);\n        }\n    }\n\n    return selection as NormalizedArraySelection;\n}\n\nexport function replaceEllipsis(selection: ArraySelection | number, shape: number[]) {\n    selection = ensureArray(selection);\n\n    let ellipsisIndex = -1;\n    let numEllipsis = 0;\n    for (let i = 0; i < selection.length; i++) {\n        if (selection[i] === \"...\") {\n            ellipsisIndex = i;\n            numEllipsis += 1;\n        }\n    }\n\n    if (numEllipsis > 1) {\n        throw new RangeError(\"an index can only have a single ellipsis ('...')\");\n    }\n    if (numEllipsis === 1) {\n        // count how many items to left and right of ellipsis\n        const numItemsLeft = ellipsisIndex;\n        const numItemsRight = selection.length - (numItemsLeft + 1);\n        const numItems = selection.length - 1; // All non-ellipsis items\n        if (numItems >= shape.length) {\n            // Ellipsis does nothing, just remove it\n            selection = selection.filter((x) => x !== \"...\");\n        } else {\n            // Replace ellipsis with as many slices are needed for number of dims\n            const numNewItems = shape.length - numItems;\n            let newItem = selection.slice(0, numItemsLeft).concat(new Array(numNewItems).fill(null));\n            if (numItemsRight > 0) {\n                newItem = newItem.concat(selection.slice(selection.length - numItemsRight));\n            }\n            selection = newItem;\n        }\n    }\n    // Fill out selection if not completely specified\n    if (selection.length < shape.length) {\n        const numMissing = shape.length - selection.length;\n        selection = selection.concat(new Array(numMissing).fill(null));\n    }\n\n    checkSelectionLength(selection, shape);\n    return selection;\n}\n\nexport function normalizeIntegerSelection(dimSelection: number, dimLength: number): number {\n    // Note: Maybe we should convert to integer or warn if dimSelection is not an integer\n\n    // handle wraparound\n    if (dimSelection < 0) {\n        dimSelection = dimLength + dimSelection;\n    }\n\n    // handle out of bounds\n    if (dimSelection >= dimLength || dimSelection < 0) {\n        throw new BoundsCheckError(`index out of bounds for dimension with length ${dimLength}`);\n    }\n\n    return dimSelection;\n}\n\nfunction isInteger(s: any) {\n    return typeof s === \"number\";\n}\n\nexport function isIntegerArray(s: any) {\n    if (!Array.isArray(s)) {\n        return false;\n    }\n    for (const e of s) {\n        if (typeof e !== \"number\") {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function isSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    if (s !== null && (s as any)[\"_slice\"] === true) {\n        return true;\n    }\n    return false;\n}\n\nfunction isContiguousSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    return isSlice(s) && ((s as Slice).step === null || (s as Slice).step === 1);\n}\n\nfunction isPositiveSlice(s: (Slice | number | number[] | \"...\" | \":\" | null)): boolean {\n    return isSlice(s) && ((s as Slice).step === null || ((s as Slice).step as number) >= 1);\n}\n\nexport function isContiguousSelection(selection: ArraySelection) {\n    selection = ensureArray(selection);\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (!(isIntegerArray(s) || isContiguousSlice(s) || s === \"...\")) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction isBasicSelection(selection: ArraySelection): boolean {\n    selection = ensureArray(selection);\n\n    for (let i = 0; i < selection.length; i++) {\n        const s = selection[i];\n        if (!(isInteger(s) || isPositiveSlice(s))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction* product<T>(...iterables: (() => IterableIterator<T>)[]): IterableIterator<T[]> {\n    if (iterables.length === 0) { return; }\n    // make a list of iterators from the iterables\n    const iterators = iterables.map(it => it());\n    const results = iterators.map(it => it.next());\n\n    // Disabled to allow empty inputs\n    // if (results.some(r => r.done)) {\n    //     throw new Error(\"Input contains an empty iterator.\");\n    // }\n\n    for (let i = 0; ;) {\n        if (results[i].done) {\n            // reset the current iterator\n            iterators[i] = iterables[i]();\n            results[i] = iterators[i].next();\n            // advance, and exit if we've reached the end\n            if (++i >= iterators.length) { return; }\n        } else {\n            yield results.map(({ value }) => value);\n            i = 0;\n        }\n        results[i] = iterators[i].next();\n    }\n}\n\nexport class BasicIndexer implements Indexer {\n    dimIndexers: DimIndexer[];\n    shape: number[];\n    dropAxes: null;\n\n    constructor(selection: ArraySelection, array: ZarrArray) {\n        selection = normalizeArraySelection(selection, array.shape);\n\n        // Setup per-dimension indexers\n        this.dimIndexers = [];\n        const arrayShape = array.shape;\n        for (let i = 0; i < arrayShape.length; i++) {\n            let dimSelection = selection[i];\n            const dimLength = arrayShape[i];\n            const dimChunkLength = array.chunks[i];\n\n            if (dimSelection === null) {\n                dimSelection = slice(null);\n            }\n\n\n            if (isInteger(dimSelection)) {\n                this.dimIndexers.push(new IntDimIndexer(dimSelection as number, dimLength, dimChunkLength));\n            } else if (isSlice(dimSelection)) {\n                this.dimIndexers.push(new SliceDimIndexer(dimSelection as Slice, dimLength, dimChunkLength));\n            } else {\n                throw new RangeError(`Unspported selection item for basic indexing; expected integer or slice, got ${dimSelection}`);\n            }\n        }\n\n        this.shape = [];\n        for (const d of this.dimIndexers) {\n            if (d instanceof SliceDimIndexer) {\n                this.shape.push(d.numItems);\n            }\n        }\n        this.dropAxes = null;\n    }\n\n    * iter() {\n        const dimIndexerIterables = this.dimIndexers.map(x => (() => x.iter()));\n        const dimIndexerProduct = product(...dimIndexerIterables);\n\n        for (const dimProjections of dimIndexerProduct) {\n            // TODO fix this, I think the product outputs too many combinations\n            const chunkCoords = [];\n            const chunkSelection = [];\n            const outSelection = [];\n\n            for (const p of dimProjections) {\n                chunkCoords.push((p).dimChunkIndex);\n                chunkSelection.push((p).dimChunkSelection);\n                if ((p).dimOutSelection !== null) {\n                    outSelection.push((p).dimOutSelection);\n                }\n            }\n\n            yield ({\n                chunkCoords,\n                chunkSelection,\n                outSelection,\n            } as ChunkProjection);\n        }\n\n    }\n}\n\nclass IntDimIndexer implements DimIndexer {\n    dimSelection: number;\n    dimLength: number;\n    dimChunkLength: number;\n    numItems: number;\n\n    constructor(dimSelection: number, dimLength: number, dimChunkLength: number) {\n        dimSelection = normalizeIntegerSelection(dimSelection, dimLength);\n        this.dimSelection = dimSelection;\n        this.dimLength = dimLength;\n        this.dimChunkLength = dimChunkLength;\n        this.numItems = 1;\n    }\n\n    * iter() {\n        const dimChunkIndex = Math.floor(this.dimSelection / this.dimChunkLength);\n        const dimOffset = dimChunkIndex * this.dimChunkLength;\n        const dimChunkSelection = this.dimSelection - dimOffset;\n        const dimOutSelection = null;\n        yield {\n            dimChunkIndex,\n            dimChunkSelection,\n            dimOutSelection,\n        } as ChunkDimProjection;\n    }\n}\n\nclass SliceDimIndexer implements DimIndexer {\n    dimLength: number;\n    dimChunkLength: number;\n    numItems: number;\n    numChunks: number;\n\n    start: number;\n    stop: number;\n    step: number;\n\n    constructor(dimSelection: Slice, dimLength: number, dimChunkLength: number) {\n        // Normalize\n        const [start, stop, step] = sliceIndices(dimSelection, dimLength);\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n        if (this.step < 1) {\n            throw new NegativeStepError();\n        }\n\n        this.dimLength = dimLength;\n        this.dimChunkLength = dimChunkLength;\n        this.numItems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n        this.numChunks = Math.ceil(this.dimLength / this.dimChunkLength);\n    }\n\n    *iter() {\n        const dimChunkIndexFrom = Math.floor(this.start / this.dimChunkLength);\n        const dimChunkIndexTo = Math.ceil(this.stop / this.dimChunkLength);\n\n        // Iterate over chunks in range\n        for (let dimChunkIndex = dimChunkIndexFrom; dimChunkIndex < dimChunkIndexTo; dimChunkIndex++) {\n\n            // Compute offsets for chunk within overall array\n            const dimOffset = dimChunkIndex * this.dimChunkLength;\n            const dimLimit = Math.min(this.dimLength, (dimChunkIndex + 1) * this.dimChunkLength);\n\n            // Determine chunk length, accounting for trailing chunk\n            const dimChunkLength = dimLimit - dimOffset;\n\n            let dimChunkSelStart: number;\n            let dimChunkSelStop: number;\n            let dimOutOffset: number;\n\n            if (this.start < dimOffset) {\n                // Selection starts before current chunk\n\n                dimChunkSelStart = 0;\n                const remainder = (dimOffset - this.start) % this.step;\n                if (remainder > 0) {\n                    dimChunkSelStart += this.step - remainder;\n                }\n                // Compute number of previous items, provides offset into output array\n                dimOutOffset = Math.ceil((dimOffset - this.start) / this.step);\n            } else {\n                // Selection starts within current chunk\n                dimChunkSelStart = this.start - dimOffset;\n                dimOutOffset = 0;\n            }\n\n            if (this.stop > dimLimit) {\n                // Selection ends after current chunk\n                dimChunkSelStop = dimChunkLength;\n            } else {\n                // Selection ends within current chunk\n                dimChunkSelStop = this.stop - dimOffset;\n            }\n\n            const dimChunkSelection = slice(dimChunkSelStart, dimChunkSelStop, this.step);\n            const dimChunkNumItems = Math.ceil((dimChunkSelStop - dimChunkSelStart) / this.step);\n            const dimOutSelection = slice(dimOutOffset, dimOutOffset + dimChunkNumItems);\n            yield {\n                dimChunkIndex,\n                dimChunkSelection,\n                dimOutSelection,\n            } as ChunkDimProjection;\n        }\n\n    }\n\n}\n","import { Order, FillType, ChunksArgument, DtypeString } from \"./types\";\n\nimport { DimensionSelection, Slice } from \"./core/types\";\nimport { isSlice } from \"./core/indexing\";\nimport { TypedArray } from \"./nestedArray/types\";\n\n/**\n * This should be true only if this javascript is getting executed in Node.\n */\nexport const IS_NODE = typeof process !== \"undefined\" && process.versions && process.versions.node;\n\nexport function humanReadableSize(size: number) {\n    if (size < 2 ** 10) {\n        return `${size}`;\n    }\n    else if (size < 2 ** 20) {\n        return `${(size / (2 ** 10)).toFixed(1)}K`;\n    }\n    else if (size < 2 ** 30) {\n        return `${(size / (2 ** 20)).toFixed(1)}M`;\n    }\n    else if (size < 2 ** 40) {\n        return `${(size / (2 ** 30)).toFixed(1)}G`;\n    }\n    else if (size < 2 ** 50) {\n        return `${(size / (2 ** 40)).toFixed(1)}T`;\n    }\n    return `${(size / (2 ** 50)).toFixed(1)}P`;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function normalizeStoragePath(path: string | String | null): string {\n    if (path === null) {\n        return \"\";\n    }\n\n    if (path instanceof String) {\n        path = path.valueOf();\n    }\n\n    // convert backslash to forward slash\n    path = path.replace(/\\\\/g, \"/\");\n    // ensure no leading slash\n    while (path.length > 0 && path[0] === '/') {\n        path = path.slice(1);\n    }\n\n    // ensure no trailing slash\n    while (path.length > 0 && path[path.length - 1] === '/') {\n        path = path.slice(0, path.length - 1);\n    }\n\n\n    // collapse any repeated slashes\n    path = path.replace(/\\/\\/+/g, \"/\");\n\n    // don't allow path segments with just '.' or '..'\n    const segments = path.split('/');\n\n    for (const s of segments) {\n        if (s === \".\" || s === \"..\") {\n            throw Error(\"path containing '.' or '..' segment not allowed\");\n        }\n    }\n    return path as string;\n}\n\nexport function normalizeShape(shape: number | number[]): number[] {\n    if (typeof shape === \"number\") {\n        shape = [shape];\n    }\n    return shape.map(x => Math.floor(x));\n}\n\nexport function normalizeChunks(chunks: ChunksArgument, shape: number[]): number[] {\n    // Assume shape is already normalized\n\n    if (chunks === null || chunks === true) {\n        throw new Error(\"Chunk guessing is not supported yet\");\n    }\n\n    if (chunks === false) {\n        return shape;\n    }\n\n    if (typeof chunks === \"number\") {\n        chunks = [chunks];\n    }\n\n    // handle underspecified chunks\n    if (chunks.length < shape.length) {\n        // assume chunks across remaining dimensions\n        chunks = chunks.concat(shape.slice(chunks.length));\n    }\n\n    return chunks.map((x, idx) => {\n        // handle null or -1 in chunks\n        if (x === -1 || x === null) {\n            return shape[idx];\n        } else {\n            return Math.floor(x);\n        }\n    });\n}\n\nexport function normalizeOrder(order: string): Order {\n    order = order.toUpperCase();\n    return order as Order;\n}\n\nexport function normalizeDtype(dtype: DtypeString): DtypeString {\n    return dtype;\n}\n\nexport function normalizeFillValue(fillValue: FillType): FillType {\n    return fillValue;\n}\n\n/**\n * Determine whether `item` specifies a complete slice of array with the\n *  given `shape`. Used to optimize __setitem__ operations on chunks\n * @param item\n * @param shape\n */\nexport function isTotalSlice(item: DimensionSelection | DimensionSelection[], shape: number[]): boolean {\n    if (item === null) {\n        return true;\n    }\n    if (!Array.isArray(item)) {\n        item = [item];\n    }\n\n    for (let i = 0; i < Math.min(item.length, shape.length); i++) {\n        const it = item[i];\n        if (it === null) continue;\n\n        if (isSlice(it)) {\n            const s = it as Slice;\n            const isStepOne = s.step === 1 || s.step === null;\n\n            if (s.start === null && s.stop === null && isStepOne) {\n                continue;\n            }\n            if (((s.stop as number) - (s.start as number)) === shape[i] && isStepOne) {\n                continue;\n            }\n            return false;\n        }\n        return false;\n\n\n        // } else {\n        //     console.error(`isTotalSlice unexpected non-slice, got ${it}`);\n        //     return false;\n        // }\n    }\n    return true;\n}\n\n/**\n * Checks for === equality of all elements.\n */\nexport function arrayEquals1D(a: ArrayLike<any>, b: ArrayLike<any>) {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/*\n * Determines \"C\" order strides for a given shape array.\n * Strides provide integer steps in each dimention to traverse an ndarray.\n *\n * NOTE: - These strides here are distinct from numpy.ndarray.strides, which describe actual byte steps.\n *       - Strides are assumed to be contiguous, so initial step is 1. Thus, output will always be [XX, XX, 1].\n */\nexport function getStrides(shape: number[]): number[] {\n    // adapted from https://github.com/scijs/ndarray/blob/master/ndarray.js#L326-L330\n    const ndim = shape.length;\n    const strides = Array(ndim);\n    let step = 1; // init step\n    for (let i = ndim - 1; i >= 0; i--) {\n        strides[i] = step;\n        step *= shape[i];\n    }\n    return strides;\n}\n\n/**\n * Preserves (double) slashes earlier in the path, so this works better\n * for URLs. From https://stackoverflow.com/a/46427607/4178400\n * @param args parts of a path or URL to join.\n */\nexport function joinUrlParts(...args: string[]) {\n    return args.map((part, i) => {\n        if (i === 0) {\n          return part.trim().replace(/[\\/]*$/g, '');\n        } else {\n          return part.trim().replace(/(^[\\/]*|[\\/]*$)/g, '');\n        }\n      }).filter(x=>x.length).join('/');\n}\n\n\n/**\n * Swaps byte order in-place for a given TypedArray.\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\n * @param src TypedArray\n */\nexport function byteSwapInplace(src: TypedArray): void {\n  const b = src.BYTES_PER_ELEMENT;\n  if (b === 1) return; // no swapping needed\n  if (IS_NODE) {\n    // Use builtin methods for swapping if in Node environment\n    const bytes = Buffer.from(src.buffer, src.byteOffset, src.length * b);\n    if (b === 2) bytes.swap16();\n    if (b === 4) bytes.swap32();\n    if (b === 8) bytes.swap64();\n    return;\n  }\n  // In browser, need to flip manually\n  // Adapted from https://github.com/zbjornson/node-bswap/blob/master/bswap.js\n  const flipper = new Uint8Array(src.buffer, src.byteOffset, src.length * b);\n  const numFlips = b / 2;\n  const endByteIndex = b - 1;\n  let t: number;\n  for (let i = 0; i < flipper.length; i += b) {\n    for (let j = 0; j < numFlips; j++) {\n      t = flipper[i + j];\n      flipper[i + j] = flipper[i + endByteIndex - j];\n      flipper[i + endByteIndex - j] = t;\n    }\n  }\n}\n\n/**\n * Creates a copy of a TypedArray and swaps bytes.\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\n * @param src TypedArray\n */\nexport function byteSwap(src: TypedArray): TypedArray {\n    const copy = src.slice();\n    byteSwapInplace(copy);\n    return copy;\n}\n","export const ARRAY_META_KEY = \".zarray\";\nexport const GROUP_META_KEY = \".zgroup\";\nexport const ATTRS_META_KEY = \".zattrs\";\n","import { normalizeStoragePath, normalizeChunks, normalizeDtype, normalizeShape, normalizeOrder, normalizeFillValue } from '../util';\nimport { Store } from './types';\nimport { ARRAY_META_KEY, GROUP_META_KEY } from '../names';\nimport { FillType, Order, Filter, CompressorConfig, ZarrGroupMetadata, ChunksArgument, DtypeString, ZarrArrayMetadata, FillTypeSerialized } from '../types';\nimport { ContainsArrayError, ContainsGroupError } from '../errors';\n\n\n/**\n * Return true if the store contains an array at the given logical path.\n */\nexport async function containsArray(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    const prefix = pathToPrefix(path);\n    const key = prefix + ARRAY_META_KEY;\n    return store.containsItem(key);\n}\n\n/**\n * Return true if the store contains a group at the given logical path.\n */\nexport async function containsGroup<T>(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    const prefix = pathToPrefix(path);\n    const key = prefix + GROUP_META_KEY;\n    return store.containsItem(key);\n}\n\n\nexport function pathToPrefix(path: string): string {\n    // assume path already normalized\n    if (path.length > 0) {\n        return path + '/';\n    }\n    return '';\n}\n\nasync function listDirFromKeys(store: Store, path: string) {\n    // assume path already normalized\n    const prefix = pathToPrefix(path);\n    const children = new Set<string>();\n\n    for (const key in await store.keys()) {\n        if (key.startsWith(prefix) && key.length > prefix.length) {\n            const suffix = key.slice(prefix.length);\n            const child = suffix.split('/')[0];\n            children.add(child);\n        }\n    }\n    return Array.from(children).sort();\n}\n\nasync function requireParentGroup(store: Store, path: string, chunkStore: Store | null, overwrite: boolean) {\n    // Assume path is normalized\n    if (path.length === 0) {\n        return;\n    }\n\n    const segments = path.split(\"/\");\n    let p = \"\";\n    for (const s of segments.slice(0, segments.length - 1)) {\n        p += s;\n        if (await containsArray(store, p)) {\n            await initGroupMetadata(store, p, overwrite);\n        } else if (!await containsGroup(store, p)) {\n            await initGroupMetadata(store, p);\n        }\n        p += \"/\";\n    }\n}\n\n/**\n * Obtain a directory listing for the given path. If `store` provides a `listDir`\n *  method, this will be called, otherwise will fall back to implementation via the\n *  `MutableMapping` interface.\n * @param store \n */\nexport async function listDir(store: Store, path: string | null = null) {\n    path = normalizeStoragePath(path);\n    if (store.listDir) {\n        return store.listDir(path);\n    } else {\n        return listDirFromKeys(store, path);\n    }\n}\n\nasync function initGroupMetadata(store: Store, path: string | null = null,overwrite = false) {\n    path = normalizeStoragePath(path);\n\n    // Guard conditions\n    if (overwrite) {\n        throw Error(\"Group overwriting not implemented yet :(\");\n    } else if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n    }\n\n    const metadata: ZarrGroupMetadata = { zarr_format: 2 };\n    const key = pathToPrefix(path) + GROUP_META_KEY;\n    await store.setItem(key, JSON.stringify(metadata));\n}\n/**\n *  Initialize a group store. Note that this is a low-level function and there should be no\n *  need to call this directly from user code.\n */\nexport async function initGroup(store: Store, path: string | null = null, chunkStore: null | Store = null, overwrite = false) {\n    path = normalizeStoragePath(path);\n    await requireParentGroup(store, path, chunkStore, overwrite);\n    await initGroupMetadata(store, path, overwrite);\n}\n\nasync function initArrayMetadata(\n    store: Store,\n    shape: number | number[],\n    chunks: ChunksArgument,\n    dtype: DtypeString,\n    path: string,\n    compressor: null | CompressorConfig,\n    fillValue: FillType,\n    order: Order,\n    overwrite: boolean,\n    chunkStore: null | Store,\n    filters: null | Filter[]\n) {\n    // Guard conditions\n    if (overwrite) {\n        throw Error(\"Array overwriting not implemented yet :(\");\n    } else if (await containsArray(store, path)) {\n        throw new ContainsArrayError(path);\n    } else if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path);\n    }\n\n    // Normalize metadata,  does type checking too.\n    dtype = normalizeDtype(dtype);\n    shape = normalizeShape(shape);\n    chunks = normalizeChunks(chunks, shape);\n    order = normalizeOrder(order);\n    fillValue = normalizeFillValue(fillValue);\n\n    if (filters !== null && filters.length > 0) {\n        throw Error(\"Filters are not supported yet\");\n    }\n\n    let serializedFillValue: FillTypeSerialized = fillValue;\n\n    if (typeof fillValue === \"number\") {\n        if (Number.isNaN(fillValue)) serializedFillValue = \"NaN\";\n        if (Number.POSITIVE_INFINITY === fillValue) serializedFillValue = \"Infinity\";\n        if (Number.NEGATIVE_INFINITY === fillValue) serializedFillValue = \"-Infinity\";\n    }\n\n    filters = null;\n\n    const metadata: ZarrArrayMetadata = {\n        zarr_format: 2,\n\n        shape: shape,\n        chunks: chunks as number[],\n\n        dtype: dtype,\n        fill_value: serializedFillValue,\n        order: order,\n        compressor: compressor,\n        filters: filters,\n    };\n    const metaKey = pathToPrefix(path) + ARRAY_META_KEY;\n    await store.setItem(metaKey, JSON.stringify(metadata));\n}\n\n/**\n * \n * Initialize an array store with the given configuration. Note that this is a low-level\n * function and there should be no need to call this directly from user code\n */\nexport async function initArray(\n    store: Store,\n    shape: number | number[],\n    chunks: ChunksArgument,\n    dtype: DtypeString,\n    path: string | null = null,\n    compressor: null | CompressorConfig = null,\n    fillValue: FillType = null,\n    order: Order = \"C\",\n    overwrite = false,\n    chunkStore: null | Store = null,\n    filters: null | Filter[] = null\n) {\n\n    path = normalizeStoragePath(path);\n    await requireParentGroup(store, path, chunkStore, overwrite);\n    await initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n}\n","import { ZarrMetadataType, UserAttributes } from './types';\nimport { ValidStoreType } from './storage/types';\nimport { IS_NODE } from './util';\n\nexport function parseMetadata(\n    s: ValidStoreType | ZarrMetadataType\n): ZarrMetadataType | UserAttributes {\n    // Here we allow that a store may return an already-parsed metadata object,\n    // or a string of JSON that we will parse here. We allow for an already-parsed\n    // object to accommodate a consolidated metadata store, where all the metadata for\n    // all groups and arrays will already have been parsed from JSON.\n    if (typeof s !== 'string') {\n        // tslint:disable-next-line: strict-type-predicates\n        if (IS_NODE && Buffer.isBuffer(s)) {\n            return JSON.parse(s.toString());\n        } else if (s instanceof ArrayBuffer) {\n            const utf8Decoder = new TextDecoder();\n            const bytes = new Uint8Array(s);\n            return JSON.parse(utf8Decoder.decode(bytes));\n        } else {\n            return s;\n        }\n    }\n    return JSON.parse(s);\n}\n","import { createProxy, AsyncMutableMapping, AsyncMutableMappingProxy } from './mutableMapping';\nimport { Store } from './storage/types';\nimport { parseMetadata } from './metadata';\nimport { UserAttributes } from './types';\nimport { PermissionError } from './errors';\n\n/**\n * Class providing access to user attributes on an array or group. Should not be\n * instantiated directly, will be available via the `.attrs` property of an array or\n * group.\n */\nexport class Attributes<M extends UserAttributes> implements AsyncMutableMapping<any> {\n    store: Store;\n    key: string;\n    readOnly: boolean;\n    cache: boolean;\n    private cachedValue: M | null;\n\n    constructor(store: Store, key: string, readOnly: boolean, cache = true) {\n        this.store = store;\n        this.key = key;\n        this.readOnly = readOnly;\n        this.cache = cache;\n        this.cachedValue = null;\n    }\n\n    /**\n     * Retrieve all attributes as a JSON object.\n     */\n    public async asObject() {\n        if (this.cache && this.cachedValue !== null) {\n            return this.cachedValue;\n        }\n        const o = await this.getNoSync();\n        if (this.cache) {\n            this.cachedValue = o;\n        }\n        return o;\n    }\n\n    private async getNoSync(): Promise<M> {\n        try {\n            const data = await this.store.getItem(this.key);\n            // TODO fix typing?\n            return parseMetadata(data) as M;\n        } catch (error) {\n            return {} as M;\n        }\n    }\n\n    private async setNoSync(key: string, value: any) {\n        const d = await this.getNoSync();\n        (d as any)[key] = value;\n        await this.putNoSync(d);\n        return true;\n    }\n\n    private async putNoSync(m: M) {\n        await this.store.setItem(this.key, JSON.stringify(m));\n        if (this.cache) {\n            this.cachedValue = m;\n        }\n    }\n\n    private async delNoSync(key: string): Promise<boolean> {\n        const d = await this.getNoSync();\n        delete (d as any)[key];\n        await this.putNoSync(d);\n        return true;\n    }\n\n    /**\n     * Overwrite all attributes with the provided object in a single operation\n     */\n    async put(d: M) {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.putNoSync(d);\n    }\n\n    async setItem(key: string, value: any): Promise<boolean> {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.setNoSync(key, value);\n    }\n\n    async getItem(key: string) {\n        return ((await this.asObject()) as any)[key];\n    }\n\n    async deleteItem(key: string) {\n        if (this.readOnly) {\n            throw new PermissionError(\"attributes are read-only\");\n        }\n        return this.delNoSync(key);\n    }\n\n    async containsItem(key: string) {\n        return ((await this.asObject()) as any)[key] !== undefined;\n    }\n\n    proxy(): AsyncMutableMappingProxy<any> {\n        return createProxy(this);\n    }\n}","import { DtypeString } from '../types';\nimport { ValueError } from '../errors';\n\nexport type NestedArrayData = TypedArray | NDNestedArrayData;\nexport type NDNestedArrayData =\n  | TypedArray[]\n  | TypedArray[][]\n  | TypedArray[][][]\n  | TypedArray[][][][]\n  | TypedArray[][][][][]\n  | TypedArray[][][][][][];\n\nexport type TypedArray =\n  | Uint8Array\n  | Int8Array\n  | Uint16Array\n  | Int16Array\n  | Uint32Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\n// ArrayLike<any> & {\n//     BYTES_PER_ELEMENT: number;\n//     set(array: ArrayLike<number>, offset?: number): void;\n//     slice(start?: number, end?: number): TypedArray;\n//     subarray(start?: number, end?: number): TypedArray;\n//     buffer: Buffer | ArrayBuffer;\n//     constructor: TypedArrayConstructor<TypedArray>;\n// };\nexport type TypedArrayConstructor<TypedArray> = {\n  new(): TypedArray;\n  // tslint:disable-next-line: unified-signatures\n  new(size: number): TypedArray;\n  // tslint:disable-next-line: unified-signatures\n  new(buffer: ArrayBuffer): TypedArray;\n  BYTES_PER_ELEMENT: number;\n};\n\nexport const DTYPE_TYPEDARRAY_MAPPING: { [A in DtypeString]: TypedArrayConstructor<TypedArray> } = {\n  '|b': Int8Array,\n  '|B': Uint8Array,\n  '|u1': Uint8Array,\n  '|i1': Int8Array,\n  '<b': Int8Array,\n  '<B': Uint8Array,\n  '<u1': Uint8Array,\n  '<i1': Int8Array,\n  '<u2': Uint16Array,\n  '<i2': Int16Array,\n  '<u4': Uint32Array,\n  '<i4': Int32Array,\n  '<f4': Float32Array,\n  '<f8': Float64Array,\n  '>b': Int8Array,\n  '>B': Uint8Array,\n  '>u1': Uint8Array,\n  '>i1': Int8Array,\n  '>u2': Uint16Array,\n  '>i2': Int16Array,\n  '>u4': Uint32Array,\n  '>i4': Int32Array,\n  '>f4': Float32Array,\n  '>f8': Float64Array\n};\n\n/*\n * Called by NestedArray and RawArray constructors only.\n * We byte-swap the buffer of a store after decoding\n * since TypedArray views are little endian only.\n *\n * This means NestedArrays and RawArrays will always be little endian,\n * unless a numpy-like library comes around and can handle endianess\n * for buffer views.\n */\nexport function getTypedArrayDtypeString(t: TypedArray): DtypeString {\n  // Favour the types below instead of small and big B\n  if (t instanceof Uint8Array) return '|u1';\n  if (t instanceof Int8Array) return '|i1';\n  if (t instanceof Uint16Array) return '<u2';\n  if (t instanceof Int16Array) return '<i2';\n  if (t instanceof Uint32Array) return '<u4';\n  if (t instanceof Int32Array) return '<i4';\n  if (t instanceof Float32Array) return '<f4';\n  if (t instanceof Float64Array) return '<f8';\n  throw new ValueError('Mapping for TypedArray to Dtypestring not known');\n}\n","import { ArraySelection, SliceIndices } from '../core/types';\nimport { ValueError } from '../errors';\nimport { TypedArray, TypedArrayConstructor, NestedArrayData, NDNestedArrayData } from './types';\nimport { normalizeArraySelection, selectionToSliceIndices } from '../core/indexing';\n\n/**\n * Digs down into the dimensions of given array to find the TypedArray and returns its constructor.\n * Better to use sparingly.\n */\nexport function getNestedArrayConstructor<T extends TypedArray>(arr: any): TypedArrayConstructor<T> {\n    // TODO fix typing\n    // tslint:disable-next-line: strict-type-predicates\n    if ((arr as TypedArray).byteLength !== undefined) {\n        return (arr).constructor;\n    }\n    return getNestedArrayConstructor(arr[0]);\n}\n\n/**\n * Returns both the slice result and new output shape\n * @param arr NestedArray to slice\n * @param shape The shape of the NestedArray\n * @param selection\n */\nexport function sliceNestedArray<T extends TypedArray>(arr: NestedArrayData, shape: number[], selection: number | ArraySelection): [NestedArrayData | number, number[]] {\n    // This translates \"...\", \":\", null into a list of slices or integer selections\n    const normalizedSelection = normalizeArraySelection(selection, shape);\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, shape);\n    const outArray = _sliceNestedArray(arr, shape, sliceIndices);\n    return [outArray, outShape];\n}\n\nfunction _sliceNestedArray<T extends TypedArray>(arr: NestedArrayData, shape: number[], selection: (SliceIndices | number)[]): NestedArrayData | number {\n    const currentSlice = selection[0];\n\n    // Is this necessary?\n    // // This is possible when a slice list is passed shorter than the amount of dimensions\n    // // tslint:disable-next-line: strict-type-predicates\n    // if (currentSlice === undefined) {\n    //     return arr.slice();\n    // }\n\n    // When a number is passed that dimension is squeezed\n    if (typeof currentSlice === \"number\") {\n        // Assume already normalized integer selection here.\n        if (shape.length === 1) {\n            return arr[currentSlice];\n        } else {\n            return _sliceNestedArray(arr[currentSlice] as NestedArrayData, shape.slice(1), selection.slice(1));\n        }\n    }\n    const [from, to, step, outputSize] = currentSlice;\n\n    if (outputSize === 0) {\n        return new (getNestedArrayConstructor(arr))(0);\n    }\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            return (arr as TypedArray).slice(from, to);\n        }\n\n        const newArrData = new (arr.constructor as TypedArrayConstructor<T>)(outputSize);\n        for (let i = 0; i < outputSize; i++) {\n            newArrData[i] = (arr as TypedArray)[from + i * step];\n        }\n        return newArrData;\n    }\n\n    let newArr = new Array(outputSize);\n\n    for (let i = 0; i < outputSize; i++) {\n        newArr[i] = _sliceNestedArray(arr[from + i * step] as NestedArrayData, shape.slice(1), selection.slice(1));\n    }\n\n    // This is necessary to ensure that the return value is a NestedArray if the last dimension is squeezed\n    // e.g. shape [2,1] with slice [:, 0] would otherwise result in a list of numbers instead of a valid NestedArray\n    if (outputSize > 0 && typeof newArr[0] === \"number\") {\n        const typedArrayConstructor = (arr[0] as TypedArray).constructor;\n        newArr = (typedArrayConstructor as any).from(newArr);\n    }\n\n    return newArr;\n}\n\n\n\n\nexport function setNestedArrayToScalar<T extends TypedArray>(dstArr: NestedArrayData, value: number, destShape: number[], selection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(selection, destShape, true);\n\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n    const [sliceIndices, _outShape] = selectionToSliceIndices(normalizedSelection, destShape) as [SliceIndices[], number[]];\n    _setNestedArrayToScalar(dstArr, value, destShape, sliceIndices);\n}\n\nexport function setNestedArray<T extends TypedArray>(dstArr: NestedArrayData, sourceArr: NestedArrayData, destShape: number[], sourceShape: number[], selection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(selection, destShape, false);\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, destShape);\n\n    // TODO: replace with non stringify equality check\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n        throw new ValueError(`Shape mismatch in target and source NestedArray: ${outShape} and ${sourceShape}`);\n    }\n\n    _setNestedArray(dstArr, sourceArr, destShape, sliceIndices);\n}\n\n\nfunction _setNestedArray<T extends TypedArray>(dstArr: NestedArrayData, sourceArr: NestedArrayData | number, shape: number[], selection: (SliceIndices | number)[]) {\n\n    const currentSlice = selection[0];\n\n    if (typeof sourceArr === \"number\") {\n        _setNestedArrayToScalar(dstArr, sourceArr, shape, selection.map(x => typeof x === \"number\" ? [x, x + 1, 1, 1] : x));\n        return;\n    }\n\n    // This dimension is squeezed.\n    if (typeof currentSlice === \"number\") {\n        _setNestedArray((dstArr as NDNestedArrayData)[currentSlice], sourceArr, shape.slice(1), selection.slice(1));\n        return;\n    }\n\n    const [from, _to, step, outputSize] = currentSlice;\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            (dstArr as TypedArray).set(sourceArr as TypedArray, from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[from + i * step] = (sourceArr)[i];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setNestedArray((dstArr as NDNestedArrayData)[from + i * step], (sourceArr as NDNestedArrayData)[i], shape.slice(1), selection.slice(1));\n    }\n}\n\nfunction _setNestedArrayToScalar<T extends TypedArray>(dstArr: NestedArrayData, value: number, shape: number[], selection: SliceIndices[]) {\n    const currentSlice = selection[0];\n\n    const [from, to, step, outputSize] = currentSlice;\n\n    if (shape.length === 1) {\n        if (step === 1) {\n            (dstArr as TypedArray).fill(value, from, to);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[from + i * step] = value;\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setNestedArrayToScalar((dstArr as NDNestedArrayData)[from + i * step], value, shape.slice(1), selection.slice(1));\n    }\n}\n\nexport function flattenNestedArray(arr: NestedArrayData, shape: number[], constr?: TypedArrayConstructor<TypedArray>): TypedArray {\n    if (constr === undefined) {\n        constr = getNestedArrayConstructor(arr);\n    }\n    const size = shape.reduce((x, y) => x * y, 1);\n    const outArr = new constr(size);\n\n    _flattenNestedArray(arr, shape, outArr, 0);\n\n    return outArr;\n}\n\nfunction _flattenNestedArray(arr: NestedArrayData, shape: number[], outArr: TypedArray, offset: number) {\n    if (shape.length === 1) {\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\n        // We just slice set the array directly from one level above to save some function calls.\n        outArr.set((arr as TypedArray), offset);\n        return;\n    }\n\n    if (shape.length === 2) {\n        for (let i = 0; i < shape[0]; i++) {\n            outArr.set((arr as TypedArray[])[i], offset + shape[1] * i);\n        }\n        return arr;\n    }\n\n    const nextShape = shape.slice(1);\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n    const mult = nextShape.reduce((x, y) => x * y, 1);\n\n    for (let i = 0; i < shape[0]; i++) {\n        _flattenNestedArray((arr as NDNestedArrayData)[i], nextShape, outArr, offset + mult * i);\n    }\n    return arr;\n}\n","import { DtypeString } from '../types';\nimport { NestedArrayData, TypedArray, TypedArrayConstructor, DTYPE_TYPEDARRAY_MAPPING, getTypedArrayDtypeString } from './types';\nimport { ArraySelection, Slice } from '../core/types';\nimport { slice } from '../core/slice';\nimport { ValueError } from '../errors';\nimport { normalizeShape, IS_NODE } from '../util';\nimport { setNestedArray, setNestedArrayToScalar, flattenNestedArray, sliceNestedArray } from './ops';\n\nexport class NestedArray<T extends TypedArray> {\n    dtype: DtypeString;\n    shape: number[];\n    data: NestedArrayData;\n\n    constructor(data: TypedArray, shape?: number | number[], dtype?: DtypeString)\n    constructor(data: Buffer | ArrayBuffer | NestedArrayData | null, shape: number | number[], dtype: DtypeString)\n    constructor(data: Buffer | ArrayBuffer | NestedArrayData | TypedArray | null, shape?: number | number[], dtype?: DtypeString) {\n        const dataIsTypedArray = data !== null && !!(data as TypedArray).BYTES_PER_ELEMENT;\n\n        if (shape === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n            }\n            shape = [(data as TypedArray).length];\n        }\n\n        if (dtype === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n            }\n            dtype = getTypedArrayDtypeString(data as TypedArray);\n        }\n\n        shape = normalizeShape(shape);\n        this.shape = shape;\n        this.dtype = dtype;\n\n        if (dataIsTypedArray && shape.length !== 1) {\n            data = (data as TypedArray).buffer;\n        }\n\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n        if (this.shape.length === 0) {\n            this.data = new DTYPE_TYPEDARRAY_MAPPING[dtype](1);\n        }\n        else if (\n            // tslint:disable-next-line: strict-type-predicates\n            (IS_NODE && Buffer.isBuffer(data))\n            || data instanceof ArrayBuffer\n            || data === null\n            || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n        ) {\n            // Create from ArrayBuffer or Buffer\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n            if (data === null) {\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n            }\n\n            const numDataElements = (data as ArrayBuffer).byteLength / parseInt(dtype[dtype.length - 1], 10);\n            if (numShapeElements !== numDataElements) {\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n            }\n            const typeConstructor: TypedArrayConstructor<TypedArray> = DTYPE_TYPEDARRAY_MAPPING[dtype];\n            this.data = createNestedArray((data as ArrayBuffer), typeConstructor, shape);\n        } else {\n            this.data = data;\n        }\n    }\n\n    public get(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[]): NestedArray<T>;\n    public get(selection: ArraySelection): NestedArray<T> | number;\n    public get(selection: ArraySelection): NestedArray<T> | number {\n        const [sliceResult, outShape] = sliceNestedArray(this.data, this.shape, selection);\n        if (outShape.length === 0) {\n            return sliceResult as number;\n        } else {\n            return new NestedArray(sliceResult as NestedArrayData, outShape, this.dtype);\n        }\n    }\n\n    public set(selection: ArraySelection = null, value: NestedArray<T> | number) {\n        if (selection === null) {\n            selection = [slice(null)];\n        }\n        if (typeof value === \"number\") {\n            if (this.shape.length === 0) {\n                // Zero dimension array..\n                this.data[0] = value;\n            } else {\n                setNestedArrayToScalar(this.data, value, this.shape, selection);\n            }\n        } else {\n            setNestedArray(this.data, value.data, this.shape, value.shape, selection);\n        }\n    }\n\n    public flatten(): T {\n        if (this.shape.length === 1) {\n            return this.data as T;\n        }\n        return flattenNestedArray(this.data, this.shape, DTYPE_TYPEDARRAY_MAPPING[this.dtype]) as T;\n    }\n\n    /**\n     * Currently only supports a single integer as the size, TODO: support start, stop, step.\n     */\n    public static arange(size: number, dtype: DtypeString = \"<i4\"): NestedArray<TypedArray> {\n        const constr = DTYPE_TYPEDARRAY_MAPPING[dtype];\n        const data = rangeTypedArray([size], constr);\n        return new NestedArray(data, [size], dtype);\n    }\n}\n\n\n\n/**\n * Creates a TypedArray with values 0 through N where N is the product of the shape.\n */\nexport function rangeTypedArray<T extends TypedArray>(shape: number[], tContructor: TypedArrayConstructor<T>) {\n    const size = shape.reduce((x, y) => x * y, 1);\n    const data = new tContructor(size);\n    data.set([...Array(size).keys()]); // Sets range 0,1,2,3,4,5\n    return data;\n}\n\n/**\n * Creates multi-dimensional (rank > 1) array given input data and shape recursively.\n * What it does is create a Array<Array<...<Array<Uint8Array>>> or some other typed array.\n * This is for internal use, there should be no need to call this from user code.\n * @param data a buffer containing the data for this array.\n * @param t constructor for the datatype of choice\n * @param shape list of numbers describing the size in each dimension\n * @param offset in bytes for this dimension\n */\nexport function createNestedArray<T extends TypedArray>(data: Buffer | ArrayBuffer, t: TypedArrayConstructor<T>, shape: number[], offset = 0): NestedArrayData {\n    if (shape.length === 1) {\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\n        // We just slice set the array directly from one level above to save some function calls.\n        return new t(data.slice(offset, offset + shape[0] * t.BYTES_PER_ELEMENT));\n    }\n\n    const arr = new Array<any>(shape[0]);\n    if (shape.length === 2) {\n        for (let i = 0; i < shape[0]; i++) {\n            arr[i] = new t(data.slice(offset + shape[1] * i * t.BYTES_PER_ELEMENT, offset + shape[1] * (i + 1) * t.BYTES_PER_ELEMENT));\n        }\n        return arr;\n    }\n\n    const nextShape = shape.slice(1);\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\n    const mult = nextShape.reduce((x, y) => x * y, 1);\n\n    for (let i = 0; i < shape[0]; i++) {\n        arr[i] = createNestedArray(data, t, nextShape, offset + mult * i * t.BYTES_PER_ELEMENT);\n    }\n    return arr;\n}\n","import { ArraySelection, SliceIndices } from '../core/types';\nimport { normalizeArraySelection, selectionToSliceIndices } from '../core/indexing';\nimport { ValueError } from '../errors';\nimport { TypedArray } from '../nestedArray/types';\n\nexport function setRawArrayToScalar(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, value: number) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedSelection = normalizeArraySelection(dstSelection, dstShape, true);\n    const [sliceIndices] = selectionToSliceIndices(normalizedSelection, dstShape);\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\n    _setRawArrayToScalar(value, dstArr, dstStrides, sliceIndices as SliceIndices[]);\n}\n\nexport function setRawArray(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, sourceArr: TypedArray, sourceStrides: number[], sourceShape: number[]): void {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, false);\n    const [dstSliceIndices, outShape] = selectionToSliceIndices(normalizedDstSelection, dstShape);\n\n    // TODO: replace with non stringify equality check\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\n        throw new ValueError(`Shape mismatch in target and source RawArray: ${outShape} and ${sourceShape}`);\n    }\n\n    _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides);\n}\n\nexport function setRawArrayFromChunkItem(dstArr: TypedArray, dstStrides: number[], dstShape: number[], dstSelection: number | ArraySelection, sourceArr: TypedArray, sourceStrides: number[], sourceShape: number[], sourceSelection: number | ArraySelection) {\n    // This translates \"...\", \":\", null, etc into a list of slices.\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, true);\n    // Above we force the results to be dstSliceIndices only, without integer selections making this cast is safe.\n    const [dstSliceIndices] = selectionToSliceIndices(normalizedDstSelection, dstShape);\n\n    const normalizedSourceSelection = normalizeArraySelection(sourceSelection, sourceShape, false);\n    const [sourceSliceIndicies] = selectionToSliceIndices(normalizedSourceSelection, sourceShape);\n\n    // TODO check to ensure chunk and dest selection are same shape?\n    // As is, this only gets called in ZarrArray.getRaw where this condition should be ensured, and check might hinder performance.\n\n    _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices as SliceIndices[], sourceArr, sourceStrides, sourceSliceIndicies);\n}\n\nfunction _setRawArrayToScalar(value: number, dstArr: TypedArray, dstStrides: number[], dstSliceIndices: SliceIndices[]) {\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n\n    const [from, _to, step, outputSize] = currentDstSlice;\n\n    if (dstStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1) {\n            dstArr.fill(value, from, from + outputSize);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = value;\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        _setRawArrayToScalar(\n            value,\n            dstArr.subarray(currentDstStride * (from + (step * i))),\n            nextDstStrides,\n            nextDstSliceIndices,\n        );\n    }\n}\n\nfunction _setRawArray(dstArr: TypedArray, dstStrides: number[], dstSliceIndices: (number | SliceIndices)[], sourceArr: TypedArray, sourceStrides: number[]) {\n    if (dstSliceIndices.length === 0) {\n        dstArr.set(sourceArr);\n        return;\n    }\n\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n\n    // This dimension is squeezed.\n    if (typeof currentDstSlice === \"number\") {\n        _setRawArray(\n            dstArr.subarray(currentDstSlice * currentDstStride),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr,\n            sourceStrides\n        );\n        return;\n    }\n\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\n    const [from, _to, step, outputSize] = currentDstSlice;\n\n    if (dstStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1 && currentSourceStride === 1) {\n            dstArr.set(sourceArr.subarray(0, outputSize), from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * i];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        // Apply strides as above, using both destination and source-specific strides.\n        _setRawArray(\n            dstArr.subarray(currentDstStride * (from + (i * step))),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr.subarray(currentSourceStride * i),\n            nextSourceStrides\n        );\n    }\n}\n\nfunction _setRawArrayFromChunkItem(dstArr: TypedArray, dstStrides: number[], dstSliceIndices: SliceIndices[], sourceArr: TypedArray, sourceStrides: number[], sourceSliceIndices: (SliceIndices | number)[]) {\n    if (sourceSliceIndices.length === 0) {\n        // Case when last source dimension is squeezed\n        dstArr.set(sourceArr.subarray(0, dstArr.length));\n        return;\n    }\n\n    // Get current indicies and strides for both destination and source arrays\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\n    const [currentSourceSlice, ...nextSourceSliceIndices] = sourceSliceIndices;\n\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\n\n    // This source dimension is squeezed\n    if (typeof currentSourceSlice === \"number\") {\n        /*\n        Sets dimension offset for squeezed dimension.\n\n        Ex. if 0th dimension is squeezed to 2nd index (numpy : arr[2,i])\n\n            sourceArr[stride[0]* 2 + i] --> sourceArr.subarray(stride[0] * 2)[i] (sourceArr[i] in next call)\n\n        Thus, subsequent squeezed dims are appended to the source offset.\n        */\n        _setRawArrayFromChunkItem(\n            // Don't update destination offset/slices, just source\n            dstArr, dstStrides, dstSliceIndices,\n            sourceArr.subarray(currentSourceStride * currentSourceSlice),\n            nextSourceStrides,\n            nextSourceSliceIndices,\n        );\n        return;\n    }\n\n    const [from, _to, step, outputSize] = currentDstSlice; // just need start and size\n    const [sfrom, _sto, sstep, _soutputSize] = currentSourceSlice; // Will always be subset of dst, so don't need output size just start\n\n    if (dstStrides.length === 1 && sourceStrides.length === 1) {\n        if (step === 1 && currentDstStride === 1 && sstep === 1 && currentSourceStride === 1) {\n            dstArr.set(sourceArr.subarray(sfrom, sfrom + outputSize), from);\n        } else {\n            for (let i = 0; i < outputSize; i++) {\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * (sfrom + (sstep * i))];\n            }\n        }\n        return;\n    }\n\n    for (let i = 0; i < outputSize; i++) {\n        // Apply strides as above, using both destination and source-specific strides.\n        _setRawArrayFromChunkItem(\n            dstArr.subarray(currentDstStride * (from + (i * step))),\n            nextDstStrides,\n            nextDstSliceIndices,\n            sourceArr.subarray(currentSourceStride * (sfrom + (i * sstep))),\n            nextSourceStrides,\n            nextSourceSliceIndices,\n        );\n    }\n}\n","import { DtypeString } from '../types';\nimport { ArraySelection } from '../core/types';\nimport { slice } from '../core/slice';\nimport { ValueError } from '../errors';\nimport { normalizeShape, IS_NODE, getStrides } from '../util';\nimport { TypedArray, DTYPE_TYPEDARRAY_MAPPING, getTypedArrayDtypeString, TypedArrayConstructor } from '../nestedArray/types';\nimport { setRawArrayFromChunkItem, setRawArrayToScalar, setRawArray } from './ops';\n\nexport class RawArray {\n    dtype: DtypeString;\n    shape: number[];\n    strides: number[];\n    data: TypedArray;\n\n    constructor(data: TypedArray, shape?: number | number[], dtype?: DtypeString, strides?: number[])\n    constructor(data: Buffer | ArrayBuffer | null, shape?: number | number[], dtype?: DtypeString, strides?: number[])\n    constructor(data: Buffer | ArrayBuffer | TypedArray | null, shape?: number | number[], dtype?: DtypeString, strides?: number[]) {\n        const dataIsTypedArray = data !== null && !!(data as TypedArray).BYTES_PER_ELEMENT;\n\n        if (shape === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\n            }\n            shape = [(data as TypedArray).length];\n        }\n        shape = normalizeShape(shape);\n\n        if (dtype === undefined) {\n            if (!dataIsTypedArray) {\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\n            }\n            dtype = getTypedArrayDtypeString(data as TypedArray);\n        }\n\n        if (strides === undefined) {\n            strides = getStrides(shape);\n        }\n\n        this.shape = shape;\n        this.dtype = dtype;\n        this.strides = strides;\n\n        if (dataIsTypedArray && shape.length !== 1) {\n            data = (data as TypedArray).buffer;\n        }\n\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\n        if (this.shape.length === 0) {\n            this.data = new DTYPE_TYPEDARRAY_MAPPING[dtype](1);\n        } else if (\n            // tslint:disable-next-line: strict-type-predicates\n            (IS_NODE && Buffer.isBuffer(data))\n            || data instanceof ArrayBuffer\n            || data === null\n            || data.toString().startsWith(\"[object ArrayBuffer]\") // Necessary for Node.js for some reason..\n        ) {\n            // Create from ArrayBuffer or Buffer\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\n\n            if (data === null) {\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\n            }\n\n            const numDataElements = (data as ArrayBuffer).byteLength / parseInt(dtype[dtype.length - 1], 10);\n            if (numShapeElements !== numDataElements) {\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\n            }\n            const typeConstructor: TypedArrayConstructor<TypedArray> = DTYPE_TYPEDARRAY_MAPPING[dtype];\n            this.data = new typeConstructor(data as ArrayBuffer);\n        } else {\n            this.data = data;\n        }\n    }\n\n    public set(selection: ArraySelection, value: RawArray | number): void;\n    public set(selection: ArraySelection, chunk: RawArray, chunkSelection: ArraySelection): void;\n    public set(selection: ArraySelection = null, value: RawArray | number, chunkSelection?: ArraySelection) {\n        if (selection === null) {\n            selection = [slice(null)];\n        }\n        if (typeof value === \"number\") {\n            if (this.shape.length === 0) {\n                // Zero dimension array..\n                this.data[0] = value;\n            } else {\n                setRawArrayToScalar(this.data, this.strides, this.shape, selection, value);\n            }\n        } else if (value instanceof RawArray && chunkSelection) {\n            // Copy directly from decoded chunk to destination array\n            setRawArrayFromChunkItem(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape, chunkSelection);\n        } else {\n            setRawArray(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape);\n        }\n    }\n}\n\n\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","'use strict';\nmodule.exports = (promise, onFinally) => {\n\tonFinally = onFinally || (() => {});\n\n\treturn promise.then(\n\t\tval => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => val),\n\t\terr => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => {\n\t\t\tthrow err;\n\t\t})\n\t);\n};\n","'use strict';\n\nconst pFinally = require('p-finally');\n\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t}\n\n\tif (milliseconds === Infinity) {\n\t\tresolve(promise);\n\t\treturn;\n\t}\n\n\tconst timer = setTimeout(() => {\n\t\tif (typeof fallback === 'function') {\n\t\t\ttry {\n\t\t\t\tresolve(fallback());\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\tif (typeof promise.cancel === 'function') {\n\t\t\tpromise.cancel();\n\t\t}\n\n\t\treject(timeoutError);\n\t}, milliseconds);\n\n\t// TODO: Use native `finally` keyword when targeting Node.js 10\n\tpFinally(\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tpromise.then(resolve, reject),\n\t\t() => {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t);\n});\n\nmodule.exports = pTimeout;\n// TODO: Remove this for the next major release\nmodule.exports.default = pTimeout;\n\nmodule.exports.TimeoutError = TimeoutError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = (count / 2) | 0;\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\nexports.default = lowerBound;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lower_bound_1 = require(\"./lower-bound\");\nclass PriorityQueue {\n    constructor() {\n        this._queue = [];\n    }\n    enqueue(run, options) {\n        options = Object.assign({ priority: 0 }, options);\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item && item.run;\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\nexports.default = PriorityQueue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.default.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options\n        // TODO: Remove this `as`.\n        );\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                this.emit('active');\n                this._queue.dequeue()();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n}\nexports.default = PQueue;\n","import { Store, ValidStoreType } from \"../storage/types\";\n\nimport { containsGroup, pathToPrefix } from '../storage/index';\nimport { normalizeStoragePath, isTotalSlice, arrayEquals1D, byteSwap, byteSwapInplace } from '../util';\nimport { ZarrArrayMetadata, UserAttributes, FillType } from '../types';\nimport { ARRAY_META_KEY, ATTRS_META_KEY } from '../names';\nimport { Attributes } from \"../attributes\";\nimport { parseMetadata } from \"../metadata\";\nimport { ArraySelection, DimensionSelection, Indexer, Slice, ChunkProjection } from \"./types\";\nimport { BasicIndexer, isContiguousSelection, normalizeIntegerSelection } from './indexing';\nimport { NestedArray } from \"../nestedArray\";\nimport { RawArray } from \"../rawArray\";\nimport { TypedArray, DTYPE_TYPEDARRAY_MAPPING } from '../nestedArray/types';\nimport { ValueError, PermissionError, BoundsCheckError, ContainsGroupError, isKeyError } from '../errors';\nimport { getCodec } from \"../compression/registry\";\n\n\nimport type { Codec } from 'numcodecs';\nimport PQueue from 'p-queue';\n\nexport interface GetOptions {\n  concurrencyLimit?: number;\n  progressCallback?: (progressUpdate: {\n    progress: number;\n    queueSize: number;\n  }) => void;\n}\n\nexport interface SetOptions {\n  concurrencyLimit?: number;\n  progressCallback?: (progressUpdate: {\n    progress: number;\n    queueSize: number;\n  }) => void;\n}\n\nexport interface GetRawChunkOptions<O> {\n  storeOptions: O;\n}\n\nexport class ZarrArray {\n\n  public store: Store;\n  private compressor: Promise<Codec> | null;\n\n  private _chunkStore: Store | null;\n  /**\n   * A `Store` providing the underlying storage for array chunks.\n   */\n  public get chunkStore(): Store {\n    if (this._chunkStore) {\n      return this._chunkStore;\n    }\n    return this.store;\n  }\n  public path: string;\n  public keyPrefix: string;\n  public readOnly: boolean;\n  public cacheMetadata: boolean;\n  public cacheAttrs: boolean;\n  public meta: ZarrArrayMetadata;\n  public attrs: Attributes<UserAttributes>;\n\n  /**\n   * Array name following h5py convention.\n   */\n  public get name(): string | null {\n    if (this.path.length > 0) {\n      if (this.path[0] !== \"/\") {\n        return \"/\" + this.path;\n      }\n      return this.path;\n    }\n    return null;\n  }\n\n  /**\n   * Final component of name.\n   */\n  public get basename(): string | null {\n    const name = this.name;\n    if (name === null) {\n      return null;\n    }\n    const parts = name.split(\"/\");\n    return parts[parts.length - 1];\n  }\n\n  /**\n   * \"A list of integers describing the length of each dimension of the array.\n   */\n  public get shape(): number[] {\n    // this.refreshMetadata();\n    return this.meta.shape;\n  }\n\n  /**\n   * A list of integers describing the length of each dimension of a chunk of the array.\n   */\n  public get chunks(): number[] {\n    return this.meta.chunks;\n  }\n\n  /**\n   * Integer describing how many element a chunk contains\n   */\n  private get chunkSize(): number {\n    return this.chunks.reduce((x, y) => x * y, 1);\n  }\n\n  /**\n   *  The NumPy data type.\n   */\n  public get dtype() {\n    return this.meta.dtype;\n  }\n\n  /**\n   *  A value used for uninitialized portions of the array.\n   */\n  public get fillValue(): FillType {\n\n    const fillTypeValue = this.meta.fill_value;\n\n    // TODO extract into function\n    if (fillTypeValue === \"NaN\") {\n      return NaN;\n    } else if (fillTypeValue === \"Infinity\") {\n      return Infinity;\n    } else if (fillTypeValue === \"-Infinity\") {\n      return -Infinity;\n    }\n\n    return this.meta.fill_value as FillType;\n  }\n\n  /**\n   *  Number of dimensions.\n   */\n  public get nDims() {\n    return this.meta.shape.length;\n  }\n\n  /**\n   *  The total number of elements in the array.\n   */\n  public get size() {\n    // this.refreshMetadata()\n    return this.meta.shape.reduce((x, y) => x * y, 1);\n  }\n\n  public get length() {\n    return this.shape[0];\n  }\n\n\n  private get _chunkDataShape() {\n    if (this.shape === []) {\n      return [1];\n    } else {\n      const s = [];\n      for (let i = 0; i < this.shape.length; i++) {\n        s[i] = Math.ceil(this.shape[i] / this.chunks[i]);\n      }\n      return s;\n    }\n  }\n  /**\n   * A tuple of integers describing the number of chunks along each\n   * dimension of the array.\n   */\n  public get chunkDataShape() {\n    // this.refreshMetadata();\n    return this._chunkDataShape;\n  }\n\n  /**\n   * Total number of chunks.\n   */\n  public get numChunks() {\n    // this.refreshMetadata();\n    return this.chunkDataShape.reduce((x, y) => x * y, 1);\n  }\n\n  /**\n   * Instantiate an array from an initialized store.\n   * @param store Array store, already initialized.\n   * @param path Storage path.\n   * @param readOnly True if array should be protected against modification.\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\n   */\n  public static async create(store: Store, path: null | string = null, readOnly = false, chunkStore: Store | null = null, cacheMetadata = true, cacheAttrs = true) {\n    const metadata = await this.loadMetadataForConstructor(store, path);\n    return new ZarrArray(store, path, metadata as ZarrArrayMetadata, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n  }\n\n  private static async loadMetadataForConstructor(store: Store, path: null | string) {\n    try {\n      path = normalizeStoragePath(path);\n      const keyPrefix = pathToPrefix(path);\n      const metaStoreValue = await store.getItem(keyPrefix + ARRAY_META_KEY);\n      return parseMetadata(metaStoreValue);\n    } catch (error) {\n      if (await containsGroup(store, path)) {\n        throw new ContainsGroupError(path ?? '');\n      }\n      throw new Error(\"Failed to load metadata for ZarrArray:\" + error.toString());\n    }\n  }\n\n  /**\n   * Instantiate an array from an initialized store.\n   * @param store Array store, already initialized.\n   * @param path Storage path.\n   * @param metadata The initial value for the metadata\n   * @param readOnly True if array should be protected against modification.\n   * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n   * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\n   * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\n   * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\n   * If false, user attributes are reloaded from the store prior to all attribute read operations.\n   */\n  private constructor(store: Store, path: null | string = null, metadata: ZarrArrayMetadata, readOnly = false, chunkStore: Store | null = null, cacheMetadata = true, cacheAttrs = true) {\n    // N.B., expect at this point store is fully initialized with all\n    // configuration metadata fully specified and normalized\n\n    this.store = store;\n    this._chunkStore = chunkStore;\n    this.path = normalizeStoragePath(path);\n    this.keyPrefix = pathToPrefix(this.path);\n    this.readOnly = readOnly;\n    this.cacheMetadata = cacheMetadata;\n    this.cacheAttrs = cacheAttrs;\n    this.meta = metadata;\n    if (this.meta.compressor !== null) {\n      this.compressor = getCodec(this.meta.compressor);\n    } else {\n      this.compressor = null;\n    }\n\n\n    const attrKey = this.keyPrefix + ATTRS_META_KEY;\n    this.attrs = new Attributes<UserAttributes>(this.store, attrKey, this.readOnly, cacheAttrs);\n  }\n\n  /**\n   * (Re)load metadata from store\n   */\n  public async reloadMetadata() {\n    const metaKey = this.keyPrefix + ARRAY_META_KEY;\n    const metaStoreValue = this.store.getItem(metaKey);\n    this.meta = parseMetadata(await metaStoreValue) as ZarrArrayMetadata;\n    return this.meta;\n  }\n\n  private async refreshMetadata() {\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n  }\n\n  public get(selection?: undefined | Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public get(selection?: ArraySelection, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public get(selection: ArraySelection = null, opts: GetOptions = {}): Promise<NestedArray<TypedArray> | number> {\n    return this.getBasicSelection(selection, false, opts);\n  }\n\n  public getRaw(selection?: undefined | Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], opts?: GetOptions): Promise<RawArray | number>;\n  public getRaw(selection?: ArraySelection, opts?: GetOptions): Promise<RawArray | number>;\n  public getRaw(selection: ArraySelection = null, opts: GetOptions = {}): Promise<RawArray | number> {\n    return this.getBasicSelection(selection, true, opts);\n  }\n\n  // asRaw = false\n  public async getBasicSelection(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], asRaw?: false, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  public async getBasicSelection(selection: ArraySelection, asRaw?: false, opts?: GetOptions): Promise<NestedArray<TypedArray> | number>;\n  // asRaw = true\n  public async getBasicSelection(selection: Slice | \":\" | \"...\" | null | (Slice | null | \":\" | \"...\")[], asRaw?: true, opts?: GetOptions): Promise<RawArray | number>;\n  public async getBasicSelection(selection: ArraySelection, asRaw?: true, opts?: GetOptions): Promise<RawArray | number>;\n\n  public async getBasicSelection(selection: ArraySelection, asRaw = false, { concurrencyLimit = 10, progressCallback }: GetOptions = {}): Promise<NestedArray<TypedArray> | RawArray | number> {\n    // Refresh metadata\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n\n    // Check fields (TODO?)\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      return this.getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback);\n    }\n  }\n\n  private getBasicSelectionND(selection: ArraySelection, asRaw: boolean, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void): Promise<number | NestedArray<TypedArray> | RawArray> {\n    const indexer = new BasicIndexer(selection, this);\n    return this.getSelection(indexer, asRaw, concurrencyLimit, progressCallback);\n  }\n\n  private async getSelection(indexer: BasicIndexer, asRaw: boolean, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void): Promise<number | NestedArray<TypedArray> | RawArray> {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be extracted. Each chunk is processed in turn, extracting the\n    // necessary data and storing into the correct location in the output array.\n\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n\n    // check fields are sensible (TODO?)\n\n    const outDtype = this.dtype;\n    const outShape = indexer.shape;\n    const outSize = indexer.shape.reduce((x, y) => x * y, 1);\n\n    if (asRaw && (outSize === this.chunkSize)) {\n      // Optimization: if output strided array _is_ chunk exactly,\n      // decode directly as new TypedArray and return\n      const itr = indexer.iter();\n      const proj = itr.next(); // ensure there is only one projection\n      if (proj.done === false && itr.next().done === true) {\n        const chunkProjection = proj.value as ChunkProjection;\n        const out = await this.decodeDirectToRawArray(chunkProjection, outShape, outSize);\n        return out;\n      }\n    }\n\n    const out = asRaw\n      ? new RawArray(null, outShape, outDtype)\n      : new NestedArray(null, outShape, outDtype);\n\n    if (outSize === 0) {\n      return out;\n    }\n\n    // create promise queue with concurrency control\n    const queue = new PQueue({ concurrency: concurrencyLimit });\n\n    if (progressCallback) {\n\n      let progress = 0;\n      let queueSize = 0;\n      for (const _ of indexer.iter()) queueSize += 1;\n      progressCallback({ progress: 0, queueSize: queueSize });\n      for (const proj of indexer.iter()) {\n        (async () => {\n          await queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n          progress += 1;\n          progressCallback({ progress: progress, queueSize: queueSize });\n        })();\n      }\n\n    } else {\n      for (const proj of indexer.iter()) {\n        queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\n      }\n    }\n\n    // guarantees that all work on queue has finished\n    await queue.onIdle();\n\n    // Return scalar instead of zero-dimensional array.\n    if (out.shape.length === 0) {\n      return out.data[0] as number;\n    }\n\n    return out;\n  }\n\n  /**\n   * Obtain part or whole of a chunk.\n   * @param chunkCoords Indices of the chunk.\n   * @param chunkSelection Location of region within the chunk to extract.\n   * @param out Array to store result in.\n   * @param outSelection Location of region within output array to store results in.\n   * @param dropAxes Axes to squeeze out of the chunk.\n   */\n  private async chunkGetItem<T extends TypedArray>(chunkCoords: number[], chunkSelection: DimensionSelection[], out: NestedArray<T> | RawArray, outSelection: DimensionSelection[], dropAxes: null | number[]) {\n    if (chunkCoords.length !== this._chunkDataShape.length) {\n      throw new ValueError(`Inconsistent shapes: chunkCoordsLength: ${chunkCoords.length}, cDataShapeLength: ${this.chunkDataShape.length}`);\n    }\n\n    const cKey = this.chunkKey(chunkCoords);\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      const decodedChunk = await this.decodeChunk(cdata);\n\n      if (out instanceof NestedArray) {\n\n        if (isContiguousSelection(outSelection) && isTotalSlice(chunkSelection, this.chunks) && !this.meta.filters) {\n          // Optimization: we want the whole chunk, and the destination is\n          // contiguous, so we can decompress directly from the chunk\n          // into the destination array\n\n          // TODO check order\n          // TODO filters..\n          out.set(outSelection, this.toNestedArray<T>(decodedChunk));\n          return;\n        }\n\n        // Decode chunk\n        const chunk = this.toNestedArray(decodedChunk);\n        const tmp = chunk.get(chunkSelection);\n\n        if (dropAxes !== null) {\n          throw new Error(\"Drop axes is not supported yet\");\n        }\n\n        out.set(outSelection, tmp as NestedArray<T>);\n\n      } else {\n        /* RawArray\n        Copies chunk by index directly into output. Doesn't matter if selection is contiguous\n        since store/output are different shapes/strides.\n        */\n        out.set(outSelection, this.chunkBufferToRawArray(decodedChunk), chunkSelection);\n      }\n\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if cKey doesn't exist in store\n        if (this.fillValue !== null) {\n          out.set(outSelection, this.fillValue);\n        }\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  public async getRawChunk<O>(chunkCoords: number[], opts?: GetRawChunkOptions<O>): Promise<RawArray> {\n    if (chunkCoords.length !== this.shape.length) {\n      throw new Error(`Chunk coordinates ${chunkCoords.join(\".\")} do not correspond to shape ${this.shape}.`);\n    }\n    try {\n      for (let i = 0; i < chunkCoords.length; i++) {\n        const dimLength = Math.ceil(this.shape[i] / this.chunks[i]);\n        chunkCoords[i] = normalizeIntegerSelection(chunkCoords[i], dimLength);\n      }\n    } catch (error) {\n      if (error instanceof BoundsCheckError) {\n        throw new BoundsCheckError(`index ${chunkCoords.join(\".\")} is out of bounds for shape: ${this.shape} and chunks ${this.chunks}`);\n      } else {\n        throw error;\n      }\n    }\n    const cKey = this.chunkKey(chunkCoords);\n    const cdata = this.chunkStore.getItem(cKey, opts?.storeOptions);\n    const buffer = await this.decodeChunk(await cdata);\n    const outShape = this.chunks.filter(d => d !== 1); // squeeze chunk dim if 1\n    return new RawArray(buffer, outShape, this.dtype);\n  }\n\n  private chunkKey(chunkCoords: number[]) {\n    return this.keyPrefix + chunkCoords.join(\".\");\n  }\n\n  private ensureByteArray(chunkData: ValidStoreType): Uint8Array {\n    if (typeof chunkData === \"string\") {\n      return new Uint8Array(Buffer.from(chunkData).buffer);\n    }\n    return new Uint8Array(chunkData);\n  }\n\n  private toTypedArray(buffer: Buffer | ArrayBuffer) {\n    return new DTYPE_TYPEDARRAY_MAPPING[this.dtype](buffer);\n  }\n\n  private toNestedArray<T extends TypedArray>(data: ValidStoreType) {\n    const buffer = this.ensureByteArray(data).buffer;\n\n    return new NestedArray<T>(buffer, this.chunks, this.dtype);\n  }\n\n  private async decodeChunk(chunkData: ValidStoreType) {\n    let bytes = this.ensureByteArray(chunkData);\n\n    if (this.compressor !== null) {\n      bytes = await (await this.compressor).decode(bytes);\n    }\n\n    if (this.dtype.includes('>')) {\n      // Need to flip bytes for Javascript TypedArrays\n      // We flip bytes in-place to avoid creating an extra copy of the decoded buffer.\n      byteSwapInplace(this.toTypedArray(bytes.buffer));\n    }\n\n    // TODO filtering etc\n    return bytes.buffer;\n  }\n\n  private chunkBufferToRawArray(buffer: Buffer | ArrayBuffer) {\n    return new RawArray(buffer, this.chunks, this.dtype);\n  }\n\n  private async decodeDirectToRawArray({ chunkCoords }: ChunkProjection, outShape: number[], outSize: number): Promise<RawArray> {\n    const cKey = this.chunkKey(chunkCoords);\n    try {\n      const cdata = await this.chunkStore.getItem(cKey);\n      return new RawArray(await this.decodeChunk(cdata), outShape, this.dtype);\n    } catch (error) {\n      if (isKeyError(error)) {\n        // fill with scalar if item doesn't exist\n        const data = new DTYPE_TYPEDARRAY_MAPPING[this.dtype](outSize);\n        return new RawArray(data.fill(this.fillValue as number), outShape);\n      } else {\n        // Different type of error - rethrow\n        throw error;\n      }\n    }\n  }\n\n  public async set(selection: ArraySelection = null, value: any, opts: SetOptions = {}) {\n    await this.setBasicSelection(selection, value, opts);\n  }\n\n  public async setBasicSelection(selection: ArraySelection, value: any, { concurrencyLimit = 10, progressCallback }: SetOptions = {}) {\n    if (this.readOnly) {\n      throw new PermissionError(\"Object is read only\");\n    }\n\n    if (!this.cacheMetadata) {\n      await this.reloadMetadata();\n    }\n\n    if (this.shape === []) {\n      throw new Error(\"Shape [] indexing is not supported yet\");\n    } else {\n      await this.setBasicSelectionND(selection, value, concurrencyLimit, progressCallback);\n    }\n  }\n\n  private async setBasicSelectionND(selection: ArraySelection, value: any, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void) {\n    const indexer = new BasicIndexer(selection, this);\n    await this.setSelection(indexer, value, concurrencyLimit, progressCallback);\n  }\n\n  private getChunkValue(proj: ChunkProjection, indexer: Indexer, value: number | NestedArray<TypedArray>, selectionShape: number[]): number | NestedArray<TypedArray> {\n    let chunkValue: number | NestedArray<TypedArray>;\n    if (selectionShape === []) {\n      chunkValue = value;\n    } else if (typeof value === \"number\") {\n      chunkValue = value;\n    } else {\n      chunkValue = value.get(proj.outSelection);\n      // tslint:disable-next-line: strict-type-predicates\n      if (indexer.dropAxes !== null) {\n        throw new Error(\"Handling drop axes not supported yet\");\n      }\n    }\n    return chunkValue;\n  }\n\n  private async setSelection(indexer: Indexer, value: number | NestedArray<TypedArray>, concurrencyLimit: number, progressCallback?: (progressUpdate: { progress: number; queueSize: number }) => void) {\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be replaced. Each chunk is processed in turn, extracting the\n    // necessary data from the value array and storing into the chunk array.\n\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n\n    // TODO? check fields are sensible\n\n    // Determine indices of chunks overlapping the selection\n    const selectionShape = indexer.shape;\n\n    // Check value shape\n    if (selectionShape === []) {\n      // Setting a single value\n    } else if (typeof value === \"number\") {\n      // Setting a scalar value\n    } else if (value instanceof NestedArray) {\n      // TODO: non stringify equality check\n      if (!arrayEquals1D(value.shape, selectionShape)) {\n        throw new ValueError(`Shape mismatch in source NestedArray and set selection: ${value.shape} and ${selectionShape}`);\n      }\n    } else {\n      // TODO support TypedArrays, buffers, etc\n      throw new Error(\"Unknown data type for setting :(\");\n    }\n\n    const queue = new PQueue({ concurrency: concurrencyLimit });\n\n    if (progressCallback) {\n\n      let queueSize = 0;\n      for (const _ of indexer.iter()) queueSize += 1;\n\n      let progress = 0;\n      progressCallback({ progress: 0, queueSize: queueSize });\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n        (async () => {\n          await queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n          progress += 1;\n          progressCallback({ progress: progress, queueSize: queueSize });\n        })();\n      }\n\n    } else {\n\n      for (const proj of indexer.iter()) {\n        const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\n        queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\n      }\n\n    }\n\n    // guarantees that all work on queue has finished\n    await queue.onIdle();\n  }\n\n  private async chunkSetItem<T extends TypedArray>(chunkCoords: number[], chunkSelection: DimensionSelection[], value: number | NestedArray<TypedArray>) {\n    // Obtain key for chunk storage\n    const chunkKey = this.chunkKey(chunkCoords);\n\n    let chunk: null | TypedArray = null;\n\n    const dtypeConstr = DTYPE_TYPEDARRAY_MAPPING[this.dtype];\n    const chunkSize = this.chunkSize;\n\n    if (isTotalSlice(chunkSelection, this.chunks)) {\n      // Totally replace chunk\n\n      // Optimization: we are completely replacing the chunk, so no need\n      // to access the existing chunk data\n\n      if (typeof value === \"number\") {\n        // TODO get the right type here\n        chunk = new dtypeConstr(chunkSize);\n        chunk.fill(value);\n      } else {\n        chunk = value.flatten();\n      }\n    } else {\n\n      // partially replace the contents of this chunk\n\n      // Existing chunk data\n      let chunkData: TypedArray;\n\n      try {\n        // Chunk is initialized if this does not error\n        const chunkStoreData = await this.chunkStore.getItem(chunkKey);\n        const dBytes = await this.decodeChunk(chunkStoreData);\n        chunkData = this.toTypedArray(dBytes);\n      } catch (error) {\n        if (isKeyError(error)) {\n          // Chunk is not initialized\n          chunkData = new dtypeConstr(chunkSize);\n          if (this.fillValue !== null) {\n            chunkData.fill(this.fillValue);\n          }\n        } else {\n          // Different type of error - rethrow\n          throw error;\n        }\n      }\n\n      const chunkNestedArray = new NestedArray(\n        chunkData,\n        this.chunks,\n        this.dtype,\n      );\n      chunkNestedArray.set(chunkSelection, value);\n      chunk = chunkNestedArray.flatten();\n    }\n    const chunkData = await this.encodeChunk(chunk);\n    this.chunkStore.setItem(chunkKey, chunkData);\n  }\n\n  private async encodeChunk(chunk: TypedArray) {\n    if (this.dtype.includes('>')) {\n      /*\n       * If big endian, flip bytes before applying compression and setting store.\n       *\n       * Here we create a copy (not in-place byteswapping) to avoid flipping the\n       * bytes in the buffers of user-created Raw- and NestedArrays.\n      */\n      chunk = byteSwap(chunk);\n    }\n\n    if (this.compressor !== null) {\n      const bytes = new Uint8Array(chunk.buffer);\n      const cbytes = await (await this.compressor).encode(bytes);\n      return cbytes.buffer;\n    }\n\n    // TODO: filters, etc\n    return chunk.buffer;\n  }\n}","import { SyncStore, ValidStoreType } from \"./types\";\nimport { createProxy, MutableMappingProxy } from \"../mutableMapping\";\nimport { KeyError } from \"../errors\";\n\nexport class MemoryStore<T extends ValidStoreType> implements SyncStore<T> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    root: { [key: string]: any };\n\n    constructor(root = {}) {\n        this.root = root;\n    }\n\n    public proxy(): MutableMappingProxy<T> {\n        return createProxy(this);\n    }\n\n    private getParent(item: string): [any, string] {\n        let parent = this.root;\n        const segments = item.split('/');\n        // find the parent container\n        for (const k of segments.slice(0, segments.length - 1)) {\n            parent = parent[k];\n            if (!parent) {\n                throw Error(item);\n            }\n            // if not isinstance(parent, self.cls):\n            //     raise KeyError(item)\n        }\n        return [parent, segments[segments.length - 1]];\n    }\n\n    private requireParent(item: string): [any, string] {\n        let parent = this.root;\n        const segments = item.split('/');\n\n        // require the parent container\n        for (const k of segments.slice(0, segments.length - 1)) {\n            // TODO: verify correct implementation\n            if (parent[k] === undefined) {\n                parent[k] = {};\n            }\n            parent = parent[k];\n        }\n\n        return [parent, segments[segments.length - 1]];\n    }\n\n    getItem(item: string) {\n        const [parent, key] = this.getParent(item);\n        const value = parent[key];\n        if (value === undefined) {\n            throw new KeyError(item);\n        }\n        return value;\n    }\n\n    setItem(item: string, value: any): boolean {\n        const [parent, key] = this.requireParent(item);\n        parent[key] = value;\n        return true;\n    }\n\n    deleteItem(item: string): boolean {\n        const [parent, key] = this.getParent(item);\n        return delete parent[key];\n    }\n\n    containsItem(item: string): boolean {\n        // TODO: more sane implementation\n        try {\n            return this.getItem(item) !== undefined;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    keys(): string[] {\n        throw new Error(\"Method not implemented.\");\n    }\n\n\n}","import { ValidStoreType, AsyncStore } from './types';\nimport { IS_NODE, joinUrlParts } from '../util';\nimport { KeyError, HTTPError } from '../errors';\n\nenum HTTPMethod {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  PUT = 'PUT',\n}\n\nconst DEFAULT_METHODS = [HTTPMethod.HEAD, HTTPMethod.GET, HTTPMethod.PUT];\n\ninterface HTTPStoreOptions {\n    fetchOptions?: RequestInit;\n    supportedMethods?: HTTPMethod[];\n}\n\nexport class HTTPStore implements AsyncStore<ArrayBuffer> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    public url: string;\n    public fetchOptions: RequestInit;\n    private supportedMethods: Set<HTTPMethod>;\n\n    constructor(url: string, options: HTTPStoreOptions = {}) {\n        this.url = url;\n        const { fetchOptions = {}, supportedMethods = DEFAULT_METHODS } = options;\n        this.fetchOptions = fetchOptions;\n        this.supportedMethods = new Set(supportedMethods);\n    }\n\n    keys(): Promise<string[]> {\n        throw new Error('Method not implemented.');\n    }\n\n    async getItem(item: string, opts?: RequestInit) {\n        const url = joinUrlParts(this.url, item);\n        const value = await fetch(url, { ...this.fetchOptions, ...opts });\n\n        if (value.status === 404) {\n            // Item is not found\n            throw new KeyError(item);\n        } else if (value.status !== 200) {\n            throw new HTTPError(String(value.status));\n        }\n\n        // only decode if 200\n        if (IS_NODE) {\n            return Buffer.from(await value.arrayBuffer());\n        } else {\n            return value.arrayBuffer(); // Browser\n        }\n    }\n\n    async setItem(item: string, value: ValidStoreType): Promise<boolean> {\n        if (!this.supportedMethods.has(HTTPMethod.PUT)) {\n          throw new Error('HTTP PUT no a supported method for store.');\n        }\n        const url = joinUrlParts(this.url, item);\n        if (typeof value === 'string') {\n            value = new TextEncoder().encode(value).buffer;\n        }\n        const set = await fetch(url, { ...this.fetchOptions, method: HTTPMethod.PUT, body: value });\n        return set.status.toString()[0] === '2';\n    }\n\n    deleteItem(_item: string): Promise<boolean> {\n        throw new Error('Method not implemented.');\n    }\n\n    async containsItem(item: string): Promise<boolean> {\n        const url = joinUrlParts(this.url, item);\n        // Just check headers if HEAD method supported\n        const method = this.supportedMethods.has(HTTPMethod.HEAD) ? HTTPMethod.HEAD : HTTPMethod.GET;\n        const value = await fetch(url, { ...this.fetchOptions, method });\n        return value.status === 200;\n    }\n}\n","import { ChunksArgument, DtypeString, CompressorConfig, Order, Filter, FillType, PersistenceMode } from './types';\nimport { Store } from './storage/types';\nimport { ZarrArray } from './core/index';\nimport { MemoryStore } from './storage/memoryStore';\nimport { initArray, containsArray, containsGroup } from './storage/index';\nimport { TypedArray } from './nestedArray/types';\nimport { NestedArray } from './nestedArray/index';\nimport { normalizeStoragePath } from './util';\nimport { ContainsArrayError, ValueError, ArrayNotFoundError, ContainsGroupError } from './errors';\nimport { HTTPStore } from './storage/httpStore';\n\n/**\n * See `create` function for type signature of these values\n */\nexport interface CreateArrayOptionsWithoutShape {\n    chunks?: ChunksArgument;\n    dtype?: DtypeString;\n    compressor?: CompressorConfig | null;\n    fillValue?: FillType;\n    order?: Order;\n    store?: Store;\n    overwrite?: boolean;\n    path?: string;\n    chunkStore?: Store;\n    filters?: Filter[];\n    cacheMetadata?: boolean;\n    cacheAttrs?: boolean;\n    readOnly?: boolean;\n}\n\nexport type CreateArrayOptions = {\n    shape: number | number[];\n    chunks?: ChunksArgument;\n    dtype?: DtypeString;\n    compressor?: CompressorConfig | null;\n    fillValue?: FillType;\n    order?: Order;\n    store?: Store;\n    overwrite?: boolean;\n    path?: string;\n    chunkStore?: Store;\n    filters?: Filter[];\n    cacheMetadata?: boolean;\n    cacheAttrs?: boolean;\n    readOnly?: boolean;\n};\n\n/**\n * \n * @param shape Array shape.\n * @param chunks  Chunk shape. If `true`, will be guessed from `shape` and `dtype`. If\n *      `false`, will be set to `shape`, i.e., single chunk for the whole array.\n *      If an int, the chunk size in each dimension will be given by the value\n *      of `chunks`. Default is `true`.\n * @param dtype NumPy dtype.\n * @param compressor Primary compressor.\n * @param fillValue Default value to use for uninitialized portions of the array.\n * @param order Memory layout to be used within each chunk.\n * @param store Store or path to directory in file system or name of zip file.\n * @param overwrite  If True, delete all pre-existing data in `store` at `path` before creating the array.\n * @param path Path under which array is stored.\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n * @param filters Sequence of filters to use to encode chunk data prior to compression.\n * @param cacheMetadata If `true` (default), array configuration metadata will be cached for the\n *      lifetime of the object. If `false`, array metadata will be reloaded\n *      prior to all data access and modification operations (may incur\n *      overhead depending on storage and data access pattern).\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read\n *      operations. If `false`, user attributes are reloaded from the store prior\n *      to all attribute read operations.\n * @param readOnly `true` if array should be protected against modification, defaults to `false`.\n */\nexport async function create(\n    { shape, chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path, chunkStore, filters, cacheMetadata = true, cacheAttrs = true, readOnly = false }: CreateArrayOptions,\n): Promise<ZarrArray> {\n\n    store = normalizeStoreArgument(store);\n\n    await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n    const z = await ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n\n    return z;\n}\n\n\n/**\n * Create an empty array.\n */\nexport async function empty(shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = null;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with zero being used as the default value for\n * uninitialized portions of the array.\n */\nexport async function zeros(shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = 0;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with one being used as the default value for\n * uninitialized portions of the array.\n */\nexport async function ones(shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = 1;\n    return create({ shape, ...opts });\n}\n\n/**\n * Create an array, with `fill_value` being used as the default value for\n * uninitialized portions of the array\n */\nexport async function full(shape: number | number[], fillValue: FillType, opts: CreateArrayOptionsWithoutShape = {}) {\n    opts.fillValue = fillValue;\n    return create({ shape, ...opts });\n}\n\nexport async function array(data: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts: CreateArrayOptionsWithoutShape = {}) {\n    // TODO: infer chunks?\n\n    let shape = null;\n    if (data instanceof NestedArray) {\n        shape = data.shape;\n        opts.dtype = opts.dtype === undefined ? data.dtype : opts.dtype;\n    } else {\n        shape = data.byteLength;\n        // TODO: infer datatype\n    }\n    // TODO: support TypedArray\n\n    const wasReadOnly = opts.readOnly === undefined ? false : opts.readOnly;\n    opts.readOnly = false;\n\n    const z = await create({ shape, ...opts });\n    await z.set(null, data);\n    z.readOnly = wasReadOnly;\n\n    return z;\n}\n\nexport async function openArray(\n    { shape, mode = \"a\", chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path = null, chunkStore, filters, cacheMetadata = true, cacheAttrs = true }: { shape?: number | number[]; mode?: PersistenceMode; chunks?: ChunksArgument; dtype?: DtypeString; compressor?: CompressorConfig | null; fillValue?: FillType; order?: Order; store?: Store; overwrite?: boolean; path?: string | null; chunkStore?: Store; filters?: Filter[]; cacheMetadata?: boolean; cacheAttrs?: boolean } = {},\n) {\n    store = normalizeStoreArgument(store);\n    if (chunkStore === undefined) {\n        chunkStore = normalizeStoreArgument(store);\n    }\n    path = normalizeStoragePath(path);\n\n    if (mode === \"r\" || mode === \"r+\") {\n        if (!await containsArray(store, path)) {\n            if (await containsGroup(store, path)) {\n                throw new ContainsGroupError(path);\n            }\n            throw new ArrayNotFoundError(path);\n        }\n    } else if (mode === \"w\") {\n\n        if (shape === undefined) {\n            throw new ValueError(\"Shape can not be undefined when creating a new array\");\n        }\n        await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n\n    } else if (mode === \"a\") {\n        if (!await containsArray(store, path)) {\n            if (await containsGroup(store, path)) {\n                throw new ContainsGroupError(path);\n            }\n            if (shape === undefined) {\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\n            }\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n        }\n    } else if (mode === \"w-\" || (mode as any) === \"x\") {\n        if (await containsArray(store, path)) {\n            throw new ContainsArrayError(path);\n        } else if (await containsGroup(store, path)) {\n            throw new ContainsGroupError(path);\n        } else {\n            if (shape === undefined) {\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\n            }\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);\n        }\n    } else {\n        throw new ValueError(`Invalid mode argument: ${mode}`);\n    }\n\n    const readOnly = mode === \"r\";\n    return ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\n}\n\n\nexport function normalizeStoreArgument(store?: Store | string): Store {\n    if (store === undefined) {\n        return new MemoryStore();\n    } else if (typeof store === \"string\") {\n        return new HTTPStore(store);\n    }\n    return store;\n}","import { createProxy, AsyncMutableMapping, AsyncMutableMappingProxy } from './mutableMapping';\nimport { Store, } from './storage/types';\nimport { normalizeStoragePath } from './util';\nimport { containsArray, pathToPrefix, containsGroup, initGroup } from './storage/index';\nimport { ContainsArrayError, GroupNotFoundError, PermissionError, KeyError, ValueError, ContainsGroupError } from './errors';\nimport { ZarrGroupMetadata, UserAttributes, PersistenceMode } from './types';\nimport { GROUP_META_KEY, ATTRS_META_KEY } from './names';\nimport { parseMetadata } from './metadata';\nimport { Attributes } from './attributes';\nimport { array, empty, zeros, ones, full, create, normalizeStoreArgument, CreateArrayOptionsWithoutShape } from './creation';\nimport { NestedArray } from './nestedArray';\nimport { TypedArray } from './nestedArray/types';\nimport { ZarrArray } from './core';\n\n\nexport class Group implements AsyncMutableMapping<Group | ZarrArray> {\n    /**\n     * A `Store` providing the underlying storage for the group.\n     */\n    public store: Store;\n\n    /**\n     * Storage path.\n     */\n    public path: string;\n\n    /**\n     * Group name following h5py convention.\n     */\n    public get name(): string {\n        if (this.path.length > 0) {\n            if (this.path[0] !== \"/\") {\n                return \"/\" + this.path;\n            }\n            return this.path;\n        }\n        return \"/\";\n    }\n\n    /**\n     * Final component of name.\n     */\n    public get basename(): string {\n        const parts = this.name.split(\"/\");\n        return parts[parts.length - 1];\n    }\n\n    /**\n     * An object containing user-defined attributes. Note that\n     * attribute values are stored as a JSON string in a store.\n     */\n    public attrs: Attributes<UserAttributes>;\n\n\n    private _chunkStore: Store | null;\n    /**\n     * A `Store` providing the underlying storage for array chunks.\n     */\n    public get chunkStore(): Store {\n        if (this._chunkStore) {\n            return this._chunkStore;\n        }\n        return this.store;\n    }\n\n    private keyPrefix: string;\n    public readOnly: boolean;\n    private meta: ZarrGroupMetadata;\n\n    public static async create(store: Store, path: string | null = null, readOnly = false, chunkStore: Store | null = null, cacheAttrs = true) {\n        const metadata = await this.loadMetadataForConstructor(store, path);\n        return new Group(store, path, metadata as ZarrGroupMetadata, readOnly, chunkStore, cacheAttrs);\n    }\n\n    private static async loadMetadataForConstructor(store: Store, path: null | string) {\n        path = normalizeStoragePath(path);\n        const keyPrefix = pathToPrefix(path);\n        try {\n            const metaStoreValue = await store.getItem(keyPrefix + GROUP_META_KEY);\n            return parseMetadata(metaStoreValue);\n        } catch (error) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            throw new GroupNotFoundError(path);\n        }\n    }\n\n    private constructor(store: Store, path: string | null = null, metadata: ZarrGroupMetadata, readOnly = false, chunkStore: Store | null = null, cacheAttrs = true) {\n        this.store = store;\n        this._chunkStore = chunkStore;\n        this.path = normalizeStoragePath(path);\n        this.keyPrefix = pathToPrefix(this.path);\n        this.readOnly = readOnly;\n        this.meta = metadata;\n\n        // Initialize attributes\n        const attrKey = this.keyPrefix + ATTRS_META_KEY;\n        this.attrs = new Attributes<UserAttributes>(this.store, attrKey, this.readOnly, cacheAttrs);\n    }\n\n    private itemPath(item: string | null) {\n        const absolute = typeof item === \"string\" && item.length > 0 && item[0] === '/';\n        const path = normalizeStoragePath(item);\n        // Absolute path\n        if (!absolute && this.path.length > 0) {\n            return this.keyPrefix + path;\n        }\n        return path;\n    }\n\n    /**\n     * Create a sub-group.\n     */\n    public async createGroup(name: string, overwrite = false) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        const path = this.itemPath(name);\n        await initGroup(this.store, path, this._chunkStore, overwrite);\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n    }\n\n    /**\n     * Obtain a sub-group, creating one if it doesn't exist.\n     */\n    public async requireGroup(name: string, overwrite = false) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        const path = this.itemPath(name);\n        if (!await containsGroup(this.store, path)) {\n            await initGroup(this.store, path, this._chunkStore, overwrite);\n        }\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n    }\n\n    private getOptsForArrayCreation(name: string, opts: CreateArrayOptionsWithoutShape = {}) {\n        const path = this.itemPath(name);\n        opts.path = path;\n\n        if (opts.cacheAttrs === undefined) {\n            opts.cacheAttrs = this.attrs.cache;\n        }\n        opts.store = this.store;\n        opts.chunkStore = this.chunkStore;\n        return opts;\n    }\n\n    /**\n     * Creates an array\n     */\n    public array(name: string, data: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts?: CreateArrayOptionsWithoutShape, overwrite?: boolean) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n        opts.overwrite = overwrite === undefined ? opts.overwrite : overwrite;\n\n        return array(data, opts);\n    }\n\n    public empty(name: string, shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return empty(shape, opts);\n    }\n\n    public zeros(name: string, shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return zeros(shape, opts);\n    }\n\n    public ones(name: string, shape: number | number[], opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return ones(shape, opts);\n    }\n\n    public full(name: string, shape: number | number[], fillValue: number | null, opts: CreateArrayOptionsWithoutShape = {}) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        return full(shape, fillValue, opts);\n    }\n\n    public createDataset(name: string, shape?: number | number[], data?: Buffer | ArrayBuffer | NestedArray<TypedArray>, opts?: CreateArrayOptionsWithoutShape) {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        opts = this.getOptsForArrayCreation(name, opts);\n\n        let z: Promise<ZarrArray>;\n        if (data === undefined) {\n            if (shape === undefined) {\n                throw new ValueError(\"Shape must be set if no data is passed to CreateDataset\");\n            }\n            z = create({ shape, ...opts });\n        } else {\n            z = array(data, opts);\n        }\n        return z;\n    }\n\n    async getItem(item: string) {\n        const path = this.itemPath(item);\n        if (await containsArray(this.store, path)) {\n            return ZarrArray.create(this.store, path, this.readOnly, this.chunkStore, undefined, this.attrs.cache);\n        } else if (await containsGroup(this.store, path)) {\n            return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\n        }\n        throw new KeyError(item);\n    }\n\n    async setItem(item: string, value: any) {\n        await this.array(item, value, {}, true);\n        return true;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async deleteItem(_item: string): Promise<boolean> {\n        if (this.readOnly) {\n            throw new PermissionError(\"group is read only\");\n        }\n        throw new Error(\"Method not implemented.\");\n    }\n\n    async containsItem(item: string) {\n        const path = this.itemPath(item);\n        return await containsArray(this.store, path) || containsGroup(this.store, path);\n    }\n\n    proxy(): AsyncMutableMappingProxy<Group> {\n        return createProxy(this);\n    }\n}\n\n/**\n * Create a group.\n * @param store Store or path to directory in file system.\n * @param path Group path within store.\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\n * @param overwrite If `true`, delete any pre-existing data in `store` at `path` before creating the group.\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations.\n *   If `false`, user attributes are reloaded from the store prior to all attribute read operations.\n */\nexport async function group(store?: Store | string, path: string | null = null, chunkStore?: Store, overwrite = false, cacheAttrs = true) {\n    store = normalizeStoreArgument(store);\n    path = normalizeStoragePath(path);\n\n    if (overwrite || await containsGroup(store)) {\n        await initGroup(store, path, chunkStore, overwrite);\n    }\n\n    return Group.create(store, path, false, chunkStore, cacheAttrs);\n}\n\n/**\n * Open a group using file-mode-like semantics.\n * @param store Store or path to directory in file system or name of zip file.\n * @param path Group path within store.\n * @param mode Persistence mode, see `PersistenceMode` type.\n * @param chunkStore Store or path to directory in file system or name of zip file.\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations\n *   If False, user attributes are reloaded from the store prior to all attribute read operations.\n *\n */\nexport async function openGroup(store?: Store | string, path: string | null = null, mode: PersistenceMode = \"a\", chunkStore?: Store, cacheAttrs = true) {\n    store = normalizeStoreArgument(store);\n    if (chunkStore !== undefined) {\n        chunkStore = normalizeStoreArgument(store);\n    }\n    path = normalizeStoragePath(path);\n\n    if (mode === \"r\" || mode === \"r+\") {\n        if (!await containsGroup(store, path)) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            throw new GroupNotFoundError(path);\n        }\n    } else if (mode === \"w\") {\n        await initGroup(store, path, chunkStore, true);\n    } else if (mode === \"a\") {\n        if (!await containsGroup(store, path)) {\n            if (await containsArray(store, path)) {\n                throw new ContainsArrayError(path);\n            }\n            await initGroup(store, path, chunkStore);\n        }\n    } else if (mode === \"w-\" || (mode as any) === \"x\") {\n        if (await containsArray(store, path)) {\n            throw new ContainsArrayError(path);\n        } else if (await containsGroup(store, path)) {\n            throw new ContainsGroupError(path);\n        } else {\n            await initGroup(store, path, chunkStore);\n        }\n    } else {\n        throw new ValueError(`Invalid mode argument: ${mode}`);\n    }\n\n    const readOnly = mode === \"r\";\n    return Group.create(store, path, readOnly, chunkStore, cacheAttrs);\n}\n","import { SyncStore, ValidStoreType } from \"./types\";\nimport { createProxy, MutableMappingProxy } from \"../mutableMapping\";\nimport { KeyError } from \"../errors\";\n\nexport class ObjectStore<T extends ValidStoreType> implements SyncStore<T> {\n    listDir?: undefined;\n    rmDir?: undefined;\n    getSize?: undefined;\n    rename?: undefined;\n\n    public object: {\n        [key: string]: T;\n    };\n\n    constructor() {\n        this.object = {};\n    }\n\n    getItem(item: string): T {\n        if (!Object.prototype.hasOwnProperty.call(this.object, item)) {\n            throw new KeyError(item);\n        }\n        return this.object[item];\n    }\n    setItem(item: string, value: T): boolean {\n        this.object[item] = value;\n        return true;\n    }\n    deleteItem(item: string): boolean {\n        return delete this.object[item];\n    }\n    containsItem(item: string): boolean {\n        return Object.prototype.hasOwnProperty.call(this.object, item);\n    }\n    proxy(): MutableMappingProxy<T> {\n        return createProxy(this);\n    }\n    keys(): string[] {\n        return Object.getOwnPropertyNames(this.object);\n    }\n}"],"names":["lower_bound_1","p_timeout_1","EventEmitter","priority_queue_1"],"mappings":"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"}